これは coreutils-ja.info、coreutils-ja.texi より makeinfo
バージョン 4.8 によって作成されました。

INFO-DIR-SECTION Basics
START-INFO-DIR-ENTRY
* Coreutils(ja): (coreutils-ja).       Core GNU (file, text, shell) utilities.
* Common options(ja): (coreutils-ja)Common options.      Common options.
* File permissions(ja): (coreutils-ja)File permissions.  Access modes.
* Date input formats(ja): (coreutils-ja)Date input formats.
END-INFO-DIR-ENTRY

INFO-DIR-SECTION Individual utilities
START-INFO-DIR-ENTRY
* basename(ja): (coreutils-ja)basename invocation.   Strip directory and suffix.
* cat(ja): (coreutils-ja)cat invocation.             Concatenate and write files.
* chgrp(ja): (coreutils-ja)chgrp invocation.         Change file groups.
* chmod(ja): (coreutils-ja)chmod invocation.         Change file permissions.
* chown(ja): (coreutils-ja)chown invocation.         Change file owners/groups.
* chroot(ja): (coreutils-ja)chroot invocation.       Specify the root directory.
* cksum(ja): (coreutils-ja)cksum invocation.         Print POSIX CRC checksum.
* comm(ja): (coreutils-ja)comm invocation.           Compare sorted files by line.
* cp(ja): (coreutils-ja)cp invocation.               Copy files.
* csplit(ja): (coreutils-ja)csplit invocation.       Split by context.
* cut(ja): (coreutils-ja)cut invocation.             Print selected parts of lines.
* date(ja): (coreutils-ja)date invocation.           Print/set system date and time.
* dd(ja): (coreutils-ja)dd invocation.               Copy and convert a file.
* df(ja): (coreutils-ja)df invocation.               Report filesystem disk usage.
* dir(ja): (coreutils-ja)dir invocation.             List directories briefly.
* dircolors(ja): (coreutils-ja)dircolors invocation. Color setup for ls.
* dirname(ja): (coreutils-ja)dirname invocation.       Strip non-directory suffix.
* du(ja): (coreutils-ja)du invocation.               Report on disk usage.
* echo(ja): (coreutils-ja)echo invocation.           Print a line of text.
* env(ja): (coreutils-ja)env invocation.             Modify the environment.
* expand(ja): (coreutils-ja)expand invocation.       Convert tabs to spaces.
* expr(ja): (coreutils-ja)expr invocation.           Evaluate expressions.
* factor(ja): (coreutils-ja)factor invocation.       Print prime factors
* false(ja): (coreutils-ja)false invocation.         Do nothing, unsuccessfully.
* fmt(ja): (coreutils-ja)fmt invocation.             Reformat paragraph text.
* fold(ja): (coreutils-ja)fold invocation.           Wrap long input lines.
* groups(ja): (coreutils-ja)groups invocation.       Print group names a user is in.
* head(ja): (coreutils-ja)head invocation.           Output the first part of files.
* hostid(ja): (coreutils-ja)hostid invocation.       Print numeric host identifier.
* hostname(ja): (coreutils-ja)hostname invocation.   Print or set system name.
* id(ja): (coreutils-ja)id invocation.               Print real/effective uid/gid.
* install(ja): (coreutils-ja)install invocation.     Copy and change attributes.
* join(ja): (coreutils-ja)join invocation.           Join lines on a common field.
* kill(ja): (coreutils-ja)kill invocation.           Send a signal to processes.
* link(ja): (coreutils-ja)link invocation.           Make hard links between files.
* ln(ja): (coreutils-ja)ln invocation.               Make links between files.
* logname(ja): (coreutils-ja)logname invocation.     Print current login name.
* ls(ja): (coreutils-ja)ls invocation.               List directory contents.
* md5sum(ja): (coreutils-ja)md5sum invocation.       Print or check message-digests.
* mkdir(ja): (coreutils-ja)mkdir invocation.         Create directories.
* mkfifo(ja): (coreutils-ja)mkfifo invocation.       Create FIFOs (named pipes).
* mknod(ja): (coreutils-ja)mknod invocation.         Create special files.
* mv(ja): (coreutils-ja)mv invocation.               Rename files.
* nice(ja): (coreutils-ja)nice invocation.           Modify scheduling priority.
* nl(ja): (coreutils-ja)nl invocation.               Number lines and write files.
* nohup(ja): (coreutils-ja)nohup invocation.         Immunize to hangups.
* od(ja): (coreutils-ja)od invocation.               Dump files in octal, etc.
* paste(ja): (coreutils-ja)paste invocation.         Merge lines of files.
* pathchk(ja): (coreutils-ja)pathchk invocation.     Check file name portability.
* pr(ja): (coreutils-ja)pr invocation.               Paginate or columnate files.
* printenv(ja): (coreutils-ja)printenv invocation.   Print environment variables.
* printf(ja): (coreutils-ja)printf invocation.       Format and print data.
* ptx(ja): (coreutils-ja)ptx invocation.             Produce permuted indexes.
* pwd(ja): (coreutils-ja)pwd invocation.             Print working directory.
* readlink(ja): (coreutils-ja)readlink invocation.   Print referent of a symlink.
* rm(ja): (coreutils-ja)rm invocation.               Remove files.
* rmdir(ja): (coreutils-ja)rmdir invocation.         Remove empty directories.
* seq(ja): (coreutils-ja)seq invocation.             Print numeric sequences
* shred(ja): (coreutils-ja)shred invocation.         Remove files more securely.
* sleep(ja): (coreutils-ja)sleep invocation.         Delay for a specified time.
* sort(ja): (coreutils-ja)sort invocation.           Sort text files.
* split(ja): (coreutils-ja)split invocation.         Split into fixed-size pieces.
* stat(ja): (coreutils-ja)stat invocation.           Report file(system) status.
* stty(ja): (coreutils-ja)stty invocation.           Print/change terminal settings.
* su(ja): (coreutils-ja)su invocation.               Modify user and group id.
* sum(ja): (coreutils-ja)sum invocation.             Print traditional checksum.
* sync(ja): (coreutils-ja)sync invocation.           Synchronize memory and disk.
* tac(ja): (coreutils-ja)tac invocation.             Reverse files.
* tail(ja): (coreutils-ja)tail invocation.           Output the last part of files.
* tee(ja): (coreutils-ja)tee invocation.             Redirect to multiple files.
* test(ja): (coreutils-ja)test invocation.           File/string tests.
* touch(ja): (coreutils-ja)touch invocation.         Change file timestamps.
* tr(ja): (coreutils-ja)tr invocation.               Translate characters.
* true(ja): (coreutils-ja)true invocation.           Do nothing, successfully.
* tsort(ja): (coreutils-ja)tsort invocation.         Topological sort.
* tty(ja): (coreutils-ja)tty invocation.             Print terminal name.
* uname(ja): (coreutils-ja)uname invocation.         Print system information.
* unexpand(ja): (coreutils-ja)unexpand invocation.   Convert spaces to tabs.
* uniq(ja): (coreutils-ja)uniq invocation.           Uniquify files.
* unlink(ja): (coreutils-ja)unlink invocation.       Removal via unlink(2).
* users(ja): (coreutils-ja)users invocation.         Print current user names.
* vdir(ja): (coreutils-ja)vdir invocation.           List directories verbosely.
* wc(ja): (coreutils-ja)wc invocation.               Line, word, and byte counts.
* who(ja): (coreutils-ja)who invocation.             Print who is logged in.
* whoami(ja): (coreutils-ja)whoami invocation.       Print effective user id.
* yes(ja): (coreutils-ja)yes invocation.             Print a string indefinitely.
END-INFO-DIR-ENTRY

   This manual documents version 5.2.1 of the GNU core utilities,
including the standard programs for text and file manipulation.

   Copyright (C) 1994, 1995, 1996, 2000, 2001, 2002, 2003, 2004 Free
Software Foundation, Inc.

     Permission is granted to copy, distribute and/or modify this
     document under the terms of the GNU Free Documentation License,
     Version 1.1 or any later version published by the Free Software
     Foundation; with no Invariant Sections, with no Front-Cover Texts,
     and with no Back-Cover Texts.  A copy of the license is included
     in the section entitled "GNU Free Documentation License".


File: coreutils-ja.info,  Node: Top,  Next: Introduction,  Up: (dir)

GNU Coreutils
*************

This manual documents version 5.2.1 of the GNU core utilities,
including the standard programs for text and file manipulation.

   Copyright (C) 1994, 1995, 1996, 2000, 2001, 2002, 2003, 2004 Free
Software Foundation, Inc.

     Permission is granted to copy, distribute and/or modify this
     document under the terms of the GNU Free Documentation License,
     Version 1.1 or any later version published by the Free Software
     Foundation; with no Invariant Sections, with no Front-Cover Texts,
     and with no Back-Cover Texts.  A copy of the license is included
     in the section entitled "GNU Free Documentation License".

* Menu:

* Introduction::                       Caveats, overview, and authors.
* Common options::                     Common options.
* Output of entire files::             cat tac nl od
* Formatting file contents::           fmt pr fold
* Output of parts of files::           head tail split csplit
* Summarizing files::                  wc sum cksum md5sum
* Operating on sorted files::          sort uniq comm ptx tsort
* Operating on fields within a line::  cut paste join
* Operating on characters::            tr expand unexpand
* Directory listing::                  ls dir vdir d v dircolors
* Basic operations::                   cp dd install mv rm shred
* Special file types::                 ln mkdir rmdir mkfifo mknod
* Changing file attributes::           chgrp chmod chown touch
* Disk usage::                         df du stat sync
* Printing text::                      echo printf yes
* Conditions::                         false true test expr
* Redirection::                        tee
* File name manipulation::             dirname basename pathchk
* Working context::                    pwd stty printenv tty
* User information::                   id logname whoami groups users who
* System context::                     date uname hostname
* Modified command invocation::        chroot env nice nohup su
* Process control::                    kill
* Delaying::                           sleep
* Numeric operations::                 factor seq
* File permissions::                   Access modes.
* Date input formats::                 Specifying date strings.
* Opening the software toolbox::       The software tools philosophy.
* GNU Free Documentation License::     The license for this documentation.
* Index::                              General index.

 --- 詳細なノードリスト ---

共通のオプション

* Exit status::                 Indicating program success or failure.
* Backup options::              Backup options
* Block size::                  Block size
* Target directory::            Target directory
* Trailing slashes::            Trailing slashes
* Traversing symlinks::         Traversing symlinks to directories
* Treating / specially::        Treating / specially
* Standards conformance::       Standards conformance

ファイル全体を出力

* cat invocation::              Concatenate and write files.
* tac invocation::              Concatenate and write files in reverse.
* nl invocation::               Number lines and write files.
* od invocation::               Write files in octal or other formats.

ファイルの内容の書式化

* fmt invocation::              Reformat paragraph text.
* pr invocation::               Paginate or columnate files for printing.
* fold invocation::             Wrap input lines to fit in specified width.

ファイルの一部を出力

* head invocation::             Output the first part of files.
* tail invocation::             Output the last part of files.
* split invocation::            Split a file into fixed-size pieces.
* csplit invocation::           Split a file into context-determined pieces.

ファイルの要約

* wc invocation::               Print newline, word, and byte counts.
* sum invocation::              Print checksum and block counts.
* cksum invocation::            Print CRC checksum and byte counts.
* md5sum invocation::           Print or check message-digests.

ソートされたファイルの操作

* sort invocation::             Sort text files.
* uniq invocation::             Uniquify files.
* comm invocation::             Compare two sorted files line by line.
* ptx invocation::              Produce a permuted index of file contents.
* tsort invocation::            Topological sort.

`ptx': 並べ替えた索引の生成

* General options in ptx::      Options which affect general program behavior.
* Charset selection in ptx::    Underlying character set considerations.
* Input processing in ptx::     Input fields, contexts, and keyword selection.
* Output formatting in ptx::    Types of output format, and sizing the fields.
* Compatibility in ptx::        The GNU extensions to `ptx'

行のフィールドの操作

* cut invocation::              Print selected parts of lines.
* paste invocation::            Merge lines of files.
* join invocation::             Join lines on a common field.

文字の操作

* tr invocation::               Translate, squeeze, and/or delete characters.
* expand invocation::           Convert tabs to spaces.
* unexpand invocation::         Convert spaces to tabs.

`tr': 文字を置換する，まとめる，そして/または削除する

* Character sets::              Specifying sets of characters.
* Translating::                 Changing one set of characters to another.
* Squeezing::                   Squeezing repeats and deleting.
* Warnings in tr::              Warning messages.

ディレクトリのリストアップ

* ls invocation::               List directory contents
* dir invocation::              Briefly list directory contents
* vdir invocation::             Verbosely list directory contents
* dircolors invocation::        Color setup for `ls'

`ls': ディレクトリの内容をリストアップする

* Which files are listed::      Which files are listed
* What information is listed::  What information is listed
* Sorting the output::          Sorting the output
* More details about version sort::  More details about version sort
* General output formatting::   General output formatting
* Formatting the file names::   Formatting the file names

基本操作

* cp invocation::               Copy files and directories
* dd invocation::               Convert and copy a file
* install invocation::          Copy files and set attributes
* mv invocation::               Move (rename) files
* rm invocation::               Remove files or directories
* shred invocation::            Remove files more securely

特殊なファイル形式

* link invocation::             Make a hard link via the link syscall
* ln invocation::               Make links between files
* mkdir invocation::            Make directories
* mkfifo invocation::           Make FIFOs (named pipes)
* mknod invocation::            Make block or character special files
* readlink invocation::         Print the referent of a symbolic link
* rmdir invocation::            Remove empty directories
* unlink invocation::           Remove files via unlink syscall

ファイルの属性を変更する

* chown invocation::            Change file owner and group
* chgrp invocation::            Change group ownership
* chmod invocation::            Change access permissions
* touch invocation::            Change file timestamps

ディスクの利用状況

* df invocation::               Report filesystem disk space usage
* du invocation::               Estimate file space usage
* stat invocation::             Report file or filesystem status
* sync invocation::             Synchronize data on disk with memory

テキストの出力

* echo invocation::             Print a line of text
* printf invocation::           Format and print data
* yes invocation::              Print a string until interrupted

条件文

* false invocation::              Do nothing, unsuccessfully
* true invocation::               Do nothing, successfully
* test invocation::               Check file types and compare values
* expr invocation::               Evaluate expressions

`test': ファイル形式の調査と値の比較

* File type tests::               File type tests
* Access permission tests::       Access permission tests
* File characteristic tests::     File characteristic tests
* String tests::                  String tests
* Numeric tests::                 Numeric tests

`expr': 式の評価

* String expressions::         + : match substr index length
* Numeric expressions::        + - * / %
* Relations for expr::         | & < <= = == != >= >
* Examples of expr::           Examples of using `expr'

リダイレクト

* tee invocation::               Redirect output to multiple files

ファイル名の操作

* basename invocation::          Strip directory and suffix from a file name
* dirname invocation::           Strip non-directory suffix from a file name
* pathchk invocation::           Check file name portability

作業中の状況

* pwd invocation::               Print working directory
* stty invocation::              Print or change terminal characteristics
* printenv invocation::          Print all or some environment variables
* tty invocation::               Print file name of terminal on standard input

`stty': 端末の特徴の出力や変更

* Control::                     Control settings
* Input::                       Input settings
* Output::                      Output settings
* Local::                       Local settings
* Combination::                 Combination settings
* Characters::                  Special characters
* Special::                     Special settings

ユーザの情報

* id invocation::                Print real and effective uid and gid
* logname invocation::           Print current login name
* whoami invocation::            Print effective user id
* groups invocation::            Print group names a user is in
* users invocation::             Print login names of users currently logged in
* who invocation::               Print who is currently logged in

システムの状況

* date invocation::              Print or set system date and time
* uname invocation::             Print system information
* hostname invocation::          Print or set system name
* hostid invocation::            Print numeric host identifier.

`date': システムの日時の出力と設定

* Time directives::              Time directives
* Date directives::              Date directives
* Literal directives::           Literal directives
* Padding::                      Padding
* Setting the time::             Setting the time
* Options for date::             Options for `date'
* Examples of date::             Examples of `date'

コマンドの呼び出しを修正

* chroot invocation::            Run a command with a different root directory
* env invocation::               Run a command in a modified environment
* nice invocation::              Run a command with modified scheduling priority
* nohup invocation::             Run a command immune to hangups
* su invocation::                Run a command with substitute user and group id

プロセス制御

* kill invocation::              Sending a signal to processes.

遅延

* sleep invocation::             Delay for a specified time

数学的操作

* factor invocation::            Print prime factors
* seq invocation::               Print numeric sequences

ファイルの許可

* Mode Structure::               Structure of File Permissions
* Symbolic Modes::               Mnemonic permissions representation
* Numeric Modes::                Permissions as octal numbers

日付の入力書式

* General date syntax:           General date syntax
* Calendar date items:           Calendar date items
* Time of day items:             Time of day items
* Time zone items:               Time zone items
* Day of week items:             Day of week items
* Relative items in date strings:  Relative items in date strings
* Pure numbers in date strings:  Pure numbers in date strings
* Authors of getdate:            Authors of getdate

ソフトウェアツールボックスを開く

* Toolbox introduction::         Toolbox introduction
* I/O redirection::              I/O redirection
* The who command::              The `who' command
* The cut command::              The `cut' command
* The sort command::             The `sort' command
* The uniq command::             The `uniq' command
* Putting the tools together::   Putting the tools together

GNU Free Documentation License

* How to use this License for your documents::


File: coreutils-ja.info,  Node: Introduction,  Next: Common options,  Prev: Top,  Up: Top

1 はじめに
**********

このマニュアルは作業中です．初心者に適した方法で，基本的な概念を説明し
ようとしていないセクションもたくさんあります．そのため，興味があればこ
のマニュアルの改善に参加してください．GNUコミュニティ全体が利益を
得るでしょう．

   バグを<bug-coreutils@gnu.org>に報告してください． バージョンナンバー，マシンアーキテクチャ，入力ファイル，そしてバグの再
現に必要なその他のあらゆる情報含めることを忘れないでください．入力，期
待したもの，得たもの，そして間違っている理由です．差分は歓迎しますが，
推測が難しいときもあるので，問題の記述も含めてください．*Note Bugs:
(gcc)Bugs.

   このマニュアルは配布物のUNIX man
pageを元にしていて，それは，元々David MacKenzieによって書かれ，Jim
Meyeringによって更新されました．現在読ん
でいるものは，これらのユーティリティの権威のあるドキュメントです．man
pageは，既に管理されていません．元となる`fmt'のman pageは， Ross
Patersonによって書かれました．Franc,ois Pinardは，Texinfo書式
への最初の変換を行いました．Karl Berryは索引の追加，いくつかの再編成，
そして結果の編集を行いました．Free Software Foundationの事務所のスタッ
フBrian Youmansは，現在のオムニバスのマニュアルを生成するため，
textutils，fileutils，そしてsh-utilsのマニュアルを統合しました．
Richard Stallmanは，全体的なプロセスに，彼のいつもの貴重な洞察を寄稿し
ました．


File: coreutils-ja.info,  Node: Common options,  Next: Output of entire files,  Prev: Introduction,  Up: Top

2 共通のオプション
******************

特定のオプションは，以下のすべてのプログラムで利用可能です．それぞれの
プログラムで同一の記述を書く代わりに以下で記述します．(実際，すべての
GNUプログラムが，これらのオプションを受け入れる(あるいは受け入れ
るべき)です．)

通常，オプションとオペランドは任意の順序で書くことが可能で，プログラムは
すべてのオプションがあらゆるオペランドの前に書かれているかのように動作し
ます．例えば，`sort -r passwd -t :'は`sort -r -t : passwd'のよ
うに動作し，それは`:'が`-t'のオプション引数であるためです．
しかし，`POSIXLY_CORRECT'環境変数が設定されている場合，特定のコマン
ドで指定ない場合，オプションをオペランドの前に書く必要があります．

   これらのプログラムには，`--help'と`--version'が単一のコ
マンドライン引数のときだけ，それを認識するものもあります．

`--help'
     すべての利用可能なオプションをリストアップした使用方法のメッセージを出
     力し，正しく終了します．

`--version'
     バージョンナンバーを出力して，正しく終了します．

`--'
     オプションリストを区切ります．それ以降の引数は何であろうと，たとえ
     `-'で始まる場合でもオペランドとして扱われます．例えば，`sort --
     -r'は`-r'という名前のファイルから読み込みます．


   単一の`-'は，オプションのように見えても本当のオプションではありま
せん．状況から明らかな場合は，それは標準入力や標準出力を意味し，オペラ
ンドやオプション引数として使用可能です．例えば，`sort -o - -'は標
準出力に書き出し，標準入力から読み込み，そしてそれは単なる
`sort'と等価です．他で指定されない限り，ファイル名が要求される
あらゆる状況で`-'を書くことが可能です．

* Menu:

* Exit status::                 Indicating program success or failure.
* Backup options::              -b -S -V, in some programs.
* Block size::                  BLOCK_SIZE and --block-size, in some programs.
* Target directory::            --target-directory, in some programs.
* Trailing slashes::            --strip-trailing-slashes, in some programs.
* Traversing symlinks::         -H, -L, or -P, in some programs.
* Treating / specially::        --preserve-root and --no-preserve-root.
* Standards conformance::       Conformance to the POSIX standard.


File: coreutils-ja.info,  Node: Exit status,  Next: Backup options,  Up: Common options

2.1 終了ステータス
==================

ほとんどすべてのコマンドの呼び出しは，他のコマンドの動作を変更するため
にしよう可能な，正規の"終了ステータス(exit status)"を生成します．
コマンドの大半は，ゼロの終了ステータスは成功を示します．失敗はゼロ以外
の値で示されます--通常は`1'ですが，POSIXではゼロ以外で
あることを要求しているだけなので，独特のプラットフォームでは違う可能性
があります．

しかし，以下で説明されているプログラムには，それ以外の終了ステータスの
値を生成するものや，`0'と`1'の値に別の意味を割り当てているも
のもあります．例外は以下の通りです．`chroot', `env', `expr', `nice',
`nohup', `printenv', `sort', `su', `test', `tty'.


File: coreutils-ja.info,  Node: Backup options,  Next: Block size,  Prev: Exit status,  Up: Common options

2.2 バックアップオプション
==========================

GNUプログラムには(少なくとも，`cp'，`install'，
`ln'，そして`mv'には)オプションで，新しいバージョンの
ファイルを書き出す前に，ファイルのバックアップを作成するものもあります．
以下のオプションは，これらのバックアップを細かく制御します．オプション
は，特定のプログラムの説明でも簡単に記述します．

`-b'
`--backup[=METHOD]'
     バックアップを作成しないと上書きされたり削除されたりするそれぞれのファ
     イルのバックアップを作成します．このオプションを用いないと，オリジナル
     のバージョンは破棄されます．作成するバックアップの形式を決定するために，
     METHODを使用してください．このオプションが使用されていて，
     METHODが指定されていないとき，`VERSION_CONTROL'環境変数の値
     が使用されます．そして`VERSION_CONTROL'が設定されていない場合は，
     デフォルトのバックアップ形式は`existing'になります．

     このオプションの短い形式`-b'は，引数を全く受け入れないことに注
     意してください．`-b'の使用は，`--backup=existing'の使用
     と等価です．

     このオプションは，Emacs変数の`version-control'に対応します．
     METHODに対する値は，Emacsで使用されるものと同じです．このオプショ
     ンも，より記述的な名前を受け入れます．有効なMETHODは以下の通りで
     す(ユニークに識別できる省略も受け入れます)．

    `none'
    `off'
          バックアップを作成しません．

    `numbered'
    `t'
          常に番号付のバックアップを作成します．

    `existing'
    `nil'
          既に番号付のバックアップファイルがある場合，番号付のバックアップを作成
          し，それ以外では単純にバックアップします．

    `simple'
    `never'
          常に単純なバックアップを作成します．`never'と`none'を混同し
          ないように注意してください．


`-S SUFFIX'
`--suffix=SUFFIX'
     `-b'で作成されるそれぞれのバックアップファイルにSUFFIXを
     追加します．このオプションが指定されていない場合，
     `SIMPLE_BACKUP_SUFFIX'環境変数の値が使用されます．そして
     `SIMPLE_BACKUP_SUFFIX'が設定されていない場合，デフォルトで`~'
     となり，それはちょうどEmacsと同じです．

`--version-control=METHOD'
     このオプションは時代遅れで，将来のリリースで削除されるでしょう．それは，
     `--backup'で置き換えられました．



File: coreutils-ja.info,  Node: Block size,  Next: Target directory,  Prev: Backup options,  Up: Common options

2.3 ブロックサイズ
==================

GNUプログラム(少なくとも，`df'，`du'，そして
`ls')には，ファイルサイズを"ブロック"で表示するものもありま
す．ファイルサイズをより読みやすくするため，ブロックサイズを調整するこ
とが可能です．表示で使用するブロックサイズは，あらゆるファイルシステム
のブロックサイズから独立しています．分数のブロック数は最も近い整数に切
り上げられます．

デフォルトのブロックサイズは，以下の環境変数を順番に調べることで選択さ
れます．最初に設定されていたものでブロックサイズを決定します．

`DF_BLOCK_SIZE'
     これは，`df'コマンドに対するデフォルトのブロックサイズを指定し
     ます．同様に，`DU_BLOCK_SIZE'は`du'に対するデフォルト，そ
     して`LS_BLOCK_SIZE'は`ls'に対するデフォルトを指定します．

`BLOCK_SIZE'
     上記のコマンド指定の環境変数が設定されていない場合，これは，三つのコマ
     ンド全てに対するデフォルトのブロックサイズを指定します．

`POSIXLY_CORRECT'
     `COMMAND_BLOCK_SIZE'も`BLOCK_SIZE'変数も設定されておらず，
     この変数が設定されている場合，ブロックサイズのデフォルトは512になりま
     す．


上記の環境変数がどれも設定されていない場合，ほとんどの状況でブロックサ
イズは現在のデフォルトの1024バイトですが，この数は将来変更されるかもし
れません．`ls'のファイルサイズに対して，ブロックサイズのデフォ
ルトは1バイトです．

ブロックサイズの指定は，ブロックごとのバイト数の指定で正の整数にしたり，
人間が可読な書式を選択して`human-readable'や`si'にしたりする
ことが可能です．整数には，十進数の倍数となる SI prefixes
(http://www.bipm.fr/enus/3_SI/si-prefixes.html)の上
位互換の接尾子を続けたり， IEC 60027-2 prefixes for binary multiples
(http://physics.nist.gov/cuu/Units/binary.html)が続けてもかまいません．

   人間が可読な書式を用いると，出力サイズにはメガバイトに対する`M'の
ような大きさを示す文字が続きます．`BLOCK_SIZE=human-readable'は
1024乗を使用します．`M'は1,048,576バイトを意味します．
`BLOCK_SIZE=si'は似ていますが，それは1000乗を使用し`B'が後置
されます．`MB'は1,000,000を意味します．

   `''が前置されているブロックサイズの指定で，千単位で区切られた大き
さを表示するようになります．`LC_NUMERIC'ロカールは，千の分離子とグ
ループ分けを指定します．例えば，アメリカ英語のロカールでは，
`--block-size="'1kB"'で1234000バイトの大きさを`1,234'と表示
するようになるでしょう．デフォルトのCロカールでは，千単位の区切りが無
いので，`''には効果がありません．

整数のブロックサイズは，そのサイズの倍数を指定する接尾子を続けることが
可能です．そのままの大きさを示す文字や`iB'が続くものは，1024倍を
指定します．`B'が続く大きさを示す文字は，代わりに1000倍を指定しま
す．例えば，`1M'と`1MiB'は`1048576'と等価で，`1MB'
は`1000000'と等価です．

   前置する整数が無い普通のサフィックスでは，`1'が前置されているかの
ように動作しますが，大きさを示す文字が出力に後置されます．例えば，
`--block-size="kB"'は3000を`3kB'と表示します．

   以下の大きさを示す文字が定義されています．`1Y'のような大きなサイ
ズは，その計算の限界のためコンピュータに拒絶されるかもしれません．

`kB'
     キロバイト：10^3 = 1000．

`k'
`K'
`KiB'
     キビバイト：2^10 = 1024．`K'は特殊です．SIの接頭辞は `k' で，IEC
     60027-2の接頭辞は`Ki'ですが，伝統的なものと
     POSIXでは，`k'を`KiB'の意味で使用します．

`MB'
     メガバイト：10^6 = 1,000,000．

`M'
`MiB'
     メビバイト：2^20 = 1,048,576．

`GB'
     ギガバイト：10^9 = 1,000,000,000．

`G'
`GiB'
     ギビバイト：2^30 = 1,073,741,824．

`TB'
     テラバイト：10^12 = 1,000,000,000,000．

`T'
`TiB'
     テビバイト：2^40 = 1,099,511,627,776．

`PB'
     ペタバイト：10^15 = 1,000,000,000,000,000．

`P'
`PiB'
     ペビバイト：2^50 = 1,125,899,906,842,624．

`EB'
     エクサバイト：10^18 = 1,000,000,000,000,000,000．

`E'
`EiB'
     エクシビバイト：2^60 = 1,152,921,504,606,846,976．

`ZB'
     ゼータバイト：10^21 = 1,000,000,000,000,000,000,000．

`Z'
`ZiB'
     2^70 = 1,180,591,620,717,411,303,424．(`Zi'はIEC 60027-2へ
     のGNUの拡張です．)

`YB'
     ヨッタバイト：10^24 = 1,000,000,000,000,000,000,000,000．

`Y'
`YiB'
     2^80 = 1,208,925,819,614,629,174,706,176．(`Yi'はIEC
     60027-2へのGNUの拡張です．)

   ブロックサイズのデフォルトは，`--block-size=SIZE'オプショ
ンを明示することで優先することが可能です．`-k'オプションは，
`--block-size=1k'と等価で，それは`POSIXLY_CORRECT'環境変数
が指定されていない場合のデフォルトです．`-h'や
`--human-readable'オプションは，
`--block-size=human-readable'と等価です．`--si'オプショ
ンは，`--block-size=si'と等価です．


File: coreutils-ja.info,  Node: Target directory,  Next: Trailing slashes,  Prev: Block size,  Up: Common options

2.4 ターゲットディレクトリ
==========================

GNUプログラム(少なくとも`cp'，`install'，
`ln'，そして`mv')には，このオプションでターゲットディ
レクトリの指定を可能にするものもあります．

`--target-directory=DIRECTORY'
     対象となるDIRECTORYを指定します．

     ほとんどのプログラムのインターフェースは，オプションと有限数の(おそら
     くゼロの)固定した位置の引数を処理した後，残りの引数リストは空である，
     または同じように処理される(通常ファイルとなる)項目のリストになっている
     ことが期待されています．`xargs'プログラムは，この慣習を用いて
     より良く動作するように設計されています．

     様々な数の引数の_最後_に特例(すなわち，ターゲットディレクトリ)が
     あるため，`mv'の類のコマンドは普通のものとは言えません．例えば
     "全てのファイルをここから`../d/'に移動する"ような処理を実行する
     ために，`mv * ../d/'では引数の空間を使い果すかもしれませんし， `ls
     | xargs ...'では，それぞれの従属コマンドの呼び出しへの特別な
     最後の引数を指定する方法がないため，明確ではなくなります．(それは，シェ
     ルコマンドで動作させることが可能ですが，人間の労働と能力が余分に必要と
     なります．)

     `--target-directory'オプションによって，`cp'，
     `install'，`ln'，そして`mv'プログラムで，
     `xargs'を用いて便利に使用することが可能になります．例えば，現
     在のディレクトリから同じ階層のディレクトリ，ここでは`d'に，ファイ
     ルを移動することが可能です．(しかし，これは`.'で始まる名前のファ
     イルを移動しません．)

          ls |xargs mv --target-directory=../d

     GNU `find'プログラムを使用している場合，以下のコマンドで
     _全ての_ファイルを移動することが可能です．
          find . -mindepth 1 -maxdepth 1 \
            | xargs mv --target-directory=../d

     しかし，現在のディレクトリにファイルがない場合や，改行文字を含む名前の
     ファイルがある場合，それは失敗するでしょう．以下の例は，これらの制限を
     取り除きますが，GNU `find'とGNU `xargs'の両 方を必要とします．
          find . -mindepth 1 -maxdepth 1 -print0 \
            | xargs --null --no-run-if-empty \
                mv --target-directory=../d



File: coreutils-ja.info,  Node: Trailing slashes,  Next: Traversing symlinks,  Prev: Target directory,  Up: Common options

2.5 末尾のスラッシュ
====================

GNUプログラム(少なくとも`cp'と`mv')には，それぞれ
のSOURCE引数を処理する前に末尾のスラッシュを取り除くことが可能な
ものもあります．`--strip-trailing-slashes'オプションはこの動作
を可能にします．

   SOURCE引数の末尾にスラッシュがあり，ディレクトリへのシンボリック
リンクを指定しているとき，これは役に立ちます．シェルにはシンボリックリ
ンクのようなものに対してファイル名の補完を実行しているとき，末尾のスラッ
シュを自動的に追加することが可能なものもあるので，このシナリオは現実と
なります．このオプションがない場合，例えば(システムの名前変更機能のた
め)`mv'は，末尾のスラッシュをシンボリックリンク先を参照しない
ように要求するよう解釈する必要があり，そして，そのためシンボリックリン
クではなく，間接的に参照される_ディレクトリ_の名前を変更するはず
です．そのような動作がデフォルトということにびっくりするかもしれません
が，それはPOSIXで要求されていて，その標準のそれ以外の部分と
一貫しています．


File: coreutils-ja.info,  Node: Traversing symlinks,  Next: Treating / specially,  Prev: Trailing slashes,  Up: Common options

2.6 シンボリックリンクをたどる
==============================

以下のオプションは，`--recursive' (`-R')オプションも使用
されているときに，`chown'と`chgrp'が(ディレクトリ)階層
をたどる方法を変更します．
以下のオプションの一つ以上が指定されている場合，最後のものだけ効果があ
ります．これらのオプションは，ディレクトリ構造の処理を，シンボリックリ
ンクとして処理するか，そのディレクトリがルートになっている階層構造のす
べてのファイルを処理するかを指定します．

以下のオプションは，シンボリックリンクかその参照先のいずれを処理するか
を制御する`--dereference'と`--no-dereference' (`-h')とは独立しています．

`-H'
     `--recursive' (`-R')が指定されていて，コマンドライン引数
     がディレクトリへのシンボリックリンクの場合，それをたどっていきます．

`-L'
     再帰的にたどる状況で，ディレクトリへのシンボリックリンクを，見つかった
     ものはすべてたどります．

`-P'
     シンボリックリンクをたどりません．これは`-H'，`-L'，また
     は`-P'のいずれも指定されていない場合のデフォルトです．



File: coreutils-ja.info,  Node: Treating / specially,  Next: Standards conformance,  Prev: Traversing symlinks,  Up: Common options

2.7 / の特別な扱い方
====================

コマンドには，階層構造全体を破壊するような処理が可能なものもあります．
例えば，適切な特権を持つユーザが間違って`rm -rf / tmp/junk'や `cd /bin;
rm -rf ../'を実行した場合，システム全体のすべてのファイ
ルが削除される可能性があります．そのようなコマンドが正当であるというこ
とは滅多に無いので(1)，GNU
`rm'は`--preserve-root'オプションを提供し，最終的に
`/'とされるようなディレクトリの処理を`rm'にさせないように
します．もう一つの新たなオプションである`--no-preserve-root'は，
前出の`--preserve-root'オプションの効果をなくします．
`--preserve-root'の動作が`rm'のデフォルトになる可能性が
あることに注意して下さい．

   コマンド`chgrp'，`chmod'，そして`chown'も，階
層構造全体を破壊する処理が可能なので，これらのオプションをサポートして
います．しかし，`rm'とは異なり，ファイルを実際にアンリンクする
わけではないので，`/'で再帰的な処理をするときは，おそらくこれらの
コマンドはさらに危険で，その理由は処理時間が短いため，ユーザが停止させ
る前に多くのファイルに障害が発生するためです．

   ---------- Footnotes ----------

   (1) 知っているものがあれば
<bug-coreutils@gnu.org>にメールを書いて下さい．


File: coreutils-ja.info,  Node: Standards conformance,  Prev: Treating / specially,  Up: Common options

2.8 標準への準拠
================

状況によっては，GNUのユーティリティのデフォルトの動作は
POSIXの標準と互換性がありません．これらの非互換性を抑制する
ため，`POSIXLY_CORRECT'環境変数を定義してください．POSIX
準拠を調査していない限り，`POSIXLY_CORRECT'を定義する必要はありま せん．

   新しいバージョンのPOSIXには，古いバージョンのものと互換性が
無いものもあります．例えば，古いバージョンのPOSIXでは，それ
ぞれの入力ファイルの二番目とそれ以降のフィールドをもとにソートするコマ
ンド`sort +1'を要求していますが，POSIX 1003.1-2001から
は同じコマンドで`+1'という名前のファイルをソートすることを要求し
ていて，フィールドをもとにしたソートを行なうため，コマンド`sort -k
2'を代わりに使用する必要があります．

   GNUのユーティリティは通常，システム標準のPOSIXのバージョ
ンに準拠しています．異なるPOSIXのバージョンに準拠させるため，
適用させる標準の年月を指定するYYYYMMの形式の値に
`_POSIX2_VERSION'環境変数を設定してください．現在，
`_POSIX2_VERSION'に対して二つの値がサポートされています．
`199209'はPOSIX 1003.2-1992を意味し，`200112'は POSIX
1003.1-2001を意味します．例えば，古いバージョンの
POSIXを仮定する古いソフトウェアを実行し，`sort +1'， `head
-1'，または`tail +1'を使用している場合，環境変数で
`_POSIX2_VERSION=199209'を設定することで，互換性の問題を回避する
ことが可能です．


File: coreutils-ja.info,  Node: Output of entire files,  Next: Formatting file contents,  Prev: Common options,  Up: Top

3 ファイル全体の出力
********************

以下のコマンドは，いくつかの方法で，おそらくファイルを変換しながら，ファ
イル全体を読み込み，そして書き出します．

* Menu:

* cat invocation::              Concatenate and write files.
* tac invocation::              Concatenate and write files in reverse.
* nl invocation::               Number lines and write files.
* od invocation::               Write files in octal or other formats.


File: coreutils-ja.info,  Node: cat invocation,  Next: tac invocation,  Up: Output of entire files

3.1 `cat': ファイルを連結し書き込む
===================================

`cat'は，それぞれのFILE(`-'は標準入力を意味します)
や，与えられない場合は標準入力を標準出力へコピーします．概要です．

     cat [OPTION] [FILE]...

   プログラムは以下のオプションを受け入れます．*Note Common
options::も参照 してください．

`-A'
`--show-all'
     `-vET'と等価です．

`-B'
`--binary'
     MS-DOSとMS-Windowsのみで，ファイルをバイナリモードで読み書きします．デ
     フォルトで，MS-DOS/MS-Windowsでの`cat'は，標準出力がファイルや
     パイプにリダイレクトされているときだけ，バイナリモードを使用します．こ
     のオプションはそれに優先します．バイナリファイルのI/Oでは，
     `cat'はファイルのコピープログラムとして使用されることが多いの
     で，それらの書式(DOSテキストとバイナリに対するUnixテキスト)を保つため
     に使われます．(以下の)オプションには，元ファイルの内容が重要でないとき
     には，`cat'にテキストモードでファイルを読み書きさせるものもあ
     ります(例えば，行が`cat'で番号付けされるときや行の終りに印を付
     けるとき)．これは，これらのオプションをDOS/Windowsユーザが期待したよう
     に動作させるためのものです．例えば，DOS形式のテキストファイルは，テキ
     ストモードで読まれない場合，`-b'で空の行として扱われない，CR-LF
     というペアの文字が行末にあります．

`-b'
`--number-nonblank'
     空白でない全ての出力行に，1で始まる番号を付けます．MS-DOSとMS-Windows
     では，このオプションで，`cat'はテキストモードでファイルを読み
     書きします．

`-e'
     `-vE'と等価です．

`-E'
`--show-ends'
     それぞれの行末の後に`$'を表示します．MS-DOSとMS-Windowsでは，
     `cat'はこのオプションでテキストモードでファイルを読み書きしま す．

`-n'
`--number'
     全ての出力行に，1で始まる番号を付けます．MS-DOSとMS-Windowsでは，
     `cat'はこのオプションでテキストモードでファイルを読み書きしま す．

`-s'
`--squeeze-blank'
     複数の隣接した空白行を，一行のブランク行に置換します．MS-DOSと
     MS-Windowsでは，`cat'はこのオプションでテキストモードでファイ
     ルを読み書きします．

`-t'
     `-vT'と等価です．

`-T'
`--show-tabs'
     TAB文字を `^I'として表示します．

`-u'
     無視されます．Unix互換性のためです．

`-v'
`--show-nonprinting'
     LFDとTAB以外のコントロール文字を，`^'表記法を使用して表示し，
     `M-'を使用したハイビットセットがある文字に前置します．MS-DOSと
     MS-Windowsでは，`cat'はこのオプションでDOSバイナリモードでファ
     イルと標準入力を読み込むので，それぞれの行末のCR文字が表示されます．


   終了ステータスのゼロは成功を示し，ゼロ以外の値は失敗を示します．


File: coreutils-ja.info,  Node: tac invocation,  Next: nl invocation,  Prev: cat invocation,  Up: Output of entire files

3.2 `tac': 逆順にファイルを連結し書き込む
=========================================

`tac'は，それぞれのFILE(`-'は，標準入力を意味します)
や，与えられない場合は標準入力を，個々に分割されたレコード(デフォルト
は行)を逆順にしながら，標準出力へコピーします．概要です．

     tac [OPTION]... [FILE]...

   "レコード(record)"は，文字列のインスタンス(デフォルトは改行)で分け
られています．デフォルトで，このセパレータ文字列はファイルのレコードの
終りに続けて付加されます．

   プログラムは以下のオプションを受け入れます．*Note Common
options::も参照 してください．

`-b'
`--before'
     セパレータを，ファイルのレコードの最初に前置して付加します．

`-r'
`--regex'
     セパレータ文字列を正規表現として扱います．MS-DOS/MS-Windowsでの
     `tac'ユーザは，`tac'がファイルをバイナリモードで読むた
     め，テキストファイルのそれぞれの行はUnixスタイルのLFの代わりにCR/LFの
     ペアで終ることに注意すべきです．

`-s SEPARATOR'
`--separator=SEPARATOR'
     SEPARATORを，改行の代わりにセパレータ文字列として用います．


   終了ステータスのゼロは成功を示し，ゼロ以外の値は失敗を示します．


File: coreutils-ja.info,  Node: nl invocation,  Next: od invocation,  Prev: tac invocation,  Up: Output of entire files

3.3 `nl': 行に番号を付けファイルに書き込む
==========================================

`nl'は，それぞれのFILE(`-'は標準入力を意味します)や，
与えられない場合は標準入力を，いくつかの行または全ての行に行番号を加え
て標準出力へ書き出します．概要です．

     nl [OPTION]... [FILE]...

   `nl'は，入力を(論理)ページに分解します．デフォルトで，それぞれ
の論理ページのトップで，行番号が1にリセットされます．`nl'は全
ての入力ファイルを単一のドキュメントとして扱います．行番号や論理ページ
をファイル間でリセットしません．

論理ページは三つのセクションから成立ちます．ヘッダ，ボディ，そしてフッ
タです．任意のセクションを空にすることも可能です．それぞれ異なるスタイ
ルで番号を付けることが可能です．

論理ページのセクションの最初は，以下のデリミタ文字列の一つを入力ファイ
ルに単一行で含めることで示されます．

`\:\:\:'
     ヘッダの始まり．

`\:\:'
     ボディの始まり．

`\:'
     フッタの始まり．

   これらの文字列を構成する二つの文字を，`\'と`:'から変更するこ
とはオプション(以下を参照)で可能ですが，パターンと文字列の長さの変更は
不可能です．

セクションデリミタは，出力では空行に置換されます．入力ファイルの，最初
のセクションのデリミタ文字列より前のあらゆるテキストは，ボディセクショ
ンの一部と考えられるので，`nl'は，セクションデリミタが無いファ
イルを，一つのボディセクションとして扱います．

   プログラムは以下のオプションを受け入れます．*Note Common
options::も参照 してください．

`-b STYLE'
`--body-numbering=STYLE'
     それぞれの論理ページのボディセクションの行に対する番号付けのスタイルを
     選択します．行が番号付けされないとき，現在の行番号は増加しませんが，行
     番号と分離する文字列が行に前置されます．スタイルは以下のとおりです．

    `a'
          全ての行に番号を付けます．

    `t'
          (デフォルトでボディに対し)空でない行だけ，番号を付けます．

    `n'
          (デフォルトでヘッダやフッタに対し)番号を付けません．

    `pBRE'
          基本正規表現BREにマッチしたものを含む行だけ番号を付けます．
          *Note Regular Expressions: (grep)Regular Expressions.

`-d CD'
`--section-delimiter=CD'
     セクションを分離する文字をCDに設定します．デフォルトは`\:'
     です．Cのみ与えられた場合，二番目の`:'はそのままです．(シェ
     ルが展開する`\'やその他のメタ文字を，引用符やバックスラッシュの追
     加で保護することを忘れないでください．)

`-f STYLE'
`--footer-numbering=STYLE'
     `--body-numbering'の同類です．

`-h STYLE'
`--header-numbering=STYLE'
     `--body-numbering'の同類です．

`-i NUMBER'
`--page-increment=NUMBER'
     行番号をNUMBERずつ(デフォルトは1)増加します．

`-l NUMBER'
`--join-blank-lines=NUMBER'
     NUMBER(デフォルトは1)連続した空行を，番号付としては一つの論理行
     だと考え，最後のものだけに番号付けします．NUMBERより少ない行の連
     続した空行があるところでは番号付けをしません．空行とは，文字を含まずス
     ペースやタグも含まないものです．

`-n FORMAT'
`--number-format=FORMAT'
     行の番号付けの書式を選択します(デフォルトは`rn'です)．

    `ln'
          左寄せで，先頭にゼロを書きません．

    `rn'
          右寄せで，先頭にゼロを書きません．

    `rz'
          右寄せで，先頭にゼロを書きます．

`-p'
`--no-renumber'
     論理ページの最初で，行番号をリセットしません．

`-s STRING'
`--number-separator=STRING'
     出力で，STRINGを使って(デフォルトはTAB文字)テキスト行と行番号を
     分離します．

`-v NUMBER'
`--starting-line-number=NUMBER'
     それぞれの論理ページの行番号の初期値を，NUMBER(デフォルトは1)に
     設定します．

`-w NUMBER'
`--number-width=NUMBER'
     行番号に，NUMBER文字使います(デフォルトは6)．


   終了ステータスのゼロは成功を示し，ゼロ以外の値は失敗を示します．


File: coreutils-ja.info,  Node: od invocation,  Prev: nl invocation,  Up: Output of entire files

3.4 `od': 八進数やその他の書式でファイルを書き出す
==================================================

`od'は，それぞれのFILE(`-'は標準入力を意味します)や，
与えられない場合は標準入力を明瞭な表現で書き出します．概要です．

     od [OPTION]... [FILE]...
     od --traditional [FILE] [[+]OFFSET [[+]LABEL]]

それぞれの出力行は，入力オフセットとそれに続くファイルデータのグループ
から成り立ちます．デフォルトで，`od'は八進数でオフセットを出力
し，それぞれのファイルのデータグループは，一つの八進数として出力される
入力からの二バイトです．

   プログラムは以下のオプションを受け入れます．*Note Common
options::も参照 してください．

`-A RADIX'
`--address-radix=RADIX'
     出力するファイルオフセットの基数を選択します．RADIXは，以下の一
     つが使用可能です．

    `d'
          十進数．

    `o'
          八進数．

    `x'
          16進数．

    `n'
          なし(出力オフセットを出力しません)．

     デフォルトは八進数です．

`-j BYTES'
`--skip-bytes=BYTES'
     書式化と書き出しの前に，入力バイトのBYTESスキップします．
     BYTESが`0x'や`0X'で始まる場合，16進数と解釈されます．
     それ以外で`0'で始まる場合は八進数．それ以外では十進数です．
     `b'の追加でBYTESを512倍し，`k'は1024倍，そして`m'
     は1048576倍します．

`-N BYTES'
`--read-bytes=BYTES'
     入力の最大BYTESバイトを出力します．`bytes'に対する接頭辞と
     接尾子は，`-j'のものと同じように解釈されます．

`-s N'
`--strings[=N]'
     通常の出力の代わりに，"文字列定数(string constants)"だけを出力しま
     す．それは，少なくともN個の連続したASCIIの印字可能な文
     字で，それにはnull(ゼロ)バイトが続きます．

     `--strings'でNが省略されている場合，デフォルトは3です．古
     いシステムでは，GNU `od'は時代遅れのオプション
     `-s[N]'をサポートしていて，そこでのNのデフォルトも3 です．POSIX
     1003.1-2001 (*note Standards conformance::)では，
     引数を用いない`-s'は許可されません．代わりに`--strings'
     を使用してください．

`-t TYPE'
`--format=TYPE'
     ファイルデータの出力書式を選択します．TYPEは，以下の形式を示す文
     字の一つ以上の文字列です．単一のTYPE文字列に，一つ以上の形式を示
     す文字を含めたり，一回以上このオプションを使用した場合，`od'は，
     それぞれの指定したデータ形式を用いて，それぞれの出力行のコピーを，指定
     した順番で書き出します．

     あらゆる形式指定の終りに"z"を加えることで，形式指定で生成された出力
     行に，印刷可能な文字に存在するASCII文字の表示を加えます．

    `a'
          指名された文字．

    `c'
          ASCII文字，またはバックスラッシュエスケープ．

    `d'
          符号付き十進数．

    `f'
          浮動小数点．

    `o'
          八進数．

    `u'
          符号無し十進数．

    `x'
          16進数．

     形式`a'は，スペースに対し`sp'，改行に対し`nl'，そして
     null(ゼロ)バイトに対し`nul'のようなものを出力します．形式`c'
     は，それぞれ` '，`\n'，そして`\0'を出力します．

     `a'と`c'以外の形式に対し，それぞれの数字の解釈に使用するバイ
     ト数を，以下の十進の整数を用いた形式を示す文字で与えられているデータ形
     式で指定することができます．代わりに，以下の文字の一つを用いた形式を示
     す文字で，Cコンパイラ組込みのデータ形式を指定することも可能です．整数
     (`d'，`o'，`u'，`x')に対しては以下のようになります．

    `C'
          char

    `S'
          short

    `I'
          int

    `L'
          long

     浮動小数点(`f')に対しては以下のようになります．
    F
          float

    D
          double

    L
          long double

`-v'
`--output-duplicates'
     同一の連続した行を出力します．デフォルトで，二行以上連続した出力行が同
     一のとき，`od'は最初の行のみ出力し，それ以下の行には省略を示す
     ためアスタリスクだけを書きます．

`-w N'
`--width[=N]'
     出力行ごとに，`n'入力バイトをダンプします．これは，出力形式で指定
     したものに関連するサイズの最小公倍数の倍数にする必要があります．

     このオプションが全く指定されていない場合，デフォルトは16です．
     `--width'でNが省略されている場合，デフォルトは32です．古
     いシステムでは，GNU `od'は時代遅れのオプション
     `-w[N]'を代わりにサポートしていて，そこでのNのデフォ
     ルトも32です．POSIX 1003.1-2001 (*note Standards
     conformance::)では，引数を用いない`-w'を許可していません．代わり
     に`--width'を使用してください．


   次のいくつかのオプションは，書式指定の短いものです．GNU
`od'は，短いものと書式指定のオプションのあらゆる組み合わせを受
け入れます．これらのオプションは累積されます．

`-a'
     指名された文字として出力します．`-ta'と等価です．

`-b'
     八進数のバイトとして出力します．`-toC'と等価です．

`-c'
     ASCII文字やバックスラッシュエスケープとして出力します．
     `-tc'と等価です．

`-d'
     符号無しの十進数のshortとして出力します．`-tu2'と等価です．

`-f'
     浮動小数点として出力します．`-tfF'と等価です．

`-h'
     16進数のshortとして出力します．`-tx2'と等価です．

`-i'
     十進数のshortとして出力します．`-td2'と等価です．

`-l'
     十進数のlongとして出力します．`-td4'と等価です．

`-o'
     八進数のshortとして出力します．`-to2'と等価です．

`-x'
     16進数のshortとして出力します．`-tx2'と等価です．

`--traditional'
     伝統的な`od'が受け入れる，オプション引数が無いものとして認識し
     ます．以下の構文です．

          od --traditional [FILE] [[+]OFFSET[.][b] [[+]LABEL[.][b]]]

     これは，最大一つのファイルと，オプション引数で指定しているオフセットと
     疑似スタートアドレス，LABELを指定するために使用することが可能で
     す．デフォルトで，OFFSETは，書式化と書き出しの前にスキップする入
     力バイトの量が八進数で指定されていると解釈されます．オプションで十進数
     の位置を後置すると，OFFSETの解釈は強制的に十進数とします．十進数
     が指定されておらず，オフセットが`0x'や`0X'で始まる場合，それ
     は16進数として解釈されます．`b'の後置がある場合，スキップされるバ
     イト数はOFFSET の512倍になります．LABEL引数は，
     OFFSETのように解釈されますが，それは初期の疑似アドレスを指定しま
     す．疑似アドレスは，通常のアドレスに続くカッコ内に表示されます．


   終了ステータスのゼロは成功を示し，ゼロ以外の値は失敗を示します．


File: coreutils-ja.info,  Node: Formatting file contents,  Next: Output of parts of files,  Prev: Output of entire files,  Up: Top

4 ファイルの内容の書式化
************************

以下のコマンドは，ファイルの内容を再書式化します．

* Menu:

* fmt invocation::              Reformat paragraph text.
* pr invocation::               Paginate or columnate files for printing.
* fold invocation::             Wrap input lines to fit in specified width.


File: coreutils-ja.info,  Node: fmt invocation,  Next: pr invocation,  Up: Formatting file contents

4.1 `fmt': 段落のテキストを再書式化する．
=========================================

`fmt'は，与えられた(最大)文字数(デフォルトは75)の出力行を生成
するために行を補充し繋げます．概要です．

     fmt [OPTION]... [FILE]...

   `fmt'は，指定されたFILE引数(または，与えられない場合は標
準入力)からファイルを読み込み，標準出力に書き出します．

デフォルトで，空白行，単語間のスペース，そして字下げは出力で維持されま
す．連続した入力行で字下げが異なるものは連結されません．入力のタブは展
開され，出力に書き込まれます．

   `fmt'は，文の終りで改行しようとし，文の最初の単語の後や文の最
後の単語の前での改行を避けようとします．"文の切れ目(sentence
break)"は段落の終り，または，`.?!'で終るすべて単語に，二つのスペー
スまたは行末が続くものと定義されていて，カッコや引用符の内部は無視され
ます．TeXのように，`fmt'は行の分割を選択する前に"段落"全
体を読み込みます．アルゴリズムは"Breaking Paragraphs Into Lines(段落
を行に区切る)"の変種です(Donald E. Knuth and Michael F. Plass,
`Software--Practice and Experience', 11 (1981), 1119-1184)．

   プログラムは以下のオプションを受け入れます．*Note Common
options::も参照 してください．

`-c'
`--crown-margin'
     "Crown margin"モード: 段落の最初の二行の字下げを保存し，それに続く
     それぞれの行の左の余白を，二行目の余白に揃えます．

`-t'
`--tagged-paragraph'
     "Tagged paragraph"モード: crown marginモードに似ていますが，段落の
     最初の行の字下が二行目の字下げと同じ場合，最初の行は一行の段落として扱
     われます．

`-s'
`--split-only'
     行の分割のみです．短い行を長い形式に連結しません．これはコードのサンプ
     ル行と，その他の"書式化された"テキストが醜く連結されることを妨げます．

`-u'
`--uniform-spacing'
     スペースの付け方を統一します．単語の間のスペースを一つのスペースに，そ
     して文の間のスペースを二つのスペースに減らします．

`-WIDTH'
`-w WIDTH'
`--width=WIDTH'
     出力ファイルをWIDTH文字(デフォルトは75)まで補充します．
     `fmt'は最初に，これより7%短い行にし，行の長さのバランスのため
     の空間を与えようとします．

`-p PREFIX'
`--prefix=PREFIX'
     PREFIX(空白で始めることも可能です)で始まる行のみ，書式化を適用し
     ます．prefixと前置されたあらゆる空白は，書式化のため取り除かれ，それぞ
     れの出力行に再び取り付けられます．一つの使用方法としては，ある種のプロ
     グラムのコメントの書式化があげられ，そこではコードは変化しません．


   終了ステータスのゼロは成功を示し，ゼロ以外の値は失敗を示します．


File: coreutils-ja.info,  Node: pr invocation,  Next: fold invocation,  Prev: fmt invocation,  Up: Formatting file contents

4.2 `pr': 印刷のためのファイルのページ化とコラム化
==================================================

`pr'は，それぞれのFILE(`-'は標準入力を意味します)や，
与えられない場合は標準入力をページ化し，オプションで複数列の書式での出
力を標準出力に書き出します．オプションで，全てのFILEを結合し一列
ごとに並列に全てを出力します．概要です．

     pr [OPTION]... [FILE]...

デフォルトで，五行のヘッダがそれぞれのページに出力されます．二行の空白
行．日付，ファイル名，そしてページ番号がある行．さらに二行は空白行です．
また，五行の空白行を持つフッタも出力します．`-F'オプションで，
三行のヘッダを出力します．最初の二行の空白行は削除されます．フッタは使
用されません．どちらの場合でもデフォルトのPAGE_LENGTHは66行です．
テキスト行のデフォルト数は56(`-F'が無い場合)から63(`-F'
がある場合)まで変化します．ヘッダのテキスト行は，`DATE STRING
PAGE'の形式で，行がPAGE_WIDTHいっぱいになるよ
うにSTRINGの周りにスペースが挿入されます．ここで，DATEは日
付(詳細は，`-D'や`--date-format'オプションを参照してくだ
さい)，STRINGはセンタリングされたヘッダ文字列，そしてPAGE
はページ番号を示します．`LC_MESSAGES'ロカールカテゴリはPAGE
の綴りに影響します．デフォルトのCロカールでは`Page NUMBER'
になり，NUMBERは十進数のページ番号です．

入力のフォームフィードは，出力で改ページとなります．複数のフォームフィー
ドは空のページを生成します．

   列は同じ幅で，オプションの文字列(デフォルトは`space')で分けられて
います．複数列の出力では，`-J'オプションを使用していない場合，
行は常にPAGE_WIDTH(デフォルトで72)で切り詰められます．単一列での
出力は，デフォルトでは切り詰められません．その場合，行を切り詰めるため
`-W'オプションを使用してください．

   以下の変更は，version 1.22iでなされ，それ以降の`pr'のバージョ
ンに適用されています．  - Brian
   * 小文字のLETTER OPTIONS(`-s'，`-w')には，より良い
     POSIX準拠のもので再定義されているものもあります．それ以外の
     場合での出力は，他のUnixに適合されたものもあります．これらの変更は，プ
     ログラムの以前のバージョンと互換性がありません．

   * NEW CAPITAL LETTERオプション(`-J'，`-S'，
     `-W')には，小文字のオプションでの予期せぬインターフェースを取り
     消すために導入されたものもあります．`-N'オプションと二番目の引
     数`+FIRST_PAGE'のLAST_PAGEで，より柔軟性が高くなります．入
     力ファイルのフォームフィード設定を詳細に扱うため，`-T'オプショ
     ンが必要になります．

   * 大文字のオプションは，小文字のものに優先します．

   * オプション引数には(`-s'，`-S'，`-e'，`-i'，
     `-n'と比較して)，(POSIX仕様で既に述べられた)前置され
     ているオプション文字と分離されている引数を指定することが不可能なものも
     あります．

   プログラムは以下のオプションを受け入れます．*Note Common
options::も参照 してください．

`+FIRST_PAGE[:LAST_PAGE]'
`--pages=FIRST_PAGE[:LAST_PAGE]'
     ページFIRST_PAGEから出力を開始し，LAST_PAGEで停止します．
     `:LAST_PAGE'が無い場合は，ファイルの終りを暗黙に指定します．
     飛ばされたページ数を計算している間，入力ファイルのそれぞれのフォーム
     フィードは，結果として新しいページになります．`+FIRST_PAGE'
     がある場合と無い場合のページの数え方は同じです．デフォルトで，入力ファ
     イルの最初のページでカウントを開始します(最初のページは出力されません)．
     行の番号付けは，`-N'オプションで変更してもかまいません．

`-COLUMN'
`--columns=COLUMN'
     それぞれ単一FILEを用いて，`-a'が使用されない場合は
     COLUMN列(デフォルトで1)の出力を生成し列を下へ向かって出力します．
     列の幅は，COLUMNが増加するに従い，自動的に減少します．
     PAGE_WIDTHを増加させるため，`-W/-w'を使用していない場合も
     同様です．このオプションは，いくつかの行を切り詰める可能性があります．
     それぞれのページの列の行数は平均化されます．オプション`-e'と
     `-i'は，複数のテキスト列の出力のためにあります．`-J'をと
     もに用いると，列の整列と行の切り詰めは停止します．十分な長さの行は，フ
     リーフィールド書式に組み込まれ，`-S'オプションはフィールドを分
     ける可能性があります．`-COLUMN'は`-m'オプションと
     ともに使用してはいけません．

`-a'
`--across'
     それぞれ単一FILEを用い，列を下ではなく横に出力します．
     `-COLUMN'オプションは，一列以上のCOLUMNで与える必要
     があります．列に適さないほど余りに長い場合，それは切り詰められます．

`-c'
`--show-control-chars'
     ハット表記で(例えば，`^G')を使用して制御文字を出力します．八進数
     のバックスラッシュ表記で，その他の印刷不可能な文字を表示します．デフォ
     ルトで，印刷不可能な文字は変更されません．

`-d'
`--double-space'
     ダブルスペースの出力です．

`-D FORMAT'
`--date-format=FORMAT'
     FORMATを使用してヘッダの日付を書式化し，それはコマンド`date
     +FORMAT'と同じ慣習を使用します．*Note date invocation::.
     `%'で始まる指示語以外，FORMAT内の文字は変更されずに出力され
     ます．ヘッダの日付の場所に，例えば`--date-format="Monday
     morning"'のような，任意の文字列を指定するために，このオプションを使用
     することが可能です．

     `POSIXLY_CORRECT'環境変数が設定されていない場合，日付の書式はデフォ
     ルトで`%Y-%m-%d %H:%M'です(例えば，`2001-12-04 23:59')．それ
     以外の場合，書式は`LC_TIME'ロカールカテゴリに依存し，デフォルトは
     `%b %e %H:%M %Y'(例えば，`Dec  4 23:59 2001')になります．

`-e[IN-TABCHAR[IN-TABWIDTH]]'
`--expand-tabs[=IN-TABCHAR[IN-TABWIDTH]]'
     入力のTABをスペースに展開します．オプションの引数
     IN-TABCHARは，入力のタブ文字(デフォルトはTAB文字)です．二番目の
     オプション引数IN-TABWIDTHは，入力タブ文字の幅(デフォルトは8)です．

`-f'
`-F'
`--form-feed'
     出力ページを分けるため，改行の代わりにフォームフィードを使用します．デ
     フォルトページの長さの66行は変更されません．しかし，ページごとのテキス
     トの行数はデフォルトの56行から63行に変更されます．

`-h HEADER'
`--header=HEADER'
     ヘッダのファイル名を中央揃えされた文字列HEADERで置換します．シェ
     ルを使用しているとき，HEADERを引用符で囲むべきで，`-h'と
     はスペースで分離すべきです．

`-i[OUT-TABCHAR[OUT-TABWIDTH]]'
`--output-tabs[=OUT-TABCHAR[OUT-TABWIDTH]]'
     出力上でスペースをTABに置換します．オプション引数
     OUT-TABCHARは出力されるタブ文字です(デフォルトはTAB文字です)．二
     番目のオプション引数OUT-TABWIDTHは出力されるタブ文字の幅(デフォ
     ルトで8)です．

`-J'
`--join-lines'
     十分な長さの行に統合します．列オプション`-COLUMN'， `-a
     -COLUMN'，または`-m'とともに使用します．
     `-W/-w'の行の切り詰めを停止します．列の整列は使用されません．
     `-S[STRING]'とともに使用してもかまいません．`-J'は
     (`-W'と`-S'とともに)，三列オプションの古い (POSIX
     準拠の)オプション`-w'と`-s'を解決するた めに導入されました．

`-l PAGE_LENGTH'
`--length=PAGE_LENGTH'
     ページの長さを，ヘッダ[とフッタ]の行を含めて，PAGE_LENGTH行(デフォ
     ルトで66)に設定します．PAGE_LENGTHが10以下(または`-F'が3
     以下)の場合，ヘッダとフッタは取り除かれ，入力ファイルの全てのフォーム
     フィード設定は，`-T'オプションが指定されたかのように無視されま す．

`-m'
`--merge'
     全てのFILEを並列に，それぞれの列に一つに統合して出力します．列に
     適さないほど行が長すぎる場合，それは`-J'オプションが使用されて
     いない限り切り詰められます．`--sep-string[=STRING]'を使用
     してもかまいません．FILEの(フォームフィード設定の)空のページは空
     の列を生成しますが，STRINGで印は付いたままです．結果として，連続
     した行の番号付けと，統合されたファイル全体を通じて印が付いた列になりま
     す．統合されても完全に空のページになるものは，区切りも行番号もありませ
     ん．デフォルトヘッダは`DATE PAGE'になり，真中にスペー
     スが挿入されます．これで中間の空白部分を満たすため，`-h'や
     `--header'オプションとともに使用してもかまいません．

`-n[NUMBER-SEPARATOR[DIGITS]]'
`--number-lines[=NUMBER-SEPARATOR[DIGITS]]'
     DIGITS桁の行の番号付けを提供します(デフォルトのDIGITSは5で
     す)．複数列の出力では，番号はそれぞれのテキスト列の最初のDIGITS
     列の位置や，`-m'出力のそれぞれの行だけに生成されます．単一列の
     出力では，番号はそれぞれの行に`-m'が行うように生成します．デフォ
     ルトの行カウントの開始は，入力ファイルの最初の行で始まります
     (`--page'オプションと`-N'オプションとは異なり，最初に印
     刷される行ではありません)．オプション引数NUMBER-SEPARATORは，以
     下に続くテキストと分離するために行数に後置される文字です．デフォルトの
     分離文字はTAB文字です．厳密な意味で，TABは常に単一の列の出力だけに出力
     されます．TAB幅はTAB位置で変化し，例えば，左のMARGIN
     が`-o'オプションで指定された場合は変化します．複数列出力のプロ
     パティは，`equal width of output columns' (POSIX指定)
     で与えられます．TAB幅は，最初の列の値で固定され，左の
     MARGINの値の違いでは変更されません．それは，固定数のスペースが常
     にNUMBER-SEPARATOR TABの位置に出力されることを意味します．タブ機
     能は出力位置に依存します．

`-N LINE_NUMBER'
`--first-line-number=LINE_NUMBER'
     最初のページに出力される最初の行(ほとんどの場合，入力ファイルの最初で
     はありません)を，数字のLINE_NUMBERで行のカウントを開始します．

`-o MARGIN'
`--indent=MARGIN'
     それぞれの行をMARGINスペースのマージン幅(デフォルトはゼロ)で字下
     げします．ページ全体の幅はマージンに`-W/-w'オプションの
     PAGE_WIDTH設定を加えたものになります．数字付の単一列の出力では
     (`-n'オプションとは異なり)制限されることによるオーバーフローが
     発生するかもしれません．

`-r'
`--no-file-warnings'
     引数FILEが開けなかったとき，警告メッセージを出力しません．(しか
     し，終了ステータスはゼロではありません．)

`-s[CHAR]'
`--separator[=CHAR]'
     単一文字CHARで列を分けます．CHARのデフォルトは，
     `-w'を用いないとTAB文字で，`-w'を用いると`no
     character'になります．`-s'が無い場合のデフォルトの分離文字は
     `space'に設定されます．`-s[char]'は，`-w'が設定され
     ていない場合，全ての三列オプション(`-COLUMN'|`-a
     -COLUMN'|`-m')の行の切り詰めを停止します．それは，
     POSIX準拠の公式なものです．

`-S STRING'
`--sep-string[=STRING]'
     出力の列を分離するためSTRINGを使用します．`-S'オプション
     は`-s'オプションと異なり，`-W/-w'オプションに対し効果が
     ありません．それは行の切り詰めや列の整列に効果がありません． `-S'
     を用いず，`-J'を用いると，`pr'はデフォルト
     の出力の分離文字のTABを使用します．`-S'や`-J'を用いない と，`pr'
     は`space'を使用します(`-S" "'と同じです)．
     `-SSTRING'を用るとき，STRINGを空にしてはいけません．
     STRINGが無い`--sep-string'は`--sep-string=""'と等 価です．

     古いシステムでは，`pr'は時代遅れのオプション
     `-S[STRING]'を代わりにサポートし，STRINGはオプショ
     ンになります．POSIX 1003.1-2001 (*note Standards
     conformance::)ではこの古い使用方法を許可していません．移植性がある空の
     STRINGを指定するため，`--sep-string'を使用してください．

`-t'
`--omit-header'
     それぞれのページに，通常のヘッダ[とフッタ]を出力せず，ページの底まで補
     充しません(空白行またはフォームフィードを用います)．ページ構造は生成さ
     れませんが，入力ファイルで設定されているフォームフィードは維持されます．
     前もって定義されたページ化は変更されません．`-t'や`-T'は，
     他のオプションとともに使用すると便利かもしれません．例えば，`-t
     -e4'は，入力ファイルのTAB文字を四つのスペースに展開しますが，それ以外
     の変更を行いません．`-t'の使用は`-h'に優先します．

`-T'
`--omit-pagination'
     ヘッダ[とフッタ]を出力しません．更に，入力ファイルのフォームフィード設
     定を全て削除します．

`-v'
`--show-nonprinting'
     出力できない文字を，八進数のバックスラッシュ表記で出力します．

`-w PAGE_WIDTH'
`--width=PAGE_WIDTH'
     複数のテキスト列出力に対してのみ，ページ幅をPAGE_WIDTH文字数に設
     定します(PAGE_WIDTHのデフォルトは72です)．`-s[CHAR]'は，
     デフォルトページ幅を停止し，すべての行を切り詰め，列を整列します．十分
     な長さの行は，列オプションの設定にかかわらずマージされます．
     PAGE_WIDTH設定が無い場合，おそらく単一列の出力になります．
     POSIX準拠の公式なものです．

`-W PAGE_WIDTH'
`--page_width=PAGE_WIDTH'
     ページ幅をPAGE_WIDTH文字に設定します．それは列オプションによらず
     有効です．`-J'が使用されない場合，テキスト行は切り詰められます．
     三列オプション(`-COLUMN'，`-a -COLUMN'，または
     `-m')の一つとともに用いた場合，列の整列は常に使用されます．セパ
     レータオプションの`-S'や`-s'は，`-W'オプションに
     効果がありません．デフォルトは72文字です．`-W PAGE_WIDTH'が
     無く，あらゆる列オプションが無い場合，行の切り詰めは行われません(下位
     互換を保つためと，よくある仕事に合わせるために定義されています)．それ
     は，`-W 72 -J'と等価です．ヘッダ行は常に切り詰められません．


   終了ステータスのゼロは成功を示し，ゼロ以外の値は失敗を示します．


File: coreutils-ja.info,  Node: fold invocation,  Prev: pr invocation,  Up: Formatting file contents

4.3 `fold': 指定された幅に合わせるため，入力行を折り曲げる
==========================================================

`fold'は，それぞれのFILE(`-'は標準入力を意味します)
や，与えられない場合は標準入力を，長い行を改行しながら標準出力に書き出
します．概要です．

     fold [OPTION]... [FILE]...

   デフォルトで，`fold'は80列以上の幅の行を改行します．出力は必要
な行数に分けられます．

   `fold'はデフォルトで画面の列を数えます．このため，タブは一列以
上に数えられ，バックスペースは列のカウント数を減らし，そして，キャリッ
ジリターンは列をゼロに設定します．

   プログラムは，以下のオプションも受け入れます．*Note Common
options::も参 照してください．

`-b'
`--bytes'
     列ではなくバイトを数え，そのため，タブ，バックスペースと，キャリッジリ
     ターンは，他の文字同様にそれぞれ一列カウント数を上げます．

`-s'
`--spaces'
     単語の境界で改行します．列は最後の空白の後で，最大の列の長さの前で改行
     されます．そのような空白行が行に含まれていない場合，行は最大の行幅で通
     常通り改行されます．

`-w WIDTH'
`--width=WIDTH'
     80の代わりに，WIDTH列の最大行幅を使用します．

     古いシステムでは，`fold'は時代遅れのオプション
     `-WIDTH'をサポートしています．POSIX 1003.1-2001 (*note Standards
     conformance::)では，これは許可されていません．代わり に`-w
     WIDTH'を使用してください．


   終了ステータスのゼロは成功を示し，ゼロ以外の値は失敗を示します．


File: coreutils-ja.info,  Node: Output of parts of files,  Next: Summarizing files,  Prev: Formatting file contents,  Up: Top

5 ファイルの一部の出力
**********************

以下のコマンドは，入力の一部を出力します．

* Menu:

* head invocation::             Output the first part of files.
* tail invocation::             Output the last part of files.
* split invocation::            Split a file into fixed-size pieces.
* csplit invocation::           Split a file into context-determined pieces.


File: coreutils-ja.info,  Node: head invocation,  Next: tail invocation,  Up: Output of parts of files

5.1 `head': ファイルの最初の部分を出力
======================================

`head'は，それぞれのFILEの最初の部分(デフォルトで十行)出
力します．ファイルが与えられていない場合や，`-'というFILEが
与えられているときは標準入力から読み込みます．概要です．

     head [OPTION]... [FILE]...

   一つ以上のFILEが指定されている場合，`head'は以下から成り
立つ一行のヘッダを出力します．
     ==> FILE NAME <==
   それぞれのFILEの前に出力されます．

   プログラムは以下のオプションを受け入れます．*Note Common
options::も参照 してください．

`-c N'
`--bytes=N'
     最初の行の代わりに，最初のNバイトを出力します．後置される
     `b'はNの512倍，`k'は1024倍，そして`m'は1048576倍
     になります．しかし，Nが`-'で始まる場合，それぞれのファイル
     の最後のNを出力します．

`-n N'
`--lines=N'
     最初のN行を出力します．しかし，Nが`-'で開始される場合，
     それぞれのファイルの最後のNを出力します．

`-q'
`--quiet'
`--silent'
     ファイル名のヘッダを出力しません．

`-v'
`--verbose'
     常にファイル名のヘッダを出力します．


   古いシステムでは，`head'は時代遅れのオプション
`-COUNTOPTIONS'をサポートし，それは最初に指定されて
いる場合だけ認識されます．COUNTは十進数の数値で，オプションで
`-c'でのサイズ指定文字(`b', `k', `m')や，行数を
意味する`l'，またはそれ以外のオプション文字(`cqv')が続きます． POSIX
1003.1-2001 (*note Standards conformance::)ではこれを
許可していません．代わりに`-c COUNT'や`-n COUNT' を使用してください．

   終了ステータスのゼロは成功を示し，ゼロ以外の値は失敗を示します．


File: coreutils-ja.info,  Node: tail invocation,  Next: split invocation,  Prev: head invocation,  Up: Output of parts of files

5.2 `tail': ファイルの最後の部分を出力
======================================

`tail'は，それぞれのFILEの最後の部分(デフォルトで十行)出
力します．ファイルが与えられていない場合や，`-'というFILEが
与えられているときは標準入力から読み込みます．概要です．

     tail [OPTION]... [FILE]...

   一つ以上のFILEが指定されている場合，`tail'は以下から成り
立つ一行のヘッダを出力します．
     ==> FILE NAME <==
   それぞれのFILEの前に出力されます．

   GNU `tail'は，任意の量のデータを出力することが可能です
(`tail'の他のバージョンにはできないものもあります)．ファイルを
逆順にすることはファイルの終りを出力する作業とは全く異なるので，
`-r'オプション(逆順に出力)もありません．BSD `tail'
(`-r'があるものの一つ)は，最大でそのバッファの大きさまで，通常
32KiBのファイルを逆順にすることが可能なだけです．ファイルを逆順にする
より信頼性のある用途が広い方法は，GNU `tac'コマンドです．

   あらゆるオプション引数が，`+'で始まる数字Nの場合，
`tail'はファイルの終りの代わりに，それぞれのファイルの最初から
N番目の項目で出力を開始します．

   プログラムは以下のオプションを受け入れます．*Note Common
options::も参照 してください．

`-c BYTES'
`--bytes=BYTES'
     最後の行の代わりに，最後のBYTESバイトを出力します．後置される
     `b'はBYTESの512倍，`k'は1024倍，そして`m'は 1048576倍になります．

`-f'
`--follow[=HOW]'
     ファイルが増大している可能性があるため，ファイルの終りから，それ以降の
     文字を読み込むことを永久に繰り返します．このオプションは，パイプから読
     み込まれているとき無視されます．一つ以上のファイルが与えられている場合，
     出力されてるファイルを示すため，異なるファイルから出力を得るときはいつ
     でも，`tail'がヘッダを出力します．

     このオプションでは，ファイルを追跡する方法を指定する方法が二つあります
     が，その違いは，追跡しているファイルが削除されたり名前を変更されたりし
     たとき通知可能だということだけです．リンクが無くなった後でも，増え続け
     るファイルの終りの追跡を続けたい場合は，`--follow=descriptor'を
     使用してください．これはデフォルトの動作ですが，回転(rotate)される(削
     除や名前の変更がなされ，再び開かれる)ログファイルを追跡しているときは
     不便です．その場合，他のプログラムにより削除され再作成されたかどうかを
     周期的に見て，再び開かれる指名されたファイルを追跡するため，
     `--follow=name'を使用してください．

     使用している方法にかかわらず，追跡しているファイルが縮まっていると決定
     された場合，`tail'はファイルが切り詰められたことを告げるメッセー
     ジを出力し，新たに決定された終端からファイルの終りを再追跡しはじめます．

     ファイルが削除されたとき，`tail'の動作は名前で続けるか記述子で
     続けるかに依存します．名前で続けるとき，`tail'はファイルが削除
     されたことを検出し，その影響のメッセージを与えることが可能で，
     `--retry'が指定されている場合，ファイルが再び現れたかどうかを見
     るため周期的な調査を続けるでしょう．記述子で続けるとき，`tail'
     はファイルのリンクが切れたり名前が変更されたことを検出せず，メッセージ
     を出力しません．ファイルは既に元の名前でアクセスできませんが，まだ増加
     しているかもしれません．

     オプション値の`descriptor'と`name'はオプションの長い形式での
     み指定でき，`-f'では指定できません．

`-F'
     このオプションは`--follow=name --retry'と同じです．すなわち，
     `tail'は削除されたときファイルを再び開こうとします．これが失敗
     しても，`tail'は再びアクセス可能になるまで挑戦し続けます．

`--retry'
     このオプションは，名前で続けるときだけ意味があります．このオプションが
     無い場合，存在していないまたはアクセスできないファイルに`tail'
     が遭遇したとき，それはその事実を報告し再び調査しません．

`--sleep-interval=NUMBER'
     繰り返しの間の待ち時間の秒数を変更します(デフォルトは1.0秒)．待ってい
     る間，指定された全てのファイルの大きさが変ったかどうか調査します．
     `tail'の歴史的な実装では，NUMBERを整数にする必要がありま
     した．しかし，GNU `tail'は(小数部の前にピリオドを使用している)
     任意の浮動小数点の数値を受け入れます．

`--pid=PID'
     名前または記述子で続ける場合，全てのFILE引数に唯一書き込んでいる
     プロセスID PIDを指定してもかまいません．そして，プロセスが終了し
     た少し後で`tail'も終了します．これは書き込んでいるものと
     `tail'プロセスが同じマシンで動作している場合のみ正確に動作しま
     す．例えば，ファイルにビルドの出力を保存したりファイルが大きくなるのを
     見たりするため`make'と`tail'を以下のように呼び出し，ビ
     ルドが完了したとき`tail'の処理は終了します．このオプションを用
     いない場合，`tail -f'プロセスを自分で停止する必要があります．
          $ make >& makerr & tail --pid=$! -f makerr
     使用中でない，または，`tail'されているファイルに書き込んでいる
     プロセスに対応しないPIDを指定した場合，`tail'はあらゆる
     FILEの増加が終了するよりかなり前に終了したり，実際に書き込んでい
     るものが終了してしばらくしても終了しないかもしれません．`--pid'
     はシステムによってはサポートできないことに注意してください．その状況で
     は，`tail'は警告を出力します．

`--max-unchanged-stats=N'
     名前でファイルを`tail'しているとき，N(デフォルトで
     n=5)回連続して大きさ
     が同じ場合，ファイル名が以前と同じデバイス/inode番号の組に関連している
     かどうかを決定するため，ファイルに対して`open'/`fstat'を実行
     します．回転(rotate)されているログファイルを追跡しているとき，前回に回
     転(rotate)した行を`tail'が出力するときと，新しいログファイルで
     蓄積された行を出力するときの間は，おそらく数秒になります．このオプショ
     ンは，名前で追跡しているときのみ意味があります．

`-n N'
`--lines=N'
     最後のN行出力します．

`-q'
`--quiet'
`--silent'
     ファイル名のヘッダを出力しません．

`-v'
`--verbose'
     常にファイル名のヘッダを出力します．


   古いシステムでは，`tail'は時代遅れのオプション
`-COUNTOPTIONS'をサポートし，それは最初に指定されて
いる場合だけ認識されます．COUNTは十進数の数値で，オプションで
`-c'でのサイズ指定文字(`b'，`k'，`m')や，行数を
意味する`l'，またはそれ以外のオプション文字(`cfqv')が続きま
す．古いシステムには，`-+COUNT'と同じ意味がある時代遅れの
オプション`+COUNT'をサポートしているものもあります． POSIX 1003.1-2001
(*note Standards conformance::)ではこれら
を許可していません．代わりに`-c COUNT'や`-n COUNT'を使用してください．

   終了ステータスのゼロは成功を示し，ゼロ以外の値は失敗を示します．


File: coreutils-ja.info,  Node: split invocation,  Next: csplit invocation,  Prev: tail invocation,  Up: Output of parts of files

5.3 `split': ファイルを固定サイズの部分に分割
=============================================

`split'は，INPUT(何も与えられなかったり，INPUTが
`-'の場合は標準入力)の連続したセクションを含む出力ファイルを生成
します．概要です．

     split [OPTION] [INPUT [PREFIX]]

   デフォルトで，`split'はINPUTの1000行(または，最後のセク
ションでは残り)を，それぞれの出力ファイルに書き込みます．

   出力ファイルの名前はPREFIX (デフォルトは`x')にグループ文字
(デフォルトで`aa'，`ab'，...)が続くものから成り立ってい
て，それで，伝統的なファイル名の順番で出力ファイルをソートし結合したも
のが，元の入力ファイルを生成するようになっています．出力ファイル名を使
い切った場合，`split'は作成された出力ファイルを削除せずにエラー
を報告します．

   このプログラムは以下のオプションも受け入れます．*Note Common
options::も 参照してください．

`-a LENGTH'
`--suffix-length=LENGTH'
     長さLENGTHの接尾子を使用します．デフォルトのLENGTHは2です．

`-l LINES'
`--lines=LINES'
     INPUTのLINES行をそれぞれの出力ファイルに書き込みます．

     古いシステムでは，`split'は時代遅れのオプション
     `-LINES'をサポートしています．POSIX 1003.1-2001 (*note Standards
     conformance::)ではこれを許可していません．代わりに `-l
     LINES'を使用してください．

`-b BYTES'
`--bytes=BYTES'
     INPUTの最初のBYTESバイトを，それぞれの出力ファイルに書き込
     みます．`b'の後置はBYTESの512倍，`k'は1024倍，そして
     `m'は1048576倍です．

`-C BYTES'
`--line-bytes=BYTES'
     BYTESバイトを越えないINPUTの完全な行を，できるだけ多くそれ
     ぞれの出力ファイルに書き込みます．BYTESバイトより長い行に対して
     は，行のBYTESバイトより少ない部分が残るまで，それぞれの出力ファ
     イルにBYTESバイト書き込み，それから通常通りに続けます．
     BYTESは`--bytes'オプションに対するものと同じ書式です．

`-d'
`--numeric-suffixes'
     小文字ではなく，数字の接尾子を使用します．

`--verbose'
     それぞれの出力ファイルが開かれる直前に，標準エラー出力に状態を書き込み
     ます．


   終了ステータスのゼロは成功を示し，ゼロ以外の値は失敗を示します．


File: coreutils-ja.info,  Node: csplit invocation,  Prev: split invocation,  Up: Output of parts of files

5.4 `csplit': ファイルを文脈で決定された部分に分割
==================================================

`csplit'は，INPUT(INPUTが`-'の場合は標準入力)
のセクションを含む，ゼロ以上の出力ファイルを作成します．概要です．

     csplit [OPTION]... INPUT PATTERN...

   出力ファイルの内容は，後で詳述するPATTERN引数で決定されます．
PATTERN引数が入力ファイルに存在しない行を参照する場合，エラーが
発生します(例えば，残っている行が与えられた正規表現にマッチしない場合)．
全てのPATTERNがマッチした後，残りの入力は一つの最後の出力ファイ
ルにコピーされます．

   デフォルトで，`csplit'は，それぞれの出力ファイルが作成された後，
バイト数をそのファイルに書き込みます．

   PATTERN引数の形式は以下の通りです．

`N'
     N行までの入力を含む出力ファイルを作成しますが，N行は含みま
     せん．繰り返し数が続く場合，それぞれの繰り返しに対し，入力ファイルの次
     のN行を含む出力ファイルも作成します．

`/REGEXP/[OFFSET]'
     REGEXPにマッチするものを含む入力ファイルの次の行まで，現在の行
     (ただし，マッチは含まれない)を含む出力ファイルを作成します．オプション
     のOFFSETは整数です．与えられた場合，マッチした行までの入力(ただ
     し，マッチは含まれない)に，OFFSET加えた，または引いた入力まで出
     力ファイルに書き出され，その後の行は入力の次の部分になります．

`%REGEXP%[OFFSET]'
     前の形式に似ていますが，出力ファイルを作成しないので，入力ファイルの部
     分は効率的に無視されます．

`{REPEAT-COUNT}'
     前のパターンをREPEAT-COUNT回余分に繰り返します．
     REPEAT-COUNTは正の整数，またはアスタリスクになり，それは入力が使
     い果たされるのに必要なだけ繰り返すことを意味します．


   出力ファイル名は，前置(デフォルトで`xx')とそれに続く接尾子から成
り立ちます．デフォルトで接尾子は二桁の十進数で，`00'から`99'
まで順番に上昇します．あらゆる状況で，ファイル名の順番でソートされた出
力ファイルを連結すると，元の入力ファイルを生成します．

   デフォルトで，`csplit'がエラーや，ハングアップ，中断，終了，ま
たは終端シグナルを検出した場合，それまでに存在する作成されたあらゆる出
力ファイルを削除します．

   プログラムは以下のオプションを受け入れます．*Note Common
options::も参照 してください．

`-f PREFIX'
`--prefix=PREFIX'
     出力ファイルの接尾子として，PREFIXを使用します．

`-b SUFFIX'
`--suffix=SUFFIX'
     出力ファイル名の接尾子としてSUFFIXを使用します．このオプションが
     指定されている場合，接尾子の文字列は，一つだけの`printf(3)'形式の
     変換での指定を含んでいる必要があり，おそらく，書式指定のフラグ，フィー
     ルドの幅，精密さの指定，またはこれら全ての修飾語を含みます．フォーマッ
     ト文字は，二進数の整数の引数を可読なものに変換する必要があります．この
     ため，`d'，`i'，`u'，`o'，`x'，そして`X'
     の変換は可能です．完全なSUFFIXは，それぞれの個別な出力ファイルに
     対し，ファイル名の接尾子を順番に形成するため(現在の出力ファイル数とと
     もに) `sprintf(3)'に与えられます．このオプションを使用した場合，
     `--digits'オプションは無視されます．

`-n DIGITS'
`--digits=DIGITS'
     デフォルトの2の代わりにDIGITS桁の長さの数字を含む出力ファイル名
     を使用します．

`-k'
`--keep-files'
     エラーが検出された場合でも出力ファイルを削除しません．

`-z'
`--elide-empty-files'
     長さゼロの出力ファイルの生成を抑制します．(入力ファイルのセクションを
     分離するものがそれぞれのセクションの最初の行に印を付ける状況では，この
     オプションを使用しない限り，最初の出力ファイルは，通常長さゼロのファイ
     ルになります．)出力ファイルの順番は，このオプションが指定されていると
     きでさえ，0から始まる連続したものになります．

`-s'
`-q'
`--silent'
`--quiet'
     出力ファイルの大きさを出力しません．


   終了ステータスのゼロは成功を示し，ゼロ以外の値は失敗を示します．


File: coreutils-ja.info,  Node: Summarizing files,  Next: Operating on sorted files,  Prev: Output of parts of files,  Up: Top

6 ファイルの要約
****************

以下のコマンドは，ファイルの内容全体を表現するいくつかの数字を生成しま
す．

* Menu:

* wc invocation::               Print newline, word, and byte counts.
* sum invocation::              Print checksum and block counts.
* cksum invocation::            Print CRC checksum and byte counts.
* md5sum invocation::           Print or check message-digests.


File: coreutils-ja.info,  Node: wc invocation,  Next: sum invocation,  Up: Summarizing files

6.1 `wc': 改行，単語，そしてバイト数を出力
==========================================

`wc'は，それぞれの与えられたFILEや，与えられなかった場合
や`-'のFILEに対し，バイト数，文字，空白で区切られた単語，そ
して改行を数えます．概要です．

     wc [OPTION]... [FILE]...

   `wc'は，それぞれのファイルに対し，数えたものを一行出力し，ファ
イルが引数として与えられた場合，数に続けてファイル名を出力します．一つ
以上のFILEが与えられた場合，`wc'は，ファイル名
`total'と共に，累積された数を最終行に出力します．数は，以下の順序
で出力されます．改行，単語，文字，バイトです．それぞれの計数結果は，数
字とファイル名の行が列にうまく並ぶように，右寄せで，それぞれのフィール
ドの間に少なくとも一つのスペースを入れて出力します．計数結果のフィール
ドの幅は，入力に依存して変化するので，特定のフィールドの幅に依存すべき
ではありません．しかし，GNUの拡張として，一つの計数結果だけ
を出力する場合，前置されるスペースを用いずに出力されることが保証されま
す．

   デフォルトで，`wc'は三つの数すべてを出力します．オプションで，
出力したい数のみを指定することができます．オプションは，前に与えられた
ものを元に戻すことはできません．そのため，以下のようにした場合を考えま
す．

     wc --bytes --words

これは，バイト数と単語の数の両方を出力します．

   `--max-line-length'オプションを用いた場合，`wc'はファイ
ルごとの最長の行の長さを出力し，一つ以上のファイルがある場合，それらの
長さの(合計ではなく)最大を出力します．

   プログラムは以下のオプションも受け入れます．*Note Common
options::も参照し てください．

`-c'
`--bytes'
     バイト数のみ出力します．

`-m'
`--chars'
     文字数のみ出力します．

`-w'
`--words'
     単語数のみ出力します．

`-l'
`--lines'
     改行数のみ出力します．

`-L'
`--max-line-length'
     最長行の長さのみ出力します．


   終了ステータスのゼロは成功を示し，ゼロ以外の値は失敗を示します．


File: coreutils-ja.info,  Node: sum invocation,  Next: cksum invocation,  Prev: wc invocation,  Up: Summarizing files

6.2 `sum': チェックサムとブロック数を出力
=========================================

`sum'は，与えられたそれぞれのFILE，または，与えられない
場合や`-'のファイルが与えられた場合は標準入力の16ビットのチェック
サムを計算します．概要です．

     sum [OPTION]... [FILE]...

   `sum'は，それぞれのFILEのチェックサムに続けて，ファイル
のブロック数を(切り上げで)出力します．一つ以上のFILEが与えられた
場合，ファイル名も出力します(デフォルト)．(`--sysv'オプションを
指定した場合，少なくとも一つのファイル引数があるときは，対応するファイ
ル名が出力されます．)

   デフォルトで，GNU `sum'は，BSD `sum'と互換性のあ
るアルゴリズムを用いて計算し，ファイルサイズを1024バイトブロックの単位
で出力します．

   プログラムは以下のオプションも受け入れます．*Note Common
options::も参照 してください．

`-r'
     デフォルト(BSD互換)のアルゴリズムを使用します．このオプションは，
     System V `sum'との互換性も含みます．`-s'を与えない限り，
     効果はありません．

`-s'
`--sysv'
     System V `sum'のデフォルトと互換のアルゴリズムを使用して，チェッ
     クサムを計算し，512バイトブロックの単位でファイルサイズを出力します．


   `sum'は，互換性のために提供されています．新しいアプリケーショ
ンでは，`cksum'プログラム(次のセクションを参照)が望ましいでしょ う．

   終了ステータスのゼロは成功を示し，ゼロ以外の値は失敗を示します．


File: coreutils-ja.info,  Node: cksum invocation,  Next: md5sum invocation,  Prev: sum invocation,  Up: Summarizing files

6.3 `cksum': CRCチェックサムとバイトカウントを出力
==================================================

`cksum'は，与えられたそれぞれのFILE，または，与えられな
い場合や`-'のファイルが与えられた場合は標準入力の周期的な冗長性の
調査(CRC)のチェックサムを計算します．概要です．

     cksum [OPTION]... [FILE]...

   `cksum'は，ファイルのバイト数と一緒に，それぞれのファイルに対
し，CRCチェックサムと，引数が与えられていない場合以外はファイル名を出
力します．

   `cksum'は，通常，信用できない手段(例えば，ネットニュース)で転
送されたファイルが切り詰められていないか，受信したファイルの
`cksum'出力と元ファイルの`cksum'出力(通常は配布物で与
えられます)を比較することで確認するために使用します．

   CRCアルゴリズムは，POSIX標準で指定されました． BSDやSystem V
`sum'アルゴリズムとは互換性がありません(前のセクションを参照し
てください)．それはより強固です．

   オプションは`--help'と`--version'だけです．*Note Common options::.

   終了ステータスのゼロは成功を示し，ゼロ以外の値は失敗を示します．


File: coreutils-ja.info,  Node: md5sum invocation,  Prev: cksum invocation,  Up: Summarizing files

6.4 `md5sum': メッセージダイジェストの出力と調査
================================================

`md5sum'は，それぞれ指定されたFILEに対し，128-bitチェッ
クサム(または"fingerprint"，または"message-digest")を計算しま
す．FILEが`-'で指定されたり，ファイルが与えられていない場合
は，`md5sum'は標準入力のチェックサムを計算します．
`md5sum'は，ファイルとチェックサムが一貫しているかどうか決定す
ることも可能です．概要です．

     md5sum [OPTION]... [FILE]...
     md5sum [OPTION]... --check [FILE]

   それぞれのFILEに対し，`md5sum'は，MD5チェックサム，入力ファ
イルがバイナリかテキストかを示すフラグ，そしてファイル名を出力します．
FILEが無い，または`-'として指定されている場合，標準入力を読 み込みます．

   プログラムは以下のオプションも受け入れます．*Note Common
options::も参照 してください．

`-b'
`--binary'
     全ての入力ファイルをバイナリとして扱います．このオプションは，Unixシス
     テムではバイナリとテキストでファイルに差が無いので効果がありません．こ
     のオプションは，内部と外部での文字表示が異なるシステムでは便利です．
     MS-DOSとMS-Windowsでは，これはデフォルトです．

`-c'
`--check'
     ファイル名とチェックサム情報を，単一のFILE(または，FILEが
     指定されない場合は標準入力)から読み込み，それぞれの指定された名前のファ
     イルと対応するチェックサムデータが対応しているかどうか報告します．
     `md5sum'のこのモードでの入力は，通常，`md5sum'を実行して
     生成されたチェックサムで，それは以前の出力です．それぞれの入力の有効な
     行は，MD5チェックサムから成り立ち，バイナリ/テキストフラグと，ファイル
     名です．バイナリファイルは`*'で，テキストは` 'で印が付きます．
     それぞれのそのような行に対し，`md5sum'は，指名されたファイルを
     読み込み，そのMD5チェックサムを計算します．そして，計算されたメッセー
     ジダイジェストが，ファイル名を持つ行の一つとマッチしない場合，ファイル
     にはテストに失敗したというメモが付きます．それ以外の場合，ファイルは調
     査をパスします．デフォルトで，それぞれの有効な行に対し，指名されたファ
     イルが調査を通過したかどうかを示す一行を，標準出力に書き出します．全て
     の調査の実行後，失敗があった場合，警告を標準エラーに出力します．出力を
     抑制するために，`--status'オプションを使用してください．リスト
     アップされたファイルに，開いたり読み込んだりすることが不可能なものがあ
     る場合，有効な行が関連するファイルとMD5チェックサムに対応しない場合，
     または，有効な行が見つからない場合，`md5sum'はゼロ以外のステー
     タスで終了します．それ以外の場合は，正しく終了します．

`--status'
     このオプションは，チェックサムの照合時のみ便利です．チェックサムを照合
     するとき，デフォルトのファイルに対し一行の診断を生成せず，あらゆる失敗
     を要約する警告を出力しません．ファイルを開くあるいは読み込む際の失敗は，
     標準エラーに個別の診断結果を出力します．リストアップされたファイルがす
     べて読み込み可能で，対応するMD5チェックサムと対応している場合，正しく
     終了します．それ以外の場合，失敗があることを示すステータスコードで終了
     します．

`-t'
`--text'
     全ての入力ファイルを，テキストファイルとして扱います．このオプションは
     `--binary'の反対です．

`-w'
`--warn'
     チェックサムを照合するとき，不適切に書式化されたMD5チェックサム行につ
     いて警告します．このオプションは，入力の調査で，全てではなくいくつかの
     行が有効な場合のみ便利です．


   終了ステータスのゼロは成功を示し，ゼロ以外の値は失敗を示します．


File: coreutils-ja.info,  Node: Operating on sorted files,  Next: Operating on fields within a line,  Prev: Summarizing files,  Up: Top

7 ソートされたファイルの処理
****************************

以下のコマンドは，ソートされたファイルで動作する(あるいはそれを生成す
る)コマンドです．

* Menu:

* sort invocation::             Sort text files.
* uniq invocation::             Uniquify files.
* comm invocation::             Compare two sorted files line by line.
* ptx invocation::              Produce a permuted index of file contents.
* tsort invocation::            Topological sort.
* tsort background::            Where tsort came from.


File: coreutils-ja.info,  Node: sort invocation,  Next: uniq invocation,  Up: Operating on sorted files

7.1 `sort': テキストファイルをソート
====================================

`sort'は，与えられたファイル，または与えられない場合や，
`-'のFILEの場合は標準入力からの全ての行を，ソート，統合，ま
たは比較します．デフォルトで，`sort'は結果を標準出力に書き出し
ます．概要です．

     sort [OPTION]... [FILE]...

   `sort'は，処理時に三つのモードがあります．ソート(デフォルト)，
統合，そしてソートされてることの調査です．以下のオプションで処理モード
を変更します．

`-c'
`--check'
     与えられたファイルが，すでにソートされているかどうか調査します．全てが
     ソートされていない場合，エラーメッセージを出力し，1のステータスで終了
     します．それ以外の場合は正常に終了します．

`-m'
`--merge'
     与えられたファイルを，グループ化してソートすることで，統合します．それ
     ぞれの入力ファイルは，個別にソートされている必要があります．それは常に，
     統合ではなくソートのために動作します．統合は，それが動作する状況ではよ
     り高速なため提供されています．


   行の組は，以下のように比較されます．キーフィールドが指定された場合，
`sort'は，それぞれのフィールドの組を，コマンドラインで指定され
た順番で，関連する順序オプションで，差が見つかるまで，またはフィールド
の残りが無くなるまで比較します．指定されない場合は，すべて比較する際，
`LC_COLLATE'ロカールで指定された，文字の順番を使用します． (1)

   大域的なオプション`bdfgiMnr'が与えられて，キーフィールドが指定さ
れていない場合，`sort'は大域的なオプションに従い，行全体を比較 します．

   最終的に，全てのキーが同じとき(または，順序オプションが全く指定されて
いない場合)，最後の手段として，`sort'は行全体を比較します．最
後の手段は，`--reverse'(`-r')の大域的なオプションを尊重
して比較します．`--stable'(`-s')オプションは，この最後の
手段では利用できず，それは，全てのフィールドの比較が同じになる行は，元
の相対的な順序のままにするためです．フィールドや大域的なオプションが指
定されない場合，`--stable'(`-s')は効果がありません．

   GNU `sort'は，(全てのGNUユーティリティで指定されるよ
うに)入力行の長さの制限や，行で許可されるバイト数の限界がありません．
更に，入力ファイルの最終バイトが改行でない場合，GNU
`sort'は，黙ってそれを供給します．行の後ろの改行は，比較の目的
では行の一部です．

   終了ステータスは以下のようになります．
     0 エラーがない場合
     1 `-c'オプションとともに呼び出され，入力が適切にソートされていない場合
     2 エラーが生じた場合

   環境変数`TMPDIR'が設定されている場合，`sort'は，一時ファイ
ルのディレクトリとして，`/tmp'の代わりにその変数をディレクトリと
して使用します．`--temporary-directory'(`-T')オプション
は，順序的に環境変数に優先します．

以下のオプションは，出力行の順序に影響します．それらは，大域的，または
キーフィールドの一部として指定してもかまいません．キーフィールドが指定
されていない場合，大域的なオプションは行全体の比較に対して適用されます．
それ以外では，大域的なオプションは，それ自身オプションが指定されていな
いキーフィールドに継承されます．以前のPOSIXのバージョンの
`sort'では，大域的なオプションはキーフィールドだけに影響するの
で，移植性の高いシェルスクリプトでは大域的なオプションを最初に指定すべ
きです．

`-b'
`--ignore-leading-blanks'
     それぞれの行でソートするキーを探すとき，前の空白を無視します．
     `LC_CTYPE'ロカールで文字形式を決定します．

`-d'
`--dictionary-order'
     "phone directory"の順序でソートします．ソート時に，文字，数字，そ
     して空白以外の全ての文字は無視されます．`LC_CTYPE'ロカールで文字形
     式を決定します．

`-f'
`--ignore-case'
     比較時に，小文字を大文字と同じに扱い，例えば，`b'と`B'は同等
     にソートされます．`LC_CTYPE'ロカールで文字形式を決定します．

`-g'
`--general-numeric-sort'
     それぞれの行のプレフィクスを倍精度浮動小数点の数に変換するため，標準C
     関数`strtod'を使用し，数値的なソートをします．これで，
     `1.0e-34'と`10e100'のような浮動小数点の数を，科学的な表記方
     で指定できます．`LC_NUMERIC'ロカールで小数点文字を決定します．オー
     バーフローや，アンダーフロー，変換エラーは報告しません．以下の順番を使
     用します．

        * 数字で始まらない行(全て同じと考えます)．

        * NaN("Not a
          Number"値で，IEEEでの算術的な浮動小数点です)一貫している
          がマシンに依存した順番．

        * 負の無限大．

        * 数字の順番に並んだ有限数(-0と+0は等しい)．

        * 正の無限大．

     他に選択肢が無い場合のみ，このオプションを使用してください．
     `--numeric-sort'(`-n')よりはるかに遅く，浮動小数点に変換
     するとき，情報を失うはずです．

`-i'
`--ignore-nonprinting'
     印刷不可能な文字を無視します．`LC_CTYPE'ロカールで文字形式を決定し
     ます．このオプションは，より強力な`--dictionary-order'
     (`-d')オプションも与えられている場合，効果がありません．

`-M'
`--month-sort'
     任意の量の空白から成り立つ最初の文字列に月の名前の省略が続くものは，大
     文字のまま保持され，`JAN' < `FEB' < ... < `DEC'の順
     に比較されます．無効な名前は，有効な名前の下になります．`LC_TIME'
     ロカールで，月のつづりを決定します．

`-n'
`--numeric-sort'
     数値的なソートです．数字でそれぞれの行を開始します．特に，オプションの
     空白，オプションの`-'記号，そして，1000で区切られたり，小数点文字
     とゼロ以上の桁を続けることが可能な，ゼロ以上の桁から成り立ちます．
     `LC_NUMERIC'ロカールで，小数点文字と1000の区切りを指定します．

     数値的なソートは，浮動小数点の数値を表現する文字列を比較するため，慣習
     的とは思われない手法を使用します．最初にそれぞれの文字列をCの
     `double'形式に変換してそれらの値を比較するのではなく，
     `sort'は，二つの文字列の小数点文字を一列に並べて，一度に文字の
     列を比較します．このアプローチを使う一つの利益は速度です．実際には，二
     つの対応する文字列を倍精度浮動小数点に(または，文字列を整数に)変換し，
     倍精度浮動小数点を比較するより効率的です．更に，精度による損失はありま
     せん．それぞれの文字列を比較前に`double'に変換すると，ほとんどの
     システムで16桁程度に精度が制限されるでしょう．

     前置される`+'も，指数表記も認識されません．そのような文字列を数値
     的に比較するために，`-g'オプションを使用してください．

`-r'
`--reverse'
     比較の結果を逆順にし，より大きなキー値を持つ行が，出力では後方なるので
     はなく，前方に現われるようになります．


   その他のオプションは以下の通りです．

`-o OUTPUT-FILE'
`--output=OUTPUT-FILE'
     標準出力の代わりに，OUTPUT-FILEに出力を書き出します．必要があれ
     ば，`sort'はOUTPUT-FILEを開く前に入力を読み込むので， `sort -o F
     F'と`cat F | sort -o F'のようなコマンドを使用する
     ことで，同じファイルを安全にソートすることが可能です．

     より新しいシステムでは，`POSIXLY_CORRECT'が設定されている場合，
     `-o'を入力ファイルの後に書くことができません．例えば， `sort F -o
     F'です．移植性の高いスクリプトでは，すべての入力ファイ ルの前に`-o
     OUTPUT-FILE'を指定すべきです．

`-s'
`--stable'
     条件によっては実行される最後の手段の比較を利用不可能にし，
     `sort'を安定させます．デフォルトで，コマンドラインオプションに
     よって影響する順番として行の比較が同じになるとき，行全体をキーとして，
     順序付けオプションが指定されていない状態で，"最後の手段の比較
     (last-resort
     comparison)"を使用して，これらの行に順番を付けます．しか
     し，順序指定として`--reverse' (`-r')が指定されている場合，
     最後の手段の比較は`--reverse'を使用します．あらゆる状況で，順序
     付けオプションが指定されていないときや，`--reverse'だけが指定さ
     れているとき，最後の手段の比較は実行されません．

`-S SIZE'
`--buffer-size=SIZE'
     与えられたSIZEのメインメモリのソートバッファを使用します．デフォ
     ルトで，SIZEは1024バイト単位です．`%'を追加すると，
     SIZEを物理メモリのパーセントとして解釈します．`K'を追加する
     と，SIZEを1024倍(デフォルト)にし，`M'は1,048,576倍，
     `G'は1,073,741,824倍などのようになり，以下`T'，`P'，
     `E'，`Z'，そして`Y'も同様です．`b'を追加すると，
     SIZEは倍数表現ではなくバイト数として解釈されます．

     このオプションで，デフォルトより大きいまたは小さいソートバッファを用い
     て開始させることで，`sort'のパフォーマンスの改善することが可能
     です．しかし，このオプションは初期のバッファサイズだけに影響します．
     SIZEより大きな入力行を`sort'が見つけた場合，バッファは
     SIZE以上に大きくなります．

`-t SEPARATOR'
`--field-separator=SEPARATOR'
     それぞれの行からソートキーを検索するとき，フィールドセパレータとして，
     文字SEPARATORを使用します．デフォルトで，フィールドは，空白でな
     い文字と空白文字の間の空の文字列で分離されます．すなわち，入力行
     ` foo bar'が与えられた場合，`sort'はそれを，フィール
     ド` foo'と` bar'に分離します．フィールドセパレータは，
     フィールドの前やフィールドの後の部分とは考えられません．しかし，
     `-k 2'のように行末まで展開されるソートフィールドや，`-k
     2,3'のように範囲があるソートフィールドは，範囲の終点に存在するフィール
     ドセパレータを保持します．

     フィールド分離文字としてゼロバイト(ASCII NUL (Null)文字)
     を指定するために，二文字の文字列`\0'，例えば`sort -t '\0''を
     使用して下さい．

`-T TEMPDIR'
`--temporary-directory=TEMPDIR'
     一時ファイルを保存するためディレクトリTEMPDIRを使用し，それは
     `TMPDIR'環境変数に優先します．このオプションが一回以上与えられた場
     合，一時ファイルはすべて与えられたディレクトリに保存されます．入出力が
     拘束されるほどの大量のソートやマージを行なう場合，異なるディスクやコン
     トローラにあるディレクトリを指定するためにこのオプションを使用すること
     で，パフォーマンスが改善するはずです．

`-u'
`--unique'
     通常，比較結果が等しい行の最初の行のみを出力します．
     `--check'(`-c')オプションに対し，比較結果が等しい連続し
     た行の対が無いことを調査します．

`-k POS1[,POS2]'
`--key=POS1[,POS2]'
     POS1とPOS2(または，POS2が省略された場合は行末)の間か
     ら成り立つ，POS2は_含まれます_，行の一部をソート時のフィー
     ルドに指定します．フィールドと文字の位置は，1から番号付けされます．そ
     のため，二番目のフィールドをソートするため，`--key=2,2' (`-k
     2,2')を使用してください．以下により多くの例があります．

`-z'
`--zero-terminated'
     入力を行の集合として扱い，ASCII LF (Line Feed)の代わり
     にゼロバイト(ASCII NUL (Null)文字)で終端します．このオ
     プションは，任意のパス名を(ラインフィード文字を含んでいても)確実に処理
     するため，`perl -0'や，`find -print0'と`xargs -0'と組み
     合わせると便利です．


   歴史的な(BSDとSystem Vの)`sort'の実装は，解釈が異なるオプショ
ンがあり，特に，`-b'，`-f'と`-n'があげられます． GNU
`sort'は，POSIXの動作に従い，それは通常(常 にではない!)System
Vの動作に似ています．POSIXによると，
`-n'は，もはや`-b'を暗黙に指定しません．一貫性のため，
`-M'も同様に変更されました．これは，フィールドの指定が明確でな
い状況で，文字の位置の意味に影響するかもしれません．唯一の訂正方法は，
明示的に`-b'を加えることです．

   `-k'オプションを用いたソート時のフィールド指定の位置は，
`F.C'形式となり，Fは使用するフィールド数で，
Cはフィールドのはじまりから数えた最初の文字までの数です．最初の
位置として，`.C'が省略されているとフィールドの最初の文字を
用います．`-b'オプションが指定されている場合，指定したフィール ドの`.C'
の部分は，フィールドの最初の空白ではない文字から数 えます．

   ソートキーの位置は，オプション文字`Mbdfinr'を加えてもかまわず，そ
の場合，大域的な順序オプションは，特定のフィールドに使用されません．
`-b'オプションは，指定した最初と最後のフィールドの一方または両
方に独立に適用され，大域的なオプションを継承する場合，両方に適用されま
す．キーは複数のフィールドに跨ってもかまいません．

   古いシステムでは，`sort'は時代遅れのソートキーを指定するゼロを
起点とした構文の`+POS1 [-POS2]'をサポートしています． POSIX 1003.1-2001
(*note Standards conformance::)ではこれを
許可していません．代わりに`-k'を使用してください．

   様々なオプションの組合せを紹介する例は以下のようになります．

   * 下降的な(逆順の)数の順序でソートします．

          sort -nr

   *
     アルファベット順に，最初と二番目のフィールドを除いてソートします．これ
     は，三つ目のフィールドから始まり，それぞれの行の終りまで続く文字で構成
     された，単一のキーを使用します．

          sort -k 3

   *
     二番目のフィールドを数値的にソートし，五つ目のフィールドの三番目と四番
     目の文字のアルファベットでソートすることで，その値が同じものを並べます．
     フィールドの分離に`:'を使用します．

          sort -t : -k 2,2n -k 5.3,5.4

     `-k 2,2'の代わりに`-k 2'と書いた場合，`sort'は二番目の
     フィールドで始まり，行の終りまで続く全ての文字を，主要な_数値_キー
     として使用することに注意してください．アプリケーションのほとんど大多数
     に対しては，数値として一つフィールド以上に跨って扱うキーは，期待したも
     のではないでしょう．

     また，`n'の修飾は，最初のキーに対し，フィールドの終りを指定するも
     のに適用されることに注意してください．それは，`-k 2n,2'や`-k
     2n,2n'を指定することと同じです．全ての修飾は，`b'が関連する
     _フィールド_に適用されることを期待し，修飾文字がフィールドの最初
     そして/または，キー指定のフィールドの終りに適用されるかどうかに依存し
     ません．

   *
     五番目のフィールドでパスワードファイルをソートし，前置されるすべての空
     白を無視します．五番目のフィールドが等しい値の行を，三番目のフィールド
     のユーザIDでソートします．

          sort -t : -k 5b,5 -k 3,3n /etc/passwd

     代わりに，大域的な数値の修飾`-n'を使用します．

          sort -t : -n -k 5b,5 -k 3,3 /etc/passwd

   * 大文字小文字を識別するタグファイルを生成します．

          find src -type f -print0 | sort -t / -z -f | xargs -0 etags --append

     この状況では，`-print0'，`-z'，そして`-0'の使用は， Line
     Feed文字を含むパス名がソート処理で分割されないようにします．

     最後に，前後の空白を無視するため，`b'修飾を最初のキーに対しフィー
     ルドの終りの指定に適用できます．

          sort -t : -n -k 5b,5b -k 3,3 /etc/passwd

     または，大域的な`-b'修飾を`-n'の代わりに使用し，二番目の
     キー指定に`n'を明示します．

          sort -t : -b -k 5,5 -k 3,3n /etc/passwd


   ---------- Footnotes ----------

   (1) POSIXではないロカール(例えば`LC_ALL'を
`en_US'に設定している)場合，`sort'はいつもとは異なるソー
トされた出力を生成する可能性があります．その状況では，`LC_ALL'環境
変数を`C'に設定してください．`LC_COLLATE'だけを設定することに
は二つの問題があることに注意してください．最初は，`LC_ALL'が既に設
定されている場合，無効になることです．二番目は，`LC_CTYPE'(または
`LC_CTYPE'が設定されていない場合は`LANG')が互換性の無い値に設
定されている場合の動作が未定義であることです．例えば，`LC_CTYPE'が
`ja_JP.PCK'で，`LC_COLLATE'が`en_US.UTF-8'の場合，動作は 未定義です．


File: coreutils-ja.info,  Node: uniq invocation,  Next: comm invocation,  Prev: sort invocation,  Up: Operating on sorted files

7.2 `uniq': ファイルのユニーク化
================================

`uniq'は与えられたファイル，または与えられない場合や`-'の
INPUT名に対し，ユニークな行を書き出します．概要です．

     uniq [OPTION]... [INPUT [OUTPUT]]

   デフォルトで`uniq'はその入力行を出力し，そして，出力行が繰り返
さないように隣接した繰り返している行の最初のものだけを出力します．オプ
ションで，そうする代わりに，繰り返さない行を表示しない，さらに，すべて
の繰り返し行を表示することも可能です．

入力ファイルはソートされている必要はありませんが，繰り返している行は隣
接している場合のみ検出されます．隣接していないものを除去したい場合，お
そらく`sort -u'を使用したいと思うでしょう．

   比較には，`LC_COLLATE'ロカールカテゴリで指定された文字の順番を使用
します．

   OUTPUTファイルが無い場合，`uniq'は標準出力に書き出します．

   このプログラムは，以下のオプションも受け入れます．*Note Common
options:: も参照してください．

`-f N'
`--skip-fields=N'
     ユニークさを調査する前に，それぞれの行のNフィールドスキップしま
     す．行がNフィールドより少ない場合，比較で空の文字列を使用します．
     フィールドは，少なくとも一つ以上のスペースやタブで区切られた，非スペー
     ス，非タブ文字の並びです．

     古いシステムでは，`uniq'は時代遅れのオプション
     `-N'をサポートしています．POSIX 1003.1-2001 (*note Standards
     conformance::)ではこれを許可していません．代わりに `-f
     N'を使用してください．

`-s N'
`--skip-chars=N'
     ユニークさの調査の前に，N文字スキップします．行がN文字より
     少ない場合，比較で空の文字列を使用します．フィールドと文字のスキップオ
     プションを両方とも使用した場合，フィールドが最初にスキップされます．

     古いシステムでは，`uniq'は時代遅れのオプション
     `+N'をサポートしています．POSIX 1003.1-2001 (*note Standards
     conformance::)ではこれを許可していません．代わりに `-s
     N'を使用してください．

`-c'
`--count'
     それぞれの行で同じものが発生した回数を出力します．

`-i'
`--ignore-case'
     行の比較時に大文字小文字の違いを無視します．

`-d'
`--repeated'
     繰り返しではない行を除外します．単独で使用しているとき，このオプション
     で`uniq'は繰り返している行の最初のものを出力し，それ以外は何も
     出力しません．

`-D'
`--all-repeated[=DELIMIT-METHOD]'
     繰り返している行の二番目とそれに続く行を除外しませんが，繰り返していな
     い行は除外します．このオプションは，主に他のオプションと組み合わせると
     便利で，例えば，大文字小文字を無視したり，選択したフィールドのみを比較
     する場合です．追加のDELIMIT-METHODで繰り返している行の組を分ける
     方法を伝え、それは以下の一つにする必要があります．

    `none'
          繰り返している行の組を分離しません．これは`--all-repeated'
          (`-D')と同じです．

    `prepend'
          それぞれの繰り返している行の組の前に改行を出力します．

    `separate'
          繰り返している行の組を単一の改行で分離します．これは，最初の組の前に改
          行が無いこと以外`prepend'を使用することと同じで，ユーザに直接出力
          するためにはより適しているでしょう．

     組が分離されていて，入力に二つ以上の空白行があるとき，出力が不明瞭にな
     ることに注意してください．それを避けるため，連続した改行を単一の改行に
     置換するように，入力を`tr -s '\n''でフィルタリングしてください．

     これは，GNUの拡張です．

`-u'
`--unique'
     最初に繰り返している行を除外します．単独で使用しているとき，このオプショ
     ンで`uniq'はユニークな行を出力し，それ以外では何もしません．

`-w N'
`--check-chars=N'
     (指定されたすべてのフィールドと文字をスキップした後)それぞれの行の最大
     N文字を比較します．デフォルトで，行の残り全体が比較されます．


   終了ステータスのゼロは成功を示し，ゼロ以外の値は失敗を示します．


File: coreutils-ja.info,  Node: comm invocation,  Next: ptx invocation,  Prev: uniq invocation,  Up: Operating on sorted files

7.3 `comm': 二つのソートされた行と行の比較
==========================================

`comm'は，二つの入力ファイルの共通の行とユニークな行を標準出力
に書き出します．`-'のファイル名は標準入力を意味します．概要です．

     comm [OPTION]... FILE1 FILE2

   `comm'を使用する前に，`LC_COLLATE'ロカールで指定された順番
に入力ファイルをソートする必要があります．入力ファイルが改行文字で終ら
ない場合，改行は暗黙に付加されます．オプションを用いない`sort'
コマンドは，`comm'の入力に適したファイルを常に出力します．

   オプションが無い場合，`comm'は三列の出力を生成します．一列目は
FILE1のユニークな行を含み，二列目はFILE2のユニークな行を含
み，三列目は両方のファイルに共通な列を含みます．列は単一のTAB文字で分
離されます．

   オプションの`-1'，`-2'，そして`-3'は，対応する列
の出力を抑制します．*Note Common options::も参照してください．

   他の比較ユーティリティとは異なり，`comm'は比較の結果に依存しな
い終了ステータスがあります．上記の通常の比較では，`comm'はゼロ
のコードで終了します．エラーがあった場合，ゼロでないステータスで終了し
ます．


File: coreutils-ja.info,  Node: tsort invocation,  Next: tsort background,  Prev: ptx invocation,  Up: Operating on sorted files

7.4 `tsort': 位相幾何学的なソート
=================================

`tsort'は，位相幾何学的なソートを，与えられたFILE，また
は入力ファイルが与えられない場合や`-'のファイルに対しては標準入力
で実行します．詳細とちょっとした歴史は*Note tsort background::を参照して
ください．概要です．

     tsort [OPTION] [FILE]

   `tsort'は，その入力を文字列の組で，空白で分離されていて，不完
全な順序で示されているものとして読み込みます．出力は，与えられた不完全
な順序に対応する完全な順序になります．

   例えば以下のようにします．

     tsort <<EOF
     a b c
     d
     e f
     b c d e
     EOF

これは以下の出力を生成します．

     a
     b
     c
     d
     e
     f

より現実的な例を考えてみましょう．一つのファイルに大きなすべての関数の
セットがあり，一つ以外のすべてがスタティックに宣言されていると仮定しま
す．現在，それ(いわゆる`main')はファイルの最初に定義されていて，
それから直接呼び出されるものが続き，それらが呼び出すものがそれに続いて
いる，といったようになっています．さて，プロトタイプの利点が決定すると，
それらの関数の宣言(定義からのたくさんの情報が重複していることを意味し
ます)の関係を選択し，それらが使用される前にできるだけ多くの関数の順番
を整理することになるでしょう，それ以降の処理を自動化する一つの方法とし
て，直接呼ばれるそれぞれの関数のリストを入手することがあげられます．そ
のようなリストを生成することが可能なプログラムはたくさんあります．それ
らはグラフと呼ばれる物を記述します．それぞれの行で，左の関数が右の関数
を直接呼び出すことを示している以下のリストを考えてみましょう．

     main parse_options
     main tail_file
     main tail_forever
     tail_file pretty_name
     tail_file write_header
     tail_file tail
     tail_forever recheck
     tail_forever pretty_name
     tail_forever write_header
     tail_forever dump_remainder
     tail tail_lines
     tail tail_bytes
     tail_lines start_lines
     tail_lines dump_remainder
     tail_lines file_lines
     tail_lines pipe_lines
     tail_bytes xlseek
     tail_bytes start_bytes
     tail_bytes dump_remainder
     tail_bytes pipe_bytes
     file_lines dump_remainder
     recheck pretty_name

   そのとき，要求を満足するようにそれらの関数の順番を生成するため，
`tsort'を使用することが可能です．

     example$ tsort call-graph | tac
     dump_remainder
     start_lines
     file_lines
     pipe_lines
     xlseek
     start_bytes
     pipe_bytes
     tail_lines
     tail_bytes
     pretty_name
     write_header
     tail
     recheck
     parse_options
     tail_file
     tail_forever
     main

   `tsort'は入力内の循環を検出し，出現した最初の循環部分を標準エ
ラーに書き出します．

与えられた不完全な順序が，一般に唯一の完全な順序でないことに注意してく
ださい．上記の例の状況では，関数`parse_options'は，`main'の
前であればリストのどこにあってもかまいません．

   オプションは，`--help'と`--version'のみです． *Note Common options::.


File: coreutils-ja.info,  Node: tsort background,  Prev: tsort invocation,  Up: Operating on sorted files

7.5 `tsort': 背景
=================

`tsort'は，初期のUnixのバージョンのリンカで，アーカイブファイ
ルを正確に一度だけ正しい順序で処理するために存在しています．
`ld'はそれぞれのオブジェクトをアーカイブから読み出すので，プロ
グラムで基本となるものが必要かどうか，リンク時に未定義のシンボルが定義
されているかどうかは明確です．

これは，アーカイブでの依存性を特別処理する必要があったことを意味します．
例えば，`scanf'はおそらく`read'を呼び出します．それは，一度
アーカイブ全体を見渡すとき，`scanf.o'が`read.o'の前に現れる
ことが重要だということで，そうでなければ，`scanf'を呼び出している
が，`read'を呼び出していないプログラムで，期待していない未解決の
`read'への参照に結局なってしまうからです．

この問題を解決する方法は，最初にオブジェクトファイル内の依存性を生成す
ることです．これは，`lorder'と呼ばれるシェルスクリプトで行なわ
れていました．GNUツールは，私の知る限りlorderを用いるバージョンを提供
していませんが，BSDの配布物ではまだ見つかるはずです．

   `lorder'の出力で`tsort'を実行すると，アーカイブに追加
したオブジェクトの定義順を並べ替えた結果を使用することが可能になります．

   1980年以降，Unixのアーカイブにはシンボル表が含まれていて(伝統的に
`ranlib'で構築され，今では`ar'自身で構築されます)，
Unixのリンカは，アーカイブファイル全体を何回も効率的に処理するため，そ
のシンボル表を使用するので，この一連の処理は時代遅れです．

   いずれにせよ，こういうことで`tsort'は生まれました．古い問題を
解決するためにリンカがアーカイブファイルを処理する方法で，それは別の方
法で解決されています．

   終了ステータスのゼロは成功を示し，ゼロ以外の値は失敗を示します．


File: coreutils-ja.info,  Node: ptx invocation,  Next: tsort invocation,  Prev: comm invocation,  Up: Operating on sorted files

7.6 `ptx': 並べ替えた索引の生成
===============================

`ptx'は，テキストファイルを読み込み，その内容のそれぞれのキー
ワードを用いて，並べ替えられた索引を本来は生成します．呼び出しの形態は
以下の一つです．

     ptx [OPTION ...] [FILE ...]
     ptx -G [OPTION ...] [INPUT [OUTPUT]]

   `-G'(または同等の: `--traditional')オプションは，全ての
GNU拡張を利用不可にし，伝統的なモードに切替えるので，いくつか制限
があり，そしてプログラムのオプションデフォルト値を変更します．
`-G'が指定されていない場合，GNU拡張は常に利用可能です．
`ptx'のGNU拡張は，このドキュメントに適切に文章化されてい
ます．完全なリストは，*Note Compatibility in ptx::.

   個別のオプションは，以下のセクションで説明します．

   GNU拡張が利用可能なとき，ゼロ，一つ，または複数のFILEをオプ
ションの後に続けてかまいません．FILEが無い場合，プログラムは標準
入力から読み込みます．一つまたは複数FILEある場合，全ての入力ファ
イルが連結されているかのように，順番に全て読み込まれる入力ファイル名に
なります．しかし，それぞれのファイルの間に完全に文脈の終りが有り，自動
的な参照が要求されるとき，ファイル名と行番号は，入力ファイルの個別のテ
キストを参照します．全ての状況で，プログラムは並べ替えられた索引を標準
出力に書き出します．

   GNU拡張が利用可能で_ない_とき，すなわち，伝統的なモードでプ
ログラムが動作しているとき，ゼロ，一つ，または二つのパラメータをオプショ
ンの後に続けてかまもいません．パラメータが無い場合，プログラムは標準入
力を読み込み，標準出力に並べ替えた索引を生成します．一つのパラメータの
みの場合，それは標準入力の代わりに読み込まれるテキストINPUTを指
名します．二つのパラメータが与えられた場合，それらはそれぞれ，読み込ま
れるINPUTファイル名と，生成するOUTPUTファイル名を与えます．
この場合，二番目のパラメータとして与えられるファイルの内容が壊れること
に_十分注意して_ください．この動作は，System V `ptx'互換
で規定されています．GNUの標準は，オプションで導入されない出力パラ
メータを防止します．

   _あらゆる_ファイルは，オプション値や入力テキストファイルとして指
名され，単一のダッシュ`-'を使用でき，その場合は標準入力と考えられ
ます．しかし，プログラムの呼び出しに一回以上，この慣習を使用する意味は
ありません．

* Menu:

* General options in ptx::      Options which affect general program behavior.
* Charset selection in ptx::    Underlying character set considerations.
* Input processing in ptx::     Input fields, contexts, and keyword selection.
* Output formatting in ptx::    Types of output format, and sizing the fields.
* Compatibility in ptx::


File: coreutils-ja.info,  Node: General options in ptx,  Next: Charset selection in ptx,  Up: ptx invocation

7.6.1 一般的なオプション
------------------------

`-C'
`--copyright'
     著作権とコピー条件の短いメモを出力し，それ以上何も処理せず終了します．

`-G'
`--traditional'
     既に拡張されているので，このオプションは，`ptx'に対する全ての
     GNU拡張を利用不可にし，伝統的なモードに切替えます．

`--help'
     短いヘルプを標準出力に出力し，それ以上何も処理せず終了します．

`--version'
     プログラムのバージョンを標準出力に出力し，それ以上何も処理せずに終了し
     ます．


   終了ステータスのゼロは成功を示し，ゼロ以外の値は失敗を示します．


File: coreutils-ja.info,  Node: Charset selection in ptx,  Next: Input processing in ptx,  Prev: General options in ptx,  Up: ptx invocation

7.6.2 文字セットの選択
----------------------

現在セットアップされているので，プログラムは，入力ファイルが8ビット
ISO-8859-1コードを使用して符号化されていると考え，Latin-1文字セットだ
ということも分かりますが，それは，MS-DOSでコンパイル_されていない
場合_で，その場合はIBM-PCの文字セットを使用します．(GNU
`ptx'を，より小さいMS-DOSマシンで動作させる方法が分かりません．) 7-bit
ASCIIとは異なり，文字である文字セットは別物です．これ
は正規表現のマッチの動作を変更します．そのため，キーワードに対するデフォ
ルトの正規表現で，外国や発音記号の文字が可能となります．しかし，キーワー
ドのソートはそのままです．それは，全く盲目的に基礎的な文字セットの順序
に従います．

`-f'
`--ignore-case'
     ソートに対し，小文字を大文字にまとめます．



File: coreutils-ja.info,  Node: Input processing in ptx,  Next: Output formatting in ptx,  Prev: Charset selection in ptx,  Up: ptx invocation

7.6.3 単語の選択と入力の処理
----------------------------

`-b FILE'

`--break-file=FILE'
     このオプションは，単語を生成する文字の記述方法(`-W')の代替物を
     提供します．それは，単語の部分にならない文字のリストを含むファイル名を
     導入し，このファイルは"ブレークファイル(Break file)"と呼ばれます．
     ブレークファイルの一部でないあらゆる文字は単語の要素です．`-b'
     と`-W'を両方指定した場合，`-W'が優先され`-b'は無 視されます．

     GNU拡張が利用可能な場合，改行をブレーク文字とすることを避ける唯一
     の方法で，ファイルの終りにさえ改行が全く無いファイルに，全てのブレーク
     文字を書くことでできます．GNU拡張が利用不可能な場合，スペース，タ
     ブ，そして改行は，ブレークファイルに含まれていない場合でも，常にブレー
     ク文字だと考慮されます．

`-i FILE'
`--ignore-file=FILE'
     このオプションで関連付けられたファイルは，用語索引の出力でキーワードと
     されない単語のリストを含みます．それは"無視ファイル(Ignore file)"
     と呼ばれます．ファイルは，正確にそれぞれの行に一単語を含みます．単語を
     分ける行の終りは，`-S'オプションの値を適用されません．

     このオプションが指定されない場合，デフォルトの無視ファイルが
     `ptx'で使用され，インストール時に変更されていない場合，通常は
     `/usr/local/lib/eign'で見つかります．デフォルトの無視ファイルの影
     響を無くしたい場合，代わりに`/dev/null'を指定してください．

`-o FILE'
`--only-file=FILE'
     このオプションで関連付けられたファイルは，用語索引の出力に維持される単
     語のリストを含み，このファイルで述べていないあらゆる単語は無視されます．
     ファイルは"オンリーファイル(Only file)"と呼ばれています．ファイル
     は，正確にそれぞれの行に一単語を含みます．単語を分ける行の終りは，
     `-S'オプションの値を適用されません．

     オンリーファイルにデフォルトはありません．オンリーファイルと無視ファイ
     ルの両方にある場合，オンリーファイルで与えられ，無視ファイルで与えられ
     ない単語のみキーワードに適用されます．

`-r'
`--references'
     それぞれの入力行で，空白文字でない前置された並びは，結果として得られる
     並べ替えされた索引で，この入力行を識別する目的の参照として受け取られま
     す．参照生成に関するより多くの情報は，*Note Output formatting in
     ptx::.
     このオプションの使用で，オプション`-S'に対するデフォルト値を変
     更します．

     このオプションを使用すると，プログラムは出力の文脈からの参照の削除の試
     みが非常に難しくなりますが，文脈の終りが正確に改行で終る_とき_，
     そうすることに成功します．オプション`-r'が`-S'デフォルト
     値とともに使用された場合や，GNU拡張が利用不可能なとき，この条件は
     常に満たされ，参照は完全に出力文脈から除外されます．

`-S REGEXP'
`--sentence-regexp=REGEXP'
     このオプションは，行末や文の終りを記述する正規表現を選択します．実際，
     この正規表現の効果以外に，行末や文の終わりのには他の区別があり，入力行
     の境界は，このオプションの外で特別な重要性はありません．デフォルトで，
     GNU拡張が使用可能なときや，`-r'オプションが使用されていな
     い場合，文の終りが使用されます．この場合，正確なREGEXはGNU
     emacsから取り込まれます．

          [.?!][]\"')}]*\\($\\|\t\\|  \\)[ \t\n]*

     GNU拡張が使用不可能なときや，`-r'オプションが使用されてい
     る場合は，常に行の終りが使用され，この場合デフォルトのREGEXPは以
     下のようになります．

          \n

     空のREGEXPの使用は，行末と文の終りの認識を完全に不可能にすること
     と同等です．この場合，ファイル全体が単一の大きな行や文と考えられます．
     ユーザは，オプション`-F ""'を通じて，全ての切り詰めフラグの生成を，
     不許可にしたい場合もあります．*Note Syntax of Regular Expressions:
     (emacs)Regexps.

     キーワードが入力行や文の最初で発生したとき，出力文脈の行の最初に，利用
     されない領域を作成することもよくあります．キーワードが入力行や文の終り
     近くで発生したとき，出力文脈の行の終りに利用されない領域を作成すること
     もよくあります．プログラムは，その中の文脈の周りを包むことで，それらの
     領域を補充しようとします．入力行や文の頭は，出力行の右の利用されていな
     い行を補充するために使用されます．

     ユーザの利便性の問題として，C言語で見つかる，通常のバックスラッシュさ
     れたエスケープ・シーケンスは認識され，`ptx'自身によって対応す
     る文字に変換されます．

`-W REGEXP'
`--word-regexp=REGEXP'
     このオプションは，それぞれのキーワードを記述している正規表現を選択しま
     す．デフォルトで，GNU拡張が利用可能な場合，単語は文字の並びです．
     使用されるREGEXPは`\w+'です．GNU拡張が利用不可能な場合，
     単語はデフォルトで，スペース，タブ，または改行で終るあらゆるものです．
     使用されるREGEXPは`[^ \t\n]+'です．

     空のREGEXPは，このオプションを使用しないのと同等で，デフォルト動
     作になります．*Note Syntax of Regular Expressions: (emacs)Regexps.

     ユーザの利便性の問題として，C言語で見つかる，多くの通常のバックスラッ
     シュされたエスケープ・シーケンスは認識され，`ptx'自身によって
     対応する文字に変換されます．



File: coreutils-ja.info,  Node: Output formatting in ptx,  Next: Compatibility in ptx,  Prev: Input processing in ptx,  Up: ptx invocation

7.6.4 出力の書式
----------------

出力書式は，主に`-O'と`-T'オプションで制御され，それは以
下の表で記述されています．`-O'も`-T'も選択されていないと
きで，GNU拡張が利用可能な場合，プログラムはdumb端末に適した出力書
式を選択します．それぞれのキーワードの生成は，出力を行の中心にし，周り
をその左右の文脈で囲います．それぞれのフィールドは適切で正しいものなの
で，用語索引の出力を容易に観察することが可能です．特別な特徴として，自
動的な参照がオプション`-A'で指定されていて，左の文脈の前に出力
されている，すなわち，オプション`-R'が選択されて_いない_場
合，コロンが参照の後に追加されます．これは，GNU Emacsが
`next-error'を処理することでうまく作用します．このデフォルト出力
書式では，改行やタブのようなそれぞれの空白文字は，正確に一つのスペース
に単に変換され，連続したスペースの圧縮は特に試みません．これは将来変更
されるかもしれません．これらの空白文字以外の，256文字の基本セットの全
ての他の文字は逐語的に転送されます．

   出力書式は，以下のオプションで更に制御されます．

`-g NUMBER'
`--gap-size=NUMBER'
     出力行のフィールド間の最小の空白の隙間を選択します．

`-w NUMBER'
`--width=NUMBER'
     それぞれの最終行の出力最大幅を選択します．参照が使用される場合，
     `-R'オプションの値に依存して，それらは出力最大幅に含められたり
     省かれたりします．これらのオプションが選択されていない場合，すなわち，
     参照が左の文脈の前に出力されるとき，出力最大幅は全ての参照の最大長まで
     考慮されます．このオプションが選択された場合，すなわち，参照が右の文脈
     の後に出力されるとき，出力最大幅は参照が使用するスペースの量も，前にあ
     る隙間も考慮されません．

`-A'
`--auto-reference'
     自動的な参照を選択します．それぞれの入力行は，ファイル名と間に単一のコ
     ロンを用いた行の序数で作成された自動的な参照を持ちます．しかし，標準入
     力が読み込まれているときは，ファイル名は空です．`-A'と
     `-r'の両方が選択された場合，入力参照は読み込まれスキップされま
     すが，自動的な参照は出力時に利用され，それは入力参照に優先します．

`-R'
`--right-side-refs'
     デフォルト出力書式で，オプション`-R'が使用されていないとき，オ
     プション`-r'や`-A'の影響で生成されるあらゆる参照は，右の
     文脈の後に，出力行の右端に与えられます．デフォルト出力書式で，オプショ
     ン`-R'が指定された場合，参照は，左の文脈の前に，それぞれの出力
     行の始めに代わりに与えられます．それ以外のあらゆる出力書式に対し，
     `-R'が選択されたときは常に，参照の幅が`-w'で与えられた全
     体の出力幅に含まれ_ない_という事実以外，オプション`-R'はほ
     とんど無視されます．

     GNU拡張が利用不可能なときは，常にこのオプションは自動的に選択され
     ます．

`-F STRING'
`--flac-truncation=STRING'
     このオプションは，文字列STRINGの使用が報告された出力での，あらゆ
     る切り詰めを要求します．ほとんどの出力フィールドは，オプション
     `-S'が選択されたのと同様に，現在の行や現在の文の始めや終りに向
     かって，理論的に展開されます．しかし，許可される出力行幅の最大値は存在
     し，それはオプション`-w'で変更でき，そしてそれは様々な出力フィー
     ルドに対しスペースで更に分割されます．現在の行に適するように，その行の
     最初や終りまで伸ばすことができないためフィールドを切り詰める必要がある
     とき，切り詰めが発生します．デフォルトで，使用される文字列は単一のスラッ
     シュで，`-F /'のようになります．

     STRINGは一文字以上が可能で，`-F ...'のようになります．また，
     STRINGが空(`-F ""')となる特定の場合，切り詰めフラグは利用不
     可能で，切り詰めマークはこの場合は現われません．

     ユーザの利便性の問題として，多くの通常の，C言語で見つかる，バックスペー
     スされたエスケープシーケンスは認識され，`ptx'自身によって，対
     応する文字に変換されます．

`-M STRING'
`--macro-name=STRING'
     `nroff'，`troff'やTeXに適した出力を生成している間，
     `xx'の代わりに，使用する他のSTRINGを選択します．

`-O'
`--format=roff'
     `nroff'や`troff'の処理に適した出力書式を選択します．それぞれ
     の出力行は以下のようになります．

          .xx "TAIL" "BEFORE" "KEYWORD_AND_AFTER" "HEAD" "REF"

     それで，出力の植字を処理するための，`.xx' roffマクロを書くことが
     可能になります．GNU拡張が利用不可能な場合，これはデフォルト出力で
     す．オプション`-M'は，`xx'を他のマクロ名に変更するために使
     用することが可能です．

     この出力形式で，改行やタブのような，表示不可能なそれぞれの文字は，連続
     したスペースを圧縮するという特別な試みを行わず，正確に一つのスペースに
     単に変換されます．それぞれの引用文字：`"'は二重になるので，
     `nroff'や`troff'で正しく処理されます．

`-T'
`--format=tex'
     TeXでの処理に適した出力書式を選択します．それぞれの出力行は以下のよ
     うになります．

          \xx {TAIL}{BEFORE}{KEYWORD}{AFTER}{HEAD}{REF}

     それで，出力の植字の処理するための`\xx'定義を書くことが可能になり
     ます．参照が生成されないとき，すなはち，オプション`-A'もオプショ
     ン`-r'も選択されていないとき，それぞれの`\xx'の最後のパラ
     メータが抑制されることに注意してください．オプション`-M'は，
     `xx'を他のマクロ名に変更するために利用可能です．

     この出力書式では，`$'，`%'，`&'，`#'そして`_'のよ
     うないくつかの特殊文字は，自動的にバックスラッシュで保護されます．弓カッ
     コの`{'，`}'もバックスラッシュで保護されますが，(数学モード
     を強制する)ドル記号の組でも囲まれます．バックスラッシュ自身は
     `\backslash{}'の並びを生成します．曲折アクセント記号とティルデ
     分音記号は，`^\{ }'と`~\{ }'の並びをそれぞれ生成します．
     その他の基礎となる文字セットの分音文字は，適切なTeXの並びを可能な限
     り生成します．改行とタブのようなその他の表示不可能な文字と，
     ASCIIではない全ての他の文字は，連続したスペースを圧縮すると
     いう特別な試みを行わず，一つのスペースに単に変換されます．これらの特殊
     文字をTeXで処理する改善方法を知らせてください．



File: coreutils-ja.info,  Node: Compatibility in ptx,  Prev: Output formatting in ptx,  Up: ptx invocation

7.6.5 `ptx'のGNU拡張
--------------------

この`ptx'のバージョンには，System V `ptx'には存在しな
いいくつかの特徴があります．これらの拡張された特徴は，他のコマンドライ
ンオプションで優先されない場合，`-G'コマンドラインオプションを
使用して抑制されます．GNU拡張には，優先で元に戻すことができないも
のがあり，そのため，GNU拡張を気にする場合，簡単な規則で
`-G'を避けるはずです．ここに，このプログラムとSystem V
`ptx'の間の違いがあります．

   *
     このプログラムは，一度に多くの入力ファイルを読むことが可能で，それは常
     に，用語索引の結果を標準出力に書き出します．一方，System V
     `ptx'は，一つのみファイルを読み込み，結果を標準出力に書き出す
     か，二番目のFILEパラメータがコマンドで与えられている場合は，その
     FILEに書き出します．

     オプションで導入されない出力パラメータがあると，GNUができる限り避
     けようとしている危険な操作になります．そのため，GNUとSystem Vの間
     の移植性のある`ptx'を使用するため，単一の入力ファイルで常に使
     用することに注意を払い，常に標準出力で結果を期待するべきです．配置する
     ものが`-G'を受け入れる`ptx'がインストールされていること
     が分かった場合，`ptx'を使用した製品での`ptx'の呼び出し
     で，`-G'オプションを自動的に配置したいと思うかもしれません．

   * System V `ptx'でのみ利用可能なオプションは，`-b'，
     `-f'，`-g'，`-i'，`-o'，`-r'，
     `-t'，そして`-w'です．全ての他のオプションはGNU拡張
     で，この列挙では繰り返しません．さらに，GNU拡張が利用可能なとき，
     わずかに意味が異なるオプションもあり，それは以下で記述します．

   * デフォルトで，用語索引出力は`troff'や`nroff'に対して書式化さ
     れません．それはむしろ，dumb端末に対する出力です．`troff'や
     `nroff'への出力は，オプション`-O'を通じて選択してもかまい ません．

   * `-R'オプションが選択されない場合，最大の参照幅は出力行幅全体か
     ら引いたものになります．GNU拡張が利用不可能な場合，参照の幅は出力
     行の幅の計算で考慮されません．

   * `NUL'を含む256文字全ては，たとえGNU拡張が利用不可能な場合でも，
     常に入力ファイルから読み込まれ，問題となる影響もなく処理されます．しか
     し，System V `ptx'は8ビット文字を受け入れず，いくつかの制御文
     字は削除され，チルダ`~'は処分されます．

   * 入力行の長さは，GNU拡張が利用できない場合でさえ，利用可能なメモリ
     でのみ制限されます．しかしSystem V `ptx'は，それぞれの行の最初
     の200文字のみ処理します．

   *
     ブレーク(単語ではない)文字は，全ての基礎となる文字セット以外，分音記号
     の有無によらず，全ての文字をデフォルトとします．GNU拡張が利用不可
     能なとき，ブレーク文字は，スペース，タブと改行のみをデフォルトとします．

   * プログラムは，出力行の幅でより良いものを使用します．GNU拡張が利用
     不可能な場合，プログラムは，代わりにSystem V `ptx'を模倣しよう
     としますが，このプログラムが完全に再現していない，わずかな配置不備もま
     だあります．

   *
     ユーザは，IgnoreファイルとOnlyファイルの両方を指定できます．これは，
     System V `ptx'では許可されません．



File: coreutils-ja.info,  Node: Operating on fields within a line,  Next: Operating on characters,  Prev: Operating on sorted files,  Up: Top

8 行のフィールドの処理
**********************

* Menu:

* cut invocation::              Print selected parts of lines.
* paste invocation::            Merge lines of files.
* join invocation::             Join lines on a common field.


File: coreutils-ja.info,  Node: cut invocation,  Next: paste invocation,  Up: Operating on fields within a line

8.1 `cut': 行の選択した部分の出力
=================================

`cut'は，それぞれの入力ファイルや，ファイルが与えられない場合
や`-'のファイル名に対しては標準入力の，それぞれの行の選択された部
分を標準出力に書き出します．概要です．

     cut [OPTION]... [FILE]...

   以下の表で，BYTE-LIST，CHARACTER-LIST，そして
FIELD-LISTは，一つ以上の数字またはカンマで分けられた(ダッシュで
分けられた二つの数字の)範囲です．バイト，文字，そしてフィールドは，1で
始まる番号がつきます．不完全な範囲を与えることができます．
`-M'は`1-M'を意味します．`N-'は，
`N'から行末やフィールドの終りまでを意味します．

   このプログラムは以下のオプションも受け入れます．*Note Common
options::も 参照してください．

`-b BYTE-LIST'
`--bytes=BYTE-LIST'
     BYTE-LISTでリストアップされた位置にあるバイトのみを出力します．
     タブとバックスペースは他の文字と同様に扱われます．それらは1バイト使用
     します．出力の分離文字が指定されている場合(`--output-delimiter'
     を参照して下さい)，選択したバイトの範囲の間の文字列を出力します．

`-c CHARACTER-LIST'
`--characters=CHARACTER-LIST'
     CHARACTER-LISTにリストアップされている位置にある文字のみを出力し
     ます．現在は`-b'と同じですが，国際化でそれが変更される可能性が
     あります．タブとバックスペースは他の文字と同様に扱われます．それらは1
     バイト使用します．出力の分離文字が指定されている場合
     (`--output-delimiter' を参照して下さい)，選択したバイトの範囲の
     間の文字列を出力します．

`-f FIELD-LIST'
`--fields=FIELD-LIST'
     FIELD-LISTにリストアップされたフィールドのみを出力します．デフォ
     ルトで，フィールドはTAB文字で分けられています． `--only-delimited'
     (`-s')オプションが指定されない限り，
     デリミタ文字の無い行も出力されます．

`-d INPUT_DELIM_BYTE'
`--delimiter=INPUT_DELIM_BYTE'
     `-f'に対し，フィールドは，INPUT_DELIM_BYTEの最初の文字に
     よって，入力を分離したものになります．(デフォルトはTABです)．

`-n'
     マルチバイトの文字を分けません(現在何もしません)．

`-s'
`--only-delimited'
     `-f'に対し，フィールド分離文字を含まない列を出力しません．通常，
     フィールド分離文字が無い行は，そのまま出力されます．

`--output-delimiter=OUTPUT_DELIM_STRING'
     `-f'に対し，出力フィールドは，OUTPUT_DELIM_STRINGで分けら
     れます．デフォルトは入力の分離文字を使用します．バイトや文字のオフセッ
     トの範囲を選択するために`-b'や`-c'を使用しているとき，選
     択したバイト数の範囲の間にOUTPUT_DELIM_STRINGを出力します．


   終了ステータスのゼロは成功を示し，ゼロ以外の値は失敗を示します．


File: coreutils-ja.info,  Node: paste invocation,  Next: join invocation,  Prev: cut invocation,  Up: Operating on fields within a line

8.2 `paste': ファイルの行を統合します
=====================================

`paste'は，与えられたそれぞれのファイルの，順番的に対応してい
る行を，TAB文字で分離しながら標準出力に書き出します．`-'のファイ
ル名に対して，または入力ファイルが与えられない場合，標準入力が使用され
ます．

   例えば以下のようになります．

     $ cat num2
     1
     2
     $ cat let3
     a
     b
     c
     $ paste num2 let3
     1       a
     2       b
             c

   概要です．

     paste [OPTION]... [FILE]...

   プログラムは以下のオプションを受け入れます．*Note Common
options::も参照 してください．

`-s'
`--serial'
     それぞれのファイルから一行ではなく，一度に一つのファイルの行をペースト
     します．

          $ paste -s num2 let3
          1       2
          a       b       c

`-d DELIM-LIST'
`--delimiters=DELIM-LIST'
     統合される行の分離文字TABの代わりに，DELIM-LISTの文字を順番に使
     用します．DELIM-LISTが使い尽くされたとき，最初から再び開始します．

          $ paste -d '%_' num2 let3 num2
          1%a_1
          2%b_2
          %c_


   終了ステータスのゼロは成功を示し，ゼロ以外の値は失敗を示します．


File: coreutils-ja.info,  Node: join invocation,  Prev: paste invocation,  Up: Operating on fields within a line

8.3 `join': 共通のフィールドで行を結合
======================================

`join'は，同一の結合フィールドを持つそれぞれの入力行の組に対し，
一行を標準出力に書き出します．概要です．

     join [OPTION]... FILE1 FILE2

   FILE1またはFILE2は(両方ではなく)`-'が可能で，標準入力
を意味します．FILE1とFILE2は，結合フィールド上で並べ替えし
ておくべきです．

   通常，並べ替えの順序は，`LC_COLLATE'ロカールで指定されている順番で
す．`-t'オプションが与えられない限り，`sort -b'のように，
並べ替えの比較では結合フィールドの最初の空白は無視されます．
`--ignore-case'オプションが与えられている場合，`sort -f'の
ように，並べ替えの比較では結合フィールドの文字の大文字小文字は無視され
ます．

   しかし，GNUの拡張として，入力に組になる行が無い場合，並び順は，上記の
並び替えの比較が同じであると考えられる場合，そしてそのときだけ，二つの
フィールドが同じであると考えられる順番になるはずです．例えば，以下のよ
うになります．

     $ cat file1
     a a1
     c c1
     b b1
     $ cat file2
     a a2
     c c2
     b b2
     $ join file1 file2
     a a1 a2
     c c1 c2
     b b1 b2

   デフォルトは，以下の通りです．結合フィールドは，それぞれの行の最初の
フィールドです．入力のフィールドは，一つ以上の空白で分離されていて，行
の前の空白は無視されます．出力のフィールドはスペースで分離されています．
それぞれの出力行は，結合フィールド，FILE1の残りのフィールド，そ
してFILE2の残りのフィールドから成り立ちます．

   プログラムは，以下のオプションを受け入れます．*Note Common
options::も参 照してください．

`-a FILE-NUMBER'
     ファイルFILE-NUMBER (`1'または`2'のいずれか)で組になっ
     ていないそれぞれの行に対し，一行を通常の出力に追加して出力します．

`-e STRING'
     入力で欠けているこれらの出力フィールドを，STRINGで置換します．

`-i'
`--ignore-case'
     キーを比較するとき，大文字小文字の違いを無視します．このオプションを用
     いると，入力ファイルの行は同じ方法でソートされている必要があります．こ
     の順序を生成するために，`sort -f'を使用してください．

`-1 FIELD'
     ファイル1のフィールドFIELD(正の整数)で結合します．

`-2 FIELD'
     ファイル2のフィールドFIELD (正の整数)で結合します．

`-j FIELD'
     `-1 FIELD -2 FIELD'と同じです．

`-o FIELD-LIST'
     FIELD-LISTの書式に従い，それぞれの出力行を生成します．
     FIELD-LISTのそれぞれの要素は，単一文字`0'，または，ファイル
     番号のM，`1'または`2'，そしてNが正のフィールド番
     号となっている，M.Nの形式になります．

     `0'のフィールド指定は，結合フィールドを示します．ほとんどの場合，
     `0'フィールドの指定の機能は，対応する結合フィールドとなる，明示的
     なM.Nを用いて再現できます．しかし，(`-a'または`-v'
     オプションを用いて)組にならない行を出力するとき，両方のファイルで組に
     ならない行がある場合，FIELD-LISTでM.Nを用いて結合フィール
     ドを指定する方法はありません．`join'にその機能を与えるため，
     POSIXは`0'フィールド指定の表記を考え出しました．

     FIELD-LISTの要素は，カンマまたは空白で分けられています．全ての出
     力行は - `-a'や`-v'オプションで出力されるものを含め -
     指定されたFIELD-LISTが適用されます．

`-t CHAR'
     文字CHARを入出力のフィールドセパレータとして使用します．入力ファ
     イルでCHARが見つかるたびに，意味があるものとして扱います．

`-v FILE-NUMBER'
     通常の出力の代わりに，ファイルFILE-NUMBER (`1'または
     `2')の組にならないそれぞれの行に対し，一行を出力します．


   更に，GNU `join'は，単一の引数で呼び出されたとき，オプショ
ン`--help'と`--version'は認識されます．*Note Common options::.

   終了ステータスのゼロは成功を示し，ゼロ以外の値は失敗を示します．


File: coreutils-ja.info,  Node: Operating on characters,  Next: Directory listing,  Prev: Operating on fields within a line,  Up: Top

9 文字の処理
************

このコマンドは，個別に文字を処理します．

* Menu:

* tr invocation::               Translate, squeeze, and/or delete characters.
* expand invocation::           Convert tabs to spaces.
* unexpand invocation::         Convert spaces to tabs.


File: coreutils-ja.info,  Node: tr invocation,  Next: expand invocation,  Up: Operating on characters

9.1 `tr': 文字の変換，圧縮，そして/または，削除
===============================================

概要です．

     tr [OPTION]... SET1 [SET2]

   `tr'は標準入力を標準出力にコピーし，そのとき以下の処理の一つを
実行します．

   * 変換，さらに結果の繰り返し文字の圧縮．

   * 繰り返し文字の圧縮．

   * 文字の削除．

   * 文字の削除後，結果から繰り返し文字の圧縮．

   SET1と(与えられている場合)SET2引数は，順番付けされた文字を
定義し，以下のSET1とSET2を参照します．これらの組は，
`tr'が処理する入力文字です．`--complement'
(`-c')オプションは，SET1をその補集合(SET1に無い全て
の文字)に置換します．

   終了ステータスのゼロは成功を示し，ゼロ以外の値は失敗を示します．

* Menu:

* Character sets::              Specifying sets of characters.
* Translating::                 Changing one set of characters to another.
* Squeezing::                   Squeezing repeats and deleting.
* Warnings in tr::              Warning messages.


File: coreutils-ja.info,  Node: Character sets,  Next: Translating,  Up: tr invocation

9.1.1 文字の組の指定
--------------------

SET1とSET2の引数の書式は，正規表現の書式に似ています．しか
し正規表現ではなく，文字のリストのみです．これらの文字列のほとんどの文
字は単にその文字自身を表しますが，利便性のため，文字列には以下でリスト
アップされた速記を含むことができます．そのうち，以下で注意する
SET1またはSET2のみでしか利用できないものもあります．

バックスラッシュエスケープ
     以下でリストアップされていない，文字が続くバックスラッシュは，エラーメッ
     セージを発生します．

    `\a'
          Control-G.

    `\b'
          Control-H.

    `\f'
          Control-L.

    `\n'
          Control-J.

    `\r'
          Control-M.

    `\t'
          Control-I.

    `\v'
          Control-K.

    `\OOO'
          OOOで与えられる値の文字で，一桁から三桁までの八進数．

    `\\'
          バックスラッシュ．

範囲
     表記方法の`M-N'は，MからNまで昇順に，全て
     の文字に展開されます．Mは，対照でNの前であるべきです．そう
     でない場合，結果としてエラーとなります．例としては，`0-9'は
     `0123456789'と同じです．

     GNU `tr'は，範囲を囲む角括弧を使用するSystem V構文をサポー
     トしません．その書式で指定された変換は，括弧はそれ自身に変換されるので，
     期待したように動作します．しかし，期待しない動作を行なうときもあるので
     避けるべきです．例えば，`tr -d '[0-9]''は数字だけでなく括弧も削除
     します．

     多くの歴史的に一般的なものと，範囲の使用の受け入れには移植性がありませ
     ん．例えば，EBCDICのホストでは，`A-Z'の範囲を使用すると，
     ASCIIでは`A'から`Z'までが不連続なので期待したよう
     に動作しません．POSIXに準拠しているバージョンの`tr'
     に依存している場合，これを回避する最善の方法は，文字クラスを使用するこ
     とです(以下を参照して下さい)．それ以外では，範囲内のメンバーを列挙する
     ことが最も移植性がある(そして最も醜い)方法です．

繰り返される文字
     SET2での`[C*N]'の表記は，文字CのN個
     のコピーに展開されます．このため，`[y*6]'は`yyyyyy'と同じで
     す．SET2での`[C*]'の表記は，SET2をSET1と
     同じ長さにするのに必要なたくさんのCのコピーに展開されます．
     Nが`0'で始まる場合は八進数に，それ以外では十進数だと解釈さ れます．

文字クラス
     `[:CLASS:]'の表記は，(あらかじめ定義された)クラス CLASS
     にある全ての文字に展開されます．文字は，特定の順序で展開さ
     れませんが，`upper'と`lower'クラスは，昇順に展開されます．
     `--delete' (`-d')と`--squeeze-repeats'
     (`-s')オプションが両方与えられている場合，すべての文字クラスを
     SET2で使用することが可能です．それ以外の場合，文字クラス
     `lower'と`upper'はSET2に適用され，さらに，対応する(そ
     れぞれ`upper'と`lower'の)文字クラスがSET1の位置に相対
     的に同じものが指定されている場合だけそうなります．これは，大文字小文字
     の変換の指定です．クラス名は以下で与えられます．無効なクラス名が与えら
     れた場合，結果としてエラーとなります．

    `alnum'
          文字と数字．

    `alpha'
          文字．

    `blank'
          水平方向の空白．

    `cntrl'
          コントロール文字．

    `digit'
          数字．

    `graph'
          スペースを含まない，印刷可能な文字．

    `lower'
          小文字．

    `print'
          スペースを含む，印刷可能な文字．

    `punct'
          句読点文字．

    `space'
          水平垂直の空白．

    `upper'
          大文字．

    `xdigit'
          16進数の数字．

等価なクラス
     構文`[=C=]'は，Cと等価な文字の全てに，特定の順序を持
     たずに展開されます．等価なクラスは，英語以外のアルファベットをサポート
     する目的で，比較的最近発明されました．しかし，それらの定義や内容を決定
     する標準的な方法はなさそうです．そのため，GNU `tr'では，
     完全には実装されていません．それぞれの文字の等価クラスは，その文字から
     のみ構成されていて，特定の利用価値はありません．


File: coreutils-ja.info,  Node: Translating,  Next: Squeezing,  Prev: Character sets,  Up: tr invocation

9.1.2 変換
----------

SET1とSET2の両方が与えられ，`--delete'
(`-d')オプションが与えられていない場合，`tr'は変換を実
行します．`tr'は，SET1にある入力のぞれぞれの文字を，対応
するSET2の文字に変換します．SET1に無い文字は，そのまま変換
されず通過します．SET1の文字が一回以上現われ，SET2の対応す
る文字が全て同じではない場合，最後の一つのみ使用されます．例えば，以下
の二つのコマンドは等価です．

     tr aaa xyz
     tr a z

   `tr'の一般的な使用法は，小文字を大文字に変換することです．これ
を行なう方法はたくさんあるはずです．その三つを以下に書きます．

     tr abcdefghijklmnopqrstuvwxyz ABCDEFGHIJKLMNOPQRSTUVWXYZ
     tr a-z A-Z
     tr '[:lower:]' '[:upper:]'

しかし，上記の`a-z'のような範囲の使用には移植性がありません．

   `tr'が変換を実行しているとき，SET1とSET2は，通常同
じ長さです．SET1がSET2より短い場合，SET2の終りの余分
な文字は無視されます．

   一方，SET1をSET2より大きくすることは移植性がありません．
POSIXでは，その結果が未定義だと述べています．この場合，BSD
`tr'は，SET2をSET2の最後文字で必要なだけ繰り返すこ
とでSET1の長さに引き延ばします．System V `tr'は，
SET1をSET2の長さに切り詰めます．

   デフォルトで，GNU `tr'はBSD `tr'のようにこの状態
を処理します．`--truncate-set1' (`-t')オプションが与えら
れている場合，GNU `tr'はSystem V `tr'のようにこの
状態を処理します．このオプションは，変換以外の処理では無視されます．

   この場合，System V `tr'のように動作させると，比較的一般的なBSD
の表現は壊れます．

     tr -cs A-Za-z0-9 '\012'

それは，全ての非英数字を改行に変換する代わりに，(SET1の補語の最
初の要素)ゼロバイトのみ変換されるためです．

ところで，上記の慣例は範囲を使用しているので移植性がありません．
POSIXが`tr'に文句をいう場合，ここでは以下のように書
いた方が良いでしょう．

     tr -cs '[:alnum:]' '[\n*]'


File: coreutils-ja.info,  Node: Squeezing,  Next: Warnings in tr,  Prev: Translating,  Up: tr invocation

9.1.3 繰り返しの圧縮と削除
--------------------------

`--delete' (`-d')オプションのみ与えられたとき，
`tr'は，SET1にあるあらゆる入力文字を削除します．

   `--squeeze-repeats' (`-s')オプションのみ与えられたとき，
`tr'は，SET1にある，それぞれの入力で繰り返される文字の並
びを，その文字が一度だけ表れるように置換します．

   `--delete'と`--squeeze-repeats'の両方が与えられた場合，
`tr'は，最初にSET1を用いて削除を実行し，SET2を用い
て残りの文字から繰り返しを圧縮します．

   `--squeeze-repeats'オプションは，変換時にも利用でき，その場合，
`tr'は，最初に変換を実行し，SET2を用いて残りの文字から繰
り返しを圧縮します．

   ここに，オプションの様々な組合せの表現例をいくつかあげます．

   * 全てのゼロバイトを削除．

          tr -d '\000'

   *
     全ての単語を単独行にします．これは，全ての非英数文字を改行に変換し，繰
     り返される改行になっているそれぞれの文字列を単一の改行に圧縮します．

          tr -cs '[:alnum:]' '[\n*]'

   * 繰り返される改行のそれぞれの並びを，単一の改行に変換します．

          tr -s '\n'

   *
     ドキュメントで単語の二重の出現を見付けます．例えば，改行で分離されてい
     る繰り返している単語"the the"と書くこともよくあります．以下のbourne
     シェルスクリプトは，最初に句読点と空白文字の並びを単一の改行文字に変換
     する動作を行います．それでそれぞれの"単語"が単独行に書かれます．次に
     全ての大文字を小文字に置き換え，最後に繰り返している単語だけを出力する
     ために，`uniq'を`-d'オプションで実行します．

          #!/bin/sh
          cat "$@" \
            | tr -s '[:punct:][:blank:]' '\n' \
            | tr '[:upper:]' '[:lower:]' \
            | uniq -d

   * 文字の小さな組を削除することは，一般的に簡単です．例えば，すべての
     `a'，`x'，そして`M'を削除するために，以下のようにします．

          tr -d axM

     しかし，これらの文字の一つが`-'のとき，`-'には特別な意味があ
     るので，ちょっとトリッキーになります．上記と同じ作業を実行し，さらにす
     べての`-'文字を削除するため，`tr -d -axM'を試してみるかもし
     れませんが，`tr'は`-a'をコマンドラインオプションと解釈
     しようとするので失敗するでしょう．代わりに，文字列の間にハイフンを
     `tr -d a-xM'のように書いてみても，`tr'は`a-x'を三文
     字ではなく`a'...`x'の範囲として解釈するので動作しません．
     問題を解決する方法の一つは，文字のリストの最後にハイフンを書くことです．

          tr -d axM-

     より一般的に，文字クラスの表記`[=c=]'を使用し，`-'(または，
     任意の文字)を`c'の位置に書きます．

          tr -d '[=-=]axM'

     上記の例で使用しているシングルクオートは，角括弧をシェルが解釈すること
     を防ぎます．



File: coreutils-ja.info,  Node: Warnings in tr,  Prev: Squeezing,  Up: tr invocation

9.1.4 警告メッセージ
--------------------

環境変数`POSIXLY_CORRECT'を設定すると，POSIXを厳密に遵守
するため，以下の警告とエラーのメッセージをオフにします．それ以外の場合，
以下の診断結果を出力します．

  1. `--delete'オプションが与えられているが，
     `--squeeze-repeats'が与えられておらず，SET2が与えられてい
     るとき，GNU `tr'は，SET2が使用されないため，デフォ
     ルトで使用方法のメッセージを出力し終了します．POSIX仕様では，
     この場合SET2は無視する必要があると述べられています．黙って引数を
     無視するのは悪い考えです．

  2. 曖昧な八進数のエスケープが与えられたときです．例えば`\400'は，八
     進数の400の値が単一バイトに適さないので，実際には`0'が後置された
     `\40'になります．


   GNU `tr'は，BSDやSystem Vとの完全な互換性を提供していませ
ん．例えば，POSIXの概念`[:alpha:]'，`[=c=]'，そし
て`[c*10]'の解釈を利用不可にすることはできません．また，GNU
`tr'は，ゼロバイトを保護する方法を提供できない伝統的なUnixバー
ジョンと異なり，ゼロバイトを自動的に削除できません．


File: coreutils-ja.info,  Node: expand invocation,  Next: unexpand invocation,  Prev: tr invocation,  Up: Operating on characters

9.2 `expand': タブをスペースに変換
==================================

`expand'は，与えられたそれぞれのFILE，または，与えられな
い場合や`-'のFILEの場合は標準入力の内容を，タブ文字を適切な
数のスペースに変換して，標準出力に書き出します．概要です．

     expand [OPTION]... [FILE]...

   デフォルトで，`expand'は全てのタブをスペースに変換します．それ
は全ての出力でバックスペース文字を維持します．それらはタブ計算に対し，
列の数を減少させます．デフォルトの動作は`-8'(タブをそれぞれ八列
に設定する)と同じです．

   プログラムは，以下のオプションを受け入れます．*Note Common
options::も参 照してください．

`-t TAB1[,TAB2]...'
`--tabs=TAB1[,TAB2]...'
     一つのタブストップのみ与えられた場合，タブをTAB1個の別々のスペー
     ス(デフォルトで8)に設定します．それ以外の場合，タブをTAB1，
     TAB2，...(0から番号付けされる)列に設定し，与えられた最後のタ
     ブストップ以降のあらゆるタブを単一のスペースで置換します．タブストップ
     は，カンマではなく空白で分けることも可能です．

     古いシステムでは，`expand'は時代遅れのオプション
     `-TAB1[,TAB2]...'をサポートしていて，そこではタ
     ブストップをカンマで分離するはずです．POSIX 1003.1-2001 (*note
     Standards conformance::)ではこれを許可していません．代わりに `-t
     TAB1[,TAB2]...'を使用してください．

`-i'
`--initial'
     それぞれの行の最初のタブ(前にあるものが全て非スペース文字や非タブ文字
     となるもの)をスペースに変換します．


   終了ステータスのゼロは成功を示し，ゼロ以外の値は失敗を示します．


File: coreutils-ja.info,  Node: unexpand invocation,  Prev: expand invocation,  Up: Operating on characters

9.3 `unexpand': スペースをタブに変換する
========================================

`unexpand'は，与えられたそれぞれのFILE，または与えられな
い場合や`-'のFILEに対しては標準入力の内容を，二つ以上のスペー
スやタブ文字の文字列を，二つ以上のスペースやタブ文字を，必要とされる数
のスペースを可能な限り連続するタブに変換しながら，内容を標準出力に書き
出します．概要です．

     unexpand [OPTION]... [FILE]...

   デフォルトで，`unexpand'は，最初のスペースとタブ(前にあるもの
が全て非スペース文字や非タブ文字となるもの)だけを，ぞれぞれの行で変換
します．それは，出力でバックスペース文字を維持します．タブの計算で列が
減少します．デフォルトで，タブは八列単位に設定されます．

   プログラムは以下のオプションを受け入れます．*Note Common
options::も参照 してください．

`-t TAB1[,TAB2]...'
`--tabs=TAB1[,TAB2]...'
     一つのタブストップのみ与えられた場合，タブを，デフォルトの8の代わりに，
     それぞれTAB1スペースに設定します．それ以外の場合，タブを
     TAB1列，TAB2列，... (0から番号付けされる)に設定し，与
     えられたタブストップ以降のスペースタブは，変更されずに残ります．タブス
     トップはカンマではなく空白で分離することも可能です．オプションは暗黙に
     `-a'オプションを指定します．

     古いシステムでは，`unexpand'は時代遅れのオプション
     `-TAB1[,TAB2]...'をサポートしていて，そこではタ
     ブストップをカンマで分離するはずです．POSIX 1003.1-2001 (*note
     Standards conformance::)ではこれを許可していません．代わりに
     `--first-only -t TAB1[,TAB2]...'を使用してくだ さい．

`-a'
`--all'
     最初のものだけでなく，全ての二つ以上のスペースやタブをタブに変換します．


   終了ステータスのゼロは成功を示し，ゼロ以外の値は失敗を示します．


File: coreutils-ja.info,  Node: Directory listing,  Next: Basic operations,  Prev: Operating on characters,  Up: Top

10 ディレクトリのリストアップ
*****************************

この章では，`ls'コマンドとその変形の`dir'と
`vdir'を記述し，それはファイルに関する情報をリストアップします．

* Menu:

* ls invocation::               List directory contents.
* dir invocation::              Briefly ls.
* vdir invocation::             Verbosely ls.
* dircolors invocation::        Color setup for ls, etc.


File: coreutils-ja.info,  Node: ls invocation,  Next: dir invocation,  Up: Directory listing

10.1 `ls': ディレクトリの内容をリストアップ
===========================================

`ls'プログラムは，ファイル(のすべての形式で，ディレクトリを含
む)に関する情報をリストアップします．オプションとファイル引数は，通常
のものと同様，任意に混ぜることが可能です．

   オプションの無いコマンドラインのディレクトリ引数に対し，`ls'は
デフォルトで，ディレクトリの内容をリストアップし，それは再帰的ではなく，
`.'で始まる名前を持つファイルは除外しています．他のオプションの無
い引数に対し，`ls'はデフォルトで，そのファイル名のみをリストアッ
プします．オプションではない引数が指定されない場合，`ls'は現在
のディレクトリの内容をリストアップします．

デフォルトで，出力はアルファベット順に出力され，それはロカールの設定に
影響されます．(1)
標準出力が端末の場合，出力は(垂直方向にソートされた)列になり，制御文字
は疑問符として出力されます．それ以外の場合，出力は一行ごとにリストアッ
プされ，制御文字はそのままになります．

   `ls'はあまりに基本的なプログラムなので，数年かけて多くのオプショ
ンを蓄積してきました．それらは以下のサブセクションで記述します．それぞ
れのセクションで，オプションはアルファベット順に(大文字小文字を無視し
て)リストアップされています．オプションをサブセクションに分けることは
絶対ではなく，それは，一つ以上の`ls'の処理の局面に影響するため です．

   終了ステータスのゼロは成功を示し，ゼロ以外の値は失敗を示します．

   *Note Common options::も参照してください．

* Menu:

* Which files are listed::
* What information is listed::
* Sorting the output::
* More details about version sort::
* General output formatting::
* Formatting file timestamps::
* Formatting the file names::

   ---------- Footnotes ----------

   (1) POSIXロカールにではないものを使用し
ている(例えば，`LC_ALL'を`en_US'に設定している)場合， `ls'
は慣れているものとは異なる並べ替えの出力を生成する可能性
があります．そのような状況では，`LC_ALL'を`C'に設定して下さい．


File: coreutils-ja.info,  Node: Which files are listed,  Next: What information is listed,  Up: ls invocation

10.1.1 リストアップされるファイル
---------------------------------

これらのオプションは，`ls'がリストアップするファイルの情報を決
定します．デフォルトで，コマンドラインのあらゆるファイルとディレクトリ
の内容が表示されます．

`-a'
`--all'
     `.'で始まるファイルを含め，ディレクトリの全てのファイルをリストアッ
     プします．

`-A'
`--almost-all'
     `.'と`..'以外の，ディレクトリの全てのファイルをリストアップ
     します．

`-B'
`--ignore-backups'
     コマンドラインで与えられない限り，`~'で終るファイルをリストアップ
     しません．

`-d'
`--directory'
     ディレクトリの名前のみリストアップし，それはファイルの他の形式と同様で，
     その内容をリストアップしません． `--dereference-command-line'
     (`-H')， `--dereference' (`-L')，または
     `--dereference-command-line-symlink-to-dir'オプションが指定され
     ていない限り，コマンドラインでリストアップされているシンボリックリンク
     をたどりません．

`-H'
`--dereference-command-line'
     コマンドライン引数がシンボリックリンクを指定している場合，リンク自身で
     はなくリンクが参照しているファイルの情報を表示します．

`--dereference-command-line-symlink-to-dir'
     一つの例外がありますが，シンボリックリンクを間接参照しません．コマンド
     ライン引数で，ディレクトリを参照するシンボリックリンクが指定されている
     場合，リンク自身ではなくディレクトリの情報を表示します．他に参照に関連
     するオプション(`--classify' (`-F')，`--directory'
     (`-d')，(`-l')，`--dereference' (`-L')，ま
     たは`--dereference-command-line' (`-H'))が指定されていな
     いとき，これはデフォルトの動作です．

`-I PATTERN'
`--ignore=PATTERN'
     コマンドラインで与えられていない限り，シェルパターン(正規表現ではあり
     ません)PATTERNにマッチする名前のファイルをリストアップしません．
     シェルと同様に，ファイル名の最初の`.'は，PATTERNの最初のワ
     イルドカードにマッチしません．このオプションを複数回与えると便利なとき
     もあります．例えば，以下のようにします．

          $ ls --ignore='.??*' --ignore='.[^.]' --ignore='#*'

     最初のオプションは，`.'で始まる長さが3文字以上の名前を無視し，二
     番目は`..'以外の`.'で始まる全ての2文字の名前を無視し，三番目
     は`#'で始まる名前を無視します．

`-L'
`--dereference'
     長いリストで，シンボリックリンク自身ではなくシンボリックリンクが参照す
     るファイルの情報(例えば，時間や許可)を表示します．しかし，このオプショ
     ンを使用していても，`ls'はリンク先のファイル名ではなく，リンク
     自身の名前を出力します．

`-R'
`--recursive'
     全てのディレクトリの内容を，再帰的にリストアップします．



File: coreutils-ja.info,  Node: What information is listed,  Next: Sorting the output,  Prev: Which files are listed,  Up: ls invocation

10.1.2 リストアップされる情報
-----------------------------

これらのオプションは，`ls'が表示する情報に影響します．デフォル
トで，ファイル名のみ表示されます．

`--author'
     長い書式のディレクトリのリストを生成するとき，それぞれのファイルの著者
     をリストアップします．GNU/Hurdでは，ファイルの著者はその所有者とは異な
     りますが，他のオペレーティングシステムではその二つは同じです．

`-D'
`--dired'
     長いリスト(`-l')の書式を用いた場合，主な出力の後に追加して以下
     を出力します．

          //DIRED// BEG1 END1 BEG2 END2 ...

     BEGNとENDNは，出力のそれぞれのファイル名の始めと終りのバイ
     ト位置を記録する符号無し整数です．これで，たとえスペースや改行といった
     通常用いない文字を含むときも，異常な検索をすることなく，Emacsで簡単に
     名前を見つかるようになります．

     ディレクトリが再帰的(`-R')にリストアップされる場合，出力はそれ
     ぞれのサブディレクトリの後に，良く似た行を出力します．
          //SUBDIRED// BEG1 END1 ...

     最終的に以下の形式の行を出力します．
          //DIRED-OPTIONS// --quoting-style=WORD
     WORDは引用形式です(*note Formatting the file names::)．

     以下は実際の例です．

          $ mkdir -p a/sub/deeper a/sub2
          $ touch a/f1 a/f2
          $ touch a/sub/deeper/file
          $ ls -gloRF --dired a
            a:
            total 8
            -rw-r--r--  1    0 Dec  3 00:50 f1
            -rw-r--r--  1    0 Dec  3 00:50 f2
            drwxr-xr-x  3 4096 Dec  3 00:50 sub/
            drwxr-xr-x  2 4096 Dec  3 00:50 sub2/

            a/sub:
            total 4
            drwxr-xr-x  2 4096 Dec  3 00:50 deeper/

            a/sub/deeper:
            total 0
            -rw-r--r--  1 0 Dec  3 00:50 file

            a/sub2:
            total 0
          //DIRED// 49 51 86 88 123 126 162 166 222 228 288 292
          //SUBDIRED// 2 3 171 176 233 245 296 302
          //DIRED-OPTIONS// --quoting-style=literal

     上記の`//DIRED//'行のオフセットの組が，以下の名前`f1'，
     `f2'，`sub'，`sub2'，`deeper'，`file'を分離し
     ていることに注意して下さい．`//SUBDIRED//'行のオフセットは，以下
     のディレクトリ名`a'，`a/sub'，`a/sub/deeper'，
     `a/sub2'を分離しています．

     以下は，五番目の項目名を抽出する方法，`deeper'の例で，対応するオ
     フセットの組は，222と228です．

          $ ls -gloRF --dired a > out
          $ dd bs=1 skip=222 count=6 < out 2>/dev/null; echo
          deeper

     上記のリストには，`deeper'の項目に対してスラッシュが後置されてい
     ますが，オフセットは，最後のスラッシュを用いていない名前を選択している
     ことに注意して下さい．しかし，`ls'を `--escape'(`-b')
     のようなオプションとともに
     `--dired'を用いて呼び出し，特殊文字を含むファイル名を処理する場
     合，バックスラッシュが含まれる_こと_に注意して下さい．

          $ touch 'a b'
          $ ls -blog --dired 'a b'
            -rw-r--r--  1 0 Dec  3 00:52 a\ b
          //DIRED// 31 35
          //DIRED-OPTIONS// --quoting-style=escape

     引用の印(例えば`--quoting-style=c')を追加して，引用形式を使用し
     ている場合，オフセットには引用の印が含まれます．そのため，ユーザが環境
     変数`QUOTING_STYLE'で，引用形式を選択している可能性があることに注
     意して下さい．このため，`--dired'を使用しているアプリケーション
     では，明示的にコマンドラインで`--quoting-style=literal'オプショ
     ン(`-N'または`--literal')を指定する，またはエスケープさ
     れた名前のパーサを用意しておいて下さい．

`--full-time'
     長い形式のディレクトリリストの書式と，完全な時間のリストを生成します．
     `--time-style=full-iso'とともに`--format=long'を使用する
     ことと等価です(*note Formatting file timestamps::)．

`-g'
     長い書式のディレクトリのリスト表示ですが，所有者の情報は表示しません．

`-G'
`--no-group'
     長い書式のディレクトリのリスト表示で，グループ情報の表示を禁止します．
     (これはGNUではないバージョンの`ls'ではデフォルトで，我々
     は互換性のためにこのオプションを提供します．)

`-h'
`--human-readable'
     メビバイトに対する`M'のような，サイズ文字を追加します．1000倍では
     なく1024倍が使用されます．`M'は1,048,576バイトを意味します．1000
     倍を望む場合，`--si'オプションを使用してください．

`-i'
`--inode'
     それぞれのファイルのinode番号(ファイルシリアル番号とインデックス番号と
     も呼ばれています)を，ファイル名の左に出力します．(この番号は，特定のファ
     イルシステム内の，それぞれのファイルを単一のものとして識別します．)

`-l'
`--format=long'
`--format=verbose'
     それぞれのファイル名に加えて，ファイル形式，許可，ハードリンク数，所有
     者名，バイトのサイズ，そして通常は編集した時間となっているタイムスタン
     プ(*note Formatting file timestamps::)を出力します．

     通常，サイズは句読点を用いずバイト数を出力しますが，これは優先可能です
     (*note Block size::)．例えば，`-h'では，人間が読み易い省略した
     ものを出力し，`--block-size="'1"'は，現在のロカールで千単位で分離
     してバイト数を出力します．

     リストアップされているそれぞれのディレクトリに対し，`total
     BLOCKS'という行をファイルに前置し，そこでのBLOCKSは，その
     ディレクトリの全てのファイルに対する全体的なディスク占有量です．ブロッ
     クサイズは，現在デフォルトで1024バイトですが，これに優先させることが可
     能です(*note Block size::)．BLOCKSは，それぞれのハードリンクを別々
     に数えて計算します．これはおそらく欠陥です．

     リストアップされる許可は，象徴的なモードでの指定に似ています
     (*note Symbolic Modes::)．しかし，`ls'は，それぞれの許可の設定
     を複数のビットを三番目の文字に組み合わせ，以下のようにします．

    `s'
          setuidやsetgidビットと対応する実行可能ビットが，両方設定されている場合．

    `S'
          setuidやsetgidビットは設定されているが，対応する実行可能ビットが設定さ
          れていない場合．

    `t'
          stickyビットとotherの実行可能ビットが両方設定されている場合．

    `T'
          stickyビットは設定されているが，otherの実行可能ビットが設定されていな
          い場合．

    `x'
          実行可能ビットが設定されていて，上記は何も適応されない場合．

    `-'
          それ以外．

     許可ビットに続くものは，ファイルに適用するアクセス手法の変更を指定する
     単一の文字です．文字がスペースのとき，アクセス手法の変更はありません．
     印刷可能な文字(例えば`+')のとき，そのような手法があります．

`-n'
`--numeric-uid-gid'
     長い書式でディレクトリのリストを生成しますが，所有者とグループの名前の
     代わりに数値のUIDとGIDをリストアップします．

`-o'
     長いディレクトリのリストの書式を生成しますが，グループ情報は表示しませ
     ん．それは，`--no-group'を用いた`--format=long'の使用と 同じです．

`-s'
`--size'
     ファイル名の左側に，それぞれのファイルのディスク占有量を出力します．こ
     れは，ファイルが使用しているディスクスペースの総量で，それは通常ファイ
     ルサイズよりわずかに多くなりますが，ファイルに欠陥がある場合は，より小
     さくなるはずです．

     通常ディスクの占有量は1024バイト単位で出力されますが，これに優先させる
     ことが可能です(*note Block size::)．

     HP-UXシステムからBSDシステムに，NFSでマウントされているファイルに対し，
     このオプションは，正しい値の半分のサイズを報告します．HP-UXシステムで
     は，BSDシステムからNFSでマウントされているファイルに対し，正しい値の2
     倍のサイズを報告します．これは，HP-UXの欠点のためです．それはHP-UXの
     `ls'プログラムにも影響します．

`--si'
     メガバイトに対する`MB'のような，SI形式のサイズの略語を追加します．
     1024倍ではなく1000倍が使用されます．`MB'は1,000,000バイトを意味し
     ます．このオプションは，`--block-size=si'と等価です．1024倍を望
     む場合，`-h'または`--human-readable'オプションを使用して ください．



File: coreutils-ja.info,  Node: Sorting the output,  Next: More details about version sort,  Prev: What information is listed,  Up: ls invocation

10.1.3 出力の並べ替え
---------------------

これらのオプションは，`ls'が並べ替える出力の情報の順序を変更し
ます．デフォルトで，並べ替えは文字コードによって行われます(例えば，
ASCIIの順番です)．

`-c'
`--time=ctime'
`--time=status'
`--time=use'
     長いリスト書式(例えば，`-l'，`-o')が使用されている場合，
     編集時間の代わりにステータス変更時間(inodeの`ctime')が出力されま
     す．時間(`--sort=time'または`-t')で明示的に並べ替えをし
     たり，長いリストの書式を使用しないとき，ステータスの変更時間によって並
     べ替えます．

`-f'
     主に，`-U'に似ています -- 並べ替えしません．ディレクトリに保存
     されているファイルの順番に，それらをリストアップします．しかし，
     `-a'(すべてのファイルをリストアップ)も利用可能で，(前に
     `-f'が指定されている場合)`-l'，`--color'，そして
     `-s'は利用不可能です．

`-r'
`--reverse'
     並べ替えのあらゆる手法を反転します --
     例えば，アルファベットの逆順，
     新しいものを最初，小さいものを最初，またはすべて逆順にリストアップしま
     す．

`-S'
`--sort=size'
     ファイルサイズで，大きいものを最初にして並べ替えます．

`-t'
`--sort=time'
     編集時間(inodeの`mtime')で，新しいものを最初にして並べ替えます．

`-u'
`--time=atime'
`--time=access'
     長いリスト書式(例えば，`--format=long')が使用されている場合，最
     後にアクセスした時間(inodeの`atime')が出力されます．時間
     (`--sort=time'または`-t')で明示的に並べ替えをしたり，長
     いリストの書式を使用しないとき，アクセスした時間によって並べ替えます．

`-U'
`--sort=none'
     並べ替えしません．ディレクトリに保存されている順番にファイルをリストアッ
     プします．(`-f'が行う，他と関連することは何もしません．) 並べ替
     えを行わないことで，目立って速くすることが可能なので，非常に大きなディ
     レクトリをリストアップするとき，これは特に便利です．

`-v'
`--sort=version'
     バージョン名と数字で，小さいものを最初にして並べ替えます．それはデフォ
     ルトの並べ替えに似ている動作で，それぞれの10進数の並びが，索引/バージョ
     ン番号として数値的に扱われることが期待されます．(*Note More
     details about version sort::.)

`-X'
`--sort=extension'
     ディレクトリの内容を，ファイルの拡張子(最後の`.'の後の文字)で，ア
     ルファベット順に並べ替えます．ファイルの拡張子がないものが最初になりま
     す．



File: coreutils-ja.info,  Node: More details about version sort,  Next: General output formatting,  Prev: Sorting the output,  Up: ls invocation

10.1.4 バージョンの並べ替えの詳細
---------------------------------

バージョンの並べ替えは，ファイル名が索引やバージョン番号を含むことが多
いという事実を考慮にいれています．標準的な並べ替え機能は，一文字づつを
基本に比較するため，通常，人々が期待する順序を生成しません．バージョン
の並べ替えは，この問題を提出し，その名前に索引/バージョン番号を伴うファ
イルを多く含むディレクトリを眺めるとき特に役に立ちます．

           > ls -1            > ls -1v
           foo.zml-1.gz       foo.zml-1.gz
           foo.zml-100.gz     foo.zml-2.gz
           foo.zml-12.gz      foo.zml-6.gz
           foo.zml-13.gz      foo.zml-12.gz
           foo.zml-2.gz       foo.zml-13.gz
           foo.zml-25.gz      foo.zml-25.gz
           foo.zml-6.gz       foo.zml-100.gz

数字の部分にゼロが前置されていても，分数として考慮されることに注意して
下さい．

           > ls -1            > ls -1v
           abc-1.007.tgz      abc-1.007.tgz
           abc-1.012b.tgz     abc-1.01a.tgz
           abc-1.01a.tgz      abc-1.012b.tgz

   この機能は，`strverscmp'関数を使用して実装しています． *Note
String/Array Comparison: (libc)String/Array
Comparison.実装を決定した結果，`ls -v'はロカールカテゴリの
`LC_COLLATE'を使用しなくなりました．結果として，数字以外の接頭辞は，
`LC_COLLATE'が`C'に設定されているかのように並べ替えられます．


File: coreutils-ja.info,  Node: General output formatting,  Next: Formatting file timestamps,  Prev: More details about version sort,  Up: ls invocation

10.1.5 一般的な出力書式
-----------------------

これらのオプションは，出力の外観に影響します．

`-1'
`--format=single-column'
     ファイルを一行ごとにリストアップします．これは，標準出力が端末でないと
     きのデフォルトです．

`-C'
`--format=vertical'
     列で縦方向に並べ替えされてリストアップされます．標準出力が端末の場合，
     これはデフォルトです．`dir'と`d'プログラムに対し，それは
     常にデフォルトです．GNU `ls'は，最も少ない行で可能な限り
     多くのファイルを表示できるように，列の幅を変更して使用します．

`--color [=WHEN]'
     ファイル形式を区別するため使用する色を指定します．WHENは省略され
     る，または以下の一つになります．
        * none - 色を全く使用しません．これはデフォルトです．

        * auto - 標準出力が端末の場合のみ色を使用します．

        * always - 常に色を使用します．
     `--color'を指定しWHENが無いのは，`--color=always'
     と同じです．色付きのリストを`more'や`less'の様なページャ
     にパイプで渡すと，通常読むことができない結果を生成します．しかし，
     `more -f'を使用すると動作するでしょう．

`-F'
`--classify'
`--indicator-style=classify'
     ファイル形式を示す文字を，それぞれのファイル名に追加します．また，実行
     可能な標準ファイルに対し，`*'を加えます．ファイル形式表示子は，ディ
     レクトリに対する`/'，シンボリックリンクに対する`@'，FIFOに
     対する`|'，ソケットに対する`='で，標準ファイルは何もありませ ん．
     `--dereference-command-line' (`-H')， `--dereference'
     (`-L')，または
     `--dereference-command-line-symlink-to-dir'オプションが指定され
     ていない限り，コマンドラインでリストアップされているシンボリックリンク
     をたどりません．

`--indicator-style=WORD'
     エントリー名にスタイルWORD文字表示子を以下のように追加します．
    `none'
          あらゆる文字表示子を追加しません．これはデフォルトです．

    `file-type'
          ディレクトリに対し`/'，シンボリックリンクに対し`@'，FIFOに
          対し`|'，ソケットに対し`='を追加し，標準ファイルには何も追加
          しません．これは`-p'や`--file-type'オプションと同じです．

    `classify'
          実行可能な標準ファイルに`*'を加え，それ以外は`file-type'とし
          て動作します．これは，`-F'や`--classify'オプションと同じ
          です．

`-k'
     ファイルの大きさを1024バイトブロックで出力し，デフォルトのブロックサイ
     ズ(*note Block size::)に優先します．

`-m'
`--format=commas'
     それぞれの行にできるだけ多くフィットするように，`, ' (カンマとス
     ペース)で分けて，水平方向にリストアップします．

`-p'
`--file-type'
`--indicator-style=file-type'
     それぞれのファイル名にファイル形式を示す文字を追加します．これは
     `-F'に似ていますが，実行可能なものは印を付けません．

`-x FORMAT'
`--format=across'
`--format=horizontal'
     ファイルを列に，水平にソートしてリストアップします．

`-T COLS'
`--tabsize=COLS'
     それぞれのタブストップがCOLS列の幅だと考えます．デフォルトは8で
     す．`ls'は，効率のために出力可能なところではタブを使用します．
     COLSが0の場合はタブを全く使用しません．

`-w'
`--width=COLS'
     画面がCOLS列の幅だと考えます．可能な場合，デフォルトは端末の設定
     で与えられます．それ以外で，環境変数`COLUMNS'が設定されている場合，
     それが使用されます．それ以外の場合，デフォルトの80です．



File: coreutils-ja.info,  Node: Formatting file timestamps,  Next: Formatting the file names,  Prev: General output formatting,  Up: ls invocation

10.1.6 ファイルのタイムスタンプの書式化
---------------------------------------

デフォルトで，ファイルのタイムスタンプは短縮した様式でリストアップされ
ます．ほとんどのロカールで`2002-03-30 23:45'のようなタイムスタン
プが使用されます．しかし，デフォルトのPOSIXロカールでは，昔
のタイムスタンプに対し`Mar 30  2002'のような日付を使用し，最近
のタイムスタンプに対し，`Mar 30 23:45'のように年が無い日付と時間
を使用します．

   タイムスタンプは，六カ月未満のものを"最近のもの(recent)"と考え，未
来のものは日付がつきません．タイムスタンプが今日の場合は，最近のものの
形式でリストアップされず，タイムスタンプが未来のものは，おそらく時間の
歪みの問題があることを意味し，`make'のようにファイルのタイムス
タンプに依存しているプログラムでは問題になる可能性があります．

以下のオプションで，ファイルのタイムスタンプを出力する方法を変更します．

`--time-style=STYLE'
     タイムスタンプをSTYLEの形式でリストアップします．STYLEは以
     下の一つにします．

    `+FORMAT'
          FORMATを使用してタイムスタンプをリストアップし，FORMATは
          `date'の書式化引数のように解釈されます(*note date
          invocation::)．例えば，`--time-style="+%Y-%m-%d %H:%M:%S"'で
          `ls'は`2002-03-30 23:45:56'のようにタイムスタンプをリスト
          アップします．`date'同様，FORMATの解釈では`LC_TIME'
          ロカールカテゴリの影響を受けます．

          FORMATに二つの書式化文字列が，改行で分けられて存在する場合，前者
          は最近のものではないファイルに使用され，後者は最近のファイルに使用され
          ます．出力列を並べたい場合，二つの書式の一つにスペースを挿入する必要が
          あるかもしれません．

    `full-iso'
          完全なISO 8601の日付，時間，タイムゾーンを，ナノ秒の精度を使
          用してタイムスタンプをリストアップし，例えば，`2002-03-30
          23:45:56.477817180 -0700'のようにします．この形式は`+%Y-%m-%d
          %H:%M:%S.%N %z'と等価です．

          オペレーティングシステムで利用可能なすべての情報を含んでいる時間の出力
          になるので，これは役に立ちます．例えば，ファイルが最新かどうかを決定す
          るため，GNU `make'は完全なタイムスタンプを使用するの
          で，`make'の動作を解釈する助けとなります．

    `long-iso'
          ISO 8601の日付，分単位の時間でリストアップし，例えば，
          `2002-03-30 23:45'のようにします．これらのタイムスタンプは，
          `full-iso'のタイムスタンプより短く，毎日の作業では通常十分に利用
          できるものです．この形式は`%Y-%m-%d %H:%M'と等価です．

    `iso'
          最近のものではないタイムスタンプはISO 8601(例えば，
          `2002-03-30
          ')で，最近のものは，月，日，時間，そして分でリストアッ
          プします(例えば，`03-30 23:45')．これらのタイムスタンプは，
          `long-iso'のタイムスタンプより悪くなりますが，より小さなスペース
          で同じ情報を提供し，また簡潔なので`ls'の出力は伝統的な80列の出
          力行に適しています．以下の二つの`ls'の呼び出しは等価です．

               newline='
               '
               ls -l --time-style="+%Y-%m-%d $newline%m-%d %H:%M"
               ls -l --time-style="iso"

    `locale'
          タイムスタンプをロカール依存の様式でリストアップします．例えば，フィン
          ランドのロカールでは，最近のものではないタイムスタンプを`maalis
          30  2002'のように，そして最近のもののタイムスタンプを`maalis
          30
          23:45'のようにリストアップするでしょう．ロカール依存のタイムスタンプは，
          通常，`iso'のタイムスタンプよりスペースを使用し，また，ロカールの
          慣習は幅広く，プログラムでパースするのはより難しくなりますが，多くの人々
          はそれで読み易くなります．

          `LC_TIME'ロカールカテゴリはタイムスタンプの書式を指定します．デフォ
          ルトのPOSIXロカールは，`Mar 30 2002'と`Mar 30
          23:45'のようなタイムスタンプを使用します．このロカールでは，以下の二つ
          の`ls'の呼び出しは等価です．

               newline='
               '
               ls -l --time-style="+%b %e  %Y$newline%b %e %H:%M"
               ls -l --time-style="locale"

          それ以外のロカールでは動作は異なります．例えばドイツのロカールでは，
          `--time-style="locale"'は`--time-style="+%e. %b %Y
          $newline%e. %b %H:%M"'と等価で，`30. Ma"r 2002 'と `30. Ma"r
          23:45'のようなタイムスタンプを生成するでしょう．

    `posix-STYLE'
          `LC_TIME'ロカールがPOSIXの場合，タイムスタンプを
          POSIXロカールで，それ以外ではSTYLEのタイムスタンプでリ
          ストアップします．例えば，デフォルトのスタイル`posix-long-iso'で
          は，POSIXロカールのときは，`Mar 30  2002'と`Mar 30
          23:45'のようなタイムスタンプで，それ以外では`2002-03-30 23:45'
          のようなタイムスタンプでリストアップします．

   `--time-style'オプションのデフォルト値を，環境変数
`TIME_STYLE'を用いて指定することが可能です．`TIME_STYLE'が設定
されていない場合，デフォルトのスタイルは`posix-long-iso'です． GNU
Emacs 21とそれ以降では，ISOの日付をパースする
ことは可能ですが，それより古いEmacsのバージョンではそうではないので，
古いバージョンのEmacsを使用していて，POSIX以外のロカールを指
定している場合，`TIME_STYLE="locale"'を設定する必要があるかもしれ
ません．


File: coreutils-ja.info,  Node: Formatting the file names,  Prev: Formatting file timestamps,  Up: ls invocation

10.1.7 ファイル名の書式化
-------------------------

これらのオプションは，ファイル名自身を出力する方法を変更します．

`-b'
`--escape'
`--quoting-style=escape'
     ファイル名の表示不可能な文字を，Cで使用されるような，アルファベットと
     八進数のバックスラッシュシーケンスを用いて引用符で囲みます．

`-N'
`--literal'
`--quoting-style=literal'
     ファイル名を引用符で囲みません．

`-q'
`--hide-control-chars'
     ファイル名の表示不能な文字の代わりに疑問符を出力します．出力が端末の場
     合と，プログラムが`ls'の場合，これはデフォルトです．

`-Q'
`--quote-name'
`--quoting-style=c'
     二重引用符でファイル名を囲み，表示不可能な文字をCのように引用符で囲み
     ます．

`--quoting-style=WORD'
     ファイル名とその他の任意の文字を含む文字列の引用符に形式WORDを使
     用します．WORDは以下の一つになります．
    `literal'
          そのまま文字列を出力します．これは，`-N'や`--literal'オ
          プションと同じです．

    `shell'
          文字列にシェルのメタ文字を含んでいたり，不明瞭な出力を生じる場合，引用
          符で囲みます．引用符で囲むことは，`bash'のような
          POSIX互換のシェルに対しては適切ですが，`csh'のように
          互換性の無いシェルで常に動作するわけではありません．

    `shell-always'
          シェルに対して，通常は引用符が不要な場合でも文字列を引用符で囲みます．

    `c'
          Cの文字列リテラルのように文字列を引用符で囲み，それには周りの二重引用
          符が含まれ．これは`-Q'や`--quote-name'オプションと同じで す．

    `escape'
          Cの文字列リテラルのように文字列を引用符で囲みますが，周りの二重引用符
          は省略したものになります．これは，`-b'や`--escape'オプショ
          ンと同じです．

    `clocale'
          Cの文字列リテラルのように文字列を引用符で囲みますが，周りの引用符はロ
          カールに適したものになります．

    `locale'
          Cの文字列リテラルのように文字列を引用符で囲みますが，周りの引用符はロ
          カールに適したものになり，デフォルトのCロカールでは"like
          this"の代 わりに`like
          this'のように引用符で囲みます．これは多くのディスプレ
          イでより良く見えます．

     `--quoting-style'オプションのデフォルト値を，環境変数
     `QUOTING_STYLE'で指定することが可能です．環境変数が設定されていな
     い場合，デフォルト値は`literal'ですが，このデフォルトは，このパッ
     ケージの将来のバージョンで`shell'に変更されるかもしれません．

`--show-control-chars'
     ファイル名の出力不可能な文字をそのまま出力します．出力が端末の場合やプ
     ログラムが`ls'の場合以外では，これがデフォルトです．



File: coreutils-ja.info,  Node: dir invocation,  Next: vdir invocation,  Prev: ls invocation,  Up: Directory listing

10.2 `dir': ディレクトリの内容の短いリスト
==========================================

`dir'(と`d'としてインストールされるもの)は，`ls -C
-b'と同じです．すなわち，デフォルトでファイルは列にリストアップされ，
縦方向に並べ替えされ，そして特殊文字はバックスペースエスケープシーケン
スで再表現されます．

   *Note `ls': ls invocation.


File: coreutils-ja.info,  Node: vdir invocation,  Next: dircolors invocation,  Prev: dir invocation,  Up: Directory listing

10.3 `vdir': ディレクトリの内容の冗長なリスト
=============================================

`vdir'は(`v'としてインストールされるものも)，`ls -l
-b'と同じです．すなわち，デフォルトでファイルは長い書式でリストアップ
され，特殊文字はバックスペースエスケープシーケンスで再表現されます．


File: coreutils-ja.info,  Node: dircolors invocation,  Prev: vdir invocation,  Up: Directory listing

10.4 `dircolors': `ls'の色をセットアップ
========================================

`dircolors'は，`ls' (と`dir'等)から出力する色
のために端末を設定する連続したシェルコマンドを出力します．一般的な使用
方法は以下の通りです．

     eval `dircolors [OPTION]... [FILE]`

   FILEが指定されている場合，`dircolors'は，ファイル形式と
拡張子に対して使用する色を決定するために，それを読み込みます．それ以外
の場合，前もってコンパイルされたデータベースが使用されます．これらのファ
イルの書式の詳細のため，`dircolors --print-database'を実行してく
ださい．

   出力は，`LS_COLORS'環境変数を設定するためのシェルコマンドです．コ
マンドラインで使用するシェル構文を指定することが可能で，そうでなければ
`dircolors'は`SHELL'環境変数の値から判別します．

   プログラムは以下のオプションも受け入れます．*Note Common
options::も参照 してください．

`-b'
`--sh'
`--bourne-shell'
     Bourneシェルコマンドを出力します．`SHELL'環境変数が設定されていて，
     `csh'や`tcsh'で終わらない場合，これはデフォルトです．

`-c'
`--csh'
`--c-shell'
     Cシェルコマンドを出力します．`SHELL'が`csh'や`tcsh'で終
     わる場合，これがデフォルトです．

`-p'
`--print-database'
     (組み込みの)デフォルトカラーの設定データベースを出力します．この出力は，
     それ自身有効な設定ファイルで，可能性をすべて記述しています．


   終了ステータスのゼロは成功を示し，ゼロ以外の値は失敗を示します．


File: coreutils-ja.info,  Node: Basic operations,  Next: Special file types,  Prev: Directory listing,  Up: Top

11 基本的なオペレーション
*************************

この章は，基本的なファイル操作に対するコマンドを記述します．コピー，移
動(名前の変更)，そして削除(リムーブ)です．

* Menu:

* cp invocation::               Copy files.
* dd invocation::               Convert and copy a file.
* install invocation::          Copy files and set attributes.
* mv invocation::               Move (rename) files.
* rm invocation::               Remove files or directories.
* shred invocation::            Remove files more securely.


File: coreutils-ja.info,  Node: cp invocation,  Next: dd invocation,  Up: Basic operations

11.1 `cp': ファイルとディレクトリのコピー
=========================================

`cp'は，ファイル(または，オプションでディレクトリ)をコピーしま
す．コピーはオリジナルから完全に独立しています．一つのファイルをもう一
つにコピーする，または，任意の多くのファイルをコピー先のディレクトリに
コピーすることのいずれかが可能です．概要です．

     cp [OPTION]... SOURCE DEST
     cp [OPTION]... SOURCE... DIRECTORY

   最後の引数が既存のディレクトリを指す場合，`cp'はそれぞれの
SOURCEファイルをそのディレクトリに(同じ名前のままで)コピーします．
それ以外で，二つのファイルが与えられた場合，最初のものを二番目のものに
コピーします．最後の引数がディレクトリでなく，二つ以上のオプションでな
い引数が与えられた場合エラーとなります．

一般的に，ファイルは読み込まれたとおりに書き込まれます．例外は，以下の
`--sparse'オプションを参照してください．

   デフォルトで，`cp'はディレクトリをコピーしません．しかし，
`-R'，`-a'，そして`-r'オプションでは，
`cp'は元のディレクトリを下り，対応するコピー先のディレクトリに
ファイルをコピーすることで，再帰的にコピーします．

   デフォルトで，`cp'は再帰的にコピーしないときのみ，シンボリック
リンクをたどります．このデフォルトは，`--no-dereference'
(`-d')，`--dereference' (`-L')，そして`-H'
オプションで優先することが可能です．これらのオプションの一つ以上が指定
されている場合，最後のものが他のものに対して，そのまま優先します．

   デフォルトで，`cp'は，再帰的なコピーではないときだけ特殊ファイ
ルの内容をコピーします．このデフォルトは，`--copy-contents'オプ
ションで優先させることが可能です．

   `cp'は一般的に，以下の例外はありますが，ファイルの自分自身への
コピーを拒絶します．`--force --backup'が同一のSOURCEと
DESTで指定され，通常のファイルを参照している場合，`cp'は，
通常の方法(*note Backup options::)で指定されたように，通常または番号付
きのバックアップファイルを作成します．これは，変更前に既存のファイルの
バックアップを単に作成したいとき役に立ちます．

   プログラムは以下のオプションも受け入れます．*Note Common
options::も参照 してください．

`-a'
`--archive'
     コピー時に，元のファイルの構造と属性を可能な限り保持します(しかし，ディ
     レクトリ構造の保持は試みません．すなわち，`ls -U'はコピーされてい
     るディレクトリの項目を，異なる順序でリストアップする可能性があります)．
     `-dpR'と同じです．

`-b'
`--backup[=METHOD]'
     *Note Backup options::.
     上書きされたり削除されたりするそれぞれのファイ
     ルのバックアップを作成します．特殊な場合として，強制とバックアップのオ
     プションが指定され，SOURCEとDESTが同じ名前で存在していると
     き，通常のファイルとして，`cp'はSOURCEのバックアップを作
     成します．このオプションの組合わせの役に立つ応用の一つは，以下の小さな
     Bourneシェルスクリプトです．

          #!/bin/sh
          # Usage: backup FILE...
          # Create a GNU-style backup of each listed FILE.
          for i; do
            cp --backup --force "$i" "$i"
          done

`--copy-contents'
     再帰的にコピーをしている場合，特殊ファイル(例えばFIFOとデバイスファイ
     ル)の内容を通常のファイルのようにコピーします．これは，それぞれのソー
     スファイルからデータを読み込み，それをコピー先に書き込むことを意味しま
     す．通常は，FIFOと`/dev'ディレクトリで見つかるような特殊ファイル
     では好ましくない効果があるので，このオプションの使い方はよく誤解されま
     す．ほとんどの状況で，FIFOと`/dev/console'のような特殊ファイルを
     読み込もうとして`cp -R --copy-contents'は限りなく読み込み続け，
     `/dev/zero'をコピーで使用している場合，コピー先のディスクはいっぱ
     いになるでしょう．このオプションは，再帰的にコピーしていない限り効果が
     無く，シンボリックリンクのコピーにも影響しません．

`-d'
     シンボリックリンクを，それが示すファイルをコピーするのではなく，シンボ
     リックリンクとしてコピーし，コピーのソースファイル間のハードリンクを保
     持します．`--no-dereference --preserve=links'と等価です．

`-f'
`--force'
     このオプションを使用せずコピーし，コピー先のファイルが存在し，書き込み
     で開くことができないとき，コピーは失敗します．しかし，`--force'
     を用いた場合，コピー先のファイルが開けないとき，`cp'はそれをア
     ンリンクし，もう一度開こうとします．この動作は，`--link'と
     `--symbolic-link'でそれを可能にすることとは異なり，それによって
     コピー先ファイルは開かれることなく，無条件にアンリンクされます．
     `--remove-destination'の記述も参照してください．

`-H'
     コマンドライン引数がシンボリックリンクを指定している場合，シンボリック
     リンクではなく，ファイルをその位置にコピーします．しかし，再帰的にたどっ
     ていて見つかったすべてのシンボリックリンクを(その元を保存して)コピーし
     ます．

`-i'
`--interactive'
     既存の通常のコピー先のファイルを上書きするかどうか，プロンプトを表示し
     ます．

`-l'
`--link'
     ディレクトリ以外はコピーの代わりにハードリンクを作成します．

`-L'
`--dereference'
     常にシンボリックリンクをたどります．

`-P'
`--no-dereference'
     シンボリックリンクを，それが示すファイルをコピーするのではなくシンボリッ
     クリンクとしてコピーします．

`-p'
`--preserve[=ATTRIBUTE_LIST]'
     指定されている元のファイルの属性を保持します．指定する場合，
     ATTRIBUTE_LISTは以下の文字列の一つ以上を，カンマで分離されたリス
     トにする必要があります．

    `mode'
          許可の属性を保持します．

    `ownership'
          所有者とグループの属性を保持します．最近のシステムでは，スーパーユーザ
          のみファイルの所有者を変更することが可能で，通常のユーザは，要求される
          グループのメンバーの場合のみ，ファイルの所有者のグループを保持すること
          が可能です．

    `timestamps'
          最後のアクセスと最後の編集のタイムスタンプを保持します．

    `links'
          対応するソースファイル間のリンクをコピー先のファイルに保持します．

    `all'
          すべてのファイル属性を保持します．上記のすべてを指定したものと等価です．

     ATTRIBUTE_LISTを用いずに`--preserve'を使用することは，
     `--preserve=mode,ownership,timestamps'と等価です．

     このオプションがないとき，それぞれのコピー先のファイルは，元のファイル
     に対応するパーミッションで作成され，umaskで設定されているビットがなく
     なり，そして，set-user-idビットとset-group-idビットがなくなります．
     *Note File permissions::.

`--no-preserve=ATTRIBUTE_LIST'
     指定された属性を保持しません．ATTRIBUTE_LISTは
     `--preserve'の形式と同じです．

`--parents'
     それぞれのコピー先のファイル名を，ターゲットディレクトリにスラッシュと
     指定されたソースファイルの名前を追加したものとして作成します．
     `cp'に与える最後の引数は，既存のディレクトリ名にする必要があり
     ます．例えば，以下のようなコマンドを入力します．

          cp --parents a/b/c existing_dir

     これはファイル`a/b/c'を`existing_dir/a/b/c'にコピーし，存在
     しないあらゆる中間ディレクトリを作成します．

`--reply[=HOW]'
     `--reply=yes'を使用すると，コピー先のファイルに関するすべてのプ
     ロンプトに対する応答として`yes'が与えられたかのように`cp'
     が動作します．それは，それまでに使用されていた`--interactive'や
     `-i'オプションを効果的に停止します．コピー先のファイルに関する
     すべてのプロンプトに対する応答として`no'が与えられたかのように
     `cp'に動作させるため，`--reply=no'を指定して下さい．そ
     れぞれ既存のコピー先のファイルに関して，`cp'がユーザにプロンプ
     トを表示するようにするため，`--reply=query'を指定して下さい．

`-R'
`-r'
`--recursive'
     再帰的にディレクトリをコピーします．デフォルトではシンボリックリンクを
     たどりません．`--archive' (`-a')，`-d'， `--dereference'
     (`-L')，`--no-dereference'
     (`-P')，そして`-H'オプションを参照して下さい．特殊ファイ
     ルは，元となるファイルと同じ形式でコピー先のファイルを作成することでコ
     ピーします．`--copy-contents'オプションを参照して下さい．シンボ
     リックリンクや特殊ファイルをコピーするために`-r'を使用すること
     には移植性がありません．GNU以外のシステムには，歴史的な理由から
     `-r'で`-L'と`--copy-contents'の等価物を暗黙に指定
     するものもあります．また，シンボリックリンクをコピーするため
     `-R'を使用することは，`-P'も指定しない限り移植性が無く，
     それは，デフォルトでシンボリックリンクの間接参照を行なう実装が
     POSIXで許可されているためです．

`--remove-destination'
     それぞれの既存のコピー先ファイルを，それを開く前に削除します(上記の
     `-f'とは異なります)．

`--sparse=WHEN'
     "まばらなファイル(sparse file)"は"穴(holes)" -- 物理的なディ
     スクブロックには発生しないゼロバイトの列 -- を含みます．`read'シ
     ステムコールはこれらをゼロとして読み込みます．バイナリファイルには連続
     するゼロバイトを含むことが多いので，これでディスクスペースの節約と速度
     の増加の両方を達成することが可能です．デフォルトでは，`cp'は発
     見的手法を用いて入力された元ファイルの穴を見付け，対応する出力ファイル
     に同様にまばらにします．通常のファイルだけがまばらになります．

     WHENの値は以下の一つになります．
    `auto'
          デフォルトの動作です：入力ファイルがまばらの場合，出力ファイルもまばら
          にするように試みます．しかし，出力ファイルが存在し，通常のファイルでは
          ないものを参照している場合，まばらにする試みは行ないません．

    `always'
          入力ファイルの十分に長いゼロバイトの連続に対し，入力ファイルがまばらで
          ない場合でも，出力ファイルに対応する穴(連続したゼロバイト)の作成を試み
          ます．これは，入力ファイルがまばらなファイルをサポートしていないファイ
          ルシステム(例えば，SGI IRIX
          5.3とそれ以前の`efs'ファイルシステム)
          に存在していて，出力ファイルがサポートしているファイルシステムのとき役
          に立ちます．穴(連続したゼロバイト)は通常のファイルにだけ作成されるので，
          コピー先のファイルが通常のファイルではない場合，`cp'はまばらに
          しようとはしません．

    `never'
          出力ファイルをまばらにしません．`mkswap'コマンドを用いてファイ
          ルを作成するとき，そのようなファイルには穴があってはならないので，これ
          が役に立ちます．

`--strip-trailing-slashes'
     それぞれのSOURCE引数から，後置されるスラッシュを削除します． *Note
     Trailing slashes::.

`-s'
`--symbolic-link'
     ディレクトリでないものをコピーする代わりにシンボリックリンクを作成しま
     す．すべての元ファイル名は，リンク先のファイルが現在のディレクトリにあ
     る場合以外，絶対的である(`/'で始まる)必要があります．シンボリック
     リンクをサポートしないシステムでは，このオプションは結果としてエラーメッ
     セージを返すだけです．

`-S SUFFIX'
`--suffix=SUFFIX'
     `-b'で作成されるそれぞれのバックアップファイル名に，
     SUFFIXを追加します．*Note Backup options::.

`--target-directory=DIRECTORY'
     移動(コピー)先のDIRECTORYを指定します．*Note Target directory::.

`-v'
`--verbose'
     コピーする前にそれぞれのファイル名を出力します．

`-V METHOD'
`--version-control=METHOD'
     `-b'で作成するバックアップの形式を変更します．METHOD引数
     は，`none' (または`off')，`numbered' (または`t')， `existing'
     (または`nil')，または`never' (または
     `simple')が利用可能です．*Note Backup options::.

`-x'
`--one-file-system'
     コピーを開始したファイルシステムと異なるサブディレクトリを省略します．
     しかし，マウントポイントのディレクトリはコピー_されます_．


   終了ステータスのゼロは成功を示し，ゼロ以外の値は失敗を示します．


File: coreutils-ja.info,  Node: dd invocation,  Next: install invocation,  Prev: cp invocation,  Up: Basic operations

11.2 `dd': ファイルの変換とコピー
=================================

`dd'は，変更可能なI/Oブロックサイズを用いて，(デフォルトで，標
準入力から標準出力に)ファイルをコピーし，オプションの動作でそれを変更
します．概要です．

     dd [OPTION]...

   プログラムは，以下のオプションも受け入れます．*Note Common
options::も参 照してください．

   以下の(BYTESとBLOCKS)数値的な値のオプションを続けて倍数に
することが可能です．それは，`b'=512，`c'=1，`w'=2，
`xM'=M，または`k'=1024のようなあらゆるブロックサ イズ接尾子です(*note
Block size::)．

   スキップとI/Oに対し異なるブロックサイズを使用するためは，`dd'
の呼び出しを別々に行なってください．例えば，以下のシェルコマンドでは，
ディスクとテープの間で512kBブロックでデータをコピーしますが，ディスク
の最初の4kBのラベルは，保存されたり復元されたりしません．

     disk=/dev/rdsk/c0t1d0s2
     tape=/dev/rmt/0

     # Copy all but the label from disk to tape.
     (dd bs=4k skip=1 count=0 && dd bs=512k) <$disk >$tape

     # Copy from tape back to disk, but leave the disk label alone.
     (dd bs=4k seek=1 count=0 && dd bs=512k) <$tape >$disk

   `SIGUSR1'シグナルを実行中の`dd'に送ることで，標準エラー出
力にレコード番号を出力し，そのまま続けて書き込み，コピーを再開します．
以下の例では，`dd'を10Mブロックをコピーする処理をバックグラン
ドで実行しています．`kill'コマンドで，直前のレコード数の最初の
組を出力し，`dd'が終了したとき最後の組を出力します．

     $ dd if=/dev/zero of=/dev/null count=10M & pid=$!
     $ kill -USR1 $pid; sleep 99
     5403604+0 records in
     5403604+0 records out
     10485760+0 records in
     10485760+0 records out

`if=FILE'
     標準入力の代わりにFILEから読み込みます．

`of=FILE'
     標準出力の代わりにFILEに書き出します．`conv=notrunc'が与え
     られていない場合，`dd'はFILEをゼロバイト(または，
     `seek='で指定されたサイズ)に切り詰めます．

`ibs=BYTES'
     一度にBYTESバイト読み込みます．

`obs=BYTES'
     一度にBYTESバイト書き出します．

`bs=BYTES'
     一度にBYTESバイト読み書きします．これは`ibs'と`obs'に 優先します．

`cbs=BYTES'
     一度にBYTESバイト変換します．

`skip=BLOCKS'
     コピーする前に入力ファイルで，BLOCKS `ibs'バイトブロックを
     読み飛ばします．

`seek=BLOCKS'
     コピーする前に出力ファイルで，BLOCKS `ibs'バイトブロックを
     読み飛ばします．

`count=BLOCKS'
     ファイルの終りまでのすべてではなく，入力ファイルからBLOCKS
     `ibs'バイトブロックコピーします．

`conv=CONVERSION[,CONVERSION]...'
     CONVERSION引数で指定されたようにファイルを変換します．(カンマの
     回りにスペースはありません．)

     以下の変換です．

    `ascii'
          EBCDICをASCIIに変換します．

    `ebcdic'
          ASCIIをEBCDICに変換します．

    `ibm'
          ASCIIを別のEBCDICに変換します．

    `block'
          入力のそれぞれの行に対し，入力の改行をスペースに置換し，必要なスペース
          を埋め込みながら，`cbs'バイト出力します．

    `unblock'
          それぞれの`cbs'の大きさの入力ブロックで，末尾のスペースを改行に置
          換します．

    `lcase'
          大文字を小文字に変換します．

    `ucase'
          小文字を大文字に変換します．

    `swab'
          入力バイトのすべての組を入れ替えます．GNU `dd'は他と異な
          り，偶数バイトを読み込んだとき動作します --
          最後のバイトは，単にコピー
          されます．(入れ替えるバイトがないからです)．

    `noerror'
          読み込みエラー後も続けます．

    `notrunc'
          出力ファイルを切り詰めません．

    `sync'
          すべての入力ブロックを，後置するゼロバイトを埋め込み`ibs'サイズに
          します．`block'や`unblock'を使用するとき，ゼロバイトの代わり
          にスペースで埋め込みます．


   終了ステータスのゼロは成功を示し，ゼロ以外の値は失敗を示します．


File: coreutils-ja.info,  Node: install invocation,  Next: mv invocation,  Prev: dd invocation,  Up: Basic operations

11.3 `install': ファイルのコピーと属性の設定
============================================

`install'は，許可モードと，可能な場合は所有者とグループ設定し
ながらファイルをコピーします．概要です．

     install [OPTION]... SOURCE DEST
     install [OPTION]... SOURCE... DIRECTORY
     install -d [OPTION]... DIRECTORY...

   これらの最初のものは，SOURCEファイルはDESTターゲットファイ
ルにコピーされます．二番目では，それぞれのSOURCEファイルはコピー
先のDIRECTORYにコピーされます．最後では，それぞれの
DIRECTORY(と足りない親ディレクトリ)がコピーされます．

   `install'は`cp'に似ていますが，コピー先のファイルの属
性を制御することが可能になっています．それはMakefileで一般的に使用され，
プログラムをコピー先のディレクトリにコピーします．自分自身にファイルを
コピーすることは拒否されます．

   プログラムは，以下のオプションも受け入れます．*Note Common
options::も参 照してください．

`-b'
`--backup[=METHOD]'
     *Note Backup options::.
     上書きされたり削除されたりするそれぞれのファイルのバックアップを作成し
     ます．

`-c'
     無視されます．古いUnixバージョンの`install'の互換性のためです．

`-d'
`--directory'
     与えられたそれぞれのディレクトリと足りない親ディレクトリを，コマンドラ
     インで与えられたやデフォルトの所有者，グループとモードに設定しながら作
     成します．親ディレクトリも与えられた属性で作成されます．(これはSunOS
     4.x `install'と異なり，そこではディレクトリはデフォルトの属性
     が与えられます．)

`-g GROUP'
`--group=GROUP'
     インストールされるファイルやディレクトリのグループ所有権を， GROUP
     に設定します．デフォルトは，プロセスの現在のグループです．
     GROUPは，グループ名や数値的なグループIDが可能です．

`-m MODE'
`--mode=MODE'
     インストールされるファイルやディレクトリの許可をMODEに設定し，そ
     れは八進数や`chmod'の象徴的なモードが可能で，0が出発点となりま
     す(*note File permissions::)．デフォルトモードは`u=rwx,go=rx'です
     -- 所有者の読み書き実行，グループとそれ以外は読み込みと実行です．

`-o OWNER'
`--owner=OWNER'
     `install'が適切な特権(ルートとして実行)を持つ場合，インストー
     ルされるファイルやディレクトリの所有権はOWNERに設定されます．デ
     フォルトは`root'です．OWNERは，ユーザ名または，数値のユーザ
     IDが可能です．

`-p'
`--preserve-timestamps'
     インストールされたそれぞれのファイルの，最後にアクセスした時間と最後に
     編集した時間を，対応するそれぞれの元ファイルにマッチさせます．このオプ
     ション無しでファイルがインストールされたとき，最後にアクセスした時間と
     最後に編集した時間は，どちらもインストールされた時間に設定されます．こ
     のオプションは，最後にインストールされた時ではなく，最後にビルドされた
     時を追跡し続けるため，インストールされたファイルの最後に編集された時間
     を使用する場合，役に立ちます．

`-s'
`--strip'
     インストールされたバイナリ実行形式から，シンボルテーブルを取り除きます．

`-S SUFFIX'
`--suffix=SUFFIX'
     `-b'で作成されるそれぞれのバックアップファイル名に，
     SUFFIXを追加します．*Note Backup options::.

`--target-directory=DIRECTORY'
     移動(コピー)先のDIRECTORYを指定します．*Note Target directory::.

`-v'
`--verbose'
     コピーする前に，それぞれのファイル名を出力します．

`-V METHOD'
`--version-control=METHOD'
     `-b'で作成するバックアップの形式を変更します．METHOD引数
     は，`none' (または`off')，`numbered' (または`t')， `existing'
     (または`nil')，または`never' (または
     `simple')が利用可能です．*Note Backup options::.


   終了ステータスのゼロは成功を示し，ゼロ以外の値は失敗を示します．


File: coreutils-ja.info,  Node: mv invocation,  Next: rm invocation,  Prev: install invocation,  Up: Basic operations

11.4 `mv': ファイルの移動(名前の変更)
=====================================

`mv'は，ファイル(やディレクトリ)を移動したり名前を変更したりし
ます．概要です．

     mv [OPTION]... SOURCE DEST
     mv [OPTION]... SOURCE... DIRECTORY

   最後の引数が，既存のディレクトリを示す場合，`mv'は，それ以外の
与えられたそれぞれのファイルを，同じファイル名で，そのディレクトリに移
動します．それ以外では，二つのファイルが与えられた場合，一番目の名前を
二番目に変更します．最後の引数がディレクトリではなく，二つ以上のファイ
ルが与えられた場合，エラーとなります．

   `mv'は，一つのファイルシステムから別のものへ，あらゆる形式のファ
イル移動が可能です．fileutilsのバージョン`4.0'以前では，
`mv'は通常のファイルのみファイルシステム間での移動が可能でした．
例えば，現在の`mv'は，一つのパーティションから別のものへ，特殊
なデバイスファイルを含むディレクトリ階層全体を移動することが可能です．
それは最初に，要求されたディレクトリとファイルをコピーする`cp -a'
で使用されているものと同じコードを使用し，それから(コピーが成功したと
仮定して)元を削除します．コピーが失敗した場合，移動先のパーティション
にコピーされた部分が削除されます．一つのパーティションから三つのディレ
クトリを別のものにコピーしていて，最初のディレクトリが成功し，二番目が
失敗した場合，最初のものは移動先のパーティションに残り，二番目と三番目
は元のパーティションに残ります．

   移動先のファイルが存在し通常の書き込みが不可で，標準入力が端末で，
`-f'や`--force'オプションが与えられていない場合，
`mv'はファイルを置換するかどうか，ユーザにプロンプトを表示しま
す．(自分が所有するファイル，または，そのディレクトリに書き込み許可が
ある必要があります．)応答が`y'または`Y'で始まらない場合，ファ
イルはスキップされます．

   _警告_：ディレクトリを示すシンボリックリンクを移動しようとし，ス
ラッシュを後置したシンボリックリンクを指定した場合，`mv'はシン
ボリックリンクを移動しませんが，その代わりにシンボリックリンクが参照す
るディレクトリを移動します．*Note Trailing slashes::.

   プログラムは以下のオプションも受け入れます．*Note Common
options::も参照 してください．

`-b'
`--backup[=METHOD]'
     *Note Backup options::.
     上書きされたり削除されたりするそれぞれのファイルのバックアップを作成し
     ます．

`-f'
`--force'
     移動先のファイルを削除したり上書きしたりする前に，ユーザにプロンプトを
     表示しません．

`-i'
`--interactive'
     ファイルの許可に依存せず，それぞれの既存の移動先のファイルを上書きす
     るかどうかプロンプトを表示します．`y'や`Y'で始まらない返答の
     場合，ファイルはスキップされます．

`--reply[=HOW]'
     `--reply=yes'の指定は，`--force'の使用と等価です．
     `mv'が移動先のファイルに関するプロンプトに対し`no'が与え
     られているかのように動作させるため，`--reply=no'を指定して下さ
     い．移動先のファイルが存在するとき`mv'がユーザにプロンプトを表
     示するようにするため，`--reply=query'を指定して下さい．

`-u'
`--update'
     同じまたは新しい編集時間を持つ既存の移動先にディレクトリ以外のものを移
     動しません．

`-v'
`--verbose'
     移動する前にそれぞれのファイル名を出力します．

`--strip-trailing-slashes'
     それぞれのSOURCE引数から，後置されるスラッシュを削除します． *Note
     Trailing slashes::.

`-S SUFFIX'
`--suffix=SUFFIX'
     `-b'で作成されるそれぞれのバックアップファイル名に，
     SUFFIXを追加します．*Note Backup options::.

`--target-directory=DIRECTORY'
     移動(コピー)先のDIRECTORYを指定します．*Note Target directory::.

`-V METHOD'
`--version-control=METHOD'
     `-b'で作成するバックアップの形式を変更します．METHOD引数
     は，`none' (または`off')，`numbered' (または`t')， `existing'
     (または`nil')，または`never' (または
     `simple')が利用可能です．*Note Backup options::.


   終了ステータスのゼロは成功を示し，ゼロ以外の値は失敗を示します．


File: coreutils-ja.info,  Node: rm invocation,  Next: shred invocation,  Prev: mv invocation,  Up: Basic operations

11.5 `rm': ファイルやディレクトリの削除
=======================================

`rm'は与えられたFILEを削除します．デフォルトではディレク
トリを削除しません．概要です．

     rm [OPTION]... [FILE]...

   ファイルに書き込みができない，標準入力が端末，そして，`-f'また
は`--force'オプションが与えられていない場合，または，
`-i'または`--interactive'オプションが与えられて_い
る_場合，`rm'はユーザにファイルを削除するかどうかを促すプロン
プトを表示します．`y' や`Y'で始まらない返答の場合，ファイル
は省略されます．

   _警告_：ファイルを削除するために`rm'を使用する場合，通常
はファイルの内容を復活させることが可能です．より確実にファイルの内容を
本当に復活させないようにしたい場合，`shred'の使用を検討して下 さい．

   プログラムは以下のオプションも受け入れます．*Note Common
options::も参照 してください．

`-d'
`--directory'
     `rmdir'の代わりに`unlink'を用いてディレクトリの削除を試み，
     そしてアンリンクを試みる前にディレクトリが空である必要はありません．適
     切な特権を持ち，オペレーティングシステムがディレクトリに対する
     `unlink'をサポートしている場合のみ，これは動作します．ディレクト
     リのアンリンクはディレクトリ内のすべてのファイルを参照できなくなるので，
     この後でファイルシステムに`fsck'した方が賢明です．

`-f'
`--force'
     存在しないファイルを無視し，ユーザにプロンプトを表示しません．前にある
     `--interactive' (`-i')オプションを無視します．

`-i'
`--interactive'
     それぞれのファイルを削除するかどうかプロンプトを表示します．`y'や
     `Y'で始まらない返答の場合，ファイルはスキップされます．前にある
     `--force' (`-f')オプションを無視します．

`--preserve-root'
     `--recursive'オプションを使用しているとき，ファイルシステムのルー
     ト，`/'の移動する試みを失敗させます．`--recursive'を用いて
     いない場合，このオプションは効果がありません．*Note Treating /
     specially::.

`--no-preserve-root'
     それ以前の`--preserve-root'オプションの効果を取り消します． *Note
     Treating / specially::.

`-r'
`-R'
`--recursive'
     ディレクトリの内容を再帰的に削除します．

`-v'
`--verbose'
     削除する前にそれぞれのファイル名を出力します．


   よくある問題の一つは，`-'で始まる名前を持つファイルの削除の方法で
す．GNU `rm'では，引数を解析する`getopt'関数を使用す
るすべてのプログラムに似ていて，以下のすべての引数がオプションでないこ
とを示す`--'オプションを使用します．現在のディレクトリの`-f'
というファイル名を削除するため，以下のどちらかの入力で可能になります．

     rm -- -f

または以下のようにします．

     rm ./-f

   この目的に対する，Unix `rm'プログラムの単一の`-'の使用は，
getoptの標準構文の開発以前のものです．

   終了ステータスのゼロは成功を示し，ゼロ以外の値は失敗を示します．


File: coreutils-ja.info,  Node: shred invocation,  Prev: rm invocation,  Up: Basic operations

11.6 `shred': より安全なファイルの削除
======================================

`shred'は，非常に高価なハードウェアを用いてもデータの復活を妨
げるように，デバイスやファイルを上書きします．

   通常，ファイルを削除するとき(*note rm invocation::)，データは実際には
破壊されません．ファイルが保存されている場所をリストアップしている索引
のみ破壊し，記憶装置は再利用可能になります．索引の再構築を試み，その部
分が再利用されていない場合，ファイルを元に戻すことが可能なアンデリート
ユーティリティがあります．

ほとんど満タンのドライブを使用している忙しいシステムでは，スペースは数
秒で再利用可能になります．しかし，それが確実であることを知る方法はあり
ません．機密データがあり，機密でないデータでファイルを実際に上書きする
ことでリカバリが不可能だということを確かめたいかもしれません．

しかし，そうした後でも，研究所へディスクを持っていき，上書きされたデー
タの下の元データのかすかな"残響"を探すために感度の高い(そして高価な)
多くの機器を使用することが可能です．データが一度上書きされただけでは，
それはさほど難しくありません．

取り返しができないように何かを削除する最前の方法は，メディアに酸をかけ
て破壊する，溶かしてしまう，またはそれに似たことをすることです．フロッ
ピーディスクのような，安い着脱可能なメディアに対しては，これは好ましい
方法です．しかし，ハードドライブは高価で，溶かすのが難しいため，
`shred'ユーティリティでは破壊することなく類似の効果を達成しよ
うとします．

これは，古いデータに対するダメージを最大にするように選ばれたデータパター
ンで，上書き動作を何回も使用します．これがフロッピーディスクで動作して
いても，パターンはハードドライブで最適な効果があるように設計されている
ものになります．詳細は，ソースコードと，Sixth USENIX Security Symposium
(San Jose, California, 22-25 July, 1996)の予稿から，Peter
Gutmannの論文`Secure Deletion of Data from Magnetic and Solid-State
Memory'を参照してください．論文は
`http://www.cs.auckland.ac.nz/~pgut001/pubs/secure_del.html'で，オ
ンラインでも利用可能です．

   `shred'は非常に重要な仮定に依存していることに*注意して
ください*．それは，ファイルシステムがその場所のデータを上書きするとい
うことです．これは伝統的な方法ですが，現代の多くのファイルシステムはこ
の仮定を満足するように設計されていません．例外は以下を含みます．

   *
     AIXとSolarisが提供するような，Log-structureまたはjournalファイルシステ
     ム．

   *
     RAIDベースのファイルシステムのように，重複したデータを書き込み，書き込
     みで失敗した場合でも続けるファイルシステム．

   * Network
     ApplianceのNFSサーバのような，スナップショットを作成するファイ
     ルシステム．

   *
     NFSのバージョン3のクライアントのような，一時的な位置にキャッシュを作成
     するファイルシステム．

   * 圧縮されているファイルシステム．

ファイルシステムがどのように動作しているかよく分からない場合，その場所
に上書きされないと仮定すべきで，それは，そのファイルシステムの通常のファ
イルで，`shred'が信頼できる動作を行うことができないことを意味 します．

一般的に言って，上記の手法で設計されたファイルシステムの問題をバイパス
するため，ファイルではなくデバイスに`shred'するとより信頼でき
ます．しかし，デバイスを`shred'してさえ，常に完全に信頼するこ
とはできません．例えば，ほとんどのディスクは，不良セクタがアプリケーショ
ンに見えないようにをマッピングします．不良セクタが機密データを含む場合，
`shred'ではそれを破壊することは不可能です．

   `shred'は，バックアップについて何もしないように，これらの問題
の検出も報告も試みません．しかし，ファイルではなくデバイスに
`shred'する方がより信頼できるので，`shred'はデフォルト
で出力ファイルを切り詰めたり削除したりしません．このデフォルトはデバイ
スに対しより適していて，それは通常切り詰めもできませんし，削除もすべき
ではありません．

最後に，バックアップとミラーの危険性を検討します．ファイルシステムのバッ
クアップとリモートのミラーには，削除不可能なファイルのコピーが含まれ，
それで`shred'したファイルを後に復活させることが可能です．その
ため，その後`shred'を使用して破壊したいデータを保持している場
合，バックアップやミラーが無いことを確かめて下さい．

     shred [OPTION]... FILE[...]

   プログラムは以下のオプションも受け入れます．*Note Common
options::も参照 してください．

`-f'
`--force'
     上書き可能が必要な場合，ファイルの許可に優先させます．

`-NUMBER'
`-n NUMBER'
`--iterations=NUMBER'
     デフォルトで，`shred'は25回の上書きを使用します．これで，少な
     くとも一回の使用で使用される有用な上書きパターンの全てに対して十分にな
     ります．時間の節約のため減らしたり，時間の無駄遣いをする場合に増やすこ
     とが可能です．

`-s BYTES'
`--size=BYTES'
     ファイルの最初のBYTESバイトを`shred'します．デフォルトは
     ファイル全体を`shred'します．BYTESは乗数を指定するために，
     `k'，`M'，または`G'のようなサイズ指定を続けることができ
     ます．*Note Block size::.

`-u'
`--remove'
     ファイルを`shred'した後，(可能な場合は)それを切り詰め，そして
     削除します．ファイルが複数のリンクを持つ場合，指名されたリンクのみ削除
     されます．

`-v'
`--verbose'
     バイ菌の増殖のようにステータスの表示を更新します．

`-x'
`--exact'
     デフォルトで，`shred'は，ファイルの最後のブロックまで完全に消
     去するため，通常のファイルのサイズをファイルシステムのブロックサイズの
     次の乗数まで切り上げます．その動作を抑制するため，`--exact'を使
     用して下さい．このため，デフォルトでは，512バイトのブロックを持つファ
     イルシステム上の，10バイトの通常のファイルを`shred'する場合，
     結果としてファイルは512バイトになります．このオプションを用いると，
     `shred'はファイルのサイズを増加させません．

`-z'
`--zero'
     通常，`shred'の書き込みの最終動作は，ランダムデータの作成です．
     これが(例えば，暗号化されたデータのように見えるため)ハードディスク上で
     目立つ場合や，より整然とさせたいと考える場合，`--zero'オプショ
     ンで全てをゼロビットを用いて上書きする動作を追加します．これは，
     `--iterations'オプションで指定した動作数に追加されます．

`-'
     標準出力を`shred'します．

     この引数はオプションと見なされます．一般的な`--'オプションはコマ
     ンドラインのオプションの終りを示すために使用されますが，`-'は普通
     のファイルとして解釈されます．

     この使用目的は，削除された一時ファイルを`shred'することです．
     例です．

          i=`tempfile -m 0600`
          exec 3<>"$i"
          rm -- "$i"
          echo "Hello, world" >&3
          shred - >&3
          exec 3>-

     シェルコマンド`shred - >file'は，`shred'の呼び出しの前に，
     それがFILEを切り詰めるため，FILEの内容を`shred'しない
     ことに注意してください．コマンド`shred file'，または(Bourne互換シェ
     ルを使用している場合は)コマンド`shred - 1<>file'を代わりに使用し
     てください．


最初のドライブのフロッピーディスクに作成されたファイルシステムの，全て
の記録を消去するために，以下のコマンドを使用するかもしれません．そのコ
マンドは，1.44MBフロッピーを消去するために約20分かかります．

     shred --verbose /dev/fd0

同様に，ハードディスクの選択されたパーティションの全てのデータを消去す
るために，以下のようなコマンドを与えることが可能です．

     shred --verbose /dev/sda5

   終了ステータスのゼロは成功を示し，ゼロ以外の値は失敗を示します．


File: coreutils-ja.info,  Node: Special file types,  Next: Changing file attributes,  Prev: Basic operations,  Up: Top

12 特殊ファイルの形式
*********************

この章は，特殊な形式のファイルを作成する方法(そして，特殊なファイル形
式の一つのディレクトリを削除する`rmdir'方法)を記述します．

Unixのようなオペレーティングシステムでは，他のものより特殊なファイル形
式は著しく少ないのですが，_すべて_のものを"通常のファイル (normal
files)"と差異の無いバイトストリームとして扱うことが可能だとい
うわけではありません．例えば，ファイルを作成したり削除したりするとき，
システムはこの情報を記録する必要があり，それは"ディレクトリ
(directory)" -- 特殊な形式のファイル -- で行います．興味があれば，ディ
レクトリを通常のファイルとして読み込むことも可能ですが，システムにその
作業をさせるために，ファイルのバイト上で，特定の順序になるよう，強制て
きな構造にする必要があります．このためそれは"特殊な"形式のファイルと
なります．

ディレクトリ以外では，特殊なファイル形式は，名前付きパイプ(FIFO)，シン
ボリックリンク，ソケット，そして"特殊ファイル(special files)"と呼
ばれるものを含みます．

* Menu:

* link invocation::             Make a hard link via the link syscall
* ln invocation::               Make links between files.
* mkdir invocation::            Make directories.
* mkfifo invocation::           Make FIFOs (named pipes).
* mknod invocation::            Make block or character special files.
* readlink invocation::         Print the referent of a symbolic link.
* rmdir invocation::            Remove empty directories.
* unlink invocation::           Remove files via the unlink syscall


File: coreutils-ja.info,  Node: link invocation,  Next: ln invocation,  Up: Special file types

12.1 `link': linkシステムコールでハードリンクを作成する
=======================================================

`link'は単一のハードリンクを一度に作成します．それは，システム
が提供する`link'関数への最小のインターフェースです．*Note Hard Links:
(libc)Hard Links.  概要です．

     link FILENAME LINKNAME

   FILENAMEは既存のファイルにする必要があり，LINKNAME既存のディ
レクトリに存在しないものを指定する必要があります．`link'はリン
クを作成するために，単純に`link (FILENAME, LINKNAME)' を呼び出します．

   終了ステータスのゼロは成功を示し，ゼロ以外の値は失敗を示します．


File: coreutils-ja.info,  Node: ln invocation,  Next: mkdir invocation,  Prev: link invocation,  Up: Special file types

12.2 `ln': ファイル間にリンクを作成
===================================

`ln'は，ファイル間のリンクを作成します．デフォルトで，それはハー
ドリンクを作成します．`-s'を用いると，シンボリック(または
"ソフト(soft)")リンクを作成します．概要です．

     ln [OPTION]... TARGET [LINKNAME]
     ln [OPTION]... TARGET... DIRECTORY

   * 最後の引数が既存のディレクトリを示す場合，`ln'はそのディレクト
     リ内のそれぞれのTARGETファイルに，TARGETの名前を使用しなが
     らリンクを作成します．(しかし，以下の`--no-dereference'オプショ
     ンの記述を参照してください．)

   * 二つのファイル名が与えられた場合，`ln'は二番目から一番目へのリ
     ンクを作成します．

   * 一つのTARGETが与えられた場合，`ln'は，現在のディレクトリ
     のそのファイルにリンクを作成します．

   *
     最後の引数がディレクトリでなく，二つ以上のファイルが与えられた場合はエ
     ラーとなります．`-f'や`-i' (以下を参照)を用いない場合,
     `ln'は既存のファイルを削除しません．`ln'に既存のファイ
     ルの名前を変えさせるために，`--backup'オプションを使用してくだ
     さい．


   "ハードリンク(hard link)"は，既存のファイルの別名です．リンクとオ
リジナルは区別できません．技術的には，それらは同じinodeを共有し，inode
はファイルに関する必要な情報をすべて含んでいます -- 実際，inodeがファ
イル_である_と言っても間違いではありません．既存のすべての実装で
は，ディレクトリにハードリンクを作成できず，ハードリンクはファイルシス
テム間をまたぐことができません．(しかしながら，これらの制限は
POSIXとマッチしません．)

   一方，"シンボリックリンク(Symbolic links)" (短く言うと
"symlinks")は，リンクファイルが実際には名前の異なるファイルを参照
する特殊なファイル形式です(すべてのカーネルがサポートしているわけでは
ありません．System V release 3(とそれより古いもの)はsymlinkがありませ
ん)．ほとんどの処理(開く，読み込む，書き出す等)は，シンボリックリンク
を通じて行われ，カーネルは自動的にリンクを"dereferences"し，リンク
先を処理します．しかし，リンク先ではなくリンクファイル自身に作用する
(例えば削除)処理もあります．*Note Symbolic Links: (library)Symbolic
Links.

   プログラムは以下のオプションも受け入れます．*Note Common
options::も参照 してください．

`-b'
`--backup[=METHOD]'
     *Note Backup options::.
     上書きされたり削除されたりするそれぞれのファイルのバックアップを作成し
     ます．

`-d'
`-F'
`--directory'
     スーパーユーザによるディレクトリのハードリンク作成の試みができるように
     します．しかし，スーパーユーザでもシステムの制限のため，失敗する可能性
     があることに注意して下さい．

`-f'
`--force'
     既存のリンク先ファイルを削除します．

`-i'
`--interactive'
     既存リンク先ファイルを削除するかどうか，プロンプトを表示します．

`-n'
`--no-dereference'
     明示的な，ディレクトリへのシンボリックリンクとなるリンク先が与えられた
     とき，リンク先を通常のファイルとして扱います．

     リンク先が(シンボリックリンクではない)実際のディレクトリのとき，不明瞭
     なことはありません．しかし，指定されたリンク先がディレクトリへのシンボ
     リックリンクの時，ユーザの要求の扱い方は，二通りあります．`ln'
     は，リンク先を通常のディレクトリとして扱い，それに対するリンクを作成す
     ることができます．一方，リンク先を非ディレクトリ --
     シンボリックリン ク --
     として見ることもできます．その場合，`ln'は，新しいリン
     クを作成する前に，そのシンボリックリンクを削除またはバックアップする必
     要があります．デフォルトでは，ディレクトリへのシンボリックリンクである
     リンク先を，ディレクトリと同様に扱います．

`-s'
`--symbolic'
     ハードリンクの代わりにシンボリックリンクを作成します．このオプションは，
     シンボリックリンクをサポートしていないシステムでは，単にエラーメッセー
     ジを生成します．

`-S SUFFIX'
`--suffix=SUFFIX'
     `-b'で作成されるそれぞれのバックアップファイル名に，
     SUFFIXを追加します．*Note Backup options::.

`--target-directory=DIRECTORY'
     移動(コピー)先のDIRECTORYを指定します．*Note Target directory::.

`-v'
`--verbose'
     リンクする前にそれぞれのファイル名を出力します．

`-V METHOD'
`--version-control=METHOD'
     `-b'で作成するバックアップの形式を変更します．METHOD引数
     は，`none' (または`off')，`numbered' (または`t')， `existing'
     (または`nil')，または`never' (または
     `simple')が利用可能です．*Note Backup options::.


   以下は例です．

     ln -s /some/name  # creates link ./name pointing to /some/name
     ln -s /some/name myname  # creates link ./myname pointing to /some/name
     ln -s a b ..      # creates links ../a and ../b pointing to ./a and ./b

   終了ステータスのゼロは成功を示し，ゼロ以外の値は失敗を示します．


File: coreutils-ja.info,  Node: mkdir invocation,  Next: mkfifo invocation,  Prev: ln invocation,  Up: Special file types

12.3 `mkdir': ディレクトリの作成
================================

`mkdir'は指定された名前でディレクトリを作成します．概要です．

     mkdir [OPTION]... NAME...

   NAMEが既存のファイルでディレクトリではない場合，`mkdir'
は標準エラー出力に警告メッセージを出力し，残っているNAMEを処理し
た後，1のステータスで終了します．NAMEが既存のディレクトリで，
`-p'オプションが与えられていないときも同じです．NAMEが既存
のディレクトリで，`-p'オプションが与えられている場合，
`mkdir'はそれを無視します．すなわち，`mkdir'は警告の出
力も，エラーの発生も，(`-m'オプションが与えられていても)ディレク
トリのモードの変更もせず，残りのNAMEの処理を続けます．

   プログラムは以下のオプションも受け入れます．*Note Common
options::も参照 してください．

`-m MODE'
`--mode=MODE'
     作成されるディレクトリのモードをMODEで設定し，それは
     `chmod'で設定する抽象的なもので，(読み書きと実行を全員に許可す
     る)`a=rwx'から目的のポイントのためにumaskのビットセットを引いたも
     のを使用します．*Note File permissions::.

`-p'
`--parents'
     それぞれの引数に対し，足りない親ディレクトリを作成します．親ディレクト
     リのモードは`u+wx'で編集されたumaskに設定します．既存のディレクト
     リに対する引数は無視します．

`-v'

`--verbose'
     作成されるそれぞれのディレクトリに対しメッセージを出力します．これは
     `--parents'とともに用いると最も便利です．

   終了ステータスのゼロは成功を示し，ゼロ以外の値は失敗を示します．


File: coreutils-ja.info,  Node: mkfifo invocation,  Next: mknod invocation,  Prev: mkdir invocation,  Up: Special file types

12.4 `mkfifo': FIFO(名前付きパイプ)の作成
=========================================

`mkfifo'はFIFO("名前付きパイプ(named pipes)"とも呼ばれる)
を指定された名前で作成します．概要です．

     mkfifo [OPTION] NAME...

   "FIFO"は，個別のプロセス間の通信を可能にする特殊なファイル形式です．
一つのプロセスは書き込みで，もう一つは読み込みでFIFOを開き，データは，
シェルやその他の通常の名前無しパイプのように流れます．

   プログラムは以下のオプションも受け入れます．*Note Common
options::も参照 してください．

`-m MODE'
`--mode=MODE'
     作成されるFIFOのモードをMODEに設定し，それは`chmod'で設
     定する抽象的なもので，(読み込みと書き出しを全員に許可する)`a=rw'
     から目的のポイントのためにumaskのビットセットを引いたものを使用します．
     *Note File permissions::.


   終了ステータスのゼロは成功を示し，ゼロ以外の値は失敗を示します．


File: coreutils-ja.info,  Node: mknod invocation,  Next: readlink invocation,  Prev: mkfifo invocation,  Up: Special file types

12.5 `mknod': ブロックやキャラクタ特殊ファイルの作成
====================================================

`mknod'は，FIFO，キャラクタ特殊ファイルや，ブロック特殊ファイ
ルを指定された名前で作成します．概要です．

     mknod [OPTION]... NAME TYPE [MAJOR MINOR]

   上記の"特殊ファイル形式"と異なり，"特殊ファイル(special file)"と
いう用語は，Unix上で技術的な意味があります．それはデータを生成または受
信するものです．これは通常，ハードウェアの物理的な部分に対応します．
(これらのファイルは，通常，システム設定時に作成されます．)
`mknod'コマンドは，この形式のファイルを作成するものです．その
ようなデバイスは，一度に一文字または一度に一"ブロック"(多くの文字)読
み込むことが可能で，そのため，"ブロック特殊(block special)"ファイ
ルと"キャラクタ特殊(character special)"ファイルがあると我々は述べ
ています．

   NAMEの後の引数は作成するファイルの形式を指定します．

`p'
     FIFOに対応します．

`b'
     ブロック特殊ファイルに対応します．

`c'
     キャラクタ特殊ファイルに対応します．


ブロックやキャラクタ特殊ファイルを作成しているとき，メジャーとマイナー
デバイス番号をファイル形式の後に与える必要があります．メジャーまたはマ
イナーのデバイス番号が`0x'や`0X'で始まる場合，それは16進数と
して解釈されます．それ以外で`0'で始まる場合は八進数，それ以外では
十進数です．

   プログラムは以下のオプションも受け入れます．*Note Common
options::も参照 してください．

`-m MODE'
`--mode=MODE'
     作成されるファイルのモードをMODEに設定し，それは`chmod'
     で設定する抽象的なもので，`a=rw'から目的のポイントのためにumaskの
     ビットセットを引いたものを使用します．*Note File permissions::.


   終了ステータスのゼロは成功を示し，ゼロ以外の値は失敗を示します．


File: coreutils-ja.info,  Node: readlink invocation,  Next: rmdir invocation,  Prev: mknod invocation,  Up: Special file types

12.6 `readlink': シンボリックリンクの対象を出力
===============================================

`readlink'は，サポートされている二つのモードの一つで動作します．

`readlinkモード'
     `readlink'は，与えられたシンボリックリンクの値を出力します．
     `readlink'がシンボリックリンクのパス名以外の引数で呼び出される
     場合，出力を生成せず，ゼロ以外の終了コードで終了します．

`canonicalizeモード'
     `readlink'は，`.'，`..' も，繰返されるパス分離子(`/')もシンボ
     リックリンクも含めず，与えられた絶対的なファイル名を出力します．構成要
     素が足りない，または利用不可能なパスでは，出力を生成せずゼロ以外の終了
     コードで終了します．


     readlink [OPTION] FILE

   デフォルトで，`readlink'はreadlinkモードで処理します．

   プログラムは以下のオプションを受け入れます．*Note Common
options::も参照 して下さい．

`-f'
`--canonicalize'
     canonicalizeモードで実行します．

`-n'
`--no-newline'
     後置される改行を出力しません．

`-s'
`-q'
`--silent'
`--quiet'
     ほとんどのエラーメッセージを抑制します．

`-v'
`--verbose'
     エラーメッセージを報告します．


   `readlink'は，OpenBSD 2.1で最初に書かれました．

   終了ステータスのゼロは成功を示し，ゼロ以外の値は失敗を示します．


File: coreutils-ja.info,  Node: rmdir invocation,  Next: unlink invocation,  Prev: readlink invocation,  Up: Special file types

12.7 `rmdir': 空のディレクトリの削除
====================================

`rmdir'は空のディレクトリを削除します．概要です．

     rmdir [OPTION]... DIRECTORY...

   DIRECTORY引数が既存の空のディレクトリを参照していない場合，エラー
となります．

   プログラムは以下のオプションも受け入れます．*Note Common
options::も参照 してください．

`--ignore-fail-on-non-empty'
     ディレクトリが空でないため，それぞれ単独であるディレクトリ削除の失敗を
     無視します．

`-p'
`--parents'
     DIRECTORYを削除し，それぞれのDIRECTORYの構成要素の削除を試
     みます．そのため，例えば，`rmdir -p a/b/c'は`rmdir a/b/c a/b
     a'に似ています．同様に，これらのディレクトリが空でないと判明した場合は
     失敗します．そのような失敗で，診断を引き起こし，`rmdir'を失敗
     で終了させないため，`--ignore-fail-on-non-empty'オプションを使
     用してください．

`-v'

`--verbose'
     削除に成功したそれぞれの診断を提唱します．DIRECTORYは削除されま
     す．


   空でないディレクトリの(再帰的な)削除方法は，*Note rm invocation::.

   終了ステータスのゼロは成功を示し，ゼロ以外の値は失敗を示します．


File: coreutils-ja.info,  Node: unlink invocation,  Prev: rmdir invocation,  Up: Special file types

12.8 `unlink': unlinkシステムコールでファイルを削除
===================================================

`unlink'は，単一の指定されたファイル名を削除します．それは，シ
ステムが提供する`unlink'関数の最小のインターフェースです． *Note
Deleting Files: (libc)Deleting Files. 概要です．

     unlink FILENAME

   システムには，`unlink'を削除するディレクトリ名として使用可能なも
のもあります．その他に，特権ユーザだけがそうすることが可能なものもあり
ます．GNUシステムでは，`unlink'でディレクトリ名を削除することはあ
りません．

   デフォルトで，`unlink'は`--help'と`--version'オ
プションを尊重します．それによって，`--help'や
`--version'と命名されたファイルの削除がちょっと難しくなるので，
環境変数`POSIXLY_CORRECT'が設定されているときは，`unlink'
はそのようなコマンドライン引数をオプションではなくオペランドとして扱い
ます．

   終了ステータスのゼロは成功を示し，ゼロ以外の値は失敗を示します．


File: coreutils-ja.info,  Node: Changing file attributes,  Next: Disk usage,  Prev: Special file types,  Up: Top

13 ファイル属性の変更
*********************

ファイルとは，その内容，名前，そしてファイル形式(*note Special file
types::)だけの存在ではありません．ファイルには，所有者(ユーザID)，グルー
プ(グループID)，許可(所有者がファイルに行えること，グループの人ができ
ること，そして，その他誰でも可能であること)，様々なタイムスタンプ，そ
してその他の情報があります．まとめて，これらをファイルの"属性
(attributes)"と呼びます．

   これらのコマンドはファイルの属性を変更します．

* Menu:

* chgrp invocation::            Change file groups.
* chmod invocation::            Change access permissions.
* chown invocation::            Change file owners and groups.
* touch invocation::            Change file timestamps.


File: coreutils-ja.info,  Node: chown invocation,  Next: touch invocation,  Prev: chmod invocation,  Up: Changing file attributes

13.1 `chown': ファイルの所有者とグループの変更
==============================================

`chown'は，与えられたそれぞれのFILEのユーザと/またはグルー
プの所有権を，NEW-OWNERや，既存の参照ファイルのユーザとグループ
に変更します．概要です．

     chown [OPTION]... {NEW-OWNER | --reference=REF_FILE} FILE...

   NEW-OWNERが使用された場合，新しい所有者と/またはグループを以下の
ように指定します(空白は含みません)．

     [OWNER] [ [:] [GROUP] ]

   具体例です．

OWNER
     OWNER (ユーザ名または数値的なユーザID)のみ与えられた場合，そのユー
     ザが与えられたそれぞれのファイルの所有者になり，ファイルのグループは変
     更されません．

OWNER`:'GROUP
     OWNERにコロンとGROUP (グループ名または数値的なグループID)
     が，それら間にスペースを置かずに続いている場合，ファイルのグループ所有
     権を(GROUPに)同様に変更します．

OWNER`:'
     コロンはあるが，グループ名がOWNERに続かない場合，ユーザがファイ
     ルの所有者になり，ファイルのグループはOWNERのログイングループに
     変更されます．

`:'GROUP
     コロンとそれに続くGROUPが与えられているが所有者が省略されている
     場合，ファイルのグループのみ変更されます．この場合，`chown'は
     `chgrp' と同じ機能を果たします．


   古いスクリプトでは，`:'セパレータの場所に`.'を使用している可
能性があります．POSIX 1003.1-2001 (*note Standards
conformance::)では，それをサポートすることを要求していませんが，後方互
換性のため，GNU `chown'は曖昧な結果にならない限り
`.'をサポートします．互換性のため，そして，
OWNER`.'GROUPで`.'を含む名前のユーザを識別してしまうと
好ましくない結果になるので，新しいスクリプトでは`.'の使用を避ける
べきです．

   警告：`chown'コマンドは，システムによってはセットユーザIDやセッ
トグループIDビットがクリアされているかもしれません．`chown'コ
マンドは，`chown'コマンドの制御下にないシステム依存のファイル
のモード変更する，基礎的なシステムのポリシーと機能に依存します．システ
ムによっては(例えばLinux)，基礎的なシステムの`chown'関数がクリア
しているので，`chown'コマンドのセットユーザIDやセットグループ
IDビットはクリアされてます．それ以外のシステム(例えばHP-UXとSolaris)で
は，スーパーユーザとして処理されるとき，`chown'コマンドはこれ
らのビットに影響しません．`chown'の利用が特権ユーザ以外に許可
されているシステムでは，これらのビットは常にシステムによってクリアされ
ています．そうでないとき，基礎的なシステムの動作を調査して下さい．

   プログラムは以下のオプションも受け入れます．*Note Common
options::も参照 してください．

`-c'
`--changes'
     所有権が実際に変更されるそれぞれのFILEに対する動作を，冗長に記述
     します．

`-f'
`--silent'
`--quiet'
     所有権を変更できないファイルについてのエラーメッセージを出力しません．

`--from=OLD-OWNER'
     OLD-OWNERで指定されている現在の属性がある場合，FILEの所有
     権を変更します．OLD-OWNERは，上記のNEW-OWNERの記述と同じ形
     式です．このオプションは，潜在的な悪習の窓をかなり狭めるという点で，セ
     キュリティの立場から主に役に立ちます．例えば，以下のように，このオプショ
     ンを使用しないで，ユーザのファイルに対してUIDの変更を反映させるために，
     `root'が実行したとします．

          find / -owner OLDUSER -print0 | xargs -0 chown NEWUSER

     しかし，`find'が既存のファイルの所有者をテストしたときと，
     `chown'が実際に実行したときの間が非常に長い可能性があるので，
     それは危険です．ギャップを小さくするひとつの方法は，それぞれのファイル
     に対し見つかったときに`chown'を呼び出すことです．

          find / -owner OLDUSER -exec chown NEWUSER {} \;

     しかし，影響されるファイルが多い場合は，それは非常に遅くなります．この
     オプションを用いると，(ギャップを狭めたままで)完全ではありませんが，そ
     れは安全になります．

          chown -R --from=OLDUSER NEWUSER /

`--dereference'
     シンボリックリンク自身に動作せず，それが示すものに動作します．

`-h'
`--no-dereference'
     シンボリックリンクが示すものではなく，それ自身に動作します．これはデフォ
     ルトです．このモードは`lchown'システムコールに依存します．
     `lchown'システムコールが提供されていないシステムでは，コマンドラ
     インで指定されるファイルがシンボリックリンクの時，`chown'は失
     敗します．デフォルトで，再帰的な処理の間に発見されるシンボリックリンク
     に対する診断結果は表示されませんが，それについては`--verbose'は
     参照してください．

`--preserve-root'
     `--recursive'オプションを使用しているとき，ファイルシステムのルー
     ト，`/'の移動する試みを失敗させます．`--recursive'を用いて
     いない場合，このオプションは効果がありません．*Note Treating /
     specially::.

`--no-preserve-root'
     それ以前の`--preserve-root'オプションの効果を取り消します． *Note
     Treating / specially::.

`--reference=REF_FILE'
     それぞれのFILEのユーザとグループを，REF_FILEと同じになるよ
     うに変更します．REF_FILEがシンボリックリンクの場合，シンボリック
     リンクのユーザとグループではなく，それが参照するファイルのものを使用し
     ます．

`-v'
`--verbose'
     処理された全てのファイルに対し，診断結果を出力します．`lchown'シ
     ステムコールがないシステムで，再帰的な処理の間にシンボリックリンクが見
     つかり，`--no-dereference'の影響がある場合，シンボリックリンク
     もその参照先も変更されないことを告げる診断結果を表示します．

`-R'
`--recursive'
     ディレクトリとその内容の所有権を再帰的に変更します．

`-H'
     `--recursive' (`-R')が指定されていて，コマンドライン引数
     がディレクトリへのシンボリックリンクの場合，それをたどっていきます．
     *Note Traversing symlinks::.

`-L'
     再帰的にたどる状況で，ディレクトリへのシンボリックリンクを，見つかった
     ものはすべてたどります． *Note Traversing symlinks::.

`-P'
     シンボリックリンクをたどりません．これは`-H'，`-L'，また
     は`-P'のいずれも指定されていない場合のデフォルトです． *Note
     Traversing symlinks::.


   終了ステータスのゼロは成功を示し，ゼロ以外の値は失敗を示します．


File: coreutils-ja.info,  Node: chgrp invocation,  Next: chmod invocation,  Up: Changing file attributes

13.2 `chgrp': グループの所有権の変更
====================================

`chgrp'は，それぞれの与えられたFILEのグループ所有権を
GROUP(グループ名またはグループIDのどちらかで与えられるはずです)，
または，既存の参照ファイルのグループに変更します．概要です．

     chgrp [OPTION]... {GROUP | --reference=REF_FILE} FILE...

   プログラムは以下のオプションも受け入れます．*Note Common
options::も参照 してください．

`-c'
`--changes'
     グループが実際に変更されているそれぞれのFILEに対し，動作を冗長に
     記述します．

`-f'
`--silent'
`--quiet'
     グループを変更できなかったファイルに関するエラーメッセージを出力しませ
     ん．

`--dereference'
     シンボリックリンク自身に作用するのではなく，それが指し示すものに作用し
     ます．

`-h'
`--no-dereference'
     シンボリックリンクを，それが指し示すものの代わりにそれ自身に動作します．
     これはデフォルトです．このモードは`lchown'システムコールに依存し
     ます．コマンドラインで指定されているファイルがシンボリックリンクの時，
     `chgrp'は失敗します．デフォルトで，再帰的な変換の間に見つかっ
     たシンボリックリンクに対し診断結果は表示されませんが，それについては
     `--verbose'を参照してください．

`--preserve-root'
     `--recursive'オプションを使用しているとき，ファイルシステムのルー
     ト，`/'の移動する試みを失敗させます．`--recursive'を用いて
     いない場合，このオプションは効果がありません．*Note Treating /
     specially::.

`--no-preserve-root'
     それ以前の`--preserve-root'オプションの効果を取り消します． *Note
     Treating / specially::.

`--reference=REF_FILE'
     それぞれのFILEのグループを，REF_FILEと同じになるように変更
     します．REF_FILEがシンボリックリンクの場合，シンボリックリンクの
     グループではなく，それが参照するファイルのものを使用します．

`-v'
`--verbose'
     処理した全てのファイルに対し，診断結果を出力します．`lchown'シス
     テムコールがないシステムで，再帰的な変換の間にシンボリックリンクが見つ
     かり，`--no-dereference'が有効でない場合，シンボリックリンクも
     参照するものも変更されないことを告げる診断結果を表示します．

`-R'
`--recursive'
     ディレクトリとその内容のグループ所有権を再帰的に変更します．

`-H'
     `--recursive' (`-R')が指定されていて，コマンドライン引数
     がディレクトリへのシンボリックリンクの場合，それをたどっていきます．
     *Note Traversing symlinks::.

`-L'
     再帰的にたどる状況で，ディレクトリへのシンボリックリンクを，見つかった
     ものはすべてたどります． *Note Traversing symlinks::.

`-P'
     シンボリックリンクをたどりません．これは`-H'，`-L'，また
     は`-P'のいずれも指定されていない場合のデフォルトです． *Note
     Traversing symlinks::.


   終了ステータスのゼロは成功を示し，ゼロ以外の値は失敗を示します．


File: coreutils-ja.info,  Node: chmod invocation,  Next: chown invocation,  Prev: chgrp invocation,  Up: Changing file attributes

13.3 `chmod': アクセス許可の変更
================================

`chmod'は指名されたファイルのアクセス許可を変更します．概要で す．

     chmod [OPTION]... {MODE | --reference=REF_FILE} FILE...

   `chmod'システムコールは，シンボリックリンクの許可を変更できな
いため，`chmod'はそれらのの許可を決して変更しません．シンボリッ
クリンクの許可は決して使用されないので，これは問題ではありません．しか
し，コマンドラインでリストアップされたそれぞれのシンボリックリンクに対
し，`chmod'は指し示されたファイルの許可を変更します．その代わ
り，再帰的にディレクトリを横断している間，`chmod'は，遭遇した
シンボリックリンクを無視します．

   MODEが使用されている場合，それは新しい許可を指定します．詳細は *Note
File permissions::のセクションを参照してください．

   プログラムは以下のオプションも受け入れます．*Note Common
options::も参照 してください．

`-c'
`--changes'
     許可が実際に変更されているそれぞれのFILEに対し，動作を冗長に記述
     します．

`-f'
`--silent'
`--quiet'
     許可を変更できなかったファイルに関するエラーメッセージを出力しません．

`--preserve-root'
     再帰的にファイルシステムのルート，`/'を変更する試みを失敗させます．
     `--recursive'を用いていない場合，このオプションは効果がありませ
     ん．*Note Treating / specially::.

`--no-preserve-root'
     それ以前の`--preserve-root'オプションの効果を取り消します． *Note
     Treating / specially::.

`-v'
`--verbose'
     与えられたすべてのFILEに対し，動作，非動作の冗長な記述を行います．

`--reference=REF_FILE'
     それぞれのFILEのモードを，REF_FILEと同じになるように変更し
     ます．*Note File permissions::.  REF_FILEがシンボリックリンクの場
     合，シンボリックリンクのモードではなく，それが参照するファイルのものを
     使用します．

`-R'
`--recursive'
     ディレクトリとその内容の許可を再帰的に変更します．


   終了ステータスのゼロは成功を示し，ゼロ以外の値は失敗を示します．


File: coreutils-ja.info,  Node: touch invocation,  Prev: chown invocation,  Up: Changing file attributes

13.4 `touch': ファイルのタイプスタンプの変更
============================================

`touch'は，指定されたファイルのアクセスと/や編集された時間を変
更します．概要です．

     touch [OPTION]... FILE...

   古いシステムでは，`touch'は以下のような時代遅れの構文ををサポー
トしています．最初のFILEが`-t'オプションの有効な引数で，
タイムスタンプが`-d'，`-r'，または`-t'オプション
で全く与えられておらず，`--'引数が与えられていない場合，その引数
はファイル名としてではなく，その他のファイルに対する時間として解釈され
ます．POSIX 1003.1-2001 (*note Standards conformance::)では，
これを許可していません．代わりに`-t'を使用してください．

   存在しないFILEはすべて空として作成されます．

   アクセスと編集の時間の両方を現在の時間に変更するとき，`touch'
は実行しているユーザがファイルの所有者で無いが，書き込み許可があるもの
のタイムスタンプを変更することができます．それ以外では，ユーザはそのファ
イルの所有者である必要があります．

   `touch'は，ファイルの二つの時間 - 最後のアクセスと編集 - を
変更するオプションを提供しますが，実際には三番目のinodeの変更時間も同
じです．これはファイルの`ctime'としてよく参照されます．inodeの変
更時間は，ファイルのメタ情報が最後に変更された時間を表現します．一般的
な例の一つは，ファイルの許可を変更したときです．許可の変更は，ファイル
にアクセスしないのでatimeを変更しませんし，ファイルの編集もしないので
mtimeも変更しません．しかし，ファイル自身の何かは変っていまて，これは
どこかに記録する必要があります．これはctimeフィールドの仕事です．例え
ば，バックアッププログラムが新しい許可値まで含めてファイルの新しいコピー
を作成することを可能にするために，これが必要になります．他に影響しない
ようにファイルのctimeを編集するもう一つの処理は名前の変更です．通常の
処理では，ユーザがctimeフィールドをユーザが指定した値に変更することは，
いかなる場合でも不可能です．

   プログラムは以下のオプションも受け入れます．*Note Common
options::も参照 して下さい．

`-a'
`--time=atime'
`--time=access'
`--time=use'
     アクセス時間だけ変更します．

`-c'
`--no-create'
     存在していないファイルを作成しません．

`-d'
`--date=time'
     現在の時間の代わりにTIMEを指定します．それは，月名，タイムゾーン，
     `am'と`pm'等を含めることが可能です．*Note Date input formats::.

`-f'
     無視されます．BSD版の`touch'の互換性のためです．

`-m'
`--time=mtime'
`--time=modify'
     編集時間だけ変更します．

`-r FILE'
`--reference=FILE'
     現在の時間の代わりに参照FILEの時間を使用します．このオプションが
     `--date=TIME' (`-d TIME')オプションと組み合
     わされている場合，参照するFILEの時間は，与えられたものの
     TIMEから相対的なものになりますが，それ以外では無視されます．例え
     ば，`-r foo -d '-5 seconds''は，`foo'の対応するタイムスタン
     プの五秒前と同じタイムスタンプを指定します．

`-t [[CC]YY]MMDDhhmm[.ss]'
     現在の時間の代わりに引数(オプションの四桁または二桁の年，月，日，時間，
     分，オプションの秒)を使用します．年が二桁のみで指定された場合，
     CCは，0 ... 68に対し20，69 ... 99に対し19になります．年
     の数字が指定されない場合，今年の日付として解釈されます．


   終了ステータスのゼロは成功を示し，ゼロ以外の値は失敗を示します．


File: coreutils-ja.info,  Node: Disk usage,  Next: Printing text,  Prev: Changing file attributes,  Up: Top

14 ディクスの使用
*****************

無限の量のデータを保てるディスクはありません．これらのコマンドは，ディ
スクストレージの使用や利用可能な量を報告します．(これは_メインメ
モリ_，すなわち，プログラムが実行時に使用するRAMの量に対しては重要なこ
とはしません．そのため，`ps'や`pstat'や`swap'やそのよう
なコマンドが必要です．)

* Menu:

* df invocation::               Report filesystem disk space usage.
* du invocation::               Estimate file space usage.
* stat invocation::		Report file or filesystem status.
* sync invocation::             Synchronize memory and disk.


File: coreutils-ja.info,  Node: df invocation,  Next: du invocation,  Up: Disk usage

14.1 `df': ファイルシステムのディスクスペースの使用の報告
=========================================================

`df'は，ファイルシステムの使用されているディスクスペースと利用
可能なディスクスペースの量を報告します．概要です．

     df [OPTION]... [FILE]...

   引数を用いない場合，`df'は現在マウントされている(すべての形式
の)すべてのファイルシステムの使用されている，そして利用可能な空間を報
告します．それ以外では，`df'はそれぞれの引数のFILEを含む
ファイルシステム上の内容を報告します．

通常ディスクスペースは1024バイト単位で出力されますが，これに優先するこ
とも可能です(*note Block size::)．整数ではない量は，次の単位まで切り上
げられます．

   引数のFILEがマウントされているファイルシステムを含むディスクデバ
イスファイルの場合，`df'はデバイスノードを含むファイルシステム
(すなわちルートファイルシステム)ではなく，そのファイルシステムの利用可
能な空間を表示します．GNU `df'では，マウントしていないファ
イルシステムのディスクの使用を決定することは，ファイルシステム構造のほ
とんどのシステム間での極めて移植性のない緻密な知識が必要になるので，そ
うしようとしません．

   プログラムは以下のオプションも受け入れます．*Note Common
options::も参照 してください．

`-a'
`--all'
     0ブロックの大きさのファイルシステムをリストに含め，それはデフォルトで
     は省略されます．そのようなファイルシステムは，通常はオートマウントエン
     トリーのような，特定の目的の疑似ファイルシステムです．また，サポートさ
     れているシステムもある"ignore"や"auto"形式のファイルシステムは，こ
     のオプションが指定されたときだけ含まれます．

`-B SIZE'
`--block-size=SIZE'
     表示する前に，SIZEで大きさを計ります(*note Block size::)．例えば，
     `-BG'では，1,073,741,824バイト単位で大きさを表示します．

`-h'
`--human-readable'
     メビバイトに対する`M'のような，サイズ文字を追加します．1000倍では
     なく1024倍が使用されます．`M'は1,048,576バイトを意味します．1000
     倍を望む場合，`--si'オプションを使用してください．

`-H'
     `--si'と等価です．

`-i'
`--inodes'
     ブロックの使用の代わりに，inode使用の情報をリストアップします．
     inode(index
     nodeの省略)は，ファイルに関する，所有者，許可，タイムスタ
     ンプ，そしてディスクの位置のような情報を含みます．

`-k'
     1024バイトブロックで出力し，デフォルトのブロックサイズに優先します
     (*note Block size::)．このオプションは，`--block-size=1K'と等価
     です．

`-l'
`--local'
     ローカルファイルシステムのリストだけに制限します．デフォルトではリモー
     トファイルシステムもリストアップされます．

`--no-sync'
     使用データを取得する前に`sync'システムコールを呼び出しません．こ
     れは多くのディスクを持つシステム上で`df'の実行をかなり速くする
     かもしれませんが，システム(特にSunOS)によっては，結果が若干古いものに
     なるかもしれません．これはデフォルトです．

`-P'
`--portability'
     POSIX出力形式を使用します．これは，以下を除いてデフォルトの
     書式に似ています．

       1.
          それぞれのファイルシステムの情報は常に正確に一行で出力されます．マウン
          トデバイスはその行に書かれません．これはマウントデバイスの名前が20文字
          以上(例えば，いくつかのネットワークマウント)の場合，列がきちんと並ばな
          いことを意味します．

       2. ヘッダ出力行のラベルは，POSIXに従い変更されます．

`--si'
     メガバイトに対する`MB'のような，SI形式のサイズの略語を追加します．
     1024倍ではなく1000倍が使用されます．`MB'は1,000,000バイトを意味し
     ます．このオプションは，`--block-size=si'と等価です．1024倍を望
     む場合，`-h'または`--human-readable'オプションを使用して ください．

`--sync'
     あらゆる使用データの取得前に`sync'システムコールを呼び出します．
     システム(特にSunOS)によってはこうすることで結果がより新しいものになり
     ますが，一般的に言って，特に多くの，または非常に忙しいファイルシステム
     があるとき，このオプションで`df'はかなり遅くなります．

`-t FSTYPE'
`--type=FSTYPE'
     FSTYPE形式のファイルシステムのリストにだけ制限します．複数のファ
     イルシステム形式は，複数の`-t'オプションを与えることで指定する
     ことが可能です．デフォルトでは何も省略されません．

`-T'
`--print-type'
     それぞれのファイルシステムの形式を出力します．ここで出力される形式は，
     `-t'と`-x'オプションで含めたり除外したりすることが可能な
     ものと同じです．出力される特定の形式は，システムでサポートしているもの
     すべてです．ここに共通の名前がいくつかあります(このリストはもちろん網
     羅的なものではありません)．

    `nfs'
          NFSファイルシステム，すなわち，他のマシンからネットワークでマウントさ
          れたものです．これは，すべてのシステムで同じように使用されると思われる，
          一つの形式の名前です．

    `4.2, ufs, efs...'
          ローカルにマウントされたハードディスクのファイルシステムです．(システ
          ムはこれらの一つ以上のものをサポートするかもしれません．Linuxはそうで
          す．)

    `hsfs, cdfs'
          CD-ROMドライブのファイルシステムです．HP-UXは`cdfs'を使用し，その
          他のほとんどのシステムは`hsfs' (`hs'は"High Sierra"です)を
          使用します．

    `pcfs'
          MS-DOSのファイルシステムで，通常ディスケット上です．


`-x FSTYPE'
`--exclude-type=FSTYPE'
     FSTYPE形式でないファイルシステムにリストを制限します．複数のファ
     イルシステムの形式は，複数の`-x'オプションを使用することで排除
     することが可能です．デフォルトでは省略されるファイルシステム形式はあり
     ません．

`-v'
     無視されます．System V版の`df'への互換性のためです．


   終了ステータスのゼロは成功を示し，ゼロ以外の値は失敗を示します．


File: coreutils-ja.info,  Node: du invocation,  Next: stat invocation,  Prev: df invocation,  Up: Disk usage

14.2 `du': ファイルスペースの使用を推定
=======================================

`du'は，指定されているファイルとそれぞれの(ディレクトリ引数の)
サブディレクトリが使用しているディスクスペースの量を報告します．概要で
す．

     du [OPTION]... [FILE]...

   引数を用いない場合，`du'は現在のディレクトリのディスクスペース
を報告します．通常，ディスクスペースは1024バイト単位で出力されますが，
これに優先することも可能です(*note Block size::)．整数ではない量は，次
に大きな単位に切り上げられます．

   プログラムは以下のオプションも受け入れます．*Note Common
options::も参照 してください．

`-a'
`--all'
     ディレクトリだけでなく，すべてのファイルを数えたものを表示します．

`--apparent-size'
     ディスクを使用している大きさではなく見かけ上の大きさを出力します．ファ
     イルの見かけ上の大きさは，通常のファイルに対し`wc -c'，またはより
     一般的に，`ls -l --block-size=1'や`stat --format=%s'で報告さ
     れるバイト数です．例えば，改行が無い単語`zoo'を含んでいるファイル
     はもちろん，見かけ上の大きさは3になります．そのような小さなファイルで
     も，ファイルが存在するファイルシステムの形式や設定によっては，ゼロから
     16バイト，またはより大きなキロバイトのディスク領域が必要かもしれません．
     しかし，以下のコマンドで作成される疎らなファイルを考えてみます．
          : | dd bs=1 seek=`echo '2^31'|bc` of=big
     これは，見かけ上2ギガバイトですが，最近のほとんどのシステムでは，実際
     にはほとんどディスク領域を使用しません．

`-b'
`--bytes'
     `--apparent-size --block-size=1'と同じです．

`-B SIZE'
`--block-size=SIZE'
     大きさを出力する前にSIZEで計測します(*note Block size::)．例えば，
     `-BG'では1,073,741,824バイト単位で出力します．

`-c'
`--total'
     すべての引数を処理した後，すべての引数の合計を出力します．これは，与え
     られたファイルやディレクトリの集合の，ディスク使用の合計を知るために使
     用することが可能です．

`-D'
`--dereference-args'
     コマンドライン引数のシンボリックリンクを間接参照します．その他のシンボ
     リックリンクには影響しません．これは，`/usr/tmp'のように，シンボ
     リックリンクにされることが多いディレクトリのディスクの使用状況を知りた
     いとき役に立ちます．

`-h'
`--human-readable'
     メビバイトに対する`M'のような，サイズ文字を追加します．1000倍では
     なく1024倍が使用されます．`M'は1,048,576バイトを意味します．1000
     倍を望む場合，`--si'オプションを使用してください．

`-H'
     現在は，`-H'で警告される以外は`-H'は`--si'と同じ
     です．このオプションは変更され，`--dereference-args'
     (`-D')と等価になっています．

`-k'
     1024バイトブロックで出力し，デフォルトのブロックサイズに優先します
     (*note Block size::)．このオプションは，`--block-size=1K'と等価
     です．

`-l'
`--count-links'
     すでに(ハードリンクとして)現れている場合でも，すべてのファイルのサイズ
     を計算します．

`-L'
`--dereference'
     シンボリックリンクを間接参照します(リンクで使用しているスペースの代わ
     りに，リンクが示すファイルやディレクトリが使用しているディスクスペース
     を表示します)．

`-P'
`--no-dereference'
     `du'が見つけたそれぞれのシンボリックリンクを，シンボリックリン
     クが使用しているディスクスペースと考えます．

`--max-depth=DEPTH'
     階層のルートから最大MAX_DEPTHレベルまで降りて，それぞれのディレクトリ
     (そして`--all'の場合はファイル)の合計を表示します．ルートはレベル
     0なので，`du --max-depth=0'は`du -s'と同じです．

`-0'
`--null'
     それぞれの行の終りに，改行ではなくゼロバイト(`NUL')を出力します．
     このオプションで，出力に改行が含まれているファイル名が含まれているとき
     でも，他のプログラムが`du'の出力を構文解析することが可能になり
     ます．

`--si'
     メガバイトに対する`MB'のような，SI形式のサイズの略語を追加します．
     1024倍ではなく1000倍が使用されます．`MB'は1,000,000バイトを意味し
     ます．1024倍を望む場合，`-h'または`--human-readable'オプ
     ションを使用してください．

`-s'
`--summarize'
     それぞれの引数の合計のみ表示します．

`-S'
`--separate-dirs'
     サブディレクトリのサイズを含めず，それぞれのディレクトリのサイズを別々
     に報告します．

`-x'
`--one-file-system'
     処理を開始した引数のディレクトリと異なるファイルシステムを省略します．

`--exclude=PATTERN'
     再帰的なとき，PATTERNにマッチするサブディレクトリやファイルを省
     略します．例えば，`du --exclude='*.o''は`.o'で終わる名前のファ
     イルを除外します．

`-X FILE'
`--exclude-from=FILE'
     除外するパターンをFILEから受け取る以外，`--exclude'に似て
     います．FILEが`-'の場合，標準入力からパターンを受け取ります．


   BSDシステムでは，HP-UXシステムからのNFSマウントされているファイルの正
しい値の半分のサイズを，`du'は報告します．HP-UXシステムでは，
BSDシステムからのNFSマウントされているファイルの正しい値の二倍のサイズ
を報告します．これはHP-UXの欠陥です．それはHP-UX `du'プログラ
ムにも影響します．

   終了ステータスのゼロは成功を示し，ゼロ以外の値は失敗を示します．


File: coreutils-ja.info,  Node: stat invocation,  Next: sync invocation,  Prev: du invocation,  Up: Disk usage

14.3 `stat': ファイルやファイルシステムのステータスを報告
=========================================================

`stat'は，指定したファイルの情報を表示します．概要です．

     stat [OPTION]... [FILE]...

   オプションを用いていない場合，`stat'は与えられたファイルのすべ
ての情報を報告します．しかし，与えられたファイルが存在するファイルシス
テムの情報だけを報告するために使用することも可能です．ファイルがリンク
の場合，`stat'はリンク先のファイルの情報も与えてくれます．

`-f'
`--filesystem'
     与えられたファイル自身の情報ではなく，ファイルが存在しているファイルシ
     ステムの情報を報告します．

`-L'
`--dereference'
     `stat'のシンボリックリンクの処理方法を変更します．このオプショ
     ンを用いると，`stat'はそれぞれのシンボリックリンク引数の参照先
     のファイルで動作します．そうでなければ，`stat'はシンボリックリ
     ンクで直接動作します．

`-t'
`--terse'
     他のプログラムでパースするのに適した，簡潔な方式で情報を出力します．

`-c'
`--format'
     ユーザ指定の出力書式を可能にします．

     ファイルのステータスとして解釈されるものです．
        * %a - アクセス許可の八進数

        * %A - アクセス許可の人間が読める形式

        * %b - 領域のブロック数 (see `%B')

        * %B - `%b'で報告されるそれぞれのブロックのバイト数

        * %d - 十進数のデバイス番号

        * %D - 16進数のデバイス番号

        * %f - 16進数のraw mode

        * %F - ファイル形式

        * %g - 所有者のグループId

        * %G - 所有者のグループ名

        * %h - ハードリンク数

        * %i - inode番号

        * %n - ファイル名

        * %N -
          シンボリックリンクの場合，間接参照した引用符で囲まれたファイル名

        * %o - IOブロックサイズ

        * %s - バイト単位の全体の大きさ

        * %t - 16進数のメジャーデバイス形式

        * %T - 16進数のマイナーデバイス形式

        * %u - 所有者のユーザId

        * %U - 所有者のユーザ名

        * %x - 最後にアクセスした時間

        * %X - 最後にアクセスしたEpoch以来の秒数

        * %y - 最後に編集した時間

        * %Y - 最後に編集したEpoch以来の秒数

        * %z - 最後に変更した時間

        * %Z - 最後に変更したEpoch以来の秒数

     ファイルシステムのステータスとして解釈されるものです．
        * %n - ファイル名

        * %i - 16進数のファイルシステムid

        * %l - ファイル名の最大長さ

        * %t - 16進数の形式

        * %T - 人間が読める形式

        * %b - ファイルシステム全体のデータブロック

        * %f - ファイルシステムの空きブロック

        * %a - スーパーユーザ以外が利用可能な空きブロック

        * %s - 最適に移動されるブロックサイズ

        * %c - ファイルシステム全体のファイルノード

   終了ステータスのゼロは成功を示し，ゼロ以外の値は失敗を示します．


File: coreutils-ja.info,  Node: sync invocation,  Prev: stat invocation,  Up: Disk usage

14.4 `sync': ディスクのデータとメモリの同期
===========================================

`sync'は，メモリに蓄えられているデータをすべてディスクに書き出
します．これは，(制限はあるものの)編集されたスーパーブロック，編集され
たinode，そして遅延された読み書きが含まれます．これはカーネルで実装さ
れている必要があります．`sync'プログラムは，`sync'システ
ムコールの呼び出し以外，何もしません．

カーネルは，(相対的に遅い)ディクスの読み書きを避けるため，メモリのデー
タをそのままにします．これはパフォーマンスを改善しますが，コンピュータ
が壊れた場合，結果としてデータが失われたり，ファイルシステムが壊れるか
もしれません．`sync'は，メモリにあるものすべてを確実にディスク
に書き込みます．

   単独の`--help'や`--version' (*note Common options::)以外
のあらゆるオプションは無視されます．

   終了ステータスのゼロは成功を示し，ゼロ以外の値は失敗を示します．


File: coreutils-ja.info,  Node: Printing text,  Next: Conditions,  Prev: Disk usage,  Up: Top

15 テキストの表示
*****************

このセクションは，テキスト文字列を画面に表示するコマンドを説明します．

* Menu:

* echo invocation::             Print a line of text.
* printf invocation::           Format and print data.
* yes invocation::              Print a string until interrupted.


File: coreutils-ja.info,  Node: echo invocation,  Next: printf invocation,  Up: Printing text

15.1 `echo': テキストの行を表示
===============================

`echo'は，与えられたそれぞれのSTRINGを，それぞれの間にス
ペースを用い，最後のものの後に改行を用いて，標準出力に書き出します．概
要です．

     echo [OPTION]... [STRING]...

   プログラムは以下のオプションも受け入れます．*Note Common
options::も参照 してください．

`-n'
     終りの改行を出力しません．

`-e'
     それぞれのSTRINGで，以下のバックスペースエスケープされた文字の解
     釈を可能にします．

    `\a'
          警報(ベル)

    `\b'
          バックスペース

    `\c'
          終りの改行を抑制

    `\f'
          フォームフィード

    `\n'
          改行

    `\r'
          キャリッジリターン

    `\t'
          水平タブ

    `\v'
          垂直タブ

    `\\'
          バックスラッシュ

    `\NNN'
          ASCIIコードがNNN(八進数)の文字．NNNが有効な数字
          でない場合，それは文字通りに出力されます．


   終了ステータスのゼロは成功を示し，ゼロ以外の値は失敗を示します．


File: coreutils-ja.info,  Node: printf invocation,  Next: yes invocation,  Prev: echo invocation,  Up: Printing text

15.2 `printf': データの書式化と出力
===================================

`printf'はテキストの書式化された表示を行います．概要です．

     printf FORMAT [ARGUMENT]...

   `printf'は，C `printf'関数と同じ方法で，`%'指示語と
`\'エスケープを解釈しながらFORMAT文字列を表示します．与えら
れたARGUMENTのすべてを変換する必要があるので，FORMAT引数は
再利用されます．

浮動小数点の引数は，小数桁の前にピリオドを使用する必要がありますが，出
力は現在のロカールの`LC_NUMERIC'カテゴリに依存します．例えば，ロカー
ルの基数文字がカンマのとき，コマンド`printf %g 3.14'で`3,14'
を出力しますが，コマンド`printf %g 3,14'はエラーになります．

   `printf'は追加の指示語`%b'があり，それは，FORMAT文
字列と同じ方法で`\'エスケープを解釈しながら，その引数文字列を表示
しますが，例外として，八進数のエスケープは`\0OOO'の形式で，
OOOは0から3桁の八進数になります．

   `printf'は，表示文字を指定するとき，FORMAT内の
`\0ooo'を(OOOが1から3桁の八進の場合)八進数として，そして，
表示文字を指定するとき，`\xhhh'を(HHHが0から三桁の16進の場
合)16進数として解釈します．

   `printf'は，ISO C 99で導入された二文字の構文を解釈し
ます．四桁の16進数HHHHで指定される16ビットのUnicode文字に対する
`\u'，そして，四桁の16進数HHHHHHHHで指定される32ビットの
Unicode文字に対する`\U'です．現在のロカールのLC_CTYPEの部分に依存
して`printf'はUnicode文字を出力し，すなわち，環境変数
`LC_ALL'，`LC_CTYPE'，`LANG'の値には依存しません．

   `\u'と`\U'の処理では，`iconv'の機能が完全になっている必
要があります．glibc 2.2(またはそれより新しいもの)を用いたシステムや，
このパッケージに優先する`libiconv'がインストールされているときは
動作します．それ以外で`\u'と`\U'を使用すると，エラーメッセー
ジが表示されます．

   追加のエスケープ`\c'は，`printf'にそれ以上の出力を生成さ せません．

   オプションは，単独の`--help'や`--version'だけです． *Note Common
options::.

   Unicode文字の構文は，ロカールに依存している文字列を書くとき役に立ちま
す．例えば，Euro通貨の記号を含む文字列です．

     $ /usr/local/bin/printf '\u20AC 14.95'

これで，Euroの記号をサポートしているすべてのロカールで(ISO-8859-15，
UTF-8，他)正しく出力されます．同様に中国文字を利用します．

     $ /usr/local/bin/printf '\u4e2d\u6587'

これで，すべての中国のロカール(GB2312，BIG5，UTF-8，等)で正しく出力さ
れます．

   これらの例は，GNU `bash'の組み込み関数`printf'と区別する
ため，`printf'のフルパス名が与えられていることに注意して下さい．

より長い文字列では，それぞれの文字一つ一つの16進数のコード値を探す必要
がありません．`\u'エスケープシーケンスが混ざっている
ASCII文字は，JAVAのソースファイルのエンコードとして知られて
います．このエンコードされた文字列を変換するために，GNU recode 3.5c(ま
たはより新しいもの)を使用することが可能です．テキストの一部を，ロケー
ルに依存しない方法でこのテキストを出力するシェルスクリプトに変換する方
法は以下のようになります．

     $ LC_CTYPE=zh_CN.big5 /usr/local/bin/printf \
         '\u4e2d\u6587\n' > sample.txt
     $ recode BIG5..JAVA < sample.txt \
         | sed -e "s|^|/usr/local/bin/printf '|" -e "s|$|\\\\n'|" \
         > sample.sh

   終了ステータスのゼロは成功を示し，ゼロ以外の値は失敗を示します．


File: coreutils-ja.info,  Node: yes invocation,  Prev: printf invocation,  Up: Printing text

15.3 `yes': 中断するまで文字列を出力
====================================

`yes'は，スペースで分離され改行後置されたコマンドライン引数を，
キルされるまで永遠に出力します．引数が与えられない場合は，改行後置され
た`y'を，キルされるまで永遠に出力します．

   上記のエラーで，`yes'は`1'のステータスで終了します．

   オプションは，単独の`--help'や`--version'だけです． *Note Common
options::.


File: coreutils-ja.info,  Node: Conditions,  Next: Redirection,  Prev: Printing text,  Up: Top

16 条件文
*********

このセクションでは，その出力ではなく，終了ステータスが主に役に立つコマ
ンドを記述します．このためそれらは，シェルの`if'文の条件やパイプ
ラインの最後のコマンドとしてよく使用されます．

* Menu:

* false invocation::            Do nothing, unsuccessfully.
* true invocation::             Do nothing, successfully.
* test invocation::             Check file types and compare values.
* expr invocation::             Evaluate expressions.


File: coreutils-ja.info,  Node: false invocation,  Next: true invocation,  Up: Conditions

16.1 `false': 何もせず失敗します
================================

`false'は，"失敗(failure)"を意味する1の終了ステータスを返
す以外何もしません．それは，シェルスクリプトの失敗のコマンドが必要な位
置で使用することが可能です．

   デフォルトで，`false'は`--help'と`--version'を尊
重します．しかし，それはPOSIXに準拠していないので，環境変数
`POSIXLY_CORRECT'が設定されているとき，`false'は，
`--help'と`--version'を含む，すべてのコマンドライン引数 を無視します．

   このバージョンの`false'は，Cプログラムとして実装されていて，そ
のため，シェルスクリプトの実装より安全かつ高速になり，アカウントの使用
を禁止する目的のダミーシェルとして使用しても安全でしょう．

   `false'は，(ここで説明されている他のすべてのプログラムとは異な り)
`--help'や`--version'を用いて呼び出されても，失敗の
終了ステータスを返しすことに注意して下さい．


File: coreutils-ja.info,  Node: true invocation,  Next: test invocation,  Prev: false invocation,  Up: Conditions

16.2 `true': 何もせず成功します
===============================

`true'は，"成功(success)"を意味する0の終了ステータスを返す
以外何もしません．それは，シェルスクリプトの成功のコマンドが必要な位置
で使用することが可能ですが，シェル組み込みコマンド `:' (コロン)は
同じことをより高速に行います．最近のほとんどのシェルでは，
`true'が組み込みコマンドなので，スクリプトで`true'を使用
するとき，おそらくここで説明しているものではなく組み込みコマンドを使用
することになります．

   デフォルトで，は`--help'と`--version'を尊重します．しか
し，それはPOSIXに準拠していないので，環境変数
`POSIXLY_CORRECT'が設定されているとき，`true'は
`--help'と`--version'を含む，すべてのコマンドライン引数 を無視します．

   しかし，`true'にゼロ以外のステータスで終了させることも可能であ
ることに注意して下さい．非POSIXモードで呼び出され，
`--help'や`--version'オプションを用い，標準出力が閉じら
れている，またはI/Oエラーとなるファイルにリダイレクトするときがそうで
す．例えば，Bouene互換シェルでの使用例です．

     $ ./true --version >&-
     ./true: write error: Bad file number
     $ ./true --version > /dev/full
     ./true: write error: No space left on device

   このバージョンの`true'は，Cプログラムとして実装されていて，そ
のため，シェルスクリプトの実装より安全かつ高速になり，アカウントの使用
を禁止する目的のダミーシェルとして使用しても安全でしょう．


File: coreutils-ja.info,  Node: test invocation,  Next: expr invocation,  Prev: true invocation,  Up: Conditions

16.3 `test': ファイル形式の調査と値の比較
=========================================

条件式EXPRの評価に依存して，0(真)または1(偽)のステータスを返しま
す．式のそれぞれの部分は，分離された引数にする必要があります．

   `test'には，ファイルのステータスの調査，文字演算子，そして数字
比較の演算子があります．

   `test'には，`test'を前置する代わりに四角い開括弧，閉括弧
と使用する，もう一つの形式があります．例えば，`test -d /'の代わり に`[
-d / ]'と書くことも可能です．四角い括弧は分離されている引数
にする必要があります．例えば，`[-d /]'では期待した効果になりませ ん．
`test EXPR'と`[ EXPR ]'には同じ意味があるの
で，以下では前者の形式だけを議論していきます．

ほとんどのシェルには同じ名前の組み込みコマンドがあるため，スクリプト内
や対話的に簡素なコマンド名を使用すると，ここで記述するものと異なる機能
となる可能性があります．

   以下のオプションの他に，単一の引数も可能です．引数が空でない場合，
`test'はtrueを返します．任意の文字列の引数が可能で，それらの文
字列には`-d'，`-1'，`--'，`--help'，そして
`--version'といった，他のプログラムのほとんどがオプションとして処
理するものも含まれます．ヘルプやバージョン情報を取得するため，コマンド
`[ --help'と`[ --version'を，いつもの閉じ括弧を用いずに呼び
出して下さい．*Note Common options::.

   終了ステータスです．
     0 式がtrueの場合．
     1 式がfalseの場合．
     2 エラーが生じた場合．

* Menu:

* File type tests::             -[bcdfhLpSt]
* Access permission tests::     -[gkruwxOG]
* File characteristic tests::   -e -s -nt -ot -ef
* String tests::                -z -n = !=
* Numeric tests::               -eq -ne -lt -le -gt -ge
* Connectives for test::        ! -a -o


File: coreutils-ja.info,  Node: File type tests,  Next: Access permission tests,  Up: test invocation

16.3.1 ファイル形式のテスト
---------------------------

これらのオプションは，ファイルの特定の形式をテストします．(ファイルの
すべてですが，すべてのファイルが同じではありません！)

`-b FILE'
     FILEが存在し，ブロックスペシャルデバイスの場合は真です．

`-c FILE'
     FILEが存在し，キャラクタスペシャルデバイスの場合は真です．

`-d FILE'
     FILEが存在し，ディレクトリの場合は真です．

`-f FILE'
     FILEが存在し，通常のファイルの場合は真です．

`-h FILE'
`-L FILE'
     FILEが存在し，シンボリックリンクの場合は真です．

`-p FILE'
     FILEが存在し，名前付きパイプの場合は真です．

`-S FILE'
     FILEが存在し，ソケットの場合は真です．

`-t FD'
     FDが端末に関連づけられているファイル記述子の場合は真です．



File: coreutils-ja.info,  Node: Access permission tests,  Next: File characteristic tests,  Prev: File type tests,  Up: test invocation

16.3.2 アクセス許可のテスト
---------------------------

これらのオプションは，特定のアクセス許可をテストします．

`-g FILE'
     FILEが存在し，そのセットグループidビットが設定されている場合は真
     です．

`-k FILE'
     FILEが存在し，"スティッキー(sticky)"ビットが設定されている場
     合は真です．

`-r FILE'
     FILEが存在し，読み込み可能な場合は真です．

`-u FILE'
     FILEが存在し，セットユーザidビットが設定されている場合は真です．

`-w FILE'
     FILEが存在し，書き込み可能な場合は真です．

`-x FILE'
     FILEが存在し，実行可能な場合は真です．

`-O FILE'
     FILEが存在し，現在実施中のユーザidに所有されている場合は真です．

`-G FILE'
     FILEが存在し，現在実施中のグループidに所有されている場合は真です．



File: coreutils-ja.info,  Node: File characteristic tests,  Next: String tests,  Prev: Access permission tests,  Up: test invocation

16.3.3 ファイルの特徴テスト
---------------------------

これらのオプションはその他のファイルの特徴を調査します．

`-e FILE'
     FILEが存在している場合は真です．

`-s FILE'
     FILEが存在し，大きさがゼロより大きい場合は真です．

`FILE1 -nt FILE2'
     FILE1がFILE2より(修正日で)新しい場合，または，FILE1
     が存在しFILE2が存在しない場合は真です．

`FILE1 -ot FILE2'
     FILE1がFILE2より(修正日で)古い場合，または，FILE2が
     存在しFILE1が存在しない場合は真です．

`FILE1 -ef FILE2'
     FILE1とFILE2が同じデバイスとi-node番号を持つ場合，すなわち，
     それらがお互いにハードリンクの場合は真です．



File: coreutils-ja.info,  Node: String tests,  Next: Numeric tests,  Prev: File characteristic tests,  Up: test invocation

16.3.4 文字列のテスト
---------------------

これらのオプションは文字列の特徴をテストします．文字列は`test'
に対して引用符で囲みませんが，例えばスペースのような，シェルで特別な意
味を持つ文字を保護するために，それらを引用符で囲む必要があるかもしれま
せん．

`-z STRING'
     STRINGの長さがゼロの場合は真です．

`-n STRING'
`STRING'
     STRINGの長さがゼロではないの場合は真です．

`STRING1 = STRING2'
     文字列が等しい場合は真です．

`STRING1 != STRING2'
     文字列が等しくない場合は真です．



File: coreutils-ja.info,  Node: Numeric tests,  Next: Connectives for test,  Prev: String tests,  Up: test invocation

16.3.5 数値テスト
-----------------

数値の関係です．引数は，完全な数値(負も可能です)，または，STRING
の長さを評価する特別な式`-l STRING'にする必要があります．

`ARG1 -eq ARG2'
`ARG1 -ne ARG2'
`ARG1 -lt ARG2'
`ARG1 -le ARG2'
`ARG1 -gt ARG2'
`ARG1 -ge ARG2'
     これらの算数の二項演算子は，それぞれ，ARG1がARG2に比べて，
     等しい，等しくない，小さい，以下，大きい，または以上の場合に真を返しま
     す．


   例えば以下のようにします．

     test -1 -gt -2 && echo yes
     => yes
     test -l abc -gt 1 && echo yes
     => yes
     test 0x100 -eq 1
     error--> test: integer expression expected before -eq


File: coreutils-ja.info,  Node: Connectives for test,  Prev: Numeric tests,  Up: test invocation

16.3.6 `test'の連結
-------------------

通常の論理結合子です．

`! EXPR'
     EXPRが偽の場合は真です．

`EXPR1 -a EXPR2'
     EXPR1とEXPR2の両方が真の場合は真です．

`EXPR1 -o EXPR2'
     EXPR1またはEXPR2のどちらかが真の場合は真です．



File: coreutils-ja.info,  Node: expr invocation,  Prev: test invocation,  Up: Conditions

16.4 `expr': 式の評価
=====================

`expr'は式を評価し，結果を標準出力に書き出します．それぞれの式
のトークンは，分離している引数にする必要があります．

オペランドは整数または文字列のいずれかになります．整数は，一桁以上の十
進数と，追加で`-'を前置したものから成り立ちます．`expr'は，
あらゆるものが，適用されているオペレーションに依存して，オペランドの位
置に存在する整数または文字列を変換します．

   文字列は`expr'対し引用符で囲みませんが，例えばスペースのような，
シェルで特別な意味を持つ文字を保護するために，それらを引用符で囲む必要
があるかもしれません．しかし，引用符で囲まれているかどうかに依存せず，
文字列オペランドは，括弧や`+'のような`expr'の演算子にすべ
きではなく，引用符で囲まれているものを評価するために，任意の文字列を
`$str'をシェルに渡すことは安全ではありません．これを排比する方法
の一つは，`GNU'の拡張`+' (例えば`+ "$str" = foo')で
す．より移植性の高い方法は，`" $str"'を使用し，前置するスペー
スを数に入れるため式の結果を調整することです(例えば`" $str" = " foo"')．

   オプションとして間違って解釈される可能性があるので，符の整数や前に
`-'が付く文字列を`expr'の最初の引数として渡すべきではあり
ません．これは，括弧で避けることが可能です．また，移植性の高いスクリプ
トでは，整数の形式となりうる文字列演算子を使用すべきではありません．こ
れは，上記のスペースを前置する方法で回避可能です．

演算子は，挿入辞シンボルや前置キーワードとして与えることができます．カッ
コは，通常の方法のグループとして使用してもかまいません．しかし，シェル
が評価することを避けるために，カッコと多くのオペレータを引用符で囲む必
要があります．

   終了ステータスは，以下のようになります．

     0 式がnullでも0でもない場合．
     1 式がnullまたは0の場合．
     2 式が構文上有効な場合．
     3 エラーが生じた場合．

* Menu:

* String expressions::          + : match substr index length
* Numeric expressions::         + - * / %
* Relations for expr::          | & < <= = == != >= >
* Examples of expr::            Examples.


File: coreutils-ja.info,  Node: String expressions,  Next: Numeric expressions,  Up: expr invocation

16.4.1 文字列式
---------------

`expr'は，パターンマッチングと，その他の文字列演算子をサポート
します．これらは，(次のセクションの)数字と関係の両演算子より低い優先順
位になります．

`STRING : REGEX'
     パターンマッチングを実行します．引数は文字列に制限され，二番目は，
     `^'が暗黙に前置された(基本的にGNU流の`grep'の)正規表現と
     考えられます．最初の引数は，この正規表現に対しマッチの評価がなされます．

     マッチの評価が成功し，REGEXが`\('と`\)'を使用している
     場合，`:'式は，サブ式にマッチしたSTRINGの一部となります．そ
     れ以外の場合はマッチした文字の数を返します．

     マッチの評価に失敗した場合，REGEXで`\('と`\)'が使用さ
     れていれば`:'演算子はnull文字を返し，それ以外では0を返します．

     最初の`\( ... \)'の組のみ，戻り値に関係します．追加の組は，正
     規表現演算子のグループ化の意味しかありません．

     正規表現内では，`\+'，`\?'，そして`\|'は，それぞれ，1以
     上，ゼロ以上，オア分離の選択肢の演算子です．SunOSとその他の
     `expr'はこれらを通常の文字として扱います．(POSIXは，
     どちらの動作も許可します．) 正規表現の構文の詳細は，*Note Regular
     Expression Library: (regex)Top.  例は*Note Examples of expr::
     にあります．

`match STRING REGEX'
     パターンマッチングを行う別の方法です．これは，`STRING : REGEX'と同じです．

`substr STRING POSITION LENGTH'
     少なくともLENGTHの長さの，POSITIONから始まる，STRING
     のサブ文字列を返します．POSITIONまたはLENGTHのどちらかが，
     負，ゼロ，または数字以外の場合，null文字列を返します．

`index STRING CHARSET'
     CHARSETの最初の文字が見つかった，STRINGの最初の位置を返し
     ます．CHARSETの文字がSTRINGで見つからない場合は，0を返しま す．

`length STRING'
     STRINGの長さを返します．

`+ TOKEN'
     キーワードのようなMATCHや，演算子のような`/'の場合でも，
     TOKENを文字列として解釈します．これで，`expr length + "$x"'
     や`expr + "$x" : '.*/\(.\)''のテストが可能となり，$Xの値が
     (例えば)`/'や`index'に偶然なった場合でも，正しく動作します．
     この演算子はGNUの拡張です．移植性の高いシェルスクリプトでは，`+
     "$token"'の代わりに`" $token" : ' \(.*\)''を使用すべきで す．


   `expr'にキーワードとして文字列を解釈させるために，`quote'
演算子を使用する必要があります．


File: coreutils-ja.info,  Node: Numeric expressions,  Next: Relations for expr,  Prev: String expressions,  Up: expr invocation

16.4.2 数式
-----------

`expr'は，通常の算術演算子をサポートし，優先順位は順に増加しま
す．(前のセクションの)文字列演算子は，より順位の低い演算子で，(次のセ
クションの)連結子は，より順位が高くなります．

`+ -'
     加算と減算です．どちらの引数も整数に変換されます．そうでない場合はエラー
     を生じます．

`* / %'
     乗算，除算，剰余です．どちらの引数も整数に変換されます．そうでない場合
     はエラーを生じます．



File: coreutils-ja.info,  Node: Relations for expr,  Next: Examples of expr,  Prev: Numeric expressions,  Up: expr invocation

16.4.3 `expr'の関係式
---------------------

`expr'は，通常の論理結合と関係式をサポートします．これらは(前
のセクションの)文字や数字の演算子より優先順位が高くなっています．ここ
に，低い優先順位を最初にしたリストがあります．

`|'
     最初の引数がnullでもゼロでもない場合はそれを，それ以外では，二番目の引
     数がnullでもゼロでもない場合はそれを，それ以外では0を返します．最初の
     引数がnullでもゼロでもない場合，二番目の引数と同じにはなりません．

`&'
     どちらの引数もnullやゼロでない場合は最初の引数を，それ以外では0を返し
     ます．最初の引数がnullでもゼロでもない場合，二番目の引数と同じにはなり
     ません．

`< <= = == != >= >'
     引数を比較し，関係が真の場合は1を，それ以外では0を返します．`=='
     は`='の同義語です．`expr'は最初に，両方の引数を整数に変換
     しようとし，数値の比較を行います．どちらかの変換が失敗した場合，
     `LC_COLLATE'で指定されている文字の対応表の順序を使用して，辞書的な
     比較を行います．



File: coreutils-ja.info,  Node: Examples of expr,  Prev: Relations for expr,  Up: expr invocation

16.4.4 `expr'の使用例
---------------------

シェルのメタ文字を引用符で囲むものを含む例として以下のようなものがあり
ます．

   Bourne互換シェルで，シェル変数`foo'に1を加えます．
     foo=`expr $foo + 1`

   `$fname'に保存されているファイル名のディレクトリ以外の部分を，
`/'を含めずに出力します．
     expr $fname : '.*/\(.*\)' '|' $fname

   `\+'が演算子だということを表示する例です．
     expr aaa : 'a\+'
     => 3

     expr abc : 'a\(.\)c'
     => b
     expr index abcdef cz
     => 3
     expr index index a
     error--> expr: syntax error
     expr index quote index a
     => 0


File: coreutils-ja.info,  Node: Redirection,  Next: File name manipulation,  Prev: Conditions,  Up: Top

17 リダイレクション
*******************

Unixシェルは，通常いくつかの形式の"リダイレクション(redirection)"
を提供します -- コマンドの入力元や出力先を変更する方法です．しかし，
一つの便利なリダイレクションでは，シェルではなく，別々のコマンドで実行
されます．以下ではそれを記述します．

* Menu:

* tee invocation::              Redirect output to multiple files.


File: coreutils-ja.info,  Node: tee invocation,  Up: Redirection

17.1 `tee': 出力を複数のファイルにリダイレクトする
==================================================

`tee'コマンドは，標準入力を標準出力と引数で与えられた任意のファ
イルにコピーします．これは，データをパイプに送るだけでなく，コピーを保
存したいときに役に立ちます．概要です．

     tee [OPTION]... [FILE]...

存在しないファイルに書き出す場合，ファイルが作成されます．既存のファイ
ルに書き出す場合，前から含まれているデータは，`-a'オプションが
使用されない場合は上書きされます．

   プログラムは以下のオプションを受け入れます．*Note Common
options::も参照 してください．

`-a'
`--append'
     標準入力を与えられたファイルに，上書きせずに追加します．

`-i'
`--ignore-interrupts'
     中断シグナルを無視します．


   終了ステータスのゼロは成功を示し，ゼロ以外の値は失敗を示します．


File: coreutils-ja.info,  Node: File name manipulation,  Next: Working context,  Prev: Redirection,  Up: Top

18 ファイル名の操作
*******************

このセクションはファイル名を操作するコマンドを記述します．

* Menu:

* basename invocation::         Strip directory and suffix from a file name.
* dirname invocation::          Strip non-directory suffix from a file name.
* pathchk invocation::          Check file name portability.


File: coreutils-ja.info,  Node: basename invocation,  Next: dirname invocation,  Up: File name manipulation

18.1 `basename': ディレクトリと接尾子をファイル名から除去
=========================================================

`basename'は，前置されるディレクトリ要素をNAMEから削除し
ます．概要です．

     basename NAME [SUFFIX]

   SUFFIXが指定され，NAMEの終りが同じ場合，それはNAMEか
ら同様に削除されます．`basename'は結果を標準出力に出力します．

   オプションは`--help'と`--version'だけです．*Note Common options::.

   終了ステータスのゼロは成功を示し，ゼロ以外の値は失敗を示します．


File: coreutils-ja.info,  Node: dirname invocation,  Next: pathchk invocation,  Prev: basename invocation,  Up: File name manipulation

18.2 `dirname': ディレクトリ以外の接尾子をファイル名から除去
============================================================

`dirname'は，最後のスラッシュで分離されている(おそらくファイル
名となる)文字列の内容以外をすべて出力します．概要です．

     dirname NAME

   NAMEは単一の要素で，`dirname'は(現在のディレクトリを意味 する)
`.'を表示します．

   オプションは`--help'と`--version'だけです．*Note Common options::.

   終了ステータスのゼロは成功を示し，ゼロ以外の値は失敗を示します．


File: coreutils-ja.info,  Node: pathchk invocation,  Prev: dirname invocation,  Up: File name manipulation

18.3 `pathchk': ファイル名の移植性を調査
========================================

`pathchk'は，ファイル名の移植性を調査します．概要です．

     pathchk [OPTION]... NAME...

   それぞれのNAMEに対し，`pathchk'はこれらの条件が真かどう
かのメッセージを出力します．
  1. NAMEに存在するディレクトリの一つが検索(実行)許可を持たない．

  2. NAMEの長さが，ファイルシステムのファイル名の長さの最大より長い．

  3. 既存のディレクトリ名にマッチするNAMEの一つの要素の長さが，ファイ
     ルシステムのファイル名の要素の長さの最大より長い．

   プログラムは以下のオプションも受け入れます．*Note Common
options::も参照 してください．

`-p'
`--portability'
     根底にあるファイルシステムの長さ調査を実行する代わりに，
     POSIXの移植性のための最小制限に対し，それぞれのファイル名と
     その要素の長さをテストします．ファイル名に，移植性のあるファイル名文字
     セットに無い文字が含まれていないことも調査します．


   終了ステータス．

     0 すべての指定されたファイル名が，すべてのテストを通過した場合．
     1 それ以外．


File: coreutils-ja.info,  Node: Working context,  Next: User information,  Prev: File name manipulation,  Up: Top

19 作業の状況
*************

このセクションは，作業している状況を表示または変更するコマンドを記述し
ます．現在のディレクトリ，端末設定，その他です．次のセクションのユーザ
関連のコマンドも参照してください．

* Menu:

* pwd invocation::              Print working directory.
* stty invocation::             Print or change terminal characteristics.
* printenv invocation::         Print environment variables.
* tty invocation::              Print file name of terminal on standard input.


File: coreutils-ja.info,  Node: pwd invocation,  Next: stty invocation,  Up: Working context

19.1 `pwd': 作業中のディレクトリを表示
======================================

`pwd'は，現在のディレクトリの完全に解決された名前を出力します．
すなわち，出力される名前のすべての要素は，実際のディレクトリ名です --
シンボリックリンクではありません．

ほとんどのシェルには同じ名前の組み込みコマンドがあるので，装飾なしのス
クリプト内や対話的なコマンド名を用いると，ここで記述しているものとは異
なる機能になる可能性があります．

   オプションは単独の`--help'と`--version'だけです． *Note Common
options::.
終了ステータスのゼロは成功を示し，ゼロ以外の値は失敗を示します．


File: coreutils-ja.info,  Node: stty invocation,  Next: printenv invocation,  Prev: pwd invocation,  Up: Working context

19.2 `stty': 端末の特徴を表示または変更
=======================================

`stty'は，ボーレートのような，端末の特徴を表示または変更します．
概要です．

     stty [OPTION] [SETTING]...
     stty [OPTION]

   設定行がない場合，`stty'は，ボーレート，(システムがサポートす
る)回線制御数，そして`stty sane'で設定された値から変更された回線
設定を表示します．デフォルトで，モードの読み込みと設定は標準入力に接続
されているtty回線で実行されますが，これは`--file'オプションで修
正することが可能です．

   `stty'は，端末回線処理の状況を変更する，以下で記述するようなオ
プションではない多くの引数を受け入れます．

   プログラムは以下のオプションを受け入れます．*Note Common
options::も参照 してください．

`-a'
`--all'
     すべての現在の設定を人間が読める形式で出力します．このオプションは，あ
     らゆる回線設定と組み合わせて使用することはできません．

`-F DEVICE'
`--file=DEVICE'
     標準入力に接続しているtty回線の代わりに，DEVICEで指定されている
     ファイル名で開かれた回線を設定します．このオプションは，`clocal'
     が設定されていない場合，キャリア検出回線が高速ではないので， POSIX
     ttyのブロッキングを避けるために，`O_NONDELAY'フラ
     グの使用を要求するPOSIX ttyを開くために必要です．そのため，
     従来の方法でシェルがデバイスを開くことが，常に可能なわけではありません．

`-g'
`--save'
     他の`stty'コマンドが現在の設定を復元するための引数として使用可
     能な形式で，すべての現在の設定を表示します．このオプションは，あらゆる
     回線設定と組み合わせて使用することはできません．


   多くの設定は，前置される`-'で停止することが可能です．そのような引
数は，それら記述で"取り消し可能"として以下では印がついています．記述
自身は，肯定の場合を述べていて，すなわち，(もちろん，明言されていなけ
れば)取り消しでは_ありません_．

   設定には，拡張を使用しているため，すべてのPOSIXシステムで利
用可能ではないものもあります．そのような引数はその記述で"非
POSIX"という印がついています．非POSIXシステムでは，
これらやその他の設定も利用可能ではありませんが，すべてのバリエーション
を説明するのは実行不可能です．まずは，試してみてください．

   終了ステータスのゼロは成功を示し，ゼロ以外の値は失敗を示します．

* Menu:

* Control::                     Control settings
* Input::                       Input settings
* Output::                      Output settings
* Local::                       Local settings
* Combination::                 Combination settings
* Characters::                  Special characters
* Special::                     Special settings


File: coreutils-ja.info,  Node: Control,  Next: Input,  Up: stty invocation

19.2.1 制御設定
---------------

制御設定です．

`parenb'
     出力の一般的なパリティビットと，入力の期待するパリティビットです．取り
     消し可能です．

`parodd'
     (取り消す場合も)偶パリティです．取り消し可能です．

`cs5'
`cs6'
`cs7'
`cs8'
     文字サイズを5，6，7，または8ビットに設定します．

`hup'
`hupcl'
     最後の処理がttyを閉じるとき，ハングアップシグナルを送ります．取り消し
     可能です．

`cstopb'
     二つのストップビット(取消しの場合は一つ)を使用します．取り消し可能です．

`cread'
     入力の受信を許可します．取り消し可能です．

`clocal'
     モデム制御シグナルを利用不可能にします．取り消し可能です．

`crtscts'
     RTS/CTSフロー制御を利用可能にします．非POSIXです．取り消し可
     能です．


File: coreutils-ja.info,  Node: Input,  Next: Output,  Prev: Control,  Up: stty invocation

19.2.2 入力設定
---------------

`ignbrk'
     ブレーク文字を無視します．取り消し可能です．

`brkint'
     ブレークを中断シグナルにします．取り消し可能です．

`ignpar'
     パリティエラーの文字を無視します．取り消し可能です．

`parmrk'
     (255-0の文字の順に)パリティーエラーに印を付けます．取り消し可能です．

`inpck'
     入力パリティチェックを可能にします．取り消し可能です．

`istrip'
     入力文字のハイビット(八番目)をクリアします．取り消し可能です．

`inlcr'
     ニューラインをキャリッジリターンに変換します．取り消し可能です．

`igncr'
     キャリッジリターンを無視します．取り消し可能です．

`icrnl'
     キャリッジリターンをニューラインに変換します．取り消し可能です．

`ixon'
     XON/XOFFフロー制御(すなわち，`CTRL-S'/`CTRL-Q')を可能にします．
     取り消し可能です．

`ixoff'
`tandem'
     システム入力バッファがほぼいっぱいのときの`stop'文字と，再びほと
     んど空になったときの`start'文字の送信を可能にします．取り消し可能
     です．

`iuclc'
     大文字を小文字に変換します．非POSIXです．取り消し可能です．

`ixany'
     あらゆる文字の出力の再開を許可します(取消しの場合は開始文字のみです)．
     非POSIXです．取り消し可能です．

`imaxbel'
     入力バッファがいっぱいになったときに文字が届いた場合，ビープを鳴し，入
     力バッファをフラッシュしないことを可能にします．非POSIXです．
     取り消し可能です．


File: coreutils-ja.info,  Node: Output,  Next: Local,  Prev: Input,  Up: stty invocation

19.2.3 出力設定
---------------

以下の引数は出力に関連する処理です．

`opost'
     出力を後処理します．取り消し可能です．

`olcuc'
     小文字を大文字に変換します．非POSIXです．取り消し可能です．

`ocrnl'
     キャリッジリターンをニューラインに変換します．非POSIXです．
     取り消し可能です．

`onlcr'
     ニューラインをキャリッジリターンに変換します．非POSIXです．
     取り消し可能です．

`onocr'
     最初の列のキャリッジリターンを出力しません．非POSIXです．取
     り消し可能です．

`onlret'
     ニューラインがキャリッジリターンを実行します．非POSIXです．
     取り消し可能です．

`ofill'
     遅延に対する時間調整の代わりに，文字の補充(パディング)を使用します．非
     POSIXです．取り消し可能です．

`ofdel'
     補充に対し，null文字の代わりにデリート文字を使用します．非
     POSIXです．取り消し可能です．

`nl1'
`nl0'
     ニューラインの遅延形式です．非POSIXです．

`cr3'
`cr2'
`cr1'
`cr0'
     キャリッジリターンの遅延形式です．非POSIXです．

`tab3'
`tab2'
`tab1'
`tab0'
     水平タブの遅延形式です．非POSIXです．

`bs1'
`bs0'
     バックスペースの遅延形式です．非POSIXです．

`vt1'
`vt0'
     垂直タブの遅延形式です．非POSIXです．

`ff1'
`ff0'
     フォームフィードの遅延形式です．非POSIXです．


File: coreutils-ja.info,  Node: Local,  Next: Combination,  Prev: Output,  Up: stty invocation

19.2.4 ローカル設定
-------------------

`isig'
     `interrupt'， `quit'，そして`suspend'特殊文字を可能にし
     ます．取り消し可能です．

`icanon'
     `erase'，`kill'，`werase'，そして`rprnt'特殊文字を
     可能にします．取り消し可能です．

`iexten'
     非POSIX特殊文字を可能にします．取り消し可能です．

`echo'
     入力文字をエコーバックします．取り消し可能です．

`echoe'
`crterase'
     `erase'文字をバックスペース-スペース-バックスペースとしてエコーバッ
     クします．取り消し可能です．

`echok'
     `kill'文字の後のニューラインをエコーバックします．取り消し可能です．

`echonl'
     他の文字をエコーバックしていなくても，ニューラインをエコーバックします．
     取り消し可能です．

`noflsh'
     `interrupt'と`quit'特殊文字の後のフラッシュを不可能にします．
     取り消し可能です．

`xcase'
     `icanon'が設定されているとき，同じ小文字に`\'を前置すること
     で，入力と出力の大文字を可能にします．非POSIXです．取り消し
     可能です．

`tostop'
     端末に書き込もうとしているバックグラウンド処理を停止します．非
     POSIXです．取り消し可能です．

`echoprt'
`prterase'
     削除された文字を後方の`\'と`/'の間にエコーバックします．非
     POSIXです．取り消し可能です．

`echoctl'
`ctlecho'
     制御文字を，そのままではなく，ハット表示(`^C')でエコーバッ
     クします．非POSIXです．取り消し可能です．

`echoke'
`crtkill'
     `echoctl'と`echok'の設定の代わりに，`echoprt'と
     `echoe'の設定で示すものとして，行のそれぞれの文字を削除することで，
     `kill'特殊文字をエコーバックします．非POSIXです．取り消
     し可能です．


File: coreutils-ja.info,  Node: Combination,  Next: Characters,  Prev: Local,  Up: stty invocation

19.2.5 組み合わせ設定
---------------------

組み合わせ設定です．

`evenp'
`parity'
     `parenb -parodd cs7'と同じです．取り消し可能です．取り消しの場合
     は，`-parenb cs8'と同じです．

`oddp'
     `parenb parodd cs7'と同じです．取り消し可能です．取り消しの場合は，
     `-parenb cs8'と同じです．

`nl'
     `-icrnl -onlcr'と同じです．取り消し可能です．取り消しの場合は，
     `icrnl -inlcr -igncr onlcr -ocrnl -onlret'と同じです．

`ek'
     `erase'と`kill'特殊文字をそのデフォルト値にリセットします．

`sane'
     以下と同じです．
          cread -ignbrk brkint -inlcr -igncr icrnl -ixoff
          -iuclc -ixany imaxbel opost -olcuc -ocrnl onlcr
          -onocr -onlret -ofill -ofdel nl0 cr0 tab0 bs0 vt0
          ff0 isig icanon iexten echo echoe echok -echonl
          -noflsh -xcase -tostop -echoprt echoctl echoke
     そして，すべての特殊文字をそのデフォルト値に設定します．

`cooked'
     `brkint ignpar istrip icrnl ixon opost isig icanon'と同じで，
     `min'と`time'文字が`eof'と`eol'文字と同じ場合は，
     `eof'と`eol'文字をそのデフォルト値に設定します．取り消し可能
     です．取り消しの場合は，`raw'と同じです．

`raw'
     以下と同じです．
          -ignbrk -brkint -ignpar -parmrk -inpck -istrip
          -inlcr -igncr -icrnl -ixon -ixoff -iuclc -ixany
          -imaxbel -opost -isig -icanon -xcase min 1 time 0
     取り消し可能です．取り消しの場合は，`cooked'と同じです．

`cbreak'
     `-icanon'と同じです．取り消し可能です．取り消しの場合は，
     `icanon'と同じです．

`pass8'
     `-parenb -istrip cs8'と同じです．取り消し可能です．取り消しの場合
     は，`parenb istrip cs7'と同じです．

`litout'
     `-parenb -istrip -opost cs8'と同じです．取り消し可能です．取り消
     しの場合は，`parenb istrip opost cs7'同じです．

`decctlq'
     `-ixany'と同じです．非POSIXです．取り消し可能です．

`tabs'
     `tab0'と同じです．取り消し可能です．取り消しの場合は，`tab3'
     と同じです．

`lcase'
`LCASE'
     `xcase iuclc olcuc'と同じです．非POSIXです．取り消し可 能です．

`crt'
     `echoe echoctl echoke'と同じです．

`dec'
     `echoe echoctl echoke -ixany intr ^C erase ^? kill C-u'と同じです．


File: coreutils-ja.info,  Node: Characters,  Next: Special,  Prev: Combination,  Up: stty invocation

19.2.6 特殊文字
---------------

特殊文字のデフォルト値はシステムごとに異なります．それらは，構文 `name
value'で設定され，nameは以下にリストアップされていて，value
はハット表示(`^C')の文字通り，または，16進を示す`0x'，
八進数を示す`0'，または，十進を示すその他もので始まる整数のどちら
かで，与えることが可能です．

   GNU sttyに対し，`^-'や`undef'の値を与えることで，特殊文
字を使用不可能にします．(これは，Ultrix `stty'と互換性がなく，
それは特殊文字を使用不可能にするために`u'の値を使用します． GNU
`stty'は，値`u'を他と同じように扱い，言い換える
と，特殊文字を<U>に設定します．)

`intr'
     中断シグナルを送信します．

`quit'
     終了シグナルを送信します．

`erase'
     最後に入力された文字を削除します．

`kill'
     現在の行を削除します．

`eof'
     ファイルの終りを送信します(入力を終了します)．

`eol'
     行の終りです．

`eol2'
     行の終りの別文字です．非POSIXです．

`swtch'
     異なるシェルレイヤーに切り替えます．非POSIXです．

`start'
     停止後の出力を再開します．

`stop'
     出力を停止します．

`susp'
     端末の停止シグナルを送信します．

`dsusp'
     入力をフラッシュした後，停止シグナルを送信します．非POSIXです．

`rprnt'
     現在の行を再描画します．非POSIXです．

`werase'
     最後に入力された単語を消去します．非POSIXです．

`lnext'
     入力された次の文字を，それが特殊文字の場合でも，そのまま入力します．非
     POSIXです．


File: coreutils-ja.info,  Node: Special,  Prev: Characters,  Up: stty invocation

19.2.7 特殊設定
---------------

`min N'
     `-icanon'が設定されているとき，制限されている時間値までに安全に読
     み込む文字の最小数を設定します．

`time N'
     `-icanon'が設定されているとき，文字の最小数が読み込まれていない場
     合，読み込み時間切れまでの10秒単位の数字を設定します．

`ispeed N'
     入力速度をNに設定します．

`ospeed N'
     出力速度をNに設定します．

`rows N'
     ttyカーネルドライバに端末の行数Nを伝えます．非POSIXです．

`cols N'
`columns N'
     カーネルに端末の列数Nを伝えます．非POSIXです．

`size'
     端末が持っているとカーネルが想像する，列と行の数を表示します．(カーネ
     ルで行と列をサポートしないシステムでは，特に環境変数`LINES'と
     `COLUMNS'が代わりに使用されます．しかし，GNU `stty'はそれ
     について何も知りません．)非POSIXです．

`line N'
     回線制御Nを使用します．非POSIXです．

`speed'
     端末の速度を出力します．

`N'
     入出力の速度をNに設定します．Nは，以下の一つになります．0 50 75
     110 134 134.5 150 200 300 600 1200 1800 2400 4800 9600 19200 38400
     `exta' `extb'です．`exta'は19200と同じです．
     `extb'は38400と同じです．`-clocal'が設定されている場合，0は
     回線を切断します．


File: coreutils-ja.info,  Node: printenv invocation,  Next: tty invocation,  Prev: stty invocation,  Up: Working context

19.3 `printenv': すべてまたはいくつかの環境変数を出力
=====================================================

`printenv'は，環境変数の値を出力します．概要です．

     printenv [OPTION] [VARIABLE]...

   引数が指定されていない場合，`printenv'はすべての環境変数の値を
出力します．それ以外の場合，それは，それぞれの設定されている
VARIABLEの値を出力し，設定されていないものには何もしません．

   オプションは，単独の`--help'または`--version'だけです． *Note Common
options::.

   終了ステータス．

     0 すべての指定された変数が見つかった場合．
     1 指定された変数の少なくとも一つが見つかった場合．
     2 書き込みエラーが発生した場合．


File: coreutils-ja.info,  Node: tty invocation,  Prev: printenv invocation,  Up: Working context

19.4 `tty': 標準入力につながっている端末のファイル名を出力
==========================================================

`tty'は，標準入力が接続してある端末のファイル名を出力します．
標準入力が端末でない場合，それは，`not a tty'を出力します．概要で す．

     tty [OPTION]...

   プログラムは以下のオプションも受け入れます．*Note Common
options::も参照 してください．

`-s'
`--silent'
`--quiet'
     何も出力しません．終了ステータスを返すだけです．


   `tty'の終了ステータスです．

     0 標準入力が端末の場合．
     1 標準入力が端末でない場合．
     2 不正な引数が与えられた場合．
     3 書き込みエラーが発生した場合．


File: coreutils-ja.info,  Node: User information,  Next: System context,  Prev: Working context,  Up: Top

20 ユーザ情報
*************

このセクションは，ユーザに関連する情報を出力するコマンドを記述します．
login，グループ，その他です．

* Menu:

* id invocation::               Print real and effective uid and gid.
* logname invocation::          Print current login name.
* whoami invocation::           Print effective user id.
* groups invocation::           Print group names a user is in.
* users invocation::            Print login names of users currently logged in.
* who invocation::              Print who is currently logged in.


File: coreutils-ja.info,  Node: id invocation,  Next: logname invocation,  Up: User information

20.1 `id': 実際と実効のuidとgidを出力
=====================================

`id'は，与えられたユーザや，ユーザが指定されていない場合はそれ
を実行しているプロセスの情報を出力します．概要です．

     id [OPTION]... [USERNAME]

デフォルトで，それは実際のユーザid，実際のグループid，実際のユーザidと
異なる場合は実効ユーザid，実際のグループidと異なる場合は実効グループid，
そして，追加のグループidを出力します．

それぞれのこれらの数値は，識別文字が前置され，カッコ内に対応するユーザ
やグループ名が続きます．

   オプションで，`id'は，上記の情報の一部のみを出力します． *Note
Common options::も参照してください．

`-g'
`--group'
     グループidのみ出力します．

`-G'
`--groups'
     追加のグループのみ出力します．

`-n'
`--name'
     ID番号の代わりにユーザやグループの名前を出力します．`-u'，`-g'，
     または`-G'が必要です．

`-r'
`--real'
     実効の代わりに，実際のユーザやグループのidを出力します．`-u'，
     `-g'，または`-G'が必要です．

`-u'
`--user'
     ユーザidのみ出力します．


   終了ステータスのゼロは成功を示し，ゼロ以外の値は失敗を示します．


File: coreutils-ja.info,  Node: logname invocation,  Next: whoami invocation,  Prev: id invocation,  Up: User information

20.2 `logname': 現在のログイン名を出力
======================================

`logname'は，ファイル`/etc/utmp'に見つかる，呼び出してい
るユーザ名を出力し，0のステータスで終了します．呼び出しているプロセス
に対する`/etc/utmp'項目がない場合，`logname'はエラーメッ
セージを出力し，1のステータスで終了します．

   オプションは`--help'と`--version'のみです．*Note Common options::.

   終了ステータスのゼロは成功を示し，ゼロ以外の値は失敗を示します．


File: coreutils-ja.info,  Node: whoami invocation,  Next: groups invocation,  Prev: logname invocation,  Up: User information

20.3 `whoami': 実効ユーザidの出力
=================================

`whoami'は，現在の実効ユーザidに関連しているユーザ名を出力しま
す．コマンド`id -un'と同じです．

   オプションは`--help'と`--version'のみです．*Note Common options::.

   終了ステータスのゼロは成功を示し，ゼロ以外の値は失敗を示します．


File: coreutils-ja.info,  Node: groups invocation,  Next: users invocation,  Prev: whoami invocation,  Up: User information

20.4 `groups': ユーザが所属するグループ名を出力
===============================================

`groups'は，与えられたそれぞれのUSERNAME，または，名前が
与えられない場合は現在のプロセスに対する，プライマリと追加のグループ名
を出力します．名前が与えられた場合は，それぞれのユーザ名が，ユーザのグ
ループのリストの前に出力されます．概要です．

     groups [USERNAME]...

   グループリストは，コマンド`id -Gn'の出力と同じです．

   オプションは`--help'と`--version'のみです．*Note Common options::.

   終了ステータスのゼロは成功を示し，ゼロ以外の値は失敗を示します．

