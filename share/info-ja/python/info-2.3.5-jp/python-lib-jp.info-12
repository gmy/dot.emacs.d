This is python-lib-jp.info, produced by makeinfo version 4.5 from
python-lib-jp.texi.

12 October 2005


File: python-lib-jp.info,  Node: math,  Next: cmath,  Prev: test,  Up: 各種サービス

数学関数
========

数学関数(`sin()' など)。

このモジュールはいつでも利用できます。標準 C で定義されている数学関数に
アクセスすることができます。

これらの関数で複素数を使うことはできません。複素数に対応する必要がある
ならば、 `cmath' モジュールにある同じ名前の関数を使ってくだ
さい。ほとんどのユーザーは複素数を理解するのに必要なだけの数学を勉強し
たくないので、複素数に対応した関数と対応していない関数の区別がされてい
ます。これらの関数では複素数が利用できないため、引数に複素数を渡される
と、複素数の結果が返えるのではなく例外が発生します。その結果、プログラ
マは、そもそもどういった理由で例外がスローされたのかに早い段階で気づく
事ができます。(1)

このモジュールでは次の関数が用意されています。
特に明示的に指定されていなければ、戻り値は全て浮動小数点数となります:

`acos(x)'
     X の逆余弦を返します。

`asin(x)'
     X の逆正弦を返します。

`atan(x)'
     X 逆正接を返します。

`atan2(y, x)'
     `atan(Y / X)' の逆正接を返します。

`ceil(x)'
     X 以上の最も小さい整数をfloat型で返します。

`cos(x)'
     X の余弦を返します。

`cosh(x)'
     X の双曲線余弦を返します。

`degrees(x)'
     角 X をラジアンから度数に変換します。

`exp(x)'
     `e**X' を返します。

`fabs(x)'
     X の絶対値を返します。

`floor(x)'
     X 以下の最も大きい整数をfloat型で返します。

`fmod(x, y)'
     プラットフォームの C ライブラリで定義されている `fmod(X, Y)'
     を返します。 Python の `X % Y'
     という式が同じ結果を返さないかもしれないことに注意してください。

`frexp(x)'
     X の仮数と指数を `(M, E)'のペアとして返します。 `X == M * 2**E'
     というように、Mはfloat型でEはint型です。 X がゼロの場合は、 `(0.0,
     0)'を返し、それ以外の場合は、 `0.5 <= abs(M) < 1' です。

`hypot(x, y)'
     ユークリッド距離(`sqrt(X*X + Y*Y)')を返します。

`ldexp(x, i)'
     `X * (2**I)' を返します。

`log(x[, base])'
     X の自然対数を返します。 BASE を底とした X の対数を返します。BASE
     を省略した場合 X の自然対数を返します。 _Changed in Python version
     2.3_


`log10(x)'
     X の10を底とした対数を返します。

`modf(x)'
     Xの小数部分と整数部分を返します。 両方の結果は
     Xの符号を受け継ぎます。 整数部はfloat型で返されます。

`pow(x, y)'
     `X**Y'を返します。

`radians(x)'
     角 X を度数からラジアンに変換します。

`sin(x)'
     Xの正弦を返します。

`sinh(x)'
     Xの双曲線正弦を返します。

`sqrt(x)'
     X の平方根を返します。

`tan(x)'
     X の正接を返します。

`tanh(x)'
     X の双曲線正接を返します。

`frexp()'と `modf()' は C のものとは異なった呼び出し/返し
パターンを持っていることに注意してください。引数を1つだけ受け取り、1組のペアに
なった値を返すので、2つ目の戻り値を`出力引数'(Python
にそのようなものはありません) 経由で返したりはしません。

このモジュールでは2つの数学定数も定義されています。

`pi'
     数学定数 _pi_。

`e'
     数学定数 _e_。

_Notice:_ `math' モジュールは、ほとんどが実行プラットフォームにおける C
言語の数学ライブラリ関数に対する薄いラッパでできています。
例外的な場合での挙動は、 C
言語標準ではおおさっぱにしか定義されておらず、 さらに Python
は数学関数におけるエラー報告機能の挙動をプラットフォームの C
実装から受け継いでいます。その結果として、エラーの際 (およびなんらか
の引数がとにかく例外的であると考えられる場合) に送出される特定の例外に
ついては、プラットフォーム間やリリースバージョン間を通じて有意なものと
なっていません。例えば、 `math.log(0)' が `-Inf' を返すか `ValueError'
または  `OverflowError' を送出するかは不定であり、 `math.log(0)' が
`OverflowError' を送出する場合において `math.log(0L)' が `ValueError'
を送出するときもあります。

See also:
     *Note cmath:: これらの多くの関数の複素数版。

---------- Footnotes ----------

(1) 訳注：例外が発生しないで、計算結果が返えってし
まうと、計算結果がおかしい事から、原因が複素数を渡したせいである事に
プログラマが気づくのがおくれる可能性があります。


File: python-lib-jp.info,  Node: cmath,  Next: random,  Prev: math,  Up: 各種サービス

複素数のための数学関数
======================

複素数のための数学関数です。

このモジュールは常に利用することができます。このモジュールでは、
複素数のための数学関数群へのアクセス手段を提供します。
以下が提供されている関数群です:

`acos(x)'
     X の逆余弦 (arc cosine) を返します。 この関数には二つの branch cut
     があります: 一つは 1 から右側に実数軸に沿って
     _infinity_へと延びていて、 下から連続しています。 もう一つは -1
     から左側に実数軸に沿って -_infinity_へと延びていて、
     上から連続しています。

`acosh(x)'
     X の逆双曲線余弦を返します。 branch cut が一つあり、1
     の左側に実数軸に沿って -_infinity_へと
     延びていて、上から連続しています。

`asin(x)'
     X の逆正弦を返します。 `acos()' と同じ branch cut を持ちます。

`asinh(x)'
     X の双曲線正弦を返します。 2 つの brnch cut があり、+-`1j' の左から
     +-_infinity_`j' に延びており、両方とも上で連続しています。
     これらの branch cut
     は将来のリリースで修正されるべきバグとみなされて います。 正しい
     branch cut は虚数軸に沿って延びており、一つは `1j' から
     _infinity_`j' までで右から連続、もう一方は -`1j' から下って
     -_infinity_`j' までで、左から連続です。

`atan(x)'
     X の逆正接を返します。 2 つの branch cut があります: 一つは `1j'
     から虚数軸に沿って _infinity_`j' へと延びており、
     左で連続です。もう一方は -`1j' から虚数軸に沿って -_infinity_`j'
     までで、左で連続です。 (この仕様は上の branch cut
     が反対側から連続になるように変更されるかも しれません)。

`atanh(x)'
     X の逆双曲線正接を返します。 2 つの branch cut があります: 一つは
     1 から実数軸に沿って _infinity_までで、上で連続です。 もう一方は
     -1 から実数軸に沿って -_infinity_までで、 上で連続です。
     (この仕様は左側の branch cut
     が反対側から連続になるように変更されるかも しれません)。

`cos(x)'
     X の余弦を返します。

`cosh(x)'
     X の双曲線余弦を返します。

`exp(x)'
     指数値 `e**X' を返します。

`log(x)'
     X の自然対数を返します。 branch cut を一つもち、0
     から負の実数軸に沿って -_infinity_に
     延びており、上で連続しています。

`log10(x)'
     X の底 10 対数を返します。 `log()' と同じbranch cut を持ちます。

`sin(x)'
     X の正弦を返します。

`sinh(x)'
     X の双曲線正弦を返します。

`sqrt(x)'
     X の平方根を返します。 `log()' と同じ branch cut を持ちます。

`tan(x)'
     X の正接を返します。

`tanh(x)'
     X の双曲線正接を返します。

このモジュールではまた、以下の数学上の定数も定義しています:

`pi'
     数学上の定数 _pi_ で、実数です。

`e'
     数学上の定数 _e_ で、実数です。

提供される関数の選択は `math'  と同様
ですが、全く同じではないので注意してください。二つのモジュールに
しているのは、ユーザによっては複素数には興味がなく、おそらく
複素数とは何かすら知らないからです。そういった人たちはむしろ、
`math.sqrt(-1)' が複素数を返すよりも例外を送出するほうを
好みます。また、`cmath' で定義されている関数は常に、
たとえ答えを実数として表現することができる (虚数部分がゼロの複素数)
の場合でも、複素数を返すので注意してください。

branch cut に関する注釈: branch cut をもつ曲線上では、与えられた関数は
連続でありえなくなります。これらは多くの複素関数における必然的な
特性です。複素関数を計算する必要がある場合、これらの branch cut に
関して理解しているものと仮定しています。悟りに至るために何らかの
(到底基礎的とはいえない) 複素数に関する書をひもといてください。
数値計算を目的とした branch cut の正しい選択方法についての情報としては、
以下がよい参考文献となります:

See also:
     Kahan, W:  Branch cuts for complex elementary functions; or, Much
     ado about nothings's sign bit.  In Iserles, A., and Powell, M.
     (eds.), . Clarendon Press (1987) pp165-211.


File: python-lib-jp.info,  Node: random,  Next: whrandom,  Prev: cmath,  Up: 各種サービス

擬似乱数を生成する
==================

よく知られている様々な分布をもつ擬似乱数を生成する。

このモジュールでは様々な分布をもつ擬似乱数生成器を実装しています。
整数用では、ある値域内の数の選択を一様にします。
配列用には、配列からのランダムな要素の一様な選択、リストの要素の順列をランダムに置き換える関数、順列を入れ替えずにランダムに取り出す関数があります。

実数用としては、一様分布、正規分布 (ガウス分布)、
対数正規分布、負の指数分布、ガンマおよびベータ分布を計算する
関数があります。 角度分布の生成用には、von Mises 分布が利用可能です。

ほとんど全てのモジュール関数は基礎となる関数 `random()' に依存
します。この関数は半開区間 [0.0, 1.0) の値域を持つ一様な浮動小数点数を生
成します。Python は中心となる乱数生成器として Mersenne Twister を使いま
す。これは 53 ビットの浮動小数点を生成し、周期が  2**19937-1、本体は C
で実装されていて、高速でスレッドセーフです。Mersenne Twister は、現存す
る中で、最も大規模にテストされた乱数生成器のひとつです。しかし、完全に決
定論的であるため、この乱数生成器は全ての目的に合致しているわけではなく、
暗号化の目的には全く向いていません。

このモジュールで提供されている関数は、実際には `random.Random'
クラスの隠蔽されたインスタンスのメソッドにバインドされています。
内部状態を共有しない生成器を取得するため、自分で `Random'
のインスタンスを生成することができます。異なる `Random'
のインスタンスを各スレッド毎に生成し、`jumpahead()'
メソッドを使うことで各々のスレッドにおいて生成された乱数配列が
重複しないようにすれば、マルチスレッドプログラムを作成する上で
特に便利になります。

自分で考案した基本乱数生成器を使いたいなら、クラス `Random' を
サブクラス化することもできます: この場合、メソッド `random()'、
`send()'、`getstate()'、`setstate()'、および `jumpahead()'
をオーバライドしてください。

サブクラス化の例として、`random' モジュールは `WichmannHill'
クラスを提供します。このクラスは Python だけで書かれた代替生成器を実装し
ています。このクラスは、乱数生成器に Wichmann-Hill 法を使っていた古いバ
ージョンの Python から得られた結果を再現するための、後方互換の手段になり
ます。 _Changed in Python version 2.3_

保守関数:

`seed([x])'
     基本乱数生成器を初期化します。 オプション引数 X
     はハッシュ可能な任意のオブジェクトを とり得ます。X が省略されるか
     `None' の場合、現在のシステム 時間が使われます;
     現在のシステム時間はモジュールが最初にインポート
     された時に乱数生成器を初期化するためにも使われます。 X が `None'
     でも、整数でも長整数でもない場合、 `hash(X)' が代わりに使われます。
     X が整数または長整数の場合、X が直接使われます。

`getstate()'
     乱数生成器の現在の内部状態を記憶したオブジェクトを返します。
     このオブジェクトを `setstate()' に渡して内部状態を
     復帰することができます。 _Added in Python version 2.1_

`setstate(state)'
     STATE は予め `getstate()' を呼び出して得ておかなくては
     なりません。`setstate()' は `setstate()' が呼び出
     された時の乱数生成器の内部状態を復帰します。 _Added in Python
     version 2.1_

`jumpahead(n)'
     内部状態を、現在の状態から、非常に離れているであろう状態に変更します。
     N は非負の整数です。 これはマルチスレッドのプログラムが複数の
     `Random' クラス のインスタンスと結合されている場合に非常に便利です:
     `setstate()' や `seed()'
     は全てのインスタンスを同じ内部状態にするのに
     使うことができ、その後 `jumpahead()' を使って各インスタンスの
     内部状態を引き離すことができます。 _Added in Python version 2.1_
     _Changed in Python version 2.3_

整数用の関数:

`randrange([start,] stop[, step])'
     `range(START、STOP、STEP)' の要素から
     ランダムに選ばれた要素を返します。この関数は `choice(range(START,
     STOP, STEP))' と等価ですが、実際には range
     オブジェクトを生成しません。 _Added in Python version 1.5.2_

`randint(a, b)'
     `A <= N <= B' であるような ランダムな整数 N を返します。

配列用の関数:

`choice(seq)'
     空でない配列 SEQ からランダムに要素を返します。

`shuffle(x[, random])'
     配列 X を直接変更によって混ぜます。 オプションの引数 RANDOM
     は、値域が [0.0, 1.0) のランダムな
     浮動小数点数を返すような引数を持たない関数です; 標準では、
     この関数は `random()' です。

     かなり小さい `len(X)' であっても、X の順列は
     ほとんどの乱数生成器の周期よりも大きくなるので注意してください;
     このことは長い配列に対してはほとんどの順列は生成されないことを
     意味します。

`sample(population, k)'
     母集団の配列から選ばれた長さ K の一意な要素からなるリスト
     を返します。値の置換を行わないランダムサンプリングに用いられます。
     _Added in Python version 2.3_

     母集団自体を変更せずに、母集団内の要素を含む新たなリストを返します。返さ
     れたリストは選択された順に並んでいるので、このリストの部分スライスもラン
     ダムなサンプルになります。これにより、くじの当選者を1等賞と2等賞（の部分
     スライス）に分けるといったことも可能です。母集団の要素はハッシュ可能でな
     くても、ユニークでなくても、かまいません。母集団が繰り返しを含む場合、返
     されたリストの各要素はサンプルから選択可能な要素になります。整数の並びか
     らサンプルを選ぶには、引数に `xrange' を使いましょう。特に、巨
     大な母集団からサンプルを取るとき、速度と空間効率が上がります。
     `sample(xrange(10000000), 60)'

以下の関数は特殊な実数値分布を生成します。関数パラメタは
対応する分布の公式において、数学的な慣行に従って使われている
変数から取られた名前がつけられています; これらの公式のほとんどは
多くの統計学のテキストに載っています。

`random()'
     値域 [0.0, 1.0) の次のランダムな浮動小数点数を返します。

`uniform(a, b)'
     `A <= N <= B' であるような ランダムな実数 N を返します。

`betavariate(alpha, beta)'
     ベータ分布です。引数の満たすべき条件は Beta distribution.
     Conditions on the parameters are `ALPHA > -1' および `BETA > -1'
     です。 0 から 1 の値を返します。

`cunifvariate(mean, arc)'
     円形一様分布です。MEAN は平均角度で、ARC は平均角を
     中心とした分布の範囲です。値は両方ともラジアンで表され、0 から
     _pi_ の値をとることができます。返される値の範囲は `MEAN - ARC/2'
     から `MEAN + ARC/2' になりますが、  0 から _pi_
     の間に正規化されます。

     _This is deprecated in Python 2.3.  `(MEAN + ARC *
     (random.random() - 0.5)) % math.pi' を代わりに使ってください。_

`expovariate(lambd)'
     指数分布です。LAMBD は平均にしたい値で 1.0 を割ったものです。
     (このパラメタは "lambda" と呼ぶべきなのですが、Python の予約語
     なので使えません。) 返される値の範囲は 0 から正の無限大です。

`gammavariate(alpha, beta)'
     ガンマ分布です。 (ガンマ関数 _ではありません_ ！)
     引数の満たすべき条件は  `ALPHA > 0' および `BETA > 0' です。

`gauss(mu, sigma)'
     ガウス分布です。MU は平均であり、 SIGMA は
     標準偏差です。この関数は後で定義する関数 `normalvariate()'
     より少しだけ高速です。

`lognormvariate(mu, sigma)'
     対数正規分布です。この分布を自然対数を用いた分布にした場合、 平均
     MU で標準偏差 SIGMA の正規分布になるでしょう。 MU
     は任意の値を取ることができ、 SIGMA はゼロより
     大きくなければなりません。

`normalvariate(mu, sigma)'
     正規分布です、MU は平均で、SIGMA は標準偏差です。

`vonmisesvariate(mu, kappa)'
     MU は平均の角度で、0 から 2*_pi_ までのラジアンで
     表されます。KAPPA は濃度パラメタで、ゼロまたはそれ以上
     でなければなりません。KAPPA がゼロに等しい場合、 この分布は範囲 0
     から 2*_pi_ の一様でランダムな角度の 分布に退化します。

`paretovariate(alpha)'
     パレート分布です。ALPHA は形状パラメタです。

`weibullvariate(alpha, beta)'
     ワイブル分布です。ALPHA はスケールパラメタで、 BETA
     は形状パラメタです。

代替の乱数生成器

`WichmannHill([seed])'
     乱数生成器として Wichmann-Hill アルゴリズムを実装するクラスです。
     `Random' クラスと同じメソッド全てと、下で説明する `whseed'
     メソッドを持ちます。このクラスは、Python
     だけで実装されているので、スレ
     ッドセーフではなく、呼び出しと呼び出しの間にロックが必要です。また、周期
     が 6,953,607,871,644
     と短く、独立した2つの乱数列が重複しないように注意が 必要です。

`whseed([x])'
     これは obsolete で、バージョン 2.1 以前の Python
     と、ビット・レベルの互 換性のために提供されてます。詳細は `seed'
     を参照してください。 `whseed'
     は、引数に与えた整数が異なっても、内部状態が異なること
     を保障しません。取り得る内部状態の個数が 2**24
     以下になる場合もあります。

See also:
     M. Matsumoto and T. Nishimura, "Mersenne Twister: A
     623-dimensionally equidistributed uniform pseudorandom number
     generator",  Vol. 8, No. 1, January pp.3-30 1998.

     Wichmann, B. A. & Hill, I. D., "Algorithm AS 183: An efficient and
     portable pseudo-random number generator",  31 (1982) 188-190.


File: python-lib-jp.info,  Node: whrandom,  Next: bisect,  Prev: random,  Up: 各種サービス

擬似乱数生成器
==============

浮動小数点数の擬似乱数生成器。

_This is deprecated in Python 2.1.  `random' を代りに使ってください。_

_Note:_ Python 2.1 以前のリリースでは、このモジュールは  `random'
モジュールの実装における一部でした。
現在はもう使われていません。このモジュールを直接使わないで ください;
代わりに `random' を使ってください。 This module was an implementation
detail of the

このモジュールは Wichmann-Hill による擬似乱数生成器クラスを実装します。
このクラスはまた、 `whrandom' と名づけられています。 `whrandom'
クラスのインスタンスは  節で記述されている乱数生成器インタフェース
(Random Number Generator インタフェース) に準拠しています。
このモジュールではまた、Wichmann-Hill アルゴリズムに特有の
以下のメソッドを提供しています:

`seed([x, y, z])'
     整数 X、Y、Z から乱数生成器を初期化します。
     このモジュールが最初に取り込まれたときに、乱数は現在の時刻から
     取り出された値で初期化されます。 X、Y、および Z が省略されるか `0'
     の場合、
     乱数のシードは現在のシステム時刻から計算されます。引数のうち 3
     つ全てではなく、1 または 2 個だけが `0' の場合、ゼロ
     に鳴っている値は 1 に置き換えられます。このことにより、一見して
     異なるシード値が同じ値になってしまい、乱数生成器から生成される
     擬似乱数列もこれに対応します。

`choice(seq)'
     空でない配列 SEQ からランダムに要素を選んで返します。

`randint(a, b)'
     `A<=N<=B' であるような整数の乱数 N を返します。

`random()'
     範囲 [0.0 ... 1.0) から次の浮動小数点数の乱数 N を返します。

`seed(x, y, z)'
     整数 X、Y、Z から乱数生成器を初期化します。
     このモジュールが最初にインポートされた際、乱数は現在の時刻から
     取り出された値で初期化されます。

`uniform(a, b)'
     `A<=N<B' であるようなランダムな実数 N を返します。

`whrandom' モジュールがインポートされた時、`whrandom'
クラスのインスタンスも生成され、このインスタンスのメソッドを
モジュールレベルで利用できるようにします。従って、 `N =
whrandom.random()' を以下のコード:

     generator = whrandom.whrandom()
     N = generator.random()

のように書くこともできます。

乱数生成器の別々のインスタンスを使った場合、擬似乱数の配列
は独立になるので注意してください。

See also:
     *Note random:: Generators for various random distributions and
     documentation for the Random Number Generator interface.
     Wichmann, B. A. & Hill, I. D., "Algorithm AS 183:  An efficient
     and portable pseudo-random number generator",  31 (1982) 188-190.


File: python-lib-jp.info,  Node: bisect,  Next: heapq,  Prev: whrandom,  Up: 各種サービス

配列二分法アルゴリズム
======================

バイナリサーチ用の配列二分法アルゴリズム。

このモジュールは、挿入の度にリストをソートすることなく、リストをソートされた
順序に保つことをサポートします。
大量の比較操作を伴うような、アイテムがたくさんあるリストでは、より一般的な
アプローチに比べて、パフォーマンスが向上します。

動作に基本的な二分法アルゴリズムを使っているので、`bisect'
と呼ばれています。
ソースコードはこのアルゴリズムの実例として一番役に立つかもしれません
(境界条件はすでに正しいです!)。

次の関数が用意されています。

`bisect_left(list, item[, lo[, hi]])'
     ソートされた順序を保ったまま ITEM を LIST に挿入するのに適した
     挿入点を探し当てます。
     リストの中から検索する部分集合を指定するには、パラメーターの LO と
     HI を使います。 デフォルトでは、リスト全体が使われます。 ITEM
     がすでに LIST に含まれている場合、挿入点はどのエントリー
     よりも前(左)になります。 戻り値は、`LIST.insert()'
     の第一引数として使うのに適しています。 LIST
     はすでにソートされているものとします。 _Added in Python version
     2.1_

`bisect_right(list, item[, lo[, hi]])'
     `bisect_left()' と似ていますが、LIST に含まれる ITEM
     のうち、どのエントリーよりも後ろ(右)にくるような挿入点を返します。
     _Added in Python version 2.1_。

`bisect(...)'
     `bisect_right()' のエイリアス。

`insort_left(list, item[, lo[, hi]])'
     ITEM を LIST にソートされた順序で(ソートされたまま)挿入します。
     これは、 `LIST.insert(bisect.bisect_left(LIST, ITEM, LO, HI),
     ITEM)' と同等です。 LIST はすでにソートされているものとします。
     _Added in Python version 2.1_

`insort_right(list, item[, lo[, hi]])'
     `insort_left()' と似ていますが、LIST に含まれる ITEM
     のうち、どのエントリーよりも後ろに ITEM を挿入します。 _Added in
     Python version 2.1_

`insort(...)'
     `insort_right()' のエイリアス。

* Menu:

* bisect-example::


File: python-lib-jp.info,  Node: bisect-example,  Prev: bisect,  Up: bisect

使用例
------

一般には、`bisect()' 関数は数値データを分類するのに役に立ちます。
この例では、`bisect()' を使って、(たとえば)順序のついた数値の区切り点
の集合に基づいて、試験全体の成績の文字を調べます。 区切り点は 85 以上は
`A'、 75..84 は `B'、などです。

     >>> grades = "FEDCBA"
     >>> breakpoints = [30, 44, 66, 75, 85]
     >>> from bisect import bisect
     >>> def grade(total):
     ...           return grades[bisect(breakpoints, total)]
     ...
     >>> grade(66)
     'C'
     >>> map(grade, [33, 99, 77, 44, 12, 88])
     ['E', 'A', 'B', 'D', 'F', 'A']

bisect モジュールは Queue
モジュールと一緒に使って、優先順序つき待ち行列を実装
することができます。 (Fredrik Lundh の好意による例です):

     import Queue, bisect
     
     class PriorityQueue(Queue.Queue):
         def _put(self, item):
             bisect.insort(self.queue, item)
     
     # 使い方
     queue = PriorityQueue(0)
     queue.put((2, "second"))
     queue.put((1, "first"))
     queue.put((3, "third"))
     priority, value = queue.get()


File: python-lib-jp.info,  Node: heapq,  Next: array,  Prev: bisect,  Up: 各種サービス

ヒープキューアルゴリズム
========================

ヒープキュー (別名優先度キュー) アルゴリズム。

_Added in Python version 2.3_

このモジュールではヒープキューアルゴリズムの一実装を提供しています。
優先度キューアルゴリズムとしても知られています。

ヒープとは、全ての K に対して、ゼロから要素を数えて いった際に、
`HEAP[K] <= HEAP[2*K+1]' かつ `HEAP[K] <= HEAP[2*K+2]'
となる配列です。比較のために、存在しない要素は無限大として扱われます。
ヒープの興味深い属性は `HEAP[0]' が常に最小の要素に なることです。

以下の API は教科書におけるヒープアルゴリズムとは 2 つの側面で異なって
います: (a) ゼロベースのインデクス化を行っています。これにより、
ノードに対するインデクスとその子ノードのインデクスの関係がやや明瞭で
なくなりますが、Python はゼロベースのインデクス化を使っているので
よりしっくりきます。(b) われわれの pop メソッドは最大の要素ではなく
最小の要素 (教科書では "min heap:最小ヒープ" と呼ばれています;
教科書では並べ替えをインプレースで行うのに適した "max heap:最大ヒープ"
が一般的です)。

これらの 2 点によって、ユーザに戸惑いを与えることなく、ヒープを通常の
Python リストとして見ることができます: `HEAP[0]' が最小の 要素となり、
`HEAP.sort()' はヒープを不変なままに保ちます!

ヒープを作成するには、`[]' に初期化されたリストを使うか、 `heapify()'
を用いて要素の入ったリストを変換します。

以下の関数が提供されています:

`heappush(heap, item)'
     ITEM を HEAP に push します。ヒープを不変に保ちます。

`heappop(heap)'
     pop を行い、HEAP から最初の要素を返します。ヒープは不変に
     保たれます。ヒープが空の場合、`IndexError' が送出されます。

`heapify(x)'
     リスト X をインプレース処理し、線形時間でヒープに変換します。

`heapreplace(heap, item)'
     HEAP から最小の要素を pop して返し、新たに ITEM を push
     します。ヒープのサイズは変更されません。 ヒープが空の場合、
     `IndexError' が送出されます。 この関数は `heappop()' に次いで
     `heappush()'
     を送出するよりも効率的で、固定サイズのヒープを用いている場合には
     より適しています。返される値は ITEM よりも大きくなるかも
     しれないので気をつけてください! これにより、このルーチンの合理的な
     利用法が制限されています。

使用例を以下に示します:

     >>> from heapq import heappush, heappop
     >>> heap = []
     >>> data = [1, 3, 5, 7, 9, 2, 4, 6, 8, 0]
     >>> for item in data:
     ...     heappush(heap, item)
     ...
     >>> sorted = []
     >>> while heap:
     ...     sorted.append(heappop(heap))
     ...
     >>> print sorted
     [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
     >>> data.sort()
     >>> print data == sorted
     True
     >>>

* Menu:

* 理論::


File: python-lib-jp.info,  Node: 理論,  Prev: heapq,  Up: heapq

理論
----

(説明は Fran輟is Pinard によるものです。このモジュールの Python コード
は Kevin O'Connor の貢献によるものです。)

ヒープとは、全ての K について、要素を 0 から数えたときに、 `a[K] <=
a[2*K+1]' かつ `a[K] <= a[2*K+2]' となる配列です。
比較のために、存在しない要素を無限大と考えます。 ヒープの興味深い属性は
`HEAP[0]' が常に最小の要素に なることです。

上記の奇妙な不変式は、勝ち抜き戦判定の際に効率的なメモリ表現を行う
ためのものです。 以下の番号は `a[K]' ではなく K とします:

                                        0
     
                       1                                 2
     
               3               4                5               6
     
           7       8       9       10      11      12      13      14
     
         15 16   17 18   19 20   21 22   23 24   25 26   27 28   29 30

上の木構造では、各セル K は `2*K+1' および `2*K+2'
を最大値としています。 スポーツに見られるような通常の 2
つ組勝ち抜き戦では、各セルはその
下にある二つのセルに対する勝者となっていて、個々のセルの勝者を
追跡していくことにより、そのセルに対する全ての相手を見ることが
できます。しかしながら、このような勝ち抜き戦を使う計算機
アプリケーションの多くでは、勝歴を追跡する必要はりません。
メモリ効率をより高めるために、勝者が上位に進級した際、
下のレベルから持ってきて置き換えることにすると、あるセルと
その下位にある二つのセルは異なる三つの要素を含み、かつ
上位のセルは二つの下位のセルに対して "勝者と" なります。

このヒープ不変式が常に守られれば、インデクス 0 は明らかに
最勝者となります。最勝者の要素を除去し、"次の" 勝者を見つける
ための最も単純なアルゴリズム的手法は、ある敗者要素 (ここでは上図の セル
30 とします) を 0 の場所に持っていき、この新しい 0 を
濾過するようにしてツリーを下らせて値を交換してゆきます。不変関係が
再構築されるまでこれを続けます。この操作は明らかに、ツリー内の
全ての要素数に対して対数的な計算量となります。全ての要素について
繰り返すと、 O(n log n) のソート(並べ替え)になります。

このソートの良い点は、新たに挿入する要素が、その最に取り出す 0 番目の
要素よりも "良い値" でない限り、ソートを行っている最中に新たな要素を
効率的に追加できるというところです。

この性質は、シミュレーション的な状況で、ツリーで全ての入力
イベントを保持し、"勝者となる状況" を最小のスケジュール時刻にする
ような場合に特に便利です。あるイベントが他のイベント群の実行を
スケジュールする際、それらは未来にスケジュールされることになるので、
それらのイベント群を容易にヒープに積むことができます。
すなわち、ヒープはスケジューラを実装する上で良いデータ構造で
あるといえます (私は MIDI シーケンサで使っているものです :-).

これまでスケジューラを実装するための様々なデータ構造が広範に
研究されています。ヒープは十分高速で、速度もおおむね一定であり、
最悪の場合でも平均的な速度とさほど変わらないため良いデータ構造と
いえます。しかし、最悪の場合がひどい速度になることを除き、
たいていでより効率の高い他のデータ構造表現も存在します。

ヒープはまた、巨大なディスクのソートでも非常に有用です。
おそらくご存知のように、巨大なソートを行うと、複数の "ラン (run)"
(予めソートされた配列で、そのサイズは通常 CPU メモリの量に関係
しています) が生成され、続いて統合処理 (merging) がこれらのランを
判定します。この統合処理はしばしば非常に巧妙に組織されています (1)。
重要なのは、最初のソートが可能な限り長いランを生成することです。
勝ち抜き戦はこれを行うための良い方法です。もし利用可能な全ての
メモリを使って勝ち抜き戦を行い、要素を置換および濾過処理して
現在のランに収めれば、ランダムな入力に対してメモリの二倍の
サイズのランを生成することになり、大体順序づけがなされている入力に
対してはもっと高い効率になります。

さらに、ディスク上の 0 番目の要素を出力して、現在の勝ち抜き戦に
(最後に出力した値に "勝って" しまうために) 収められない入力を得た
なら、ヒープには収まらないため、ヒープのサイズは減少します。
解放されたメモリは二つ目のヒープを段階的に構築するために巧妙に再利用
することができ、この二つ目のヒープは最初のヒープが崩壊していく
のと同じ速度で成長します。最初のヒープが完全に消滅したら、
ヒープを切り替えて新たなランを開始します。なんと巧妙で
効率的なのでしょう！

一言で言うと、ヒープは知って得するメモリ構造です。
私はいくつかのアプリケーションでヒープを使っていて、 `ヒープ'
モジュールを常備するのはいい事だと考えています。 :-)

---------- Footnotes ----------

(1) 現在使われているディスクバランス化アルゴリズムは、最近は
もはや巧妙というよりも目障りであり、このためにディスクに対するシーク
機能が重要になっています。巨大な容量を持つテープのようにシーク不能な
デバイスでは、事情は全く異なり、個々のテープ上の移動が可能な限り
効率的に行われるように非常に巧妙な処理を (相当前もって) 行わねば
なりません (すなわち、もっとも統合処理の "進行" に関係があります)。
テープによっては逆方向に読むことさえでき、巻き戻しに時間を取られる
のを避けるために使うこともできます。正直、本当に良いテープソート
は見ていて素晴らしく驚異的なものです！ソートというのは常に偉大な
芸術なのです！:-)


File: python-lib-jp.info,  Node: array,  Next: sets,  Prev: heapq,  Up: 各種サービス

効率のよい数値配列
==================

Efficient arrays of uniformly typed numeric values.

このモジュールは基本的な値(文字、整数、浮動小数点数)の配列を効率よく表現できる新しいオブジェクト型を定義します。配列
はシーケンス型であり、格納されるオブジェクトの型に制限があることを除けば、リストとまったく同じように振る舞います。オブジェクト生成時に一文字の"型コード"を用いて型を指定します。次の型コードが定義されています:

型コード           Cの型              Pythonの型         最小サイズ(バイト単位)
------             ------             ------             ------
'c'                char               文字(str型)        1
'b'                signed char        int型              1
'B'                unsigned char      int型              1
'u'                Py_UNICODE         Unicode文字(unicode型)2
'h'                signed short       int型              2
'H'                unsigned short     int型              2
'i'                signed int         int型              2
'I'                unsigned int       long型             2
'l'                signed long        int型              4
'L'                unsigned long      long型             4
'f'                float              float型            4
'd'                double             float型            8

値の実際の表現はマシンアーキテクチャ(厳密に言うとCの実装)によって決まります。`itemsize'属性から実際のサイズが得られます。Pythonの通常の整数型ではCのunsigned
(long)整数の最大範囲を表せないため、`'L''と`'I''要素として格納される値はPythonの長整数として表されます。

モジュールは次の型を定義します:

`array(typecode[, initializer])'
     要素のデータ型がTYPECODEに限定される新しい配列を返します。オプションの値INITIALIZERをわたすと初期値になりますが、リストまたは文字列でなければなりません。新しい配列に初期要素を追加するために、リストまたは文字列はその配列の`fromlist()'、`fromstring()'あるいは`fromunicode()'メソッド(以下を参照して下さい)へ渡されます。

`ArrayType'
     もはや使われない`array'の別名。

配列オブジェクトは、添字付け、スライス、連結および反復といった通常のシーケンス演算をサポートします。スライス代入を使うとき、代入される値は同じ方コードの配列オブジェクトでなければなりません。他すべての場合には、`TypeError'が発生します。配列オブジェクトはバッファインターフェイスを実装しており、バッファオブジェクトがサポートされるところではどこでも使われます。

次のデータアイテムとメソッドもサポートされます:

`typecode'
     配列を作るときに使われる型コード文字です。

`itemsize'
     内部表現における1つの配列要素のバイト単位の長さです。

`append(x)'
     値Xをもつ新しい要素を配列の末尾に追加します。

`buffer_info()'
     配列の内容を保持するのに使われているバッファの現在のメモリアドレスと要素の長さを与えるタプル`(ADDRESS,
     LENGTH)'を返します。`ARRAY.buffer_info()[1] *
     ARRAY.itemsize'で、バイト単位のメモリバッファの大きさを計算できます。メモリアドレスを必要とする、例えば`ioctl()'操作のような低レベルな(そして、本質的に危険な)I/Oインタフェースを使って作業する場合に、ときどき便利です。その配列が存在し、長さを変える演算が行われない限り、返される数は有効です。

     _Note:_
     CあるいはC++で書かれたコードから配列オブジェクトを使う(この情報を効率的に使うたった一つの方法)ときは、配列オブジェクトがサポートするバッファインターフェイスを使う方がより理にかなっています。このメソッドは後方互換性のために保守されており、新しいコードでの使用は避けるべきです。バッファインターフェイスはで文書化されています。

`byteswap()'
     配列のすべての要素に対して"バイトスワップ"(リトルエンディアンとビッグエンディアンの変換)を行います。これは大きさが1、2、4および8バイトである値に対してのみサポートされます。値の他の型に対しては、`RuntimeError'が発生します。異なるバイトオーダーをもつマシンで書かれたファイルからデータを読み込むときに役に立ちます。

`count(x)'
     配列中のXの出現回数を返す。

`extend(a)'
     Aから配列の末尾へ配列要素を追加します。二つの配列は_全く_同じ型コードを持っていなければなりません。そうでなければ、`TypeError'が発生します。

`fromfile(f, n)'
     ファイルオブジェクトFから(マシン依存のデータ形式そのままで)N個の要素を読み込み、それらを配列の末尾に追加します。N個の要素を読めなかったときは`EOFError'が発生しますが、そのときでも利用可能な要素は配列に追加されます。Fは実際の組み込みファイルオブジェクトでなければなりません。`read()'メソッドをもつ他のものは動作しないでしょう。

`fromlist(list)'
     リストから要素を追加します。型エラーが発生した場合に配列が変更されないことを除いて、`for
     x in LIST: a.append(x)'と同等です。

`fromstring(s)'
     文字列から要素を追加します。(まるでファイルから`fromfile()'メソッドを使って読み込んだかのように)マシン依存のデータの配列として文字列を解釈しています。

`fromunicode(s)'
     与えられたユニコード文字列からのデータで、この配列を拡張します。配列は型'u'の配列でなければなりません。そうでなければ、ValueErrorが発生します。他の型の配列にユニコードデータを追加するには、`array.fromstring(ustr.decode(enc))'を使ってください。

`index(x)'
     配列の中でXが初めて現れるインデックスである、もっとも小さいIを返します。

`insert(i, x)'
     配列の位置Iの前に値Xをもつ新しい要素を挿入します。
     Iが負数の場合、配列の末尾からの相対位置として扱います。

`pop([i])'
     配列からインデックスIの要素を取り除き、それを返します。デフォルトで最後の要素を取り除いて返すようすするために、オプションの引数の既定値は`-1'です。

`read(f, n)'
     _This is deprecated in Python 1.5.1.
     `fromfile()'メソッドを使ってください。_
     ファイルオブジェクトFから(マシン依存のデータ形式そのままで)N個の要素を読み込んで、
     それらを配列の末尾に追加します。N個より少ない要素しか読めなかった場合には`EOFError'が発生しますが、そのときでも利用可能な要素は配列に追加されます。Fは実際の組み込みファイルオブジェクトでなければなりません。`read()'をもつ他のものは動作しないでしょう。

`remove(x)'
     配列から最初に現れるXを取り除きます。

`reverse()'
     配列の要素の順番を逆にします。

`tofile(f)'
     ファイルオブジェクトFにすべての要素を(マシン依存のデータ形式そのままで)書き込みます。

`tolist()'
     配列を同じ要素を持つ普通のリストに変換します。

`tostring()'
     配列をマシン依存のデータの配列に変換し、文字列表現(`tofile()'メソッドによってファイルに書き込まれるものと同じバイトシーケンス)を返します。

`tounicode()'
     配列をユニコード文字列に変換します。配列は型'u'の配列でなければなりません。そうでないならば、ValueErrorが発生します。他の型の配列からユニコード文字列を得るには、array.tostring().decode(enc)を使ってください。

`write(f)'
     _This is deprecated in Python 1.5.1.
     `tofile()'メソッドを使ってください。_
     ファイルオブジェクトFに、全ての要素を(マシン依存のデータ形式そのままで)書き込みます。

配列オブジェクトが表示される、あるいは文字列に変換されるとき、`array(TYPECODE,
INITIALIZER)'というように表現されます。配列が空ならば、INITIALIZERは省略されます。そうではなくTYPECODEが`'c''ならば、それは文字列になります。さもなければ、数字のリストになります。`array()'関数が`from
array import
array'である限り、文字列は逆クォーテーション(```')を用いて同じデータ型と値を持つ配列に逆変換できることが保証されています。例:

     array('l')
     array('c', 'hello world')
     array('u', u'hello \textbackslash u2641')
     array('l', [1, 2, 3, 4, 5])
     array('d', [1.0, 2.0, 3.14])

See also:
     *Note struct::
     異なる種類のバイナリデータをパックおよびアンパックします。 *Note
     xdrlib:: 遠隔手続き呼び出しシステムで使われるExternal Data
     Representation (XDR)データをパックおよびアンパックします。 `The
     Numerical Python Manual'{Numeric
     Python拡張(NumPy)は、別の配列型を定義しています。Numerical
     Pythonについてのこれ以上の情報は、<http://numpy.sourceforge.net/>を参照してください。(NumPyマニュアルのPDFバージョンは<http://numpy.sourceforge.net/numdoc/numdoc.pdf>で手に入ります。}


File: python-lib-jp.info,  Node: sets,  Next: itertools,  Prev: array,  Up: 各種サービス

ユニークな要素の順序なしコレクション
====================================

ユニークな要素の集合の実装

_Added in Python version 2.3_

`sets'モジュールは、ユニークな要素の順序なしコレクションを構築し、
操作するためのクラスを提供します。
帰属関係のテストやシーケンスから重複を取り除いたり、
積集合・和集合・差集合・対称差集合のような標準的な数学操作などを含みます。

他のコレクションのように、`X in SET', `len(SET)', `for X in
SET'をサポートします。
順序なしコレクションは、挿入の順序や要素位置を記録しません。
従って、インデックス・スライス・他のシーケンス的な振舞いをサポートしません。

ほとんどの集合のアプリケーションは、`__hash__()'を除いて
すべての集合のメソッドを提供する`Set'クラスを使用します。
ハッシュを要求する高度なアプリケーションについては、
`ImmutableSet'クラスが`__hash__()'メソッドを加えているが、
集合の内容を変更するメソッドは省略されます。 `Set'と`ImmutableSet'は、
何が集合(`isinstance(OBJ, BaseSet)')であるか決めるのに役立つ
抽象クラス`BaseSet'から派生します。

集合クラスは辞書を使用して実装されます。
その結果、集合はリストや辞書のような変更可能な要素を含むことができません。
しかしそれらは、タプルや`ImmutableSet'のインスタンスのような
不変コレクションを含むことができます。
集合の集合の実装中の便宜については、内部集合が自動的に変更不可能な形式に
変換されます。
例えば、`Set([Set(['dog'])])'は`Set([ImmutableSet(['dog'])])'へ
変換されます。

`Set([iterable])'
     新しい空の`Set'オブジェクトを構築します。
     もしオプションITERABLEが与えられたら、イタレータから得られた
     要素を備えた集合として更新します。
     ITERABLE中の全ての要素は、変更不可能であるか、 または*Note
     itertools::で記述されたプロトコルを使って
     変更不可能なものに変換可能であるべきです。

`ImmutableSet([iterable])'
     新しい空の`ImmutableSet'オブジェクトを構築します。
     もしオプションITERABLEが与えられたら、イタレータから得られた
     要素を備えた集合として更新します。
     ITERABLE中の全ての要素は、変更不可能であるか、 または*Note
     itertools::で記述されたプロトコルを使って
     変更不可能なものに変換可能であるべきです。

     `ImmutableSet'オブジェクトは`__hash__()'メソッドを備えているので、
     集合要素または辞書キーとして使用することができます。
     `ImmutableSet'オブジェクトは要素を加えたり取り除いたりするメソッドを
     持っていません。したがって、コンストラクタが呼ばれたとき要素はすべて
     知られていなければなりません。

* Menu:

* Set オブジェクト::
* 使用例 2::
* 不変に自動変換するためのプロトコル::


File: python-lib-jp.info,  Node: Set オブジェクト,  Next: 使用例 2,  Prev: sets,  Up: sets

Set オブジェクト
----------------

`Set'と`ImmutableSet'のインスタンスはともに、 以下の操作を備えています:

演算                     等価な演算               結果
------                   -----                    -----
len(S)                                            集合Sの濃度
                                                  (cardinality)
X in S                                            XがSに帰属していれば真を返す
X not in S                                        XがSに帰属していなければ真を返す
S.issubset(T)            `S <= T'                 Sのすべての要素がTに帰属していれば真を返す
S.issuperset(T)          `S >= T'                 Tのすべての要素がSに帰属していれば真を返す
S.union(T)               S \textbar{} T           SとTの両方の要素からなる新しい集合
S.intersection(T)        S & T                    SとTで共通する要素からなる新しい集合
S.difference(T)          S - T                    SにあるがTにない要素からなる新しい集合
S.symmetric_difference(T)S ^ T                    SとTのどちらか一方に属する要素からなる集合
S.copy()                                          Sの浅いコピーからなる集合

演算子を使わない書き方である `union()'、 `intersection()'、
`difference()'、および`symmetric_difference()' は任意の
イテレート可能オブジェクトを引数として受け取るのに対し、演算子を使った
書き方の方では引数は集合型でなければならないので注意してください。
これはエラーの元となる`Set('abc') & 'cbs'' のような書き方を
排除し、より可読性のある`Set('abc').intersection('cbs')'
を選ばせるための仕様です。 _Changed in Python version 2.3.1_

加えて、`Set'と`ImmutableSet' は集合間の比較をサポートしています。
二つの集合は、各々の集合のすべての要素が他方に含まれて (各々が他方の
部分集合) いる場合、かつその場合に限り等価になります。
ある集合は、他方の集合の真の部分集合 (proper subset、部分集合で
あるが非等価)
である場合、かつその場合に限り、他方の集合より小さくなります。
ある集合は、他方の集合の真の上位集合 (proper superset、上位集合で
あるが非等価)
である場合、かつその場合に限り、他方の集合より大きくなります。

部分集合比較やと等値比較では、完全な順序決定関数を一般化できません。
たとえば、互いに素な 2 つの集合は等しくありませんし、互いの部
分集合でもないので、`A<B'、 `A==B'、 `A>B' は_すべて_ `False'
を返します。 したがって集合は `__cmp__' メソッドを実装しません。

集合は一部の順序（部分集合の関係）を定義するだけなので、集合のリストにおいて
`list.sort()' メソッドの出力は未定義です。

以下は`ImmutableSet'で利用可能であるが`Set'にはない操作です:

演算                                 結果
------                               -----
hash(S)                              S のハッシュ値を返す

以下は`Set'で利用可能であるが`ImmutableSet'にはない操作です:

演算                     等価な演算               結果
------                   -----                    -----
S.union_update(T)        S \textbar= T            Tを加えた要素からなる集合Sを返します
S.intersection_update(T) S &= T                   Tでも見つかった要素だけを持つ集合Sを返します
S.difference_update(T)   S -= T                   Tにあった要素を取り除いた後の集合Sを返します
S.symmetric_difference_update(T)S ^= T                   SとTのどちらか一方に属する要素からなる集合
                                                  Sを返します
S.add(X)                                          要素Xを集合Sに加えます
S.remove(X)                                       要素Xを集合Sから取り除きます;
                                                  X がなければ KeyError
                                                  を送出します
S.discard(X)                                      要素Xが存在すれば、集合Sから取り除きます
S.pop()                                           Sから要素を取り除き、それを返します;
                                                  集合が空なら KeyError
                                                  を送出します
S.clear()                                         集合Sからすべての要素を取り除きます

演算子を使わない書き方である `union_update()'、
`intersection_update()'、`difference_update()'、
および`symmetric_difference_update()' は任意の
イテレート可能オブジェクトを引数として受け取るので注意してください。
_Changed in Python version 2.3.1_


File: python-lib-jp.info,  Node: 使用例 2,  Next: 不変に自動変換するためのプロトコル,  Prev: Set オブジェクト,  Up: sets

使用例
------

     >>> from sets import Set
     >>> engineers = Set(['John', 'Jane', 'Jack', 'Janice'])
     >>> programmers = Set(['Jack', 'Sam', 'Susan', 'Janice'])
     >>> managers = Set(['Jane', 'Jack', 'Susan', 'Zack'])
     >>> employees = engineers | programmers | managers           # union
     >>> engineering_management = engineers & managers            # intersection
     >>> fulltime_management = managers - engineers - programmers # difference
     >>> engineers.add('Marvin')                                  # add element
     >>> print engineers
     Set(['Jane', 'Marvin', 'Janice', 'John', 'Jack'])
     >>> employees.issuperset(engineers)           # superset test
     False
     >>> employees.union_update(engineers)         # update from another set
     >>> employees.issuperset(engineers)
     True
     >>> for group in [engineers, programmers, managers, employees]:
     ...     group.discard('Susan')                # unconditionally remove element
     ...     print group
     ...
     Set(['Jane', 'Marvin', 'Janice', 'John', 'Jack'])
     Set(['Janice', 'Jack', 'Sam'])
     Set(['Jane', 'Zack', 'Jack'])
     Set(['Jack', 'Sam', 'Jane', 'Marvin', 'Janice', 'John', 'Zack'])


File: python-lib-jp.info,  Node: 不変に自動変換するためのプロトコル,  Prev: 使用例 2,  Up: sets

不変に自動変換するためのプロトコル
----------------------------------

集合は変更不可能な要素だけを含むことできます。
都合上、変更可能な`Set'オブジェクトは、集合要素として加えられる前に、
自動的に`ImmutableSet'へコピーします。
そのメカニズムはハッシュ可能な要素を常に加えることですが、
もしハッシュ不可能な場合は、その要素は変更不可能な等価物を返す
`__as_immutable__()'メソッドを持っているかどうかチェックされます。

`Set'オブジェクトは、`ImmutableSet'のインスタンスを返す
`__as_immutable()__'メソッドを持っているので、集合の集合を構築
することが可能です。

集合内のメンバーであることをチェックするために、
要素をハッシュする必要がある`__contains__()'メソッドと
`remove()'メソッドが、同様のメカニズムを必要としています。
これらのメソッドは要素がハッシュできるかチェックします。
もし出来なければ-`__hash__()',`__eq__()',`__ne__()'
のための一時的なメソッドを備えたクラスによってラップされた要素を返すメソッド-
`__as_temporarily_immutable__()'メソッドをチェックします。

代理メカニズムは、オリジナルの可変オブジェクトから分かれたコピーを
組み上げる手間を助けてくれます。

`Set'オブジェクトは、新しいクラス`_TemporarilyImmutableSet'
によってラップされた`Set'オブジェクトを返す、
`__as_temporarily_immutable__()'メソッドを実装します。

ハッシュ可能を与えるための2つのメカニズムは通常ユーザーに見えません。
しかしながら、マルチスレッド環境下においては、
`_TemporarilyImmutableSet'によって一時的にラップされたものを
持っているスレッドがあるときに、もう一つのスレッドが集合を更新することで、
衝突を発生させることができます。
言いかえれば、変更可能な集合の集合はスレッドセーフではありません。


File: python-lib-jp.info,  Node: itertools,  Next: ConfigParser,  Prev: sets,  Up: 各種サービス

効率的なループ実行のためのイテレータ生成関数
============================================

効率的なループ実行のためのイテレータ生成関数。

_Added in Python version 2.3_

このモジュールではイテレータを構築する部品を実装しています。プログラム言
語HaskellとSMLからアイデアを得ていますが、Pythonに適した形に修正されてい
ます。

このモジュールは、高速でメモリ効率に優れ、単独でも組み合わせても使用する
ことのできるツールを標準化したものです。標準化により、多数の個人が、それ
ぞれの好みと命名規約で、それぞれ少しだけ異なる実装を行う為に発生する可読
性と信頼性の問題を軽減する事ができます。

ここで定義したツールは簡単に組み合わせて使用することができるようになって
おり、アプリケーション固有のツールを簡潔かつ効率的に作成する事ができます。

例えば、SMLの作表ツール`tabulate(f)'は`f(0), f(1), ...'のシー
ケンスを作成します。このツールボックスでは`imap()'と
`count()'を用意しており、この二つを組み合わせて `imap(f,
count())'とすれば同じ結果を得る事ができます。

同様に、`operator'モジュールの高速な関数とも一緒に使用すること
ができるようになっています。

他にこのモジュールに追加したい基本的な構築部品があれば、開発者に提案して
ください。

イテレータを使用すると、Pythonで書いてもCで書いてもリストを使用した同じ
処理よりメモリ効率がよく、高速となります。これはデータをメモリ上に"在庫
"しておくのではなく、必要に応じて作成する注文生産方式を採用しているため
です。

イテレータによるパフォーマンス上のメリットは、要素の数が増えるにつれてよ
り明確になります。一定以上の要素を持つリストでは、メモリキャッシュのパフ
ォーマンスに対する影響が大きく、実行速度が低下します。

See also:
     The Standard ML Basis Library, .

     Haskell, A Purely Functional Language, .

* Menu:

* Itertool関数::
* 例 6::

