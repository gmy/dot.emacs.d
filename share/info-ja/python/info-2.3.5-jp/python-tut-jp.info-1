This is python-tut-jp.info, produced by makeinfo version 4.5 from
python-tut-jp.texi.

12 October 2005


File: python-tut-jp.info,  Node: Top,  Next: 序,  Prev: (dir),  Up: (dir)

Python チュートリアル
*********************

* Menu:

* 序::
* Python への意欲を高める::
* Python インタプリタを使う::
* 形式ばらない Python の紹介::
* その他の制御フローツール::
* データ構造::
* モジュール::
* 入力と出力::
* エラーと例外::
* クラス::
* 標準ライブラリの簡単なツアー::
* さあ何を？::
* 対話入力編集とヒストリ置換::
* 浮動小数点演算、その問題と制限::
* 歴史とライセンス::
* 日本語訳について::
* 用語集::
* Module Index::
* Class-Exception-Object Index::
* Function-Method-Variable Index::
* Miscellaneous Index::


File: python-tut-jp.info,  Node: 序,  Next: Python への意欲を高める,  Prev: Top,  Up: Top

序
**

Copyright (C) 2001, 2002, 2003 Python Software Foundation.  All rights
reserved.

Copyright (C) 2000 BeOpen.com.  All rights reserved.

Copyright (C) 1995-2000 Corporation for National Research Initiatives.
All rights reserved.

Copyright (C) 1991-1995 Stichting Mathematisch Centrum.  All rights
reserved.

Translation Copyright (C) 2003 Python Document Japanese Translation
Project. All rights reserved.

ライセンスおよび許諾に関する完全な情報は、このドキュメントの末尾を
参照してください。

     Python は簡単に学ぶことができ、それでいて強力な言語の一つです。
     Python には高レベルなデータ構造が効率的に実装されており、
     オブジェクト指向プログラミングに対しても、単純でありがながら
     効果的なアプローチをしています。洗練された文法とデータ型を動的に
     決定する機能は、そのインタプリタの特性とあいまって Python を
     理想的なスクリプトプログラミング言語にするとともに、多くの
     プラットフォームにおける幅広い対象領域において迅速にアプリケーションを
     開発できるようにしています。

     Python インタプリタ自体と拡張可能な標準ライブラリは、
     ソースコード、または多くの主要な計算機環境向けのバイナリ形式として、
     いずれも Python Web サイト <http://www.python.org/> から無料で
     入手でき、かつ無料で配布することができます。
     このサイトではまた、無料で手に入るたくさんのサードパーティ製
     Python モジュール、プログラム、ツール類、追加のドキュメントに
     ついて、その配布物やポインタが置かれています。

     Python インタプリタは C 言語や C++ 言語 (あるいは C 言語から
     呼び出すことができるその他の言語) で実装された新たな関数やデータ
     構造を組み込んで拡張することが簡単にできます。Python はまた、
     カスタマイズ可能なアプリケーションを作るための拡張機能記述言語
     としてぴったりです。

     このチュートリアルでは、Python の言語仕様と仕組みについて、その
     基本的な概念と機能をざっと紹介します。例として挙げた題について
     自分の手で体験するには手元に Python
     インタプリタがあると便利ですが、
     どの題もそれ自体で完結した話になっているので、このチュートリアルを
     オフラインで読むことも可能です。

     標準のオブジェクトやモジュールの記述については、ドキュメント
     「Python ライブラリリファレンス ()」 を 参照してください。C 言語や
     C++ 言語で拡張モジュールを書くなら、 「Python
     インタプリタの拡張と埋め込み ()」、および 「Python/C API
     リファレンス ()」を参照してください。Python
     について広く深くカバーしている 書籍もいくつかあります。

     このチュートリアルは網羅的な内容ではありません。また、個別の機能
     について全てをカバーしているわけでもありません。通常使われている
     機能すら全てカバーされていません。その代わり、このチュートリアルでは
     Python
     の特筆すべき機能をたくさん紹介して、この言語の持ち味やスタイル
     について好印象を持ってもらうつもりです。このチュートリアルを読んだ
     後には、読者のみなさんは Python のモジュールやプログラムを読み書き
     できるようになり、 「Python ライブラリリファレンス ()」
     に記述されているさまざまな Python ライブラリモジュールについて学ぶ
     準備ができていることでしょう。



File: python-tut-jp.info,  Node: Python への意欲を高める,  Next: Python インタプリタを使う,  Prev: 序,  Up: Top

Python への意欲を高める
***********************

巨大なシェルスクリプトを書いたことがあるなら、
「もう一つ機能を追加したいのだけれど、プログラムはすでに遅くなりすぎて
いるし、巨大すぎるし、複雑すぎる ...」、あるいは 「追加したい機能
にはシステムコールか、 C 言語からしかアクセスできない別の関数が必要 だ
...」 といった気持ちを理解できるでしょう。

身近な課題というのはたいてい、スクリプトを C 言語で書き直すほど大した
ことではありません; そしてその課題にはおそらく可変長の文字列や
(ファイル名をソートしたリストのような) 他のデータ型 が必要で、
これはシェルスクリプトで実装するのは簡単だが C 言語でやるのは大仕事に
なるし、もしかするとあなた自身はそれほど C 言語に詳しくはないかも
しれません。

別の状況として、「おそらくいくつかの C 言語のライブラリを使って
仕事をしなければならないのだけれど、C 言語でお決まりの、プログラム
作成／コンパイル／テスト／再コンパイルのサイクルは時間がかかりすぎる。
もっと早くプログラムを開発したい」、あるいは、「機能拡張のための
言語を使えるようなプログラムを書いたのだけれど、新しく言語を設計して、
その言語のためのインタプリタを実装して、テストして、自分の
アプリケーションと連動させるまではやりたくない」といったことも
あるでしょう。

これらのケースでは、Python はまさにあなたにぴったりの言語です。 Python
は使い方は単純ですが、シェルスクリプトよりも多くのデータ
構造を扱うことができ、大規模なプログラムを行うためのサポートを
持った本物のプログラム言語です。一方で、 Python は C 言語よりも
はるかに多くのエラーチェック機構を提供しています。また、 _超高水準
(very-high-level)_ のプログラム言語で、柔軟性のある
配列や辞書といった高水準データ型が組み込まれています。これらの型を
効率よく処理するための実装を C 言語でやろうとすると数日がかりに
なってしまうでしょう。比較的汎用性の高いデータ型を持つため、 Python は
_Awk_ や _Perl_ さえはるかにしのぐ広い領域の
問題に適用することができます。その上、Python でやれば、多くの
仕事は上述の言語と少なくとも同じくらいに簡単にこなせます。

Python ではプログラムをモジュールに分割して他の Python プログラムで
再利用することができます。Python には膨大な標準モジュールが付属
していて、プログラムを作る上での基盤として -- あるいは Python
プログラミングを学ぶために -- 利用することができます。組み込み
モジュールではまた、ファイル I/O 、システムコール、ソケットといった
機能や、Tk のようなグラフィカルユーザインタフェースツールキットを使う
ためのインタフェースさえも提供しています。

Python はインタプリタ言語です。このため、コンパイルやリンクが必要
ないので、プログラムを開発する際にかなりの時間を節約できます。
インタプリタは対話的に利用することもできます。対話的インタプリタの
利用によって、この言語の様々な機能について実験してみたり、やっつけ仕事
のプログラムを書いたり、ボトムアップでプログラムを開発する際に
関数をテストしたりといったことが簡単にできます。便利な電卓にもなります。

Python
では、とてもコンパクトで読みやすいプログラムを書くことができます。
Python で書かれたプログラムは大抵、同じ機能を提供する C 言語や C++
言語のプログラムよりもはるかに短くなります。これには以下のようないくつか
の理由があります:

   *
     高レベルのデータ型によって、複雑な操作を一つの実行文で表現することが
     できます;

   * 実行文のグループ化はグループの開始や終了の括弧を使う代わりに
     インデントで行うことができます;

   * 変数や引数の宣言が不要になります。

Python は _拡張する_ ことができます: C 言語でプログラムを書く方法
を知っているなら、新たな組み込み関数やモジュールをインタプリタに追加
することは簡単です。これによって、処理速度を決定的に左右する操作を
最大速度で動作するように実現したり、(ベンダ特有のグラフィクスライブラリ
のように) バイナリ形式でしか手に入らないライブラリを Python にリンク
したりできます。その気になれば、Python インタプリタを C で書かれた
アプリケーションにリンクして、アプリケーションに対する拡張言語や
命令言語として使うこともできます。

ところで、この言語は BBC のショー番組、"モンティパイソンの空飛ぶ
サーカス (Monty Python's Flying Circus)" から取ったもので、
気味の悪い爬虫類とは関係ありません。このドキュメントにある
モンティパイソンの寸劇を参照するのは、よいどころか、むしろ
奨励されています！

* Menu:

* ここからどこへ::


File: python-tut-jp.info,  Node: ここからどこへ,  Prev: Python への意欲を高める,  Up: Python への意欲を高める

ここからどこへ
==============

さて、皆さんはもう Python にとてもそそられて、もうちょっと詳しく
調べてみたくなったはずです。プログラミング言語を習得する最良の
方法は使ってみることですから、ここでやってみましょう。

次の章では、まずインタプリタを使うための機微を説明します。これはさして
面白みのない情報なのですが、後に説明する例題を試してみる上で
不可欠なことです。

チュートリアルの残りの部分では、Python プログラム言語と実行システム
の様々な機能を例題を交えて紹介します。単純な式、実行文、データ型から
始めて、関数とモジュールを経て、最後には例外処理やユーザ定義クラス
といったやや高度な概念にも触れます。


File: python-tut-jp.info,  Node: Python インタプリタを使う,  Next: 形式ばらない Python の紹介,  Prev: Python への意欲を高める,  Up: Top

Python インタプリタを使う
*************************

* Menu:

* インタプリタを起動する::
* インタプリタとその環境::


File: python-tut-jp.info,  Node: インタプリタを起動する,  Next: インタプリタとその環境,  Prev: Python インタプリタを使う,  Up: Python インタプリタを使う

インタプリタを起動する
======================

Python が使える計算機なら、インタプリタはたいてい
`/usr/local/bin/python' にインストールされています; UNIX
シェルのサーチパスに `/usr/local/bin' を入れれば、 シェルで

     python

とコマンドを入力すれば使えるようになります。
インストールする際にどのディレクトリに Python インタプリタを入れるか
をオプションで指定できるので、インタプリタは他のディレクトリにあるかも
しれません; 身近な Python の導師 (guru) か、システム管理者に聞いてみて
ください。(例えば、その他の場所として `/usr/local/python' が
一般的です。)

ファイル終端文字 (UNIXでは <Control-D>、DOS や Windows では
<Control-Z>) を一次プロンプト (primary prompt) に入力すると、
インタプリタは終了状態ゼロで終了します。もしこの操作がうまく働かないなら、
コマンド: `import sys; sys.exit()' を入力することで
インタプリタを終了することができます。

通常、インタプリタの行編集機能は、あまり洗練されたものではありません。
UNIXシステムでは、インタプリタをインストールした誰かが GNU readline
ライブラリのサポートを有効にしていれば、洗練された対話的行編集や
ヒストリ機能が追加されます。
コマンドライン編集機能がサポートされているかを最も手っ取り早く
調べる方法は、おそらく最初に表示された Python プロンプトに Control-P
を入力してみることでしょう。ビープ音が鳴るなら、コマンドライン編集
機能があります; 編集キーについての解説は付録 *Note
対話入力編集とヒストリ置換:: を
参照してください。何も起こらないように見えるか、`^P' が
エコーバックされるなら、コマンドライン編集機能は利用できません;
現在編集中の行から文字を削除するにはバックスペースを使うしかありません。

インタプリタはさながら UNIX シェルのように働きます: 標準入力
が端末に接続された状態で呼び出されると、コマンドを対話的に読み込んで
実行します; ファイル名を引数にしたり、標準入力からファイルを入力
すると、インタプリタはファイルから _スクリプト_ を読み込んで
実行します。

インタプリタを起動する第二の方法は ``python' `-c' COMMAND [arg] ...'
です。この形式では、シェルの `-c' オプションと同じように、 COMMAND
に指定した文を実行します。Python 文はしばしば
スペースその他のシェルにとって特殊な意味をもつ文字を含むので、 COMMAND
全体を二重引用符を囲っておくのがベストです。

`python file' と `python <file' の違いに注意してください。
後者の場合、`input()' や `raw_input()' を呼び出した
時のようにプログラム自体から入力が要求されると、その入力は _ファイル_
から調達されます。プログラムの実行が開始される前に
ファイルはすでにパーザによってファイルの終端まで読み込まれているので、
入力はすぐにファイル終端に到達します。前者の場合 (大抵はこちらの
方が望ましい動作です)、入力には Python インタプリタの標準入力に
接続された何らかのファイルまたはデバイスが充てられます。

スクリプトファイルが使われた場合、スクリプトを走らせて、そのまま対話
モードに入れると便利なことがあります。これは `-i' を
スクリプトの前に追加することで実現できます。(前の段落で述べたのと
同じ理由から、スクリプトが標準入力から読まれた場合にはこのオプション
はうまく働きません。)

* Menu:

* 引数の受け渡し::
* 対話モード::


File: python-tut-jp.info,  Node: 引数の受け渡し,  Next: 対話モード,  Prev: インタプリタを起動する,  Up: インタプリタを起動する

引数の受け渡し
--------------

インタプリタがスクリプト名と付加な引数を受け取ると、それらは 変数
`sys.argv' としてスクリプトに渡されます。これは
文字列からなるリストになります。リストの長さは少なくとも 1 です;
スクリプト名も引数も与えられなければ、`sys.argv[0]' は
空の文字列になります。スクリプト名として `'-'' (標準入力を意味 します)
を与えると、`sys.argv[0]' は `'-'' に設定されます。 `-c' COMMAND
を使うと、`sys.argv[0]' は `'-c'' に設定されます。`-c' COMMAND
より後ろに あるオプションは、Python
インタプリタがオプションを処理する際には 使われませんが、COMMAND
から扱えるように `sys.argv' に は残されます。


File: python-tut-jp.info,  Node: 対話モード,  Prev: 引数の受け渡し,  Up: インタプリタを起動する

対話モード
----------

命令文を tty から読み取っているときには、インタプリタは _対話モード
(interactive mode)_ であるといいます。 このモードでは、インタプリタは
_一次プロンプト(primary prompt)_
を表示して次のコマンドを入力するよう促します。
一次プロンプトは普通、三つの大なり記号 (`>`>'>~') です; 継続する行
(continuation line) に対しては、インタプリタは _二次プロンプト
(secondary prompt)_ を表示します。 これはデフォルトでは三つのドット
(`...~') です。
インタプリタは、最初のプロンプトを出す前にバージョン番号と著作権表示
から始まる歓迎のメッセージを出力します。

     python
     Python 1.5.2b2 (#1, Feb 28 1999, 00:02:06)  [GCC 2.8.1] on sunos5
     Copyright 1991-1995 Stichting Mathematisch Centrum, Amsterdam
     >>>

継続する行は、複数の行から構成される構文を入力するときに必要です。
例として、以下の `if' 文を見てください。

     >>> the_world_is_flat = 1
     >>> if the_world_is_flat:
     ...     print "Be careful not to fall off!"
     ...
     Be careful not to fall off!


File: python-tut-jp.info,  Node: インタプリタとその環境,  Prev: インタプリタを起動する,  Up: Python インタプリタを使う

インタプリタとその環境
======================

* Menu:

* エラー処理::
* 実行可能な Python スクリプト::
* ソースコードの文字コード方式 encoding::
* 対話モード用の起動時実行ファイル::


File: python-tut-jp.info,  Node: エラー処理,  Next: 実行可能な Python スクリプト,  Prev: インタプリタとその環境,  Up: インタプリタとその環境

エラー処理
----------

エラーが発生すると、インタプリタはエラーメッセージとスタックトレース
(stack trace) を出力します。対話モードにいるときは、インタプリタは
一次プロンプトに戻ります; 入力がファイルからきているときには、
インタプリタはスタックトレースを出力した後、非ゼロの終了状態で終了します。
(`try' 文の `except' 節で処理された例外は、ここでいうエラー
にはあたりません。)
いくつかのエラーは無条件に致命的であり、非ゼロの終了状態となるプログラム
の終了を引き起こします; これにはインタプリタ内部の矛盾や
ある種のメモリ枯渇が当てはまります。
エラーメッセージは全て標準エラー出力ストリームに書き込まれます;
これに対して、実行した命令からの通常出力される内容は標準出力に
書き込まれます。

割り込み文字 (interrupt character、普通は Control-C か DEL) を
一次または二次プロンプトに対して打鍵すると、入力が取り消されて
一次プロンプトに戻ります。 (1)
コマンドの実行中に割り込み文字を打鍵すると `KeyboardInterrupt'
例外が送出されます。この例外は `try' 文で処理できます。

---------- Footnotes ----------

(1)  GNU Readline
パッケージに関する問題のせいで妨げられることがあります。


File: python-tut-jp.info,  Node: 実行可能な Python スクリプト,  Next: ソースコードの文字コード方式 encoding,  Prev: エラー処理,  Up: インタプリタとその環境

実行可能な Python スクリプト
----------------------------

BSD 風の UNIX システムでは、Python スクリプトはシェルスクリプトの
ようにして直接実行可能にできます。これを行うには、以下の行

     #! /usr/bin/env python

(ここではインタプリタがユーザの `PATH' 上にあると仮定しています)
をスクリプトの先頭に置き、スクリプトファイルに実行可能モードを
与えます。 `#!' はファイルの最初の２文字でなければなりません。
プラットフォームによっては、この最初の行を終端する改行文字が Mac OS
形式 (`\r') や Windows 形式 (`\r\n') で はなく、
UNIX形式でなければならないことがあります。
ハッシュまたはポンド文字、すなわち `#' は、Python
ではコメントを書き始めるために使われているので注意してください。

`chmod' コマンドを使えば、スクリプトに実行モード (または実行権限)
を与えることができます:

     $ chmod +x myscript.py


File: python-tut-jp.info,  Node: ソースコードの文字コード方式 encoding,  Next: 対話モード用の起動時実行ファイル,  Prev: 実行可能な Python スクリプト,  Up: インタプリタとその環境

ソースコードの文字コード方式 (encoding)
---------------------------------------

ASCII 形式でない文字コード化方式 (エンコーディング: encoding) を Python
ソースコードファイル中で使うことができます。最良の方法は、 `#!' 行の
直後に一行かそれ以上の特殊なコメントを挿入して、ソースファイルのエンコード
を指定するというものです:

     # -*- coding: iso-8859-1 -*-

このように宣言しておくと、ソースファイル中の全ての文字は {}`iso-8859-1'
でエンコードされているものとして扱われ、Unicode 文字列リテラルを指定した
エンコードで直接記述することができます。利用可能なエンコードのリストは
の `codecs' の節にあります。

利用しているエディタがファイルを UTF-8 バイト整列記号 (通称 BOM: Byte
Order Mark) 付きの `UTF-8' で保存できる場合、エンコード
宣言の代わりに使うことができます。 IDLE は `Options/General/Default
Source Encoding/UTF-8' が設定されている場合、 UTF-8
でエンコードされたファイルの識別機能をサポートします。UTF-8 シグネチャ
は (2.2 以前の) 古い Python
リリースでは解釈されず、オペレーティングシステムは `#!'
ファイルを判別できなくなるので注意してください。

UTF-8 を (シグネチャやエンコード宣言を行って) 使うと、世界中の
ほとんどの言語で使われている文字を文字列リテラルやコメントの中に
同時に使うことができます。識別子に対する非 ASCII文字の使用はサポート
されていません。全ての文字を正しく表示できるようにするには、使っている
エディタがファイルを UTF-8 であると認識することができなければならず、
かつファイル内で使われている全ての文字をサポートするようなフォントを
使わなければなりません。


File: python-tut-jp.info,  Node: 対話モード用の起動時実行ファイル,  Prev: ソースコードの文字コード方式 encoding,  Up: インタプリタとその環境

対話モード用の起動時実行ファイル
--------------------------------

Python を対話的に使うときには、インタプリタが起動する度に実行される
何らかの標準的なコマンドがあると便利なことがよくあります。
これを行うには、`PYTHONSTARTUP' と呼ばれる環境変数を、
インタプリタ起動時に実行されるコマンドが入ったファイル名に設定します。
この機能は UNIX シェルの `.profile' に似ています。

このファイルは対話セッションのときだけ読み出されます。Python
がコマンドを スクリプトから読み出しているときや、 `/dev/tty'
がコマンドの 入力元として明示的に指定されている
(この場合対話的セッションのように 動作します) _わけではない_
場合にはこのファイルは読み出されません。
ファイル内のコマンドは、対話的コマンドが実行される名前空間と同じ名前空間内で
実行されます。このため、ファイル内で定義されていたり import された
オブジェクトは、限定子をつけなくても対話セッション内で使うことができます。
また、このファイル内で `sys.ps1' や `sys.ps2' を変更して、
プロンプトを変更することもできます。

もし現在のディレクトリから追加的なスタートアップファイルを読み出したいのなら、
グローバルのスタートアップファイルの中で `if
os.path.isfile('.pythonrc.py'): execfile('.pythonrc.py')'
のようなコードのプログラムを書くことができます。
スクリプト中でスタートアップファイルを使いたいのなら、以下のようにして
スクリプト中で明示的に実行しなければなりません:

     import os
     filename = os.environ.get('PYTHONSTARTUP')
     if filename and os.path.isfile(filename):
         execfile(filename)


File: python-tut-jp.info,  Node: 形式ばらない Python の紹介,  Next: その他の制御フローツール,  Prev: Python インタプリタを使う,  Up: Top

形式ばらない Python の紹介
**************************

以下の例では、入力と出力は (`>`>'>~' や `...~') といった
プロンプトがあるかないかで区別します: 例どおりに実行するなら、
プロンプトが表示されているときに、例中のプロンプトよりも後ろの内容全てを
タイプ入力しなければなりません; プロンプトが先頭にない行はインタプリタ
からの出力です (1) 。

例中には二次プロンプトだけが表示されている行がありますが、これは
空行を入力しなければならないことを意味するので注意してください;
空行の入力は複数の行からなる命令の終わりをインタプリタに教えるために
使われます。

このマニュアルにある例の多くは、対話プロンプトで入力されるものでも
コメントを含んでいます。Python におけるコメント文はハッシュ文字 `#'
で始まり、物理行の終わりまで続きます。
コメントは行の先頭にも、空白やコードの後にも書くことができますが、
文字列リテラル (string literal) の内部に置くことはできません。
文字列リテラル中のハッシュ文字はただのハッシュ文字です。

例:

     # これは１番目のコメント
     SPAM = 1                 # そしてこれは２番目のコメント
                              # ... そしてこれは３番目!
     STRING = "# これはコメントではありません。"

* Menu:

* Python を電卓として使う::
* プログラミングへの第一歩::

---------- Footnotes ----------

(1)  入力と出力を区別するために異なるフォントを使おうとは思うのですが、
それに必要な LaTeX の hack 作業に必要な量が、今のところ私の能力を
超えています。


File: python-tut-jp.info,  Node: Python を電卓として使う,  Next: プログラミングへの第一歩,  Prev: 形式ばらない Python の紹介,  Up: 形式ばらない Python の紹介

Python を電卓として使う
=======================

それでは、簡単な Python コマンドをいくつか試しましょう。
インタプリタを起動して、 一次プロンプト、`>`>'>~' が現れるのを待ちます。
(そう長くはかからないはずです)

* Menu:

* 数::
* 文字列::
* Unicode 文字列::
* リスト::


File: python-tut-jp.info,  Node: 数,  Next: 文字列,  Prev: Python を電卓として使う,  Up: Python を電卓として使う

数
--

インタプリタは単純な電卓のように動作します:
式をタイプ入力することができ、その結果が書き出されます。
式の文法は素直なものです: 演算子 `+', `-', `*', `/' は (Pascal や C
といった) 他のほとんどの言語と同じように動作します。
括弧をグループ化に使うこともできます。例えば:

     >>> 2+2
     4
     >>> # これはコメント
     ... 2+2
     4
     >>> 2+2  # そしてこれはコードと同じ行にあるコメント
     4
     >>> (50-5*6)/4
     5
     >>> # 整数の除算は floor (実数の解を越えない最大の整数) を返す:
     ... 7/3
     2
     >>> 7/-3
     -3

C と同じく、等号 (`=') を使って変数に値を代入します。
代入された値は書き出されません:

     >>> width = 20
     >>> height = 5*9
     >>> width * height
     900

複数の変数に同時に値を代入することができます:

     >>> x = y = z = 0  # x と y と z をゼロにする
     >>> x
     0
     >>> y
     0
     >>> z
     0

浮動小数点は完全にサポートしています;
被演算子の型が混合されているときには、
演算子は整数の被演算子を浮動小数点型に変換します。

     >>> 3 * 3.75 / 1.5
     7.5
     >>> 7.0 / 2
     3.5

複素数もサポートされています。虚数は接尾辞 `j' または `J' を
付けて書き表します。ゼロでない実数部をもつ複素数は `(REAL+IMAGj)'
のように書き表すか、 `complex(REAL, IMAG)' 関数で生成できます。

     >>> 1j * 1J
     (-1+0j)
     >>> 1j * complex(0,1)
     (-1+0j)
     >>> 3+1j*3
     (3+3j)
     >>> (3+1j)*3
     (9+3j)
     >>> (1+2j)/(1+1j)
     (1.5+0.5j)

複素数は、常に実部と虚部に相当する二つの浮動小数点数で表されます。
複素数 Z からそれぞれの部分を取り出すには、`Z.real' と `Z.imag'
を使います。

     >>> a=1.5+0.5j
     >>> a.real
     1.5
     >>> a.imag
     0.5

数値を浮動小数点数や整数へに変換する関数 (`float()', `int()', `long()')
は複素数に対しては動作しません --
複素数を実数に変換する方法には、ただ一つの正解というものがないからです。
絶対値 (magnitude) を (浮動小数点数として) 得るには `abs(Z)' を
使い、実部を得るには `z.real' を使ってください。

     >>> a=3.0+4.0j
     >>> float(a)
     Traceback (most recent call last):
       File "<stdin>", line 1, in ?
     TypeError: can't convert complex to float; use abs(z)
     >>> a.real
     3.0
     >>> a.imag
     4.0
     >>> abs(a)  # sqrt(a.real**2 + a.imag**2)
     5.0
     >>>

対話モードでは、最後に印字された式は変数 `_' に代入されます。
このことを利用すると、 Python を電卓として使うときに、計算を連続して
行う作業が多少楽になります。以下に例を示します:

     >>> tax = 12.5 / 100
     >>> price = 100.50
     >>> price * tax
     12.5625
     >>> price + _
     113.0625
     >>> round(_, 2)
     113.06
     >>>

ユーザはこの変数を読取り専用の値として扱うべきです。
この変数に明示的な代入を行ってはいけません -- そんなことをすれば、
この組み込み変数と同じ名前で、元の組み込み変数の不思議な動作を覆い隠して
しまうような、別個のローカルな変数が生成されてしまいます。


File: python-tut-jp.info,  Node: 文字列,  Next: Unicode 文字列,  Prev: 数,  Up: Python を電卓として使う

文字列
------

数のほかに、Python は文字列も操作できます。
文字列はいくつもの方法で表現できます。
文字列はシングルまたはダブルのクォートで囲みます。

     >>> 'spam eggs'
     'spam eggs'
     >>> 'doesn\'t'
     "doesn't"
     >>> "doesn't"
     "doesn't"
     >>> '"Yes," he said.'
     '"Yes," he said.'
     >>> "\"Yes,\" he said."
     '"Yes," he said.'
     >>> '"Isn\'t," she said.'
     '"Isn\'t," she said.'

文字列リテラルはいくつもかの方法で複数行にまたがって記述することが
できます。継続行を使うことができ、これには行の末尾の文字を
バックスラッシュにします。こうすることで、次の行が現在の行と論理的に
継続していることを示します:

     hello = "This is a rather long string containing\n\
     several lines of text just as you would do in C.\n\
         Note that whitespace at the beginning of the line is\
      significant."
     
     print hello

`\n' を使って文字列に改行位置を埋め込まなくてはならないことに注意
してください; 末尾のバックスラッシュの後ろにある改行文字は無視されます。
従って、上の例は以下のような出力を行います:

     This is a rather long string containing
     several lines of text just as you would do in C.
         Note that whitespace at the beginning of the line is significant.

一方、文字列リテラルを "raw" 文字列にすると、`\n' のような
エスケープシーケンスは改行に変換されません。逆に、行末のバックスラッシュ
やソースコード中の改行文字が文字列データに含められます。つまり、以下の例:

     hello = r"This is a rather long string containing\n\
     several lines of text much as you would do in C."
     
     print hello

は、以下のような出力を行います:

     This is a rather long string containing\n\
     several lines of text much as you would do in C.

また、対になった三重クォート `"""' または `'`'''' で
文字列を囲むこともできます。
三重クォートを使っているときには、行末をエスケープする必要はありません、
しかし、行末の改行文字も文字列に含まれることになります。

     print """
     Usage: thingy [OPTIONS]
          -h                        Display this usage message
          -H hostname               Hostname to connect to
     """

は以下のような出力を行います:

     Usage: thingy [OPTIONS]
          -h                        Display this usage message
          -H hostname               Hostname to connect to

インタプリタは、文字列演算の結果を、タイプ入力する時のと同じ方法で
出力します: 文字列はクオート文字で囲い、クオート文字自体やその他の
奇妙な文字は、正しい文字が表示されるようにするために
バックスラッシュでエスケープします。
文字列がシングルクオートを含み、かつダブルクオートを含まない場合には、
全体をダブルクオートで囲います。そうでない場合にはシングルクオートで
囲みます。 (後で述べる `print' を使って、クオートやエスケープ
のない文字列を書くことができます。)

文字列は `+' 演算子で連結させる (くっつけて一つにする) ことができ、 `*'
演算子で反復させることができます。

     >>> word = 'Help' + 'A'
     >>> word
     'HelpA'
     >>> '<' + word*5 + '>'
     '<HelpAHelpAHelpAHelpAHelpA>'

互いに隣あった二つの文字列リテラルは自動的に連結されます:
例えば、上記の最初の行は `word = 'Help' 'A'' と書くことも できました;
この機能は二つともリテラルの場合にのみ働くもので、
任意の文字列表現で使うことができるわけではありません。

     >>> 'str' 'ing'             #  <-  これは ok
     'string'
     >>> 'str'.strip() + 'ing'   #  <-  これは ok
     'string'
     >>> 'str'.strip() 'ing'     #  <-  これはダメ
       File "<stdin>", line 1, in ?
         'str'.strip() 'ing'
                       ^
     SyntaxError: invalid syntax

文字列は添字表記 (インデクス表記) することができます; C
言語と同じく、文字列の最初の文字の添字 (インデクス) は 0 となります。
独立した文字型というものはありません; 単一の文字は、単に サイズが 1
の文字列です。Icon 言語と同じく、部分文字列を _スライス表記_:
コロンで区切られた二つのインデクスで指定する ことができます。

     >>> word[4]
     'A'
     >>> word[0:2]
     'He'
     >>> word[2:4]
     'lp'

スライスのインデクスには便利なデフォルト値があります;
最初のインデクスを省略すると、0 と見なされます。 第 2
のインデクスを省略すると、スライスしようとする文字列のサイズと
みなされます。

     >>> word[:2]    # 最初の２文字
     'He'
     >>> word[2:]    # 最初の２文字を除くすべて
     'lpA'

C 言語の文字列と違い、Python の文字列は変更できません。
インデクス指定された文字列中のある位置に代入を行おうとすると
エラーになります:

     >>> word[0] = 'x'
     Traceback (most recent call last):
       File "<stdin>", line 1, in ?
     TypeError: object doesn't support item assignment
     >>> word[:1] = 'Splat'
     Traceback (most recent call last):
       File "<stdin>", line 1, in ?
     TypeError: object doesn't support slice assignment

一方、要素どうしを組み合わせた新たな文字列の生成は、簡単で効率的です:

     >>> 'x' + word[1:]
     'xelpA'
     >>> 'Splat' + word[4]
     'SplatA'

スライス演算には便利な不変式があります: `s[:i] + s[i:]' は `s'
に等しくなります。

     >>> word[:2] + word[2:]
     'HelpA'
     >>> word[:3] + word[3:]
     'HelpA'

スライス表記に行儀の悪いインデクス指定をしても、値はたしなみよく処理
されます: インデクスが大きすぎる場合は文字列のサイズと置き換えられます。
スライスの下境界 (文字列の左端) よりも小さいインデクス値を上境界
(文字列の右端) に指定すると、空文字列が返されます。

     >>> word[1:100]
     'elpA'
     >>> word[10:]
     ''
     >>> word[2:1]
     ''

インデクスを負の数にして、右から数えることもできます。 例えば:

     >>> word[-1]     # 最後の文字
     'A'
     >>> word[-2]     # 最後から二つめの文字
     'p'
     >>> word[-2:]    # 最後の２文字
     'pA'
     >>> word[:-2]    # 最後の２文字を除くすべて
     'Hel'

-0 は 0 と全く同じなので、右から数えることができません。
注意してください!

     >>> word[-0]     # (-0 は 0 に等しい)
     'H'

負で、かつ範囲外のインデクスをスライス表記で行うと、インデクス
は切り詰められます。しかし、単一の要素を指定する (スライスでない)
インデクス指定でこれを行ってはいけません:

     >>> word[-100:]
     'HelpA'
     >>> word[-10]    # エラー
     Traceback (most recent call last):
       File "<stdin>", line 1, in ?
     IndexError: string index out of range

スライスの働きかたをおぼえる最も良い方法は、
インデクスが文字と文字の_あいだ (between)_ を指しており、最初の
文字の左端が 0 になっていると考えることです。そうすると、 N
文字からなる文字列中の最後の文字の右端はインデクス N となります。例えば:

      +---+---+---+---+---+
      | H | e | l | p | A |
      +---+---+---+---+---+
      0   1   2   3   4   5
     -5  -4  -3  -2  -1

といった具合です。

数が記された行のうち、最初の方の行は、文字列中のインデクス 0...5 の
位置を表します; 次の行は、対応する負のインデクスを表しています。 I から
J までのスライスは、それぞれ I, J
とラベル付けされたけられた端点間のすべての文字からなります。

非負のインデクス対の場合、スライスされた配列の長さは、スライスの両端の
インデクスが境界内にあるかぎり、インデクス間の差になります。 例えば、
`word[1:3]' の長さは 2 になります。

組込み関数 `len()' は文字列の長さ (length) を返します。

     >>> s = 'supercalifragilisticexpialidocious'
     >>> len(s)
     34

See also:
     `配列型'              {次節で記述されている文字列および Unicode
     文字列は _配列型_
     の例であり、配列型でサポートされている共通の操作を
     サポートしています。} `文字列メソッド'              {文字列や
     Unicode 文字列では、基本的な変換や検索を
     行うための数多くのメソッドをサポートしています。}
     `文字列フォーマット操作'              {文字列や Unicode 文字列が
     `%' 演算子の左被演算子
     である場合に呼び出されるフォーマット操作については、ここで詳しく記述
     されています。}


File: python-tut-jp.info,  Node: Unicode 文字列,  Next: リスト,  Prev: 文字列,  Up: Python を電卓として使う

Unicode 文字列
--------------

Python 2.0 から、プログラマはテキスト・データを格納するための新しい
データ型、Unicode オブジェクトを利用できるようになりました。 Unicode
オブジェクトを使うと、Unicode データ (<http://www.unicode.org/> 参照)
を記憶したり、操作したりできます。また、 Unicode オブジェクトは
既存の文字列オブジェクトとよく統合していて、必要に応じた自動変換機能を
提供しています。

Unicode には、古今のテキストで使われているあらゆる書き文字のあらゆる
文字について、対応付けを行うための一つの序数を規定しているという利点が
あります。 これまでは、書き文字のために利用可能な序数は 256
個しかなく、テキストは
書き文字の対応付けを行っているコードページに束縛されているのが通常
でした。 このことは、とりわけソフトウェアの国際化 (通常 `i18n' -- `i' +
18 文字 + `n' の意) に対して大きな 混乱をもたらしました。Unicode
では、すべての書き文字に対して単一の
コードページを定義することで、これらの問題を解決しています。

Python では、Unicode 文字列の作成は通常の文字列を作成するのと
同じように単純なものです:

     >>> u'Hello World !'
     u'Hello World !'

クオートの前にある小文字の `u' は、Unicode 文字列を生成
することになっていることを示します。文字列に特殊な文字を
含めたければ、Python の _Unicode-Escape_ エンコーディングを
使って行えます。以下はその方法を示しています:

     >>> u'Hello\u0020World !'
     u'Hello World !'

エスケープシーケンス `\u0020' は、序数の値 0x0020 を持つ Unicode 文字
(スペース文字) を、指定場所に挿入することを示します。

他の文字は、それぞれの序数値をそのまま Unicode の序数値に用いて
解釈されます。多くの西洋諸国で使われている標準 Latin-1 エンコーディング
のリテラル文字列があれば、Unicode の下位 256 文字が Latin-1 の 256
文字と同じになっていて便利だと思うことでしょう。

上級者のために、通常の文字列の場合と同じく raw モードもあります。
これには、文字列を開始するクオート文字の前に 'ur' を付けて、 Python に
_Raw-Unicode-Escape_ エンコーディングを使わせ
なければなりません。このモードでは、上記の `\uXXXX' の
変換は機能、小文字の 'u' の前に奇数個のバックスラッシュがあるときにだけ
適用されます。

     >>> ur'Hello\u0020World !'
     u'Hello World !'
     >>> ur'Hello\\u0020World !'
     u'Hello\\\\u0020World !'

raw モードは、正規表現を記述する時のように、沢山のバックスラッシュを
入力しなければならないときとても役に立ちます。

これら標準のエンコーディングにとは別に、Python では、既知の
文字エンコーディングに基づいて Unicode 文字列を生成する一連の
手段を提供しています。

組込み関数 `unicode()'  は、 登録されているすべての Unicode codecs
(COder: エンコーダ と DECoder デコーダ)
へのアクセス機能を提供します。codecs が変換できる
エンコーディングには、よく知られているものとして _Latin-1_, _ASCII_,
_UTF-8_ および _UTF-16_ が
あります。後者の二つは可変長のエンコードで、各 Unicode 文字を 1
バイトまたはそれ以上のバイト列に保存します。デフォルトのエンコーディング
は通常 ASCIIに設定されています。ASCIIでは 0 から 127 の範囲の
文字だけを通過させ、それ以外の文字は受理せずエラーを出します。 Unicode
文字列を印字したり、ファイルに書き出したり、 `str()'
で変換すると、デフォルトのエンコーディングを 使った変換が行われます。

     >>> u"abc"
     u'abc'
     >>> u"あいう"
     u'\x82\xa0\x82\xa2\x82\xa4'
     >>> str(u"あいう")
     Traceback (most recent call last):
       File "<stdin>", line 1, in ?
     UnicodeEncodeError: 'ascii' codec can't encode characters in position 0-5:
     ordinal not in range(128)

特定のエンコーディングを使って Unicode 文字列を 8 ビットの文字列に
変換するために、Unicode オブジェクトでは `encode()'
メソッドを提供しています。このメソッドは単一の引数として
エンコーディングの名前をとります。エンコーディング名には
小文字の使用が推奨されています。

     >>> u"あいう".encode('utf-8')
     '\xc2\x82\xc2\xa0\xc2\x82\xc2\xa2\xc2\x82\xc2\xa4'

特定のエンコーディングで書かれているデータがあり、そこから Unicode
文字列を生成したいなら、`unicode()' を使い、 第 2
引数にエンコーディング名を指定します。

     unicode('\xc2\x82\xc2\xa0\xc2\x82\xc2\xa2\xc2\x82\xc2\xa4', 'utf-8')
     u'\x82\xa0\x82\xa2\x82\xa4'


File: python-tut-jp.info,  Node: リスト,  Prev: Unicode 文字列,  Up: Python を電卓として使う

リスト
------

Python は数多くの _複合 (compound)_ データ型を備えており、
別々の値を一まとめにするために使えます。 最も汎用的なデータ型は _リスト
(list) _ で、コンマで区切られた
値からなるリストを各カッコで囲んだものとして書き表されます。
リストの要素をすべて同じ型にする必要はありません。

     >>> a = ['spam', 'eggs', 100, 1234]
     >>> a
     ['spam', 'eggs', 100, 1234]

文字列のインデクスと同じく、リストのインデクスは 0 から開始します。
また、スライス、連結なども行えます:

     >>> a[0]
     'spam'
     >>> a[3]
     1234
     >>> a[-2]
     100
     >>> a[1:-1]
     ['eggs', 100]
     >>> a[:2] + ['bacon', 2*2]
     ['spam', 'eggs', 'bacon', 4]
     >>> 3*a[:3] + ['Boe!']
     ['spam', 'eggs', 100, 'spam', 'eggs', 100, 'spam', 'eggs', 100, 'Boe!']

_変化不可能 (immutable)_ な文字列型と違い、
リストは個々の要素を変更することができます。

     >>> a
     ['spam', 'eggs', 100, 1234]
     >>> a[2] = a[2] + 23
     >>> a
     ['spam', 'eggs', 123, 1234]

スライスに代入することもできます。スライスの代入を行って、
リストのサイズを変更することさえできます。

     >>> # いくつかの項目を置換する:
     ... a[0:2] = [1, 12]
     >>> a
     [1, 12, 123, 1234]
     >>> # いくつかの項目を除去する:
     ... a[0:2] = []
     >>> a
     [123, 1234]
     >>> # いくつかの項目を挿入する:
     ... a[1:1] = ['bletch', 'xyzzy']
     >>> a
     [123, 'bletch', 'xyzzy', 1234]
     >>> a[:0] = a     # それ自身 (のコピー) を先頭に挿入する
     >>> a
     [123, 'bletch', 'xyzzy', 1234, 123, 'bletch', 'xyzzy', 1234]

組込み関数 `len()' はリストにも適用できます。

     >>> len(a)
     8

リストを入れ子にする (ほかのリストを含むリストを造る) ことも可能です。
例えば、

     >>> q = [2, 3]
     >>> p = [1, q, 4]
     >>> len(p)
     3
     >>> p[1]
     [2, 3]
     >>> p[1][0]
     2
     >>> p[1].append('xtra')     # 5.1節を参照
     >>> p
     [1, [2, 3, 'xtra'], 4]
     >>> q
     [2, 3, 'xtra']

最後の例では、 `p[1]' と `q' が実際には同一のオブジェクトを
参照していることに注意してください!　 _オブジェクトの意味付け
(semantics)_ については、後ほど触れることに します。


File: python-tut-jp.info,  Node: プログラミングへの第一歩,  Prev: Python を電卓として使う,  Up: 形式ばらない Python の紹介

プログラミングへの第一歩
========================

もちろん、2 たす 2 よりももっと複雑な仕事にも Python を使うことが
できます。_Fibonacci_ 級数列の先頭の部分列は次のようにして
書くことができます:

     >>> # Fibonacci 級数:
     ... # 二つの要素の和が次の要素を定義する
     ... a, b = 0, 1
     >>> while b < 10:
     ...       print b
     ...       a, b = b, a+b
     ...
     1
     1
     2
     3
     5
     8

上の例では、いくつか新しい機能を取り入れています。

   * 最初の行には _複数同時の代入 (multiple assignment)_ が入っています:
     変数 `a' と `b' は、それぞれ同時に新しい値 0 と 1 に
     なっています。この代入は最後の行でも再度使われており、代入が
     行われる前に右辺の式がまず評価されます。右辺の式は左から右へと
     順番に評価されます。

   * `while' は、条件 (ここでは `b < 10') が真である限り 実行を繰り返し
     (ループし) ます。Python では、C 言語と同様に、ゼロでない
     整数値は真となり、ゼロは偽です。条件式は文字列値やリスト値、
     実際には任意の配列型でもかまいません。例中で使われている条件テスト
     は単なる比較です。標準的な比較演算子は C 言語と同様です: すなわち、
     `<' (より小さい)、 `>' (より大きい)、 `==' (等しい)、 `<='
     (より小さいか等しい)、 `>=' (より大きいか等しい)、 および `!='
     (等しくない) 、 です。

   * ループの_本体 (body)_ は_インデント (indent, 字下げ)_
     されています: インデントは Python
     において実行文をグループにまとめる 方法です。Python は (いまだに!)
     賢い入力行編集機能を提供していないので、
     インデントされた各行を入力するにはタブや (複数個の) スペースを
     使わなければなりません。実際には、Python
     へのより複雑な入力を準備する
     にはテキストエディタを使うことになるでしょう; ほとんどのテキスト
     エディタは自動インデント機能を持っています。
     複合文を対話的に入力するときには、(パーザはいつ最後の行を入力
     したのか推し量ることができないので)
     入力の完了を示すために最後に空行を
     続けなければなりません。基本ブロックの各行は同じだけインデントされて
     いなければならないので注意してください。

   * `print' は指定した (1 つまたは複数の) 式の値を書き出します。
     `print' は、(電卓の例でしたように) 単に値を出力したい式を書くの
     とは、複数の式や文字列を扱う方法が違います。
     文字列は引用符無しで出力され、複数の要素の間にはスペースが挿入されるので、
     以下のように出力をうまく書式化できます。

          >>> i = 256*256
          >>> print 'The value of i is', i
          The value of i is 65536

     末尾にコンマを入れると、出力を行った後に改行されません:

          >>> a, b = 0, 1
          >>> while b < 1000:
          ...     print b,
          ...     a, b = b, a+b
          ...
          1 1 2 3 5 8 13 21 34 55 89 144 233 377 610 987

     インタプリタは、最後に入力した行がまだ完全な文になっていない場合、
     改行をはさんで次のプロンプトを出力することに注意してください。



File: python-tut-jp.info,  Node: その他の制御フローツール,  Next: データ構造,  Prev: 形式ばらない Python の紹介,  Up: Top

その他の制御フローツール
************************

今しがた紹介した `while' 文の他に、Python では他の言語で
おなじみの普通の制御フロー文を備えていますが、これらには多少
ひねりを加えてあります。

* Menu:

* if 文::
* for 文::
* range 関数::
* break 文と continue 文と ループの else 節::
* pass 文::
* 関数を定義する::
* 関数定義についてもう少し::


File: python-tut-jp.info,  Node: if 文,  Next: for 文,  Prev: その他の制御フローツール,  Up: その他の制御フローツール

`if' 文
=======

おそらく最もおなじみの文型は `if' 文でしょう。 例えば、

     >>> x = int(raw_input("Please enter an integer: "))
     >>> if x < 0:
     ...      x = 0
     ...      print 'Negative changed to zero'
     ... elif x == 0:
     ...      print 'Zero'
     ... elif x == 1:
     ...      print 'Single'
     ... else:
     ...      print 'More'
     ...

`elif' 部はゼロ個またはそれ以上にできます。 `else'
部を付けることもできます。 キーワード ``elif'' は `else if'
を短くしたもので、 過剰なインデントを避けるのに役立ちます。 一連の `if'
... `elif' ... `elif' ...  は、他の言語における _switch_ 文や _case_
文の代用と なります。


File: python-tut-jp.info,  Node: for 文,  Next: range 関数,  Prev: if 文,  Up: その他の制御フローツール

`for' 文
========

Python の `for'  文は、読者が C 言語や Pascal 言語
で使いなれているかもしれない `for' 文とは少し違います。 (Pascal
のように) 常に算術型の数列にわたる反復を行ったり、 (C のように)
繰返しステップと停止条件を両方ともユーザが定義できるように
するのとは違い、Python の `for'  文は、任意の 配列型
(リストまたは文字列) にわたって反復を行います。反復の順番は
配列中に要素が現れる順番です。 (for example というしゃれではないけれど)
例えば 、

     >>> # いくつかの文字列の長さを測る:
     ... a = ['cat', 'window', 'defenestrate']
     >>> for x in a:
     ...     print x, len(x)
     ...
     cat 3
     window 6
     defenestrate 12

反復操作の対象になっている配列をループので書き換える操作
(リストのような、変更可能 (mutable) な配列型でおきます) は、安全
ではありません。もし反復処理を行う対象とするリスト型を変更したいのなら、
(対象の要素を複製するなどして) コピーに対して反復を行わなければ
なりません。この操作にはスライス表記を使うと特に便利です:

     >>> for x in a[:]: # リスト全体のスライス・コピーを作る
     ...    if len(x) > 6: a.insert(0, x)
     ...
     >>> a
     ['defenestrate', 'cat', 'window', 'defenestrate']


File: python-tut-jp.info,  Node: range 関数,  Next: break 文と continue 文と ループの else 節,  Prev: for 文,  Up: その他の制御フローツール

`range()' 関数
==============

数列にわたって反復を行う必要がある場合、組み込み関数 `range()'
が便利です。この関数は算術型の数列が入ったリストを生成します。

     >>> range(10)
     [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]

指定した終端値は生成されるリストには入りません。 `range(10)' は 10
個の値からなるリストを生成し、 ちょうど長さ 10
の配列における各項目のインデクスとなります。 range
を別の数から開始したり、他の増加量 (負の増加量でさえも; 増加量は時に
`ステップ(step)' と呼ばれることもあります) を指定する こともできます:

     >>> range(5, 10)
     [5, 6, 7, 8, 9]
     >>> range(0, 10, 3)
     [0, 3, 6, 9]
     >>> range(-10, -100, -30)
     [-10, -40, -70]

ある配列にわたってインデクスで反復を行うには、 `range()' と `len()'
を次のように組み合わせます:

     >>> a = ['Mary', 'had', 'a', 'little', 'lamb']
     >>> for i in range(len(a)):
     ...     print i, a[i]
     ...
     0 Mary
     1 had
     2 a
     3 little
     4 lamb


File: python-tut-jp.info,  Node: break 文と continue 文と ループの else 節,  Next: pass 文,  Prev: range 関数,  Up: その他の制御フローツール

`break' 文と `continue' 文と ループの `else' 節
===============================================

`break' 文は、C 言語と同じく、最も内側の `for' または `while'
ループを中断します。

`continue' 文は、これもまた C 言語から借りてきたものですが、
ループを次の反復処理に飛ばします。

ループ文は `else' 節を持つことができます; `else' 節は、 (`for' で)
反復処理対象のリストを使い切ってループが終了したとき、 または (`while'
で) 条件が偽になったときに実行されますが、 `break'
文でループが終了したときは実行されません。
この動作を、素数を探す下記のループを例にとって示します:

     >>> for n in range(2, 10):
     ...     for x in range(2, n):
     ...         if n % x == 0:
     ...            print n, 'equals', x, '*', n/x
     ...            break
     ...     else:
     ...          # 因数が見つからずにループが終了
     ...          print n, 'is a prime number'
     ...
     2 is a prime number
     3 is a prime number
     4 equals 2 * 2
     5 is a prime number
     6 equals 2 * 3
     7 is a prime number
     8 equals 2 * 4
     9 equals 3 * 3


File: python-tut-jp.info,  Node: pass 文,  Next: 関数を定義する,  Prev: break 文と continue 文と ループの else 節,  Up: その他の制御フローツール

`pass' 文
=========

`pass' 文は何もしません。`pass' は、文を書くことが
構文上要求されているが、プログラム上何の動作もする必要がない時に
使われます。

     >>> while True:
     ...       pass # キーボード割り込み (keyboard interrupt) をbusy-wait で待つ
     ...

