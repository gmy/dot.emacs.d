This is python-lib-jp.info, produced by makeinfo version 4.5 from
python-lib-jp.texi.

12 October 2005


File: python-lib-jp.info,  Node: strftime の振る舞い,  Prev: tzinfo オブジェクト,  Up: datetime

`strftime()' の振る舞い
-----------------------

`date'、 `datetime'、および `time'
オブジェクトは全て、明示的な書式化文字列でコントロールして
時刻表現文字列を生成するための `strftime(FORMAT)' メソッドを
サポートしています。大雑把にいうと、`d.strftime(fmt)' は `time'
モジュールの `time.strftime(fmt, d.timetuple())'
のように動作します。ただし全てのオブジェクトが `timetuple()'
メソッドをサポートしているわけではありません。

`time' オブジェクトでは、年、月、日の値がないため、それらの
書式化コードを使うことができません。無理矢理使った場合、 年は `1900'
に置き換えられ、月と日は `0' に置き換え られます。

`date' オブジェクトでは、時、分、秒の値がないため、
それらの書式化コードを使うことができません。無理矢理使った場合、
これらの値は `0' に置き換えられます。

naive オブジェクトでは、書式化コード `%z' および `%Z'
は空文字列に置き換えられます。

aware オブジェクトでは以下のようになります:

   * `%z' `utcoffset()' は +HHMM あるいは -HHMM の形式をもった 5
     文字の文字列に変換されます。HH は UTC オフセット時間を与える 2
     桁の文字列で、MM は UTC オフセット分を与える 2 桁の文字列です。
     例えば、`utcoffset()' が `timedelta(hours=-3, minutes=-30)'
     を返した場合、`%z' は文字列 `'-0330'' に置き換わります。

   * `%Z' `tzname()' が `None' を返した場合、`%Z' は
     空文字列に置き換わります。そうでない場合、`%Z' は返された
     値に置き換わりますが、これは文字列でなければなりません。

Python はプラットフォームの C ライブラリから `strftime()'
関数を呼び出し、プラットフォーム間のバリエーションはよくあることなので、
サポートされている書式化コードの全セットはプラットフォーム間で異なります。
Python の `time' モジュールのドキュメントでは、C 標準 (1989 年版)
が要求する書式化コードをリストしており、これらのコードは 標準 C
準拠の実装がなされたプラットフォームでは全て動作します。 1999 年版の C
標準では書式化コードが追加されているので注意してください。

`strftime()' が正しく動作する年の厳密な範囲はプラットフォーム
間で異なります。プラットフォームに関わらず、1900 年以前の年は
使うことができません。


File: python-lib-jp.info,  Node: time,  Next: sched,  Prev: datetime,  Up: 汎用オペレーティングシステムサービス

時刻データへのアクセスと変換
============================

時刻データへのアクセスと変換

このモジュールでは、時刻に関するさまざまな関数を提供します。ほとんどの
関数が利用可能ですが、全ての関数が全てのプラットフォームで利用可能な
わけではありません。
このモジュールで定義されているほとんどの関数は、プラットフォーム上の
同名の C ライブラリ関数を呼び出します。これらの関数に対する意味付け
はプラットフォーム間で異なるため、プラットフォーム提供のドキュメント
を読んでおくと便利でしょう。

まずいくつかの用語の説明と慣習について整理します。

   * "エポック"("epoch")  は、
     時刻の計測がはじまった時点のことです。その年の 1 月 1 日の午前 0
     時に "エポックからの経過時間" が 0
     になるように設定されます。UNIXでは エポックは 1970
     年です。エポックがどうなっているかを知るには、 `gmtime(0)'
     の値を見るとよいでしょう。

   *
     このモジュールの中の関数は、エポック以前あるいは遠い未来の日付や時刻を
     扱うことができません。将来カットオフ（関数が正しく日付や時刻を扱えなく
     なる）が起きる時点は、C ライブラリによって決まります。
     UNIXではカットオフは通常 2038 です。

   * *2000年問題 (Y2K)*: Python はプラットフォームの C
     ライブラリに依存して います。C
     ライブラリは日付および時刻をエポックからの経過秒で表現する
     ので、一般的に 2000 年問題を持ちません。
     時刻を表現する`struct_time'（下記を参照してください）を入力として受け取る関数
     は一般的に 4
     桁表記の西暦年を要求します。以前のバージョンとの互換性の
     ために、モジュール変数 `accept2dyear' がゼロでない整数の場合、 2
     桁の西暦年をサポートします。この変数の初期値は環境変数 `PYTHONY2K'
     が空文字列のとき `1' に設定されます。空文字列
     でない文字列が設定されている場合、`0' に設定されます。こうして、
     `PYTHONY2K' を空文字列でない文字列に設定することで、西暦年の入力が
     すべて 4 桁の西暦年でなければならないようにすることができます。
     2桁の西暦年が入力された場合には、POSIX または X/Open
     標準に従って変換 されます: 69-99 の西暦年は 1969-1999 となり、0-68
     の西暦年は 2000-2068 に なります。100-1899
     は常に不正な値になります。この仕様は Python 1.5.2(a2)
     から新たに追加された機能であることに注意してください;
     それ以前のバージョン、すなわち Python 1.5.1 および 1.5.2a1
     では、1900 以下の年に対して 1900 を足します。

   * UTC  は協定世界時 (Coordinated Universal Time) のことです

     (以前はグリニッジ標準時  または GMTとして知られていました)。 UTC の
     頭文字の並びは誤りではなく、英仏の妥協によるものです。

   * DST は夏時間 (Daylight Saving Time)  のことで、一年のうち部分的に
     1 時間 タイムゾーンを修正することです。DST のルールは不可思議で
     (局所的な法律 で定められています)、年ごとに変わることもあります。
     C ライブラリはローカルルールを記したテーブルを持っており
     (柔軟に対応
     するため、たいていはシステムファイルから読み込まれます)、この点に関して
     は唯一の真実の知識の源です。

   * 多くの現時刻を返す関数 (real-time functions)
     の精度は、値や引数を表現
     するのに使う単位から想像されるよりも低いかも知れません。
     例えば、ほとんどの UNIX システムで、クロックの一刹那 (ticks) の
     精度は 1 秒 の 50 から 100 分の 1 に過ぎません。また、Mac
     では時刻は 秒きっかりのとき以外正確ではありません。

   * 反対に、`time()' および `sleep()' は UNIX の
     同等の関数よりましな精度を持っています: 時刻は浮動小数点で表され、
     `time()' は可能なかぎり最も正確な時刻を (UNIX の `gettimeofday()'
     があればそれを使って) 返します。また `sleep()'
     にはゼロでない端数を与えることができます (UNIX の `select()'
     があれば、それを使って実装しています)。

   * `gmtime()'、`localtime()'、`strptime()' が返す時刻値、 および
     `asctime()'、`mktime()'、 `strftime()' に与える時刻値はどちらも 9
     つの整数からなる 配列です。

     Index                  Attribute              Values
     ------                 -----                  -----
     0                      `tm_year'              (例えば 1993)
     1                      `tm_mon'               [1,12] の間の数
     2                      `tm_mday'              [1,31] の間の数
     3                      `tm_hour'              [0,23] の間の数
     4                      `tm_min'               [0,59] の間の数
     5                      `tm_sec'               [0,61] の間の数
                                                   `strftime()'
                                                   の説明にある *(1)*
                                                   を読んで下さい
     6                      `tm_wday'              [0,6]
                                                   の間の数、月曜が 0
                                                   になります
     7                      `tm_yday'              [1,366] の間の数
     8                      `tm_isdst'             0, 1 または -1;
                                                   以下を参照してください

     C の構造体と違って、月の値が 0-11 でなく 1-12
     であることに注意してくだ さい。西暦年の値は上の "2000年問題 (Y2K)
     " で述べたように扱われます。 夏時間フラグを `-1' にして `mktime()'
     に渡すと、たいてい は正確な夏時間の状態を実現します。

     `struct_time' を引数とする関数に正しくない長さの`struct_time'や
     要素の型が正しくない`struct_time'を与えた場合には、`TypeError'
     が送出されます。

     _Changed in Python version 2.2_

このモジュールでは以下の関数とデータ型を定義します:

`accept2dyear'
     2
     桁の西暦年を使えるかを指定するブール型の値です。標準では真ですが、
     環境変数 `PYTHONY2K' が空文字列でない値に設定されている場合には
     偽になります。実行時に変更することもできます。

`altzone'
     ローカルの夏時間タイムゾーンにおける UTC
     からの時刻オフセットで、西に 行くほど増加する秒で表した値です
     (ほとんどの西ヨーロッパでは負になり、
     アメリカでは正、イギリスではゼロになります) 。 `daylight'
     がゼロでないときのみ使用してください。

`asctime([t])'
     `gmtime()' や `localtime()' が返す時刻を表現する タプル又は
     `struct_time'を、`'Sun Jun 20 23:21:05 1993'' といった書式の 24
     文字 の文字列に変換します。T が与えられていない場合には、
     `localtime()' が返す現在の時刻が使われます。 `asctime()'
     はロケール情報を使いません。 _Note:_ 同名の C
     の関数と違って、末尾には改行文字はありません。 _Changed in Python
     version 2.1_

`clock()'
     UNIXでは、現在のプロセッサ時間秒を浮動小数点数で返します。
     時刻の精度および "プロセッサ時間 (processor time)"
     の定義そのものは同じ 名前の C
     関数に依存します。いずれにせよ、この関数は Python の ベンチマーク
     Python や 計時アルゴリズムに使われています。

     Windows では、最初にこの関数が呼び出されてからの経過時間を
     wall-clock 秒で返します。この関数は Win32 関数
     `QueryPerformanceCounter()' に基づいていて、その精度 は通常 1
     マイクロ秒以下です。

`ctime([secs])'
     エポックからの経過秒数で表現された時刻を、ローカルの時刻を表現
     する文字列に変換します。SECS が与えられていない場合、 `time()'
     が返す値が現在の時刻として使われます。 `ctime(SECS)' は
     `asctime(localtime(SECS))' と同じです。`ctime()'
     はロケール情報を使いません。 _Changed in Python version 2.1_

`daylight'
     DST タイムゾーンが定義されている場合ゼロでない値になります。

`gmtime([secs])'
     エポックからの経過時間で表現された時刻を、UTC における`struct_time'
     に変換します。このとき dst フラグは常にゼロとして扱われます。 SECS
     が与えられていない場合、`time()' が返す値が
     現在の時刻として使われます。秒の端数は無視されます。`struct_time'
     のレイアウトについては上を参照してください。 _Changed in Python
     version 2.1_

`localtime([secs])'
     `gmtime()' に似ていますが、ローカルタイムに変換します。
     現在の時刻に DST が適用される場合、 dst フラグは `1' に設定
     されます。 _Changed in Python version 2.1_

`mktime(t)'
     `localtime()' の逆を行う関数です。引数は `struct_time'か 完全な 9
     つの要素 全てに値の入ったタプル (dst フラグも必要です;
     現在の時刻に DST が 適用されるか不明の場合には `-1'
     を使ってください) で、 UTC ではなく _ローカルの_ 時刻を指定します。
     `time()' との互換性のために浮動小数点数の値を返します。
     入力の値が正しい時刻で表現できない場合、例外`OverflowError' または
     `ValueError' が送出されます (どちらが送出されるかは Python および
     その下にある C ライブラリのどちらにとって無効な値が
     入力されたかで決まります) 。この関数で生成できる最も昔の時刻値は
     プラットフォームに依存します。

`sleep(secs)'
     与えられた秒数の間実行を停止します。より精度の高い実行停止時間を指定
     するために、引数は浮動小数点にしてもかまいません。何らかのシステム
     シグナルがキャッチされた場合、それに続いてシグナル処理ルーチンが実行
     され、 `sleep()' を停止してしまいます。従って実際の実行停止
     時間は要求した時間よりも短くなるかもしれません。また、システムが
     他の処理をスケジューリングするために、実行停止時間が要求した時間よりも
     多少長い時間になることもあります。

`strftime(format[, t])'
     `gmtime()' や `localtime()' が返す時刻値タプル
     又は`struct_time'を、 FORMAT で指定した文字列形式に変換します。 T
     が与えられていない場合、`localtime()' が返す
     現在の時刻が使われます。FORMAT は文字列でなくてはなりません。
     _Changed in Python version 2.1_

     FORMAT 文字列には以下の指示語 (directive) を埋め込むことが
     できます。これらはフィールド長や精度のオプションを付けずに表され、
     `strftime()' の結果の対応する文字列と入れ替えられます:

     Directive              Meaning                Notes
     ------                 -----                  -----
     %a                     ロケールにおける省略形の曜日名。
     %A                     ロケールにおける省略なしの曜日名。
     %b                     ロケールにおける省略形の月名。
     %B                     ロケールにおける省略なしの月名。
     %c                     ロケールにおける適切な日付および時刻表現。
     %d                     月の始めから何日目かを表す
                            10 進数 [01,31]。      
     %H                     (24 時間計での)        
                            時を表す 10 進数       
                            [00,23]。              
     %I                     (12 時間計での)        
                            時を表す 10 進数       
                            [01,12]。              
     %j                     年の初めから何日目かを表す
                            10 進数 [001,366]。    
     %m                     月を表す 10 進数       
                            [01,12]。              
     %M                     分を表す 10 進数       
                            [00,59]。              
     %p                     ロケールにおける AM    
                            または PM              
                            に対応する文字列。     
     %S                     秒を表す 10 進数       (1)
                            [00,61]。              
     %U                     年の初めから何週目か   (2)
                            (日曜を週の始まりとします)を表す
                            10 進数                
                            [00,53]。年が明けてから最初の日曜日までの全ての
                            曜日は 0               
                            週目に属すると見なされます。
     %w                     曜日を表す 10 進数     
                            [0(日曜日),6]。        
     %W                     年の初めから何週目か   (2)
                            (日曜を週の始まりとします)を表す
                            10 進数                
                            [00,53]。年が明けてから最初の月曜日までの全ての
                            曜日は 0               
                            週目に属すると見なされます。
     %x                     ロケールにおける適切な日付の表現。
     %X                     ロケールにおける適切な時刻の表現。
     %y                     上 2                   
                            桁なしの西暦年を表す   
                            10 進数 [00,99]。      
     %Y                     上 2                   
                            桁付きの西暦年を表す   
                            10 進数。              
     %Z                     タイムゾーンの名前     
                            (タイムゾーンがない場合には空文字列)。
     %%                     文字 `%' 自体の表現。  

     注意:

    `(1)'
          値の幅は間違いなく `0' to `61' です; これはうるう秒と、
          （ごく稀ですが）2 重のうるう秒のためのものです。

    `(2)'
          `strptime()' 関数で使う場合、`%U' および `%W'
          を計算に使うのは曜日と年を指定したときだけです。

     以下に RFC 2822 インターネット電子メール標準で定義されている日付
     表現と互換の書式の例を示します。 (1)

          >>> from time import gmtime, strftime
          >>> strftime("%a, %d %b %Y %H:%M:%S +0000", gmtime())
          'Thu, 28 Jun 2001 14:17:15 +0000'

     いくつかのプラットフォームではさらにいくつかの指示語がサポートされて
     いますが、標準 ANSI C で意味のある値はここで列挙したものだけです。

     いくつかのプラットフォームでは、フィールドの幅や精度を指定する
     オプションが以下のように指示語の先頭の文字 `%' の直後に
     付けられるようになっていました; この機能も移植性はありません。
     フィールドの幅は通常 2 ですが、`%j' は例外で 3 です。

`strptime(string[, format])'
     時刻を表現する文字列をフォーマットに従って解釈します。返される値は
     `gmtime()' や `localtime()' が返すような`struct_time' です。FORMAT
     パラメタは `strftime()' で使うものと 同じ指示語を使います;
     このパラメタの値はデフォルトでは `"%a %b %d %H:%M:%S %Y"'
     で、`ctime()' が 返すフォーマットに一致します。 STRING が FORMAT
     に従って解釈できなかった場合、 例外 `ValueError' が送出されます。
     解析しようとする文字列が解析後に余分なデータを持っていた場合、
     `ValueError' が送出されます。欠落したデータはデフォルトの
     値で埋められ、その値は `(1900, 1, 1, 0, 0, 0, 0, 1, -1)' です。

     `%Z' 指示語へのサポートは `tzname' に収められている値と `daylight'
     が真かどうかで決められます。このため、常に既知の
     (かつ夏時間でないと考えられている) UTC や GMT を認識する時意外は
     プラットフォーム固有の動作になります。

`struct_time'
     `gmtime()'、`localtime()' および `strptime()'
     が返す時刻値配列のタイプです。 _Added in Python version 2.2_

`time()'
     時刻を浮動小数点数で返します。単位は UTC
     におけるエポックからの秒数です。
     時刻は常に浮動小数点で返されますが、全てのシステムが 1
     秒より高い精度で
     時刻を提供するとは限らないので注意してください。この関数が返す値は通常
     減少していくことはありませんが、この関数を 2
     回呼び出し、呼び出しの間に
     システムクロックの時刻を巻き戻して設定した場合には、以前の呼び出しよりも
     低い値が返ることもあります。

`timezone'
     (DST でない) ローカルタイムゾーンの UTC
     からの時刻オフセットで、西に 行くほど増加する秒で表した値です
     (ほとんどの西ヨーロッパでは負になり、
     アメリカでは正、イギリスではゼロになります) 。

`tzname'
     二つの文字列からなるタプルです。最初の要素は DST でないローカルの
     タイムゾーン名です。ふたつめの要素は DST のタイムゾーンです。 DST
     のタイムゾーンが定義されていない場合。二つ目の文字列を使うべきでは
     ありません。

`tzset()'
     ライブラリで使われている時刻変換規則をリセットします。
     どのように行われるかは、環境変数 `TZ' で指定されます。 _Added in
     Python version 2.3_

     利用できるシステム: UNIX。

     _Notice:_ 多くの場合、環境変数 `TZ' を変更すると、`tzset' を
     呼ばない限り `localtime' のような関数の出力に影響を
     及ぼすため、値が信頼できなくなってしまいます。

     `TZ' 環境変数には空白文字を含めてはなりません。

     環境変数 `TZ' の標準的な書式は以下です:
     (分かりやすいように空白を入れています)
        * std offset [dst [offset [,start[/time], end[/time]]]]

     各値は以下のようになっています:

        * std and dst
          三文字またはそれ以上の英数字で、タイムゾーンの略称を与えます。
          この値は time.tzname になります。

        * offset オフセットは形式: +- hh[:mm[:ss]] をとります。
          この表現は、UTC 時刻にするためにローカルな時間に加算する必要の
          ある時間値を示します。'-' が先頭につく場合、そのタイムゾーンは
          本子午線 (Prime Meridian) より東側にあります; それ以外の場合は
          本子午線の西側です。オフセットが dst の後ろに続かない場合、
          夏時間は標準時より一時間先行しているものと仮定します。

        * start[/time ,end[/time]] いつ DST に移動し、DST
          から戻ってくるかを示します。開始および終了
          日時の形式は以下のいずれかです:

             * JN ユリウス日 (Julian day) N (1 <= N <= 365) を表します。
               うるう日は計算に含められないため、2 月 28 日は常に 59
               で、 3 月 1 日は 60 になります。

             * N ゼロから始まるユリウス日 (0 <= N <= 365)
               です。うるう日は 計算に含められるため、2 月 29
               日を参照することができます。

             * MM.N.D M 月の第 N 週における D 番目の日 (0 <= D <= 6, 1
               <= N <= 5,  1 <= M <= 12) を表します。週 5
               は月における最終週の D 番目の日を表し、 第 4 週か第 5
               週のどちらかになります。週 1 は日 D が最初に
               現れる日を指します。日 0 は日曜日です。

          時間はオフセットと同じで、先頭に符号 ('-' や '+')
          を付けてはいけない
          ところが違います。時刻が指定されていなければ、デフォルトの値
          02:00:00 になります。

          >>> os.environ['TZ'] = 'EST+05EDT,M4.1.0,M10.5.0'
          >>> time.tzset()
          >>> time.strftime('%X %x %Z')
          '02:07:36 05/08/03 EDT'
          >>> os.environ['TZ'] = 'AEST-10AEDT-11,M10.5.0,M3.5.0'
          >>> time.tzset()
          >>> time.strftime('%X %x %Z')
          '16:08:12 05/08/03 AEST'

     多くの Unix システム (*BSD, Linux, Solaris, および Darwin を含む)
     では、システムの zoneinfo  (`tzfile(5)') データベース
     を使ったほうが、タイムゾーンごとの規則を指定する上で便利です。
     これを行うには、必要なタイムゾーンデータファイルへのパスを
     システムの 'zoneinfo' タイムゾーンデータベースからの相対で表した値
     を環境変数 `TZ' に設定します。システムの 'zoneinfo' は
     通常`/usr/share/zoneinfo' にあります。例えば、 `'US/Eastern''、
     `'Australia/Melbourne''、 `'Egypt'' ないし `'Europe/Amsterdam''
     と指定します。

          >>> os.environ['TZ'] = 'US/Eastern'
          >>> time.tzset()
          >>> time.tzname
          ('EST', 'EDT')
          >>> os.environ['TZ'] = 'Egypt'
          >>> time.tzset()
          >>> time.tzname
          ('EET', 'EEST')


See also:
     *Note locale:: 国際化サービス。ロケールの設定は `time'
     モジュールのいくつかの関数が返す値に影響をおよぼすことがあります。
     *Note calendar:: 一般的なカレンダー関連の関数。   `timegm()'
     はこのモジュールの `gmtime()' の逆の操作を行います。

---------- Footnotes ----------

(1)  現在では `%Z' の利用は推奨されていません。しかし
ここで実現したい時間及び分オフセットへの展開を行ってくれる `%Z'
エスケープは全ての ANSI C
ライブラリでサポートされているわけではありません。 また、オリジナルの
1982 年に提出された RFC 822 標準は西暦年の表現を 2 桁
と要求しています(%Y でなく%y )。しかし実際には 2000 年になるだいぶ
以前から 4 桁の西暦年表現に移行しています。4 桁の西暦年表現は RFC 2822
に おいて義務付けられ、伴って RFC 822 での取り決めは撤廃されました。


File: python-lib-jp.info,  Node: sched,  Next: mutex,  Prev: time,  Up: 汎用オペレーティングシステムサービス

イベントスケジューラ
====================

一般的な目的のためのイベントスケジューラ

`sched'モジュールは一般的な目的のためのイベントスケジューラを
実装するクラスを定義します:

`scheduler(timefunc, delayfunc)'
     `scheduler'クラスはイベントをスケジュールするための一般的な
     インターフェースを定義します。それは"外部世界"を実際に扱うための
     2つの関数を必要とします -- TIMEFUNCは引数なしで呼出し可能で
     あるべきで、そして数(それは"time"です, どんな単位でもかまいません)
     を返すようにします。DELAYFUNCは1つの引数(TIMEFUNCの出力
     と互換)で呼出し可能であり、その時間だけ遅延しなければいけません。
     各々のイベントが、マルチスレッドアプリケーションの中で他のスレッドが
     実行する機会の許可を実行した後に、DELAYFUNCは引数`0'で呼
     ばれるでしょう。

例:

     >>> import sched, time
     >>> s=sched.scheduler(time.time, time.sleep)
     >>> def print_time(): print "From print_time", time.time()
     ...
     >>> def print_some_times():
     ...     print time.time()
     ...     s.enter(5, 1, print_time, ())
     ...     s.enter(10, 1, print_time, ())
     ...     s.run()
     ...     print time.time()
     ...
     >>> print_some_times()
     930343690.257
     From print_time 930343695.274
     From print_time 930343700.273
     930343700.276

* Menu:

* スケジューラオブジェクト::


File: python-lib-jp.info,  Node: スケジューラオブジェクト,  Prev: sched,  Up: sched

スケジューラオブジェクト
------------------------

`scheduler'インスタンスは以下のメソッドを持っています:

`enterabs(time, priority, action, argument)'
     新しいイベントをスケジュールします。引数TIMEは、
     コンストラクタへ渡されたTIMEFUNCの戻り値と互換な数値型で
     なければいけません。 同じTIMEによってスケジュールされたイベントは、
     それらのPRIORITYによって実行されるでしょう。

     イベントを実行することは、`ACTION(*ARGUMENT)'を
     実行することを意味します。
     ARGUMENTはACTIONのためのパラメータを保持するシーケンスで
     なければいけません。

     戻り値は、イベントのキャンセル後に使われるかもしれないイベントです
     (`cancel()'を見よ)。

`enter(delay, priority, action, argument)'
     時間単位以上のDELAYでイベントをスケジュールします。
     そのとき、その他の関連時間、その他の引数、効果、戻り値は、
     `enterabs()'に対するものと同じです。

`cancel(event)'
     キューからイベントを消去します。
     もしEVENTがキューにある現在のイベントでないならば、
     このメソッドは`RuntimeError'を送出します。

`empty()'
     もしイベントキューが空ならば、Trueを返します。

`run()'
     すべてのスケジュールされたイベントを実行します。
     この関数は次のイベントを(コンストラクタへ渡された関数
     `delayfunc'を使うことで)待ち、そしてそれを実行し、
     イベントがスケジュールされなくなるまで同じことを繰り返します。

     ACTIONあるいはDELAYFUNCは例外を投げることができます。
     いずれの場合も、スケジューラは一貫した状態を維持し、例外を伝播するでしょう。
     例外がACTIONによって投げられる場合、イベントは`run()'への
     呼出しを未来に行なわないでしょう。

     イベントのシーケンスが、次イベントの前に、利用可能時間より実行時間が長いと、
     スケジューラは単に遅れることになるでしょう。
     イベントが落ちることはありません;
     呼出しコードはもはや適切でないキャンセルイベントに対して責任があります。


File: python-lib-jp.info,  Node: mutex,  Next: getpass,  Prev: sched,  Up: 汎用オペレーティングシステムサービス

排他制御
========

排他制御のためのロックとキュー

`mutex' モジュールでは、ロック (lock) の獲得と解除によって
排他制御を可能にするクラスを定義しています。
排他制御はスレッドやマルチタスクを使う上で便利かもしれませんが、
このクラスがそうした機能を必要として (いたり、想定して) いるわけでは
ありません。

`mutex'モジュールでは以下のクラスを定義しています:

`mutex()'
     新しい (ロックされてない) mutex を作ります。

     mutex には 2 つの状態変数 -- "ロック" ビット (locked bit) と
     キュー (queue) があります。 mutex
     がロックされていなければ、キューは空です。
     それ以外の場合、キューは空になっているか、 `(FUNCTION, ARGUMENT)'
     のペアが一つ以上入っています。
     このペアはロックを獲得しようと待機している関数 (またはメソッド)
     を表しています。 キューが空でないときに mutex
     をロック解除すると、キューの先頭の
     エントリをキューから除去し、そのエントリのペアに基づいて
     `FUNCTION(ARGUMENT)' を呼び出します。
     これによって、先頭にあったエントリが新たなロックを獲得します。

     当然のことながらマルチスレッドの制御には利用できません -
     というのも、 `lock()' が、ロックを獲得したら関数を呼び出すという
     変なインタフェースだからです。

* Menu:

* mutex オブジェクト::


File: python-lib-jp.info,  Node: mutex オブジェクト,  Prev: mutex,  Up: mutex

mutex オブジェクト
------------------

`mutex' には以下のメソッドがあります:

`test()'
     mutex がロックされているかどうか調べます。

`testandset()'
     「原子的 (Atomic)」な Test-and-Set 操作です。
     ロックがセットされていなければ獲得して `True' を返します。
     それ以外の場合には`False'を返します。

`lock(function, argument)'
     mutex がロックされていなければ `FUNCTION(ARGUMENT)' を実行します。
     mutex がロックされている場合、関数とその引数をキューに置きます。
     キューに置かれた `FUNCTION(ARGUMENT)' がいつ実行
     されるかについては`unlock'を参照してください。

`unlock()'
     キューが空ならば mutex をロック解除します。
     そうでなければ、キューの最初の要素を実行します。


File: python-lib-jp.info,  Node: getpass,  Next: curses,  Prev: mutex,  Up: 汎用オペレーティングシステムサービス

可搬性のあるパスワード入力機構
==============================

ポータブルなパスワードとユーザーIDの検索

The `getpass' module provides two functions:
getpassモジュールは二つの機能を提供します:

`getpass([prompt])'
     エコーなしでユーザーにパスワードを入力させるプロンプト。
     ユーザーはPROMPTの文字列をプロンプトに使えます、
     デフォルトは`'Password:''です。

     利用できるシステム: Machintosh, Unix, Windows


`getuser()'
     ユーザーの "ログイン名"を返します。 　有効性:UNIX、Windows

     この関数は環境変数`LOGNAME' `USER' `LNAME'
     `USERNAME'の順序でチェックして、最初の空ではない文字列が設定された値を返します。
     もし、なにも設定されていない場合はpwdモジュールが提供するシステム上のパスワードデータベースから返します。それ以外は、例外が上がります。



File: python-lib-jp.info,  Node: curses,  Next: cursestextpad,  Prev: getpass,  Up: 汎用オペレーティングシステムサービス

文字セル表示のための端末操作
============================

可搬性のある端末操作を提供する curses ライブラリへの インタフェース．

_Changed in Python version 1.6_

`curses' モジュールは、可搬性のある端末操作を行うための
デファクトスタンダードである、curses ライブラリへのインタフェースを
提供します。

UNIX 環境では curses は非常に広く用いられていますが、DOS、OS2、
そしておそらく他のシステムのバージョンも利用することができます。
この拡張モジュールは Linux および BSD 系の UNIXで動作する
オープンソースの curses ライブラリである ncurses の API に
合致するように設計されています。

See also:
     *Note cursesascii:: ロケール設定に関わらず ASCII 文字を
     扱うためのユーティリティ。 *Note cursespanel:: curses
     ウィンドウにデプス機能を追加する パネルスタック拡張。 *Note
     cursestextpad:: `Emacs' ライクなキーバインディング
     をサポートする編集可能な curses 用テキストウィジェット。 *Note
     curseswrapper:: アプリケーションの起動時および終了時に
     適切な端末のセットアップとリセットを確実に行うための関数。 `Curses
     Programming with Python'{Andrew Kuchling および Eric Raymond
     によって書かれた、curses を Python
     で使うためのチュートリアルです。 Python Web サイトで入手できます。}
     Python ソースコードの `Demo/curses/' ディレクトリには、
     このモジュールで提供されている curses
     バインディングを使ったプログラム 例がいくつか収められています。

* Menu:

* 関数 2::
* Window オブジェクト::
* 定数::


File: python-lib-jp.info,  Node: 関数 2,  Next: Window オブジェクト,  Prev: curses,  Up: curses

関数
----

`curses' モジュールでは以下の例外を定義しています:

`error'
     curses ライブラリ関数がエラーを返した際に送出される例外です。

_Note:_ 関数やメソッドにおけるオプションの引数 X および Y
がある場合、標準の値は常に現在のカーソルになります。 オプションの ATTR
がある場合、標準の値は `A_NORMAL' です。

`curses' では以下の関数を定義しています:

`baudrate()'
     端末の出力速度をビット／秒で返します。ソフトウェア端末エミュレータ
     の場合、これは固定の高い値を持つことになります。この関数は
     歴史的な理由で入れられています; かつては、この関数は時間遅延を
     生成するための出力ループを書くために用いられたり、行速度
     に応じてインタフェースを切り替えたりするために用いられたり
     していました。

`beep()'
     注意を促す短い音を鳴らします。

`can_change_color()'
     端末に表示される色をプログラマが変更できるか否かによって、
     真または偽を返します。

`cbreak()'
     cbreak モードに入ります。cbreak モード ("rare" モードと呼ばれる
     こともあります) では、通常の tty 行バッファリングはオフにされ、
     文字を一文字一文字読むことができます。ただし、raw
     モードとは異なり、 特殊文字
     (割り込み:interrupt、終了:quit、一時停止:suspend、および
     フロー制御) については、tty ドライバおよび呼び出し側のプログラムに
     対する通常の効果をもっています。まず `raw()' を呼び出し、 次いで
     `cbreak()' を呼び出すと、端末を cbreak モード にします。

`color_content(color_number)'
     色 COLOR_NUMBER の赤、緑、および青 (RGB) 要素の強度を返します。
     COLOR_NUMBER は `0' から `COLORS' の間でなければ
     なりません。与えられた色の R、G、B、の値からなる三要素のタプルが
     返されます。この値は `0' (その成分はない) から `1000'
     (その成分の最大強度) の範囲をとります。

`color_pair(color_number)'
     指定された色の表示テキストにおける属性値を返します。 属性値は
     `A_STANDOUT'、 `A_REVERSE'、 およびその他の `A_*'
     属性と組み合わせられています。 `pair_number()' はこの関数の逆です。

`curs_set(visibility)'
     カーソルの状態を設定します。VISIBILITY は 0、1、または 2 に
     設定され、それぞれ不可視、通常、または非常に可視、を意味します。
     要求された可視属性を端末がサポートしている場合、以前のカーソル
     状態が返されます;
     そうでなければ例外が送出されます。多くの端末では、 "可視 (通常)"
     モードは下線カーソルで、"非常に可視" モードは
     ブロックカーソルです。

`def_prog_mode()'
     現在の端末属性を、稼動中のプログラムが curses
     を使う際のモードである "プログラム"
     モードとして保存します。(このモードの反対は、プログラム が curses
     を使わない "シェル" モードです。) その後 `reset_prog_mode()'
     を呼ぶとこのモードを復旧します。

`def_shell_mode()'
     現在の端末属性を、稼動中のプログラムが curses
     を使っていないときのモード である "シェル"
     モードとして保存します。(このモードの反対は、 プログラムが curses
     機能を利用している "プログラム" モードです。) その後
     `reset_shell_mode()' を呼ぶとこのモードを復旧します。

`delay_output(ms)'
     出力に MS ミリ秒の一時停止を入れます。

`doupdate()'
     物理スクリーン (physical screen) を更新します。curses
     ライブラリは、
     現在の物理スクリーンの内容と、次の状態として要求されている仮想スクリーン
     をそれぞれ表す、2 つのデータ構造を保持しています。`doupdate()'
     は更新を適用し、物理スクリーンを仮想スクリーンに一致させます。

     仮想スクリーンは `addstr()' のような書き込み操作をウィンドウに
     行った後に `noutrefresh()' を呼び出して更新することができます。
     通常の `refresh()' 呼び出しは、単に `noutrefresh()' を呼んだ後に
     `doupdate()' を呼ぶだけです; 複数のウィンドウを
     更新しなければならない場合、全てのウィンドウに対して
     `noutrefresh()' を呼び出した後、一度だけ `doupdate()'
     を呼ぶことで、パフォーマンスを向上させることができ、おそらくスクリーン
     のちらつきも押さえることができます。

`echo()'
     echo モードに入ります。 echo モードでは、各文字入力はスクリーン上に
     入力された通りにエコーバックされます。

`endwin()'
     ライブラリの非初期化を行い、端末を通常の状態に戻します。

`erasechar()'
     ユーザの現在の消去文字 (erase character) 設定を返します。 UNIX
     オペレーティングシステムでは、この値は curses プログラムが
     制御している端末の属性であり、curses ライブラリ自体では設定
     されません。

`filter()'
     `filter()' ルーチンを使う場合、`initscr()' を
     呼ぶ前に呼び出さなくてはなりません。この手順のもたらす効果は以下の
     通りです: まず二つの関数の呼び出しの間は、LINES は 1
     に設定されます; clear、cup、cud、cud1、cuu1、cuu、vpa
     は無効化されます; home 文字列 は cr
     の値に設定されます。これにより、カーソルは現在の行に制限される
     ので、スクリーンの更新も同様に制限されます。
     この関数は、スクリーンの他の部分に影響を及ぼさずに文字単位の行編集を
     行う場合に利用できます。

`flash()'
     スクリーンをフラッシュ(flash) します。すなわち、画面を色反転
     (reverse-video) にして、短時間でもとにもどします。人によっては、
     `beep()' で生成される可聴な注意音よりも、このような
     "可視ベル(visible bell)" を好みます。

`flushinp()'
     全ての入力バッファをフラッシュします。この関数は、ユーザによって
     すでに入力されているが、まだプログラムによって処理されていない
     全ての先行入力文字 (typeahead) を捨て去ります。

`getmouse()'
     `getch()' が `KEY_MOUSE' を返してマウスイベントを
     通知した後、この関数を呼んで待ち行列 (queue) 上に置かれている
     マウスイベントを取得しなければなりません。イベントは `(ID, X, Y,
     Z, BSTATE)' の 5 要素のタプルで表現されています。 ID
     は複数のデバイスを区別するための ID 値で、 X、 Y、Z
     はイベントの座標値です (現在 Z は使われていません)。 BSTATE
     は整数値で、
     その各ビットはイベントのタイプを示す値に設定されています。
     この値は以下に示す定数のうち一つまたはそれ以上のビット単位 OR
     になっています。以下の定数のN は 1 から 4 のボタン番号を 示します:
     `BUTTONN_PRESSED', `BUTTONN_RELEASED', `BUTTONN_CLICKED',
     `BUTTONN_DOUBLE_CLICKED', `BUTTONN_TRIPLE_CLICKED', `BUTTON_SHIFT',
     `BUTTON_CTRL', `BUTTON_ALT'.

`getsyx()'
     仮想スクリーンにおける現在のカーソル位置を y および x
     の順で返します。 leaveok が真に設定されていれば、 -1、-1
     が返されます。

`getwin(file)'
     以前の `putwin()' 呼び出しでファイルに保存されている、
     ウィンドウ関連データを読み出します。次に、このルーチンは
     そのデータを使って新たなウィンドウを生成し初期化して、
     その新規ウィンドウオブジェクトを返します。

`has_colors()'
     端末が色表示を行える場合には真を返します。そうでない場合には偽を
     返します。

`has_ic()'
     端末が文字の挿入／削除機能を持つ場合に真を返します。
     この関数は、最近の端末エミュレータがどれもこの機能を持っているのと同じく、
     歴史的な理由だけのために含められています。

`has_il()'
     端末が行の挿入／削除機能を持つか、領域単位のスクロールによって
     機能をシミュレートできる場合に真を返します。
     この関数は、最近の端末エミュレータがどれもこの機能を持っているのと同じく、
     歴史的な理由だけのために含められています。

`has_key(ch)'
     キー値 CH をとり、現在の端末タイプがその値のキーを認識できる
     場合に真を返します。

`halfdelay(tenths)'
     半遅延モード、すなわち cbreak モードに似た、ユーザが打鍵した文字
     がすぐにプログラムで利用できるようになるモードで使われます。
     しかしながら、何も入力されなかった場合、 TENTHS 十秒後に
     例外が送出されます。TENTHS の値は 1 から 255 の間でなければ
     なりません。半遅延モードから抜けるには `nocbreak()' を使います。

`init_color(color_number, r, g, b)'
     色の定義を変更します。変更したい色番号と、その後に 3 つ組みの RGB
     値 (赤、緑、青の成分の大きさ) をとります。COLOR_NUMBER の値は `0'
     から `COLORS' の間でなければなりません。 R、G、B の値は `0' から
     `1000' の 間でなければなりません。 `init_color()' を使うと、
     スクリーン上でカラーが使用されている部分は全て新しい設定に
     即時変更されます。この関数はほとんどの端末で何も行いません;
     `can_change_color()' が `1' を返す場合にのみ 動作します。

`init_pair(pair_number, fg, bg)'
     色ペアの定義を変更します。3 つの引数: 変更したい色ペア、前景色の
     色番号、背景色の色番号、をとります。PAIR_NUMBER は `1' から
     `COLOR_PAIRS -1' の間でなければなりません (`0'
     色ペアは黒色背景に白色前景となるように設定されており、
     変更することができません) 。FG および BG 引数は `0' と `COLORS'
     の間でなければなりません。
     色ペアが以前に初期化されていれば、スクリーンを更新して、指定
     された色ペアの部分を新たな設定に変更します。

`initscr()'
     ライブラリを初期化します。スクリーン全体をあらわす `WindowObject'
     を返します。_Note:_ 端末のオープン時にエラーが発生した場合、curses
     ライブラリ によってインタープリタが終了される場合があります。

`isendwin()'
     `endwin()' がすでに呼び出されている (すなわち、curses ライブラリ
     が非初期化されてしまっている) 場合に真を返します。

`keyname(k)'
     K に番号付けされているキーの名前を返します。印字可能な ASCII
     文字を生成するキーの名前はそのキーの文字自体になります。
     コントロールキーと組み合わせたキーの名前は、キャレットの後に対応する
     ASCII 文字が続く 2 文字の文字列になります。Alt キーと組み合わせた
     キー (128-255) の名前は、先頭に `M-' が付き、その後に対応する
     ASCII 文字が続く文字列になります。

`killchar()'
     ユーザの現在の行削除文字を返します。 UNIX
     オペレーティングシステムでは、この値は curses プログラムが
     制御している端末の属性であり、curses ライブラリ自体では設定
     されません。

`longname()'
     現在の端末について記述している terminfo の長形式 name フィールドが
     入った文字列を返します。verbose 形式記述の最大長は 128 文字です。
     この値は `initscr()' 呼び出しの後でのみ定義されています。

`meta(yes)'
     YES が 1 の場合、8 ビット文字を入力として許します。YES が 0
     の場合、 7 ビット文字だけを許します。

`mouseinterval(interval)'
     ボタンが押されてから離されるまでの時間をマウスクリック一回として認識
     する最大の時間間隔を設定します。以前の内部設定値を返します。
     標準の値は 200 ミリ秒、または 5 分の 1 秒です。

`mousemask(mousemask)'
     報告すべきマウスイベントを設定し、`(AVAILMASK, OLDMASK)'
     の組からなるタプルを返します。 AVAILMASK
     はどの指定されたマウスイベントのどれが報告されるかを 示します;
     どのイベント指定も完全に失敗した場合には 0 が返ります。 OLDMASK
     は与えられたウィンドウの以前のマウスイベントマスク
     です。この関数が呼ばれない限り、マウスイベントは何も報告されません。

`napms(ms)'
     MS ミリ秒スリープします。

`newpad(nlines, ncols)'
     与えられた行とカラム数を持つパッド (pad) データ構造を生成し、その
     ポインタを返します。パッドはウィンドウオブジェクトとして返されます。

     パッドはウィンドウと同じようなものですが、スクリーンのサイズによる
     制限をうけず、スクリーンの特定の部分に関連付けられていなくても
     かまいません。大きなウィンドウが必要であり、スクリーンにはその
     ウィンドウの一部しか一度に表示しない場合に使えます。
     (スクロールや入力エコーなどによる)
     パッドに対する再描画は起こりません。 パッドに対する `refresh()'
     および `noutrefresh()' メソッド
     は、パッド中の表示する部分と表示するために利用するスクリーン上の位置を
     指定する 6 つの引数が必要です。これらの引数は pminrow、 pmincol、
     sminrow、 smincol、 smaxrow、smaxcol です; p
     で始まる引数はパッド中の表示領域の左上位置で、s で始まる引数は
     パッド領域を表示するスクリーン上のクリップ矩形を指定します。

`newwin([nlines, ncols,] begin_y, begin_x)'
     左上の角が `(BEGIN_Y, BEGIN_X)' で、高さ／幅が NLINES/NCOLS
     の新規ウィンドウを返します。

     標準では、ウィンドウは指定された位置からスクリーンの右下まで
     広がります。

`nl()'
     newlime モードに入ります。このモードはリターンキーを入力中の改行
     として変換し、出力時に改行文字を復帰 (return) と改行 (line-feed)
     に変換 します。newline モードは初期化時にはオンになっています。

`nocbreak()'
     cbreak モードから離れます。行バッファリングを行う通常の "cooked"
     モードに戻ります。

`noecho()'
     echo モードから離れます。入力のエコーバックはオフにされます。

`nonl()'
     newline モードから離れます。入力時のリターンキーから改行への変換、
     および出力時の改行から復帰／改行への低レベル変換を無効化します
     (ただし、`addch('\n')' の振る舞いは変更せず、仮想スクリーン
     上では常に復帰と改行に等しくなります)。変換をオフにすることで、
     curses は水平方向の動きを少しだけ高速化できることがあります;
     また、入力中のリターンキーの検出ができるようになります。

`noqiflush()'
     noquiflush ルーチンを使うと、通常行われている INTR、QUIT、および
     SUSP 文字による入力および出力キューのフラッシュが行われなく
     なります。シグナルハンドラが終了した際、割り込みが発生しなかった
     かのように出力を続たい場合、ハンドラ中で `noqiflush()'
     を呼び出すことができます。

`noraw()'
     raw モードから離れます。行バッファリングを行う通常の "cooked"
     モードに戻ります。

`pair_content(pair_number)'
     要求された色ペア中の色を含む `(FG, BG)' からなる
     タプルを返します。PAIR_NUMBER は `0' から ``COLOR_PAIRS' - 1'
     の間でなければなりません。

`pair_number(attr)'
     ATTR に対する色ペアセットの番号を返します。`color_pair()'
     はこの関数の逆に相当します。

`putp(string)'
     `tputs(str, 1, putchar)' と等価です; 現在の端末における、
     指定された terminfo 機能の値を出力します。putp の出力は常に標準
     出力に送られるので注意して下さい。

`qiflush( [flag] )'
     FLAG が偽なら、`noqiflush()' を呼ぶのとと同じ効果です。 FLAG
     が真か、引数が与えられていない場合、制御文字が読み出された
     最にキューはフラッシュされます。

`raw()'
     raw モードに入ります。raw モードでは、通常の行バッファリングと
     割り込み (interrupt)、終了 (quit)、一時停止 (suspend)、および
     フロー制御キーはオフになります; 文字は curses 入力関数に一文字
     づつ渡されます。

`reset_prog_mode()'
     端末を "program" モードに復旧し、予め `def_prog_mode()'
     で保存した内容に戻します。

`reset_shell_mode()'
     端末を "shell" モードに復旧し、予め `def_shell_mode()'
     で保存した内容に戻します。

`setsyx(y, x)'
     仮想スクリーンカーソルを Y、X に設定します。 Y および X が共に -1
     の場合、leaveok が設定されます。

`setupterm([termstr, fd])'
     端末を初期化します。TERMSTR は文字列で、端末の名前を与えます;
     省略された場合、TERM 環境変数の値が使われます。FD は
     初期化シーケンスが送られる先のファイル記述子です; FD
     を与えない場合、`sys.stdout' のファイル記述子が使われます。

`start_color()'
     プログラマがカラーを利用したい場合で、かつ他の何らかのカラー操作
     ルーチンを呼び出す前に呼び出さなくてはなりません。 この関数は
     `initscr()' を呼んだ直後に呼ぶようにしておくと よいでしょう。

     `start_color()' は 8 つの基本色 (黒、赤、緑、黄、青、マゼンタ、
     シアン、および白)
     と、色数の最大値と端末がサポートする色ペアの最大数
     が入っている、`curses' モジュールにおける二つのグローバル変数、
     `COLORS' および `COLOR_PAIRS' を初期化します。
     この関数はまた、色設定を端末のスイッチが入れられたときの状態に
     戻します。

`termattrs()'
     端末がサポートする全てのビデオ属性を論理和した値を返します。
     この情報は、curses プログラムがスクリーンの見え方を
     完全に制御する必要がある場合に便利です。

`termname()'
     14 文字以下になるように切り詰められた環境変数 TERM の値を返します。

`tigetflag(capname)'
     terminfo 機能名 CAPNAME に対応する機能値をブール値で返します。
     CAPNAME がブール値で表される機能値でない場合 `-1'
     が返され、機能がキャンセルされているか、端末記述上に見つからない
     場合には `0' を返します。

`tigetnum(capname)'
     terminfo 機能名 CAPNAME に対応する機能値を数値で返します。 CAPNAME
     が数値で表される機能値でない場合 `-2'
     が返され、機能がキャンセルされているか、端末記述上に見つからない
     場合には `-1' を返します。

`tigetstr(capname)'
     terminfo 機能名 CAPNAME に対応する機能値を文字列値で返します。
     CAPNAME が文字列値で表される機能値でない場合や、
     機能がキャンセルされているか、端末記述上に見つからない 場合には
     `None' を返します。

`tparm(str[,...])'
     STR を与えられたパラメタを使って文字列にインスタンス化します。 STR
     は terminfo データベースから得られたパラメタを持つ文字列
     でなければなりません。例えば、`tparm(tigetstr("cup"), 5, 3)' は
     `'\033[6;4H'' のようになります。厳密には端末の形式に
     よって異なる結果となります。

`typeahead(fd)'
     先読みチェックに使うためのファイル記述子 FD を指定します。 FD が
     `-1' の場合、先読みチェックは行われません。

     curses ライブラリはスクリーンを更新する間、先読み文字列を定期的に
     検索することで "行はみ出し最適化 (line-breakout optimization)"
     を行います。入力が得られ、かつ入力は端末からのものである場合、現在
     行おうとしている更新は refresh や doupdate を再度呼び出すまで
     先送りにします。この関数は異なるファイル記述子で先読みチェックを
     行うように指定することができます。

`unctrl(ch)'
     CH の印字可能な表現を文字列で返します。制御文字は例えば `^C'
     のようにキャレットに続く文字として表示
     されます。印字可能文字はそのままです。

`ungetch(ch)'
     CH をプッシュして、 `getch()' を次に呼び出したときに
     返されるようにします。_Note:_ `getch()' を呼び出すまでは CH
     は一つしかプッシュできません。

`ungetmouse(id, x, y, z, bstate)'
     与えられた状態データが関連付けられた `KEY_MOUSE' イベントを
     入力キューにプッシュします。

`use_env(flag)'
     この関数を使う場合、`initscr()' または newterm を呼ぶ前に
     呼び出さなくてはなりません。FLAG が偽の場合、環境変数 `LINES'
     および `COLUMNS' の値 (これらは標準の設定で 使われます)
     の値が設定されていたり、curses がウィンドウ内で 動作して (この場合
     `LINES' や `COLUMNS' が設定
     されていないとウィンドウのサイズを使います) いても、terminfo
     データベースに指定された lines および columns の値を使います。

