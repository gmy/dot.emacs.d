This is python-lib-jp.info, produced by makeinfo version 4.5 from
python-lib-jp.texi.

12 October 2005


File: python-lib-jp.info,  Node: locale,  Next: gettext,  Prev: shutil,  Up: 汎用オペレーティングシステムサービス

国際化サービス
==============

国際化サービス。

`locale' モジュールは POSIX ロケールデータベース
およびロケール関連機能へのアクセスを提供します。 POSIX
ロケール機構を使うことで、プログラマはソフトウェアが
実行される各国における詳細を知らなくても、
アプリケーション上で特定の地域文化に関係する部分を扱うことが できます。

`locale' モジュールは、`_locale' を被うように実装されており、ANSI C
ロケール実装を使っている `_locale'
が利用可能なら、こちらを先に使うようになっています。

`locale' モジュールでは以下の例外と関数を定義しています:

`Error'
     `setlocale()' が失敗したときに送出される例外です。

`setlocale(category[, locale])'
     LOCALE を指定する場合、文字列、 `(LANGUAGE CODE,
     ENCODING)'、からなるタプル、または `None'
     をとることができます。LOCALE がタプルのの場合、
     ロケール別名解決エンジンによって文字列に変換されます。 LOCALE
     が与えられていて、かつ `None' でない場合、 `setlocale()' は
     CATEGORY の設定を変更します。
     変更することのできるカテゴリは以下に列記されており、値は
     ロケール設定の名前です。空の文字列を指定すると、ユーザの環境における
     標準設定になります。 ロケールの変更に失敗した場合、`Error'
     が送出されます。 成功した場合、新たなロケール設定が返されます。

     LOCALE が省略されたり `None' の場合、CATEGORY
     の現在の設定が返されます。

     `setlocale()' はほとんどのシステムでスレッド安全では
     ありません。アプリケーションを書くとき、大抵は以下のコード

          import locale
          locale.setlocale(locale.LC_ALL, '')

     から書き始めます。これは全てのカテゴリをユーザの環境における
     標準設定 (大抵は環境変数 `LANG' で指定されています)
     に設定します。その後複数スレッドを使ってロケールを変更したり
     しない限り、問題は起こらないはずです。

     _Changed in Python version 2.0_

`localeconv()'
     地域的な慣行のデータベースを辞書として返します。辞書は以下の文字列を
     キーとして持っています:

     キー名                 カテゴリ               意味
     ------                 -----                  -----
     LC_NUMERIC             `'decimal_point''      小数点を表す文字です。
                            `'grouping''           `'thousands_sep''
                                                   が来るかもしれない場所を相対的に
                                                   表した数からなる配列です。配列が
                                                   `CHAR_MAX'
                                                   で終端されている
                                                   場合、それ以上の桁では桁数字のグループ化を行いません。配列が
                                                   `0'
                                                   で終端されている場合、最後に指定したグループが反復的に使われます。
                            `'thousands_sep''      桁グループ間を区切るために使われる文字です。
     LC_MONETARY            `'int_curr_symbol''    国際通貨を表現する記号です。
                            `'currency_symbol''    地域的な通貨を表現する記号です。
                            `'mon_decimal_point''  金額表示の際に使われる小数点です。
                            `'mon_thousands_sep''  金額表示の際に桁区切り記号です。
                            `'mon_grouping''       `'grouping''
                                                   と同じで、金額表示の際に使われます。
                            `'positive_sign''      正の値の金額表示に使われる記号です。
                            `'negative_sign''      負の値の金額表示に使われる記号です。
                            `'frac_digits''        金額を地域的な方法で表現する際の小数点以下の桁数です。
                            `'int_frac_digits''    金額を国際的な方法で表現する際の小数点以下の桁数です。

     `'p_sign_posn'' および `'n_sing_posn'' の取り得る値は
     以下の通りです。

     値                                 説明
     ------                             -----
     0                                  通貨記号および値は丸括弧で囲われます。
     1                                  符号は値と通貨記号より前に来ます。
     2                                  符号は値と通貨記号の後に続きます。
     3                                  符号は値の直前に来ます。
     4                                  符号は値の直後に来ます。
     `LC_MAX'                           このロケールでは特に指定しません。


`nl_langinfo(option)'
     ロケール特有の情報を文字列として返します。この関数は全てのシステムで
     利用可能なわけではなく、指定できる OPTION もプラットフォーム
     間で大きく異なります。引数として使えるのは、locale モジュールで利用
     可能なシンボル定数を表す数字です。


`getdefaultlocale([envvars])'
     標準のロケール設定を取得しようと試み、結果をタプル `(LANGUAGE
     CODE, ENCODING)' の形式で 返します。
     POSIXによると、`setlocale(LC_ALL, '')' を呼ばなかった
     プログラムは、移植可能な `'C'' ロケール設定を使います。
     `setlocale(LC_ALL, '')' を呼ぶことで、`LANG' 変数で
     定義された標準のロケール設定を使うようになります。 Python
     では現在のロケール設定に干渉したくないので、上で述べた
     ような方法でその挙動をエミュレーションしています。

     他のプラットフォームとの互換性を維持するために、環境変数 `LANG'
     だけでなく、引数 ENVVARS で指定された環境変数のリスト
     も調べられます。ENVVARS は標準では GNU gettext で使われて
     いるサーチパスになります; パスには必ず変数名 `LANG' が含まれて
     いるからです。GNU gettext サーチパスは `'LANGUAGE''、
     `'LC_ALL''、`'LC_CTYPE''、および `'LANG'' が
     列挙した順番に含まれています。

     `'C'' の場合を除き、言語コードは RFC 1766 に対応します。 LANGUAGE
     CODE および ENCODING が決定できなかった 場合、`None'
     になるかもしれません。

     _Added in Python version 2.0_

`getlocale([category])'
     与えられたロケールカテゴリに対する現在の設定を、 LANGUAGE CODE、
     ENCODING を含む配列で返します。 CATEGORY として `LC_ALL' 以外の
     `LC_*' の 値の一つを指定できます。標準の設定は `LC_CTYPE' です。

     `'C'' の場合を除き、言語コードは RFC 1766 に対応します。 LANGUAGE
     CODE および ENCODING が決定できなかった 場合、`None'
     になるかもしれません。

     _Added in Python version 2.0_

`getpreferredencoding([do_setlocale])'
     テキストデータをエンコードする方法を、ユーザの設定に基づいて
     返します。ユーザの設定は異なるシステム間では異なった方法で
     表現され、システムによってはプログラミング的に得ることができない
     こともあるので、この関数が返すのはただの推測です。

     システムによっては、ユーザの設定を取得するために `setlocale'
     を呼び出す必要があるため、この関数はスレッド安全
     ではありません。`setlocale' を呼び出す必要がない、または
     呼び出したくない場合、DO_SETLOCALE を `False' に
     設定する必要があります。 _Added in Python version 2.3_

`normalize(localename)'
     与えたロケール名を規格化したロケールコードを返します。返される
     ロケールコードは `setlocale()' で使うために書式化されて
     います。規格化が失敗した場合、もとの名前がそのまま返されます。

     与えたエンコードがシステムにとって未知の場合、標準の設定では、
     この関数は `setlocale()' と同様に、エンコーディングを
     ロケールコードにおける標準のエンコーディングに設定します。 _Added
     in Python version 2.0_

`resetlocale([category])'
     CATEGORY のロケールを標準設定にします。

     標準設定は `getdefaultlocale()' を呼ぶことで決定されます。
     CATEGORY は標準で `LC_ALL' になっています。 _Added in Python
     version 2.0_

`strcoll(string1, string2)'
     現在の `LC_COLLATE' 設定に従って二つの文字列を比較します。
     他の比較を行う関数と同じように、STRING1 が STRING2
     に対して前に来るか、後に来るか、あるいは二つが等しいかによって、
     それぞれ負の値、正の値、あるいは `0' を返します。

`strxfrm(string)'
     文字列を組み込み関数 `cmp()'  で
     使える形式に変換し、かつロケールに則した結果を返します。
     この関数は同じ文字列が何度も比較される場合、例えば文字列から
     なる配列を順序付けて並べる際に使うことができます。

`format(format, val[, grouping])'
     数値 VAL を現在の `LC_NUMERIC' の設定に基づいて
     書式化します。書式は `%' 演算子の慣行に従います。浮動小数点
     数については、必要に応じて浮動小数点が変更されます。GROUPING
     が真なら、ロケールに配慮した桁数の区切りが行われます。

`str(float)'
     浮動小数点数を `str(FLOAT)' と同じように書式化しますが、
     ロケールに配慮した小数点が使われます。

`atof(string)'
     文字列を `LC_NUMERIC' で設定された慣行に従って浮動小数点に変換
     します。

`atoi(string)'
     文字列を `LC_NUMERIC' で設定された慣行に従って整数に変換します。

`LC_CTYPE'
     文字タイプ関連の関数のためのロケールカテゴリです。このカテゴリの
     設定に従って、モジュール `string' における関数の振る舞い
     が変わります。

`LC_COLLATE'
     文字列を並べ替えるためのロケールカテゴリです。`locale'
     モジュールの関数 `strcoll()' および `strxfrm()' が 影響を受けます。

`LC_TIME'
     時刻を書式化するためのロケールカテゴリです。`time.strftime()'
     はこのカテゴリに設定されている慣行に従います。

`LC_MONETARY'
     金額に関係する値を書式化するためのロケールカテゴリです。
     設定可能なオプションは関数 `localeconv()' で得ることが できます。

`LC_MESSAGES'
     メッセージ表示のためのロケールカテゴリです。現在 Python は
     アプリケーション毎にロケールに対応したメッセージを出力する
     機能はサポートしていません。`os.strerror()' が
     返すような、オペレーティングシステムによって表示される
     メッセージはこのカテゴリによって影響を受けます。

`LC_NUMERIC'
     数字を書式化するためのロケールカテゴリです。関数 `format()'、
     `atoi()'、 `atof()' および `locale' モジュール の `str()'
     が影響を受けます。他の数値書式化操作は影響を 受けません。

`LC_ALL'
     全てのロケール設定を総合したものです。ロケールを変更する際にこの
     フラグが使われた場合、そのロケールにおける全てのカテゴリを設定
     しようと試みます。一つでも失敗したカテゴリがあった場合、全ての
     カテゴリにおいて設定変更を行いません。このフラグを使ってロケールを
     取得した場合、全てのカテゴリにおける設定を示す文字列が返されます。
     この文字列は、後に設定を元に戻すために使うことができます。

`CHAR_MAX'
     `localeconv()' の返す特別な値のためのシンボル定数です。

関数 `nl_langinfo' は以下のキーのうち一つを受理します。
ほとんどの記述は GNU C ライブラリ中の対応する説明から引用されています。

`CODESET'
     選択されたロケールで用いられている文字エンコーディングの名前を
     文字列で返します。

`D_T_FMT'
     時刻および日付をロケール特有の方法で表現するために、 strftime(3) の
     書式化文字列として用いることのできる文字列を返します。

`D_FMT'
     日付をロケール特有の方法で表現するために、 strftime(3) の
     書式化文字列として用いることのできる文字列を返します。

`T_FMT'
     時刻をロケール特有の方法で表現するために、 strftime(3) の
     書式化文字列として用いることのできる文字列を返します。

`T_FMT_AMPM'
     時刻を 午前／午後の書式で表現するために、 strftime(3) の
     書式化文字列として用いることのできる文字列を返します。 返される値は

`DAY_1 ... DAY_7'
     1 週間中の n 番目の曜日名を返します。_ロケール US における、
     `DAY_1' を日曜日とする慣行に従っています。国際的な (ISO 8601)
     月曜日を週の初めとする慣行ではありません。_

`ABDAY_1 ... ABDAY_7'
     1 週間中の n 番目の曜日名を略式表記で返します。

`MON_1 ... MON_12'
     n 番目の月の名前を返します。

`ABMON_1 ... ABMON_12'
     n 番目の月の名前を略式表記で返します。

`RADIXCHAR'
     基数点 (小数点ドット、あるいは小数点コンマ、等) を返します。

`THOUSEP'
     1000 単位桁区切り (3 桁ごとのグループ化) の区切り文字を返します。

`YESEXPR'
     肯定／否定で答える質問に対する肯定回答を正規表現関数で
     認識するために利用できる正規表現を返します。 _表現は C
     ライブラリの `regex()' 関数 に合ったものでなければならず、これは
     `re' で 使われている構文とは異なるかもしれません。_

`NOEXPR'
     肯定／否定で答える質問に対する否定回答を正規表現関数で
     認識するために利用できる正規表現を返します。

`CRNCYSTR'
     通貨シンボルを返します。シンボルを値の前に表示させる場合には "-"
     、値の後ろに表示させる場合には "+" 、シンボルを基数点と
     置き換える場合には "." を前につけます。

`ERA'
     現在のロケールで使われている年代を表現する値を返します。

     ほとんどのロケールではこの値を定義していません。この値を設定している
     ロケールの例は日本です。日本では、日付の伝統的な表示法に、時の天皇
     に対応する元号名を含めます。

     通常この値を直接指定する必要はありません。`E' を書式化文字列に
     指定することで、関数 `strftime' がこの情報を使うようになります。
     返される文字列の様式は決められていないので、異なるシステム間で様式に
     関する同じ知識が使えると期待してはいけません。

`ERA_YEAR'
     返される値はロケールでの現年代の年値です。

`ERA_D_T_FMT'
     返される値は `strftime' で日付および時間をロケール固有の
     年代に基づいた方法で表現するための書式化文字列として使うことができます。

`ERA_D_FMT'
     返される値は `strftime' で日付をロケール固有の
     年代に基づいた方法で表現するための書式化文字列として使うことができます。

`ALT_DIGITS'
     返される値は 0 から 99 までの 100 個の値の表現です。

例:

     >>> import locale
     >>> loc = locale.getlocale(locale.LC_ALL) # get current locale
     >>> locale.setlocale(locale.LC_ALL, 'de_DE') # use German locale; name might vary with platform
     >>> locale.strcoll('f\xe4n', 'foo') # compare a string containing an umlaut
     >>> locale.setlocale(locale.LC_ALL, '') # use user's preferred locale
     >>> locale.setlocale(locale.LC_ALL, 'C') # use default (C) locale
     >>> locale.setlocale(locale.LC_ALL, loc) # restore saved locale

* Menu:

* ロケールの背景、詳細、ヒント、助言および補足説明::
* Python 拡張の作者と、Python を埋め込むようなプログラムに関して::
* メッセージカタログへのアクセス::


File: python-lib-jp.info,  Node: ロケールの背景、詳細、ヒント、助言および補足説明,  Next: Python 拡張の作者と、Python を埋め込むようなプログラムに関して,  Prev: locale,  Up: locale

ロケールの背景、詳細、ヒント、助言および補足説明
------------------------------------------------

C 標準では、ロケールはプログラム全体にわたる特性であり、その変更は
高価な処理であるとしています。加えて、頻繁にロケールを変更する
ようなひどい実装はコアダンプを引き起こすこともあります。
このことがロケールを正しく利用する上で苦痛となっています。

そもそも、プログラムが起動した際、ロケールはユーザの希望するロケール
にかかわらず `C' です。プログラムは `setlocale(LC_ALL, '')'
を呼び出して、明示的にユーザの希望する
ロケール設定を行わなければなりません。

`setlocale()' をライブラリルーチン内で呼ぶことは、
それがプログラム全体に及ぼす副作用の面から、一般的によくない考えです。
ロケールを保存したり復帰したりするのもよくありません: 高価な処理
であり、ロケールの設定が復帰する以前に起動してしまった他のスレッド
に悪影響を及ぼすからです。

もし、汎用を目的としたモジュールを作っていて、ロケールによって
影響をうけるような操作 (例えば `string.lower()' や `time.strftime()'
の書式の一部) のロケール独立の
バージョンが必要ということになれば、標準ライブラリルーチンを
使わずに何とかしなければなりません。よりましな方法は、ロケール設定が
正しく利用できているか確かめることです。最後の手段は、
あなたのモジュールが `C' ロケール以外の設定には互換性がない
とドキュメントに書くことです。

`string'  モジュールの大小文字の変換を
行う関数はロケール設定によって影響を受けます。`setlocale()'
関数を呼んで `LC_CTYPE' 設定を変更した場合、変数
`string.lowercase'、`string.uppercase' および `string.letters'
は計算しなおされます。 例えば `from string import letters' のように、
``from' ... `import' ...' を使ってこれらの変数を
使っている場合には、それ以降の `setlocale()' の影響を
受けないので注意してください。

ロケールに従って数値操作を行うための唯一の方法はこのモジュールで
特別に定義されている関数: `atof()'、 `atoi()'、 `format()'、 `str()'
を使うことです。


File: python-lib-jp.info,  Node: Python 拡張の作者と、Python を埋め込むようなプログラムに関して,  Next: メッセージカタログへのアクセス,  Prev: ロケールの背景、詳細、ヒント、助言および補足説明,  Up: locale

Python 拡張の作者と、Python を埋め込むようなプログラムに関して
--------------------------------------------------------------

拡張モジュールは、現在のロケールを調べる以外は、決して `setlocale()'
を呼び出してはなりません。
しかし、返される値もロケールの復帰のために使えるだけなので、
さほど便利とはいえません (例外はおそらくロケールが `C' か
どうか調べることでしょう)。

Python があるアプリケーション内に埋め込まれており、アプリケーションが
Python
を初期化する前にロケールを設定した場合は一般的に問題はありません。
このとき Python は設定されているロケールを使います。_ただし_、
`LC_NUMERIC' ロケールは常に `C' に設定されます。

`locale' モジュールの関数 `setlocale()' は、`LC_NUMERIC'
ロケール設定が操作できるような印象を Python プログラマに与えますが、C
のレベルではこれは当てはまりません。 C コードでは、常に `LC_NUMERIC'
ロケール設定は `C'
になります。これは、小数点文字がピリオド以外の別の文字に変更
された場合にうまく動作しなくなるものがあまりにも多い (例えば Python
パーザはうまく動作しません) からです。 補足説明: Python
のグローバルインタプリタをロックしないまま
動作するスレッド間では、数値ロケール設定が一致しなくなることが
あるかもしれません。 このため、`LC_NUMERIC'
ロケールの設定を実装するための
可搬性のある唯一の方法は、数値ロケールをユーザの希望するロケールに
設定して、直接関係のある値を展開し、最後に `C' 数値ロケールを復帰する
ことです。

ロケールを変更するために Python コードで `locale' モジュール
を使った場合、Python を埋め込んでいるアプリケーションにも影響を
及ぼします。Python を埋め込んでいるアプリケーションに影響が及ぶ
ことを望まない場合、`config.c' ファイル内の組み込みモジュールの
テーブルから `_locale' 拡張モジュール  (ここで全てを行っています)
を削除し、共有ライブラリから `_locate' モジュールにアクセス
できないようにしてください。


File: python-lib-jp.info,  Node: メッセージカタログへのアクセス,  Prev: Python 拡張の作者と、Python を埋め込むようなプログラムに関して,  Up: locale

メッセージカタログへのアクセス
------------------------------

C ライブラリの gettext インタフェースが提供されているシステムでは、
locake モジュールでそのインタフェースを公開しています。
このインタフェースは関数 `gettext()'、 `dgettext()'、
`dcgettext()'、`textdomain()'、および `bindtextdomain()' からなります。
これらは `gettext' モジュールの同名の関数に似ていますが、
メッセージカタログとして C ライブラリのバイナリフォーマットを使い、
メッセージカタログを探すために C ライブラリのサーチアルゴリズムを
使います。

Python アプリケーションでは、通常これらの関数を呼び出す必要は
ないはずで、代わりに `gettext' を呼ぶべきです。
例外として知られているのは、内部で `gettext()' または `cdgettext()'
を呼び出すような C ライブラリにリンク
するアプリケーションです。こうしたアプリケーションでは、
ライブラリが正しいメッセージカタログを探せるようにテキスト
ドメイン名を指定する必要があります。


File: python-lib-jp.info,  Node: gettext,  Next: logging,  Prev: locale,  Up: 汎用オペレーティングシステムサービス

多言語対応に関する国際化サービス
================================

多言語対応に関する国際化サービス。

`gettext' モジュールは、 Python によるモジュールや
アプリケーションの国際化 (I18N, I-nternationalizatio-N) および地域化
(L10N, L-ocalizatio-N) サービスを提供します。 このモジュールは GNU
`gettext' メッセージカタログへの API と、 より高レベルで Python
ファイルに適しているクラスに基づいた API の
両方をサポートしてます。以下で述べるインタフェースを使うことで、
モジュールやアプリケーションのメッセージをある自然言語で記述しておき、
翻訳されたメッセージのカタログを与えて他の異なる自然言語の環境下で動作
させることができます。

ここでは Python のモジュールやアプリケーションを地域化する
ためのいくつかのヒントも提供しています。

* Menu:

* GNU gettext API::
* クラスに基づいた API::
* プログラムやモジュールを国際化する::
* 謝辞::


File: python-lib-jp.info,  Node: GNU gettext API,  Next: クラスに基づいた API,  Prev: gettext,  Up: gettext

GNU `gettext' API
-----------------

`gettext' モジュールでは、以下の GNU `gettext' API に 非常に良く似た
API を提供しています。この API を使う場合、
メッセージ翻訳の影響はアプリケーション全体に及ぼすことになります。
アプリケーションが単一の言語しか扱わず、各言語に依存する部分を
ユーザのロケール情報によって選ぶのなら、ほとんどの場合この方法で
やりたいことを実現できます。Python モジュールを地域化していたり、
アプリケーションの実行中に言語を切り替えたい場合、おそらくクラス
に基づいた API を使いたくなるでしょう。

`bindtextdomain(domain[, localedir])'
     DOMAIN をロケール辞書 LOCALEDIR に結び付け (bind) ます。
     具体的には、 `gettext' は与えられたドメインに対する バイナリ形式の
     `.mo' ファイルを、(UNIXでは)
     `LOCALEDIR/LANGUAGE/LC_MESSAGES/DOMAIN.mo' から探します。ここで
     LANGUAGES はそれぞれ環境変数 `LANGUAGE'、`LC_ALL' 、`LC_MESSAGES'、
     および `LANG' の中から検索されます。

     LOCALEDIR が省略されるか `None' の場合、現在 DOMAIN
     に結び付けられている内容が返されます。(1)

`textdomain([domain])'
     現在のグローバルドメインを調べたり変更したりします。 DOMAIN が
     `None' の場合、現在のグローバルドメインが返され
     ます。それ以外の場合にはグローバルドメインは DOMAIN に設定され、
     設定されたグローバルドメインを返します。

`gettext(message)'
     現在のグローバルドメイン、言語、およびロケール辞書に基づいて、
     MESSAGE の特定地域向けの翻訳を返します。通常、
     ローカルな名前空間ではこの関数に `_' という別名をつけます
     (下の例を参照してください)。

`dgettext(domain, message)'
     `gettext()' と同様ですが、指定された DOMAIN から
     メッセージを探します。

`ngettext(singular, plural, n)'
     `gettext()' と同様ですが、複数形の場合を考慮しています。
     翻訳文字列が見つかった場合、N の様式を適用し、
     その結果得られたメッセージを返します (言語によっては二つ以上の
     複数形があります)。 翻訳文字列が見つからなかった場合、 N が 1 なら
     SINGULAR を返します; そうでない場合 PLURAL を返します。

     複数形の様式はカタログのヘッダから取り出されます。様式は C または
     Python の式で、自由な変数 n を持ちます; 式の評価値はカタログ中の
     複数形のインデクスとなります。.po ファイルで用いられる
     詳細な文法と、様々な言語における様式については、GNU gettext
     ドキュメントを参照してください。

     _Added in Python version 2.3_


`dngettext(domain, singular, plural, n)'
     `ngettext()' と同様ですが、指定された DOMAIN から
     メッセージを探します。

     _Added in Python version 2.3_

GNU `gettext' では `dcgettext()' も定義していますが、
このメソッドはあまり有用ではないと思われるので、現在のところ
実装されていません。

以下にこの API の典型的な使用法を示します:

     import gettext
     gettext.bindtextdomain('myapplication', '/path/to/my/language/directory')
     gettext.textdomain('myapplication')
     _ = gettext.gettext
     # ...
     print _('This is a translatable string.')

---------- Footnotes ----------

(1)  標準でロケールが収められているディレクトリはシステム依存です;
例えば、RedHat Linux では `/usr/share/locale' ですが、 Solaris では
`/usr/lib/locale' です。 `gettext'
モジュールはこうしたシステム依存の標準設定をサポートしません;
その代わりに ``sys.prefix'/share/locale' を標準の
設定とします。この理由から、常にアプリケーションの開始時に
絶対パスで明示的に指定して `bindtextdomain()' を呼び出す
のが最良のやり方ということになります。


File: python-lib-jp.info,  Node: クラスに基づいた API,  Next: プログラムやモジュールを国際化する,  Prev: GNU gettext API,  Up: gettext

クラスに基づいた API
--------------------

クラス形式の `gettext' モジュールのAPI は GNU `gettext' API
よりも高い柔軟性と利便性を持っています。 Python
のアプリケーションやモジュールを地域化するにはこちらを使う
方を勧めます。`gettext' では、GNU `.mo' 形式のファイルを 解釈し、標準の
8 ビット文字列または Unicode 文字列形式でメッセージ を返す "翻訳"
クラスを定義しています。
翻訳オブジェクトのインスタンスも組み込み名前空間に関数 `_()'
として組み入れる (install) ことができます。

`find(domain[, localedir[,  languages[, all]]])'
     この関数は標準的な `.mo' ファイル検索アルゴリズムを実装
     しています。`textdomain()' と同じく、DOMAIN を引数に
     とります。オプションの LOCALEDIR は `bindtextdomain()'
     と同じです。またオプションの LANGUAGES は文字列を列挙したリスト
     で、各文字列は言語コードを表します。

     LOCALEDIR が与えられていない場合、標準のシステムロケール
     ディレクトリが使われます。(1)

     LANGUAGES が与えられなかった場合、以下の環境変数:
     `LANGUAGE'、`LC_ALL'、 `LC_MESSAGES'、および `LANG'
     が検索されます。空でない値を返した最初の候補が LANGUAGES
     変数として使われます。
     この環境変数は言語名をコロンで分かち書きしたリストを含んで
     いなければなりません。`find()' はこの文字列をコロンで
     分割し、言語コードの候補リストを生成します。

     `find()' は次に言語コードを展開および正規化し、リストの
     各要素について、以下のパス構成:

     `LOCALEDIR/LANGUAGE/LC_MESSAGES/DOMAIN.mo'

     からなる実在するファイルの探索を反復的に行います。`find()'
     は上記のような実在するファイルで最初に見つかったものを返します。
     該当するファイルが見つからなかった場合、`None' が返されます。 ALL
     が与えられていれば、全ファイル名のリストが言語リストまたは
     環境変数で指定されている順番に並べられたものを返します。

`translation(domain[, localedir[, languages[,  class_,[fallback]]]])'
     `Translations' インスタンスを DOMAIN、LOCALEDIR、および LANGUAGES
     に基づいて 生成して返します。 DOMAIN、LOCALEDIR、および LANGUAGES
     はまず 関連付けられている `.mo' ファイルパスのリストを取得する
     ために`find()' に渡されます。同じ `.mo' ファイル名を
     持つインスタンスはキャッシュされます。実際にインスタンス化される
     クラスは CLASS_ が与えられていればそのクラスが、そうでない 時には
     `GNUTranslations' です。クラスのコンストラクタは
     単一の引数としてファイルオブジェクトを取らなくてはなりません。

     複数のファイルが発見された場合、後で見つかったファイルは前に見つかった
     ファイルの代替でと見なされ、後で見つかった方が利用されます。
     代替の設定を可能にするには、`copy.copy' を使ってキャッシュから
     翻訳オブジェクトを複製します;
     こうすることで、実際のインスタンスデータは
     キャッシュのものと共有されます。

     `.mo' ファイルが見つからなかった場合、FALLBACK が偽
     (標準の設定です) ならこの関数は `IOError' を送出し、 FALLBACK
     が真なら `NullTranslations' インスタンスが 返されます。

`install(domain[, localedir[, unicode]])'
     関数 `translation()' に渡した DOMAIN および LOCALEDIR
     に基づいて、Python の組み込み名前空間に関数 `_' を組み入れます。
     UNICODE フラグは `translation()' の返した翻訳オブジェクト の
     `install' メソッドに渡されます。

     以下に示すように、通常はアプリケーション中の文字列を関数 `_()'
     の呼び出しで包み込んで翻訳対象候補であることを示します:

          print _('This string will be translated.')

     利便性を高めるためには、`_()' 関数を Python の組み込み
     名前空間に組み入れる必要があります。こうすることで、アプリケーション内の
     全てのモジュールからアクセスできるようになります。

* Menu:

* NullTranslations クラス::
* GNUTranslations クラス::
* Solaris メッセージカタログ機構のサポート::
* Catalog コンストラクタ::

---------- Footnotes ----------

(1)  上の `bindtextdomain()' に関する脚注を参照してください。


File: python-lib-jp.info,  Node: NullTranslations クラス,  Next: GNUTranslations クラス,  Prev: クラスに基づいた API,  Up: クラスに基づいた API

`NullTranslations' クラス
.........................

翻訳クラスは、元のソースファイル中のメッセージ文字列から
翻訳されたメッセージ文字列への変換を実際に実装しているクラスです。
全ての翻訳クラスが基底クラスとして用いるクラスが `NullTranslations'
です; このクラスでは独自の特殊な翻訳
クラスを実装するために使うことができる基本的なインタフェースを 以下に
`NullTranslations' のメソッドを示します:

`__init__([fp])'
     オプションのファイルオブジェクト FP を取ります。この引数
     は基底クラスでは無視されます。このメソッドは "保護された
     (protected)" インスタンス変数 _INFO および _CHARSET
     を初期化します。これらの変数の値は導出クラスで設定
     することができます。同様に _FALLBACK も初期化しますが、 この値は
     `add_fallback' で設定されます。その後、 FP が `None' でない場合
     `self._parse(fp)' を 呼び出します。

`_parse(fp)'
     基底クラスでは何もしない (no-op) ようになっています。このメソッド
     の役割はファイルオブジェクト FP を引数に取り、ファイルからデータを
     読み出し、メッセージカタログを初期化することです。サポートされていない
     メッセージカタログ形式を使っている場合、その形式を解釈するためには
     このメソッドを上書きしなくてはなりません。

`add_fallback(fallback)'
     FALLBACK を現在の翻訳オブジェクトの代替オブジェクトとして追加
     します。翻訳オブジェクトが与えられたメッセージに対して翻訳メッセージ
     を提供できない場合、この代替オブジェクトに問い合わせることになります。

`gettext(message)'
     代替オブジェクトが設定されている場合、`gettext' を代替オブジェクト
     に転送します。そうでない場合、翻訳されたメッセージを返します。
     導出クラスで上書きするメソッドです。

`ugettext(message)'
     代替オブジェクトが設定されている場合、`gettext' を代替オブジェクト
     に転送します。そうでない場合、翻訳されたメッセージを Unicode 文字列
     で返します。導出クラスで上書きするメソッドです。

`ngettext(singular, plural, n)'
     代替オブジェクトが設定されている場合、`ngettext' を代替オブジェクト
     に転送します。そうでない場合、翻訳されたメッセージを返します。
     導出クラスで上書きするメソッドです。 _Added in Python version 2.3_

`ungettext(singular, plural, n)'
     代替オブジェクトが設定されている場合、`ungettext'
     を代替オブジェクト
     に転送します。そうでない場合、翻訳されたメッセージを Unicode 文字列
     で返します。導出クラスで上書きするメソッドです。 _Added in Python
     version 2.3_

`info()'
     "保護されている" `_info' 変数を返します。

`charset()'
     "保護されている" `_charset' 変数を返します。

`install([unicode])'
     UNICODE フラグが偽の場合、このメソッドは `self.gettext()'
     を組み込み名前空間に組み入れ、`_' と結び付けます。 UNICODE
     が真の場合、`self.gettext()' の代わりに `self.ugettext()'
     を結び付けます。 標準では UNICODE は偽です。

     この方法はアプリケーションで `_' 関数を利用できるようにする
     ための最も便利な方法ですが、唯一の手段でもあるので注意してください。
     この関数はアプリケーション全体、とりわけ組み込み名前空間に影響する
     ので、地域化されたモジュールで `_' を組み入れることが
     できないのです。その代わりに、以下のコード:

          import gettext
          t = gettext.translation('mymodule', ...)
          _ = t.gettext

     を使って `_' を使えるようにしなければなりません。

     この操作は `_' をモジュール内だけのグローバル名前空間に
     組み入れるので、モジュール内の `_' の呼び出しだけに影響 します。


File: python-lib-jp.info,  Node: GNUTranslations クラス,  Next: Solaris メッセージカタログ機構のサポート,  Prev: NullTranslations クラス,  Up: クラスに基づいた API

`GNUTranslations' クラス
........................

`gettext' モジュールでは `NullTranslations' から
導出されたもう一つのクラス: `GNUTranslations' を提供しています。
このクラスはビッグエンディアン、およびリトルエンディアン両方の
バイナリ形式の GNU `gettext' `.mo' ファイル を読み出せるように
`_parse()' を上書きしています。 また、このクラスはメッセージ id
とメッセージ文字列の両方を Unicode に型強制します。

このクラスではまた、翻訳カタログ以外に、オプションのメタデータ
を読み込んで解釈します。GNU `gettext' では、空の文字列に
対する変換先としてメタデータを取り込むことが慣習になっています。
このメタデータは RFC 822 形式の `key: value' のペアに なっており、
`Project-Id-Version' キーを含んでいなければ なりません。キー
`Content-Type' があった場合、 `charset' の特性値 (property) は
"保護された" `_charset' インスタンス
変数を初期化するために用いられます。値がない場合には、デフォルトと して
`None' が使われます。
エンコードに用いられる文字セットが指定されている場合、カタログから
読み出された全てのメッセージ id とメッセージ文字列は、指定された
エンコードを用いて Unicode に変換されます。`ugettext()' は常に Unicode
を返し、`gettext()' はエンコードされた 8
ビット文字列を返します。どちらのメソッドにおける引数 id の
場合も、Unicode 文字列か US-ASCII 文字のみを含む 8 ビット文字列
だけが受理可能です。国際化されたPython プログラムでは、メソッドの
Unicode 版 (すなわち `ugettext()' や `ungettext()')
の利用が推奨されています。

key/value ペアの集合全体は辞書型データ中に配置され、"保護された"
`_info' インスタンス変数に設定されます。

`.mo' ファイルのマジックナンバーが不正な場合、あるいは
その他の問題がファイルの読み出し中に発生した場合、 `GNUTranslations'
クラスのインスタンス化で `IOError' が送出されることがあります。

以下のメソッドは基底クラスの実装からオーバライドされています:

`gettext(message)'
     カタログから MESSAGE id を検索して、対応するメッセージ文字列を、
     カタログの文字セットが既知のエンコードの場合、エンコードされた 8
     ビット 文字列として返します。MESSAGE id
     に対するエントリがカタログに
     存在せず、フォールバックが設定されている場合、フォールバック
     検索はオブジェクトの `gettext()' メソッドに転送されます。
     そうでない場合、MESSAGE id 自体が返されます。

`ugettext(message)'
     カタログから MESSAGE id を検索して、対応するメッセージ文字列を、
     Unicode でエンコードして返します。MESSAGE id に対するエントリが
     カタログに存在せず、フォールバックが設定されている場合、フォールバック
     検索はオブジェクトの `ugettext()' メソッドに転送されます。
     そうでない場合、MESSAGE id 自体が返されます。

`ngettext(singular, plural, n)'
     メッセージ id に対する複数形を検索します。カタログに対する検索では
     SINGULAR がメッセージ id として用いられ、 N には
     どの複数形を用いるかを指定します。返されるメッセージ文字列は 8
     ビットの文字列で、カタログの文字セットが既知の場合にはその
     文字列セットでエンコードされています。

     メッセージ id がカタログ中に見つからず、フォールバックオブジェクト
     が指定されている場合、メッセージ検索要求はフォールバックオブジェクトの
     `ngettext()' メソッドに転送されます。そうでない場合、 N が 1
     ならば SINGULAR が返され、それ以外に対しては PLURAL が返されます。

     _Added in Python version 2.3_

`ungettext(singular, plural, n)'
     メッセージ id に対する複数形を検索します。カタログに対する検索では
     SINGULAR がメッセージ id として用いられ、 N には
     どの複数形を用いるかを指定します。返されるメッセージ文字列は
     Unicode 文字列です。

     メッセージ id がカタログ中に見つからず、フォールバックオブジェクト
     が指定されている場合、メッセージ検索要求はフォールバックオブジェクトの
     `ungettext()' メソッドに転送されます。そうでない場合、 N が 1
     ならば SINGULAR が返され、それ以外に対しては PLURAL が返されます。

     以下に例を示します。:

          n = len(os.listdir('.'))
          cat = GNUTranslations(somefile)
          message = cat.ungettext(
              'There is %(num)d file in this directory',
              'There are %(num)d files in this directory',
              n) % {'n': n}

     _Added in Python version 2.3_


File: python-lib-jp.info,  Node: Solaris メッセージカタログ機構のサポート,  Next: Catalog コンストラクタ,  Prev: GNUTranslations クラス,  Up: クラスに基づいた API

Solaris メッセージカタログ機構のサポート
........................................

Solaris オペレーティングシステムでは、独自の `.mo'
バイナリファイル形式を定義していますが、この形式に関する
ドキュメントが手に入らないため、現時点ではサポートされていません。


File: python-lib-jp.info,  Node: Catalog コンストラクタ,  Prev: Solaris メッセージカタログ機構のサポート,  Up: クラスに基づいた API

Catalog コンストラクタ
......................

GNOME  では、James Henstridge によるあるバージョンの `gettext'
モジュールを使っていますが、このバージョンは 少し異なった API
を持っています。ドキュメントに書かれている 利用法は:

     import gettext
     cat = gettext.Catalog(domain, localedir)
     _ = cat.gettext
     print _('hello world')

となっています。過去のモジュールとの互換性のために、 `Catalog()'
は前述の `translation()' 関数の別名になっています。

このモジュールと Henstridge のバージョンとの間には一つ相違点が
あります: 彼のカタログオブジェクトはマップ型の API を介した
アクセスがサポートされていましたが、この API は使われていない
らしく、現在はサポートされていません。


File: python-lib-jp.info,  Node: プログラムやモジュールを国際化する,  Next: 謝辞,  Prev: クラスに基づいた API,  Up: gettext

プログラムやモジュールを国際化する
----------------------------------

国際化 (I18N, I-nternationalizatio-N) とは、プログラムを複数の言語に
対応させる操作を指します。地域化 (L10N, L-ocalizatio-N) とは、すでに
国際化されているプログラムを特定地域の言語や文化的な事情に対応させる
ことを指します。Python プログラムに多言語メッセージ機能を追加するには、
以下の手順を踏む必要があります:

  1. プログラムやモジュールで翻訳対象とする文字列に特殊なマークを
     つけて準備します

  2. マークづけをしたファイルに一連のツールを走らせ、生のメッセージ
     カタログを生成します

  3. 特定の言語へのメッセージカタログの翻訳を作成します

  4. メッセージ文字列を適切に変換するために `gettext'
     モジュールを使います

ソースコードを I18N 化する準備として、ファイル内の全ての文字列
を探す必要があります。翻訳を行う必要のある文字列はどれも `_('...')' --
すなわち関数 `_()' の呼び出しで
包むことでマーク付けしなくてはなりません。例えば以下のようにします:

     filename = 'mylog.txt'
     message = _('writing a log message')
     fp = open(filename, 'w')
     fp.write(message)
     fp.close()

この例では、文字列 `'writing a log message'' が翻訳対象候補として
マーク付けされており、文字列 `'mylog.txt'' および `'w'' は
されていません。

Python の配布物には、ソースコードに準備作業を行った後で
メッセージカタログの生成を助ける 2 つのツールが付属します。
これらはバイナリ配布の場合には付属していたりしなかったりしますが、
ソースコード配布には入っており、`Tools/i18n' ディレクトリ にあります。

`pygettext' プログラム (1) は全ての Python
ソースコードを走査し、予め翻訳対象としてマーク
した文字列を探し出します。このツールは GNU `gettext'
プログラムと同様ですが、Python ソースコードの機微について
熟知している反面、C 言語や C++言語のソースコードについては
全く知りません。(C 言語による拡張モジュールのように) C 言語の
コードも翻訳対象にしたいのでない限り、 GNU `gettext' は必要ありません。

`pygettext' は、テキスト形式 Uniforum スタイルによる人間が
判読可能なメッセージカタログ `.pot' ファイル群を生成します。
このファイル群はソースコード中でマークされた全ての文字列と、
それに対応する翻訳文字列のためのプレースホルダを含むファイル
で構成されています。 `pygettext' はコマンドライン形式のスクリプトで、
`xgettext' と同様のコマンドラインインタフェースをサポート します;
使用法についての詳細を見るには:

     pygettext.py --help

を起動してください。

これら `.pot' ファイルのコピーは次に、サポート対象の
各自然言語について、言語ごとのバージョンを作成する個々の人間の
翻訳者に頒布されます。翻訳者たちはプレースホルダ部分を埋めて
言語ごとのバージョンをつくり、`.po' ファイルとして
返します。(`Tools/i18n' ディレクトリ内の) `msgfmt.py'(2)
プログラムを使い、翻訳者から返された `.po' ファイルから 機械可読な
`.mo' バイナリカタログファイルを生成します。 `.mo' ファイルは、
`gettext' モジュールが実行時に 実際の翻訳処理を行うために使われます。

`gettext' モジュールをソースコード中でどのように使うかは
アプリケーション全体を国際化するのか、それとも単一のモジュールを
国際化するのかによります。

* Menu:

* モジュールを地域化する::
* アプリケーションを地域化する::
* 動作中 on the fly に言語を切り替える::
* 翻訳処理の遅延解決::

---------- Footnotes ----------

(1)  同様の作業を行う `xpot' と呼ばれるプログラムを  Franc,ois Pinard
が書いています。このプログラムは 彼の `po-utils' パッケージの一部で、
<http://www.iro.umontreal.ca/contrib/po-utils/HTML/> で入手できます。

(2)  `msgfmt.py' は GNU `msgfmt' とバイナリ互換ですが、
より単純で、Python だけを使った実装がされています。 このプログラムと
`pygettext.py' があれば、通常 Python プログラムを国際化するために GNU
`gettext' パッケージを インストールする必要はありません。


File: python-lib-jp.info,  Node: モジュールを地域化する,  Next: アプリケーションを地域化する,  Prev: プログラムやモジュールを国際化する,  Up: プログラムやモジュールを国際化する

モジュールを地域化する
......................

モジュールを地域化する場合、グローバルな変更、例えば組み込み名前空間
への変更を行わないように注意しなければなりません。GNU `gettext' API
ではなく、クラスベースの API を使うべきです。

仮に対象のモジュール名を "spam" とし、モジュールの各言語における
翻訳が収められた `.mo' ファイルが `/usr/share/locale' に GNU `gettext'
形式で置かれているとします。
この場合、モジュールの最初で以下のようにします:

     import gettext
     t = gettext.translation('spam', '/usr/share/locale')
     _ = t.gettext

翻訳オブジェクトが `.po' ファイル中の Unicode 文字列を返す
ようになっているのなら、上の代わりに以下のようにします:

     import gettext
     t = gettext.translation('spam', '/usr/share/locale')
     _ = t.ugettext


File: python-lib-jp.info,  Node: アプリケーションを地域化する,  Next: 動作中 on the fly に言語を切り替える,  Prev: モジュールを地域化する,  Up: プログラムやモジュールを国際化する

アプリケーションを地域化する
............................

アプリケーションを地域化するのなら、関数 `_()' を
グローバルな組み込み名前空間に組み入れなければならず、これは
通常アプリケーションの主ドライバ (main driver) ファイル で
行います。この操作によって、アプリケーション独自のファイルは
明示的に各ファイルで `_()' の組み入れを行わなくても 単に `_('...')'
を使うだけで済むようになります。

単純な場合では、単に以下の短いコードをアプリケーションの
主ドライバファイルに追加するだけです:

     import gettext
     gettext.install('myapplication')

ロケールディレクトリや UNICODE フラグを設定する必要が
ある場合、それらの値を `install()' 関数に渡すことが できます:

     import gettext
     gettext.install('myapplication', '/usr/share/locale', unicode=1)


File: python-lib-jp.info,  Node: 動作中 on the fly に言語を切り替える,  Next: 翻訳処理の遅延解決,  Prev: アプリケーションを地域化する,  Up: プログラムやモジュールを国際化する

動作中 (on the fly) に言語を切り替える
......................................

多くの言語を同時にサポートする必要がある場合、複数の翻訳インスタンスを
生成して、例えば以下のコード:
     import gettext
     
     lang1 = gettext.translation(languages=['en'])
     lang2 = gettext.translation(languages=['fr'])
     lang3 = gettext.translation(languages=['de'])
     
     # start by using language1
     lang1.install()
     
     # ... time goes by, user selects language 2
     lang2.install()
     
     # ... more time goes by, user selects language 3
     lang3.install()

のように、インスタンスを明示的に切り替えてもかまいません。


File: python-lib-jp.info,  Node: 翻訳処理の遅延解決,  Prev: 動作中 on the fly に言語を切り替える,  Up: プログラムやモジュールを国際化する

翻訳処理の遅延解決
..................

コードを書く上では、ほとんどの状況で文字列はコードされた場所で
翻訳されます。しかし場合によっては、翻訳対象として文字列をマーク
はするが、その後実際に翻訳が行われるように遅延させる必要が
生じます。古典的な例は以下のようなコートです:

     animals = ['mollusk',
                'albatross',
     	   'rat',
     	   'penguin',
     	   'python',
     	   ]
     # ...
     for a in animals:
         print a

ここで、リスト `animals' 内の文字列は翻訳対象としてマーク
はしたいが、文字列が出力されるまで実際に翻訳を行うのは避けたい
とします。

こうした状況を処理する一つの方法を以下に示します:

     def _(message): return message
     
     animals = [_('mollusk'),
                _('albatross'),
     	   _('rat'),
     	   _('penguin'),
     	   _('python'),
     	   ]
     
     del _
     
     # ...
     for a in animals:
         print _(a)

ダミーの `_()' 定義が単に文字列をそのまま返すように
なっているので、上のコードはうまく動作します。かつ、このダミーの
定義は、組み込み名前空間に置かれた `_()' の定義で (`del'
命令を実行するまで) 一時的に上書きすることが できます。もしそれまでに
`_' をローカルな名前空間に 持っていたら注意してください。

二つ目の例における `_()' の使い方では、"a" は文字列
リテラルではないので、`pygettext' プログラムが翻訳可能な
対象として識別しません。

もう一つの処理法は、以下の例のようなやり方です:

     def N_(message): return message
     
     animals = [N_('mollusk'),
                N_('albatross'),
     	   N_('rat'),
     	   N_('penguin'),
     	   N_('python'),
     	   ]
     
     # ...
     for a in animals:
         print _(a)

この例の場合では、翻訳可能な文字列を関数 `N_()' で マーク付けしており
(1) 、`_()' の定義とは全く衝突しません。しかしメッセージ
展開プログラムには翻訳対象の文字列が `N_()' でマーク
されていることを教える必要が出てくるでしょう。 `pygettext' および
`xpot' は両方とも、コマンドライン
上のスイッチでこの機能をサポートしています。

---------- Footnotes ----------

(1)  この `N_()' をどうするかは全くの自由です;
`MarkThisStringForTranslation()'  などとしてもかまいません。


File: python-lib-jp.info,  Node: 謝辞,  Prev: プログラムやモジュールを国際化する,  Up: gettext

謝辞
----

以下の人々が、このモジュールのコード、フィードバック、設計に関する
助言、過去の実装、そして有益な経験談による貢献をしてくれました:

   * Peter Funk

   * James Henstridge

   * Juan David Ib'a~nez Palomar

   * Marc-Andr'e Lemburg

   * Martin von L"owis

   * Franc,ois Pinard

   * Barry Warsaw

