This is python-lib-jp.info, produced by makeinfo version 4.5 from
python-lib-jp.texi.

12 October 2005


File: python-lib-jp.info,  Node: mpz,  Next: rotor,  Prev: sha,  Up: 暗号関連のサービス

GNU 多倍長整数
==============

多倍精度における算術演算を実現する GNU MP ライブラリへのインタフェース。

_This is deprecated in Python 2.2.
この節の末尾にある参考文献を読んで下さい。同様の機能を提供するパッケージについての情報があります。このモジュールは
Python 2.3 で除去されます。_

このモジュールはオプションです。モジュールを含むように設定して Python を
構築した際にのみ利用可能であり、GNU MP ソフトウェアがインストールされて
いることが必要です。

このモジュールは GNU MP ライブラリの一部の機能へのインタフェースを
実装しています。GNU MP ライブラリは多倍精度の整数および有理数
に対する算術演算ルーチンを定義しています。_整数だけの_ インタフェース
(`mpz_*()') が提供されています。 特に注釈のない限り、GNU MP
ドキュメントに記述されている内容が 適用されます。

有理数のサポート  は Python で実装されて います。例えば、Python
ソースコード配布中の `Demos/classes/Rat.py' で提供されている `Rat'
モジュール を参照してください。

一般的に、"mpz" 型の数値は他の標準の Python 数値と同様に使う
ことができます。例えば、`+'、`*'、などといった組み込み演算子
や、`abs()', `int()' ..., `divmod()', `pow()'
といった、標準の組み込み関数を使うことができます。 *注意してください:*
ライブラリには `mpz_xor()' が
なく、私にとっても必要ないので、_ビット単位のxor_ 演算は
_and_、_invert_、_or_ を組み合わせて実装 されています。

mpz 型の数値は `mpz()' を呼び出して生成します (厳密な解説に
ついては下を参照してください)。mpz 型の数値は以下のように印字されます:
`mpz(VALUE)'

`mpz(value)'
     新しい mpz 型数値を生成します。VALUE は通常の整数、長整数、
     その他の mpz 型数値、そして文字列にすることもできます。文字列の
     場合、引数は 256 進数の桁からなるアレイとして解釈され、最下桁
     が前で、値は正の数になります。下で記述されている `binary()'
     を参照してください。

`MPZType'
     `mpz()' およびこのモジュール中の他のほとんどの関数が返す
     オブジェクトの型です。

個のモジュールでは多くの _外部_ 関数が定義されています。 mpz
型でない引数はまず mpz 型の値に変換され、関数は mpz 型の数値
を返します。

`powm(base, exponent, modulus)'
     `pow(BASE, EXPONENT) %{} MODULUS' を返します。 `EXPONENT == 0'
     の場合、`mpz(1)' を返します。 C
     ライブラリ関数とは対照的に、この関数は負の指数を扱うことが
     できます。

`gcd(op1, op2)'
     OP1 および OP2 の最大公約数を返します。

`gcdext(a, b)'
     `A*S + B*T == G == gcd(A, B)' であるようなタプル `(G, S, T)'
     を返します。

`sqrt(op)'
     OP の平方根を返します。結果はゼロの向きに丸められます。

`sqrtrem(op)'
     `ROOT*ROOT + REMAINDER == OP' となるようなタプル `(ROOT,
     REMAINDER)' を返します。

`divm(numerator, denominator, modulus)'
     `Q * DENOMINATOR %{} MODULUS == NUMERATOR' となる値 Q
     を返します。この関数は `gcdext()' を使って Python
     で実装することもできます。

mpz 数値型は一つのメソッドを持ちます:

`binary()'
     mpz 型の数値をバイナリ文字列に変換します。数値は 256
     進数の桁からなる アレイに記憶されます。最小の桁が先頭になります。

     mpz 型の数値はゼロまたはそれ以上の値をもたなければなりません。
     そうでない場合 `ValueError' が送出されます。

See also:
     `General Multiprecision Python'{
     このプロジェクトでは多倍精度の算術演算を Python で行えるようにする
     新たな数値型を構築中です。彼らの最初の試みも GNU MP ライブラリに
     基づいています。}

     `mxNumber -- Extended Numeric Types for Python'{ もう一つの GNU MP
     ライブラリに対するラッパです。Windows に移植された GNU MP
     ライブラリを含みます。}


File: python-lib-jp.info,  Node: rotor,  Prev: mpz,  Up: 暗号関連のサービス

エニグマ暗号機のような暗号化と復号化
====================================

エニグマ暗号機のような暗号化と復号化。

_This is deprecated in Python 2.3.
この暗号化アルゴリズムは安全ではありません。_

このモジュールは Lance Ellinghouse  に
よって寄与されたロータによる暗号化アルゴリズムを実装しています。
この設計は第二次世界大戦中メッセージを暗号化するために用いられた
エニグマ暗号機からきたものです。ロータは単純に文字の入れ替えです。
例えば `A' をロータの起点とすると、このロータは `A' を `L' に、 `B' を
`Z' に、`C' を `G' に、等に関連付けるでしょう。暗号化
を行うためには、複数の異なるロータを選び、ロータの起点を既知の
位置に設定します; それらの初期位置が暗号化の鍵となります。
文字を暗号化するには、原文の文字を最初のロータによって入れ替え、
次にその結果を二つ目のロータで入れ替えます。そして全てのロータ
で入れ替え終わるまでこれを続けます。結果として得られた文字が
暗号文になります。次に最終段ロータの起点位置を一つだけずらし、 `A' を
`B' にします; 最終段ロータの起点位置が完全に一周したら、 最終段から 2
段目のロータを一つだけずらし、同じ手続きを再帰的に
繰り返します。別の言い方をすれば、一つの文字を暗号化した後は、
ロータを車の距離計と同じ要領で一つ進めるということです。
復号化の作業も同様です。ただし、置き換えを反転し、操作を逆に 行います。

個のモジュールで利用可能な関数は以下のとおりです:

`newrotor(key[, numrotors])'
     ロータオブジェクトを返します KEY はロータオブジェクトの
     暗号化キー文字列です; ヌル文字以外の任意のバイナリデータを含む
     ことができます。暗号化キーはロータの置き換え順列をランダムに
     生成し、初期位置を決めるために使われます。NUMROTORS は
     返されるロータオブジェクト中におけるロータ置き換えの数です。
     省略される場合、標準の値として 6 が使われます。

ロータオブジェクトは以下のメソッドを持っています:

`setkey(key)'
     ロータの暗号化キーを KEY にします、暗号化キーにヌル文字を入れては
     いけません。

`encrypt(plaintext)'
     ロータオブジェクトを初期状態に再初期化し、PLAINTEXT
     を暗号化して、暗号文を含む文字列を返します。暗号文は常に
     もとの平文と同じ長さになります。

`encryptmore(plaintext)'
     ロータオブジェクトを再初期化せずに PLAINTEXT を暗号化し、
     暗号文を含む文字列を返します。

`decrypt(ciphertext)'
     ロータオブジェクトを初期状態に再初期化し、CIPHERTEXT
     を復号化して、平文を含む文字列を返します。平文は常に
     暗号文と同じ長さになります。

`decryptmore(ciphertext)'
     ロータオブジェクトを再初期化せずに CIPHERTEXT を復号化し、
     平文を含む文字列を返します。

利用法の例:
     >>> import rotor
     >>> rt = rotor.newrotor('key', 12)
     >>> rt.encrypt('bar')
     '\xab4\xf3'
     >>> rt.encryptmore('bar')
     '\xef\xfd$'
     >>> rt.encrypt('bar')
     '\xab4\xf3'
     >>> rt.decrypt('\xab4\xf3')
     'bar'
     >>> rt.decryptmore('\xef\xfd$')
     'bar'
     >>> rt.decrypt('\xef\xfd$')
     'l(\xcd'
     >>> del rt

このモジュールのコードはオリジナルのエニグマ暗号機の厳密な
シミュレーションではありません; これはオリジナルのロータ暗号化
手続きを異なる方法で実装しています。
オリジナルのエニグマとの最も重要な違いは、エニグマでは異なる
ロータは実際には 5 から 6 個しか存在せず、一文字あたり 2 回づつ
ロータを適用していたことです; 暗号化キーはロータを暗号機に
配置する順番でした。Python の `rotor' モジュールでは、
与えられたキーはまず乱数生成器を初期化するために使います;
次にロータの順列およびその初期位置がランダムに決定されます。
オリジナルの暗号機ではアルファベット文字だけを暗号化していたのに
対し、このモジュールは 8 ビットの任意のバイナリデータを扱う
ことができ、またバイナリ出力を生成します。このモジュールは
また、任意の数のロータを扱うことができます。

オリジナルのエニグマ暗号は 1944 年に解読されました。
ここで実装されているバージョンを解読するのは、おそらくそれよりかなり
困難ですが、非常に高い技術を持ち、確信犯の攻撃者が暗号を解読するのは
不可能ではありません。従って、NSA からあなたのファイルを守りたいと
思うなら、このロータ暗号は全く安全とはいえませんが、行きずりの来訪者
にあなたのファイルを覗き見する気力を無くさせるためにはおそらくちょうど
よいでしょう。そして UNIX の `crypt' コマンドを使うよりも
やや安全かもしれません。


File: python-lib-jp.info,  Node: Tkを用いたグラフィカルユーザインターフェイス,  Next: 制限実行 restricted execution,  Prev: 暗号関連のサービス,  Up: Top

Tkを用いたグラフィカルユーザインターフェイス
********************************************

Tk/Tcl は長きにわたり Python の不可欠な一部でありつづけています。
Tk/Tcl は頑健でプラットホームに依存しないウィンドウ構築
ツールキットであり、 Python プログラマは`Tkinter'モジュールや
その拡張の`Tix'モジュールを使って利用できます。

`Tkinter' モジュールは、 Tcl/Tk 上に作られた軽量な
オブジェクト指向のレイヤです。 `Tkinter' を使うために Tcl
コードを書く必要はありませんが、 Tk のドキュメントや、場合によって は
Tcl のドキュメントを調べる必要があるでしょう。 `Tkinter' は Tk
のウィジェットを Python のクラスとして
実装しているラッパをまとめたものです。加えて、内部モジュール `_tkinter'
では、 Python と Tcl がやり取りできるような
スレッド安全なメカニズムを提供しています。

Tk は Python にとって唯一の GUI というわけではありませんが、
もっともよく使われています。 Python 用の他の GUI ツールキットに
関する詳しい情報は、*Note
他のグラフィカルユーザインタフェースパッケージ::章、「他のユーザ
インタフェースモジュールとパッケージ」を参照してください。

* Menu:

* Tkinter::
* Tix::
* ScrolledText::
* turtle::
* Idle::
* 他のグラフィカルユーザインタフェースパッケージ::


File: python-lib-jp.info,  Node: Tkinter,  Next: Tix,  Prev: Tkを用いたグラフィカルユーザインターフェイス,  Up: Tkを用いたグラフィカルユーザインターフェイス

Tcl/Tk への Python インタフェース
=================================

グラフィカルユーザインタフェースを実現する Tcl/Tk への インタフェース

`Tkinter' モジュール ("Tk インタフェース") は、 Tk GUI
ツールキットに対する標準の Python インタフェースです。 Tk と `Tkinter'
はほとんどの UNIX プラットフォーム の他、 Windows や Macintosh
システム上でも利用できます。 (Tk 自体は Python の一部ではありません。
Tk は ActiveState で保守されて います。)

See also:
     `Python Tkinter Resources' {Python Tkinter Topic Guide では、Tk を
     Python から利用する上 での情報と、その他の Tk
     にまつわる情報源を数多く提供していま す。}

     `An Introduction to Tkinter' {Fredrik Lundh
     のオンラインリファレンス資料です。}

     `Tkinter reference: a GUI for Python'
     {オンラインリファレンス資料です。}

     `Tkinter for JPython' {Jython から Tkinter
     へのインタフェースです。}

     `Python and Tkinter Programming' {John Graysonによる解説書 (ISBN
     1-884777-81-3) です。}

* Menu:

* Tkinter モジュール::
* Tkinter お助け手帳 life preserver::
* Tcl/Tk を 本当に少しだけ 見渡してみる::
* 基本的な Tk プログラムと Tkinter との対応関係::
* Tk と Tkinter はどのように関わっているのか::
* 簡単なリファレンス::


File: python-lib-jp.info,  Node: Tkinter モジュール,  Next: Tkinter お助け手帳 life preserver,  Prev: Tkinter,  Up: Tkinter

Tkinter モジュール
------------------

ほとんどの場合、本当に必要となるのは `Tkinter' モジュールだけ
ですが、他にもいくつかの追加モジュールを利用できます。 Tk
インタフェース自体は `_tkinter' と言う名前の
バイナリモジュール内にあります。 このモジュールに入っているのは Tk
への低水準のインタフェースであり、
プリケーションプログラマが直接使ってはなりません。 `_tkinter'
は通常共有ライブラリ (や DLL) になっていますが、 Python
インタプリタに静的にリンクされていることもあります。

Tk インタフェースモジュールの他にも、`Tkinter' には Python
モジュールが数多く入っています。最も重要なモジュールは、 `Tkinter'
自体と `Tkconstants' と呼ばれるモジュール
の二つです。前者は自動的に後者を import するので、以下のように
一方のモジュールを import するだけで Tkinter を使えるようになります:

     import Tkinter

あるいは、よく使うやり方で:

     from Tkinter import *

のようにします。

`Tk(screenName=None, baseName=None, className='Tk', useTk=1)'
     `Tk' クラスは引数なしでインスタンス化します。 これは Tk
     のトップレベルウィジェットを生成します。
     通常、トップレベルウィジェットはアプリケーションのメインウィンドウに
     なります。それぞれのインスタンスごとに固有の Tcl インタプリタが関連
     づけられます。

Tk をサポートしているモジュールには、他にも以下のようなモジュールが
あります:

``ScrolledText''
     垂直スクロールバー付きのテキストウィジェットです。

``tkColorChooser''
     ユーザに色を選択させるためのダイアログです。

``tkCommonDialog''
     このリストの他のモジュールが定義しているダイアログの基底クラスです。

``tkFileDialog''
     ユーザが開きたいファイルや保存したいファイルを指定できるようにする
     共通のダイアログです。

``tkFont''
     フォントの扱いを補助するためのユーティリティです。

``tkMessageBox''
     標準的な Tk のダイアログボックスにアクセスします。

``tkSimpleDialog''
     基本的なダイアログと便宜関数 (convenience function) です。

``Tkdnd''
     `Tkinter' 用のドラッグアンドドロップのサポートです。
     実験的なサポートで、Tk DND に置き替わった時点で撤廃されるはずです。

``turtle''
     Tk ウィンドウ上でタートルグラフィックスを実現します。



File: python-lib-jp.info,  Node: Tkinter お助け手帳 life preserver,  Next: Tcl/Tk を 本当に少しだけ 見渡してみる,  Prev: Tkinter モジュール,  Up: Tkinter

Tkinter お助け手帳 (life preserver)
-----------------------------------

この節は、 Tk や Tkinter を全て網羅したチュートリアルを目指している
わけではありません。むしろ、Tkinter のシステムを学ぶ上での指針を
示すための、その場しのぎ的なマニュアルです。

謝辞:
   * Tkinter は Steen Lumholt と Guido van Rossum が作成しました。

   * Tk は John Ousterhout が Berkeley の在籍中に作成しました。

   * この Life Preserver は Virginia 大学の Matt Conway 他が書きました。

   * html へのレンダリングやたくさんの編集は、Ken Manheimer が
     FrameMaker 版から行いました。

   * Fredrik Lundh はクラスインタフェース詳細な説明を書いたり
     内容を改訂したりして、現行の Tk 4.2 に合うようにしました。

   * Mike Clarkson はドキュメントをLaTeX 形式に変換し、
     リファレンスマニュアルのユーザインタフェースの章をコンパイルしました。

* Menu:

* この節の使い方::
* 簡単なHello Worldプログラム::


File: python-lib-jp.info,  Node: この節の使い方,  Next: 簡単なHello Worldプログラム,  Prev: Tkinter お助け手帳 life preserver,  Up: Tkinter お助け手帳 life preserver

この節の使い方
..............

この節は二つの部分で構成されています: 前半では、背景となることがらを
(大雑把に) 網羅しています。後半は、キーボードの横に置けるような手軽な
リファレンスになっています。

「ホゲホゲ (blah) するにはどうしたらよいですか」
という形の問いに答えよう と思うなら、まず Tk
で「ホゲホゲ」する方法を調べてから、この
ドキュメントに戻ってきてその方法に対応する`Tkinter' の
関数呼び出しに変換するのが多くの場合最善の方法になります。 Python
プログラマが Tk ドキュメンテーションを見れば、たいてい 正しい Python
コマンドの見当をつけられます。従って、 Tkinter を使うには Tk
についてほんの少しだけ知っていればよいと いうことになります。
このドキュメントではその役割を果たせないので、次善の策として、
すでにある最良のドキュメントについていくつかヒントを示しておく
ことにしましょう:

   * Tk の man マニュアルのコピーを手に入れるよう強く勧めます。
     とりわけ最も役立つのは`mann' ディレクトリ内にあるマニュアルです。
     `man3' のマニュアルページは Tk ライブラリに対する C インタフェー
     スについての説明なので、スクリプト書きにとって取り立てて役に立つ内容
     ではありません。

   * Addison-Wesley は John Ousterhout の書いた  (ISBN 0-201-63337-X)
     という名前の本 を出版しています。この本は初心者向けの Tcl と Tk
     の良い入門書です。 内容は網羅的ではなく、詳細の多くは man
     マニュアル任せにしています。

   * たいていの場合、`Tkinter.py' は参照先としては最後の地 (last
     resort) ですが、それ以外の手段で調べても分からない場合には
     救いの地 (good place) になるかもしれません。

See also:
     `ActiveState Tclホームページ' {Tk/Tcl の開発は ActiveState
     で大々的に行われています。} `Tcl and the Tk Toolkit' {Tcl
     を考案した John Ousterhout による本です。} `Practical Programming
     in Tcl and Tk' {Brent Welch の百科事典のような本です。}


File: python-lib-jp.info,  Node: 簡単なHello Worldプログラム,  Prev: この節の使い方,  Up: Tkinter お助け手帳 life preserver

簡単なHello Worldプログラム
...........................

     from Tkinter import *
     
     class Application(Frame):
         def say_hi(self):
             print "hi there, everyone!"
     
         def createWidgets(self):
             self.QUIT = Button(self)
             self.QUIT["text"] = "QUIT"
             self.QUIT["fg"]   = "red"
             self.QUIT["command"] =  self.quit
     
             self.QUIT.pack({"side": "left"})
     
             self.hi_there = Button(self)
             self.hi_there["text"] = "Hello",
             self.hi_there["command"] = self.say_hi
     
             self.hi_there.pack({"side": "left"})
     
         def __init__(self, master=None):
             Frame.__init__(self, master)
             self.pack()
             self.createWidgets()
     
     app = Application()
     app.mainloop()


File: python-lib-jp.info,  Node: Tcl/Tk を 本当に少しだけ 見渡してみる,  Next: 基本的な Tk プログラムと Tkinter との対応関係,  Prev: Tkinter お助け手帳 life preserver,  Up: Tkinter

Tcl/Tk を (本当に少しだけ) 見渡してみる
---------------------------------------

クラス階層は複雑に見えますが、実際にプログラムを書く際には、
アプリケーションプログラマはほとんど常にクラス階層の最底辺に
あるクラスしか参照しません。

注意:
   * クラスのいくつかは、特定の関数を一つの名前空間下にまとめるために
     提供されています。こうしたクラスは個別にインスタンス化するためのもの
     ではありません。

   * `Tk' クラスはアプリケーション内で一度だけインスタンス化
     するようになっています。アプリケーションプログラマが明示的に
     インスタンス化する必要はなく、他のクラスがインスタンス化されると
     常にシステムが作成します。

   * `Widget' クラスもまた、インスタンス化して使うようには
     なっていません。このクラスはサブクラス化して「実際の」ウィジェットを
     作成するためのものです。(C++ で言うところの、`抽象クラス (abstract
     class)' です)。


このリファレンス資料を活用するには、Tk の短いプログラムを読んだり、 Tk
コマンドの様々な側面を知っておく必要がままあるでしょう。
(下の説明の`Tkinter' 版は、 *Note 簡単なリファレンス::
節を参照してください。)

Tk スクリプトは Tcl プログラムです。全ての Tcl プログラムに同じく、 Tk
スクリプトはトークンをスペースで区切って並べます。 Tk
ウィジェットとは、ウィジェットの_クラス_、
ウィジェットの設定を行う_オプション_、そしてウィジェットに
役立つことをさせる_アクション_ をあわせたものに過ぎません。

Tk でウィジェットを作るには、常に次のような形式のコマンドを使います:

                     classCommand newPathname options

`CLASSCOMMAND'
     どの種類のウィジェット (ボタン、ラベル、メニュー、...)
     を作るかを表します。

`NEWPATHNAME'
     作成するウィジェットにつける新たな名前です。Tk 内の全ての名前は一意
     になっていなければなりません。一意性を持たせる助けとして、 Tk 内の
     ウィジェットは、ファイルシステムにおけるファイルと同様、 _パス名
     (pathname)_ を使って名づけられます。
     トップレベルのウィジェット、すなわち _ルート_ は `.' (ピリオド)
     という名前になり、その子ウィジェット階層もピリオドで
     区切ってゆきます。ウィジェットの名前は、例えば
     `.myApp.controlPanel.okButton' のようになります。

`OPTIONS'
     ウィジェットの見た目を設定します。場合によってはウィジェットの挙動も
     設定します。オプションはフラグと値がリストになった形式をとります。
     UNIX のシェルコマンドのフラグと同じように、フラグの前には `-' がつ
     き、複数の単語からなる値はクオートで囲まれます。

以下に例を示します:

         button   .fred   -fg red -text "hi there"
            ^       ^     \_____________________/
            |       |                |
          class    new            options
         command  widget  (-opt val -opt val ...)

ウィジェットを作成すると、ウィジェットへのパス名は新しいコマンドに
なります。この新たなWIDGET COMMAND は、プログラマが新たに作成した
ウィジェットにACTION を実行させる際のハンドル (handle) に
なります。Cでは someAction(fred, someOptions)と表し、
C++ではfred.someAction(someOptions)と表すでしょう。Tkでは:

         .fred someAction someOptions

のようにします。 オブジェクト名 `.fred'
はドットから始まっているので注意してください。

読者の想像の通り、SOMEACTION に指定できる値はウィジェット
のクラスに依存しています: fred がボタンなら `.fred disable' は
うまくいきます (fred はグレーになります) が、fred がラベルならうまく
いきません (Tkではラベルの無効化をサポートしていないからです)。

SOMEOPTIONS に指定できる値はアクションの内容に依存しています。
`disable' のようなアクションは引数を必要としませんが、
テキストエントリボックスの `delete'コマンドのようなアクションには
テキストを削除する範囲を指定するための引数が必要になります。


File: python-lib-jp.info,  Node: 基本的な Tk プログラムと Tkinter との対応関係,  Next: Tk と Tkinter はどのように関わっているのか,  Prev: Tcl/Tk を 本当に少しだけ 見渡してみる,  Up: Tkinter

基本的な Tk プログラムと Tkinter との対応関係
---------------------------------------------

Tkのクラスコマンドは、Tkinterのクラスコンストラクタに対応しています。

         button .fred                =====>  fred = Button()

オブジェクトの親 (master)
は、オブジェクトの作成時に指定した新たな名前から
非明示的に決定されます。Tkinter では親を明示的に指定します。

         button .panel.fred          =====>  fred = Button(panel)

Tk の設定オプションは、ハイフンをつけたタグと値の組からなるリストで
指定します。Tkinter では、オプションはキーワード引数にして
インスタンスのコンストラクタに指定したり、`config' に
キーワード引数を指定して呼び出したり、インデクス指定を使って
インスタンスに代入したりして設定します。オプションの設定については
*Note turtle:: 節を参照してください。　

         button .fred -fg red        =====>  fred = Button(panel, fg = "red")
         .fred configure -fg red     =====>  fred["fg"] = red
                                     OR ==>  fred.config(fg = "red")

Tk でウィジェットにアクションを実行させるには、ウィジェット名を
コマンドにして、その後にアクション名を続け、必要に応じて引数
(オプション) を続けます。 Tkinter では、クラスインスタンスの
メソッドを呼び出して、ウィジェットのアクションを呼び出します。
あるウィジェットがどんなアクション (メソッド) を実行できるかは、
Tkinter.py モジュール内にリストされています。

         .fred invoke                =====>  fred.invoke()

Tk でウィジェットを packer (ジオメトリマネジャ) に渡すには、 pack
コマンドをオプション引数付きで呼び出します。 Tkinter では Pack
クラスがこの機能すべてを握っていて、 様々な pack
の形式がメソッドとして実装されています。 `Tkinter' のウィジェットは全て
Packer からサブクラス化 されているため、pack
操作にまつわる全てのメソッドを継承しています。 Form
ジオメトリマネジャに関する詳しい情報については `Tix'
モジュールのドキュメントを参照してください。

         pack .fred -side left       =====>  fred.pack(side = "left")


File: python-lib-jp.info,  Node: Tk と Tkinter はどのように関わっているのか,  Next: 簡単なリファレンス,  Prev: 基本的な Tk プログラムと Tkinter との対応関係,  Up: Tkinter

Tk と Tkinter はどのように関わっているのか
------------------------------------------

_Note:_
以下の構図は図版をもとに書き下ろしたものです。このドキュメントの
今後のバージョンでは、図版をもっと直接的に利用する予定です。

上から下に、呼び出しの階層構造を説明してゆきます:
`あなたのアプリケーション (Python)'
     まず、 Python アプリケーションが`Tkinter'を呼び出します。

`Tkinter ( Python モジュール)'
     上記の呼び出し (例えば、ボタンウィジェットの作成) は、 _Tkinter_
     モジュール内で実現されており、Python で書かれています。 この
     Python で書かれた関数は、コマンドと引数を解析して変換し、あたかも
     コマンドが Python スクリプトではなく Tk スクリプトから来たように
     みせかけます。

`tkinter (C)'
     上記のコマンドと引数は _tkinter_ (小文字です。注意してください)
     拡張モジュール内の C 関数に渡されます 。　

`Tk Widgets (C and Tcl)'
     上記の C 関数は、Tk ライブラリを構成する C 関数の入った別の C
     モジュールへの呼び出しを行えるようになっています。 Tk は C と Tcl
     を少し使って実装されています。 Tk ウィジェットの Tcl
     部分は、ウィジェットのデフォルト動作をバインド
     するために使われ、Python で書かれた`Tkinter' モジュールが import
     される時点で一度だけ実行されます。(ユーザがこの過程を目にする
     ことはありません。

`Tk (C)'
     Tkウィジェットの Tk
     部分で実装されている最終的な対応付け操作によって...

`Xlib (C)'
     Xlib ライブラリがスクリーン上にグラフィックスを描きます。


File: python-lib-jp.info,  Node: 簡単なリファレンス,  Prev: Tk と Tkinter はどのように関わっているのか,  Up: Tkinter

簡単なリファレンス
------------------

* Menu:

* オプションの設定::
* Packer::
* Packer のオプション::
* ウィジェット変数を関連付ける::
* ウィンドウマネジャ::
* Tk オプションデータ型::
* バインドとイベント::
* index パラメータ::
* 画像::


File: python-lib-jp.info,  Node: オプションの設定,  Next: Packer,  Prev: 簡単なリファレンス,  Up: 簡単なリファレンス

オプションの設定
................

オプションは、色やウィジェットの境界線幅などを制御します。
オプションの設定には三通りの方法があります:

`オブジェクトを作成する時にキーワード引数を使う'
     :
          fred = Button(self, fg = "red", bg = "blue")

`オブジェクトを作成した後、オプション名を辞書インデックスのように扱う'
     :
          fred["fg"] = "red"
          fred["bg"] = "blue"

`オブジェクトを生成した後、config()メソッドを使って複数の属性を更新する'
     :
          fred.config(fg = "red", bg = "blue")


オプションとその振る舞いに関する詳細な説明は、該当するウィジェットの Tk
の man マニュアルを参照してください。

man マニュアルには、各ウィジェットの "STANDARD OPTIONS(標準オプション)"
と "WIDGET SPECIFIC OPTIONS (ウィジェット固有のオプション)"
がリストされていることに注意しましょう。
前者は多くのウィジェットに共通のオプションのリストで、
後者は特定のウィジェットに特有のオプションです。標準オプションの 説明は
man マニュアルの`options(3)' にあります。

このドキュメントでは、標準オプションとウィジェット固有のオプションを
区別していません。オプションによっては、ある種のウィジェットに
適用できません。あるウィジェットがあるオプションに対応しているか
どうかは、ウィジェットのクラスによります。例えばボタンには `command'
オプションがありますが、ラベルにはありません。

あるウィジェットがどんなオプションをサポートしているかは、ウィジェット
の man マニュアルにリストされています。また、実行時にウィジェットの
`config()' メソッドを引数なしで呼び出したり、`keys()'
メソッドを呼び出したりして問い合わせることもできます。
メソッド呼び出しを行うと辞書型の値を返します。この辞書は、オプション
の名前がキー (例えば `'relief'') になっていて、値が 5
要素のタプルになっています。

`bg' のように、いくつかのオプションはより長い名前を持つ共通の
オプションに対する同義語になっています (`bg'は "background" を
短縮したものです)。短縮形のオプション名を `config()' に渡すと、 5
要素ではなく 2 要素のタプルを返します。このタプルには、同義語の 名前と
「本当の」オプション名が入っています (例えば `('bg', 'background')')。

インデックス             意味                     例
------                   -----                    -----
0                        オプション名             `'relief''
1                        データベース検索用のオプション名`'relief''
2                        データベース検索用のオプションクラス`'Relief''
3                        デフォルト値             `'raised''
4                        現在の値                 `'groove''

例:

     >>> print fred.config()
     {'relief' : ('relief', 'relief', 'Relief', 'raised', 'groove')}

もちろん、実際に出力される辞書には利用可能なオプションが全て
表示されます。上の表示例は単なる例にすぎません。


File: python-lib-jp.info,  Node: Packer,  Next: Packer のオプション,  Prev: オプションの設定,  Up: 簡単なリファレンス

Packer
......

packer はTkのジオメトリ管理メカニズムの一つです。

ジオメトリマネジャは、複数のウィジェットの位置を、それぞれの
ウィジェットを含むコンテナ - 共通の_マスタ (master)_ からの
相対で指定するために使います。 やや扱いにくい _placer_
(あまり使われないのでここでは取り上げ ません) と違い、packer
は定性的な関係を表す指定子 - _上 (above)_、 _〜の左 (to the left
of)_、_引き延ばし (filling)_ など -
を受け取り、厳密な配置座標の決定を全て行ってくれます。

どんな_マスタ_ ウィジェットでも、大きさは内部の "スレイブ (slave)
ウィジェット" の大きさで決まります。packer は、スレイブウィジェットを
pack 先のマスタウィジェット中のどこに配置するかを制御するために使われ
ます。
望みのレイアウトを達成するには、ウィジェットをフレームにパックし、
そのフレームをまた別のフレームにパックできます。
さらに、一度パックを行うと、それ以後の設定変更に合わせて動的に
並べ方を調整します。

ジオメトリマネジャがウィジェットのジオメトリを確定するまで、
ウィジェットは表示されないので注意してください。
初心者のころにはよくジオメトリの確定を忘れてしまい、
ウィジェットを生成したのに何も表示されず驚くことになります。
ウィジェットは、(例えばpackerの`pack()'メソッドを適用して)
ジオメトリを確定した後で初めて表示されます。

pack() メソッドは、キーワード引数つきで呼び出せます。キーワード引数
は、ウィジェットをコンテナ内のどこに表示するか、メインの
アプリケーションウィンドウをリサイズしたときにウィジェットがどう
振舞うかを制御します。以下に例を示します:

         fred.pack()                     # デフォルトでは、side = "top"
         fred.pack(side = "left")
         fred.pack(expand = 1)


File: python-lib-jp.info,  Node: Packer のオプション,  Next: ウィジェット変数を関連付ける,  Prev: Packer,  Up: 簡単なリファレンス

Packer のオプション
...................

packer と packer の取りえるオプションについての詳細は、man マニュアル
や John Ousterhout の本の 183 ページを参照してください。

`anchor '
     アンカーの型です。 packer
     が区画内に各スレイブを配置する位置を示します。

`expand'
     ブール値で、`0'または`1' になります。

`fill'
     指定できる値は `'x''、`'y''、`'both''、`'none'' です。

`ipadxとipady'
     スレイブウィジェットの各側面の内側に行うパディング幅を表す長さを
     指定します。

`padxとpady'
     スレイブウィジェットの各側面の外側に行うパディング幅を表す長さを
     指定します。

`side'
     指定できる値は `'left'', `'right'', `'top'', `'bottom'' です。


File: python-lib-jp.info,  Node: ウィジェット変数を関連付ける,  Next: ウィンドウマネジャ,  Prev: Packer のオプション,  Up: 簡単なリファレンス

ウィジェット変数を関連付ける
............................

ウィジェットによっては、(テキスト入力ウィジェットのように)
特殊なオプションを使って、現在設定されている値をアプリケーション内の
変数に直接関連付けできます。このようなオプションには`variable'、
`textvariable'、`onvalue'、`offvalue'および`value'
があります。この関連付けは双方向に働きます: 変数の値が何らかの理由で
変更されると、関連付けされているウィジェットも更新され、新しい値を
反映します。

残念ながら、現在の`Tkinter' の実装では、 `variable' や`textvariable'
オプションでは 任意の Python の値をウィジェットに渡せません。
この関連付け機能がうまく働くのは、 `Tkinter' モジュール内で Variable
というクラスから サブクラス化されている変数によるオプションだけです。

Variable には、`StringVar'、`IntVar'、`DoubleVar'および `BooleanVar'
といった便利なサブクラスがすでにすでに数多く定義
されています。こうした変数の現在の値を読み出したければ、 `get()'
メソッドを呼び出します。また、値を変更したければ `set()'
メソッドを呼び出します。
このプロトコルに従っている限り、それ以上なにも手を加えなくても
ウィジェットは常に現在値に追従します。

例えば:
     class App(Frame):
         def __init__(self, master=None):
             Frame.__init__(self, master)
             self.pack()
     
             self.entrythingy = Entry()
             self.entrythingy.pack()
     
             # アプリケーション変数です
             self.contents = StringVar()
             # 変数の値を設定します
             self.contents.set("this is a variable")
             # エントリウィジェットに変数の値を監視させます
             self.entrythingy["textvariable"] = self.contents
     
             # ユーザがリターンキーを押した時にコールバックを呼び出させます
             # これで、このプログラムは、ユーザがリターンキーを押すと
             # アプリケーション変数の値を出力するようになります。
             self.entrythingy.bind('<Key-Return>',
                                   self.print_contents)
     
         def print_contents(self, event):
             print "hi. contents of entry is now ---->", \
                   self.contents.get()


File: python-lib-jp.info,  Node: ウィンドウマネジャ,  Next: Tk オプションデータ型,  Prev: ウィジェット変数を関連付ける,  Up: 簡単なリファレンス

ウィンドウマネジャ
..................

Tk には、ウィンドウマネジャとやり取りするための `wm' という
ユーティリティコマンドがあります。`wm' コマンドにオプション
を指定すると、タイトルや配置、アイコンビットマップなどを操作
できます。`Tkinter' では、こうしたコマンドは `Wm'
クラスのメソッドとして実装されています。 トップレベルウィジェットは
`Wm' クラスからサブクラス化 されているので、`Wm'
のメソッドを直接呼び出せます。

あるウィジェットの入っているトップレベルウィンドウを取得したい場合、
大抵は単にウィジェットのマスタを参照するだけですみます。とはいえ、
ウィジェットがフレーム内にパックされている場合、マスタはトップレベル
ウィンドウではありません。任意のウィジェットの入っている
トップレベルウィンドウを知りたければ `_root()' メソッド
を呼び出してください。このメソッドはアンダースコアがついていますが、
これはこの関数が `Tkinter' の実装の一部であり、Tk の機能
に対するインタフェースではないことを示しています。

以下に典型的な使い方の例をいくつか挙げます:

     from Tkinter import *
     class App(Frame):
         def __init__(self, master=None):
             Frame.__init__(self, master)
             self.pack()
     
     # アプリケーションを作成します
     myapp = App()
     
     #
     # ウィンドウマネジャクラスのメソッドを呼び出します。
     #
     myapp.master.title("My Do-Nothing Application")
     myapp.master.maxsize(1000, 400)
     
     # プログラムを開始します
     myapp.mainloop()


File: python-lib-jp.info,  Node: Tk オプションデータ型,  Next: バインドとイベント,  Prev: ウィンドウマネジャ,  Up: 簡単なリファレンス

Tk オプションデータ型
.....................

`anchor'
     指定できる値はコンパスの方位です:
     `"n"'、`"ne"'、`"e"'、`"se"'、`"s"'、`"sw"'、`"w"'、`"nw"'、および`"center"'。

`bitmap'
     八つの組み込み、名前付きビットマップ:
     `'error''、`'gray25''、`'gray50''、`'hourglass''、`'info''、`'questhead''、`'question''、`'warning''。
     Xビットマップファイル名を指定するために、`"@/usr/contrib/bitmap/gumby.bit"'のような`@'を先頭に付けたファイルへの完全なパスを与えてください。

`boolean'
     整数0または1、あるいは、文字列`"yes"'または`"no"'を渡すことができます。

`callback'
     これは引数を取らない Python 関数ならどれでも構いません。例えば:
              def print_it():
                      print "hi there"
              fred["command"] = print_it

`color'
     色はrgb.txtファイルのXカラーの名前か、またはRGB値を表す文字列として与えられます。RGB値を表す文字列は、4ビット:
     `"#RGB"', 8 bit: `"#RRGGBB"', 12 bit" `"#RRRGGGBBB"', あるいは、16
     bit
     `"#RRRRGGGGBBBB"'の範囲を取ります。ここでは、R,G,Bは適切な十六進数ならどんなものでも表します。詳細は、Ousterhoutの本の160ページを参照してください。

`cursor'
     `cursorfont.h'の標準Xカーソル名を、接頭語`XC_'無しで使うことができます。例えば、handカーソル(`XC_hand2')を得るには、文字列`"hand2"'を使ってください。あなた自身のビットマップとマスクファイルを指定することもできます。Ousterhoutの本の179ページを参照してください。

`distance'
     スクリーン上の距離をピクセルか絶対距離のどちらかで指定できます。ピクセルは数として与えられ、絶対距離は文字列として与えられます。絶対距離を表す文字列は、単位を表す終了文字(センチメートルには`c'、インチには`i'、ミリメートルには`m'、プリンタのポイントには`p')を伴います。例えば、3.5インチは`"3.5i"'と表現します。

`font'
     Tkは`{courier 10
     bold}'のようなリストフォント名形式を使います。正の数のフォントサイズはポイント単位で表され。負の数のサイズはピクセル単位で表されます。

`geometry'
     これは`WIDTHxHEIGHT'形式の文字列です。ここでは、ほとんどのウィジェットに対して幅と高さピクセル単位で(テキストを表示するウィジェットに対しては文字単位で)表されます。例えば:
     `fred["geometry"] = "200x100"'。

`justify'
     指定できる値は文字列です: `"left"'、`"center"'、`"right"'、and
     `"fill"'。

`region'
     これは空白で区切られた四つの要素をもつ文字列です。各要素は指定可能な距離です(以下を参照)。例えば:
     `"2 3 4 5"'と`"3i 2i 4.5i 2i"'と`"3c 2c 4c
     10.43c"'は、すべて指定可能な範囲です。

`relief'
     ウィジェットのボーダのスタイルが何かを決めます。指定できる値は:
     `"raised"'、`"sunken"'、`"flat"'、`"groove"'、and `"ridge"'。

`scrollcommand'
     これはほとんど常にスクロールバー・ウィジェットの`set()'メソッドですが、一引数を取るどんなウィジェットメソッドでもあり得ます。例えば、
     Python
     ソース配布の`Demo/tkinter/matt/canvas-with-scrollbars.py'ファイルを参照してください。

`wrap:'
     次の中の一つでなければならない:
     `"none"'、`"char"'、あるいは`"word"'。


File: python-lib-jp.info,  Node: バインドとイベント,  Next: index パラメータ,  Prev: Tk オプションデータ型,  Up: 簡単なリファレンス

バインドとイベント
..................

ウィジェットコマンドからのbindメソッドによって、あるイベントを待つことと、そのイベント型が起きたときにコールバック関数を呼び出すことができるようになります。bindメソッドの形式は:

         def bind(self, sequence, func, add=''):

ここでは:

`sequence'
     は対象とするイベントの型を示す文字列です。(詳細については、bindのmanページとJohn
     Ousterhoutの本の201ページをを参照してください。)

`func'
     は一引数を取り、イベントが起きるときに呼び出される Python
     関数です。イベント・インスタンスが引数として渡されます。(このように実施される関数は、一般にCALLBACKSとして知られています。)

`add'
     はオプションで、`'か`+'のどちらかです。
     空文字列を渡すことは、このイベントが関係する他のどんなバインドをもこのバインドが置き換えることを意味します。
     `+'を使う仕方は、この関数がこのイベント型にバインドされる関数のリストに追加されることを意味しています。

例えば:
         def turnRed(self, event):
             event.widget["activeforeground"] = "red"
     
         self.button.bind("<Enter>", self.turnRed)

イベントのウィジェットフィールドが`turnRed()'コールバック内でどのようにアクセスされているかに注意してください。
このフィールドはXイベントを捕らえるウィジェットを含んでいます。
以下の表はあなたがアクセスできる他のイベントフィールドとそれらのTkでの表現方法の一覧です。Tk
manページを参照するときに役に立つでしょう。

     Tk      Tkinterイベントフィールド       Tk      Tkinterイベントフィールド
     --      -------------------------       --      -------------------------
     %f      focus                           %A      char
     %h      height                          %E      send_event
     %k      keycode                         %K      keysym
     %s      state                           %N      keysym_num
     %t      time                            %T      type
     %w      width                           %W      widget
     %x      x                               %X      x_root
     %y      y                               %Y      y_root


File: python-lib-jp.info,  Node: index パラメータ,  Next: 画像,  Prev: バインドとイベント,  Up: 簡単なリファレンス

index パラメータ
................

たくさんのウィジェットが渡される"index"パラメータを必要とします。これらはテキストウィジェットでの特定の場所や、エントリウィジェットでの特定の文字、あるいは、メニューウィジェットでの特定のメニュー項目を指定するために使われます。

`エントリウィジェットのインデックス(インデックス、ビューインデックスなど)'
     エントリウィジェットは表示されているテキスト内の文字位置を参照するオプションを持っています。
     テキストウィジェットにおけるこれらの特別な位置にアクセスするために、これらの`Tkinter'関数を使うことができます:

    `AtEnd()'
          テキストの最後の位置を参照します

    `AtInsert()'
          テキストカーソルの位置を参照します

    `AtSelFirst()'
          選択されたテキストの先頭の位置を指します

    `AtSelLast()'
          選択されているテキストおよび最終的に選択されたテキストの末尾の位置を示します。

    `At(x[, y])'
          ピクセル位置X,
          Y(テキストを一行だけ含むテキストエントリウィジェットの場合にはYは使われない)の文字を参照します。

`テキストウィジェットのインデックス'
     テキストウィジェットに対するインデックス記法はとても機能が豊富で、Tk
     manページでよく説明されています。

`メニューのインデックス(menu.invoke()、menu.entryconfig()など)'
     メニューに対するいくつかのオプションとメソッドは特定のメニュー項目を操作します。メニューインデックスはオプションまたはパラメータのために必要とされるときはいつでも、以下のものを渡すことができます:
        * 頭から数えられ、0で始まるウィジェットの数字の位置を指す整数。

        * 文字列`'active''、現在カーソルがあるメニューの位置を指します。

        * 最後のメニューを指す文字列`"last"'。

        *
          `@6'のような`@'が前に来る整数。ここでは、整数がメニューの座標系におけるyピクセル座標として解釈されます。

        *
          文字列`"none"'、どんなメニューエントリもまったく指しておらず、ほとんどの場合、すべてのエントリの動作を停止させるためにmenu.activate()と一緒に使われます。そして、最後に、

        *
          メニューの先頭から一番下までスキャンしたときに、メニューエントリのラベルに一致したパターンであるテキスト文字列。このインデックス型は他すべての後に考慮されることに注意してください。その代わりに、それは`last'、`active'または`none'とラベル付けされたメニュー項目への一致は上のリテラルとして解釈されることを意味します。



File: python-lib-jp.info,  Node: 画像,  Prev: index パラメータ,  Up: 簡単なリファレンス

画像
....

Bitmap/Pixelmap画像を`Tkinter.Image'のサブクラスを使って作ることができます:

   * `BitmapImage'はX11ビットマップデータに対して使えます。

   * `PhotoImage'はGIFとPPM/PGMカラービットマップに対して使えます。

画像のどちらの型でも`file'または`data'オプションを使って作られます(その上、他のオプションも利用できます)。

`image'オプションがウィジェットにサポートされるところならどこでも、画像オブジェクトを使うことができます(例えば、ラベル、ボタン、メニュー)。これらの場合では、Tkは画像への参照を保持しないでしょう。画像オブジェクトへの最後の
Python
の参照が削除されたときに、おまけに画像データが削除されます。そして、どこで画像が使われていようとも、Tkは空の箱を表示します。


File: python-lib-jp.info,  Node: Tix,  Next: ScrolledText,  Prev: Tkinter,  Up: Tkを用いたグラフィカルユーザインターフェイス

Tkの拡張ウィジェット
====================

Tkinter用のTk拡張ウィジェット

`Tix' (Tk Interface
Extension)モジュールは豊富な追加ウィジェットを提供します。標準Tkライブラリには多くの有用なウィジェットがありますが、完全では決してありません。`Tix'ライブラリは標準Tkに欠けている一般的に必要とされるウィジェットの大部分を提供します:
`HList'、`ComboBox'、`Control'
(別名SpinBox)および各種のスクロール可能なウィジェット。`Tix'には、一般的に幅広い用途に役に立つたくさんのウィジェットも含まれています:
`NoteBook'、`FileEntry'、`PanedWindow'など。それらは40以上あります。

これら全ての新しいウィジェットと使うと、より便利でより直感的なユーザインタフェース作成し、あなたは新しい相互作用テクニックをアプリケーションに導入することができます。アプリケーションとユーザに特有の要求に合うように、大部分のアプリケーションウィジェットを選ぶことによって、アプリケーションを設計できます。

See also:
     `Tix Homepage' {`Tix'のホームページ。
     ここには追加ドキュメントとダウンロードへのリンクがあります。} `Tix
     Man Pages' {manページと参考資料のオンライン版。} `Tix Programming
     Guide' {プログラマ用参考資料のオンライン版。} `Tix Development
     Applications'
     {TixとTkinterプログラムの開発のためのTixアプリケーション。TideアプリケーションはTkまたはTkinterに基づいて動作します。また、リモートでTix/Tk/Tkinterアプリケーションを変更やデバグするためのインスペクタ`TixInspect'が含まれます。}

* Menu:

* Tixを使う::
* Tixウィジェット::
* Tixコマンド::


File: python-lib-jp.info,  Node: Tixを使う,  Next: Tixウィジェット,  Prev: Tix,  Up: Tix

Tixを使う
---------

`Tix(screenName[, baseName[, className]])'
     たいていはアプリケーションのメインウィンドウを表すTixのトップレベルウィジェット。それにはTclインタープリタが付随します。

     `Tix'モジュールのクラスは`Tkinter'モジュールのクラスをサブクラス化します。前者は後者をインポートします。だから、Tkinterと一緒に`Tix'を使うためにやらなければならないのは、モジュールを一つインポートすることだけです。一般的に、`Tix'をインポートし、トップレベルでの`Tkinter.Tk'の呼び出しを`Tix.Tk'に置き換えるだけでよいのです:
          import Tix
          from Tkconstants import *
          root = Tix.Tk()


`Tix'を使うためには、通常Tkウィジェットのインストールと平行して、`Tix'ウィジェットをインストールしなければなりません。インストールをテストするために、次のことを試してください:
     import Tix
     root = Tix.Tk()
     root.tk.eval('package require Tix')

これが失敗した場合は、先に進む前に解決しなければならない問題がTkのインストールにあることになります。インストールされた`Tix'ライブラリを指定するためには環境変数`TIX_LIBRARY'を使ってください。Tk動的オブジェクトライブラリ(`tk8183.dll'または`libtk8183.so')を含むディレクトリと同じディレクトリに、動的オブジェクトライブラリ(`tix8183.dll'または`libtix8183.so')があるかどうかを確かめてください。動的オブジェクトライブラリのあるディレクトリには、`pkgIndex.tcl'
(大文字、小文字を区別します)という名前のファイルも含まれているべきで、それには次の一行が含まれます:

     package ifneeded Tix 8.1 [list load "[file join $dir tix8183.dll]" Tix]


File: python-lib-jp.info,  Node: Tixウィジェット,  Next: Tixコマンド,  Prev: Tixを使う,  Up: Tix

Tixウィジェット
---------------

{Tix}1Tixは40個以上のウィジェットクラスを`Tkinter'のレパートリーに導入します。標準配布の`Demo/tix'ディレクトリには、`Tix'ウィジェットのデモがあります。

* Menu:

* 基本ウィジェット::
* ファイルセレクタ::
* ハイアラキカルリストボックス::
* タビュラーリストボックス::
* 管理ウィジェット::
* 画像タイプ::
* その他のウィジェット::
* ジオメトリマネジャを作る::


File: python-lib-jp.info,  Node: 基本ウィジェット,  Next: ファイルセレクタ,  Prev: Tixウィジェット,  Up: Tixウィジェット

基本ウィジェット
................

`Balloon()'
     ヘルプを提示するためにウィジェット上にポップアップするBalloon。ユーザがカーソルをBalloonウィジェットが束縛されているウィジェット内部へ移動させたとき、説明のメッセージが付いた小さなポップアップウィンドウがスクリーン上に表示されます。

`ButtonBox()'
     ButtonBoxウィジェットは、`Ok
     Cancel'のためだけに普通は使われるようなボタンボックスを作成します。

`ComboBox()'
     ComboBoxウィジェットはMS
     Windowsのコンボボックスコントロールに似ています。ユーザはエントリ・サブウィジェットでタイプするか、リストボックス・サブウィジェットから選択するかのどちらかで選択肢を選びます。

`Control()'
     Controlウィジェットは`SpinBox'ウィジェットとしても知られています。ユーザは二つの矢印ボタンを押すか、またはエントリに直接値を入力して値を調整します。新しい値をユーザが定義した上限と下限に対してチェックします。

`LabelEntry()'
     LabelEntryウィジェットはエントリウィジェットとラベルを一つのメガウィジェットにまとめたものです。"記入形式"型のインタフェースの作成を簡単に行うために使うことができます。

`LabelFrame()'
     LabelFrameウィジェットはフレームウィジェットとラベルを一つのメガウィジェットにまとめたものです。LabelFrameウィジェット内部にウィジェットを作成するためには、`frame'サブウィジェットに対して新しいウィジェットを作成し、それらを`frame'サブウィジェット内部で取り扱います。

`Meter()'
     Meterウィジェットは実行に時間のかかるバックグラウンド・ジョブの進み具合を表示するために使用できます。

`OptionMenu()'
     OptionMenuはオプションのメニューボタンを作成します。

`PopupMenu()'
     PopupMenuウィジェットは`tk_popup'コマンドの代替品として使用できます。`Tix'
     `PopupMenu'ウィジェットの利点は、操作するためにより少ないアプリケーション・コードしか必要としないことです。

`Select()'
     Selectウィジェットはボタン・サブウィジェットのコンテナです。ユーザに対する選択オプションのラジオボックスまたはチェックボックス形式を提供するために利用することができます。

`StdButtonBox()'
     StdButtonBoxウィジェットは、Motifに似たダイアログボックスのための標準的なボタンのグループです。


File: python-lib-jp.info,  Node: ファイルセレクタ,  Next: ハイアラキカルリストボックス,  Prev: 基本ウィジェット,  Up: Tixウィジェット

ファイルセレクタ
................

`DirList()'
     DirListウィジェットは、ディレクトリのリストビュー(その前のディレクトリとサブディレクトリ)を表示します。ユーザはリスト内の表示されたディレクトリの一つを選択したり、あるいは他のディレクトリへ変更したりできます。

`DirTree()'
     DirTreeウィジェットはディレクトリのツリービュー(その前のディレクトリとそのサブディレクトリ)を表示します。ユーザはリスト内に表示されたディレクトリの一つを選択したり、あるいは他のディレクトリに変更したりできます。

`DirSelectDialog()'
     DirSelectDialogウィジェットは、ダイアログウィンドウにファイルシステム内のディレクトリを提示します。望みのディレクトリを選択するために、ユーザはファイルシステムを介して操作するこのダイアログウィンドウを利用できます。

`DirSelectBox()'
     `DirSelectBox'は標準Motif(TM)ディレクトリ選択ボックスに似ています。ユーザがディレクトリを選択するために一般的に使われます。DirSelectBoxは主に最近ComboBoxウィジェットに選択されたディレクトリを保存し、すばやく再選択できるようにします。

`ExFileSelectBox()'
     ExFileSelectBoxウィジェットは、たいていtixExFileSelectDialogウィジェット内に組み込まれます。ユーザがファイルを選択するのに便利なメソッドを提供します。`ExFileSelectBox'ウィジェットのスタイルは、MS
     Windows 3.1の標準ファイルダイアログにとてもよく似ています。

`FileSelectBox()'
     FileSelectBoxは標準的なMotif(TM)ファイル選択ボックスに似ています。ユーザがファイルを選択するために一般的に使われます。FileSelectBoxは主に最近`ComboBox'ウィジェットに選択されたファイルを保存し、素早く再選択できるようにします。

`FileEntry()'
     FileEntryウィジェットはファイル名を入力するために使うことができます。ユーザは手でファイル名をタイプできます。その代わりに、ユーザはエントリの横に並んでいるボタンウィジェットを押すことができます。それはファイル選択ダイアログを表示します。

