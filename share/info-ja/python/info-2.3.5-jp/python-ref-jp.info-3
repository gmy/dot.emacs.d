This is python-ref-jp.info, produced by makeinfo version 4.5 from
python-ref-jp.texi.

12 October 2005


File: python-ref-jp.info,  Node: 新しい形式のクラスのための別の属性アクセス,  Next: デスクリプタ descriptor の実装,  Prev: 属性値アクセスをカスタマイズする,  Up: 属性値アクセスをカスタマイズする

新しい形式のクラスのための別の属性アクセス
..........................................

以下のメソッドは新しい形式のクラス (new-style class) のみに
適用されます。

`__getattribute__(self, name)'
     クラスのインスタンスに対する属性アクセスを実装するために、無条件に
     呼び出されます。クラスが `__getattr__()' も定義している
     場合、`__getattr__()' は (明示的に呼び出さない限り)
     呼び出されることはありません。このメソッドは (計算された) 属性値を
     返すか、`AttributeError' 例外を送出します。
     このメソッドが再帰的に際限なく呼び出されてしまうのを防ぐため、
     実装の際には常に、例えば `object.__getattribute__(self, name)'
     のように基底クラスのメソッドを同じ属性名を使って呼び出し、
     必要な属性値全てにアクセスしなければなりません。


File: python-ref-jp.info,  Node: デスクリプタ descriptor の実装,  Next: デスクリプタを呼び出す,  Prev: 新しい形式のクラスのための別の属性アクセス,  Up: 属性値アクセスをカスタマイズする

デスクリプタ (descriptor) の実装
................................

以下のメソッドは、デスクリプタメソッドを持っているクラス (いわゆる
_デスクリプタ (descriptor)_ クラス) のインスタンスが
別の新たな形式のクラス、いわゆる _オーナ (owner)_ クラスの
クラス辞書に存在する場合にのみ適用されます。 以下の例での "属性"
とは、属性の名前が オーナクラスの `__dict__' に入っているプロパティ
(porperty) を検索するためのキーになっているような属性を指します。
デスクリプタ自体は、新しい形式のクラスとしてしか実装できません。

`__get__(self, instance, owner)'
     オーナクラスやの属性を取得する (クラス属性へのアクセス) 際や、
     オーナクラスのインスタンスの属性を取得する (インスタンス属性への
     アクセス) 場合に呼び出されます。OWNER は常にオーナクラスです。
     一方、INSTANCE は属性へのアクセスを仲介するインスタンスか 属性が
     OWNER を介してアクセスされる場合は `None' に
     なります。このメソッドは (計算された) 属性値を返すか、
     `AttributeError' 例外を送出しなければなりません。

`__set__(self, instance, value)'
     オーナクラスのインスタンス INSTANCE 上の属性を新たな値 VALUE
     に設定する際に呼び出されます。

`__delete__(self, instance)'
     オーナクラスのインスタンス INSTANCE 上の属性を削除する際に
     呼び出されます。


File: python-ref-jp.info,  Node: デスクリプタを呼び出す,  Next: __slots__,  Prev: デスクリプタ descriptor の実装,  Up: 属性値アクセスをカスタマイズする

デスクリプタを呼び出す
......................

一般にデスクリプタとは、 特殊な "束縛に関する動作 (binding behaviour)"
をもつオブジェクト属性のことです。デスクリプタは、デスクリプタ
プロトコル (descriptor protocol) のメソッド: `__get__()', `__set__()',
および `__delete__()'
を使って、属性アクセスをオーバライドしているものです。
これらのメソッドのいずれかがオブジェクトに対して定義されている場合、
オブジェクトはデスクリプタであるといいます。

属性アクセスのデフォルトの動作は、オブジェクトの辞書から値を取り出したり、
値を設定したり、削除したりするというものです。例えば、`a.x' による
属性の検索では、まず `a.__dict__['x']' 、次に `type(a).__dict__['x']'
、そして`type(a)' の基底クラスで
メタクラスでないものに続く、といった具合に連鎖が起こります。

しかしながら、検索対象となる値が、デスクリプタメソッドのいずれかを
定義しているオブジェクトの属性値である場合、Python はデフォルトの動作を
オーバライドして、デスクリプタメソッドの方を呼び出します。

前後する呼び出し連鎖の中のどこでデスクリプタメソッドが呼び出されるかは、
どのデスクリプタメソッドが定義されているかと、どうやってデスクリプタ
メソッドが呼ばれるかに依存します。デスクリプタは新しい形式のオブジェクトや
クラス (`object()' や `type()' をサブクラス化したもの) だけに
対して呼び出されるので注意してください。

デスクリプタ呼び出しの基点となるのは、属性名への束縛 (binding)
、すなわち `a.x' です。引数がどのようにデスクリプタに結合されるかは `a'
に 依存します:

   * 直接呼出し (Direct Call) 最も単純で、かつめったに使われない
     呼び出し操作は、コード中で直接デスクリプタメソッドの呼び出し:
     `x.__get__(a)' を行うというものです。

   * インスタンス束縛 (Instance Binding) 新しい形式のクラスの
     インスタンスに対する束縛では、`a.x' は呼び出し:
     `type(a).__dict__['x'].__get__(a, type(a))' に変換されます。

   * クラス束縛 (Class Binding) 新しい形式のクラスに対する束縛では、
     `A.x' は呼び出し: `A.__dict__['x'].__get__(None, A)'
     に変換されます。

   * スーパクラス束縛 (Super Binding) `a' が `super'
     のインスタンスである場合、束縛 `super(B, obj).m()' を行うと まず
     `A' 、続いて `B'に対して `obj.__class_.__mro__' を
     検索し、次に呼び出し: `A.__dict__['m'].__get__(obj, A)' で
     デスクリプタを呼び出します。


インスタンス束縛では、デスクリプタ呼び出しの優先順位はどのデスクリプタが
定義されているかに依存します。データデスクリプタでは、 `__get__()' と
`__set__()' を定義します。非データ デスクリプタには `__get__()'
メソッドしかありません。
インスタンス辞書内で属性値が再定義されても、データデスクリプタは常に
この値をオーバライドします。対照的に、非データデスクリプタの
場合には、属性値はインスタンス側でオーバライドされます。

(`staticmethod()' や `classmethod()' を含む) Python
メソッドは、非データデスクリプタとして実装されています。その結果、
インスタンスではメソッドを再定義したりオーバライドできます。
このことにより、個々のインスタンスが同じクラスの他のインスタンスと
互いに異なる動作を獲得することができます。

`property()' 関数はデータデスクリプタとして実装されています。
従って、インスタンスはあるプロパティの動作をオーバライドすることが
できません。


File: python-ref-jp.info,  Node: __slots__,  Prev: デスクリプタを呼び出す,  Up: 属性値アクセスをカスタマイズする

__slots__
.........

デフォルトでは、新旧どちらのクラスも、属性の記憶領域として使うための
辞書を持っています。この仕様は、ほとんどインスタンス変数を持たない
ようなオブジェクトの場合には記憶領域の無駄遣いになります。
記憶領域の消費量は、大量のインスタンスを生成する際には深刻です。

このデフォルトの設定は、新たな形式のクラス定義において __SLOTS__ を
定義することでオーバライドできます。__SLOTS_ 宣言はインスタンス
変数の配列を受け取ります。各々のインスタンス上には、各変数の値を
記憶するのにちょうど必要な量だけの記憶領域を確保します。
各々のインスタンスに対して __DICT__ が生成されることがないので、
記憶領域が節約されます。

`__slots__'
     このクラス変数には、文字列、反復可能オブジェクト、あるいはインスタンスが
     用いる変数名を表す文字列からなる配列を代入することができます。
     この変数が新しい形式のクラスで定義されている場合、__SLOTS__
     は、各インスタンスに対して宣言された変数に必要な記憶領域を確保し、
     __DICT__ と__WEAKREF__ が自動的に生成されないようにします。 _Added
     in Python version 2.2_

__SLOTS__ を利用する際の注意

   * __DICT__ 変数がない場合、__SLOTS__ に列挙されていない
     新たな変数をインスタンスに代入することはできません。
     列挙されていない変数名を使って代入しようとした場合、
     `AttributeError' が送出されます。
     新たな変数を動的に代入したいのなら、__SLOTS__ を宣言する際に
     `'__dict__'' を変数名の配列に追加してください。

     _Changed in Python version 2.3_

   * __SLOTS__ を定義しているクラスの各インスタンスに __WEAKREF__
     変数がない場合、インスタンスに対する弱参照 (weak reference)
     はサポートされません。 弱参照のサポートが必要なら、 __SLOTS__
     を宣言する際に `'__weakref__'' を変数名の配列に追加してください。
     _Changed in Python version 2.3_

   * __SLOTS__ は、クラスのレベルで各変数に対するデスクリプタ (*Note
     デスクリプタ descriptor の実装:: を参照)
     を使って実装されます。その結果、 __SLOTS__
     に定義されているインスタンス変数のデフォルト値は
     クラス属性を使って設定できなくなっています; そうしないと、
     デスクリプタによる代入をクラス属性が上書きしてしまうからです。

   * あるクラスで、基底クラスですでに定義されているスロットを
     定義した場合、基底クラスのスロットで定義されているインスタンス変数は
     (デスクリプタを基底クラスから直接取得しない限り) アクセスできなく
     なります。これにより、プログラムの趣意が不定になってしまいます。
     将来は、この問題を避けるために何らかのチェックが追加されるかもしれません。

   * __SLOTS__ 宣言が動作するのは、定義が行われたクラスだけに
     限られています。その結果、サブクラスでは、__SLOTS__ を定義
     しない限り __DICT__ を持つことになります。

   * __SLOTS__ は、`long'、 `str'、および `tuple' といった、"可変長
     (variable-length)" の組み込み型
     から導出されたクラスでは動作しません。

   * __SLOTS__ には、文字列でない反復可能オブジェクトを
     代入することができます。辞書型も使うことができます; しかし将来、
     辞書の各キーに相当する値に何らかの特殊な意味が割り当てられる
     かもしれません。



File: python-ref-jp.info,  Node: クラス生成をカスタマイズする,  Next: 呼び出し可能オブジェクトをエミュレートする,  Prev: 属性値アクセスをカスタマイズする,  Up: 特殊メソッド名

クラス生成をカスタマイズする
----------------------------

デフォルトでは、新形式クラスは `type()' を使って構築
されます。クラス定義が別の名前空間に読み込まれ、 クラス名は `type(name,
bases, dict)' の結果に結合されます。

クラス定義が読み込まれる際、__METACLASS__ が定義されていれば、 `type()'
の代わりに __METACLASS__ が指している
呼び出し可能オブジェクトが呼び出されます。 これによって、

   * クラスが生成される前にクラス辞書を変更する

   * 他のクラスのインスタンスを返す - 本質的にはファクトリ関数の役割を
     果たす

といった、クラス生成のプロセスを監視したり置き換えたりする
クラスや関数を書くことができます。

`__metaclass__'
     この変数は `name'、`bases'、および `dict' を引数として
     取るような任意の呼び出し可能オブジェクトにできます。
     クラス生成の際、組み込みの `type()' の代わりに、指定された
     呼び出しオブジェクトが呼び出されます。 _Added in Python version
     2.2_

以下に優先順で並んだ規則によって、適切なメタクラスが決定されます:

   * `dict['__metaclass__']' があればそれを使います。

   * それ以外の場合で、最低でも一つ基底クラスを持っているなら、
     基底クラスのメタクラス (__CLASS__ 属性を探し、なければ
     基底クラスの型) を使います。

   * それ以外の場合で、__metaclass__ という名前のグローバル変数
     があれば、それをつかいます。

   * それ以外の場合には、旧形式のメタクラス (types.ClassType)
     を使います。


メタクラスは限りない潜在的利用価値を持っています。これまで試されて
きたアイデアには、ログ記録、インタフェースのチェック、
自動デリゲーション、自動プロパティ生成、プロキシ、フレームワーク、
そして自動リソースロック／同期といったものがあります。


File: python-ref-jp.info,  Node: 呼び出し可能オブジェクトをエミュレートする,  Next: コンテナをエミュレートする,  Prev: クラス生成をカスタマイズする,  Up: 特殊メソッド名

呼び出し可能オブジェクトをエミュレートする
------------------------------------------

`__call__(self[, args...])'
     インスタンスが関数として "呼ばれた" 際に呼び出されます;
     このメソッドが定義されている場合、`X(arg1, arg2, ...)' は
     `X.__call__(arg1, arg2, ...)' を短く書いたものに なります。


File: python-ref-jp.info,  Node: コンテナをエミュレートする,  Next: 配列型エミュレーションで使われるその他のメソッド,  Prev: 呼び出し可能オブジェクトをエミュレートする,  Up: 特殊メソッド名

コンテナをエミュレートする
--------------------------

以下のメソッドを定義して、コンテナオブジェクトを実装することができます。
コンテナは通常、(リストやタプルのような) 配列や、(辞書のような)
マップ型を指しますが、他のコンテナも同じように表現することができます。
最初の一連のメソッドは、配列をエミュレートしたり、マップ型を
エミュレートするために使われます; その違いとして、配列の場合には、
キーとして許されているのが、配列の長さが N であるときの `0 <= K < N'
なる整数 K か、あるいは
要素の範囲を表すスライスオブジェクトでなければならないということです。
(後方互換性のため、`__getslice__()' (以下参照) を
定義して、拡張されていない単純なスライスを扱うようにもできます。)
変更可能な配列では、Python の標準リストオブジェクトのように、 メソッド
`append()'、 `count()'、 `index()'、`extend()'、`insert()'、 `pop()'、
`remove()'、`reverse()'、および`sort()' を 提供しなければなりません。
マップ型でも、Python の標準辞書オブジェクトのように、 `keys()'、
`values()'、 `items()'、 `has_key()'、 `get()'、 `clear()'、
`setdefault()'、`iterkeys()'、 `itervalues()'、 `iteritems()'、
`pop()'、 `popitem()'、 `copy()'、 および `update()'
といったメソッドをマップ型 で提供するよう推奨しています。`UserDict'
モジュールでは、 これらのメソッドを`__getitem__()'、 `__setitem__()'、
`__delitem__()'、および `keys()' といった基本セットから
作成する上で役に立つ `DictMixin' クラスを提供しています。
最後に、配列型では以下に述べるメソッド群 `__add__()'、 `__radd__()'、
`__iadd__()'、`__mul__()'、 `__rmul__()'、および `__imul__()'
を定義して、 (配列間の結合を意味する) 加算操作と (要素の繰り返しを
意味する) 乗算操作を実装しなければなりません; `__coerce__()'
や、その他の数値演算子を定義してはなりません。 マップでも配列でも、`in'
演算子が有効利用できるように `__contains__()'
メソッドの定義を推奨します; マップ型では、 `in' は`has_key()'
と等価でなければなりません; 配列では、
配列内の値にわたって検索を行わなければなりません。さらに、
マップでも配列でも、コンテナ内にわたる反復操作ができるようにするため、
`__iter__()' を実装するよう勧めます; マップ型の場合、 `__iter__()' は
`iterkeys()' と等価でなければなりません;
配列の場合、配列内の値にわたって反復操作を行わなければなりません。

`__len__(self)'
     組み込み関数 `len()'  を実現するために
     呼び出されます。オブジェクトの長さを `>=' 0 である整数で
     返さなければなりません。また、オブジェクトが `__nonzero__()'
     メソッドを定義しておらず、`__len__()' メソッドがゼロを
     返す場合には、ブール演算コンテキストでは偽であるとみなされます。

`__getitem__(self, key)'
     `SELF[KEY]' の値評価 (evaluation) を実現するために 呼び出されます。
     配列の場合、キーとして整数とスライスオブジェクトを受理できなければ
     なりません。   (配列型をエミュレートする場合)
     負のインデクスの解釈は `__getitem__()' メソッド次第と
     なります。KEY が不適切な型であった場合、`TypeError'
     を送出してもかまいません; (負のインデクス値に対して何らかの解釈
     を行った上で) KEY が配列のインデクス集合外の値である場合、
     `IndexError' を送出しなければなりません。 _Note:_ `for'
     ループでは、配列の終端を正しく検出できるように
     するために、不正なインデクスに対して `IndexError'
     が送出されるものと期待しています。

`__setitem__(self, key, value)'
     `SELF[KEY]' に対する代入を実現するために呼び出されます。
     `__getitem__()' と同じ注意事項があてはまります。
     このメソッドを実装できるのは、あるキーに対する値の変更をサポートしているか、
     新たなキーを追加できるようなマップの場合と、ある要素を置き換えることができる
     配列の場合だけです。不正な KEY に対しては、`__getitem__()'
     メソッドと同様の例外の送出を行わなければなりません。

`__delitem__(self, key)'
     `SELF[KEY]' の削除を実現するために呼び出されます。 `__getitem__()'
     と同じ注意事項があてはまります。
     このメソッドを実装できるのは、キーの削除をサポートしているマップの場合と、
     要素を削除できる配列の場合だけです。 不正な KEY
     に対しては、`__getitem__()'
     メソッドと同様の例外の送出を行わなければなりません。

`__iter__(self)'
     このメソッドは、コンテナに対してイテレータが要求された際に呼び出されます。
     このメソッドは、コンテナ内の全てのオブジェクトにわたる反復処理ができる
     ような、新たなイテレータオブジェクトを返さなければなりません。
     マップの場合、コンテナ内のキーに渡る反復処理でなければならず、
     かつ`iterkeys()' によって利用できなければなりません。

     イテレータオブジェクトでもこのメソッドを実装する必要があります;
     イテレータの場合、自分自身を返さなければなりません。イテレータオブジェクト
     に関するより詳細な情報は、

     の "イテレータ型" を参照してください。

メンバシップテスト演算子 (`in' および `not in') は通常、
配列に渡る反復処理を使って実装されます。しかし、コンテナオブジェクト
で以下の特殊メソッドを定義して、より効率的な実装を行ったり、オブジェクト
が配列でなくてもよいようにできます。

`__contains__(self, item)'
     メンバシップテスト演算を実現するために呼び出されます。 ITEM が
     SELF 内に存在する場合には真を、そうでない場合には
     偽を返さなければなりません。マップオブジェクトの場合、値やキーと値の
     組ではなく、キーに対するメンバシップテストを考えなければなりません。


File: python-ref-jp.info,  Node: 配列型エミュレーションで使われるその他のメソッド,  Next: 数値型をエミュレーションする,  Prev: コンテナをエミュレートする,  Up: 特殊メソッド名

配列型エミュレーションで使われるその他のメソッド
------------------------------------------------

以下のオプションとなるメソッドを定義して、配列オブジェクトをより高度に
エミュレーションできます。変更不能な配列のメソッドでは、
`__getslice__()' が定義できるだけです; 変更可能な配列では
三つのメソッド全てを定義できます。

`__getslice__(self, i, j)'
     _This is deprecated in Python 2.0.  スライスオブジェクトは
     `__getitem__()' メソッドの
     パラメタとしてサポートするようになりました。_ `SELF[I:J]'
     の値評価を実現するために呼び出され ます。返されるオブジェクトは
     SELF と同じ型でなければなりません。 スライス表記で I や J
     がない場合には、それぞれゼロや `sys.maxint'
     に置き換えられるので注意してください。
     スライスに負のインデクスが用いられた場合、配列の長さがインデクス値に
     加算されます。インスタンスが `__len__()' メソッドを実装して
     いない場合には、`AttributeError' が送出されます。
     この計算の結果、インデクス値が負でなくなるという保証はありません。
     配列の長さよりも大きなインデクス値は修正されません。
     `__getslice__()' が定義されていない場合、代わりに
     スライスオブジェクトが生成されて `__getitem__()' に渡されます。

`__setslice__(self, i, j, sequence)'
     `SELF[I:J]' への代入を実現するために呼び出され ます。I および J
     に関しては、`__getslice__()' と同じ注釈があてはまります。

     このメソッドは撤廃されています。 `__setslice__()' がないか、
     `SELF[I:J:K]' 形式の拡張スライス の場合には、`__setslice__()'
     が呼ばれる代わりにスライス オブジェクトが生成され、`__setitem__()'
     に渡されます。

`__delslice__(self, i, j)'
     `SELF[I:J]' の削除を実現するために 呼び出されます。I および J
     に関しては、`__getslice__()' と同じ注釈があてはまります。

     このメソッドは撤廃されています。 `__delslice__()' がないか、
     `SELF[I:J:K]' 形式の拡張スライス の場合には、`__delslice__()'
     が呼ばれる代わりにスライス オブジェクトが生成され、`__delitem__()'
     に渡されます。

これらのメソッドは、単一のコロンを使った単一のスライスで、かつ
スライスメソッドが利用できるときにだけ呼び出されることに注意
してください。拡張スライス表記を含んでいるスライス表記や、
スライスメソッドがない場合、`__getitem__()'、 `__setitem__()'
、あるいは `__delitem__()' が
スライスオブジェクトを引数として呼び出されます。

以下の例は、プログラムやモジュールを以前のバージョンの Python
に対して互換性を持たせる方法を示したものです (`__getitem__()'、
`__setitem__()' 、および `__delitem__()'
は引数としてスライスオブジェクトを サポートするものと仮定します):

     class MyClass:
         ...
         def __getitem__(self, index):
             ...
         def __setitem__(self, index, value):
             ...
         def __delitem__(self, index):
             ...
     
         if sys.version_info < (2, 0):
             # They won't be defined if version is at least 2.0 final
     
             def __getslice__(self, i, j):
                 return self[max(0, i):max(0, j):]
             def __setslice__(self, i, j, seq):
                 self[max(0, i):max(0, j):] = seq
             def __delslice__(self, i, j):
                 del self[max(0, i):max(0, j):]
         ...

`max()' を呼び出していることに注意してください; この呼び出し
`__*slice__()' メソッド呼び出される前に、負のインデクス値を処理
しておくために必要です。 負のインデクス値が使われた場合、 `__*item__()'
メソッドは与えら れた値をそのまま使いますが、`__*slice__()' メソッドは
"調理済みの (cooked)" 形式になったインデクス値を受け取ります。
負のインデクス値が使われると、メソッドを呼び出す前に、常に配列の長さを
インデクス値に加算します (加算してもまだ負の値となっていてもかまいませ
ん); これは、組み込み配列型における慣習的な負のインデクス処理方法で、
`__*item__()' メソッドでも同様の処理を行うよう期待しています。
しかし、ここではすでに負のインデクス値の処理を行っているので、負のイン
デクスを渡すべきではありません; インデクス値は、`__*item__()'
メソッドに渡される前に、配列のインデクス集合の境界に制限されていなけれ
ばなりません。`max(0, i)' を呼び出せば、適切な値を返すので便利です。


File: python-ref-jp.info,  Node: 数値型をエミュレーションする,  Next: 型強制規則 coercion rule,  Prev: 配列型エミュレーションで使われるその他のメソッド,  Up: 特殊メソッド名

数値型をエミュレーションする
----------------------------

以下のメソッドを定義して、数値型オブジェクトをエミュレートすることがで
きます。特定の種類の数値型ではサポートされていないような演算に対応する
メソッド (非整数の数値に対するビット単位演算など) は、未定義のままにし
ておかなければなりません。

`__add__(self, other)'

`__sub__(self, other)'

`__mul__(self, other)'

`__floordiv__(self, other)'

`__mod__(self, other)'

`__divmod__(self, other)'

`__pow__(self, other[, modulo])'

`__lshift__(self, other)'

`__rshift__(self, other)'

`__and__(self, other)'

`__xor__(self, other)'

`__or__(self, other)'
     これらのメソッドは、二項算術演算 ( `-', `*', `//', `%', `divmod()'
     , `pow()' , `**', `<'`<', `>'`>', `&', `^', `|')
     を実現するために呼び出されます。例えば、式 X`+'Y の場合、X が
     `__add__()' メソッドをもつクラスのインスタン
     スであれば、`X.__add__(Y)' が呼び出されます。 `__divmod__()'
     メソッドは、`__floordiv__()' と `__mod__()'
     を使った場合と等価にならなければなりません; `__truediv__()'
     (下記参照) と関連づける必要はありません。
     組み込みの三項演算子バージョンの関数 `pow()'
     をサポートする場合には、 `__pow__()'
     は、オプションとなる第三の引数を受け取れなくては なりません。

`__div__(self, other)'

`__truediv__(self, other)'
     除算演算 (`/') は、これらのメソッドで実現されています。
     `__truediv__()' は、 `__future__.division' が有効であると
     きに使われます。それ以外の場合には `__div__()' が使われますs。
     二つのメソッドのうち一方しか定義されていなければ、オブジェクトは
     他方の演算コンテキストをサポートしなくなります; このとき、
     `TypeError' が送出されます。

`__radd__(self, other)'

`__rsub__(self, other)'

`__rmul__(self, other)'

`__rdiv__(self, other)'

`__rtruediv__(self, other)'

`__rfloordiv__(self, other)'

`__rmod__(self, other)'

`__rdivmod__(self, other)'

`__rpow__(self, other)'

`__rlshift__(self, other)'

`__rrshift__(self, other)'

`__rand__(self, other)'

`__rxor__(self, other)'

`__ror__(self, other)'
     これらのメソッドは二項算術演算 (`+', `-', `*', `/', `%', `divmod()'
     , `pow()' , `**', `<'`<', `>'`>', `&', `^', `|')
     を実現しますが、メソッド呼び出しが行われ る被演算子が逆転して
     (reflected, swapped: 入れ替えられて) います。
     これらの関数は、左側の被演算子が対応する演算をサポートしていない場合に
     のみ呼び出されます。例えば、X`-'Y において、 Y が `__rsub__()'
     メソッドを持つクラスのインスタンスであ る場合、`Y.__rsub__(X)'
     が呼び出されます。三項演算子 `pow()'  が `__rpow__()' を呼ぶことは
     ないので注意してください (型強制の規則が非常に難解になるからです)。

`__iadd__(self, other)'

`__isub__(self, other)'

`__imul__(self, other)'

`__idiv__(self, other)'

`__itruediv__(self, other)'

`__ifloordiv__(self, other)'

`__imod__(self, other)'

`__ipow__(self, other[, modulo])'

`__ilshift__(self, other)'

`__irshift__(self, other)'

`__iand__(self, other)'

`__ixor__(self, other)'

`__ior__(self, other)'
     これらのメソッドは、累算算術演算 (augmented arithmetic operations,
     `+=', `-=', `*=', `/=', `%=', `**=', `<'`<=', `>'`>=', `&=', `^=',
     `|=') を実現するために呼び出されます。 これらのメソッドでは、(SELF
     の値を変更することで) 演算を インプレースで行うよう試み、その結果
     (インプレースで演算を行えない場合や、行ってはならない場合には SELF
     自体) を返さなければなりません。
     特定のメソッドが定義されていない場合、その累算算術演算は通常のメソッド
     で代用されます。例えば、X`+='Y を評価する際、 X が `__iadd__()'
     メソッドを持つクラスのインスタンスで あれば、`X.__iadd__(Y)'
     が呼び出されます。反対に、 X が `__iadd()'
     メソッドを持たないクラスのインスタンスで あれば、X`+'Y に基づいて
     `X.__add__(Y)' および `Y.__radd__(X)' を考慮します。

`__neg__(self)'

`__pos__(self)'

`__abs__(self)'

`__invert__(self)'
     単項算術演算 (`-', `+', `abs()'  および `~{}')
     を実現するために呼び出されます。

`__complex__(self)'

`__int__(self)'

`__long__(self)'

`__float__(self)'
     組み込み関数 `complex()' , `int()' , `long()' , および `float()'
     を実現するために呼び出さ
     れます。適切な型の値を返さなければなりません。

`__oct__(self)'

`__hex__(self)'
     組み込み関数 `oct()'  および `hex()'
     を実現するために呼び出されます。文字列型を返さなければなりません。

`__coerce__(self, other)'
     "型混合モード (mixed-mode)" での数値間の算術演算を実現するために
     呼び出されます。 SELF と OTHER を共通の数値型に変換して、 2
     要素のタプルにして返すか、不可能な場合には `None' を返さなけれ
     ばなりません。共通の型が `other' の型になる場合、 `None' を
     返すだけで十分です。この場合、インタプリタはもう一方のオブジェクトを調
     べて型強制を行おうとするからです
     (とはいえ、もう一方の値の型が実装上変 更できない場合には、ここで
     SELF を OTHER の型に変換してお いた方が便利です)。戻り値に
     `NotImplemented' を使うのは、 `None' を返すのと同じです。


File: python-ref-jp.info,  Node: 型強制規則 coercion rule,  Prev: 数値型をエミュレーションする,  Up: 特殊メソッド名

型強制規則 (coercion rule)
--------------------------

本節では、型強制 (coercion) に関する規則について記述します。
プログラム言語が進化するにつれ、型強制規則について正確に
記述するのは難しくなってゆきます; 従って、あるバージョンのある
実装について記述するのは望ましくありません。その代わりに、
型強制に関する非公式的なガイドラインを示しておきます。 Python 3.0
からは、型強制がサポートされなくなる予定です。

   * % 演算子の左被演算子が文字列か Unicode オブジェクトの場合、
     型強制は起きず、文字列としての書式化操作が呼び出されます。

   * 型強制演算の定義はもはや推奨されていません。
     型強制を定義していない混合型 (mixed-mode) 演算は、
     もとの引数をそのまま演算操作に渡すようになっています。

   * 新しい形式のクラス (`object' から導出されたもの) が、
     二項演算子に対して `__coerce__()' メソッドを呼び出すことは
     ありません。; `__coerce__()' が呼び出されるのは、組み込み 関数
     `coerce()' が呼び出されたときだけです。

   * 事実上、 `NotImplemented' を返す演算子は、全く実装されていないも
     のとして扱われます。

   * 以下の説明では、`__op__()' および `__rop__()' は、演算子
     に相当する一般的なメソッド名を表すために使われます; `__iop__'
     はインプレース演算子を表します。例えば、演算子 ``+'' の場合、
     `__add__()' および `__radd__()' がそれぞれ左右の被演算子
     用の二項演算子として使われ、`__iadd__' がインプレース演算用の演
     算子として使われる、といった具合です。

   * オブジェクト X および Y に対して、 まず `X.__op__(Y)'
     が試されます。この演算が実装されて いないか、`NotImplemented'
     を返す場合、次に `Y.__rop__(X)'
     が試されます。この演算も実装されていな いか、`NotImplemented'
     を返すなら、 `TypeError'
     例外が送出されます。ただし、以下の例外があるので参照してください:

   * 前項に対する例外:
     左被演算子が組み込み型や新形式クラスのインスタンスで
     あり、かつ右被演算子が左被演算子と同じクラスか適切なサブクラスのインス
     タンスである場合、左被演算子の `__op__()' メソッドを試す _前に_
     右被演算子の `__rop__()' が試されます。
     これは、サブクラス側で二項演算子を完全にオーバライドできるようにするた
     めです。そうしなければ、常に左被演算子の __op__
     メソッドが右被演算子を 受理してしまいます:
     あるクラスのインスタンスが被演算子になるとされてい
     る場合、そのサブクラスのインスタンスもまた受理可能だからです。

   * 双方の被演算子が型強制を定義している場合、型強制は被演算子の型の
     `__op__()' や `__rop__()' メソッドが呼び出される前に呼
     び出され、それより早くなることはありません。型強制の結果、型強制を行う
     ことになったいずれの被演算子とも異なる型が返された場合、返されたオブジェ
     クトの新たな型を使って、この過程が部分的に再度行われます。

   * (``+='' のような) インプレース型の演算子を用いる際、左被演算子が
     `__iop__()' を実装していれば、`__iop__()' が呼び出され、
     方強制は一切行われません。演算が `__op__()' かつ/または
     `__rop__()' に帰着した場合、通常の型強制規則が適用されます。

   * X`+'Y において、 X が結合 (concatenation) 演算
     を実装している配列であれば、配列の結合が実行されます。

   * X`*'Y において、一方の演算子が繰り返し (repeat) 演算
     を実装している配列であり、かつ他方が整数 (`int' または `long')
     である場合、配列の繰り返しが実行されます。

   * (`__eq__()' などのメソッドで実装されている) 拡張比較は、決して
     型強制を行いません。(`__cmp__()' で実装されている) 三値比較
     (three-way comparison)
     は、他の二項演算子で行われているのと同じ条件で 型強制を受けます。

   * 現在の実装では、組み込み数値型 `int', `long' および `float'
     は型強制を行いません; 一方、`complex' は型強制
     を使います。こうした違いは、これらの型をサブクラス化する際に顕在化して
     きます。そのうち、 `complex' 型についても型強制を避けるよう修正
     されるかもしれません。これらの型は全て、関数 `coerce()' から
     利用するための `__coerce__()' メソッドを実装しています。



File: python-ref-jp.info,  Node: 実行モデル,  Next: 式 expression,  Prev: データモデル,  Up: Top

実行モデル
**********

* Menu:

* 名前づけと束縛 naming and binding::
* 例外::


File: python-ref-jp.info,  Node: 名前づけと束縛 naming and binding,  Next: 例外,  Prev: 実行モデル,  Up: 実行モデル

名前づけと束縛 (naming and binding)
===================================

"名前 (name)"  とは、オブジェクトを参照する
ものを指します。名前への束縛 (name binding) 操作を行うと、
名前を導入できます。プログラムテキスト中に名前が出現するたびに、
その名前が使われている最も内側の関数ブロック中で作成された "束縛
(binding)"  を使って名前の 参照が行われます。

"ブロック (block)"  は、Python のプログラムテキスト
からなる断片で、一つの実行単位となるものです。
モジュール、関数本体、そしてクラス定義はブロックです。
また、対話的に入力された個々のコマンドもブロックです。
スクリプトファイル (インタプリタに標準入力として与えたり、
コマンドラインの第一引数として指定したファイル) は、コードブロック
です。スクリプトコマンド (インタプリタのコマンドライン上で `*-c*'
オプションを使って指定したコマンド) もコードブロック です。組み込み関数
`eval()' や `exec' 文に 渡した文字列もコードブロックになります。
組み込み関数 `input()' から読み取られ、評価される
式もまた、コードブロックです。

コードブロックは、"実行フレーム (execution frame)"
上で実行されます。実行フレームには、 (デバッグに使われる)
管理情報が収められています。また、
現在のコードブロックの実行が完了した際に、どのようにプログラムの
実行を継続するかを決定しています。

"スコープ (scope)"  は、ある名前があるブロック内で
参照できるかどうかを決めます。ローカル変数があるブロック内で定義されて
いる場合、変数のスコープはそのブロックを含みます。関数ブロック内で
名前の定義を行った場合、その名前に対して別の束縛を行っている
ブロックを除いた、関数内の全てのブロックを含むようにスコープが
拡張されます。
クラス内で定義された名前のスコープは、クラスのブロック内に制限
されます; スコープがメソッドのコードブロックを含むよう拡張される
ことはありません。

ある名前がコードブロック内で使われると、その名前を最も近傍から囲う
ようなスコープ (最内スコープ: nearest enclosing scope) を使って束縛の
解決を行います。こうしたスコープからなる、あるコードブロック内で
参照できるスコープ全ての集合は、ブロックの "環境 (environment)"
と呼ばれます。

ある名前がブロック内で束縛されている場合、名前はそのブロックに
おけるローカル変数 (local variable) です。
ある名前がモジュールレベルで束縛されている場合、名前は グローバル変数
(global variable) です。
(モジュールコードブロックの変数は、ローカル変数でもあるし、
グローバル変数でもあります。)
ある変数がコードブロック内で使われているが、そのブロックでは定義
されていない場合、変数は "自由変数 (free variable)" です。

ある名前の定義がどこにもない場合、 `NameError'
例外が送出されます。名前がまだ束縛されていないローカルな変数を参照
した場合、`UnboundLocalError'

例外が送出されます。`UnboundLocalError' は、 `NameError'
のサブクラスです。

名前への束縛は、以下の文構成 (construct): 関数の仮引数 (formal
parameter) 指定、`import' 文、クラスや関数の定義 (定義を行ったブロック中
で、クラスや関数名の束縛が行われます)、代入時に、代入対象が識別子
である場合、`for' ループのヘッダ、または第二形式の `except'
文ヘッダ、で行われます。 "`from...import *'"  形式の import 文は、
import しようとするモジュール内で定義されている名前について、
アンダースコアから始まっている名前以外の全てを束縛します。
この形式は、モジュールレベルでしか使うことができません。

`del' 文で指定された対象は、(`del' の意味付けは、 実際は名前の解放
(unbind) ですが) 文の目的上、束縛済みのもの
とみなされます。外側のスコープで参照されている名前の解放は、
不正な操作になります; コンパイラは `SyntaxError' を 報告するでしょう。

代入文や import 文はいずれも、クラスや関数定義、モジュールレベル
(トップレベルのコードブロック) 内で起こります。

ある名前束縛操作がコードブロック内のどこかにある場合、ブロック
内でその名前を使うと、全て現在のブロックで束縛されている名前を
指すものとみなされます。このため、ある名前が束縛される前に
ブロック内で使われるとエラーを引き起こす可能性があります。

この規則はやや微妙です。Python には宣言文がなく、コードブロックの
どこで名前束縛操作を行ってもかまいません。
あるコードブロックにおけるローカル変数は、
ブロック全体から名前束縛操作が行われている部分を走査して決定 します。

global 文で指定された名前がブロック内にある場合、その名前は
常にトップレベルの名前空間で束縛された名前を参照します。
それらの名前はグローバル名前空間、すなわちコードブロックが収め
られているモジュールの名前空間とモジュール名 `__builtin__'
で表される組み込み名前空間、を検索することによって、トップレベルの
名前空間で解決されます。グローバル名前空間は、常に最初に検索
されます。名前がグローバル名前空間中に見つからない場合、組み込み
名前空間が検索されます。global 文は、その名前が使われている全て
の文に先立って記述されていなければなりません。

あるコードブロックの実行時に関連付けられる組み込み名前空間は、
実際にはコードブロックのグローバル名前空間内に入っている名前
`__builtins__' を参照する形になっています; `__builtins__'
は辞書かモジュール (後者の場合にはモジュールの辞書が使われます)
でなければなりません。通常、`__builtins__' 名前空間は、
組み込みモジュール `__builtin__' (注意: `s' なし)
のモジュール辞書です。そうでない場合、制限実行 (restricted execution)
モードが有効になっています。

あるモジュールの名前空間は、そのモジュールが最初に import された
時に自動的に作成されます。スクリプトの主モジュール (main module)は 常に
`__main__'  と呼ばれます。

グローバル文は、同じブロックの束縛操作と同じスコープを持ちます。
ある自由変数の最内スコープに global 文がある場合、その自由変数は
グローバル変数とみなされます。

クラス定義は一つの実行文で、名前の使用や定義を行います。クラス定義
への参照は、通常の名前解決規則に従います。
クラス定義の名前空間は、そのクラスの属性辞書になります。
クラスのスコープで定義された名前は、メソッドからは見えません。

* Menu:

* 動的な機能とのやりとり::


File: python-ref-jp.info,  Node: 動的な機能とのやりとり,  Prev: 名前づけと束縛 naming and binding,  Up: 名前づけと束縛 naming and binding

動的な機能とのやりとり
----------------------

自由変数の入った入れ子スコープ (nested scope) を併用すると、 Python
の文が不正な文になる場合がいくつかあります。

ある変数がスコープの外側から参照された場合、その名前に対する
削除操作は不正になります。この場合、コンパイル時にエラーが
報告されることになります。

ワイルドカード形式の import 文  -- `import *' --
を関数内で使った場合や、関数が自由変数を含んでいたり、自由変数
を伴う入れ子ブロックである場合、コンパイラは SyntaxError を 送出します。

`exec' が関数内で使われており、関数が自由変数を含んでいたり、
自由変数を伴う入れ子ブロックである場合、`exec' に明示的に
ローカル名前空間を指定しないかぎりコンパイラは SyntaxError を
送出します。 (別の言い方をすれば、`exec obj'
は不正になることがあり、`exec obj in ns' はならない、という ことです。)

`eval()'、 `execfile()'、および `input()' 関数、そして `exec'
文は、名前の解決を行う際に、現在の環境
に対して完全にアクセスできるわけではありません。名前が呼び出し側の
ローカル名前空間やグローバル名前空間から解決されることはあります。
自由変数は最内名前空間ではなく、グローバル名前空間から解決されます。 (1)

`exec' 文と、関数 `eval()' および `execfile()'
にはオプションの引数があり、グローバルおよび
ローカル名前空間をオーバライドできます。名前空間を一つしか指定
しなければ、両方の名前空間として使われます。

---------- Footnotes ----------

(1)
この制限は、上記の操作によって実行されるコードが、モジュールをコンパイルしたときには利用できないために起こります。


File: python-ref-jp.info,  Node: 例外,  Prev: 名前づけと束縛 naming and binding,  Up: 実行モデル

例外
====

例外とは、コードブロックの通常の制御フローを中断して、
エラーやその他の例外的な状況を処理できるようにするための 手段です。
例外はエラーが検出された時点で _送出 (raise)_  されます;
例外は、エラーが発生部の周辺のコードブロックか、エラーが発生した
コードブロック直接または間接的に呼び出しているコードブロック で _処理
(handle)_  することが できます。

Python インタプリタは、ランタイムエラー (ゼロによる除算など) が
検出されると例外を送出します。Python プログラムから、`raise'
文を使って明示的に例外を送出することもできます。 例外ハンドラ
(exception handler) は、 `try' ... `except'
文で指定することができます。`try' ... `finally'
節を使うとクリーンアップコード (cleanup code) を指定できます。
このコードは例外は処理しませんが、先行するコードブロックで例外が
起きても起きなくても実行されます。

Python は、エラー処理に "プログラムの終了 (termination)"
モデルを用いています: 例外ハンドラは、
プログラムに何が発生したかを把握することができ、ハンドラの外側の
レベルに処理を継続することはできますが、(問題のあったコード部分を
最初から実行しなおすのでない限り) エラーの原因を修復したり、
実行に失敗した操作をやり直すことはできません。

例外が全く処理されない場合、インタプリタはプログラムの実行を終了させる
か、対話メインループに処理を戻します。どちらの場合も、 例外が
`SystemExit' でない限りバックトレース (backtrace) を出力します。

例外は、クラスインスタンスとして識別されます。 ある例外にどの except
節が一致するかの選択は、オブジェクトの
アイデンティティに基づいて行われます。 `except'
節は、同じクラスの例外か、基底クラスの例外 しか参照しません。

例外が発行されると、オブジェクト (`None' になることもあります) が例外の
_値 (value)_ として渡されます; このオブジェクトが
例外ハンドラの選択自体に影響することはありませんが、選択された例外
ハンドラに付帯情報として渡されます。
例外がクラスの場合、オブジェクトは送出された例外クラスのインスタンス
でなければなりません。

_Notice:_ [warning] 例外に対するメッセージは、Python API
仕様には含まれていません。 メッセージの内容は、ある Python
のバージョンから次のバージョンに
なるときに、警告なしに変更される可能性があります。したがって、
複数バージョンのインタプリタで動作するようなコードにおいては、
例外メッセージの内容に依存した記述をすべきではありません。

`try' 文については、~*Note try 文:: 節、 `raise' 文については ~*Note
raise 文:: 節も参照してください。


File: python-ref-jp.info,  Node: 式 expression,  Next: 単純文 simple statement,  Prev: 実行モデル,  Up: Top

式 (expression)
***************

この章では、Python の式における個々の要素の意味について解説します。

*表記法に関する注意:* この章と以降の章での拡張BNF (extended BNF)
表記は、字句解析規則ではなく、構文規則を記述する
ために用いられています。ある構文規則 (のある表現方法) が、以下の形式

     [*]

`name `othername''

で記述されていて、この構文特有の意味付け (semantics)
が記述されていない場合、 `name'
の形式をとる構文の意味付けは、`othername' の意味付けと同じになります。

* Menu:

* 算術変換 arithmetic conversion::
* アトム、原子的要素 atom::
* 一次語 primary::
* べき乗演算 power operator::
* 単項算術演算 unary arithmetic operation::
* 二項算術演算 binary arithmetic operation::
* シフト演算 shifting operation::
* ビット単位演算の二項演算 binary bit-wise operation::
* 比較 comparison::
* ブール演算 boolean operation::
* ラムダ lambda::
* 式のリスト::
* 評価順序::
* まとめ::


File: python-ref-jp.info,  Node: 算術変換 arithmetic conversion,  Next: アトム、原子的要素 atom,  Prev: 式 expression,  Up: 式 expression

算術変換 (arithmetic conversion)
================================

以下の算術演算子の記述で、「数値引数は共通の型に変換されます」と
書かれている場合、引数は *Note データモデル:: 章の末尾に記載されている
型強制規則に基づいて型強制されます。引数がいずれも標準の数値型
である場合、以下の型強制が適用されます:

   * 片方の引数が複素数型であれば、他方は複素数型に変換されます;

   * それ以外の場合で、片方の引数が浮動小数点数であれば、他方は
     浮動小数点型に変換されます;

   * それ以外の場合で、片方の引数が長整数型であれば、他方は
     長整数型に変換されます;

   * それ以外の場合で、両方の引数が通常の整数型であれば、変換の
     必要はありません。

特定の演算子 (文字列を左引数とする `%' 演算子など) では、さらに
別の規則が適用されます。拡張をおこなうことで、個々の演算子に対する
型強制を定義できます。


File: python-ref-jp.info,  Node: アトム、原子的要素 atom,  Next: 一次語 primary,  Prev: 算術変換 arithmetic conversion,  Up: 式 expression

アトム、原子的要素 (atom)
=========================

アトム (原子的要素: atom) は、式を構成する基本単位です。もっとも単純な
アトムは、識別子またはリテラルになります。逆クオートや丸括弧、波括弧、
または角括弧で囲われた形式 (form) もまた、文法的にはアトムに分類
されます。アトムの構文定義は以下のようになります:

`atom `identifier' | `literal' | `enclosure''

`enclosure `parenth_form' | `list_display''

` | `dict_display' | `string_conversion''

* Menu:

* 識別子 identifier、または名前 name::
* リテラル::
* 丸括弧形式 parenthesized form::
* リスト表現::
* 辞書表現::
* 文字列変換::


File: python-ref-jp.info,  Node: 識別子 identifier、または名前 name,  Next: リテラル,  Prev: アトム、原子的要素 atom,  Up: アトム、原子的要素 atom

識別子 (identifier、または名前 (name))
--------------------------------------

アトムの形になっている識別子 (identifier) は名前 (name) です。
名前づけや束縛については、*Note 名前づけと束縛 naming and binding::
節を参照してください。

名前があるオブジェクトに束縛されている場合、名前アトムを評価すると
そのオブジェクトになります。名前が束縛されていない場合、アトムを
評価しようとすると`NameError' 例外を送出します。

*プライベートな名前の難号化 (mangling):*
クラス定義内にテキストの形で書かれた識別子で、二つ以上のアンダースコア
から始まり、末尾が二つ以上のアンダースコアになっていないものは、
そのクラスの "プライベートな名前 (private name)" とみなされます。
プライベートな名前は、コードが生成される前に、より長い形式の名前に
変換されます。この変換では、クラス名の先頭にあるアンダースコアを全て
はぎとり、先頭にアンダースコアを一つ挿入して、名前の前に付加します。
例えば、クラス `Ham' 内の識別子 `__spam' は、 `_Ham__spam'
に変換されます。変換は識別子が使われている構文的
コンテキストとは独立しています。変換された名前が非常に長い (255
文字以上) の場合には、実装によっては名前の切り詰めが起きる
かもしれません。クラス名がアンダースコアだけから成り立つ場合には、
変換は行われません。


File: python-ref-jp.info,  Node: リテラル,  Next: 丸括弧形式 parenthesized form,  Prev: 識別子 identifier、または名前 name,  Up: アトム、原子的要素 atom

リテラル
--------

Python では、文字列リテラルと、様々な数値リテラルをサポートしています:

`literal `stringliteral' | `integer' | `longinteger''

` | `floatnumber' | `imagnumber''

リテラルを評価すると、指定した型 (文字列、整数、長整数、
浮動小数点数、複素数) の指定した値を持つオブジェクトになります。
浮動小数点や虚数 (複素数) リテラルの場合、値は近似値になる場合
があります。詳しくは *Note リテラル literal:: を参照してください。
リテラルは全て変更不能なデータ型に対応します。このため、オブジェクト
のアイデンティティはオブジェクトの値ほど重要ではありません。
同じ値を持つ複数のリテラルを評価した場合、(それらのリテラルが
プログラムの同じ場所由来のものであっても、そうでなくても)
同じオブジェクトを指しているか、まったく同じ値を持つ別の
オブジェクトになります。


File: python-ref-jp.info,  Node: 丸括弧形式 parenthesized form,  Next: リスト表現,  Prev: リテラル,  Up: アトム、原子的要素 atom

丸括弧形式 (parenthesized form)
-------------------------------

丸括弧形式とは、式リストの一形態で、丸括弧で囲ったものです:

`parenth_form "(" [`expression_list'] ")"'

丸括弧で囲われた式のリストは、個々の式が表現するものになります:
リスト内に少なくとも一つのカンマが入っていた場合、タプルになります;
そうでない場合、式のリストを構成している単一の式自体の値になります。

中身が空の丸括弧のペアは、空のタプルオブジェクトを表します。
タプルは変更不能なので、リテラルと同じ規則が適用されます (すなわち、
空のタプルが二箇所で使われると、それらは同じオブジェクトになることも
あるし、ならないこともあります)。

タプルは丸括弧で作成されるのではなく、カンマによって作成される
ことに注意してください。例外は空のタプルで、この場合には
丸括弧が_必要です_ -- 丸括弧のつかない、 "何も記述しない式 (nothing)"
を使えるようにしてしまうと、
文法があいまいなものになってしまい、よくあるタイプミスが検出されなく
なってしまいます。


File: python-ref-jp.info,  Node: リスト表現,  Next: 辞書表現,  Prev: 丸括弧形式 parenthesized form,  Up: アトム、原子的要素 atom

リスト表現
----------

リスト表現は、角括弧で囲われた式の系列です。系列は空の系列であっても
かまいません:

`test `and_test' ( "or" `and_test' )* | `lambda_form''

`testlist `test' ( "," `test' )* [ "," ]'

`list_display "[" [`listmaker'] "]"'

`listmaker `expression' ( `list_for' | ( "," `expression' )* [","] )'

`list_iter `list_for' | `list_if''

`list_for "for" `expression_list' "in" `testlist' [`list_iter']'

`list_if "if" `test' [`list_iter']'

リスト表現は、新に作成されたリストオブジェクトを表します。
新たなリストの内容は、式のリストを与えるか、リストの内包表記 (list
comprehension) で指定します。
カンマで区切られた式のリストを与えた場合、リストの各要素は左から
右へと順に評価され、評価された順番にリスト内に配置されます。
リストの内包表記を与える場合、内包表記はまず単一の式、続いて
少なくとも一つの `for' 節、続いてゼロ個以上の `for' 節か、`if'
節になります。 この場合、新たに作成されるリストの各要素は、各々の `for'
や `if' 節を左から右の順にネストしたブロックとみなして実行し、
ネストの最内ブロックに到達する度に式を評価した値となります。


File: python-ref-jp.info,  Node: 辞書表現,  Next: 文字列変換,  Prev: リスト表現,  Up: アトム、原子的要素 atom

辞書表現
--------

辞書表現は、波括弧で囲われた、キーと値のペアからなる系列です。
系列は空の系列であってもかまいません:

`dict_display "{" [`key_datum_list'] "}"'

`key_datum_list `key_datum' ("," `key_datum')* [","]'

`key_datum `expression' ":" `expression''

辞書表現は、新たな辞書オブジェクトを表します。

キー/データのペアは、左から右へと評価され、その結果が辞書の各
エントリを決定します: 各キーオブジェクトは、対応するデータを
辞書に記憶するためのキーとして用いられます。

キーの値として使える型に関する制限は、*Note 標準型の階層:: 節ですでに
列挙しています。(一言でいうと、キーは変更可能なオブジェクトを
全て排除したハッシュ可能な型でなければなりません。)
重複するキー間で衝突が起きても、衝突が検出されることはありません;
あるキーに対して、最後に渡されたデータ (プログラムテキスト上では、
辞書表記の最も右側値となるもの) が使われます。


File: python-ref-jp.info,  Node: 文字列変換,  Prev: 辞書表現,  Up: アトム、原子的要素 atom

文字列変換
----------

文字列変換は、逆クオート (reverse quite, 別名バッククオート: backward
quote) で囲われた式のリストです:

`string_conversion "`" `expression_list' "`"'

文字列変換は、逆クオート内の式リストを評価して、評価結果の
オブジェクトを各オブジェクトの型特有の規則に従って文字列に 変換します。

オブジェクトが文字列、数値、`None' か、それらの型のオブジェクト
のみを含むタプル、リストまたは辞書の場合、評価結果の文字列は 有効な
Python 式となり、組み込み関数 `eval()' に渡した 場合に同じ値となります
(浮動小数点が含まれている場合には近似値の 場合もあります)。

(特に、文字列を変換すると、値を安全に出力するために文字列の両側に
クオートが付けられ、"変 (funny) な" 文字はエスケープシーケンスに
変換されます。)

再帰的な構造をもつオブジェクト (例えば自分自身を直接または間接的に
含むリストや辞書) では、`...' を使って再帰的参照であることが
示され、オブジェクトの評価結果は `eval()' に渡しても
等価な値を得ることができません (`SyntaxError' が 送出されます)。

組み込み関数 `repr()' は、括弧内の引数に対して、
逆クオート表記で囲われた中身と全く同じ変換を実行します。 組み込み関数
`str()' は似たような動作をしますが、
もっとユーザフレンドリな変換になります。


File: python-ref-jp.info,  Node: 一次語 primary,  Next: べき乗演算 power operator,  Prev: アトム、原子的要素 atom,  Up: 式 expression

一次語 (primary)
================

一次語は、言語において最も結合の強い操作を表します。
文法は以下のようになります:

`primary `atom' | `attributeref' | `subscription' | `slicing' | `call''

* Menu:

* 属性参照::
* 添字表記 subscription::
* スライス表記 slicing::
* 呼び出し call::


File: python-ref-jp.info,  Node: 属性参照,  Next: 添字表記 subscription,  Prev: 一次語 primary,  Up: 一次語 primary

属性参照
--------

属性参照は、一次語の後ろにピリオドと名前を連ねたものです:

`attributeref `primary' "." `identifier''

一次語の値評価結果は、例えばモジュール、リスト、インスタンスと
いった、属性参照をサポートする型でなければなりません。
オブジェクトは次に、指定した名前が識別子名と
なっているような属性を生成するよう問い合わせされます。
問い合わせた属性が得られない場合、例外 `AttributeError'  が送出
されます。それ以外の場合、オブジェクトは属性オブジェクトの型と
値を決定し、生成して返します。同じ属性参照を複数回評価したとき、
互いに異なる属性オブジェクトになることがあります。

