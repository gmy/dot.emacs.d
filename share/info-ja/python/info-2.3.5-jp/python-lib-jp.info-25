This is python-lib-jp.info, produced by makeinfo version 4.5 from
python-lib-jp.texi.

12 October 2005


File: python-lib-jp.info,  Node: ハッシュ、BTree、およびレコードオブジェクト,  Prev: bsddb,  Up: bsddb

ハッシュ、BTree、およびレコードオブジェクト
-------------------------------------------

インスタンス化したハッシュ、B-Tree, およびレコードオブジェクトは
辞書型と同じメソッドをサポートするようになります。加えて、以下に
列挙したメソッドもサポートします。 _Changed in Python version 2.3.1_

`close()'
     データベースの背後にあるファイルを閉じます。オブジェクトはアクセスできなく
     なります。これらのオブジェクトには `oepn' メソッドがないため、
     再度ファイルを開くためには、新たな `bsddb' モジュールを開く
     関数を呼び出さなくてはなりません。

`keys()'
     DB ファイルに収められているキーからなるリストを返します。リスト内の
     キーの順番は決まっておらず、あてにはなりません。特に、異なるファイル
     形式の DB 間では返されるリストの順番が異なります。

`has_key(key)'
     引数 KEY が DB ファイルにキーとして含まれている場合 `1'
     を返します。

`set_location(key)'
     カーソルを KEY で示される要素に移動し、キー及び値からなる
     タプルを返します。(`bopen' を使って開かれる) B-Tree
     データベースでは、KEY が実際にはデータベース内に存在しなかった
     場合、カーソルは並び順が KEY の次に来るような要素を指し、
     その場所のキー及び値が返されます。
     他のデータベースでは、データベース中に KEY が見つからなかった 場合
     `KeyError' が送出されます。

`first()'
     カーソルを DB ファイルの最初の要素に設定し、その要素を返します。
     B-Tree データベースの場合を除き、ファイル中のキーの順番は決まって
     いません。

`next()'
     カーソルを DB ファイルの次の要素に設定し、その要素を返します。
     B-Tree データベースの場合を除き、ファイル中のキーの順番は決まって
     いません。

`previous()'
     カーソルを DB ファイルの直前の要素に設定し、その要素を返します。
     B-Tree データベースの場合を除き、ファイル中のキーの順番は決まって
     いません。 (`hashopen()' で開かれるような)  ハッシュ表データベース
     ではサポートされていません。

`last()'
     カーソルを DB ファイルの最後の要素に設定し、その要素を返します。
     ファイル中のキーの順番は決まっていません。 (`hashopen()'
     で開かれるような)  ハッシュ表データベース
     ではサポートされていません。

`sync()'
     ディスク上のファイルをデータベースに同期させます。

以下はプログラム例です:

     >>> import bsddb
     >>> db = bsddb.btopen('/tmp/spam.db', 'c')
     >>> for i in range(10): db['%d'%i] = '%d'% (i*i)
     ...
     >>> db['3']
     '9'
     >>> db.keys()
     ['0', '1', '2', '3', '4', '5', '6', '7', '8', '9']
     >>> db.first()
     ('0', '0')
     >>> db.next()
     ('1', '1')
     >>> db.last()
     ('9', '81')
     >>> db.set_location('2')
     ('2', '4')
     >>> db.previous()
     ('1', '1')
     >>> for k, v in db.iteritems():
     ...     print k, v
     0 0
     1 1
     2 4
     3 9
     4 16
     5 25
     6 36
     7 49
     8 64
     9 81
     >>> '8' in db
     True
     >>> db.sync()
     0


File: python-lib-jp.info,  Node: dumbdbm,  Next: zlib,  Prev: bsddb,  Up: オプションのオペレーティングシステムサービス

可搬性のある DBM 実装
=====================

単純な DBM インタフェースに対する可搬性のある実装。

_Notice:_ `dumbdbm' モジュールは、 `anydbm' が安定なモジュールを
他に見つけることができなかった際の最後の手段とされています。 `dumbdbm'
モジュールは速度を重視して書かれているわけではなく、
他のデータベースモジュールのように重い使い方をするためのものでは
ありません。

`dumbdbm' モジュールは永続性辞書に類似したインタフェースを 提供し、全て
Python で書かれています。 `gdbm' や `bsddb' といったモジュールと異なり、
外部ライブラリは必要ありません。他の永続性マップ型のように、
キーおよび値は常に文字列でなければなりません。

このモジュールでは以下の内容を定義してします:

`error'
     I/O エラーのような dumbdbm 特有のエラーの際に送出されます。
     不正なキーを指定したときのような、一般的な対応付けエラーの際には
     `KeyError' が送出されます。

`open(filename[, flag[, mode]])'
     dumbdbm データベースを開き、 dubmdbm オブジェクトを返します。
     FILENAME 引数はデータベースファイル名の雛型 (特定の拡張子を
     もたないもの) です。dumbdbm データベースが生成される際、 `.dat'
     および `.dir' の拡張子を持ったファイルが生成されます。

     オプションの FLAG 引数は現状では無視されます; データベースは
     常に更新のために開かれ、存在しない場合には新たに作成されます。

     オプションの MODE 引数は UNIX におけるファイルのモードで、
     データベースを作成する際に使われます。デフォルトでは 8 進コード の
     `0666' になっています (umask によって修正を受けます)。 _Changed in
     Python version 2.2_

See also:
     *Note anydbm:: `dbm' 形式のデータベースに対する汎用インタフェース。
     *Note dbm:: DBM/NDBM ライブラリに対する同様のインタフェース。
     *Note gdbm:: GNU GDBM ライブラリに対する同様のインタフェース。
     *Note shelve:: 非文字列データを記録する永続化モジュール。 *Note
     whichdb::
     既存のデータベースの形式を判定するために使われるユーティリティモジュール。

* Menu:

* Dumbdbm オブジェクト::


File: python-lib-jp.info,  Node: Dumbdbm オブジェクト,  Prev: dumbdbm,  Up: dumbdbm

Dumbdbm オブジェクト
--------------------

`UserDict.DictMixin' クラスで提供されているメソッドに加え、 `dumbdbm'
オブジェクトでは以下のメソッドを提供しています。

`sync()'
     ディスク上の辞書とデータファイルを同期します。このメソッドは
     `Shelve' オブジェクトの `sync' メソッドから 呼び出されます。


File: python-lib-jp.info,  Node: zlib,  Next: gzip,  Prev: dumbdbm,  Up: オプションのオペレーティングシステムサービス

`gzip' 互換の圧縮
=================

`gzip' 互換の圧縮／解凍ルーチンへの低レベル インタフェース

このモジュールでは、データ圧縮を必要とするアプリケーションが zlib
ライブラリ を使って圧縮および解凍を行えるようにします。 zlib
ライブラリ自体の Web ホームページは <http://www.gzip.org/zlib/>
にある。2004 年 10 月の時点での最新バージョンは 1.2.1 です。可能なら
これ以降のバージョンを使うのがよいでしょう。 以前のバージョンの zlib
ライブラリにはこの Python モジュールと互換性
のない部分があることが知られています。

このモジュールで利用可能な例外と関数を以下に示します:

`error'
     圧縮および解凍時のエラーによって送出される例外。

`adler32(string[, value])'
     STRING のAdler-32 チェックサムを計算します。 （Adler-32
     チェックサムは、おおむね CRC32 と同等の信頼性を持ちながら
     はるかに高速に計算することができます。） VALUE
     が与えられていれば、VALUE はチェックサム計算の
     初期値として使われます。それ以外の場合には固定のデフォルト値が
     使われます。この機能によって、複数の入力文字列を結合したデータ全体
     にわたり、通しのチェックサムを計算することができます。
     このアルゴリズムは暗号法論的には強力とはいえないので、認証やデジタル
     署名などに用いるべきではありません。このアルゴリズムはチェックサム
     アルゴリズムとして用いるために設計されたものなので、汎用的な
     ハッシュアルゴリズムには向きません。

`compress(string[, level])'
     STRING で与えられた文字列を圧縮し、圧縮されたデータを含む
     文字列を返します。 LEVEL は `1' から `9' までの
     整数をとる値で、圧縮のレベルを制御します。 `1' は最も高速
     で最小限の圧縮を行います。`9' はもっとも低速になりますが
     最大限の圧縮を行います。デフォルトの値は `6' です。
     圧縮時に何らかのエラーが発生した場合、 `error' 例外を 送出します。

`compressobj([level])'
     一度にメモリ上に置くことができないようなデータストリームを圧縮
     するための圧縮オブジェクトを返します。LEVEL は `1' から `9'
     までの整数で、圧縮レベルを制御します。`1' は
     もっとも高速で最小限の圧縮を、`9' はもっとも低速になりますが
     最大限の圧縮を行います。デフォルトの値は `6' です。

`crc32(string[, value])'
     STRING の CRC (Cyclic Redundancy Check, 巡回符号方式)
     チェックサムを計算します。VALUE が与えられていれば、チェックサム
     計算の初期値として使われます。与えられていなければデフォルトの初期値
     が使われます。VALUE を与えることで、複数の入力文字列を結合した
     データ全体にわたり、通しのチェックサムを計算することができます。
     このアルゴリズムは暗号法論的には強力ではなく、認証やデジタル署名
     に用いるべきではありません。アルゴリズムはチェックサムアルゴリズムと
     して設計されてえいるので、汎用のハッシュアルゴリズムには向きません。

`decompress(string[, wbits[, bufsize]])'
     STRING 内のデータを解凍して、解凍されたデータを含む文字列を
     返します。WBITS パラメタはウィンドウバッファの大きさを制御
     します。 BUFSIZE が与えられていれば、出力バッファの書記サイズ
     として使われます。解凍処理に何らかのエラーが生じた場合、 `error'
     例外を送出します。

     WBITS の絶対値は、データを圧縮する際に用いられるヒストリ
     バッファのサイズ (ウィンドウサイズ) に対し、 2 を底とする対数を
     とったものです。最近のほとんどのバージョンの zlib ライブラリを
     使っているなら、WBITS の絶対値は 8 から 15 とするべきです。
     より大きな値はより良好な圧縮につながりますが、より多くのメモリ
     を必要とします。デフォルトの値は 15 です。WBITS の値が
     負の場合、標準的な `gzip' ヘッダを出力しません。 これは zlib
     ライブラリの非公開仕様であり、`unzip' の
     圧縮ファイル形式に対する互換性のためのものです。

     BUFSIZE は解凍されたデータを保持するためのバッファサイズの
     初期値です。バッファの空きは必要に応じて必要なだけ増加するので、
     なれば、必ずしも正確な値を指定する必要はありません。この値の
     チューニングでできることは、 `malloc()' が呼ばれる回数を
     数回減らすことぐらいです。デフォルトのサイズは 16384 です。


`decompressobj([wbits])'
     メモリ上に一度に展開できないようなデータストリームを解凍するために
     用いられる解凍オブジェクトを返します。WBITS パラメタは
     ウィンドウバッファのサイズを制御します。

圧縮オブジェクトは以下のメソッドをサポートします:

`compress(string)'
     STRING を圧縮し、圧縮されたデータを含む文字列を返します。この
     文字列は少なくとも STRING に相当します。このデータは以前に呼んだ
     `compress()' が返した出力と結合することができます。入力の一部は
     以後の処理のために内部バッファに保存されることもあります。

`flush([mode])'
     未処理の入力データが処理され、この未処理部分を圧縮したデータを含む
     文字列が返されます。MODE は定数 `Z_SYNC_FLUSH' 、 `Z_FULL_FLUSH'
     、または `Z_FINISH' のいずれかをとり、 デフォルト値は `Z_FINISH'
     です。`Z_SYNC_FLUSH' および `Z_FULL_FLUSH'
     ではこれ以後にもデータ文字列を圧縮できる
     モードで、解凍時の部分的なエラーリカバリを可能にします。一方、
     `Z_FINISH' は圧縮ストリームを閉じ、これ以後のデータの圧縮
     を禁止します。 MODE に `Z_FINISH' を設定して `flush()'
     メソッドを呼び出した後は、`compress()'
     メソッドを再び呼ぶべきではありません。唯一の現実的な操作はこの
     オブジェクトを削除することだけです。

解凍オブジェクトは以下のメソッドと 2 つの属性をサポートします:

`unused_data'
     圧縮データの末尾までのバイト列が入った文字列です。
     すなわち、この値は圧縮データの入っているバイト列の最後の文字
     までが読み出せるかぎり `""' となります。入力文字列全てが圧縮
     データを含んでいた場合、この属性は `""' 、すなわち空文字列に
     なります。

     圧縮データ文字列がどこで終了しているかを決定する唯一の
     方法は、実際にそれを解凍することです。つまり、大きなファイル
     の一部分に圧縮データが含まれているときに、その末端を調べるために
     は、データをファイルから読み出し、空でない文字列を後ろに続けて、
     `unused_data' が空文字列でなくなるまで、解凍オブジェクトの
     `decompress' メソッドに入力しつづけるしかありません。

`unconsumed_tail'
     解凍されたデータを収めるバッファの長さ制限を超えたために、最も最近の
     `decompress' 呼び出しで処理しきれなかったデータを含む文字列です。
     このデータはまだ zlib
     側からは見えていないので、正しい解凍出力を得るには 以降の
     `decompress' メソッド呼び出しに (場合によっては後続の
     データが追加された) データを差し戻さなければなりません。


`decompress(string)'
     {[max_length]} STRING を解凍し、少なくとも STRING
     の一部分に対応する
     解凍されたデータを含む文字列を返します。このデータは以前に
     `decompress()' メソッドを呼んだ時に返された出力と結合する
     ことができます。入力データの一部分が以後の処理のために内部バッファに
     保存されることもあります。

     オプションパラメタ MAX_LENGTH が与えられると、返される解凍データ
     の長さが MAX_LENGTH 以下に制限されます。このことは入力した圧縮
     データの全てが処理されるとは限らないことを意味し、処理されなかった
     データは `unconsumed_tail' 属性に保存されます。
     解凍処理を継続したいならば、この保存されたデータを以降の
     `decompress()' 呼び出しに渡さなくてはなりません。 MAX_LENGTH
     が与えられなかった場合、全ての入力が解凍され、 `unconsumed_tail'
     属性は空文字列になります。

`flush()'
     未処理の入力データを全て処理し、最終的に圧縮されなかった残りの
     出力文字列を返します。 `flush()' を呼んだ後、 `decompress()'
     を再度呼ぶべきではありません。このときできる唯一現実的な操作は
     オブジェクトの削除だけです。

See also:
     *Note gzip:: Reading and writing `gzip'-format files.

    <http://www.gzip.org/zlib/>
          The zlib library home page.



File: python-lib-jp.info,  Node: gzip,  Next: bz2,  Prev: zlib,  Up: オプションのオペレーティングシステムサービス

`gzip' ファイルのサポート
=========================

ファイルオブジェクトを用いた `gzip'
圧縮および解凍のためのインタフェース `zlib'
モジュールで提供されているデータ圧縮は、GNU の 圧縮プログラム `gzip'
のものと互換性があります。 そこで、`gzip' モジュールでは、`gzip' 形式の
ファイルを読み書きするための `GzipFile' クラスを提供します。
このクラスのオブジェクトは自動的にデータを圧縮または解凍するので、
通常のファイルオブジェクトのように見えます。 `gzip' や `gunzip'
プログラムで解凍できる、 `compress' や `pack'
による他の形式の圧縮ファイルは
このモジュールではサポートされていないので注意してください。

このモジュールでは以下の項目を定義しています:

`GzipFile([filename[, mode[, compresslevel[, fileobj]]]])'
     `GzipFile' クラスのコンストラクタです。`GzipFile' オブジェクト は
     `readinto()' と `truncate()' メソッドを除くほとんどの
     ファイルオブジェクトのメソッドをシミュレートします。 少なくとも
     FILEOBJ および FILENAME は有効な値でなければ なりません。

     クラスの新しいインスタンスは、FILEOBJ に基づいて作成
     されます。FILEOBJ は通常のファイル、`StringIO'
     オブジェクト、そしてその他ファイルをシミュレートできる
     オブジェクトでかまいません。値はデフォルトでは None で、
     ファイルオブジェクトを生成するために FILENAME を開きます。

     `gzip' ファイルヘッダ中には、ファイルが解凍されたときの元の
     ファイル名を収めることができますが、FILEOBJ が `None'
     でない場合、引数 FILENAME がファイル名として認識できる文字列
     であれば、FILENAME はファイルヘッダに収めるためだけに使われ
     ます。そうでない場合（この値はデフォルトでは空文字列です）、
     元のファイル名はヘッダに収められません。

     MODE 引数は、ファイルを読み出すのか、書き込むのかによって、 `'r'',
     `'rb'', `'a'', `'ab'', `'w'', そして `'wb'',
     のいずれかになります。FILEOBJ の
     ファイルモードが認識可能な場合、MODE はデフォルトで FILEOBJ
     のモードと同じになります。そうでない場合、 デフォルトのモードは
     `'rb'' です。'b' フラグがついて
     いなくても、ファイルがバイナリモードで開かれることを保証するために
     'b' フラグが追加されます。これはプラットフォーム間での移植性の
     ためです。

     COMPRESSLEVEL 引数は `1' から `9' までの整数で、
     圧縮のレベルを制御します。`1' は最も高速で最小限の圧縮しか
     行いません。`9' は最も低速ですが、最大限の圧縮を行います。
     デフォルトの値は `9' です。

     圧縮したデータの後ろにさらに何か追記したい場合もあるので、
     `GzipFile' オブジェクトの `close()' メソッド呼び出し は FILEOBJ
     をクローズしません。この機能によって、書き
     込みのためにオープンした `StringIO' オブジェクトを FILEOBJ
     として渡し、（`GzipFile' を `close()' した後に） `StringIO'
     オブジェクトの `getvalue()' メソッドを使って
     書き込んだデータの入っているメモリバッファを取得することができます。

`open(filename[, mode[, compresslevel]])'
     `GzipFile(FILENAME,' `MODE,' `COMPRESSLEVEL)' の短縮形です。 引数
     FILENAME は必須です。デフォルトで MODE は`'rb'' に、 COMPRESSLEVEL
     は `9' に設定されています。

See also:
     *Note zlib:: `gzip' ファイル形式のサポートを行うために必要な
     基本ライブラリモジュール。


File: python-lib-jp.info,  Node: bz2,  Next: zipfile,  Prev: gzip,  Up: オプションのオペレーティングシステムサービス

`bzip2' 互換の圧縮ライブラリ
============================

`bzip2' 互換の圧縮／解凍ルーチンへのインタフェース

_Added in Python version 2.3_

このモジュールでは bz2
圧縮ライブラリのためのわかりやすいインタフェースを
提供します。モジュールでは完全なファイルインタフェース、データを一括
して圧縮（解凍）する関数、データを逐次的に圧縮（解凍）するためのクラス
型を実装しています。

bz2 モジュールで提供されている機能を以下にまとめます:

   * `BZ2File' クラスは、`readline()', `readlines()', `writelines()',
     `seek()', 等を含む完全な ファイルインタフェースを実装します。

   * `BZ2File' クラスは `seek()' をエミュレーションで サポートします。

   * `BZ2File' クラスは広範囲の改行文字バリエーションを サポートします。

   * `BZ2File' クラスはファイルオブジェクトで言うところの、先読み
     アルゴリズムを用いた行単位の反復処理機能を提供します。

   * 逐次的圧縮（解凍）が `BZ2Compressor' および `BZ2Decompressor'
     クラスでサポートされています。

   * 一括圧縮（解凍）が関数 `compress()' および `decompress()'
     でサポートされています。

   * 個別のロックメカニズムによってスレッド安全性を持っています。

   * 埋め込みドキュメントが完備しています。

* Menu:

* ファイルの圧縮（解凍）::
* 逐次的な圧縮（解凍）::
* 一括圧縮（解凍）::


File: python-lib-jp.info,  Node: ファイルの圧縮（解凍）,  Next: 逐次的な圧縮（解凍）,  Prev: bz2,  Up: bz2

ファイルの圧縮（解凍）
----------------------

圧縮ファイルの操作は `BZ2File' クラスで提供されています。

`BZ2File(filename[, mode[, buffering[, compresslevel]]])'
     bz2 ファイルを開きます。ファイルのモードは `'r'' または `'w''
     で、それぞれ読み出しと書き込みに対応します。
     書き出し用に開いた場合、ファイルが存在しないなら新しくファイルが
     作成され、そうでない場合ファイルは切り詰められます。 BUFFERING
     パラメタが与えられた場合、`0' はバッファリング
     を行わないことを表し、それよりも大きい値はバッファサイズの指定値
     となります。デフォルトでは `0' です。COMPRESSLEVEL
     が与えられている場合、この値は `1' から `9' までの
     整数値でなければなりません。デフォルトの値は `9' です。
     ファイルへの入力に広範囲の改行文字バリエーションをサポートさせたい
     場合は `U' をファイルモードに追加します。
     入力ファイルの行末はどれも、Pythonからは `\n' として見えます。
     また、また、開かれているファイルオブジェクトは `newlines' 属性
     を持ち、`None' (まだ改行文字を読み込んでいない時), `'\r'', `'\n'',
     `'\r\n'' または全ての改行文字バリエーション
     を含むタプルになります。広範囲の改行文字サポートは読み込みだけで
     利用可能です。生成されるインスタンスは通常のファイルインスタンスと
     同様の反復操作をサポートします。

`close()'
     ファイルを閉じます。オブジェクトのデータ属性 `closed' を真に
     します。閉じられたファイルは以後の入出力操作に用いることができません。
     `close()' 自体はエラーを引き起こすことなく何度も呼び出すことが
     できます。

`read([size])'
     最大で SIZE バイトの解凍されたデータを読み出し、文字列として
     返します。SIZE 引数が負であるか省略された場合、EOF に
     たどり着くまで読み込みます。

`readline([size])'
     ファイルから次の 1 行を読み出し、改行文字も含めて文字列を返します。
     負でない SIZE 値は、返される文字列の最大バイト長を制限します
     (その場合不完全な行が返されることもあります) EOF の時には空文字列
     が返されます。

`readlines([size])'
     ファイルから読み取った行文字列の集合からなるリストを返します。
     オプション引数 SIZE が与えられていれば、返される行文字列
     全体のバイト数長さの大体の上限が指定されます。

`xreadlines()'
     前のバージョンとの互換性のために用意されています。 `BZ2File'
     オブジェクトはかつて `xreadlines' モジュールで提供されて
     いたパフォーマンス最適化を含んでいます。 _This is deprecated in
     Python 2.3.  このメソッドは `file' オブジェクトの同名の
     メソッドとの互換性のために用意されていますが、現在は推奨されない
     メソッドです。代りに `for line in file' を使ってください。_

`seek(offset[, whence])'
     ファイル位置を移動します。 引数 OFFSET はバイト数での値です。
     オプション引数 WHENCE はデフォルトで `0' (ファイルの
     先頭からのオフセットであり、offset `>= 0' となるはず) に設定されて
     います。他の値は `1' (現在のファイル位置からの相対位置であり、
     正負どちらの値もとり得ます)、および `2' (ファイルの終末端からの
     相対位置であり、通常負の値になりますが、多くのプラットフォームで
     ファイルの終末端を越えて seek を行うことができます)。

     bz2 ファイルの seek
     はエミュレーションであり、パラメタの設定によっては
     処理が非常に低速になるかもしれないので注意してください。

`tell()'
     現在のファイル位置を整数（long
     整数になるかもしれません）で返します。

`write(data)'
     ファイルに文字列 DATA を書き込みます。バッファリングのため、
     ディスク上のファイルに書き込まれたデータを反映させるには `close()'
     が必要になるかもしれないので注意してください。

`writelines(sequence_of_strings)'
     複数の文字列からなる配列をファイルに書き込みます。それぞれの
     文字列を書き込む際にさらに改行文字が追加されることはありません。
     配列は文字列を反復して取り出すことができる任意のオブジェクト
     でもかまいません。この操作はそれぞれの文字列を write() を呼んで
     書き込むのと同等の操作です。


File: python-lib-jp.info,  Node: 逐次的な圧縮（解凍）,  Next: 一括圧縮（解凍）,  Prev: ファイルの圧縮（解凍）,  Up: bz2

逐次的な圧縮（解凍）
--------------------

逐次的な圧縮および解凍は `BZ2Compressor' および `BZ2Decompressor'
クラスを用いて行われます。

`BZ2Compressor([compresslevel])'
     新しい圧縮オブジェクトを作成します。このオブジェクトはデータを逐次的に
     圧縮できます。一括してデータを圧縮したいのなら、`compress()'
     関数を代りに使ってください。COMPRESSLEVEL パラメタを与える場合、
     この値は `1' and `9' の間の整数でなければなりません。
     デフォルトの値は `9' です。

`compress(data)'
     圧縮オブジェクトに追加のデータを入力します。データが圧縮された
     チャンクを生成することができた場合にはチャンクを返します。
     圧縮データの入力を終えた後は 圧縮処理を終えるために `flush()'
     を呼んでください。
     内部バッファに残っている未処理のデータが返されます。

`flush()'
     圧縮処理を終え、内部バッファに残されているデータを返します。
     メソッドを呼んだ後は、この圧縮オブジェクトを使うべきではありません。

`BZ2Decompressor()'
     新しい解凍オブジェクトを生成します。このオブジェクトは逐次的にデータ
     を解凍できます。一括してデータを解凍したいのなら、 `decompress()'
     関数を代りに使ってください。

`decompress(data)'
     解凍オブジェクトに追加のデータを入力します。可能な限り、データが
     解凍されたチャンクを生成することができた場合にはチャンクを
     返します。ストリームの末端に到達した後に解凍処理を行おうと
     した場合には、例外 `EOFError' が送出されます。
     ストリームの終末端の後ろに何らかのデータがあった場合には、解凍
     操作からは無視され、このデータはオブジェクトの `unused_data'
     属性に収められます。


File: python-lib-jp.info,  Node: 一括圧縮（解凍）,  Prev: 逐次的な圧縮（解凍）,  Up: bz2

一括圧縮（解凍）
----------------

一括での圧縮および解凍を行うための関数、`compress()' および
`decompress()' が提供されています。

`compress(data[, compresslevel])'
     DATA を一括して圧縮します。データを逐次的に圧縮したいなら、
     `BZ2Compressor' を代りに使ってください。もし COMPRESSLEVEL
     パラメタを与えるなら、この値は `1' から `9' をとらなくては
     なりません。デフォルトの値は `9' です。

`decompress(data)'
     DATA を一括して解凍します。データを逐次的に解凍したいなら、
     `BZ2Decompressor' を代りに使ってください。


File: python-lib-jp.info,  Node: zipfile,  Next: tarfile,  Prev: bz2,  Up: オプションのオペレーティングシステムサービス

ZIP アーカイブの処理
====================

ZIP-フォーマットのアーカイブファイルを読み書きする

_Added in Python version 1.6_

ZIP は一般によく知られているアーカイブ
（書庫化）および圧縮の標準ファイルフォーマットです。 このモジュールでは
ZIP 形式のファイルの作成、読み書き、追記、
書庫内のファイル一覧の作成を行うためのツールを提供します。
より高度な使い方でこのモジュールを利用したいなら、

に定義されている ZIP ファイルフォーマットを理解することが必要に
なるでしょう。

このモジュールは現在のところ、コメントを追記した ZIP ファイルや
マルチディスク ZIP ファイルを扱うことはできません。

このモジュールで利用できる属性を以下に示します:

`error'
     不備のある ZIP ファイル操作の際に送出されるエラー

`ZipFile'
     ZIP ファイルの読み書きのためのクラスです。
     コンストラクタの詳細については、 "" (*Note ZipFile オブジェクト::
     節) を参照してください。

`PyZipFile'
     Python ライブラリを含む ZIP アーカイブを生成するためのクラスです。

`ZipInfo([filename[, date_time]])'
     アーカイブ中のメンバに関する情報を提供するために用いられるクラスです。
     このクラスのインスタンスは `ZipFile' オブジェクトの `getinfo()'
     および `infolist()' メソッドによって返され ます。`zipfile'
     モジュールを利用するほとんどのユーザはこの
     オブジェクトを自ら生成する必要はなく、モジュールが生成して返す
     オブジェクトを利用するだけでしょう。 FILENAME
     はアーカイブメンバの完全な名前で、 DATE_TIME は
     ファイルの最終更新時刻を記述する、 6 つの
     フィールドからなるタプルでなくてはなりません。各フィールドについては
     *Note tarfile::, "ZipInfo オブジェクト" 節を参照してください。

`is_zipfile(filename)'
     FILENAME が正しいマジックナンバをもつ ZIP ファイルのときに `True'
     を返し、そうでない場合 `False' を返します。この
     モジュールは現在のところ、コメントを追記した ZIP ファイルを扱うこと
     ができません。

`ZIP_STORED'
     アーカイブメンバが圧縮されていないことを表す数値定数です。

`ZIP_DEFLATED'
     通常の ZIP 圧縮手法を表す数値定数。ZIP 圧縮は zlib モジュールを必要
     とします。現在のところ他の圧縮手法はサポートされていません。

See also:
     `PKZIP Application Note'{ZIP
     ファイル形式およびアルゴリズムを作成した  Phil Katz
     によるドキュメント。}

     `Info-ZIP Home Page'{Info-ZIP プロジェクトによる ZIP
     アーカイブプログラム及びプログラム開発ライブラリに関する情報。}

* Menu:

* ZipFile オブジェクト::
* PyZipFile オブジェクト::
* ZipInfo オブジェクト::


File: python-lib-jp.info,  Node: ZipFile オブジェクト,  Next: PyZipFile オブジェクト,  Prev: zipfile,  Up: zipfile

ZipFile オブジェクト
--------------------

`ZipFile(file[, mode[, compression]])'
     ZIP ファイルを開きます。FILE はファイルへのパス名 (文字列)
     またはファイルのように振舞うオブジェクトのどちらでもかまいません。
     MODE パラメタは、既存のファイルを読むためには	`'r''、
     既存のファイルを切り詰めたり新しいファイルに書き込むためには
     `'w''、 追記を行うためには `'a'' でなくてはなりません。 MODE が
     `'a'' で FILE が既存の ZIP ファイルを
     参照している場合、追加するファイルは既存のファイル中の ZIP
     アーカイブ に追加されます。FILE が ZIP
     を参照していない場合、新しい ZIP
     アーカイブが生成され、既存のファイルの末尾に追加されます。このことは、
     ある ZIP ファイルを他のファイル、例えば	`python.exe' に

          cat myzip.zip >> python.exe

     として追加することができ、少なくとも `WinZip' がこのような
     ファイルを読めることを意味します。 COMPRESSION
     はアーカイブを書き出すときの ZIP 圧縮法で、 `ZIP_STORED' または
     `ZIP_DEFLATED' でなくては なりません。不正な値を指定すると
     `RuntimeError' が送出 されます。また、`ZIP_DEFLATED'
     定数が指定されているのに `zlib' を利用することができない場合、
     `RuntimeError' が送出されます。デフォルト値は `ZIP_STORED' です。

`close()'
     アーカイブファイルを閉じます。`close()' は
     プログラムを終了する前に必ず呼び出さなければなりません。
     さもないとアーカイブ上の重要なレコードが書き込まれません。

`getinfo(name)'
     アーカイブメンバ NAME に関する情報を持つ `ZipInfo'
     オブジェクトを返します。

`infolist()'
     アーカイブに含まれる各メンバの `ZipInfo' オブジェクトからなる
     リストを返します。既存のアーカイブファイルを開いている場合、
     リストの順番は実際の ZIP ファイル中のメンバの順番と同じになります。

`namelist()'
     アーカイブメンバの名前のリストを返します。

`printdir()'
     アーカイブの目次を `sys.stdout' に出力します。

`read(name)'
     アーカイブ中のファイルの内容をバイト列にして返します。アーカイブは
     読み込みまたは追記モードで開かれていなくてはなりません。

`testzip()'
     アーカイブ中の全てのファイルを読み、CRC	チェックサムが正常か調べます。
     アーカイブ中で不正なチェックサムをもつ最初のファイルの名前を返します。
     不正なファイルがなければ `None' を返します。

`write(filename[, arcname[, compress_type]])'
     FILENAME に指定したファイル名を持つファイルを、アーカイブ名を
     ARCNAME (デフォルトでは FILENAME と同じ) にして
     アーカイブに収録します。COMPRESS_TYPE を指定した場合、
     コンストラクタを使って新たなアーカイブエントリを生成した際に使った
     COMPRESSION パラメタを上書きします。 アーカイブのモードは `'w''
     または `'a'' でなくてはなりません。

`writestr(zinfo_or_arcname, bytes)'
     文字列 BYTESをアーカイブに書き込みます。ZINFO_OR_ARCNAME
     はアーカイブ中で指定するファイル名か、または`ZipInfo' インスタンス
     を指定します。ZINFO_OR_ARCNAMEに`ZipInfo' インスタンスを指定
     する場合、ZINFOインスタンスには少なくともファイル名、日付および時刻
     を指定しなければなりません。ファイル名を指定した場合、日付と時刻には現在の
     日付と時間が設定されます。アーカイブはモード `'w'' または `'a''
     で開かれていなければなりません。

以下のデータ属性も利用することができます。

`debug'
     使用するデバッグ出力レベル。この属性は `0'
     (デフォルト、何も出力しない) から `3' (最も多くデバッグ情報を
     出力する) までの値に設定することができます。デバッグ情報は
     `sys.stdout' に出力されます。


File: python-lib-jp.info,  Node: PyZipFile オブジェクト,  Next: ZipInfo オブジェクト,  Prev: ZipFile オブジェクト,  Up: zipfile

PyZipFile オブジェクト
----------------------

`PyZipFile' コンストラクタは `ZipFile' コンストラクタ
と同じパラメタを必要とします。インスタンスは `ZipFile' の
メソッドの他に、追加のメソッドを一つ持ちます。

`writepy(pathname[, basename])'
     `*.py' ファイルを探し、`*.py' ファイルに対応するファイルを
     アーカイブに追加します。 対応するファイルとは、もしあれば `*.pyo'
     であり、そうでなければ `*.pyc' で、必要に応じて `*.py'
     からコンパイルします。 もし pathname がファイルなら、ファイル名は
     `.py' で終わっていな ければなりません。また、(`*.py' に対応する
     `*.py[co]') ファイルはアーカイブのトップレベルに (パス情報なしで)
     追加されます。 もし pathname
     がディレクトリで、ディレクトリがパッケージディレクトリ
     でないなら、全ての `*.py[co]' ファイルはトップレベルに追加され
     ます。もしディレクトリがパッケージディレクトリなら、全ての
     `*.py[co]' ファイルはパッケージ名の名前をもつファイルパスの
     下に追加されます。サブディレクトリがパッケージディレクトリなら、
     それらは再帰的に追加されます BASENAME はクラス内部での呼び出し
     に使用するためのものです。

     `writepy()' メソッドは以下のようなファイル名を持ったアーカイブ
     を生成します。

              string.pyc                    # トップレベル名
              test/__init__.pyc             # パッケージディレクトリ
              test/testall.pyc              # test.testall モジュール
              test/bogus/__init__.pyc       # サブパッケージディレクトリ
              test/bogus/myfile.pyc         # test.bogus.myfile サブモジュール



File: python-lib-jp.info,  Node: ZipInfo オブジェクト,  Prev: PyZipFile オブジェクト,  Up: zipfile

ZipInfo オブジェクト
--------------------

`ZipFile' オブジェクトの `getinfo()' および `infolist()' メソッドは
`ZipInfo' クラスのインスタンス
を返します。それぞれのインスタンスオブジェクトは ZIP アーカイブの
一個のメンバについての情報を保持しています。

インスタンスは以下の属性を持ちます:

`filename'
     アーカイブ中のファイルの名前。

`date_time'
     アーカイブメンバの最終更新日時。この属性は6つの値からなるタプルです。:

     Index                              Value
     ------                             -----
     0                                  西暦年
     1                                  月 (1 から始まる)
     2                                  日 (1 から始まる)
     3                                  時 (0 から始まる)
     4                                  分 (0 から始まる)
     5                                  秒 (0 から始まる)


`compress_type'
     アーカイブメンバの圧縮形式。

`comment'
     各アーカイブメンバに対するコメント。

`extra'
     拡張フィールドデータ。
     この文字列データに含まれているデータの内部構成については、

     でコメントされています。

`create_system'
     ZIP アーカイブを作成したシステムを記述する文字列。

`create_version'
     このアーカイブを作成した PKZIP のバージョン。

`extract_version'
     このアーカイブを展開する際に必要な PKZIP のバージョン。

`reserved'
     予約領域。ゼロでなくてはなりません。

`flag_bits'
     ZIP フラグビット列。

`volume'
     ファイルヘッダのボリュームナンバ。

`internal_attr'
     内部属性。

`external_attr'
     外部ファイル属性。

`header_offset'
     　ファイルヘッダへのバイト数で表したオフセット。

`file_offset'
     ファイルデータの開始点へのバイト数で表したオフセット。

`CRC'
     圧縮前のファイルの CRC-32 チェックサム。

`compress_size'
     圧縮後のデータのサイズ。

`file_size'
     圧縮前のファイルのサイズ。


File: python-lib-jp.info,  Node: tarfile,  Next: readline,  Prev: zipfile,  Up: オプションのオペレーティングシステムサービス

tar アーカイブファイルを読み書きする
====================================

tar-形式のアーカイブファイルを読み書きします。 _Added in Python version
2.3_

`tarfile' モジュールは、tar
アーカイブを読んで作成することができるようにします。
いくつかの事実と外観：

   * `gzip' と `bzip2' で圧縮されたアーカイブを読み書きします。

   * POSIX 1003.1-1990 準拠あるいは GNU tar
     互換のアーカイブを作成します。

   * GNU tar 拡張機能 _長い名前_、 _longlink_ および _sparse_
     を読みます。

   * GNU tar 拡張機能を使って、無制限長さのパス名を保存します。

   *
     ディレクトリ、普通のファイル、ハードリンク、シンボリックリンク、fifo、
     キャラクタデバイスおよびブロックデバイスを処理します。また、タイムスタンプ、
     アクセス許可およびオーナーのようなファイル情報の取得および保存が可能です。

   * テープデバイスを取り扱うことができます。

`open([name[, mode [, fileobj[, bufsize]]]])'
     パス名 NAMEに `TarFile' オブジェクトを返します。 `TarFile'
     オブジェクトに関する詳細な情報については、  (セクション *Note
     TarFile オブジェクト::)を見て下さい。

     MODE has to be a string of the form `'filemode[:compression]'', it
     defaults to `'r''. Here is a full list of mode combinations: MODE
     は、`'ファイルモード[:圧縮]''の形の文字列でなければならず、
     そのデフォールトは
     `'r''です。以下にモードの組み合わせの完全な一覧を示します。

     mode                               動作
     ------                             -----
     'r'                                透過な圧縮つきで読み込むためにオープンします(推奨)。
     'r:'                               圧縮なしで排他的に読み込むためにオープンします。
     'r:gz'                             gzip
                                        圧縮で読み込むためにオープンします。
     'r:bz2'                            bzip2
                                        圧縮で読み込むためにオープンします。
     'a' または 'a:'                    圧縮なしで追加するためにオープンします。
     'w' または 'w:'                    非圧縮で書き込むためにオープンします。
     'w:gz'                             gzip
                                        圧縮で書き込むためにオープンします。
     'w:bz2'                            bzip2
                                        圧縮で書き込むためにオープンします。

     `'a:gz'' あるいは `'a:bz2''は可能ではないことに注意して下さい。
     もし MODEが、ある(圧縮した)ファイルを読み込み用にオープンするのに、
     適していないなら、`ReadError'が発生します。これを防ぐには MODE
     `'r'' を使って下さい。もし圧縮メソッドがサポートされていなければ、
     `CompressionError' が発生します。

     もし FILEOBJが指定されていれば、それは NAMEでオープンされた
     ファイルオブジェクトの代替として使うことができます。

     特別な目的のために、MODEの2番目のフォーマット:
     `'ファイルモード|[圧縮]'' があります。`open' は、そのデータを
     ブロックのストリームとして処理する `TarFile'
     オブジェクトを返します。
     ランダムシーキングはそのファイルにはなされません。もし FILEOBJ
     が与えられていれば、 それは、それぞれ `read()'、`write()'
     メソッドを持つ、任意の オブジェクトで構いません。 BUFSIZE
     は、ブロックサイズを指定し、デフォールトでは `20 * 512' バイト
     です。例えば `sys.stdin'
     とソケットファイルオブジェクトやテーブデバイスの
     組み合わせでは、これを変更して使って下さい。 しかし、そのような
     `TarFile' オブジェクトには、ランダムにアクセスされることを
     許さないという制限があります、  (セクション *Note
     readline::)を見て下さい。 現在可能なモードは：

     mode                               動作
     ------                             -----
     'r|'                               非圧縮 tar ブロックの
                                        _ストリーム_
                                        を読み込みにオープンします。
     'r|gz'                             gzip 圧縮
                                        _ストリーム_を読み込みにオープンします。
     'r|bz2'                            bzip2 圧縮 _ストリーム_
                                        を読み込みにオープンします。
     'w|'                               非圧縮
                                        _ストリーム_を書き込みにオープンします。
     'w|gz'                             gzip 圧縮 _ストリーム_
                                        を書き込みにオープンします。
     'w|bz2'                            bzip2 圧縮
                                        _ストリーム_を書き込みにオープンします。


`TarFile'
     tar
     アーカイブを読んだり、書いたりするためのクラスです。このクラスを
     直接使わないで下さい、その代わりに `open()' を使った方が良いです。
     (セクション *Note TarFile オブジェクト::)を見て下さい。

`is_tarfile(name)'
     もし NAMEが tar アーカイブファイルであれば、`True'を返し、 その
     `tarfile' モジュールで読むことができます。

`TarFileCompat(filename[, mode[, compression]])'
     `zipfile'-風なインターフェースを持つ tar アーカイブへの
     制限されたアクセスのためのクラスです。より詳細については
     `zipfile'のドキュメントに当たって下さい。 `compression'
     は、以下の定数のどれかでなければなりません：

    `TAR_PLAIN'
          非圧縮 tar アーカイブのための定数。

    `TAR_GZIPPED'
          `gzip'圧縮 tar アーカイブのための定数。


`TarError'
     すべての `tarfile' 例外のための基本クラスです。

`ReadError'
     tar アーカイブがオープンされた時、`tarfile' モジュールで操作
     できないか、あるいは何か無効であるとき発生します。

`CompressionError'
     圧縮方法がサポートされていないか、あるいはデータを正しくデコードできない
     時に発生します。

`StreamError'
     ストリーム風の `TarFile' オブジェクトで典型的な制限の
     ために発生します。

`ExtractError'
     `extract()'を使った時、もし`TarFile.errorlevel'` == 2' の
     _フェータルでない_ エラーに対してだけ発生します。

See also:
     *Note zipfile:: `zipfile' 標準モジュールのドキュメント。

     `GNU tar マニュアル、標準セクション'{GNU tar 拡張機能を含む、 tar
     アーカイブファイルのためのドキュメント。}

* Menu:

* TarFile オブジェクト::
* TarInfo オブジェクト::
* 例 9::


File: python-lib-jp.info,  Node: TarFile オブジェクト,  Next: TarInfo オブジェクト,  Prev: tarfile,  Up: tarfile

TarFile オブジェクト
--------------------

`TarFile' オブジェクトは、tar
アーカイブへのインターフェースを提供します。 tar
アーカイブは一連のブロックです。アーカイブメンバー(保存されたファイル)は、
ヘッダーブロックとそれに続くデータブロックから構成されています。ある
tar アーカイブに
ファイルを何回も保存することができます。各アーカイブメンバーは、
`TarInfo' オブジェクトによって表わされます、詳細については  (セクション
*Note TarInfo オブジェクト::)を見て下さい。

`TarFile([name [, mode[, fileobj]]])'
     _(非圧縮の)_ tar アーカイブ NAMEをオープンします。 MODE
     は、既存のアーカイブから読み込むには `'r'' 、
     既存のファイルにデータを追加するには
     `'a''、あるいは既存のファイルを
     上書きして新しいファイルを作成するには `'w'' のどれかです。MODE
     のデフォールトは `'r''です。

     もし
     FILEOBJが与えられていれば、それを使ってデータを読み書きします。
     もしそれが決定できれば、MODEは FILEOBJ のモードで上書きされます。.
     _Notice:_ FILEOBJ
     は、`TarFile'をクローズする時は、クローズされません。


`open(...)'
     代替コンストラクタです。モジュールレベルでの `open()' 関数は、
     実際はこのクラスメソッドへのショートカットです。詳細については
     セクション  を見て下さい。

`getmember(name)'
     メンバー NAME に対する `TarInfo' オブジェクトを返します。 もし
     NAMEがアーカイブに見つからなければ、`KeyError'が発生します。
     _Notice:_
     もしメンバーがアーカイブに1つ以上あれば、その最後に出現する
     ものが、最新のバージョンであるとみなされます。


`getmembers()'
     `TarInfo'
     オブジェクトのリストとしてアーカイブのメンバーを返します。
     このリストはアーカイブ内のメンバーと同じ順番です。

`getnames()'
     メンバーをその名前のリストとして返します。これは
     `getmembers()'で返されるリストと同じ順番です。

`list(verbose=True)'
     コンテンツの表を `sys.stdout' に印刷します。もし VERBOSE が
     `False' であれば、メンバー名のみ印刷します。もしそれが `True'
     であれば、`"ls -l"'-風の出力が作成されます。

`next()'
     `TarFile'が読み込み用にオープンされている時、
     アーカイブの次のメンバーを
     `TarInfo'オブジェクトとして返します。もしそれ以上利用可能なものがなければ、
     `None' を返します。

`extract(member[, path])'
     メンバーをアーカイブから現在の作業ディレクトリに、そのフル名を使って、
     抽出します。そのファイル情報はできるだけ正確に 抽出されます。
     MEMBERは、ファイル名でも`TarInfo' オブジェクトでも構いません。
     PATHを使って、異なるディレクトリを指定することができます。

`extractfile(member)'
     アーカイブからメンバーをオブジェクトとして抽出します。
     MEMBERは、ファイル名あるいは `TarInfo' オブジェクトです。 もし
     MEMBERが普通のファイルであれば、ファイル風のオブジェクトを返します。
     もし
     MEMBERがリンクであれば、ファイル風のオブジェクトをリンクのターゲットから
     構成します。 もし MEMBERが上のどれでもなければ、`None'
     が返されます。 _Notice:_
     ファイル風のオブジェクトは読み出し専用で以下のメソッドを提供します：
     `read()', `readline()', `readlines()', `seek()', `tell()'.


`add(name[, arcname[, recursive=True]])'
     ファイル NAMEをアーカイブに追加します。NAME
     は、任意のファイルタイプ
     (ディレクトリ、fifo、シンボリックリンク等)です。 もしARCNAME
     が与えられていれば、それはアーカイブ内のファイルの代替名を
     指定します。デフォールトではディレクトリは再帰的に追加されます。
     これは、RECURSIVE を `False'に設定することで避けることができます。

`addfile(tarinfo[, fileobj])'
     `TarInfo'オブジェクトTARINFOをアーカイブに追加します。 もし
     FILEOBJ が与えられていれば、`tarinfo.size' バイトがそれから読まれ、
     アーカイブに追加されます。`gettarinfo()'を使って `TarInfo'
     オブジェクトを作成することができます。 _Notice:_ Windows
     プラットフォームでは、FILEOBJは、ファイルサイズに関する問題を避けるために、
     常に、モード `'rb'' でオープンされるべきです。


`gettarinfo([name[, arcname [, fileobj]]])'
     `TarInfo'オブジェクトをファイル NAME あるいは
     (そのファイル記述子に `os.fstat()'を使って)
     ファイルオブジェクトFILEOBJの どちらか用に作成します。
     `TarInfo'の属性のいくつかは、
     `addfile()'を使って追加する前に修正することができます。
     ARCNAMEがもし与えられていれば、アーカイブ内のファイルの
     代替名を指定します。

`close()'
     `TarFile'をクローズします。書き出しモードでは、完了ゼロブロックが
     2つ、アーカイブに追加されます。

`posix=True'
     もし`True'なら、POSIX 1003.1-1990 準拠のアーカイブを作成します。GNU
     拡張機能は使われません、というのは、それらは POSIX
     標準の一部ではないからです。 これはファイル名の長さを最大 256
     に、linkname を100文字に制限します。
     もしパス名がこの制限を越えたら、`ValueError'が 発生します。 もし
     `False'であれば、GNU tar 互換アーカイブを作成します。それは POSIX
     準拠ではありませんが、無制限長さのパス名を保管することができます。

`dereference=False'
     もし
     `False'であれば、シンボリックリンクとハードリンクをアーカイブに追加します。
     もし
     `True'であれば、ターゲットファイルの内容をアーカイブに追加します。これは、
     リンクをサポートしないシステムには何も効果もありません。

`ignore_zeros=False'
     もし
     `False'であれば、空のブロックをアーカイブの終わりとして処理します。
     もし
     `True'であれば、空(で無効な)ブロックは飛ばして、できるだけ多くの
     メンバーを取得しようとします。これは連結した、あるいは損傷したアーカイブでのみ
     役に立ちます。

`debug=0'
     `0'(デバッグメッセージなし)から `3'(すべてのデバッグ
     メッセージあり)までを設定すべきです。そのメッセージは `sys.stdout'
     に書かれます。

`errorlevel=0'
     もし `0'
     なら、`extract()'を使っている時、すべてのエラーが無視されます。
     それでも、デバッギングが有効である時は、それらは、デバッグ出力にエラーメッセージとして
     出力されます。
     もし`1'なら、すべての_フェータル_エラーが、`OSError'あるいは
     `IOError' 例外として発生します。
     もし`2'なら、すべての_フェータルでない_エラーが、`TarError'例外と
     して、やはり発生します。


File: python-lib-jp.info,  Node: TarInfo オブジェクト,  Next: 例 9,  Prev: TarFile オブジェクト,  Up: tarfile

TarInfo オブジェクト
--------------------

`TarInfo' オブジェクトは `TarFile'
の一つのメンバーを表します。ファイルに
必要な(ファイルタイプ、ファイルサイズ、時刻、許可、所有者等のような)すべての属性を保存する他に、
そのタイプを決定するのに役に立ついくつかのメソッドを提供します。
これにはファイルのデータそのものは含まれま_せん_。

`TarInfo'オブジェクトは `TarFile'のメソッド `getmember()'、
`getmembers()' および `gettarinfo()'によって返されます。

`TarInfo([name])'
     `TarInfo' オブジェクトを作成します。

`frombuf()'
     `TarInfo' オブジェクトを文字列バッファから作成して返します。

`tobuf()'
     `TarInfo' オブジェクトから文字列バッファを作成します。

`TarInfo'オブジェクトには以下の public なデータ属性があります：

`name'
     アーカイブメンバーの名前。

`size'
     バイト単位でのサイズ。

`mtime'
     最終更新時刻。

`mode'
     許可ビット。

`type'
     ファイルタイプ。 TYPE は普通、以下の定数のどれかです： `REGTYPE,
     AREGTYPE, LNKTYPE, SYMTYPE, DIRTYPE, FIFOTYPE, CONTTYPE, CHRTYPE,
     BLKTYPE, GNUTYPE_SPARSE'。 `TarInfo'
     オブジェクトのタイプをもっと便利に決定するには、 以降の `is_*()'
     メソッドを使って下さい。

`linkname'
     ターゲットファイル名の名前で、これは タイプLNKTYPE と SYMTYPE の
     `TarInfo'オブジェクトにだけ存在します。

`uid, gid'
     このメンバーを本来保存した人のユーザとグループID。

`uname, gname'
     ユーザとグループ名

`TarInfo'オブジェクトは便利な照会用のメソッドもいくつか提供しています：

`isfile()'
     もし `Tarinfo' オブジェクトが普通のファイルであれば、`True'
     を返します。

`isreg()'
     `isfile()'と同じです。

`isdir()'
     もしそれがディレクトリであれば `True'を返します。

`issym()'
     もしそれがシンボリックリンクであれば `True'を返します。

`islnk()'
     もしそれがハードリンクであれば `True'を返します。

`ischr()'
     もしそれがキャラクタデバイスであれば `True'を返します。

`isblk()'
     もしそれがブロックデバイスであれば `True'を返します。

`isfifo()'
     もしそれが FIFO であれば `True'を返します。

`isdev()'
     もしそれが、キラクタデバイス、ブロックデバイスあるいは
     FIFOのどれかであれば `True'を返します。


File: python-lib-jp.info,  Node: 例 9,  Prev: TarInfo オブジェクト,  Up: tarfile

例
--

非圧縮 tar アーカイブをファイル名のリストから作成する方法：
     import tarfile
     tar = tarfile.open("sample.tar", "w")
     for name in ["foo", "bar", "quux"]:
         tar.add(name)
     tar.close()

gzip 圧縮 tar アーカイブを作成してメンバー情報のいくつかを表示する方法：
     import tarfile
     tar = tarfile.open("sample.tar.gz", "r:gz")
     for tarinfo in tar:
         print tarinfo.name, " は 大きさが ", tarinfo.size, "バイトで ",
         if tarinfo.isreg():
             print "普通のファイルです。"
         elif tarinfo.isdir():
             print "ディレクトリです。"
         else:
             print "ファイル・ディレクトリ以外のものです。"
     tar.close()

見せかけの情報を持つ tar アーカイブを作成する方法：
     import tarfile
     tar = tarfile.open("sample.tar.gz", "w:gz")
     for name in namelist:
         tarinfo = tar.gettarinfo(name, "fakeproj-1.0/" + name)
         tarinfo.uid = 123
         tarinfo.gid = 456
         tarinfo.uname = "johndoe"
         tarinfo.gname = "fake"
         tar.addfile(tarinfo, file(name))
     tar.close()

非圧縮 tar ストリームを`sys.stdin'から抽出する _唯一の_方法：
     import sys
     import tarfile
     tar = tarfile.open(mode="r|", fileobj=sys.stdin)
     for tarinfo in tar:
         tar.extract(tarinfo)
     tar.close()

