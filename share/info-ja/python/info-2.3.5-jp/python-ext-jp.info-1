This is python-ext-jp.info, produced by makeinfo version 4.5 from
python-ext-jp.texi.

12 October 2005


File: python-ext-jp.info,  Node: Top,  Next: 序,  Prev: (dir),  Up: (dir)

Python インタプリタの拡張と埋め込み
***********************************

* Menu:

* 序::
* C や C++ による Python の拡張::
* 新しい型を定義する::
* distutils による C および C++ 拡張モジュールのビルド::
* Windows 上での C および C++ 拡張モジュールのビルド::
* 他のアプリケーションへの Python の埋め込み::
* バグ報告::
* 歴史とライセンス::
* 日本語訳について::
* Module Index::
* Function-Method-Variable Index::
* Miscellaneous Index::


File: python-ext-jp.info,  Node: 序,  Next: C や C++ による Python の拡張,  Prev: Top,  Up: Top

序
**

Copyright (C) 2001, 2002, 2003 Python Software Foundation.  All rights
reserved.

Copyright (C) 2000 BeOpen.com.  All rights reserved.

Copyright (C) 1995-2000 Corporation for National Research Initiatives.
All rights reserved.

Copyright (C) 1991-1995 Stichting Mathematisch Centrum.  All rights
reserved.

Translation Copyright (C) 2003 Python Document Japanese Translation
Project. All rights reserved.

ライセンスおよび許諾に関する完全な情報は、このドキュメントの末尾を
参照してください。

     Python
     はインタプリタ形式の、オブジェクト指向のプログラミング言語です。
     このドキュメントでは、Python インタプリタを拡張するために C やC++
     でモジュールを書く方法について述べます。
     拡張モジュールでは、新たな関数を定義できるだけでなく、新たな
     オブジェクト型とそのメソッドも定義できます。
     このドキュメントではまた、Python
     インタプリタを別のアプリケーションに 埋め込み
     (embedding)、拡張言語として使う方法についても述べます。
     このドキュメントの最後には、オペレーティングシステム上で (実行時に)
     動的に拡張モジュールをロードする機能がサポートされている場合に、
     動的ロード可能な拡張モジュールをコンパイルしてリンクする方法を
     示します。

     このドキュメントでは、読者は Python
     について基礎的な知識を持ち合わせて
     いるものと仮定しています。形式ばらない Python 言語の入門には、
     を読んでください。  を読めば、 Python
     言語についてより形式的な定義を得られます。 また、 では、Python
     に広い適用範囲をもたらしている既存のオブジェクト型、関数、 および
     (組み込み、および Python で書かれたものの両方の) モジュール
     について解説しています。

     Python/C API 全体の詳しい説明は、別のドキュメントである、

     を参照してください。



File: python-ext-jp.info,  Node: C や C++ による Python の拡張,  Next: 新しい型を定義する,  Prev: 序,  Up: Top

C や C++ による Python の拡張
*****************************

C プログラムの書き方を知っているなら、Python に新たな組み込み
モジュールを追加するのはきわめて簡単です。
この新たなモジュール、拡張モジュール ("extention module")
を使うと、Python が直接行えない二つのこと: 新しい組み込み
オブジェクトの実装、そして全ての C ライブラリ関数と
システムコールに対する呼び出し、ができるようになります。

拡張モジュールをサポートするため、Python API (Application Programmer's
Interface) では一連の関数、マクロ および変数を提供していて、Python
ランタイムシステムの ほとんどの側面へのアクセス手段を提供しています。
Python API は、ヘッダ `"Python.h"' をインクルードして C
ソースに取り込みます。

拡張モジュールのコンパイル方法は、モジュールの用途やシステムの
設定方法に依存します; 詳細は後の章で説明します。

* Menu:

* 簡単な例::
* 幕間小話 エラーと例外::
* 例に戻る::
* モジュールのメソッドテーブルと初期化関数::
* コンパイルとリンク::
* C から Python 関数を呼び出す::
* 拡張モジュール関数でのパラメタ展開::
* 拡張モジュール関数のキーワードパラメタ::
* 任意の値を構築する::
* 参照カウント法::
* C++での拡張モジュール作成::
* 拡張モジュールに C API を提供する::


File: python-ext-jp.info,  Node: 簡単な例,  Next: 幕間小話 エラーと例外,  Prev: C や C++ による Python の拡張,  Up: C や C++ による Python の拡張

簡単な例
========

`spam' (Monty Python ファンの好物ですね) という名の拡張モジュールを
作成することにして、C ライブラリ関数 `system()' に対する Python
インタフェースを作成したいとします。 (1) この関数は null
で終端されたキャラクタ文字列を引数にとり、
整数を返します。この関数を以下のようにして Python から呼び出せるように
したいとします:

     >>> import spam
     >>> status = spam.system("ls -l")

まずは `spammodule.c' を作成するところから始めます。
(伝統として、`spam' という名前のモジュールを作成する場合、
モジュールの実装が入った C ファイルを `spammodule.c' と
呼ぶことになっています;  `spammify' のように長すぎる
モジュール名の場合には、単に`spammify.c' にもできます。)

このファイルの最初の行は以下のようにします:

     #include <Python.h>

これで、Python API を取り込みます (必要なら、モジュールの用途に
関する説明や、著作権表示を追加します)。

_Notice:_ [warning] Python
は、システムによっては標準ヘッダの定義に影響するような
プリプロセッサ定義を行っているので、 `Python.h' は
いずれの標準ヘッダよりも前にインクルードせねばなりません。

`Python.h' で定義されているユーザから可視のシンボルは、 全て接頭辞`Py'
または `PY' が付いています。ただし、
標準ヘッダファイル内の定義は除きます。 簡単のためと、Python
内で広範に使うことになるという理由から、 `"Python.h"'
はいくつかの標準ヘッダファイル: `<stdio.h>'、 `<string.h>'、
`<errno.h>'、および `<stdlib.h>' をインクルードしています。
後者のヘッダファイルがシステム上になければ、`"Python.h"' が 関数
`malloc()'、`free()' および `realloc()' を直接定義します。

次にファイルに追加する内容は、Python 式 `spam.system(STRING)'
を評価する際に呼び出されることになる C 関数です
(この関数を最終的にどのように呼び出すかは、後ですぐわかります):

     static PyObject *
     spam_system(PyObject *self, PyObject *args)
     {
         char *command;
         int sts;
     
         if (!PyArg_ParseTuple(args, "s", &command))
             return NULL;
         sts = system(command);
         return Py_BuildValue("i", sts);
     }

ここでは、Python の引数リスト (例えば、単一の式 `"ls -l"') から C
関数に渡す引数にそのまま変換しています。 C
関数は常に二つの引数を持ち、便宜的に SELF および ARGS と呼ばれます。

SELF 引数は C 関数が Python の関数ではなく組み込みメソッド
を実装している場合にのみ使われます。この例ではメソッドではなく
関数を定義しているので、 SELF は常に `NULL' ポインタになります。
(これは、インタプリタが二つの異なる形式の C 関数を理解しなくてもよく
するためです。)

ARGS 引数は、引数の入った Python タプルオブジェクトへの
ポインタになります。タプル内の各要素は、呼び出しの際の引数リストに
おける各引数に対応します。引数は Python オブジェクトです -- C
関数で引数を使って何かを行うには、オブジェクトから C の値に
変換せねばなりません。Python API の関数 `PyArg_ParseTuple()'
は引数の型をチェックし、C の値に変換します。 `PyArg_ParseTuple()'
はテンプレート文字列を使って、
引数オブジェクトの型と、変換された値を入れる C 変数の型を判別します。
これについては後で詳しく説明します。

`PyArg_ParseTuple()' は、全ての引数が正しい型を持っていて、
アドレス渡しされた各変数に各引数要素を保存したときに真 (非ゼロ) を
返します。この関数は不正な引数リストを渡すと偽 (ゼロ) を返します。
後者の場合、関数は適切な例外を送出するので、呼び出し側は
(例にもあるように) すぐに`NULL' を返すようにしてください。

---------- Footnotes ----------

(1) この関数へのインタフェースはすでに標準モジュール `os' にあります --
この関数を選んだのは、単純で直接的な例を示したいからです。


File: python-ext-jp.info,  Node: 幕間小話 エラーと例外,  Next: 例に戻る,  Prev: 簡単な例,  Up: C や C++ による Python の拡張

幕間小話: エラーと例外
======================

Python インタプリタ全体を通して、一つの重要な取り決めがあります:
それは、関数が処理に失敗した場合、例外状態をセットして、 エラーを示す値
(通常は `NULL' ポインタ) を返さねばならない、 ということです。
例外はインタプリタ内の静的なグローバル変数に保存されます; この値が
`NULL' の場合、例外は何も起きていないことになります。
第二のグローバル変数には、例外の "付属値 (associated value)" (`raise'
文の第二引数) が入ります。 第三の値には、エラーの発生源が Python
コード内だった場合に スタックトレースバック (stack traceback)
が入ります。 これらの三つの変数は、それぞれ Python の変数
`sys.exc_type'、 `sys.exc_value' および `sys.exc_traceback' と等価な C
の変数です ( の`sys' モジュールに関する節を参照してください。)
エラーがどのように受け渡されるかを理解するには、これらの変数に
ついてよく知っておくことが重要です。

Python API では、様々な型の例外をセットするための関数をいくつか
定義しています。

もっともよく用いられるのは`PyErr_SetString()' です。
引数は例外オブジェクトと C 文字列です。例外オブジェクトは
通常、`PyExc_ZeroDivisionError' のような定義済みのオブジェクト です。 C
文字列はエラーの原因を示し、Python 文字列オブジェクトに変換されて
例外の "付属値" に保存されます。

もう一つ有用な関数として`PyErr_SetFromErrno()' があります。
この関数は引数に例外だけをとり、付属値はグローバル変数 `errno'
から構築します。もっとも汎用的な関数は`PyErr_SetObject()' で、
二つのオブジェクト、例外と付属値を引数にとります。これら関数に
渡すオブジェクトには`Py_INCREF()' を使う必要はありません。

例外がセットされているかどうかは、`PyErr_Occurred()'
を使って非破壊的に調べられます。この関数は現在の例外オブジェクトを
返します。例外が発生していない場合には `NULL' を返します。
通常は、関数の戻り値からエラーが発生したかを判別できるはずなので、
`PyErr_Occurred()' を呼び出す必要はありません。

関数G を呼び出すF が、前者の関数の呼び出しに失敗したことを
検出すると、F 自体はエラー値 (大抵は `NULL' や `-1')
を返さねばなりません。しかし、`PyErr_*()' 関数群の
いずれかを呼び出す必要は _ありません_ -- なぜなら、G
がすでに呼び出しているからです。次いでF を呼び出したコードも
エラーを示す値を_自らを呼び出したコード_ に返すことになりますが、
同様に`PyErr_*()' は_呼び出しません_。 以下同様に 続きます --
エラーの最も詳しい原因は、最初にエラーを検出した
関数がすでに報告しているからです。エラーが Python インタプリタの
メインループに到達すると、現在実行中の Python コードは一時停止 し、
Python プログラマが指定した例外ハンドラを探し出そうとします。

(モジュールが`PyErr_*()' 関数をもう一度呼び出して、より詳細な
エラーメッセージを提供するような状況があります。このような状況では
そうすべきです。とはいえ、一般的な規則としては、`PyErr_*()'
を何度も呼び出す必要はなく、ともすればエラーの原因に関する情報を
失う結果になりがちです: これにより、ほとんどの操作が様々な理由から
失敗するかもしれません)

ある関数呼び出しでの処理の失敗によってセットされた例外を無視するには、
`PyErr_Clear()' を呼び出して例外状態を明示的に消去
しなくてはなりません。 エラーをインタプリタには渡したくなく、自前で
(何か他の作業を行ったり、 何も起こらなかったかのように見せかけるような)
エラー処理を完全に 行う場合にのみ、`PyErr_Clear()'
を呼び出すようにすべきです。

`malloc()' の呼び出し失敗は、常に例外にしなくては なりません --
`malloc()' (または `realloc()')
を直接呼び出しているコードは、`PyErr_NoMemory()' を
呼び出して、失敗を示す値を返さねばなりません。オブジェクトを
生成する全ての関数 (例えば `PyInt_FromLong()') は `PyErr_NoMemory()'
の呼び出しを済ませてしまうので、 この規則が関係するのは直接 `malloc()'
を呼び出す コードだけです。

また、`PyArg_ParseTuple()' という重要な例外を除いて、
整数の状態コードを返す関数はたいてい、UNIX のシステムコール
と同じく、処理が成功した際にはゼロまたは正の値を返し、 失敗した場合には
`-1' を返します。

最後に、エラー標示値を返す際に、(エラーが発生するまでに既に
生成してしまったオブジェクトに対して`Py_XDECREF()' や `Py_DECREF()'
を呼び出して) ごみ処理を注意深く 行ってください!

どの例外を返すかの選択は、ユーザに完全にゆだねられます。
`PyExc_ZeroDivisionError' のように、全ての組み込みの Python
例外には対応する宣言済みの C オブジェクトがあり、直接利用できます。
もちろん、例外の選択は賢く行わねばなりません --
ファイルが開けなかったことを表すのに`PyExc_TypeError'
を使ったりはしないでください (この場合はおそらく`PyExc_IOError'
の方にすべきでしょう)。
引数リストに問題がある場合には、`PyArg_ParseTuple()' はたいてい
`PyExc_TypeError' を送出します。
引数の値が特定の範囲を超えていたり、その他の満たすべき条件を満たさ
なかった場合には、`PyExc_ValueError' が適切です。

モジュール固有の新たな例外も定義できます。定義するには、通常は
ファイルの先頭部分に静的なオブジェクト変数の宣言を行います:

     static PyObject *SpamError;

そして、モジュールの初期化関数 (`initspam()')
の中で、例外オブジェクトを使って初期化します (ここでは
エラーチェックを省略しています):

     PyMODINIT_FUNC
     initspam(void)
     {
         PyObject *m;
     
         m = Py_InitModule("spam", SpamMethods);
     
         SpamError = PyErr_NewException("spam.error", NULL, NULL);
         Py_INCREF(SpamError);
         PyModule_AddObject(m, "error", SpamError);
     }

Python レベルでの例外オブジェクトの名前は `spam.error'
になることに注意してください。 `PyErr_NewException()' 関数は、 の
"組み込み例外" の節に述べられている`Exception'
クラスを基底クラスに持つ例外クラスも作成できます
(`NULL'の代わりに他のクラスを渡した場合は別です)。

`SpamError' 変数は、新たに生成された例外クラスへの参照を
維持することにも注意してください; これは意図的な仕様です!
外部のコードが例外オブジェクトをモジュールから除去できるため、
モジュールから新たに作成した例外クラスが見えなくなり、 `SpamError'
がぶら下がりポインタ (dangling pointer)
になってしまわないようにするために、クラスに対する参照を所有して
おかねばなりません。 もし`SpamError'
がぶら下がりポインタになってしまうと、 C
コードが例外を送出しようとしたときにコアダンプや意図しない副作用を
引き起こすことがあります。

この例にある PyMODINIT_FUNC の使い方については後で議論します。


File: python-ext-jp.info,  Node: 例に戻る,  Next: モジュールのメソッドテーブルと初期化関数,  Prev: 幕間小話 エラーと例外,  Up: C や C++ による Python の拡張

例に戻る
========

先ほどの関数の例に戻ると、今度は以下の実行文を理解できるはずです:

         if (!PyArg_ParseTuple(args, "s", &command))
             return NULL;

この実行文は、`PyArg_ParseTuple()' がセットする例外
によって、引数リストに何らかのエラーが生じたときに`NULL'
(オブジェクトへのポインタを返すタイプの関数におけるエラー標示値)
を返します。エラーでなければ、引数として与えた文字列値はローカル な変数
`command' にコピーされています。
この操作はポインタ代入であり、ポインタが指している文字列に対して
変更が行われるとは想定されていません (従って、標準 C では、 変数
`command' は `const char* command' として 適切に定義せねばなりません)。

次の文では、`PyArg_ParseTuple()' で得た文字列を 渡して UNIX 関数
`system()' を呼び出しています:

         sts = system(command);

`spam.system()' は `sts' を Python オブジェクト
として返さねばなりません。これには、`PyArg_ParseTuple()'
の逆ともいうべき関数`Py_BuildValue()' を使います: `Py_BuildValue()'
は書式化文字列と任意の数の C の値を 引数にとり、新たな Python
オブジェクトを返します。 `Py_BuildValue()'
に関する詳しい情報は後で示します。

         return Py_BuildValue("i", sts);

上の場合では、`Py_BuildValue()' は整数オブジェクトを
返します。(そう、整数ですら、 Python においてはヒープ上の
オブジェクトなのです! )

何ら有用な値を返さない関数 (`void' を返す関数) に 対応する Python
の関数は`None' を返さねばなりません。 関数に `None'
を返させるには、以下のような慣用句を使います:

         Py_INCREF(Py_None);
         return Py_None;

`Py_None' は特殊な Pyhton オブジェクトである `None' に 対応する C
での名前です。これまで見てきたようにほとんどのコンテキスト で "エラー"
を意味する `NULL' ポインタとは違い、`None' は純粋な Python
のオブジェクトです。


File: python-ext-jp.info,  Node: モジュールのメソッドテーブルと初期化関数,  Next: コンパイルとリンク,  Prev: 例に戻る,  Up: C や C++ による Python の拡張

モジュールのメソッドテーブルと初期化関数
========================================

さて、前に約束したように、`spam_system()' Python プログラム
からどうやって呼び出すかをこれから示します。まずは、関数名とアドレスを
"メソッドテーブル (method table)" に列挙する必要があります:

     static PyMethodDef SpamMethods[] = {
         ...
         {"system",  spam_system, METH_VARARGS,
          "Execute a shell command."},
         ...
         {NULL, NULL, 0, NULL}        /* Sentinel */
     };

リスト要素の三つ目のエントリ (`METH_VARARGS') に注意してください。
このエントリは、C 関数が使う呼び出し規約をインタプリタに教えるための
フラグです。通常この値は`METH_VARARGS' か `METH_VARARGS |
METH_KEYWORDS' のはずです; `0' は旧式の`PyArg_ParseTuple()'
の変化形が使われることを 意味します。

`METH_VARARGS' だけを使う場合、C 関数は、Python レベルでの引数が
`PyArg_ParseTuple()' が受理できるタプルの形式で渡されるもの
と想定しなければなりません; この関数についての詳細は下で説明します。

関数にキーワード引数が渡されることになっているのなら、
第三フィールドに`METH_KEYWORDS' ビットをセットできます。 この場合、C
関数は第三引数に `PyObject *' を受理するように
せねばなりません。このオブジェクトは、キーワード引数の辞書に
なります。こうした関数で引数を解釈するには、
`PyArg_ParseTupleAndKeywords()' を使ってください。

メソッドテーブルは、モジュールの初期化関数内でインタプリタに
渡さねばなりません。初期化関数はモジュールの名前を NAME としたときに
`initNAME()' という名前でなければ
ならず、モジュールファイル内で定義されているもののうち、唯一の
非`static' 要素でなければなりません:

     PyMODINIT_FUNC
     initspam(void)
     {
         (void) Py_InitModule("spam", SpamMethods);
     }

PyMODINIT_FUNC は関数の戻り値を `void' になるように宣言し、
プラットフォーム毎に必要とされる、特有のリンク宣言 (linkage declaration)
を定義すること、さらに C++ の場合には関数を `extern "C"' に
宣言することに注意してください。

Python プログラムがモジュール `spam' を初めて import
するとき、`initspam()' が呼び出されます。 (Python
の埋め込みに関するコメントは下記を参照してください。) `initspam()' は
`Py_InitModule()' を呼び出して "モジュールオブジェクト" を生成し
(オブジェクトは`"spam"' を キーとして辞書 `sys.modules'
に挿入されます)、第二引数として 与えたメソッドテーブル (`PyMethodDef'
構造体の配列) の情報に
基づいて、組み込み関数オブジェクトを新たなモジュールに挿入していきます。
`Py_InitModule()' は、自らが生成した (この段階ではまだ未使用の)
モジュールオブジェクトへのポインタを返します。 `Py_InitModule()'
は、モジュールを満足に初期化できなかった場合、
致命的エラーで中断するため、この関数の呼び出し側がエラーをチェックする
必要はありません。

Python を埋め込む場合には、`_PyImport_Inittab' テーブルの エントリ内に
`initspam()' がない限り、`initspam()'
は自動的には呼び出されません。この問題を解決する最も簡単な方法は、
`Py_Initialize()' や `PyMac_Initialize()' を 呼び出した後に
`initspam()' を直接呼び出し、
静的にリンクしておいたモジュールを静的に初期化してしまうというものです:

     int
     main(int argc, char *argv[])
     {
         /* Python インタプリタに argv[0] を渡す */
         Py_SetProgramName(argv[0]);
     
         /* Python インタプリタを初期化する。必ず必要。 */
         Py_Initialize();
     
         /* 静的モジュールを追加する */
         initspam();

Python ソース配布物中の `Demo/embed/demo.c' ファイル内 に例があります。

_Note:_ 単一のプロセス内 (または `fork()' 後の `exec()'
が介入していない状態) における複数のインタプリタにおいて、 `sys.module'
から エントリを除去したり新たなコンパイル済みモジュールを import
したりすると、拡張モジュールによっては問題を生じることがあります。
拡張モジュールの作者は、内部データ構造を初期化する際にはよくよく
用心すべきです。また、`reload()' 関数を拡張モジュールに
対して利用でき、この場合はモジュール初期化関数 (`initspam()')
は呼び出されますが、モジュールが動的にロード可能なオブジェクトファイル
(UNIXでは `.so'、Windows では `.dll') から読み出された
場合にはモジュールファイルを再読み込みしないので注意してください。

より実質的なモジュール例は、Python ソース配布物に `Modules/xxmodule.c'
という名前で入っています。
このファイルはテンプレートとしても利用できますし、単に例としても
読めます。ソース配布物や Windows にインストールされた Python
に入っている `modulator.py' では、拡張モジュールで実装しなければならない
関数やオブジェクトを宣言し、実装部分を埋めて作成するためのテンプレート
を生成できるような、簡単なグラフィカルユーザインタフェースを
提供しています。 このスクリプトは`Tools/modulator/'
ディレクトリにあります; 詳しくはディレクトリ内の `README'
ファイルを参照してください。


File: python-ext-jp.info,  Node: コンパイルとリンク,  Next: C から Python 関数を呼び出す,  Prev: モジュールのメソッドテーブルと初期化関数,  Up: C や C++ による Python の拡張

コンパイルとリンク
==================

新しい拡張モジュールを使えるようになるまで、まだ二つの作業:
コンパイルと、Python システムへのリンク、が残っています。 動的読み込み
(dynamic loading) を使っているのなら、作業の詳細は
自分のシステムが使っている動的読み込みの形式によって変わるかも
しれません; 詳しくは、拡張モジュールのビルドに関する章 (*Note distutils
による C および C++ 拡張モジュールのビルド:: 章) や、Windows
におけるビルドに関係する追加情報の章 (*Note Windows 上での C および C++
拡張モジュールのビルド:: 章) を参照してください。

動的読み込みを使えなかったり、モジュールを常時 Python インタプリタの
一部にしておきたい場合には、インタプリタのビルド設定を変更して再ビルド
しなければならなくなるでしょう。UNIXでは、幸運なことにこの作業は
とても単純です: 単に自作のモジュールファイル (例えば `spammodule.c' )
を展開したソース配布物の `Modules/' ディレクトリに置き、
`Modules/Setup.local' に自分のファイルを 説明する以下の一行:

     spam spammodule.o

を追加して、トップレベルのディレクトリで `make' を実行して、
インタプリタを再ビルドするだけです。 `Modules/' サブディレクトリでも
`make' を実行できますが、 前もって ``make' Makefile' を実行して
`Makefile' ｗ再ビルドしておかなければならりません。(この作業は `Setup'
ファイルを変更するたびに必要です。)

モジュールが別のライブラリとリンクされている必要がある場合、
ライブラリも設定ファイルに列挙できます。例えば以下のようにします:

     spam spammodule.o -lX11


File: python-ext-jp.info,  Node: C から Python 関数を呼び出す,  Next: 拡張モジュール関数でのパラメタ展開,  Prev: コンパイルとリンク,  Up: C や C++ による Python の拡張

C から Python 関数を呼び出す
============================

これまでは、Python からの C 関数の呼び出しに重点を置いて
述べてきました。ところでこの逆:  C からの Python 関数の呼び出し
もまた有用です。 とりわけ、いわゆる "コールバック"
関数をサポートするような ライブラリを作成する際にはこの機能が便利です。
ある C インタフェースがコールバックを利用している場合、
同等の機能を提供する Python コードでは、しばしば Python プログラマに
コールバック機構を提供する必要があります; このとき実装では、 C
で書かれたコールバック関数から Python で書かれたコールパック関数
を呼び出すようにする必要があるでしょう。
もちろん、他の用途も考えられます。

幸運なことに、Python インタプリタは簡単に再帰呼び出しでき、 Python
関数を呼び出すための標準インタフェースもあります。 (Python
パーザを特定の入力文字を使って呼び出す方法について
詳説するつもりはありません -- この方法に興味があるなら、 Python
ソースコードの `Python/pythonmain.c' にある、
コマンドラインオプション`-c' の実装を見てください)

Python 関数の呼び出しは簡単です。まず、C のコードに対して
コールバックを登録しようとする Python プログラムは、何らかの方法で
Python の関数オブジェクトを渡さねばなりません。このために、
コールバック登録関数 (またはその他のインタフェース) を提供
せねばなりません。このコールバック登録関数が呼び出された際に、
引き渡された Python 関数オブジェクトへのポインタをグローバル変数に --
あるいは、どこか適切な場所に -- 保存します
(関数オブジェクトを`Py_INCREF()' するようよく注意して
ください!)。例えば、以下のような関数がモジュールの一部になって
いることでしょう:

     static PyObject *my_callback = NULL;
     
     static PyObject *
     my_set_callback(PyObject *dummy, PyObject *args)
     {
         PyObject *result = NULL;
         PyObject *temp;
     
         if (PyArg_ParseTuple(args, "O:set_callback", &temp)) {
             if (!PyCallable_Check(temp)) {
                 PyErr_SetString(PyExc_TypeError, "parameter must be callable");
                 return NULL;
             }
             Py_XINCREF(temp);         /* 新たなコールバックへの参照を追加 */
             Py_XDECREF(my_callback);  /* 以前のコールバックを捨てる */
             my_callback = temp;       /* 新たなコールバックを記憶 */
             /* "None" を返す際の定型句 */
             Py_INCREF(Py_None);
             result = Py_None;
         }
         return result;
     }

この関数は`METH_VARARGS' フラグを使ってインタプリタに
登録せねばなりません; `METH_VARARGS' フラグについては、 *Note
モジュールのメソッドテーブルと初期化関数:: 節、
"モジュールのメソッドテーブルと初期化関数" で説明しています。
`PyArg_ParseTuple()' 関数とその引数については、 *Note
拡張モジュール関数でのパラメタ展開:: 節、
"拡張モジュール関数でのパラメタ展開" に記述しています。

`Py_XINCREF()' および`Py_XDECREF()' は、
オブジェクトに対する参照カウントをインクリメント/デクリメントする
ためのマクロで、`NULL' ポインタが渡されても安全に操作できる 形式です
(とはいえ、上の流れではTEMP が`NULL' になることは ありません)。
これらのマクロと参照カウントについては、*Note 参照カウント法:: 節、
"参照カウント" で説明しています。

その後、コールバック関数を呼び出す時が来たら、C 関数
`PyEval_CallObject()'

を呼び出します。 この関数には二つの引数: Python 関数と Python
関数の引数リストがあり、 いずれも任意の Python
オブジェクトを表すポインタ型です。
引数リストは常にタプルオブジェクトでなければならず、その長さは
引数の数になります。Python 関数を引数なしで呼び出すのなら
空のタプルを渡します; 単一の引数で関数を呼び出すのなら、 単要素
(singleton) のタプルを渡します。 `Py_BuildValue()'
の書式化文字列中に、ゼロ個または
一個以上の書式化コードが入った丸括弧がある場合、この関数は
タプルを返します。以下に例を示します:

         int arg;
         PyObject *arglist;
         PyObject *result;
         ...
         arg = 123;
         ...
         /* ここでコールバックを呼ぶ */
         arglist = Py_BuildValue("(i)", arg);
         result = PyEval_CallObject(my_callback, arglist);
         Py_DECREF(arglist);

`PyEval_CallObject()' は Python オブジェクトへのポインタを 返します;
これは Python 関数からの戻り値になります。 `PyEval_CallObject()'
は、引数に対して "参照カウント中立 (reference-count-neutral)" です。
上の例ではタプルを生成して引数リストとして提供しており、この
タプルは呼び出し直後に `Py_DECREF()' しています。

`PyEval_CallObject()' は "新しい" 戻り値を返します:
戻り値が表すオブジェクトは新たなオブジェクトか、既存のオブジェクトの
参照カウントをインクリメントしたものです。従って、このオブジェクトを
グローバル変数に保存したいのでないかぎり、
たとえこの戻り値に興味がなくても (むしろ、そうであればなおさら!)
何がしかの方法で戻り値オブジェクトを `Py_DECREF()'
しなければなりません。

とはいえ、戻り値を`Py_DECREF()' する前には、値が `NULL'
でないかチェックしておくことが重要です。もし `NULL'なら、呼び出した
Python 関数は例外を送出して終了させられています。 `PyEval_CallObject()'
を呼び出しているコード自体もまた Python
から呼び出されているのであれば、今度は C コードが自分を 呼び出している
Python コードにエラー標示値を返さねばなりません。
それにより、インタプリタはスタックトレースを出力したり、例外を
処理するための Python コードを呼び出したりできます。
例外の送出が不可能だったり、したくないのなら、 `PyErr_Clear()'
を呼んで例外を消去しておかねばなりません。 例えば以下のようにします:

         if (result == NULL)
             return NULL; /* エラーを返す */
         ...use result...
         Py_DECREF(result);

Python コールバック関数をどんなインタフェースにしたいかによっては、
引数リストを`PyEval_CallObject()' に与えなければ
ならない場合もあります。
あるケースでは、コールバック関数を指定したのと同じインタフェース
を介して、引数リストも渡されているかもしれません。
また別のケースでは、新しいタプルを構築して引数リストを渡さねば
ならないかもしれません。この場合最も簡単なのは `Py_BuildValue()'
を呼ぶやり方です。
例えば、整数のイベントコードを渡したければ、以下のようなコードを
使うことになるでしょう:

         PyObject *arglist;
         ...
         arglist = Py_BuildValue("(l)", eventcode);
         result = PyEval_CallObject(my_callback, arglist);
         Py_DECREF(arglist);
         if (result == NULL)
             return NULL; /* エラーを返す */
         /* 場合によってはここで結果を使うかもね */
         Py_DECREF(result);

`Py_DECREF(arglist)' が呼び出しの直後、エラーチェックよりも前に
置かれていることに注意してください! また、厳密に言えば、このコードは
完全ではありません: `Py_BuildValue()' はメモリ不足に
おちいるかもしれず、チェックしておくべきです。


File: python-ext-jp.info,  Node: 拡張モジュール関数でのパラメタ展開,  Next: 拡張モジュール関数のキーワードパラメタ,  Prev: C から Python 関数を呼び出す,  Up: C や C++ による Python の拡張

拡張モジュール関数でのパラメタ展開
==================================

`PyArg_ParseTuple()' は、以下のように宣言されています:

     int PyArg_ParseTuple(PyObject *arg, char *format, ...);

引数ARG は C 関数から Python に渡される引数リストが入った
タプルオブジェクトでなければなりません。 FORMAT 引数は書式化文字列で、

の "引数の解釈と値の構築" で解説されている書法に従わねばなりません。
残りの引数は、それぞれの変数のアドレスで、書式化文字列から
決まる型になっていなければなりません。

`PyArg_ParseTuple()' は Python 側から与えられた引数が
必要な型になっているか調べるのに対し、`PyArg_ParseTuple()'
は呼び出しの際に渡された C 変数のアドレスが有効な値を持つか調べ
られないことに注意してください: ここで間違いを犯すと、コードが
クラッシュするかもしれませんし、少なくともでたらめなビットを
メモリに上書きしてしまいます。慎重に!

呼び出し側に提供されるオブジェクトへの参照はすべて _借用_ 参照
(borrowed reference) になります; これらのオブジェクトの参照
カウントをデクリメントしてはなりません!

以下にいくつかの呼び出し例を示します:

         int ok;
         int i, j;
         long k, l;
         char *s;
         int size;
     
         ok = PyArg_ParseTuple(args, ""); /* 引数なし */
             /* Python での呼び出し: f() */

         ok = PyArg_ParseTuple(args, "s", &s); /* 文字列 */
             /* Python での呼び出し例: f('whoops!') */

         ok = PyArg_ParseTuple(args, "lls", &k, &l, &s);
             /* 二つの long と文字列 */
             /* Python での呼び出し例: f(1, 2, 'three') */

         ok = PyArg_ParseTuple(args, "(ii)s#", &i, &j, &s, &size);
             /* 二つの int と文字列、文字列のサイズも返す */
             /* Python での呼び出し例: f((1, 2), 'three') */

         {
             char *file;
             char *mode = "r";
             int bufsize = 0;
             ok = PyArg_ParseTuple(args, "s|si", &file, &mode, &bufsize);
             /* 文字列、オプションとして文字列がもう一つと整数が一つ */
             /* Python での呼び出し例:
                f('spam')
                f('spam', 'w')
                f('spam', 'wb', 100000) */
         }

         {
             int left, top, right, bottom, h, v;
             ok = PyArg_ParseTuple(args, "((ii)(ii))(ii)",
                      &left, &top, &right, &bottom, &h, &v);
             /* 矩形と点を表現するデータ */
             /* Python での呼び出し例:
                f(((0, 0), (400, 300)), (10, 10)) */
         }

         {
             Py_complex c;
             ok = PyArg_ParseTuple(args, "D:myfunction", &c);
             /* 複素数。エラー発生時用に関数名も指定 */
             /* Python での呼び出し例: myfunction(1+2j) */
         }


File: python-ext-jp.info,  Node: 拡張モジュール関数のキーワードパラメタ,  Next: 任意の値を構築する,  Prev: 拡張モジュール関数でのパラメタ展開,  Up: C や C++ による Python の拡張

拡張モジュール関数のキーワードパラメタ
======================================

`PyArg_ParseTupleAndKeywords()' は、以下のように宣言されています:

     int PyArg_ParseTupleAndKeywords(PyObject *arg, PyObject *kwdict,
                                     char *format, char *kwlist[], ...);

ARG と FORMAT パラメタは`PyArg_ParseTuple()' のものと同じです。KWDICT
パラメタはキーワード引数の入った 辞書で、 Python
ランタイムシステムから第三パラメタとして受け取ります。 KWLIST
パラメタは各パラメタを識別するための文字列からなる、
`NULL'終端されたリストです; 各パラメタ名は FORMAT 中の
型情報に対して左から右の順に照合されます。

成功すると`PyArg_ParseTupleAndKeywords()' は真を返し、
それ以外の場合には適切な例外を送出して偽を返します。

_Note:_ キーワード引数を使っている場合、タプルは入れ子にして使えません!
KWLIST 内に存在しないキーワードパラメタが渡された場合、 `TypeError'
の送出を引き起こします。

以下にキーワードを使ったモジュール例を示します。これは Geoff Philbrick
(<philbrick@hks.com>) によるプログラム例を もとにしています:

     #include "Python.h"
     
     static PyObject *
     keywdarg_parrot(PyObject *self, PyObject *args, PyObject *keywds)
     {
         int voltage;
         char *state = "a stiff";
         char *action = "voom";
         char *type = "Norwegian Blue";
     
         static char *kwlist[] = {"voltage", "state", "action", "type", NULL};
     
         if (!PyArg_ParseTupleAndKeywords(args, keywds, "i|sss", kwlist,
                                          &voltage, &state, &action, &type))
             return NULL;
     
         printf("-- This parrot wouldn't %s if you put %i Volts through it.\n",
                action, voltage);
         printf("-- Lovely plumage, the %s -- It's %s!\n", type, state);
     
         Py_INCREF(Py_None);
     
         return Py_None;
     }
     
     static PyMethodDef keywdarg_methods[] = {
         /* PyCFunction の値は PyObject* パラメタを二つだけしか引数に
          * 取らないが、 keywordarg_parrot() は三つとるので、キャストが
          * 必要。
          */
         {"parrot", (PyCFunction)keywdarg_parrot, METH_VARARGS | METH_KEYWORDS,
          "Print a lovely skit to standard output."},
         {NULL, NULL, 0, NULL}   /* センティネル値 */
     };

     void
     initkeywdarg(void)
     {
       /* モジュールを作成して関数を追加する */
       Py_InitModule("keywdarg", keywdarg_methods);
     }


File: python-ext-jp.info,  Node: 任意の値を構築する,  Next: 参照カウント法,  Prev: 拡張モジュール関数のキーワードパラメタ,  Up: C や C++ による Python の拡張

任意の値を構築する
==================

`Py_BuildValue()' は`PyArg_ParseTuple()' の
対極に位置するものです。この関数は以下のように定義されています:

     PyObject *Py_BuildValue(char *format, ...);

`Py_BuildValue()' は、`PyArg_ParseTuple()'
の認識する一連の書式化単位に似た書式化単位を認識します。ただし
(関数への出力ではなく、入力に使われる) 引数はポインタではなく、
ただの値でなければなりません。 Python から呼び出された C
関数が返す値として適切な、新たな Python オブジェクトを返します。

`PyArg_ParseTuple()' とは一つ違う点があります: `PyArg_ParseTuple()'
は第一引数をタプルにする必要があります (Python
の引数リストは内部的には常にタプルとして表現されるからです)
が、`Py_BuildValue()' はタプルを生成するとは限りません。
`Py_BuildValue()' は書式化文字列中に書式化単位が
二つかそれ以上入っている場合にのみタプルを構築します。
書式化文字列が空なら、`None' を返します。きっかり一つの
書式化単位なら、その書式化単位が記述している何らかのオブジェクト
になります。サイズが 0 や 1 のタプル返させたいのなら、書式化
文字列を丸括弧で囲います。

以下に例を示します (左に呼び出し例を、右に構築される Python
値を示します):

         Py_BuildValue("")                        None
         Py_BuildValue("i", 123)                  123
         Py_BuildValue("iii", 123, 456, 789)      (123, 456, 789)
         Py_BuildValue("s", "hello")              'hello'
         Py_BuildValue("ss", "hello", "world")    ('hello', 'world')
         Py_BuildValue("s#", "hello", 4)          'hell'
         Py_BuildValue("()")                      ()
         Py_BuildValue("(i)", 123)                (123,)
         Py_BuildValue("(ii)", 123, 456)          (123, 456)
         Py_BuildValue("(i,i)", 123, 456)         (123, 456)
         Py_BuildValue("[i,i]", 123, 456)         [123, 456]
         Py_BuildValue("{s:i,s:i}",
                       "abc", 123, "def", 456)    {'abc': 123, 'def': 456}
         Py_BuildValue("((ii)(ii)) (ii)",
                       1, 2, 3, 4, 5, 6)          (((1, 2), (3, 4)), (5, 6))


File: python-ext-jp.info,  Node: 参照カウント法,  Next: C++での拡張モジュール作成,  Prev: 任意の値を構築する,  Up: C や C++ による Python の拡張

参照カウント法
==============

C や C++のような言語では、プログラマはヒープ上のメモリを
動的に確保したり解放したりする責任があります。 こうした作業は C
では関数`malloc()' や`free()' で
行います。C++では本質的に同じ意味で演算子`new' や `delete'
が使われます。そこで、以下の議論は C の場合に限定 して行います。

`malloc()' が確保する全てのメモリブロックは、最終的には `free()'
を厳密に一度だけ呼び出して利用可能メモリのプールに
戻さねばなりません。そこで、適切な時に`free()' を呼び出す
ことが重要になります。 あるメモリブロックに対して、`free()'
を呼ばなかったにも
かかわらずそのアドレスを忘却してしまうと、ブロックが占有しているメモリ
はプログラムが終了するまで再利用できなくなります。
これはメモリリーク("memory leak") と呼ばれています。
逆に、プログラムがあるメモリブロックに対して`free()' を
呼んでおきながら、そのブロックを使い続けようとすると、 別の `malloc()'
呼び出しによって行われるブロックの再利用
と衝突を起こします。これは解放済みメモリの使用 ("using freed memory")
と呼ばれます。これは初期化されていないデータに対する参照と同様の
よくない結果 -- コアダンプ、誤った参照、不可解なクラッシュ --
を引き起こします。

よくあるメモリリークの原因はコード中の普通でない処理経路です。
例えば、ある関数があるメモリブロックを確保し、何らかの計算を行って、
再度ブロックを解放するとします。さて、関数の要求仕様を変更して、
計算に対するテストを追加すると、エラー条件を検出し、関数の途中で
処理を戻すようになるかもしれません。
この途中での終了が起きるとき、確保されたメモリブロックは解放し忘れ
やすいのです。コードが後で追加された場合には特にそうです。
このようなメモリリークが一旦紛れ込んでしまうと、長い間検出
されないままになることがよくあります: エラーによる関数の終了は、
全ての関数呼び出しのに対してほんのわずかな割合しか起きず、その一方で
ほとんどの近代的な計算機は相当量の仮想記憶を持っているため、
メモリリークが明らかになるのは、長い間動作していたプロセスが
リークを起こす関数を何度も使った場合に限られるからです。
従って、この種のエラーを最小限にとどめるようなコーディング規約や戦略を
設けて、不慮のメモリリークを避けることが重要なのです。

Python は`malloc()' や`free()' を非常によく利用
するため、メモリリークの防止に加え、解放されたメモリの使用を
防止する戦略が必要です。このために選ばれたのが 参照カウント法
("reference counting") と呼ばれる手法です。
参照カウント法の原理は簡単です: 全てのオブジェクトには
カウンタがあり、オブジェクトに対する参照がどこかに保存されたら
カウンタをインクリメントし、オブジェクトに対する参照が削除されたら
デクリメントします。カウンタがゼロになったら、オブジェクトへの
最後の参照が削除されたことになり、オブジェクトは解放されます。

もう一つの戦略は自動ガベージコレクション ("automatic garbage
collection") と呼ばれています。
(参照カウント法はガベージコレクション戦略の一つとして挙げられることも
あるので、二つを区別するために筆者は "自動 (automatic)"
を使っています。)
自動ガベージコレクションの大きな利点は、ユーザが`free()'
を明示的によばなくてよいことにあります。
(速度やメモリの有効利用性も利点として主張されています -- が、
これは確たる事実ではありません。) C
における自動ガベージコレクションの欠点は、真に可搬性のある
ガベージコレクタが存在しないということです。それに対し、
参照カウント法は可搬性のある実装ができます (`malloc()' や`free()'
を利用できるのが前提です -- C 標準は これを保証しています)。
いつの日か、十分可搬性のあるガベージコレクタが C で使えるように
なるかもしれませんが、それまでは参照カウント法でやっていく以外には
ないのです。

Python では、伝統的な参照カウント法の実装を行っている一方で、
参照の循環を検出するために働く循環参照検出機構 (cycle detector)
も提供しています。循環参照検出機構のおかげで、直接、間接に
かかわらず循環参照の生成を気にせずにアプリケーションを構築できます;
というのも、参照カウント法だけを使ったガベージコレクション実装に
とって循環参照は弱点だからです。 循環参照は、(間接参照の場合も含めて)
相互への参照が入ったオブジェクト
から形成されるため、循環内のオブジェクトは各々非ゼロの参照カウント
を持ちます。典型的な参照カウント法の実装では、たとえ循環参照を形成する
オブジェクトに対して他に全く参照がないとしても、
循環参照内のどのオブジェクトに属するメモリも再利用できません。

循環参照検出機構は、ごみとなった循環参照を検出し、Python で実装
された後始末関数 (finalizer、`__del__()' メソッド) が定義
されていないかぎり、それらのメモリを再利用できます。
後始末関数がある場合、検出機構は検出した循環参照を `gc' モジュール に
(具体的にはこのモジュールの `garbage' 変数内) に公開します。`gc'
モジュールではまた、 検出機構 (`collect()' 関数)
を実行する方法や設定用の
インタフェース、実行時に検出機構を無効化する機能も公開しています。
循環参照検出機構はオプションの機構とみなされています;
デフォルトで入ってはいますが、UNIX プラットフォーム (Mac OS X
も含みます) ではビルド時に`configure' スクリプトの `--without-cycle-gc'
オプションを使って、 他のプラットフォームでは`pyconfig.h'
ヘッダの`WITH_CYCLE_GC' 定義をはずして無効にできます。
こうして循環参照検出機構を無効化すると、`gc' モジュールは
利用できなくなります。

* Menu:

* Python における参照カウント法::
* 所有権にまつわる規則::
* 薄氷::
* NULL ポインタ::


File: python-ext-jp.info,  Node: Python における参照カウント法,  Next: 所有権にまつわる規則,  Prev: 参照カウント法,  Up: 参照カウント法

Python における参照カウント法
-----------------------------

Python には、参照カウントのインクリメントやデクリメントを処理する二つの
マクロ、`Py_INCREF(x)' と `Py_DECREF(x)' があります。 `Py_DECREF()'
は、参照カウントがゼロに到達した際に、
オブジェクトのメモリ解放も行います。 柔軟性を持たせるために、`free()'
を直接呼び出しません -- その代わりにオブジェクトの型オブジェクト ("type
object") を介します。このために
(他の目的もありますが)、全てのオブジェクトには
自身の型オブジェクトに対するポインタが入っています。

さて、まだ重大な疑問が残っています: いつ `Py_INCREF(x)' や
`Py_DECREF(x)' を使えばよいのでしょうか?
まず、いくつかの用語説明から始めさせてください。 まず、オブジェクトは
"占有 (own)" されることはありません;
しかし、あるオブジェクトに対する参照の所有 "own a reference"
はできます。オブジェクトの参照カウントは、そのオブジェクトが
参照を所有を受けている回数と定義されています。
参照の所有者は、参照が必要なくなった際に`Py_DECREF()'
を呼び出す役割を担います。参照の所有権は委譲 (transfer) できます。
所有参照 (owned reference) の放棄には、渡す、保存する、 `Py_DECREF()'
を呼び出す、という三つの方法があります。
所有参照を処理し忘れると、メモリリークを引き起こします。

オブジェクトに対する参照は、借用 ("borrow") も可能です。 (1)
参照の借用者は、`Py_DECREF()' を呼んではなりません。
借用者は、参照の所有者から借用した期間を超えて参照を保持し続けては
なりません。所有者が参照を放棄した後で借用参照を使うと、
解放済みメモリを使用してしまう危険があるので、絶対に避けねばなりません。
(2)

参照の借用が参照の所有よりも優れている点は、コードがとりうる
あらゆる処理経路で参照を廃棄しておくよう注意しなくて済むことです --
別の言い方をすれば、借用参照の場合には、処理の途中で関数を
終了してもメモリリークの危険を冒すことがない、ということです。
逆に、メモリリークの危険を冒すよりも不利な点は、ごくまともに
見えるコードが、実際には参照の借用元で放棄されてしまった後に
その参照を使うかもしれないような微妙な状況があるということです。

`Py_INCREF()' を呼び出すと、借用参照を所有参照
に変更できます。この操作は参照の借用元の状態には影響しません --
`Py_INCREF()' は新たな所有参照を生成し、参照の所有者が
担うべき全ての責任を課します (つまり、新たな参照の所有者は、以前の
所有者と同様、参照の放棄を適切に行わねばなりません)。

---------- Footnotes ----------

(1) 参照を "借用する" というメタファは厳密には正しくありません:
なぜなら、参照の所有者は依然として参照のコピーを持っている からです。

(2) 参照カウントが 1 以上かどうか調べる方法は *うまくいきません* --
参照カウント自体も解放されたメモリ上に
あるため、その領域が他のオブジェクトに使われている可能性があります!


File: python-ext-jp.info,  Node: 所有権にまつわる規則,  Next: 薄氷,  Prev: Python における参照カウント法,  Up: 参照カウント法

所有権にまつわる規則
--------------------

オブジェクトへの参照を関数の内外に渡す場合には、オブジェクトの
所有権が参照と共に渡されるか否かが常に関数インタフェース仕様の一部と
なります。

オブジェクトへの参照を返すほとんどの関数は、参照とともに所有権も
渡します。特に、`PyInt_FromLong()' や `Py_BuildValue()'
のように、新しいオブジェクトを生成する
関数は全て所有権を相手に渡します。オブジェクトが実際には新たな
オブジェクトでなくても、そのオブジェクトに対する新たな参照の
所有権を得ます。例えば、`PyInt_FromLong()'
はよく使う値をキャッシュしており、キャッシュされた値への参照を
返すことがあります。

`PyObject_GetAttrString()' のように、あるオブジェクトから
別のオブジェクトを抽出するような関数もまた、参照とともに所有権を
委譲します。こちらの方はやや理解しにくいかもしれません。というのは
よく使われるルーチンのいくつかが例外となっているからです:
`PyTuple_GetItem()'、 `PyList_GetItem()'、 `PyDict_GetItem()'、および
`PyDict_GetItemString()'
は全て、タプル、リスト、または辞書から借用参照を返します。

`PyImport_AddModule()' は、実際にはオブジェクトを生成して
返すことがあるにもかかわらず、借用参照を返します: これが可能なのは、
生成されたオブジェクトに対する所有参照は`sys.modules' に
保持されるからです。

オブジェクトへの参照を別の関数に渡す場合、一般的には、関数側は
呼び出し手から参照を借用します -- 参照を保存する必要があるなら、
関数側は`Py_INCREF()' を呼び出して独立した所有者に
なります。とはいえ、この規則には二つの重要な例外: `PyTuple_SetItem()'
と`PyList_SetItem()'
があります。これらの関数は、渡された引数要素に対して所有権を 乗っ取り
(take over) ます -- たとえ失敗してもです!  (`PyDict_SetItem()'
とその仲間は所有権を乗っ取りません -- これらはいわば "普通の"
関数です。)

Python から C 関数が呼び出される際には、C 関数は呼び出し側から
引数への参照を借用します。C 関数の呼び出し側はオブジェクトへの参照を
所有しているので、借用参照の生存期間が保証されるのは関数が処理を
返すまでです。このようにして借用参照を保存したり他に渡したりしたい
場合にのみ、`Py_INCREF()' を使って所有参照にする必要が あります。

Python から呼び出された C 関数が返す参照は所有参照でなければ なりません
-- 所有権は関数から呼び出し側へと委譲されます。


File: python-ext-jp.info,  Node: 薄氷,  Next: NULL ポインタ,  Prev: 所有権にまつわる規則,  Up: 参照カウント法

薄氷
----

数少ない状況において、一見無害に見える借用参照の利用が問題をひきおこす
ことがあります。この問題はすべて、インタプリタが非明示的に呼び出され、
インタプリタが参照の所有者に参照を放棄させてしまう状況と関係しています。

知っておくべきケースのうち最初の、そして最も重要なものは、
リスト要素に対する参照を借りている際に起きる、
関係ないオブジェクトに対する`Py_DECREF()' の使用です。 例えば:

     void
     bug(PyObject *list)
     {
         PyObject *item = PyList_GetItem(list, 0);
     
         PyList_SetItem(list, 1, PyInt_FromLong(0L));
         PyObject_Print(item, stdout, 0); /* BUG! */
     }

上の関数はまず、`list[0]' への参照を借用し、次に`list[1]' を値 `0'
で置き換え、最後にさきほど借用した参照を出力
しています。何も問題ないように見えますね? でもそうではないのです!

`PyList_SetItem()' の処理の流れを追跡してみましょう。
リストは全ての要素に対して参照を所有しているので、要素 1 を
置き換えると、以前の要素 1 を放棄します。ここで、以前の要素 1
がユーザ定義クラスのインスタンスであり、さらにこのクラスが `__del__()'
メソッドを定義していると仮定しましょう。
このクラスインスタンスの参照カウントが 1 だった場合、
リストが参照を放棄すると、インスタンスの `__del__()'
メソッドが呼び出されます。

クラスは Python で書かれているので、`__del__()' は任意の Python
コードを実行できます。この `__del__()' が `bug()' における `item'
に何か不正なことをして いるのでしょうか? その通り! `buf()'
に渡したリストが `__del__()' メソッドから操作できるとすると、`del
list[0]' の効果を持つような文を実行できてしまいます。もしこの操作で
`list[0]' に対する最後の参照が放棄されてしまうと、 `list[0]'
に関連付けられていたメモリは解放され、 結果的に `item'
は無効な値になってしまいます。

問題の原因が分かれば、解決は簡単です。
一時的に参照回数を増やせばよいのです。
正しく動作するバージョンは以下のようになります:

     void
     no_bug(PyObject *list)
     {
         PyObject *item = PyList_GetItem(list, 0);
     
         Py_INCREF(item);
         PyList_SetItem(list, 1, PyInt_FromLong(0L));
         PyObject_Print(item, stdout, 0);
         Py_DECREF(item);
     }

これは実際にあった話です。以前のバージョンの Python には、
このバグの一種が潜んでいて、`__del__()' メソッドが
どうしてうまく動かないのかを調べるために C デバッガで相当
時間を費やした人がいました...

二つ目は、借用参照がスレッドに関係しているケースです。 通常は、 Python
インタプリタにおける複数のスレッドは、
グローバルインタプリタロックがオブジェクト空間全体を保護している
ため、互いに邪魔し合うことはありません。とはいえ、ロックは
`Py_BEGIN_ALLOW_THREADS' マクロで一時的に解除したり、
`Py_END_ALLOW_THREADS' で再獲得したりできます。
これらのマクロはブロックの起こる I/O 呼び出しの周囲によく置かれ、 I/O
が完了するまでの間に他のスレッドがプロセッサを利用できるように
します。明らかに、以下の関数は上の例と似た問題をはらんでいます:

     void
     bug(PyObject *list)
     {
         PyObject *item = PyList_GetItem(list, 0);
         Py_BEGIN_ALLOW_THREADS
         ...ブロックが起こる何らかの I/O 呼び出し...
         Py_END_ALLOW_THREADS
         PyObject_Print(item, stdout, 0); /* BUG! */
     }

