This is python-lib-jp.info, produced by makeinfo version 4.5 from
python-lib-jp.texi.

12 October 2005


File: python-lib-jp.info,  Node: リソースの制限,  Next: リソースの使用状態,  Prev: resource,  Up: resource

リソースの制限
--------------

リソースの使用は下に述べる `setrlimit()' 関数を使って制限
することができます。各リソースは二つ組の制限値: ソフトリミット (soft
limit) 、およびハードリミット (hard limit) 、で制御されます。
ソフトリミットは現在の制限値で、時間とともにプロセスによって下げたり
上げたりできます。ソフトリミットはハードリミットを超えることは
できません。ハードリミットはソフトリミットよりも高い任意の値まで
下げることができますが、上げることはできません。(スーパユーザの 有効な
UID を持つプロセスのみがハードリミットを上げることができます。)

制限をかけるべく指定できるリソースはシステムに依存します。指定できる
リソースは `getrlimit(2)' マニュアルページで解説されています。
以下に列挙するリソースは背後のオペレーティングシステムがサポートする
場合にサポートされています; オペレーティングシステム側で値を調べたり
制御したりできないリソースは、そのプラットフォーム向けのこのモジュール
内では定義されていません。

`getrlimit(resource)'
     RESOURCE の現在のソフトおよびハードリミットを表すタプル `(SOFT,
     HARD)' を返します。無効なリソースが 指定された場合には
     `ValueError' が、背後のシステム コールが予期せず失敗した場合には
     `error' が送出されます。

`setrlimit(resource, limits)'
     RESOUCE の新たな消費制限を設定します。LIMITS 引数 には、タプル
     `(SOFT, HARD)' による二つの整数で、
     新たな制限を記述しなければなりません。現在指定可能な最大の制限
     を指定するために `-1' を使うことができます。

     無効なリソースが指定された場合、ソフトリミットの値がハードリミット
     の値を超えている場合、プロセスが (スーパユーザの有効な UID を持って
     いない状態で) ハードリミットを引き上げようとした場合には
     `ValueError' が送出されます。背後のシステムコールが予期せず
     失敗した場合には `error' が送出される可能性もあります。

以下のシンボルは、後に述べる関数 `setrlimit()' および `getrlimit()'
を使って消費量を制御することができるリソース
を定義しています。これらのシンボルの値は、C プログラムで使われて
いるシンボルと全く同じです。

`getrlimit(2)' の UNIX マニュアルページには、指定可能な
リソースが列挙されています。全てのシステムで同じシンボルが使われて
いるわけではなく、また同じリソースを表すために同じ値が使われて
いるとも限らないので注意してください。このモジュールはプラットフォーム
間の相違を隠蔽しようとはしていません -- あるプラットフォームで
定義されていないシンボルは、そのプラットフォーム向けの本モジュール
では利用することができません。

`RLIMIT_CORE'
     現在のプロセスが生成できるコアファイルの最大 (バイト) サイズです。
     プロセスの全体イメージを入れるためにこの値より大きなサイズのコア
     ファイルが要求された結果、部分的なコアファイルが生成される可能性が
     あります。

`RLIMIT_CPU'
     プロセッサが利用することができる最大プロセッサ時間 (秒) です。
     この制限を超えた場合、`SIGXCPU' シグナルがプロセスに送られ
     ます。(どのようにしてシグナルを捕捉したり、例えば開かれているファイルを
     ディスクにフラッシュするといった有用な処理を行うかについての情報は、
     `signal' モジュールのドキュメントを参照してください)

`RLIMIT_FSIZE'
     プロセスが生成できるファイルの最大サイズです。マルチスレッドプロセス
     の場合、この値は主スレッドのスタックにのみ影響します。

`RLIMIT_DATA'
     プロセスのヒープの最大 (バイト) サイズです。

`RLIMIT_STACK'
     現在のプロセスのコールスタックの最大 (バイト) サイズです。

`RLIMIT_RSS'
     プロセスが取りうる最大 RAM 常駐ページサイズ (resident set size)
     です。

`RLIMIT_NPROC'
     現在のプロセスが生成できるプロセスの上限です。

`RLIMIT_NOFILE'
     現在のプロセスが開けるファイル記述子の上限です。

`RLIMIT_OFILE'
     `RLIMIT_NOFILE' の BSD での名称です。

`RLIMIT_MEMLOCK'
     メモリ中でロックできる最大アドレス空間です。

`RLIMIT_VMEM'
     プロセスが占有できるマップメモリの最大領域です。

`RLIMIT_AS'
     アドレス空間でプロセスが占有できる最大領域 (バイト) です。


File: python-lib-jp.info,  Node: リソースの使用状態,  Prev: リソースの制限,  Up: resource

リソースの使用状態
------------------

以下の関数はリソース使用情報を取得するために使われます:

`getrusage(who)'
     この関数は、WHO 引数で指定される、現プロセスおよびその子プロセスに
     よって消費されているリソースを記述するオブジェクトを返します。 WHO
     引数は以下に記述される `RUSAGE_*' 定数のいずれかを
     使って指定します。

     返される値の各フィールドはそれぞれ、個々のシステムリソースがどれくらい
     使用されているか、例えばユーザモードでの実行に費やされた時間やプロセス
     が主記憶からスワップアウトされた回数、を示しています。幾つかの値、
     例えばプロセスが使用しているメモリ量は、内部時計の最小単位に依存します。

     以前のバージョンとの互換性のため、返される値は 16
     要素からなるタプル としてアクセスすることもできます。

     戻り値のフィールド `ru_utime' および `ru_stime' は
     浮動小数点数で、それぞれユーザモードでの実行に費やされた時間、および
     システムモードでの実行に費やされた時間を表します。それ以外の値は
     整数です。これらの値に関する詳しい情報は `getrusage(2)'
     を調べてください。以下に簡単な概要を示します:

     インデクス             フィールド名           リソース
     ------                 -----                  -----
     0                      `ru_utime'             ユーザモード実行時間
                                                   (float)
     1                      `ru_stime'             システムモード実行時間
                                                   (float)
     2                      `ru_maxrss'            最大常駐ページサイズ
     3                      `ru_ixrss'             共有メモリサイズ
     4                      `ru_idrss'             非共有メモリサイズ
     5                      `ru_isrss'             非共有スタックサイズ
     6                      `ru_minflt'            I/O
                                                   を必要とするページフォールト数
     7                      `ru_majflt'            I/O
                                                   を必要としないページフォールト数
     8                      `ru_nswap'             スワップアウト回数
     9                      `ru_inblock'           ブロック入力操作数
     10                     `ru_oublock'           ブロック出力操作数
     11                     `ru_msgsnd'            送信メッセージ数
     12                     `ru_msgrcv'            受信メッセージ数
     13                     `ru_nsignals'          受信シグナル数
     14                     `ru_nvcsw'             自発的な実行コンテキスト切り替え数
     15                     `ru_nivcsw'            非自発的な実行コンテキスト切り替え数

     この関数は無効な WHO 引数を指定した場合には `ValueError'
     を送出します。また、異常が発生 した場合には `error'
     例外が送出される可能性があります。

     _Changed in Python version 2.3_

`getpagesize()'
     システムページ内のバイト数を返します。(ハードウェアページサイズと
     同じとは限りません。) この関数はプロセスが使用しているメモリの
     バイト数を決定する上で有効です。`getrusage()' が 返すタプルの 3
     つ目の要素はページ数で数えたメモリ使用量です;
     ページサイズを掛けるとバイト数になります。

以下の `RUSAGE_*' シンボルはどのプロセスの情報を提供させるか
を指定するために関数 `getrusage()' に渡されます。

`RUSAGE_SELF'
     `RUSAGE_SELF' はプロセス自体に属する情報を要求するために
     使われます。

`RUSAGE_CHILDREN'
     `getrusage()' に渡すと呼び出し側プロセスの子プロセスのリソース
     情報を要求します。

`RUSAGE_BOTH'
     `getrusage()' に渡すと現在のプロセスおよび子プロセスの両方が
     消費しているリソースを要求します。全てのシステムで利用可能なわけでは
     ありません。


File: python-lib-jp.info,  Node: nis,  Next: syslog,  Prev: resource,  Up: Unix独特のサービス

Sun の NIS (Yellow Pages) へのインタフェース
============================================

Sun の NIS (Yellow Pages) ライブラリへのインタフェース。

`nis' モジュールは複数のホストを集中管理する上で便利な NIS
ライブラリを薄くラップします。

NIS は UNIX システム上にしかないので、このモジュールは
UNIXでしか利用できません。

`nis' モジュールでは以下の関数を定義しています:

`match(key, mapname)'
     MAPNAME 中で KEY に一致するものを返すか、見つからない
     場合にはエラー (`nis.error') を送出します。
     両方の引数とも文字列で、 KEY は 8 ビットクリーンです。
     返される値は (`NULL' その他を含む可能性のある) 任意のバイト配列
     です。

     MAPNAME は他の名前の別名になっていないか最初にチェックされます。

`cat(mapname)'
     `match(KEY, MAPNAME)==VALUE' となる KEY を VALUE
     に対応付ける辞書を返します。
     辞書内のキーと値は共に任意のバイト列なので注意してください。

     MAPNAME は他の名前の別名になっていないか最初にチェックされます。

`maps()'
     有効なマップのリストを返します。

`nis' モジュールは以下の例外を定義しています:

`error'
     NIS 関数がエラーコードを返した場合に送出されます。


File: python-lib-jp.info,  Node: syslog,  Next: commands,  Prev: nis,  Up: Unix独特のサービス

UNIX syslog ライブラリルーチン群
================================

UNIX syslog ライブラリルーチン群へのインタフェース。

このモジュールでは UNIX `syslog' ライブラリルーチン群への
インタフェースを提供します。`syslog' の便宜レベルに関する詳細な記述 は
UNIX マニュアルページを参照してください。

このモジュールでは以下の関数を定義しています:

`syslog([priority,] message)'
     文字列 MESSAGE をシステムログ機構に送信します。末尾の改行文字
     は必要に応じて追加されます。各メッセージは FACILITY および LEVEL
     からなる優先度でタグ付けされます。オプションの PRIORITY
     引数はメッセージの優先度を定義します。標準の 値は `LOG_INFO'
     です。PRIORITY 中に、便宜レベルが (`LOG_INFO | LOG_USER' のように)
     論理和を使ってコード化されて いない場合、`openlog()'
     を呼び出した際の値が使われます。

`openlog(ident[, logopt[, facility]])'
     標準以外のログオプションは、`syslog()' の呼び出しに先立って
     `openlog()'
     でログファイルを開く際、明示的に設定することができます。
     標準の値は (通常) INDENT = `'syslog''、 LOGOPT = `0'、FACILITY =
     `LOG_USER' です。 IDENT
     引数は全てのメッセージの先頭に付加する文字列です。 オプションの
     LOGOPT 引数はビットフィールドの値になります -
     とりうる組み合わせ値については以下を参照してください。
     オプションの FACILITY 引数は、便宜レベルコードの設定が
     明示的になされていないメッセージに対する、標準の便宜レベルを設定します。

`closelog()'
     ログファイルを閉じます。

`setlogmask(maskpri)'
     優先度マスクを MASKPRI に設定し、以前のマスク値を返します。
     MASKPRI に設定されていない優先度レベルを持った `syslog()'
     の呼び出しは無視されます。標準では全ての優先度をログ出力します。
     関数 `LOG_MASK(PRI)' は個々の優先度 PRI に対する
     優先度マスクを計算します。関数 `LOG_UPTO(PRI)' は優先度 PRI
     までの全ての優先度を含むようなマスクを計算します。

このモジュールでは以下の定数を定義しています:

`優先度 (高い優先度順):'
     `LOG_EMERG'、 `LOG_ALERT'、 `LOG_CRIT'、 `LOG_ERR'、
     `LOG_WARNING'、 `LOG_NOTICE'、 `LOG_INFO'、 `LOG_DEBUG'。

`便宜レベル:'
     `LOG_KERN'、 `LOG_USER'、 `LOG_MAIL'、 `LOG_DAEMON'、 `LOG_AUTH'、
     `LOG_LPR'、 `LOG_NEWS'、 `LOG_UUCP'、 `LOG_CRON'、および
     `LOG_LOCAL0' から `LOG_LOCAL7'。

`ログオプション:'
     `<syslog.h>' で定義されている場合、 `LOG_PID'、 `LOG_CONS'、
     `LOG_NDELAY'、 `LOG_NOWAIT'、および `LOG_PERROR'。



File: python-lib-jp.info,  Node: commands,  Prev: syslog,  Up: Unix独特のサービス

コマンド実行ユーティリティ
==========================

外部コマンドを実行するためのユーティリティです。

`commands'は、システムへコマンド文字列を渡して実行する
`os.popen()'のラッパー関数を含んでいるモジュールです。
外部で実行したコマンドの結果や、その終了ステータスを扱います。

`commands'モジュールは以下の関数を定義しています。

`getstatusoutput(cmd)'
     文字列CMDを`os.popen()'を使いシェル上で実行し、 タプル`(STATUS,
     OUTPUT)'を返します。 実際には`{ CMD ; } 2>&1'と実行されるため、
     標準出力とエラー出力が混合されます。
     また、出力の最後の改行文字は取り除かれます。
     コマンドの終了ステータスはC言語関数の`wait()'の規則に従って
     解釈することができます。

`getoutput(cmd)'
     `getstatusoutput()'に似ていますが、
     終了ステータスは無視され、コマンドの出力のみを返します。

`getstatus(file)'
     `ls -ld FILE'の出力を文字列で返します。
     この関数は`getoutput()'を使い、引数内の
     バックスラッシュ記号「$\backslash$」とドル記号「$」を適切にエスケープします。

例:

     >>> import commands
     >>> commands.getstatusoutput('ls /bin/ls')
     (0, '/bin/ls')
     >>> commands.getstatusoutput('cat /bin/junk')
     (256, 'cat: /bin/junk: No such file or directory')
     >>> commands.getstatusoutput('/bin/junk')
     (256, 'sh: /bin/junk: not found')
     >>> commands.getoutput('ls /bin/ls')
     '/bin/ls'
     >>> commands.getstatus('/bin/ls')
     '-rwxr-xr-x  1 root        13352 Oct 14  1994 /bin/ls'


File: python-lib-jp.info,  Node: Pythonデバッガ,  Next: Python プロファイラ,  Prev: Unix独特のサービス,  Up: Top

Pythonデバッガ
**************

対話的インタプリタのためのPythonデバッガ。

モジュール`pdb'はPythonプログラム用の対話的ソースコードデバッガ
を定義します。(条件付き)ブレークポイントの設定やソース行レベルでのシングルステップ実行、スタックフレームのインスペクション、ソースコードリスティングおよびいかなるスタックフレームのコンテキストにおける任意のPythonコードの評価をサポートしています。事後解析デバッギングもサポートし、プログラムの制御下で呼び出すことができます。

デバッガは拡張可能です -- 実際にはクラス`Pdb'
として定義されています。現在これについてのドキュメントはありませんが、ソースを読めば簡単に理解できます。拡張インターフェースはモジュール`bdb'
(ドキュメントなし)と`cmd' を使っています。

デバッガのプロンプトは`(Pdb)
'です。デバッガに制御された状態でプログラムを実行するための典型的な使い方は:

     >>> import pdb
     >>> import mymodule
     >>> pdb.run('mymodule.test()')
     > <string>(0)?()
     (Pdb) continue
     > <string>(1)?()
     (Pdb) continue
     NameError: 'spam'
     > <string>(1)?()
     (Pdb)

他のスクリプトをデバッグするために、`pdb.py'をスクリプトとして呼び出すこともできますせます。例えば:

     python /usr/local/lib/python1.5/pdb.py myscript.py

クラッシュしたプログラムを調べるための典型的な使い方は:

     >>> import pdb
     >>> import mymodule
     >>> mymodule.test()
     Traceback (most recent call last):
       File "<stdin>", line 1, in ?
       File "./mymodule.py", line 4, in test
         test2()
       File "./mymodule.py", line 3, in test2
         print spam
     NameError: spam
     >>> pdb.pm()
     > ./mymodule.py(3)test2()
     -> print spam
     (Pdb)

モジュールは以下の関数を定義しています。それぞれが少しづつ違った方法でデバッガに入ります:

`run(statement[, globals[, locals]])'
     デバッガに制御された状態で(文字列として与えられた)STATEMENTを実行します。デバッガプロンプトはあらゆるコードが実行される前に現れます。ブレークポイントを設定し、`continue'とタイプできます。あるいは、文を`step'や`next'を使って一つづつ実行することができます(これらのコマンドはすべて下で説明します)。オプションのGLOBALSとLOCALS引数はコードを実行する環境を指定します。デフォルトでは、モジュール`__main__'の辞書が使われます。(`exec'文または`eval()'組み込み関数の説明を参照してください。)

`runeval(expression[, globals[, locals]])'
     デバッガの制御もとで(文字列として与えられる)EXPRESSIONを評価します。`runeval()'がリターンしたとき、式の値を返します。その他の点では、この関数は`run()'を同様です。

`runcall(function[, argument, ...])'
     FUNCTION(関数またはメソッドオブジェクト、文字列ではありません)を与えられた引数とともに呼び出します。`runcall()'がリターンしたとき、関数呼び出しが返したものは何でも返します。デバッガプロンプトは関数に入るとすぐに現れます。

`set_trace()'
     スタックフレームを呼び出したところでデバッガに入ります。たとえコードが別の方法でデバッグされている最中でなくても(例えば、アサーションが失敗するとき)、これはプログラムの所定の場所でブレークポイントをハードコードするために役に立ちます。

`post_mortem(traceback)'
     与えられたTRACEBACKオブジェクトの事後解析デバッギングに入ります。

`pm()'
     `sys.last_traceback'のトレースバックの事後解析デバッギングに入ります。

* Menu:

* デバッガコマンド::
* どのように動作しているか::


File: python-lib-jp.info,  Node: デバッガコマンド,  Next: どのように動作しているか,  Prev: Pythonデバッガ,  Up: Pythonデバッガ

デバッガコマンド
================

デバッガは以下のコマンドを認識します。ほとんどのコマンドは一文字または二文字に省略することができます。例えば、`h(elp)'が意味するのは、ヘルプコマンドを入力するために`h'か`help'のどちらか一方を使うことができるということです(が、`he'や`hel'は使えず、また`H'や`Help'、`HELP'も使えません)。コマンドの引数は空白(スペースまたはタブ)で区切られなければなりません。オプションの引数はコマンド構文の角括弧(`[]')の中に入れなければなりません。角括弧をタイプしてはいけません。コマンド構文における選択肢は垂直バー(`|')で区切られます。

空行を入力すると入力された直前のコマンドを繰り返します。例外:
直前のコマンドが`list'コマンドならば、次の11行がリストされます。

デバッガが認識しないコマンドはPython文とみなして、デバッグしているプログラムのコンテキストおいて実行されます。Python文は感嘆符(`!')を前に付けることもできます。これはデバッグ中のプログラムを調査する強力な方法です。変数を変更したり関数を呼び出したりすることさえ可能です。このような文で例外が発生した場合には例外名がプリントされますが、デバッガの状態は変化しません。

複数のコマンドを`;;'で区切って一行で入力することができます。(一つだけの`;'は使われません。なぜなら、Pythonパーサへ渡される行内の複数のコマンドのための分離記号だからです。)コマンドを分割するために何も知的なことはしていません。たとえ引用文字列の途中であっても、入力は最初の`;;'対で分割されます。

デバッガはエイリアスをサポートします。エイリアスはパラメータを持つことができ、調査中のコンテキストに対して人がある程度柔軟に対応できます。

ファイル`.pdbrc'
はユーザのホームディレクトリか、またはカレントディレクトリにあります。それはまるでデバッガのプロンプトでタイプしたかのように読み込まれて実行されます。これは特にエイリアスのために便利です。両方のファイルが存在する場合、ホームディレクトリのものが最初に読まれ、そこに定義されているエイリアスはローカルファイルにより上書きされることがあります。

`h(elp) [COMMAND]'
     引数なしでは、利用できるコマンドの一覧をプリントします。引数としてCOMMANDがある場合は、そのコマンドについてのヘルプをプリントします。`help
     pdb'は完全ドキュメンテーションファイルを表示します。環境変数`PAGER'が定義されているならば、代わりにファイルはそのコマンドへパイプされます。COMMAND引数が識別子でなければならないので、`!'コマンドについてのヘルプを得るためには`help
     exec'と入力しなければならない。

`w(here)'
     スタックの底にある最も新しいフレームと一緒にスタックトレースをプリントします。矢印はカレントフレームを指し、それがほとんどのコマンドのコンテキストを決定します。

`d(own)'
     (より新しいフレームに向かって)スタックトレース内でカレントフレームを一レベル下げます。

`u(p)'
     (より古いフレームに向かって)スタックトレース内でカレントフレームを一レベル上げます。

`b(reak) [[FILENAME:]LINENO`{|}'FUNCTION[, CONDITION]]'
     LINENO引数がある場合は、現在のファイルのその場所にブレークポイントを設定します。FUNCTION引数がある場合は、その関数の中の最初の実行可能文にブレークポイントを設定します。別のファイル(まだロードされていないかもしれないもの)のブレークポイントを指定するために、行番号はファイル名とコロンをともに先頭に付けられます。
     ファイルは`sys.path'にそって検索されます。各ブレークポイントは番号を割り当てられ、その番号を他のすべてのブレークポイントコマンドが参照することに注意してください。

     第二引数を指定する場合、その値は式で、その評価値が真でなければ
     ブレークポイントは有効になりません。

     引数なしの場合は、それぞれのブレークポイントに対して、そのブレークポイントに行き当たった回数、現在の通過カウント(ignore
     count)と、もしあれば関連条件を含めてすべてのブレークポイントをリストします。

`tbreak [[FILENAME:]LINENO`{|}'FUNCTION[, CONDITION]]'
     一時的なブレークポイントで、最初にそこに達したときに自動的に取り除かれます。引数はbreakと同じです。

`cl(ear) [BPNUMBER [BPNUMBER ...]]'
     スペースで区切られたブレークポイントナンバーのリストを与えると、それらのブレークポイントを解除します。引数なしの場合は、すべてのブレークポイントを解除します(が、はじめに確認します)。

`disable [BPNUMBER [BPNUMBER ...]]'
     スペースで区切られたブレークポイントナンバーのリストとして与えられるブレークポイントを無効にします。ブレークポイントを無効にすると、プログラムの実行を止めることができなくなりますが、ブレークポイントの解除と違いブレークポイントのリストに残ったままになり、(再び)有効にすることができます。

`enable [BPNUMBER [BPNUMBER ...]]'
     指定したブレークポイントを有効にします。

`ignore BPNUMBER [COUNT]'
     与えられたブレークポイントナンバーに通過カウントを設定します。countが省略されると、通過カウントは0に設定されます。通過カウントがゼロになったとき、ブレークポイントが機能する状態になります。ゼロでないときは、そのブレークポイントが無効にされず、どんな関連条件も真に評価されていて、ブレークポイントに来るたびにcountが減らされます。

`condition BPNUMBER [CONDITION]'
     conditionはブレークポイントがhonored(???)する前に真に評価しなければならない式です。conditionがない場合は、どんな既存の条件も取り除かれます。すなわち、ブレークポイントに条件がありません。

`s(tep)'
     現在の行を実行し、最初に実行可能なものがあらわれたときに(呼び出された関数の」中か、現在の関数の次の行で)停止します.

`n(ext)'
     現在の関数の次の行に達するか、あるいは関数が返るまで実行を継続します。(`next'と`step'の差は`step'が呼び出された関数の内部で停止するのに対し、`next'は呼び出された関数を(ほぼ)全速力で実行し、現在の関数内の次の行で停止するだけです。

`r(eturn)'
     現在の関数が返るまで実行を継続します。

`c(ont(inue))'
     ブレークポイントに出会うまで、実行を継続します。

`j(ump) LINENO'
     次に実行する行を指定します。最も底のフレーム中でのみ実行可能です。
     前に戻って実行したり、不要な部分をスキップして先の処理を実行する
     場合に使用します。

     ジャンプには制限があり、例えば
     `for'ループの中には飛び込めませんし、
     `finally'節の外にも飛ぶ事ができません。

`l(ist) [FIRST[, LAST]]'
     現在のファイルのソースコードをリスト表示します。引数なしの場合は、現在の行の周囲を11行リストするか、または前のリストの続きを表示します。引数が一つある場合は、その行の周囲を11行表示します。引数が二つの場合は、与えられた範囲をリスト表示します。第二引数が第一引数より小さいときは、カウントと解釈されます。

`a(rgs)'
     現在の関数の引数リストをプリントします。

`p EXPRESSION'
     現在のコンテキストにおいてEXPRESSIONを評価し、その値をプリントします。(注意:
     `print'も使うことができますが、デバッガコマンドではありません --
     これはPythonの`print'文を実行します。)

`pp EXPRESSION'
     `pprint'モジュールを使って例外の値が整形されることを除いて`p'コマンドと同様です。

`alias [NAME [command]]'
     NAMEという名前のCOMMANDを実行するエイリアスを作成します。コマンドは引用符で囲まれていては_いけません_。入れ替え可能なパラメータは`%1'、`%2'などで指し示され、さらに`%*'は全パラメータに置き換えられます。コマンドが与えられなければ、NAMEに対する現在のエイリアスを表示します。引数が与えられなければ、すべてのエイリアスがリストされます。

     エイリアスは入れ子になってもよく、pdbプロンプトで合法的にタイプできるどんなものでも含めることができます。内部pdbコマンドをエイリアスによって上書きすることが_できます_。そのとき、このようなコマンドはエイリアスが取り除かれるまで隠されます。エイリアス化はコマンド行の最初の語へ再帰的に適用されます。行の他のすべての語はそのままです。

     例として、二つの便利なエイリアスがあります(特に`.pdbrc'ファイルに置かれたときに):

          #Print instance variables (usage "pi classInst")
          alias pi for k in %1.__dict__.keys(): print "%1.",k,"=",%1.__dict__[k]
          #Print instance variables in self
          alias ps pi self

`unalias NAME'
     指定したエイリアスを削除します。

`[!]STATEMENT'
     現在のスタックフレームのコンテキストにおいて(一行の)STATEMENTを実行します。文の最初の語がデバッガコマンドと共通でない場合は、感嘆符を省略することができます。グローバル変数を設定するために、同じ行に`global'コマンドとともに代入コマンドの前に付けることができます。

          (Pdb) global list_options; list_options = ['-l']
          (Pdb)

`q(uit)'
     デバッガを終了します。実行しているプログラムは中断されます。



File: python-lib-jp.info,  Node: どのように動作しているか,  Prev: デバッガコマンド,  Up: Pythonデバッガ

どのように動作しているか
========================

いくつかの変更がインタプリタへ加えられました:

   * `sys.settrace(FUNC)'がグローバルトレース関数を設定します

   * そこで、ローカルトレース関数を使うこともできます(後ろを参照)

トレース関数は三つの引数を持ちます:
FRAME、EVENTおよびARG。FRAMEは現在のスタックフレームです。EVENTは文字列です:
`'call''、`'line''、`'return''または`'exception''。ARGはイベント型に依存します。

新しいローカルスコープに入ったときはいつでも、グローバルトレース関数が(`'call''に設定されたEVENTとともに)呼び出されます。そのスコープで用いられるローカルトレース関数への参照を返すか、またはスコープがトレースされるべきでないならば`None'を返します。

ローカルトレース関数はそれ自身への(あるいは、さらにそのスコープ内でさらにトレースを行うための他の関数への)参照を返します。または、そのスコープにおけるトレースを停止させるために`None'を返します。

トレース関数としてインスタンスメソッドが受け入れられます(また、とても便利です)。

イベントは以下のような意味を持ちます:

``'call'''
     関数が呼び出されます(または、他のコードブロックに入ります)。グローバルトレース関数が呼び出されます。ARGは`None'です。戻り値はローカルトレース関数を指定します。

``'line'''
     インタプリタがコードの新しい行を実行しようとしているところです(ときどき、一行に複数行イベントが存在します)。ローカルトレース関数が呼び出されます。ARGは`None'です。戻り値は新しいローカルトレース関数を指定します。

``'return'''
     関数(または、コードブロック)が返ろうとしているところです。ローカルトレース関数が呼び出されます。ARGは返るであろう値です。トレース関数の戻り値は無視されます。

``'exception'''
     例外が生じています。ローカルトレース関数が呼び出されます。ARGは三要素の`(EXCEPTION,
     VALUE,
     TRACEBACK)'です。戻り値は新しいローカルトレース関数を指定します。


例外が一連の呼び出し元を伝えられて行くときに、`'exception''イベントは各レベルで生成されることことに注意してください。

コードとフレームオブジェクトについてさらに情報を得るには、を参照してください。


File: python-lib-jp.info,  Node: Python プロファイラ,  Next: インターネットプロトコルとその支援,  Prev: Pythonデバッガ,  Up: Top

Python プロファイラ
*******************

Copyright (C) 1994, by InfoSeek Corporation, all rights reserved.

Written by James Roskind.(1)

Permission to use, copy, modify, and distribute this Python software
and its associated documentation for any purpose (subject to the
restriction in the following sentence) without fee is hereby granted,
provided that the above copyright notice appears in all copies, and
that both that copyright notice and this permission notice appear in
supporting documentation, and that the name of InfoSeek not be used in
advertising or publicity pertaining to distribution of the software
without specific, written prior permission.  This permission is
explicitly restricted to the copying and modification of the software
to remain in Python, compiled Python, or other languages (such as C)
wherein the modified or derived code is exclusively imported into a
Python module.

INFOSEEK CORPORATION DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS
SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND
FITNESS. IN NO EVENT SHALL INFOSEEK CORPORATION BE LIABLE FOR ANY
SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER
RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF
CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN
CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.

このプロファイラは私が Python プログラミングを始めてからわずか3週間後
に書いたものです。その結果、稚拙なコードが出来上がってしまったのかもし
れませんが、なにせ私はまだ初心者なのでそれもよくわかりません :-) コー
ドはプロファイリングにふさわしいスピードを実現することに心血を注ぎまし
た。しかし部分的な繰り返しを避けたため、かなり不格好になってしまったと
ころがあります。改善のための意見があれば、ぜひ <jar@netscape.com>
までメールをください。サポートの _約束_
はできませんが...フィードバックへの感謝だけは確実にいたします。

* Menu:

* Profiler Introduction::
* Profiler Changes::
* インスタント・ユーザ・マニュアル::
* Deterministic Profiling::
* リファレンス・マニュアル::
* 制限事項 2::
* キャリブレーション補正::
* Profiler Extensions::
* hotshot::
* timeit::

---------- Footnotes ----------

(1)  アップデートと LaTeX への変換は  Guido van Rossum
によるもの。テキスト中に古いプロファイラのリファレン
スも残してありますが、そのコードはもう含まれていません。


File: python-lib-jp.info,  Node: Profiler Introduction,  Next: Profiler Changes,  Prev: Python プロファイラ,  Up: Python プロファイラ

プロファイラとは
================

"プロファイラ"とは、プログラム実行時の様々な状態を得ることにより、
その実行効率を調べるためのプログラムです。ここで解説するのは、
`profile' と `pstats' モジュールが提供するプロファイラ機
能についてです。このプロファイラはどの Python プログラムに対しても
"決定論的プロファイリング"をおこないます。また、プロファイルの結果
検証をす早くおこなえるよう、レポート生成用のツールも提供されています。


File: python-lib-jp.info,  Node: Profiler Changes,  Next: インスタント・ユーザ・マニュアル,  Prev: Profiler Introduction,  Up: Python プロファイラ

旧バージョンのプロファイラとの違い
==================================

(この節は歴史的資料としてのみ意味を持っています。ここで述べている旧バー
ジョンのプロファイラとは Python 1.1. 以前のものを指しています)

旧バージョンのプロファイリングモジュールとの大きな違いは、より少ない
CPU 時間で、より多くの情報が得られるようになったことです。CPU 時間と情
報量のトレードオフではなく、トレードアップを実現したのです。

主な内容は次の通りです。

`バグ修正:'
     ローカル・スタック・フレームの扱いに関する不具合を修
     正し、関数の実行時間を正しく計上するようにしました。

`正確さの向上:'
     プロファイラ自体の実行時間をユーザコード側に計上
     してしまうことがなくなりました。プラットフォーム毎のキャリブレーション
     (補正)をサポートし、プロファイラ_が_プロファイル_中に_ファイ
     ルの読み込みをおこなわないようにしました(当然その時間をユーザコードの
     ものとして計上することもなくなりました)。

`スピードアップ:'
     2つ以上の(たぶん5つ)の点を改善した結果、CPU の
     負荷が減りました。プロファイリング中はレポート生成用モジュール
     (`pstats') を使う必要がないため、軽いプロファイラモジュールだけ
     を常時ロードするようにしました。

`再帰的な関数のサポート:'
     再帰エントリのカウントにより、再帰関数
     内で処理に費やされる時間が正確に計算されるようになりました。

`レポート生成ユーザインターフェースの大幅な改善:'
     統計データを読み込む関数は任意の数のファイル名のリストを受け取り、独立
     した複数のプロファイル結果を合わせて総合的なレポートが作成できるように
     なりました。ソートの基準はキーワードで指定できるようになりました(4つの
     整数オプションを除く)。レポートはどのプロファイル・ファイルが参照され
     たかと同様に、どの関数がプロファイルされたかを示すようになりました。
     そのほか出力形式は改善もおこなわれています。



File: python-lib-jp.info,  Node: インスタント・ユーザ・マニュアル,  Next: Deterministic Profiling,  Prev: Profiler Changes,  Up: Python プロファイラ

インスタント・ユーザ・マニュアル
================================

この節は "マニュアルなんか読みたくない人"のために書かれています。こ
こではきわめて簡単な概要説明とアプリケーションのプロファイリングを手っ
とり早くおこなう方法だけを解説します。

main エントリにある関数 `foo()' をプロファイルしたいとき、モジュー
ルに次の内容を追加します。

     import profile
     profile.run('foo()')

このように書くことで `foo()' を実行すると同時に一連の情報(プロファ
イル)が表示されます。この方法はインタプリタ上で作業をしている場合、最
も便利なやり方です。プロファイルの結果をファイルに残し、後で検証したい
ときは、`run()' の2番目の引数にファイル名を指定します。

     import profile
     profile.run('foo()', 'fooprof')

スクリプトファイル `profile.py' を使って、別のスクリプトをプロファ
イルすることも可能です。次のように実行します。

     python /usr/local/lib/python1.5/profile.py myscript.py

プロファイル内容を確認するときは、`pstats' モジュールのメソッド
を使用します。統計データの読み込みは次のようにします。

     import pstats
     p = pstats.Stats('fooprof')

`Stats' クラス(上記コードはこのクラスのインスタンスを生成するだ
けの内容です)は `p' に読み込まれたデータを操作したり、表示するた
めの各種メソッドを備えています。先に `profile.run()' を実行し
たとき表示された内容と同じものは、3つのメソッド・コールにより実現でき
ます。

     p.strip_dirs().sort_stats(-1).print_stats()

最初のメソッドはモジュール名からファイル名の前に付いているパス部分を取
り除きます。2番目のメソッドはエントリをモジュール名/行番号/名前にもと
づいてソートします(旧プロファイラとの構文上の互換性機能)。3番目のメソッ
ドで全ての統計情報を出力します。次のようなソート・メソッドも使えます。

     p.sort_stats('name')
     p.print_stats()

最初の行ではリストを関数名でソートしています。2号目で情報を出力してい
ます。さらに次の内容も試してください。

     p.sort_stats('cumulative').print_stats(10)

このようにすると、関数が消費した累計時間でソートされ、さらにその上位10
件だけを表示します。どのアルゴリズムが時間を多く消費しているのか知りた
いときは、この方法が役に立つはずです。

ループで多くの時間を消費している関数はどれか調べたいときは、次のように
します。

     p.sort_stats('time').print_stats(10)

上記は関数の実行で消費した時間でソートされ、上位10個の関数の情報が表示
されます。

次の内容も試してください。

     p.sort_stats('file').print_stats('__init__')

このようにするとファイル名でソートされ、そのうちクラスの初期化メソッド
(メソッド名 `__init__')に関する統計情報だけが表示されます。

     p.sort_stats('time', 'cum').print_stats(.5, 'init')

上記は情報を時間 (time) をプライマリ・キー、累計時間 (cumulative time)
をセカンダリ・キーにしてソートした後でさらに条件を絞って統計情報を出力
します。 `.5' は上位 50% だけの選択を意味し、さらにその中から 文字列
`init' を含むものだけが表示されます。

どの関数がどの関数を呼び出しているのかを知りたければ、次のようにします
(`p' は最後に実行したときの状態でソートされています)。

     p.print_callers(.5, 'init')

このようにすると、各関数ごとの呼出し側関数の一覧が得られます。

さらに詳しい機能を知りたければマニュアルを読むか、次の関数の実行結果
から内容を推察してください。

     p.print_callees()
     p.add('fooprof')

スクリプトとして起動した場合、`pstats' モジュールはプロファイル
のダンプを読み込み、分析するための統計ブラウザとして動きます。シンプル
な行指向のインターフェース(`cmd' を使って実装)とヘルプ機能を
備えています。


File: python-lib-jp.info,  Node: Deterministic Profiling,  Next: リファレンス・マニュアル,  Prev: インスタント・ユーザ・マニュアル,  Up: Python プロファイラ

決定論的プロファイリングとは何か?
=================================

"決定論的プロファイリング"とは、すべての
_関数呼出し_、_関数からのリターン_、_例外発生_をモニターし、正確なタイミングを
記録することで、イベント間の時間、つまりどの時間にユーザ・コードが実行
されているのかを計測するやり方です。もう一方の"統計学的プロファイ
リング"(このモジュールでこの方法は採用していません)とは、有効なインス
トラクション・ポインタからランダムにサンプリングをおこない、プログラム
のどこで時間が使われているかを推定する方法です。後者の方法は、オーバヘッ
ドが少いものの、プログラムのどこで多くの時間が使われているか、その相対
的な示唆に留まります。

Python の場合、実行中必ずインタプリタが動作するため、決定論的プロファ
イリングをおこなうにあたり、計測用のコードは必須ではありません。Python
は自動的に各イベントに"フック"(オプションとしてコールバック)を提供
します。Python インタプリタの特性として、大きなオーバーヘッドを伴う傾
向がありますが、一般的なアプリケーションに決定論的プロファイリングを用
いると、プロセスのオーバーヘッドは少くて済む傾向があります。結果的に決
定論的プロファイリングは少ないコストで、Python プログラムの実行時間に
関する統計を得られる方法となっているのです。

呼出し回数はコード中のバグ発見にも使用できます(とんでもない数の呼出し
がおこなわれている部分)。インライン拡張の対象とすべき部分を見つけるた
めにも使えます(呼出し頻度の高い部分)。内部時間の統計は、注意深く最適化
すべき"ホット・ループ"の発見にも役立ちます。累積時間の統計は、アルゴ
リズム選択に関連した高レベルのエラー検知に役立ちます。なお、このプロファ
イラは再帰的なアルゴリズム実装の累計時間を計ることが可能で、通常のルー
プを使った実装と直接比較することもできるようになっています。


File: python-lib-jp.info,  Node: リファレンス・マニュアル,  Next: 制限事項 2,  Prev: Deterministic Profiling,  Up: Python プロファイラ

リファレンス・マニュアル
========================

Python profiler

プロファイラのプライマリ・エントリ・ポイントはグローバル関数
`profile.run()' です。通常、プロファイル情報の作成に使われま す。情報は
`pstats.Stats' クラスのメソッドを使って整形や出力をお
こないます。以下はすべての標準エントリポイントと関数の解説です。さらに
いくつかのコードの詳細を知りたければ、「プロファイラの拡張」を読んでく
ださい。派生クラスを使ってプロファイラを"改善"する方法やモジュールの
ソースコードの読み方が述べられています。

`run(string[, filename[, ...]])'
     この関数はオプション引数として `exec' 文に渡すファイル名を指定
     できます。このルーチンは必ず最初の引数の `exec' を試み、実行結
     果からプロファイル情報を収集しようとします。ファイル名が指定されていな
     いときは、各行の標準名(standard
     name)文字列(ファイル名/行数/関数名)で
     ソートされた、簡単なレポートが表示されます。以下はその出力例です。

                main()
                2706 function calls (2004 primitive calls) in 4.504 CPU seconds
          
          Ordered by: standard name
          
          ncalls  tottime  percall  cumtime  percall filename:lineno(function)
               2    0.006    0.003    0.953    0.477 pobject.py:75(save_objects)
            43/3    0.533    0.012    0.749    0.250 pobject.py:99(evaluate)
           ...

     最初の行はこのプロファイルが `profile.run('main()')' の呼び出しに
     よって生成されたものであり、実行された文字列は `'main()'' である
     ことを示しています。2行目は2706回の関数呼出しがあったことを示していま
     す。このうち2004回は"プリミティブ"なものです。"プリミティブ" な呼
     び出しとは、再帰によるものではない関数呼出しを指します。次の行
     `Ordered by: standard name' は、一番右側の欄の文字列を使ってソー
     トされたことを意味します。各カラムの見出しの意味は次の通りです。

    `ncalls'
          呼出し回数

    `tottime'
          この関数が消費した時間の合計(サブ関数呼出しの時間は除く)

    `percall'
          `tottime' を `ncalls' で割った値

    `cumtime'
          サブ関数を含む関数の(実行開始から終了までの)消費時間の合計。この項目は
          再帰的な関数においても正確に計測されます。

    `percall'
          `cumtime' をプリミティブな呼び出し回数で割った値

    `filename:lineno(function)'
          その関数のファイル名、行番号、関数名


     (`43/3' など)最初の欄に2つの数字が表示されている場合、最初の値は
     呼出し回数、2番目はプリミティブな呼び出しの回数を表しています。関数が再
     帰していない場合はどちらの回数も同じになるため、1つの数値しか表示され
     ません。

プロファイラ・データの分析は `pstats' モジュールを使っておこな います。

`Stats(filename[, ...])'
     このコンストラクタは FILENAME で指定した(単一または複数の)ファイ
     ルから"統計情報オブジェクト"のインスタンスを生成します。 `Stats'
     オブジェクトはレポートを出力するメソッドを通じて操作しま す。

     上記コンストラクタで指定するファイルは、使用する `Stats' に対応
     したバージョンの `profile' で作成されたものでなければなりません。
     将来のバージョンのプロファイラとの互換性は_保証されておらず_、(旧
     バージョンのものなど)他のプロファイラとの互換性もないことに注意してく
     ださい。

     複数のファイルを指定した場合、同一の関数の統計情報はすべて合算され、複
     数のプロセスで構成される全体をひとつのレポートで検証することが可能にな
     ります。既存の `Stats' オブジェクトに別のファイルの情報を追加す
     るときは、`add()' メソッドを使用します。

* Menu:

* Stats クラス::


File: python-lib-jp.info,  Node: Stats クラス,  Prev: リファレンス・マニュアル,  Up: リファレンス・マニュアル

`Stats' クラス
--------------

`Stats' には次のメソッドがあります。

`strip_dirs()'
     このメソッドは `Stats' にファイル名の前に付いているすべてのパス
     情報を取り除かせるためのものです。出力の幅を80文字以内に収めたいときに
     重宝します。このメソッドはオブジェクトを変更するため、取り除いたパス情
     報は失われます。パス情報除去の操作後、オブジェクトが保持するデータエント
     リは、オブジェクトの初期化、ロード直後と同じように"ランダムに"並んで
     います。`strip_dirs()' を実行した結果、2つの関数名が区別できな
     い(両者が同じファイルの同じ行番号で同じ関数名となった)場合、一つのエン
     トリに合算されされます。

`add(filename[, ...])'
     `Stats' クラスのこのメソッドは、既存のプロファイリング・オブジェ
     クトに情報を追加します。引数は対応するバージョンの `profile.run()'
     によって生成されたファイルの名前でなくてはな
     りません。関数の名前が区別できない(ファイル名、行番号、関数名が同じ)場
     合、一つの関数の統計情報として合算されます。

`dump_stats(filename)'
     `Stats' オブジェクトに読み込まれたデータを、ファイル名 FILENAME
     のファイルに保存します。ファイルが存在しない場合
     新たに作成され、すでに存在する場合には上書きされます。
     このメソッドは `profile.Profile' クラスの同名のメソッドと
     等価です。 _Added in Python version 2.3_

`sort_stats(key[, ...])'
     このメソッドは `Stats' オブジェクトを指定した基準に従ってソート
     します。引数には通常ソートのキーにしたい項目を示す文字列を指定します
     (例: `'time'' や`'name'' など)。

     2つ以上のキーが指定された場合、2つ目以降のキーは、それ以前のキーで同等
     となったデータエントリの再ソートに使われます。たとえば
     `sort_stats('name', 'file')' とした場合、まずすべてのエントリが関
     数名でソートされた後、同じ関数名で複数のエントリがあればファイル名でソー
     トされるのです。

     キー名には他のキーと判別可能である限り綴りを省略して名前を指定できます。
     現バージョンで定義されているキー名は以下の通りです。

     正式名                             内容
     ------                             -----
     'calls'                            呼び出し回数
     'cumulative'                       合計時間
     'file'                             ファイル名
     'module'                           モジュール名
     'pcalls'                           プリミティブな呼び出しの回数
     'line'                             行番号
     'name'                             関数名
     'nfl'                              関数名/ファイル名/行番号
     'stdname'                          標準名
     'time'                             内部時間

     すべての統計情報のソート結果は降順(最も多く時間を消費したものが一番上
     に来る)となることに注意してください。ただし、関数名、ファイル名、行数
     に関しては昇順(アルファベット順)になります。`'nfl'' と `'stdname''
     はやや異なる点があります。標準名(standard name)とは表
     示欄の名前なのですが、埋め込まれた行番号の文字コード順でソートされます。
     たとえば、(ファイル名が同じで)3、20、40という行番号のエントリがあった
     場合、20、30、40 の順に表示されます。一方 `'nfl'' は行番号を数値
     として比較します。結果的に、`sort_stats('nfl')' は
     `sort_stats('name', 'file', 'line')' と指定した場合と同じになりま
     す。

     旧バージョンのプロファイラとの互換性のため、数値を引数に使った
     `-1'、 `0'、 `1'、 `2' の形式もサポートしています。 それぞれ
     `'stdname''、`'calls''、`'time''、 `'cumulative''
     として処理されます。引数をこの旧形式で指定した場合、
     最初のキー(数値キー)だけが使われ、複数のキーを指定しても2番目以降は無
     視されます。

`reverse_order()'
     `Stats' クラスのこのメソッドは、オブジェクト内の情報のリストを逆
     順にソートします。これは旧プロファイラとの互換性のために用意されていま
     す。現在は選択したキーに応じて昇順、降順が適切に選ばれるため、このメソッ
     ドの必要性はほとんどないはずです。

`print_stats([restriction, ...])'
     `Stats' クラスのこのメソッドは、`profile.run()' の項で 述べた
     プロファイルのレポートを出力します。

     出力するデータの順序はオブジェクトに対し最後におこなった
     `sort_stats()' による操作にもとづいたものになります (`add()' と
     `strip_dirs()' による制限にも支配されます)。

     引数は一覧に大きな制限を加えることになります。初期段階でリストはプロファ
     イルした関数の完全な情報を持っています。制限の指定は(行数を指定する)整
     数、(行のパーセンテージを指定する) 0.0 から 1.0
     までの割合を指定する小 数、(出力する standard name
     にマッチする)正規表現のいずれかを使ってお こないます。正規表現は
     Python 1.5b1 で導入された `re' モジュー ルで使える Perl
     スタイルのものです。複数の制限は指定された場合、それは
     指定の順に適用されます。たとえば次のようになります。

          print_stats(.1, 'foo:')

     上記の場合まず出力するリストは全体の10%に制限され、さらにファイル名の
     一部に文字列 `.*foo:' を持つ関数だけが出力されます。

          print_stats('foo:', .1)

     こちらの例の場合、リストはまずファイル名に `.*foo:' を持つ関数だ
     けに制限され、その中の最初の 10% だけが出力されます。

`print_callers([restriction, ...])'
     `Stats' クラスのこのメソッドは、プロファイルのデータベースの中か
     ら何らかの関数呼び出しをおこなった関数すべてを出力します。出力の順序は
     `print_stats()' によって与えられるものと同じです。出力を制限す
     る引数も同じです。呼出し側関数の後にパーレンで囲まれて表示される数値は
     呼出しが何回おこなわれたかを示すものです。続いてパーレンなしで表示され
     る数値は、関数が消費した時間の合計です。

`print_callees([restriction, ...])'
     `Stats' クラスのこのメソッドは指定した関数から呼出された関数のリ
     ストを出力します。呼出し側、呼出される側の方向は逆ですが、引数と出力の
     順序に関しては `print_callers()' と同じです。

`ignore()'
     _This is deprecated in Python 1.5.1.  現バージョンの Python
     のPython では不要です。(1)_

---------- Footnotes ----------

(1)  Python が `None' 以外の使われなかった結果を表示するときに使われ
たもので、旧バージョンとの互換性のためだけに定義されています。


File: python-lib-jp.info,  Node: 制限事項 2,  Next: キャリブレーション補正,  Prev: リファレンス・マニュアル,  Up: Python プロファイラ

制限事項
========

このプロファイラには2つの基本的な制限事項があります。ひとつは、Python
インタプリタによる "呼び出し"、"リターン"、"例外発生" とい
うイベントの連携を前提にしていることです。コンパイル済みの C コード
はインタプリタの管理外で、プロファイラからは"見えません"。(組込み関
数を含む) C のコードに費やされた時間は、その C コードを呼出した Python
関数のものとして計上されることになります。ただし C コードが Python
のコードを呼び出す場合は、適切にプロファイルされます。

2つ目の制限はタイミング情報の正確さに関するものです。決定論的プロファ
イラの正確さに関する根本的問題です。最も明白な制限は、(一般に)"クロッ
ク"は .001 秒の精度しかないということです。これ以上の精度で計測するこ
とはできません。仮に充分な精度が得られたとしても、"エラー"が計測の平
均値に影響を及ぼすことがあります。最初のエラーを取り除いたとしても、そ
れがまた別のエラーを引き起こす原因となり...。

もうひとつの問題として、イベントを検知してからプロファイラがその時刻を
実際に_取得_するまでに "いくらかの時間がかかる" ことです。プロ
ファイラが時刻を取得する(そしてその値を保存する)までの間に、ユーザコー
ドがもう一度処理を実行したときにも、同様の遅延が発生します。結果的に多
く呼び出される関数または多数の関数から呼び出される関数の情報にはこの種
のエラーが蓄積する傾向にあります。

この種のエラーによる遅延の蓄積は一般にクロックの精度を越える(1クロック
以下のタイミング)ところで起きていますが、一方でこの時間を累計_可
能_ということが大きな意味を持っています。このプロファイラはプラットフォー
ムごとに(平均値から)予想されるエラーによる遅延を補正する機能を備えてい
ます。プロファイラに補正を施すと(少くとも形式的には)正確さが増しますが、
ときには数値が負の値になってしまうこともあります(呼出し回数が少く、確
率の神があなたに意地悪をしたとき :-) )。プロファイルの結果に負の値が出
力されても_驚かないでください_。これは補正をおこなった場合にのみ
現れることで、実際の計測結果は補正をおこなわない場合より、より正確なは
ずだからです。

