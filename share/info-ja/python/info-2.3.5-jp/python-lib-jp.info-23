This is python-lib-jp.info, produced by makeinfo version 4.5 from
python-lib-jp.texi.

12 October 2005


File: python-lib-jp.info,  Node: signal,  Next: socket,  Prev: オプションのオペレーティングシステムサービス,  Up: オプションのオペレーティングシステムサービス

非同期イベントにハンドラを設定する
==================================

非同期イベントにハンドラを設定します。

このモジュールでは Python でシグナルハンドラを使うための機構を
提供します。シグナルとハンドラを扱う上では、一般的なルールが
いくつかあります:

   * 特定のシグナルに対するハンドラが一度設定されると、明示的に
     リセットしないかぎり設定されたままになります (Python は背後の実装系
     に関係なく BSD 形式のインタフェースをエミュレートします)。 例外は
     `SIGCHLD' のハンドラで、この場合は背後の実装系の 仕様に従います。

   * クリティカルセクションから一時的にシグナルを"ブロック"することは
     できません。この機能をサポートしないUNIX系システムも存在するた
     めです。

   * Python のシグナルハンドラは Python のユーザが望む限り非同期で呼び
     出されますが、呼び出されるのは Python インタプリタの "原子的な
     (atomic)" 命令実行単位の間です。従って、
     (巨大なサイズのテキストに対する正規表現の一致検索のような) 純粋に
     C 言語のレベルで実現されている時間のかかる処理中に
     到着したシグナルは、不定期間遅延する可能性があります。

   * シグナルが I/O 操作中に到着すると、シグナルハンドラが処理を返した
     後に I/O 操作が例外を送出する可能性があります。 これは背後にある
     UNIX システムが割り込みシステムコールにどういう
     意味付けをしているかに依存します。

   * C 言語のシグナルハンドラは常に処理を返すので、`SIGFPE' や
     `SIGSEGV' のような同期エラーの捕捉はほとんど意味が ありません。

   * Python は標準でごく小数のシグナルハンドラをインストールしています:
     `SIGPIPE' は無視されます (従って、パイプやソケットに対する
     書き込みで生じたエラーは通常の Python 例外として報告されます)
     `SIGINT' は `KeyboardInterrupt' 例外に変換されます。
     これらはどれも上書きすることができます。

   * シグナルとスレッドの両方を同じプログラムで使用する場合にはいくつか
     注意が必要です。シグナルとスレッドを同時に利用する上で基本的に注意
     すべきことは: 常に `signal()' 命令は主スレッド (main thread)の
     処理中で実行するということです。どのスレッドも `alarm()'、
     `getsignal()'、あるいは `pause()' を実行する ことができます;
     しかし、主スレッドだけが新たなシグナルハンドラを
     設定することができ、従ってシグナルを受け取ることができるのは主スレッド
     だけです
     (これは、背後のスレッド実装が個々のスレッドに対するシグナル
     送信をサポートしているかに関わらず、Python `signal' モジュール
     が強制している仕様です)。従って、シグナルをスレッド間通信の手段として
     使うことはできません。代わりにロック機構を使ってください。

以下に `signal' モジュールで定義されている変数を示します:

`SIG_DFL'
     二つある標準シグナル処理オプションのうちの一つです; 単にシグナルに
     対する標準の関数を実行します。例えば、ほとんどのシステムでは、
     `SIGQUIT' に対する標準の動作はコアダンプと終了で、 `SIGCLD'
     に対する標準の動作は単にシグナルの無視です。

`SIG_IGN'
     もう一つの標準シグナル処理オプションで、単に受け取ったシグナルを
     無視します。

`SIG*'
     全てのシグナル番号はシンボル定義されています。例えば、ハングアップ
     シグナルは `signal.SIGHUP' で定義されています; 変数名は C
     言語のプログラムで使われているのと同じ名前で、`<signal.h>'
     にあります。 ``signal()'' に関する UNIX マニュアルページでは、
     システムで定義されているシグナルを列挙しています
     (あるシステムではリストは `signal(2)' に、別のシステムでは
     `signal(7)' に列挙されています)。
     全てのシステムで同じシグナル名のセットを定義しているわけではないので
     注意してください;
     このモジュールでは、システムで定義されているシグナル
     名だけを定義しています。

`NSIG'
     最も大きいシグナル番号に 1 を足した値です。

`signal' モジュールでは以下の関数を定義しています:

`alarm(time)'
     TIME がゼロでない値の場合、この関数は TIME 秒後頃に `SIGALRM'
     をプロセスに送るように要求します。
     それ以前にスケジュールしたアラームはキャンセルされます (常に一つの
     アラームしかスケジュールできません)。この場合、戻り値は以前に設定
     されたアラームシグナルが通知されるまであと何秒だったかを示す値です。
     TIME がゼロの場合、アラームは一切スケジュールされず、現在
     スケジュールされているアラームがキャンセルされます。
     戻り値は以前にスケジュールされたアラームが通知される予定時刻までの
     残り時間です。戻り値がゼロの場合、現在アラームがスケジュールされて
     いないことを示します。(UNIX マニュアルページ `alarm(2)'
     を参照してください)。 利用可能: UNIX。

`getsignal(signalnum)'
     シグナル SIGNALNUM に対する現在のシグナルハンドラを返します。
     戻り値は呼び出し可能な Python オブジェクトか、`signal.SIG_IGN'、
     `signal.SIG_DFL'、および `None' といった特殊な値
     のいずれかです。ここで `signal.SIG_IGN' は以前そのシグナルが
     無視されていたことを示し、`signal.SIG_DFL' は以前そのシグナルの
     標準の処理方法が使われていたことを示し、`None' はシグナルハンドラが
     まだ Python によってインストールされていないことを示します。

`pause()'
     シグナルを受け取るまでプロセスを一時停止します; その後、適切な
     ハンドラが呼び出されます。戻り値はありません。Windows では利用
     できません。(UNIX マニュアルページ `signal(2)' を
     参照してください。)

`signal(signalnum, handler)'
     シグナル SIGNALNUM に対するハンドラを関数 HANDLER にします。
     HANDLER は二つの引数 (下記参照) を取る呼び出し可能な Python
     オブジェクトにするか、`signal.SIG_IGN' あるいは `signal.SIG_DFL'
     といった特殊な値にすることができます。
     以前に使われていたシグナルハンドラが返されます (上記の
     `getsignal()' の記述を参照してください)。 (UNIX マニュアルページ
     `signal(2)' を参照してください。)

     複数スレッドの使用が有効な場合、この関数は主スレッドからのみ呼び出す
     ことができます; 主スレッド以外のスレッドで呼び出そうとすると、例外
     `ValueError' が送出されます。

     HANDLER は二つの引数: シグナル番号、および現在のスタックフレーム
     とともに呼び出されます (`None' またはフレームオブジェクト;
     フレームオブジェクトに
     ついての記述はリファレンスマニュアルの標準型の階層 か、
     `inspect'モジュールの属性の説明を参照してください)。

* Menu:

* Simple Example::


File: python-lib-jp.info,  Node: Simple Example,  Prev: signal,  Up: signal

例
--

以下は最小限のプログラム例です。この例では `alarm()'
を使って、ファイルを開く処理を待つのに費やす時間を制限します;
これはそのファイルが電源の入れられていないシリアルデバイスを
表している場合に有効で、通常こうした場合には `os.open()'
は未定義の期間ハングアップしてしまいます。ここではファイルを開く まで 5
秒間のアラームを設定することで解決しています; ファイルを
開く処理が長くかかりすぎると、アラームシグナルが送信され、
ハンドラが例外を送出するようになっています。

     import signal, os
     
     pdef handler(signum, frame):
         print 'Signal handler called with signal', signum
         raise IOError, "Couldn't open device!"
     
     # Set the signal handler and a 5-second alarm
     signal.signal(signal.SIGALRM, handler)
     signal.alarm(5)
     
     # This open() may hang indefinitely
     fd = os.open('/dev/ttyS0', os.O_RDWR)
     
     signal.alarm(0)          # Disable the alarm


File: python-lib-jp.info,  Node: socket,  Next: select,  Prev: signal,  Up: オプションのオペレーティングシステムサービス

低レベルネットワークインターフェース
====================================

低レベルネットワークインターフェース。

このモジュールは、PythonでBSD _ソケット_ インターフェースを利用する
ために使用します。最近のUNIXシステム、Windows, MacOS, BeOS, OS/2な
ど、多くのプラットフォームで利用可能です。

C言語によるソケットプログラミングの基礎については、以下の資料を参照して
ください。

(Stuart Sechrest),

(Samuel J. Leffler他), (PS1:7章 PS1:8章)。ソケットの詳細については、
各プラットフォームのソケット関連システムコールに関するドキュメント(UNIX
では マニュアルページ、WindowsではWinSock(またはWinSock2)仕様書)も参照し
てください。IPv6対応のAPIについては、RFC 2553

を参照してくださ い。

Pythonインターフェースは、UNIXのソケット用システムコールとライブラリ
を、そのままPythonのオブジェクト指向スタイルに変換したものです。各種ソケ
ット関連のシステムコールは、`socket()'関数で生成する "ソケット
オブジェクト" のメソッドとして実装されてい
ます。メソッドのパラメータはCのインターフェースよりも多少高水準で、例え
ば`read()'や`write()'メソッドではファイルオブジェクトと同
様、受信時のバッファ確保や送信時の出力サイズなどは自動的に処理されます。

ソケットのアドレスは以下のように指定します:単一の文字列は、
`AF_UNIX'アドレスファミリを示します。`(HOST,
PORT)'のペアは`AF_INET'アドレスファミリを示し、HOST
は`'daring.cwi.nl''のようなインターネットドメイン形式または
`'100.50.200.5''のようなIPv4アドレスを文字列で、PORTはポート
番号を整数で指定します。`AF_INET6'アドレスファミリは `(HOST, PORT,
FLOWINFO, SCOPEID)'の長さ4の
タプルで示し、FLOWINFOとSCOPEIDにはそれぞれCの `struct
sockaddr_in6'における`sin6_flowinfo'と
`sin6_scope_id'の値を指定します。後方互換性のため、`socket'
モジュールのメソッドでは`sin6_flowinfo'と`sin6_scope_id'を省略
する事ができますが、SCOPEIDを省略するとスコープを持ったIPv6アドレ
スの処理で問題が発生する場合があります。現在サポートされているアドレスフ
ァミリは以上です。ソケットオブジェクトで利用する事のできるアドレス形式
は、ソケットオブジェクトの作成時に指定したアドレスファミリで決まります。

IPv4アドレスのホストアドレスが空文字列の場合、`INADDR_ANY'とし
て処理されます。また、`'<broadcast>''の場合は
`INADDR_BROADCAST'として処理されます。IPv6では後方互換性のため
この機能は用意されていませんので、IPv6をサポートするPythonプログラムでは
利用しないで下さい。

IPv4/v6ソケットのHOST部にホスト名を指定すると、処理結果が一定では
ない場合があります。これはPythonはDNSから取得したアドレスのうち最初のア
ドレスを使用するので、DNSの処理やホストの設定によって異なるIPv4/6アドレ
スを取得する場合があるためです。常に同じ結果が必要であれば、HOSTに
数値のアドレスを指定してください。

エラー時には例外が発生します。引数型のエラーやメモリ不足の場合には通常の
例外が発生し、ソケットやアドレス関連のエラーの場合は
`socket.error'が発生します。

`setblocking()'メソッドで、非ブロッキングモードを使用することがで
きます。また、より汎用的に`settimeout()'メソッドでタイムアウトを
指定する事ができます。

`socket'モジュールでは、以下の定数と関数を提供しています。

`error'
     この例外は、ソケット関連のエラーが発生した場合に送出されます。例外の値は
     障害の内容を示す文字列か、または`os.error'と同様な `(ERRNO,
     STRING)'のペアとなります。オペレーティングシス
     テムで定義されているエラーコードについては`errno'
     を参照してください。

`herror'
     この例外は、C APIの`gethostbyname_ex()'や
     `gethostbyaddr()'などで、H_ERRNOのようなアドレス関連のエ
     ラーが発生した場合に送出されます。

     例外の値は`(H_ERRNO, STRING)'のペアで、ライブラリの呼び
     出し結果を返します。STRINGはC関数`hstrerror()'で取得し
     た、H_ERRNOの意味を示す文字列です。

`gaierror'
     この例外は`getaddrinfo()'と`getnameinfo()'でアドレス関
     連のエラーが発生した場合に送出されます。

     例外の値は`(ERROR, STRING)'のペアで、ライブラリの呼び出
     し結果を返します。STRINGはC関数`gai_strerror()'で取得し
     た、H_ERRNOの意味を示す文字列です。
     ERRORの値は、このモジュールで定義される `EAI_*' 定数の何れか
     となります。

`timeout'
     この例外は、あらかじめ `settimeout()' を呼び出してタイムアウトを
     有効にしてあるソケットでタイムアウトが生じた際に送出されます。
     例外に付属する値は文字列で、その内容は現状では常に "timed out"
     となります。 _Added in Python version 2.3_

`AF_UNIX'

`AF_INET'

`AF_INET6'
     アドレス（およびプロトコル）ファミリを示す定数で、`socket()'の
     最初の引数に指定することができます。`AF_UNIX'ファミリをサポート
     しないプラットフォームでは、`AF_UNIX'は未定義となります。

`SOCK_STREAM'

`SOCK_DGRAM'

`SOCK_RAW'

`SOCK_RDM'

`SOCK_SEQPACKET'
     ソケットタイプを示す定数で、`socket()'の2番目の引数に指定するこ
     とができます。(ほとんどの場合、`SOCK_STREAM'と
     `SOCK_DGRAM'以外は必要ありません。)

`SO_*'

`SOMAXCONN'

`MSG_*'

`SOL_*'

`IPPROTO_*'

`IPPORT_*'

`INADDR_*'

`IP_*'

`IPV6_*'

`EAI_*'

`AI_*'

`NI_*'

`TCP_*'
     UNIXのソケット・IPプロトコルのドキュメントで定義されている各種定数。
     ソケットオブジェクトの`setsockopt()'や`getsockopt()'で使用
     します。ほとんどのシンボルはUNIXのヘッダファイルに従っています。一部
     のシンボルには、デフォルト値を定義してあります。

`has_ipv6'
     現在のプラットフォームでIPv6がサポートされているか否かを示す真偽値。
     _Added in Python version 2.3_

`getaddrinfo(host, port[, family[, socktype[, proto[, flags]]]])'
     HOST/PORT 引数の指すアドレス情報を解決して、
     ソケット操作に必要な全ての引数が入った 5 要素のタプルを返します。
     HOSTはドメイン名、IPv4/v6アドレスの文字列、または`None' です。PORT
     は`'http''のようなサービス名文字列、ポート番号
     を表す数値、または`None' です。

     これ以外の引数は省略可能で、指定する場合には数値でなければなりません。
     HOSTとPORT に空文字列か`None' を指定すると C APIに
     `NULL'を渡せます。 `getattrinfo()' 関数は以下の構造をとる 5
     要素のタプルを返します:

     `(FAMILY, SOCKTYPE, PROTO, CANONNAME, SOCKADDR)'

     FAMILY・SOCKTYPE・PROTOは、`socket()'関数を呼
     び出す際に指定する値と同じ整数です。CANONNAMEはHOSTの規準名
     を示す文字列です。`AI_CANONNAME'を指定した場合、数値によるIPv4/
     v6アドレスを返します。SOCKADDRは、ソケットアドレスを上述の形式で表
     すタプルです。この関数の使い方については、`httplib'モジュール
     などのソースを参考にしてください。

     _Added in Python version 2.2_

`getfqdn([name])'
     NAMEの完全修飾ドメイン名を返します。NAMEが空または省略された
     場合、ローカルホストを指定したとみなします。完全修飾ドメイン名の取得には
     まず`gethostbyaddr()'でチェックし、次に可能であればエイリアスを
     調べ、名前にピリオドを含む最初の名前を値として返します。完全修飾ドメイ
     ン名を取得できない場合、ホスト名を返します。

     _Added in Python version 2.0_

`gethostbyname(hostname)'
     ホスト名を`'100.50.200.5''のようなIPv4形式のアドレスに変換します。
     ホスト名としてIPv4アドレスを指定した場合、その値は変換せずにそのまま返り
     ます。`gethostbyname()' APIへのより完全なインターフェースが必要
     であれば、`gethostbyname_ex()'を参照してください。
     `gethostbyname()'は、IPv6名前解決をサポートしていません。IPv4/
     v6のデュアルスタックをサポートする場合は`getaddrinfo()'を使用し
     ます。

`gethostbyname_ex(hostname)'
     ホスト名から、IPv4形式の各種アドレス情報を取得します。戻り値は
     `(HOSTNAME, ALIASLIST, IPADDRLIST)'のタプルで、HOSTNAMEは
     IP_ADDRESSで指定したホストの正式名、ALIASLISTは同じアドレス
     の別名のリスト(空の場合もある)、IPADDRLISTは同じホスト上の同一イ
     ンターフェースのIPv4アドレスのリスト(ほとんどの場合は単一のアドレスのみ)
     を示します。`gethostbyname()'は、IPv6名前解決をサポートしていま
     せん。IPv4/v6のデュアルスタックをサポートする場合は
     `getaddrinfo()'を使用します。

`gethostname()'
     Pythonインタープリタを現在実行中のマシンのホスト名を示す文字列を取得しま
     す。実行中マシンのIPアドレスが必要であれば、
     `gethostbyname(gethostname())'を使用してください。この処理は実行中
     ホストのアドレス-ホスト名変換が可能であることを前提としていますが、常に
     変換可能であるとは限りません。注意: `gethostname()'は完全修飾ド
     メイン名を返すとは限りません。完全修飾ドメイン名が必要であれば、
     `gethostbyaddr(gethostname())'としてください(下記参照)。

`gethostbyaddr(ip_address)'
     `(HOSTNAME, ALIASLIST, IPADDRLIST)'のタプルを返
     し、HOSTNAMEはIP_ADDRESSで指定したホストの正式名、
     `aliaslist'は同じアドレスの別名のリスト(空の場合もある)、
     `ipaddrlist'は同じホスト上の同一インターフェースのIPv4アドレスのリ
     スト(ほとんどの場合は単一のアドレスのみ)を示します。完全修飾ドメイン名が
     必要であれば、`getfqdn()'を使用してください。
     `gethostbyaddr'は、IPv4/IPv6の両方をサポートしています。

`getnameinfo(sockaddr, flags)'
     ソケットアドレスSOCKADDRから、`(HOST, PORT)'のタ
     プルを取得します。FLAGSの設定に従い、HOSTは完全修飾ドメイン
     名または数値形式アドレスとなります。同様に、PORTは文字列のポート名
     または数値のポート番号となります。 _Added in Python version 2.2_

`getprotobyname(protocolname)'
     `'icmp''のようなインターネットプロトコル名を、`socket()'の
     第三引数として指定する事ができる定数に変換します。これは主にソケットを"
     raw"モード(`SOCK_RAW')でオープンする場合には必要ですが、通常の
     ソケットモードでは第三引数に0を指定するか省略すれば正しいプロトコルが自
     動的に選択されます。

`getservbyname(servicename, protocolname)'
     インターネットサービス名とプロトコルから、そのサービスのポート番号を取得
     します。プロトコル名として、`'tcp''か`'udp''を指定することがで
     きます。

`socket(family, type[, proto])'
     アドレスファミリ、ソケットタイプ、プロトコル番号を指定してソケットを作成
     します。アドレスファミリには`AF_INET'・`AF_INET6'・
     `AF_UNIX'を指定することができます。ソケットタイプには
     `SOCK_STREAM'・`SOCK_DGRAM'・または`SOCK_'の何れ
     かを指定します。プロトコル番号には通常省略するか、または0を指定します。

`ssl(sock[, keyfile, certfile])'
     ソケットSOCKによるSSL接続を初期化します。KEYFILEには、PEMフ
     ォーマットのプライベートキーファイル名を指定します。CERTFILEには、
     PEMフォーマットの認証チェーンファイル名を指定します。処理が成功すると、
     新しい`SSLObject'が返ります。

     _証明書の認証は全く行いません。_

`fromfd(fd, family, type[, proto])'
     既存のファイルディスクリプタ(ファイルオブジェクトの`fileno()'で返
     る整数)から、ソケットオブジェクトを構築します。アドレスファミリとプロト
     コル番号は`socket()'と同様に指定します。ファイルディスクリプタ
     はソケットを指していなければなりませんが、実際にソケットであるかどうかの
     チェックは行っていません。このため、ソケット以外のファイルディスクリプタ
     を指定するとその後の処理が失敗する場合があります。この関数が必要な事はあ
     まりありませんが、UNIXのinetデーモンのようにソケットを標準入力や標準
     出力として使用するプログラムで使われます。この関数で使用するソケットは、
     ブロッキングモードと想定しています。 利用可能:UNIX


`ntohl(x)'
     32ビット整数のバイトオーダを、ネットワークバイトオーダからホストバイト
     オーダに変換します。ホストバイトオーダとネットワークバイトオーダが一致す
     るマシンでは、この関数は何もしません。それ以外の場合は4バイトのスワップ
     を行います。

`ntohs(x)'
     16ビット整数のバイトオーダを、ネットワークバイトオーダからホストバイト
     オーダに変換します。ホストバイトオーダとネットワークバイトオーダが一致す
     るマシンでは、この関数は何もしません。それ以外の場合は2バイトのスワップ
     を行います。

`htonl(x)'
     32ビット整数のバイトオーダを、ホストバイトオーダからネットワークバイト
     オーダに変換します。ホストバイトオーダとネットワークバイトオーダが一致す
     るマシンでは、この関数は何もしません。それ以外の場合は4バイトのスワップ
     を行います。

`htons(x)'
     16ビット整数のバイトオーダを、ホストバイトオーダからネットワークバイト
     オーダに変換します。ホストバイトオーダとネットワークバイトオーダが一致す
     るマシンでは、この関数は何もしません。それ以外の場合は2バイトのスワップ
     を行います。

`inet_aton(ip_string)'
     ドット記法によるIPv4アドレス(`'123.45.67.89''など)を32ビットにパッ
     クしたバイナリ形式に変換し、長さ4の文字列として返します。この関数が返す
     値は、標準Cライブラリの`struct in_addr'型を使用する関数に渡す事がで
     きます。

     IPv4アドレス文字列が不正であれば、`socket.error'が発生します。
     このチェックは、この関数で使用しているCの実装 `inet_aton()'で
     行われます。

     `inet_aton()'は、IPv6をサポートしません。IPv4/v6のデュアルスタ
     ックをサポートする場合は`getnameinfo()'を使用します。

`inet_ntoa(packed_ip)'
     32ビットにパックしたバイナリ形式のIPv4アドレスを、ドット記法による文字列
     (`'123.45.67.89''など)に変換します。この関数が返す値は、標準Cライブ
     ラリの`struct in_addr'型を使用する関数に渡す事ができます。

     この関数に渡す文字列の長さが4バイト以外であれば、
     `socket.error'が発生します。
     `inet_ntoa()'は、IPv6をサポートしません。IPv4/v6のデュアルスタ
     ックをサポートする場合は`getnameinfo()'を使用します。

`inet_pton(address_family, ip_string)'
     IPアドレスを、アドレスファミリ固有の文字列からパックしたバイナリ形式に変
     換します。`inet_pton()'は、`struct in_addr'型
     (`inet_aton()'と同様)や`struct in6_addr'を使用するライブ
     ラリやネットワークプロトコルを呼び出す際に使用することができます。

     現在サポートされているADDRESS_FAMILYは、`AF_INET'と
     `AF_INET6'です。IP_STRINGに不正なIPアドレス文字列を指定す
     ると、`socket.error'が発生します。有効なIP_STRINGは、
     ADDRESS_FAMILYと`inet_pton()'の実装によって異なります。

     利用可能: UNIX (サポートしていないプラットフォームもあります)
     _Added in Python version 2.3_

`inet_ntop(address_family, packed_ip)'
     パックしたIPアドレス(数文字の文字列)を、`'7.10.0.5''や
     `'5aef:2b::8''などの標準的な、アドレスファミリ固有の文字列形式に変
     換します。`inet_ntop()'は(`inet_ntoa()'と同様に) `struct
     in_addr'型や`struct in6_addr'型のオブジェクトを返す
     ライブラリやネットワークプロトコル等で使用することができます。

     現在サポートされているADDRESS_FAMILYは、`AF_INET'と
     `AF_INET6'です。PACKED_IPの長さが指定したアドレスファミリ
     で適切な長さでなければ、`ValueError'が発生します。
     `inet_ntop()'でエラーとなると、`socket.error'が発生し ます。

     利用可能: UNIX (サポートしていないプラットフォームもあります)
     _Added in Python version 2.3_

`getdefaulttimeout()'
     新規に生成されたソケットオブジェクトの、デフォルトのタイムアウト値を浮動
     小数点形式の秒数で返します。タイプアウトを使用しない場合には`None'
     を返します。最初にsocketモジュールがインポートされた時の初期値は
     `None'です。

     _Added in Python version 2.3_

`setdefaulttimeout(timeout)'
     新規に生成されたソケットオブジェクトの、デフォルトのタイムアウト値を浮動
     小数点形式の秒数で指定します。タイムアウトを使用しない場合には
     `None'を指定します。最初にsocketモジュールがインポートされた時の初
     期値は`None'です。

     _Added in Python version 2.3_

`SocketType'
     ソケットオブジェクトの型を示す型オブジェクト。`type(socket(...))'と
     同じです。

See also:
     *Note SocketServer:: ネットワークサーバの開発を省力化するためのク
     ラス群。

* Menu:

* socket オブジェクト::
* SSL オブジェクト::
* 例 8::


File: python-lib-jp.info,  Node: socket オブジェクト,  Next: SSL オブジェクト,  Prev: socket,  Up: socket

socket オブジェクト
-------------------

ソケットオブジェクトは以下のメソッドを持ちます。`makefile()'以外
のメソッドは、UNIXのソケット用システムコールに対応しています。

`accept()'
     接続を受け付けます。ソケットはアドレスにbind済みで、listen中である必要が
     あります。戻り値は`(CONN, ADDRESS)'のペアで、CONN
     は接続を通じてデータの送受信を行うための_新しい_ソケットオブジェク
     ト、ADDRESSは接続先でソケットにbindしているアドレスを示します。

`bind(address)'
     ソケットをADDRESSにbindします。bind済みのソケットを再バインドする
     事はできません。ADDRESSのフォーマットはアドレスファミリによって異
     なります(前述)。 _Note:_
     本来、このメソッドは単一のタプルのみを引数として受け付けますが、
     以前は`AF_INET'アドレスを示す二つの値を指定する事ができました。
     これは本来の仕様ではなく、Python
     2.0以降では使用することはできません。

`close()'
     ソケットをクローズします。以降、このソケットでは全ての操作が失敗します。
     リモート端点ではキューに溜まったデータがフラッシュされた後はそれ以上の
     データを受信しません。ソケットはガベージコレクション時に自動的にクローズ
     されます。

`connect(address)'
     ADDRESSで示されるリモートソケットに接続します。ADDRESSのフ
     ォーマットはアドレスファミリによって異なります(前述)。 _Note:_
     本来、このメソッドは単一のタプルのみを引数として受け付けますが、
     以前は`AF_INET'アドレスを示す二つの値を指定する事ができました。
     これは本来の仕様ではなく、Python
     2.0以降では使用することはできません。

`connect_ex(address)'
     `connect(ADDRESS)'と同様ですが、C言語の`connect()'
     関数の呼び出しでエラーが発生した場合には例外を送出せずにエラーを戻り値と
     して返します。(これ以外の、"host not
     found,"等のエラーの場合には例外が
     発生します。)処理が正常に終了した場合には`0'を返し、エラー時には
     `errno'の値を返します。この関数は、非同期接続をサポートする場合な
     どに使用することができます。 _Note:_
     本来、このメソッドは単一のタプルのみを引数として受け付けますが、
     以前は`AF_INET'アドレスを示す二つの値を指定する事ができました。
     これは本来の仕様ではなく、Python
     2.0以降では使用することはできません。

`fileno()'
     ソケットのファイルディスクリプタを整数型で返します。ファイルディスクリプ
     タは、`select.select()'などで使用します。

`getpeername()'
     ソケットが接続しているリモートアドレスを返します。この関数は、リモート
     IPv4/v6ソケットのポート番号を調べる場合などに使用します。ADDRESSの
     フォーマットはアドレスファミリによって異なります(前述)。この関数をサポー
     トしていないシステムも存在します。

`getsockname()'
     ソケット自身のアドレスを返します。この関数は、IPv4/v6ソケットのポート番
     号を調べる場合などに使用します。ADDRESSのフォーマットはアドレスフ
     ァミリによって異なります(前述)。

`getsockopt(level, optname[, buflen])'
     ソケットに指定されたオプションを返します(UNIXのマニュアルページ
     `getsockopt(2)'を参照)。`SO_*'等のシンボルは、このモジ
     ュールで定義しています。BUFLENを省略した場合、取得するオブションは
     整数とみなし、整数型の値を戻り値とします。BUFLENを指定した場合、長
     さBUFLENのバッファでオプションを受け取り、このバッファを文字列とし
     て返します。このバッファは、呼び出し元プログラムで`struct'
     モジュール等を利用して内容を読み取ることができま す。

`listen(backlog)'
     ソケットをListenし、接続を待ちます。引数BACKLOGには接続キューの最
     大の長さ(1以上)を指定します。BACKLOGの最大数はシステムに依存します
     (通常は5)。

`makefile([mode[, bufsize]])'
     ソケットに関連付けられた"ファイルオブジェクト"を返します(ファイルオ
     ブジェクトについては*Note
     ファイルオブジェクト::の"ファイルオブジェクト"を
     参照)。ファイルオブジェクトはソケットを`dup()'したファイルディ
     スクリプタを使用しており、ソケットオブジェクトとファイルオブジェクトは
     別々にクローズしたりガベージコレクションで破棄したりする事ができます。ソ
     ケットはブロッキングモードでなければなりません。
     オプション引数のMODEとBUFSIZE
     には、`file()'組み込み関数と同じ値を指定します。 *Note
     組み込み関数::の"組み込み関数"を参照してください。

`recv(bufsize[, flags])'
     ソケットからデータを受信し、文字列として返します。受信する最大バイト数
     は、BUFSIZEで指定します。FLAGSのデフォルト値は0です。値の意
     味についてはUNIXマニュアルページの`recv(2)'を参照してくださ い。

`recvfrom(bufsize[, flags])'
     ソケットからデータを受信し、結果をタプル`(STRING,
     ADDRESS)'として返します。STRINGは受信データの文字列で、
     ADDRESSは送信元のアドレスを示します。オプション引数FLAGSの意
     味は、上記`recv()'と同じです。ADDRESSのフォーマットはアドレ
     スファミリによって異なります(前述)。

`send(string[, flags])'
     ソケットにデータを送信します。ソケットはリモートソケットに接続済みでなけ
     ればなりません。オプション引数FLAGSの意味は、上記`recv()'と
     同じです。戻り値として、送信したバイト数を返します。アプリケーションで
     は、必ず戻り値をチェックし、全てのデータが送られた事を確認する必要があり
     ます。データの一部だけが送信された場合、アプリケーションで残りのデータを
     再送信してください。

`sendall(string[, flags])'
     ソケットにデータを送信します。ソケットはリモートソケットに接続済みでなけ
     ればなりません。オプション引数FLAGSの意味は、上記`recv()'と
     同じです。`send()'と異なり、このメソッドはSTRINGの全データ
     を送信するか、エラーが発生するまで処理を継続します。正常終了の場合は
     `None'を返し、エラー発生時には例外が発生します。エラー発生時、送信
     されたバイト数を調べる事はできません。

`sendto(string[, flags], address)'
     ソケットにデータを送信します。このメソッドでは接続先をADDRESSで指
     定するので、接続済みではいけません。オプション引数FLAGSの意味は、
     上記`recv()'と同じです。戻り値として、送信したバイト数を返しま
     す。ADDRESSのフォーマットはアドレスファミリによって異なります(前
     述)。

`setblocking(flag)'
     ソケットのブロッキング・非ブロッキングモードを指定します。FLAGが0
     の場合は非ブロッキングモード、0以外の場合はブロッキングモードとなりま
     す。全てのソケットは、初期状態ではブロッキングモードです。非ブロッキング
     モードでは、`recv()'メソッド呼び出し時に読み込みデータが無かった
     り`send()'メソッド呼び出し時にデータを処理する事ができないような
     場合に`error'例外が発生します。しかし、ブロッキングモードでは
     呼び出しは処理が行われるまでブロックされます。`s.setblocking(0)'は
     `s.settimeout(0)'と、`s.setblocking(1)'は
     `s.settimeout(None)'とそれぞれ同じ意味を持ちます。

`settimeout(value)'
     ソケットのブロッキング処理のタイムアウト値を指定します。VALUEに
     は、正の浮動小数点で秒数を指定するか、もしくは`None'を指定します。
     浮動小数点値を指定した場合、操作が完了する前にVALUEで指定した秒数
     が経過すると`timeout'が発生します。タイムアウト値に`None'を
     指定すると、ソケットのタイムアウトを無効にします。
     `s.settimeout(0.0)'は`s.setblocking(0)'と、
     `s.settimeout(None)'は`s.setblocking(1)'とそれぞれ同じ意味を持
     ちます。 _Added in Python version 2.3_

`gettimeout()'
     ソケットに指定されたタイムアウト値を取得します。タイムアウト値が設定され
     ている場合には浮動小数点型で秒数が、設定されていなければ`None'が返
     ります。この値は、最後に呼び出された`setblocking()'または
     `settimeout()'によって設定されます。_Added in Python version 2.3_

ソケットのブロッキングとタイムアウトについて:ソケットオブジェクトのモー
ドは、ブロッキング・非ブロッキング・タイムアウトの何れかとなります。初期
状態では常にブロッキングモードです。ブロッキングモードでは、処理が完了す
るまでブロックされます。非ブロッキングモードでは、処理を行う事ができなけ
れば(不幸にもシステムによって異なる値の)エラーとなります。タイムアウト
モードでは、ソケットに指定したタイムアウトまでに完了しなければ処理は失敗
となります。`setblocking()'メソッドは、`settimeout()'の省 略形式です。

内部的には、タイムアウトモードではソケットを非ブロッキングモードに設定し
ます。ブロッキングとタイムアウトの設定は、ソケットと同じネットワーク端点
へ接続するファイルディスクリプタにも反映されます。この結果、
`makefile()'で作成したファイルオブジェクトはブロッキングモードで
のみ使用することができます。これは非ブロッキングモードとタイムアウトモー
ドでは、即座に完了しないファイル操作はエラーとなるためです。

`setsockopt(level, optname, value)'
     ソケットのオプションを設定します(UNIXのマニュアルページ
     `setsockopt(2)'を参照)。`SO_*'等のシンボルは、このモジ
     ュールで定義しています。`value'には、整数または文字列をバッファとし
     て指定する事ができます。文字列を指定する場合、文字列には適切なビットを設
     定するようにします。(`struct' モジュール
     を利用すれば、Cの構造体を文字列にエンコードする事ができます。)

`shutdown(how)'
     接続の片方向、または両方向を切断します。HOWが`0'の場合、以降
     は受信を行えません。HOWが`1'の場合、以降は送信を行えません。
     HOWが`2'の場合、以降は送受信を行えません。

`read()'メソッドと`write()'メソッドは存在しませんので注意
してください。代わりにFLAGSを省略した`recv()'と
`send()'を使うことができます。


File: python-lib-jp.info,  Node: SSL オブジェクト,  Next: 例 8,  Prev: socket オブジェクト,  Up: socket

SSL オブジェクト
----------------

SSLオブジェクトには、以下のメソッドがあります。

`write(s)'
     文字列SをSSL接続で出力します。戻り値として、送信したバイト数を返し
     ます。

`read([n])'
     SSL接続からデータを受信します。Nを指定した場合は指定したバイト数の
     データを受信し、省略時はEOFまで読み込みます。戻り値として、受信したバイ
     ト列の文字列を返します。


File: python-lib-jp.info,  Node: 例 8,  Prev: SSL オブジェクト,  Up: socket

例
--

以下はTCP/IPプロトコルの簡単なサンプルとして、受信したデータをクライアン
トにそのまま返送するサーバ(接続可能なクライアントは一件のみ)と、サーバに
接続するクライアントの例を示します。サーバでは、`socket()'・
`bind()'・`listen()'・`accept()'を実行し(複数のクラ
イアントからの接続を受け付ける場合、`accept()'を複数回呼び出しま
す)、クライアントでは`socket()'と`connect()'だけを呼び出
しています。サーバでは`send()'/`recv()'メソッドはlisten中
のソケットで実行するのではなく、`accept()'で取得したソケットに対
して実行している点にも注意してください。

次のクライアントとサーバは、IPv4のみをサポートしています。

     # Echo server program
     import socket
     
     HOST = ''                 # Symbolic name meaning the local host
     PORT = 50007              # Arbitrary non-privileged port
     s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
     s.bind((HOST, PORT))
     s.listen(1)
     conn, addr = s.accept()
     print 'Connected by', addr
     while 1:
         data = conn.recv(1024)
         if not data: break
         conn.send(data)
     conn.close()

     # Echo client program
     import socket
     
     HOST = 'daring.cwi.nl'    # The remote host
     PORT = 50007              # The same port as used by the server
     s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
     s.connect((HOST, PORT))
     s.send('Hello, world')
     data = s.recv(1024)
     s.close()
     print 'Received', `data`

The next two examples are identical to the above two, but support both
IPv4 and IPv6.  The server side will listen to the first address family
available (it should listen to both instead).  On most of IPv6-ready
systems, IPv6 will take precedence and the server may not accept IPv4
traffic.  The client side will try to connect to the all addresses
returned as a result of the name resolution, and sends traffic to the
first one connected successfully.

次のサンプルは上記のサンプルとほとんど同じですが、IPv4とIPv6の両方をサ
ポートしています。サーバでは、IPv4/v6の両方ではなく、利用可能な最初のア
ドレスファミリだけをlistenしています。ほとんどのIPv6対応システムではIPv6
が先に現れるため、サーバはIPv4には応答しません。クライアントでは名前解決
の結果として取得したアドレスに順次接続を試み、最初に接続に成功したソケッ
トにデータを送信しています。

     # Echo server program
     import socket
     import sys
     
     HOST = ''                 # Symbolic name meaning the local host
     PORT = 50007              # Arbitrary non-privileged port
     s = None
     for res in socket.getaddrinfo(HOST, PORT, socket.AF_UNSPEC, socket.SOCK_STREAM, 0, socket.AI_PASSIVE):
         af, socktype, proto, canonname, sa = res
         try:
     	s = socket.socket(af, socktype, proto)
         except socket.error, msg:
     	s = None
     	continue
         try:
     	s.bind(sa)
     	s.listen(1)
         except socket.error, msg:
     	s.close()
     	s = None
     	continue
         break
     if s is None:
         print 'could not open socket'
         sys.exit(1)
     conn, addr = s.accept()
     print 'Connected by', addr
     while 1:
         data = conn.recv(1024)
         if not data: break
         conn.send(data)
     conn.close()

     # Echo client program
     import socket
     import sys
     
     HOST = 'daring.cwi.nl'    # The remote host
     PORT = 50007              # The same port as used by the server
     s = None
     for res in socket.getaddrinfo(HOST, PORT, socket.AF_UNSPEC, socket.SOCK_STREAM):
         af, socktype, proto, canonname, sa = res
         try:
     	s = socket.socket(af, socktype, proto)
         except socket.error, msg:
     	s = None
     	continue
         try:
     	s.connect(sa)
         except socket.error, msg:
     	s.close()
     	s = None
     	continue
         break
     if s is None:
         print 'could not open socket'
         sys.exit(1)
     s.send('Hello, world')
     data = s.recv(1024)
     s.close()
     print 'Received', `data`


File: python-lib-jp.info,  Node: select,  Next: thread,  Prev: socket,  Up: オプションのオペレーティングシステムサービス

I/O 処理の完了を待機する
========================

複数のストリームに対してI/O 処理の完了を待機します。

このモジュールでは、ほとんどのオペレーティングシステムで利用可能な
`select()' および `poll()' 関数へのアクセス 機構を提供します。Windows
の上ではソケットに対してしか動作しないので 注意してください;
その他のオペレーティングシステムでは、他のファイル 形式でも (特に
UNIXではパイプにも) 動作します。通常のファイルに
対して適用し、最後にファイルを読み出した時から内容が増えているかを
決定するために使うことはできません。

このモジュールでは以下の内容を定義しています:

`error'
     エラーが発生したときに送出される例外です。エラーに付属する 値は、
     `errno' からとったエラーコードを表す数値とその
     エラーコードに対応する文字列からなるペアで、C 関数の `perror()'
     が出力するものと同様です。

`poll()'
     (全てのオペレーティングシステムでサポートされているわけでは
     ありません。) ポーリングオブジェクトを返します。このオブジェクトは
     ファイル記述子を登録したり登録解除したりすることができ、
     ファイル記述子に対する I/O イベント発生をポーリングすることが
     できます; ポーリングオブジェクトが提供しているメソッドについては
     下記の ~*Note threading:: 節を参照してください。

`select(iwtd, owtd, ewtd[, timeout])'
     UNIX の `select()' システムコールに対する直接的な
     インタフェースです。最初の 3 つの引数は `待機可能なオブジェクト'
     からなるリストです: ファイル記述子を表す整数値、または
     引数を持たず、整数を返すメソッド `fileno()' を持つ
     オブジェクトです。待機可能なオブジェクトの 3 つのリストはそれぞれ
     入力、出力、そして `例外状態' に対応します。いずれかに空のリストを
     指定してもかまいませんが、3 つ全てを空のリストにしてもよいかどうか
     はプラットフォームに依存します (UNIX では動作し、Windows では
     動作しないことが知られています)。オプションの TIMEOUT 引数
     にはタイムアウトまでの秒数を浮動小数点数型で指定します。 TIMEOUT
     引数が省略された場合、関数は少なくとも一つのファイル
     記述子が何らかの準備完了状態になるまでブロックします。
     タイムアウト値ゼロは、ポーリングを行いブロックしないことを示します。

     戻り値は準備完了状態のオブジェクトからなる 3 つのリストです:
     従ってこのリストはそれぞれ関数の最初の 3 つの引数のサブセットに
     なります。ファイル記述子のいずれも準備完了にならないままタイムアウト
     した場合、3 つの空のリストが返されます。

     リストの中に含めることのできるオブジェクトは Python ファイル
     オブジェクト (すなわち `sys.stdin', あるいは `open()' や
     `os.popen()' が返すオブジェクト)、`socket.socket()'
     が返すソケットオブジェクト  です。 "wrapper"
     クラスを自分で定義することもできます。この場合、 適切な
     (単なる乱数ではなく本当のファイル記述子を返す)`fileno()'
     メソッドを持つ必要があります _Note:_ `select' はWindows
     のファイルオブジェクトを受理 しませんが、ソケットは受理します  。
     Windows では、 背後の `select()' 関数は WinSock
     ライブラリで提供されて おり、WinSock
     によって生成されたものではないファイル記述子を扱う
     ことができないのです。

* Menu:

* ポーリングオブジェクト::


File: python-lib-jp.info,  Node: ポーリングオブジェクト,  Prev: select,  Up: select

ポーリングオブジェクト
----------------------

`poll()' システムコールはほとんどの UNIX システムでサポート
されており、非常に多数のクライアントに同時にサービスを提供するような
ネットワークサーバが高い拡張性を持てるようにしています。 `poll()'
に高い拡張性があるのは、`select()' が
ビット対応表を構築し、対象ファイルの記述子に対応するビットを立て、
その後全ての対応表の全てのビットを線形探索するのに対し、 `poll()'
は対象のファイル記述子を列挙するだけでよいから です。 `select()' は
O(最大のファイル記述子番号) なのに対し、 `poll()' は
O(対象とするファイル記述子の数) で済みます。

`register(fd[, eventmask])'
     ファイル記述子をポーリングオブジェクトに登録します。これ以降の
     `poll()' メソッド呼び出しでは、そのファイル記述子に処理待ち中の
     I/O イベントがあるかどうかを監視します。FD は整数か、 整数値を返す
     `fileno()' メソッドを持つオブジェクトを取ります。
     ファイルオブジェクトも通常 `fileno()' を実装しているので、
     引数として使うことができます。

     EVENTMASK はオプションのビットマスクで、どのタイプの I/O イベント
     を監視したいかを記述します。この値は以下の表で述べる定数 `POLLIN'、
     `POLLPRI'、および `POLLOUT' の組み合わせにすることが
     できます。ビットマスクを指定しない場合、標準の値が使われ、 3
     種のイベント全てに対して監視が行われます。

     定数                               意味
     ------                             -----
     POLLIN                             読み出せるデータの存在
     POLLPRI                            緊急の読み出しデータの存在
     POLLOUT                            書き出せるかどうか:
                                        書き出し処理がブロックしないかどうか
     POLLERR                            何らかのエラー状態
     POLLHUP                            ハングアップ
     POLLNVAL                           無効な要求: 記述子が開かれていない

     すでに登録済みのファイル記述子を登録してもエラーにはならず、
     一度だけ登録した場合と同じ効果になります。

`unregister(fd)'
     ポーリングオブジェクトによって追跡中のファイル記述子を登録解除します。
     `register()' メソッドと同様に、FD は整数か、 整数値を返す
     `fileno()' メソッドを持つオブジェクトを取ります。

     登録されていないファイル記述子を登録解除しようとすると `KeyError'
     例外が送出されます。

`poll([timeout])'
     登録されたファイル記述子に対してポーリングを行い、 報告すべき I/O
     イベントまたはエラーの発生したファイル記述子に 毎に 2 要素のタプル
     `(FD, EVENT)' からなるリスト
     を返します。リストは空になることもあります。 FD
     はファイル記述子で、EVENT は該当するファイル記述子
     について報告されたイベントを表すビットマスクです -- 例えば
     `POLLIN' は入力待ちを示し、`POLLOUT' はファイル記述子
     に対する書き込みが可能を示す、などです。
     空のリストは呼び出しがタイムアウトしたか、報告すべきイベントが
     どのファイル記述子でも発生しなかったことを示します。 TIMEOUT
     が与えられた場合、処理を戻すまで待機する時間の長さを
     ミリ秒単位で指定します。TIMEOUT が省略されたり、負の値であったり、
     あるいは `None' の場合、そのポーリングオブジェクトが監視している
     何らかのイベントが発生するまでブロックします。


File: python-lib-jp.info,  Node: thread,  Next: threading,  Prev: select,  Up: オプションのオペレーティングシステムサービス

マルチスレッドのコントロール
============================

1つのインタープリタの中でのマルチスレッド制御

このモジュールはマルチスレッド(別名 "軽量プロセス" ("light-weight
processes")または"タスク"("tasks"))
に用いられる低レベルプリミティブを提供します --
グローバルデータ空間を共有するマルチスレッドを制御します。
同期のための単純なロック(別名 "mutexes"または バイナリセマフォ("binary
semaphores"))が提供されています。

このモジュールはオプションです。 Windows, Linux, SGI IRIX, Solaris
2.x、そして同じようなPOSIXスレッド
(別名"pthread")実装のシステム上でサポートされます。
`thread'を使用することのできないシステムでは、
`dummy_thread'が用意されています。
`dummy_thread'はこのモジュールと同じインターフェース
を持ち、置き換えて使用することができます。

定数と関数は以下のように定義されています:

`error'
     スレッド特有のエラーで送出されます。

`LockType'
     これはロックオブジェクトのタイプです。

`start_new_thread(function, args[, kwargs])'
     新しいスレッドを開始して、そのIDを返します。
     スレッドは引数リストARGS(タプルでなければなりません)の
     関数FUNCTIONを実行します。
     オプション引数KWARGSはキーワード引数の辞書を指定します。
     関数が戻るとき、スレッドは黙って終了します。
     関数が未定義の例外でターミネートしたとき、スタックトレースが表示され、
     そしてスレッドが終了します(しかし他のスレッドは走り続けます)。

`interrupt_main()'
     メインスレッドで KeyboardInterrupt を送出します。サブスレッドは
     この関数を使ってメインスレッドに割り込みをかけることができます。
     _Added in Python version 2.3_

`exit()'
     `SystemExit'例外を送出します。
     それが捕えられないときは、黙ってスレッドを終了させます。

`allocate_lock()'
     新しいロックオブジェクトを返します。
     ロックのメソッドはこの後に記述されます。
     ロックは初期状態としてアンロック状態です。

`get_ident()'
     現在のスレッドの`スレッドID'を返します。 これは0でない整数です。
     この値は直接の意味を持っていません;
     例えばスレッド特有のデータの辞書に索引をつけるためのような、
     マジッククッキーとして意図されています。
     スレッドが終了し、他のスレッドが作られたとき、
     スレッドIDは再利用されるかもしれません。

ロックオブジェクトは次のようなメソッドを持っています:

`acquire([waitflag])'
     オプションの引数なしで使用すると、このメソッドは他のスレッドがロックし
     ているかどうかにかかわらずロックを獲得し、`None' を返します。
     ただし他のスレッドがすでにロックしている場合には解除されるまで
     待ってからロックを獲得します (同時にロックを獲得できるスレッドは
     ひとつだけであり、これこそがロックの存在理由です)。 整数の引数
     WAITFLAG を指定すると、その値によって動作が変わります。 引数が `0'
     のときは、待たずにすぐ獲得できる場合にだけロックを獲得 します。`0'
     以外の値を与えると、先の例と同様、ロックの状態に
     かかわらず獲得をおこないます。なお、引数を与えた場合、ロックを獲得すると
     `True'、できなかったときには `False' を返します。

`release()'
     ロックを解放します。そのロックは既に獲得されたものでなければなりませんが、
     しかし同じスレッドによって獲得されたものである必要はありません。

`locked()'
     ロックの状態を返します:
     同じスレッドによって獲得されたものなら`True'、
     違うのなら`False'を返します。

*Caveats:*

   * スレッドは割り込みと奇妙な相互作用をします:
     `KeyboardInterrupt'例外は任意のスレッドによって受け取られます。
     (`signal' モジュールが利用可能なとき、
     割り込みは常にメインスレッドへ行きます。)

   * `sys.exit()'を呼び出す、 あるいは`SystemExit'例外を送出することは、
     `exit()'を呼び出すことと同じです。

   * I/O待ちをブロックするかもしれない全ての組込み関数が、
     他のスレッドの走行を許すわけではありません。
     (ほとんどの一般的なもの (`time.sleep()', `FILE.read()',
     `select.select()')は期待通りに働きます。)

   * ロックの`acquire()'メソッドに割り込むことはできません --
     `KeyboardInterrupt'例外は、ロックが獲得された後に発生します。

   * メインスレッドが終了したとき、他のスレッドが生き残るかどうかは、
     システムが定義します。 ネイティブスレッド実装を使うSGI
     IRIXでは生き残ります。 その他の多くのシステムでは、`try' ...
     `finally'節
     を実行せずに殺されたり、デストラクタを実行せずに殺されたりします。

   *
     メインスレッドが終了したとき、それの通常のクリーンアップは行なわれず
     (`try' ... `finally'節が尊重されることは除きます)、
     標準I/Oファイルはフラッシュされません。


