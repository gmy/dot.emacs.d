This is python-lib-jp.info, produced by makeinfo version 4.5 from
python-lib-jp.texi.

12 October 2005


File: python-lib-jp.info,  Node: キャリブレーション補正,  Next: Profiler Extensions,  Prev: 制限事項 2,  Up: Python プロファイラ

キャリブレーション(補正)
========================

プロファイラは イベントをハンドリングの際の time 関数呼出しおよびその
値を保存するためのオーバーヘッドを補正するための、定数を持っています。
デフォルトの値は 0 です。以下の手順で、プラットフォームに合った、より
適切な定数が得られます(前節「制限事項」の説明を参照)。

     import profile
     pr = profile.Profile()
     for i in range(5):
         print pr.calibrate(10000)

メソッドは引数として与えられた数だけ Python の呼出しをおこないます。呼
出しは直接、プロファイラを使って呼出しの両方が実施され、それぞれの時間
が計測されます。その結果、プロファイラのイベントに隠されたオーバーヘッ
ドが計算され、その値は浮動小数として返されます。たとえば、800 MHz の
Pentium で Windows 2000 を使用、Python の time.clock() をタイマとして
使った場合、値はおよそ 12.5e-6 となります。

この手順で使用しているオブジェクトはほぼ一定の結果を返します。_非
常に_早いコンピュータを使う場合、もしくはタイマの性能が貧弱な場合は一
定の結果を得るために引数に 100000 や 1000000 といった大きな値を指定す
る必要があるかもしれません。

一定の結果が得られたら、それを使う方法には3通りあります。(1)

     import profile
     
     # 1. 算出した補正値 (your_computed_bias) をこれ以降生成する
     #    Profile インスタンスに適用する。
     profile.Profile.bias = your_computed_bias
     
     # 2. 特定の Profile インスタンスに補正値を適用する。
     pr = profile.Profile()
     pr.bias = your_computed_bias
     
     # 3. インスタンスのコンストラクタに補正値を指定する。
     pr = profile.Profile(bias=your_computed_bias)

方法を選択したら、補正値は小さめに設定した方が良いでしょう。プロファイ
ルの結果に負の値が表われる"確率が少なく"なるはずです。

---------- Footnotes ----------

(1)  Python 2.2
より前のバージョンではプロファイラのソースコードに補正値と
して埋め込まれた定数を直接編集する必要がありました。今でも同じことは可
能ですが、その方法は説明しません。なぜなら、もうソースを編集する必要が
ないからです。


File: python-lib-jp.info,  Node: Profiler Extensions,  Next: hotshot,  Prev: キャリブレーション補正,  Up: Python プロファイラ

プロファイラの改善
==================

`profile' モジュールの `Profile' クラスはプロファイラの機
能を拡張するため、派生クラスの作成を前提に書かれています。しかしその方
法を説明するには、`Profile' の内部動作について詳細な解説が必要と
なるため、ここでは述べません。もし拡張をおこないたいのであれば、
`profile' モジュールのソースを注意深く読む必要があります。

プロファイラが時刻を取得する方法を変更したいだけなら(たとえば、通常の
時間(wall-clock)を使いたいとか、プロセスの経過時間を使いたい場合)、時
刻取得用の関数を `Profile' クラスのコンストラクタに指定すること
ができます。

     pr = profile.Profile(your_time_func)

この結果生成されるプロファイラは時刻取得に `your_time_func()' を
呼び出すようになります。このようなユーザ定義関数は単一の数値、あるいは
その合計が(`os.times()' と同じように)累計時間を示すリストを返
すようになっていなければなりません。関数が1つの数値、あるいは長さ2の数
値のリストを返すようになっていれば、非常に高速に処理が可能になります。

選択する時刻取得関数によって、プロファイラクラスを補正する必要があるこ
とに注意してください。多くのマシンにおいて、プロファイル時のオーバヘッ
ドを少なくする方法として、タイマはロング整数を返すのが最善です。
`os.times()' は浮動小数のタプルを返すので _おすすめできま
せん_)。タイマをより正確なものに置き換えたいならば、派生クラスでそのディ
スパッチ・メソッドを適切なタイマ呼出しと適切な補正をおこなうように書き
直す必要があります。


File: python-lib-jp.info,  Node: hotshot,  Next: timeit,  Prev: Profiler Extensions,  Up: Python プロファイラ

ハイパフォーマンス・ロギング・プロファイラ
==========================================

コードの大半が C で書かれたハイパフォーマンス・ロギン グ・プロファイラ

_Added in Python version 2.2_

このモジュールは `_hotshot' C モジュールへのより良いインターフェー
スを提供します。Hotshot は既存の `profile' に置き換わるもの
です。その大半が C で書かれているため、`profile' に比べパフォー
マンス上の影響がはるかに少なく済みます。

`Profile(logfile[, lineevents`=0'[, linetimings`=1']])'
     プロファイラ・オブジェクト。引数 LOGFILE はプロファイル・データ
     のログを保存するファイル名です。引数 LINEEVENTS はソースコー ドの1
     行ごとにイベントを発生させるか、関数の呼び出し/リターンのときだ
     け発生させるかを指定します。デフォルトの値は `0' (関数の呼び出し/
     リターンのときだけログを残す)です。引数 LINETIMINGS は時間情報を
     記録するかどうかを指定します。デフォルトの値は `1' (時間情報を記
     録する)です。


* Menu:

* プロファイル・オブジェクト::
* hotshot データの利用::
* 使用例 4::


File: python-lib-jp.info,  Node: プロファイル・オブジェクト,  Next: hotshot データの利用,  Prev: hotshot,  Up: hotshot

プロファイル・オブジェクト
--------------------------

プロファイル・オブジェクトは以下のメソッドを持っています。

`addinfo(key, value)'
     プロファイル出力の際、任意のラベル名を追加します。

`close()'
     ログファイルを閉じ、プロファイラを終了します。

`fileno()'
     プロファイラのログファイルのファイル・ディスクリプタを返します。

`run(cmd)'
     スクリプト環境で `exec' 互換文字列のプロファイルをおこないます。
     `__main__' モジュールのグローバル変数は、スクリプトの
     グローバル変数、ローカル変数の両方に使われます。

`runcall(func, *args, **keywords)'
     単一の呼び出し可能オブジェクトのプロファイルをおこないます。位置依存引
     数やキーワード引数を追加して呼び出すオブジェクトに渡すこともできます。
     呼び出しの結果はそのまま返されます。例外が発生したときはプロファイリン
     グが無効になり、例外をそのまま伝えるようになっています。

`runctx(cmd, globals, locals)'
     指定した環境で `exec' 互換文字列の評価をおこないます。文字列の
     コンパイルはプロファイルを開始する前におこなわれます。

`start()'
     プロファイラを開始します。

`stop()'
     プロファイラを停止します。


File: python-lib-jp.info,  Node: hotshot データの利用,  Next: 使用例 4,  Prev: プロファイル・オブジェクト,  Up: hotshot

hotshot データの利用
--------------------

Hotshot の統計分析

_Added in Python version 2.2_

このモジュールは hotshot プロファイル・データを標準の `pstats'
オブジェクトにロードします。

`load(filename)'
     FILENAME から hotshot データを読み込み、`pstats.Stats' ク
     ラスのインスタンスを返します。

See also:
     *Note リファレンス・マニュアル:: `profile' モジュールの `Stats'
     クラス


File: python-lib-jp.info,  Node: 使用例 4,  Prev: hotshot データの利用,  Up: hotshot

使用例
------

これは Python の"ベンチマーク" pystone を使った例です。実行にはやや
時間がかかり、巨大な出力ファイルを生成するので注意してください。

     >>> import hotshot, hotshot.stats, test.pystone
     >>> prof = hotshot.Profile("stones.prof")
     >>> benchtime, stones = prof.runcall(test.pystone.pystones)
     >>> prof.close()
     >>> stats = hotshot.stats.load("stones.prof")
     >>> stats.strip_dirs()
     >>> stats.sort_stats('time', 'calls')
     >>> stats.print_stats(20)
              850004 function calls in 10.090 CPU seconds
     
        Ordered by: internal time, call count
     
        ncalls  tottime  percall  cumtime  percall filename:lineno(function)
             1    3.295    3.295   10.090   10.090 pystone.py:79(Proc0)
        150000    1.315    0.000    1.315    0.000 pystone.py:203(Proc7)
         50000    1.313    0.000    1.463    0.000 pystone.py:229(Func2)
      .
      .
      .


File: python-lib-jp.info,  Node: timeit,  Prev: hotshot,  Up: Python プロファイラ

小さなコード断片の実行時間計測
==============================

小さなコード断片の実行時間計測。

_Added in Python version 2.3_

このモジュールは Python の小さなコード断片の時間を簡単に計測する手段を
提供します。インターフェースはコマンドラインとメソッドとして呼び出し可
能なものの両方を備えています。また、このモジュールは実行時間の計測にあ
たり陥りがちな落し穴に対する様々な対策が取られています。詳しくは、
O'Reilly の 、"Algorithms" の章にある Tim Peters
が書いた解説を参照してください。

このモジュールには次のパブリック・クラスが定義されています。

`Timer([stmt=`'pass'' [, setup=`'pass'' [, timer=<timer function>]]])'
     小さなコード断片の実行時間計測をおこなうためのクラスです。

     コンストラクタは引数として、時間計測の対象となる文、セットアップに使用
     する追加の文、タイマ関数を受け取ります。文のデフォルト値は両方とも
     `'pass'' で、タイマ関数はプラットフォーム依存(モジュールの doc
     string
     を参照)です。文には複数行の文字列リテラルを含まない限り、改行を
     入れることも可能です。

     最初の文の実行時間を計測には `timeit()' メソッドを使用します。
     また `timeit()' を複数回呼び出し、その結果のリストを返す
     `repeat()' メソッドも用意されています。

`print_exc([file=`None'])'
     計測対象コードのトレースバックを出力するためのヘルパー。

     利用例:

              t = Timer(...)       # try/except の外側で
              try:
                  t.timeit(...)    # または t.repeat(...)
              except:
                  t.print_exc()

     標準のトレースバックより優れた点は、コンパイルしたテンプレートのソース
     行が表示されることです。オプションの引数 FILE にはトレースバック
     の出力先を指定します。デフォルトは `sys.stderr' になっています。

`repeat([repeat`=3' [, number`=1000000']])'
     `timeit()' を複数回呼び出します。

     このメソッドは `timeit()' を複数回呼び出し、その結果をリストで
     返すユーティリティ関数です。最初の引数には `timeit()' を呼び出
     す回数を指定します。2番目の引数は `timeit()' へ引数として渡す
     数値です。

     _Notice:_

     結果のベクトルから平均値や標準偏差を計算して出力させたいと思うかもしれ
     ませんが、それはあまり意味がありません。多くの場合、最も低い値がそのマ
     シンが与えられたコード断片を実行する場合の下限値です。結果のうち高めの
     値は、Python
     のスピードが一定しないために生じたものではなく、時刻取得
     の際他のプロセスと衝突がおこったため、正確さが損なわれた結果生じたもの
     です。したがって、結果のうち `min()' だけが見るべき値となりま
     す。この点を押さえた上で、統計的な分析よりも常識的な判断で結果を見るよ
     うにしてください。


`timeit([number`=1000000'])'
     メイン文の実行時間を NUMBER 回取得します。このメソッドはセットアッ
     プ文を1回だけ実行し、メイン文を指定回数実行するのにかかった秒数を浮動
     小数で返します。引数はループを何回実行するかの指定で、デフォルト値は
     100万回です。メイン文、セットアップ文、タイマ関数はコンストラクタで指
     定されたものを使用します。

* Menu:

* コマンドライン・インターフェース::
* 使用例 5::


File: python-lib-jp.info,  Node: コマンドライン・インターフェース,  Next: 使用例 5,  Prev: timeit,  Up: timeit

コマンドライン・インターフェース
--------------------------------

コマンドラインからプログラムとして呼び出す場合は、次の書式を使います。

     python timeit.py [-n N] [-r N] [-s S] [-t] [-c] [-h] [statement ...]

以下のオプションが使用できます。

`-n N/`--number'=N'
     'statement' を何回実行するか

`-r N/`--repeat'=N'
     タイマを何回リピートするか(デフォルトは 3)

`-s S/`--setup'=S'
     最初に1回だけ実行する文 (デフォルトは `'pass'')

`-t/`--time''
     `time.time()' を使用する (Windows
     を除くすべてのプラットフォームのデフォルト)

`-c/`--clock''
     `time.clock()' を使用する(Windows のデフォルト)

`-v/`--verbose''
     時間計測の結果をそのまま詳細な数値でくり返し表示する

`-h/`--help''
     簡単な使い方を表示して終了する

文は複数行指定することもできます。その場合、各行は独立した文として引数
に指定されたものとして処理します。クォートと行頭のスペースを使って、イ
ンデントした文を使うことも可能です。この複数行のオプションは `-s'
においても同じ形式で指定可能です。

オプション `-n' でループの回数が指定されていない場合、10回
から始めて、所要時間が 0.2 秒になるまで回数を増やすことで適切なループ
回数が自動計算されるようになっています。

デフォルトのタイマ関数はプラットフォーム依存です。Windows の場合、
`time.clock()' はマイクロ秒の精度がありますが、 `time.time()' は 1/60
秒の精度しかありません。一方 UNIXの場 合、`time.clock()' でも 1/100
秒の精度があり、 `time.time()'
はもっと正確です。いずれのプラットフォームにお
いても、デフォルトのタイマ関数は CPU 時間ではなく通常の時間を返します。
つまり、同じコンピュータ上で別のプロセスが動いている場合、タイミングの
衝突する可能性があるということです。正確な時間を割り出すために最善の方
法は、時間の取得を数回くり返しその中の最短の時間を採用することです。
`-r' オプションはこれをおこなうもので、デフォルトのくり返し
回数は3回になっています。多くの場合はデフォルトのままで充分でしょう。
UNIXの場合 `time.clock()' を使って CPU 時間で測定することも できます。

_Notice:_ pass
文の実行による基本的なオーバーヘッドが存在することに注意してく
ださい。ここにあるコードはこの事実を隠そうとはしておらず、注意を払う
必要があります。基本的なオーバーヘッドは引数なしでプログラムを起動す
ることにより計測できます。

基本的なオーバヘッドは Python のバージョンによって異なります。Python
2.3 とそれ以前の Python の公平な比較をおこなう場合、古い方の Python は
`-O' オプションで起動し `SET_LINENO' 命令の実行時間が
含まれないようにする必要があります。


File: python-lib-jp.info,  Node: 使用例 5,  Prev: コマンドライン・インターフェース,  Up: timeit

使用例
------

以下に2つの使用例を記載します(ひとつはコマンドライン・インターフェース
によるもの、もうひとつはモジュール・インターフェースによるものです)。
内容はオブジェクトの属性の有無を調べるのに `hasattr()' を使っ た場合と
`try'/`except' を使った場合の比較です。

     % timeit.py 'try:' '  str.__nonzero__' 'except AttributeError:' '  pass'
     100000 loops, best of 3: 15.7 usec per loop
     % timeit.py 'if hasattr(str, "__nonzero__"): pass'
     100000 loops, best of 3: 4.26 usec per loop
     % timeit.py 'try:' '  int.__nonzero__' 'except AttributeError:' '  pass'
     1000000 loops, best of 3: 1.43 usec per loop
     % timeit.py 'if hasattr(int, "__nonzero__"): pass'
     100000 loops, best of 3: 2.23 usec per loop

     >>> import timeit
     >>> s = """\
     ... try:
     ...     str.__nonzero__
     ... except AttributeError:
     ...     pass
     ... """
     >>> t = timeit.Timer(stmt=s)
     >>> print "%.2f usec/pass" % (1000000 * t.timeit(number=100000)/100000)
     17.09 usec/pass
     >>> s = """\
     ... if hasattr(str, '__nonzero__'): pass
     ... """
     >>> t = timeit.Timer(stmt=s)
     >>> print "%.2f usec/pass" % (1000000 * t.timeit(number=100000)/100000)
     4.85 usec/pass
     >>> s = """\
     ... try:
     ...     int.__nonzero__
     ... except AttributeError:
     ...     pass
     ... """
     >>> t = timeit.Timer(stmt=s)
     >>> print "%.2f usec/pass" % (1000000 * t.timeit(number=100000)/100000)
     1.97 usec/pass
     >>> s = """\
     ... if hasattr(int, '__nonzero__'): pass
     ... """
     >>> t = timeit.Timer(stmt=s)
     >>> print "%.2f usec/pass" % (1000000 * t.timeit(number=100000)/100000)
     3.15 usec/pass

定義した関数に `timeit' モジュールがアクセスできるように
するために、import 文の入った `setup' 引数を渡すことができます:

     def test():
         "Stupid test function"
         L = []
         for i in range(100):
             L.append(i)
     
     if __name__=='__main__':
         from timeit import Timer
         t = Timer("test()", "from __main__ import test")
         print t.timeit()


File: python-lib-jp.info,  Node: インターネットプロトコルとその支援,  Next: インターネット上のデータの操作,  Prev: Python プロファイラ,  Up: Top

インターネットプロトコルとその支援
**********************************

この章で記述されるモジュールは、インターネットプロトコルと
関連技術の支援を実装します。それらは全てPythonで実装されています。
これらのモジュールの大部分は、システム依存のモジュール `socket'
が存在することが必要ですが、
これは現在ではほとんどの一般的なプラットフォーム上でサポート
されています。ここに概観を示します。

* Menu:

* webbrowser::
* cgi::
* cgitb::
* urllib::
* urllib2::
* httplib::
* ftplib::
* gopherlib::
* poplib::
* imaplib::
* nntplib::
* smtplib::
* telnetlib::
* urlparse::
* SocketServer::
* BaseHTTPServer::
* SimpleHTTPServer::
* CGIHTTPServer::
* Cookie::
* xmlrpclib::
* SimpleXMLRPCServer::
* DocXMLRPCServer::
* asyncore::
* asynchat::


File: python-lib-jp.info,  Node: webbrowser,  Next: cgi,  Prev: インターネットプロトコルとその支援,  Up: インターネットプロトコルとその支援

便利なウェブブラウザコントローラー
==================================

ウェウブブラウザーのための使い易いコントローラー

`webbrowser'モジュールにはウェブベースのドキュメントを表示するための、とてもハイレベルなインターフェースが定義されています。
このコントローラーオブジェクトは使い易く、プラットフォーム非依存です。
たいていの環境では、このモジュールの`open()'を呼び出すだけで正しく
動作します。

UNIXでは、X11上でグラフィカルなブラウザが選択されますが、グラフィカルなブ
ラウザが利用できなかったり、X11が利用できない場合はテキストモードのブラウザ
が使われます。
もしテキストモードのブラウザが使われたら、ユーザがブラウザから抜け出すまでプ
ロセスの呼び出しはブロックされます。

UNIXでは、環境変数`BROWSER'が存在するならプラットフォームのデフォ
ルトであるブラウザのリストをオーバーライドし、コロンで区切られたリストの順に
ブラウザの起動を試みます。
リストの中の値に`%s'が含まれていたら、テキストモードのブラウザのコマン
ドラインとして`%s'の代わりにURLが引数として解釈されます；
もし`%s'が含まれなければ、起動するブラウザの名前として単純に解釈されま
す。

非UNIXプラットフォームあるいはUNIX上でX11ブラウザが利用可能な場合、制
御プロセスはユーザがブラウザを終了するのを待ちませんが、ディスプレイにブラウ
ザのウィンドウを表示させたままにします。

以下の例外が定義されています：

`Error'
     ブラウザのコントロールエラーが起こると発生する例外。

以下の関数が定義されています：

`open(url[, new=0][, autoraise=1])'
     デフォルトのブラウザでURLを表示します。
     NEWがtrueなら、可能であればブラウザの新しいウィンドウが開きます。
     AUTORAISEがtrueなら、可能であればウィンドウが前面に表示されます（多く
     のウィンドウマネージャではこの変数の設定に関わらず、前面に表示されます）。

`open_new(url)'
     可能であれば、デフォルトブラウザの新しいウィンドウでURLを開きますが、
     そうでない場合はブラウザのただ１つのウィンドウでURLを開きます。

`get([name])'
     ブラウザの種類NAMEのコントローラーオブジェクトを返します。
     もしNAMEが空文字列なら、呼び出した環境に適したデフォルトブラウザのコン
     トローラーを返します。

`register(name, constructor[, instance])'
     ブラウザの種類NAMEを登録します。
     ブラウザの種類が登録されたら、`get()'でそのブラウザのコントローラー
     を呼び出すことができます。
     INSTANCEが指定されなかったり、`None'なら、インスタンスが必要な時
     にはCONSTRUCTORがパラメータなしに呼び出されて作られます。
     INSTANCEが指定されたら、CONSTRUCTORは呼び出されないので、
     `None'でかまいません。

     この登録は、変数`BROWSER'を設定するか、`get'を空文字列でな
     く、宣言したハンドラの名前と一致する引数とともに呼び出すときだけ、役に立ちま
     す。

いくつかの種類のブラウザがあらかじめ定義されています。
このモジュールで定義されている、関数`get()'に与えるブラウザの名前
と、それぞれのコントローラークラスのインスタンスを以下の表に示します。

Type Name                Class Name               Notes
------                   -----                    -----
'mozilla'                `Netscape('mozilla')'    
'netscape'               `Netscape('netscape')'   
'mosaic'                 `GenericBrowser('mosaic  
                         %s &')'                  
'kfm'                    `Konqueror()'            (1)
'grail'                  `Grail()'                
'links'                  `GenericBrowser('links   
                         %s')'                    
'lynx'                   `GenericBrowser('lynx    
                         %s')'                    
'w3m'                    `GenericBrowser('w3m     
                         %s')'                    
'windows-default'        `WindowsDefault'         (2)
'internet-config'        `InternetConfig'         (3)

Notes:

`(1)'
     "Konqueror"はUNIXのKDEデスクトップ環境のファイルマネージャで、KDEが動作
     している時にだけ意味を持ちます。
     何か信頼できる方法でKDEを検出するのがいいでしょう；変数`KDEDIR'では十
     分ではありません。 また、KDE
     2で`konqueror'コマンドを使うときにも、"kfm"が使われます --
     Konquerorを動作させるのに最も良い方法が実装によって選択されます。

`(2)'
     Windowsプラットフォームのみ；標準拡張モジュール`win32api'と
     `win32con'を必要とします。

`(3)'
     MacOSプラットフォームのみ；マニュアルに解説されている標準MacPythonモジュール`ic'
     を必要とします。

* Menu:

* ブラウザコントローラーオブジェクト::


File: python-lib-jp.info,  Node: ブラウザコントローラーオブジェクト,  Prev: webbrowser,  Up: webbrowser

ブラウザコントローラーオブジェクト
----------------------------------

ブラウザコントローラーには２つのメソッドが定義されていて、モジュールレベルの
便利な２つの関数に相当します：

`open(url[, new])'
     このコントローラーでハンドルされたブラウザでURLを表示します。
     NEWがtrueなら、可能であればブラウザの新しいウィンドウが開きます。

`open_new(url)'
     可能であれば、このコントローラーでハンドルされたブラウザの新しいウィンドウで
     URLを開きますが、そうでない場合はブラウザのただ１つのウィンドウで
     URLを開きます。


File: python-lib-jp.info,  Node: cgi,  Next: cgitb,  Prev: webbrowser,  Up: インターネットプロトコルとその支援

CGI (ゲートウェイインタフェース規格) のサポート
===============================================

サーバ側で動作するスクリプトにおいてフォームの内容を
解釈するために使われるゲートウェイインタフェース規格のサポート。

ゲートウェイインタフェース規格 (CGI) に準拠したスクリプトを
サポートするためのモジュールです。

このモジュールは Python で書かれた CGI スクリプトで使われる
数多くのユーティリティを定義しています。

* Menu:

* cgi-intro::
* Using the cgi module::
* 高レベルインタフェース::
* 古いクラス群::
* Functions in cgi module::
* セキュリティへの配慮::
* CGI スクリプトを UNIX システムにインストールする::
* CGI スクリプトをテストする::
* CGI スクリプトをデバッグする::
* よくある問題と解決法::


File: python-lib-jp.info,  Node: cgi-intro,  Next: Using the cgi module,  Prev: cgi,  Up: cgi

はじめに
--------

CGI スクリプトは、HTTP サーバによって起動され、通常は HTML の `<FORM>'
または `<ISINDEX>' エレメントを通じてユーザ
が入力した内容を処理するために使われます。

ほとんどの場合、CGI スクリプトはサーバ上の特殊な `cgi-bin'
ディレクトリ下に置かれます。HTTP サーバはまずリクエストの全ての 情報
(クライアントのホスト名、リクエストされている URL、クエリ
文字列、その他諸々) をスクリプトを動作させるシェルの環境変数
に設定し、スクリプトを実行した後、スクリプトの出力をクライアント
に送信します。

スクリプトの入力端もまたクライアントに接続されており、フォーム上の
データは時としてこの経路を通じて読み出されます; その他の場合、
フォームデータは URL の一部分である "クエリ文字列" を介して
渡されます。このモジュールでは、上記のケースの違いに注意しながら Python
スクリプトに対しては単純なインタフェースを提供するための
ものです。このモジュールではまた、スクリプトをデバッグするための
ユーティリティを多数提供しています。また、最近はフォームを
経由したファイルのアップロードをサポートしています (ブラウザ側
がサポートしていればです -- Grail 0.3 および Netscape 2.0 は
サポートしています。)

CGI スクリプトの出力は 2 つのセクションからなり、空行で分割
されています。最初のセクションは複数のヘッダからなり、
後続するデータがどのようなものかをクライアントに通知します。
最小のヘッダセクションを生成するための Python のコードは
以下のようなものです:

     print "Content-Type: text/html"     # HTML is following
     print                               # blank line, end of headers

二つ目のセクションは通常、ヘッダやインラインイメージ等の付属した
テキストをうまくフォーマットして表示できるようにした HTML です。
以下に単純な HTML を出力する Python コードを示します:

     print "<TITLE>CGI script output</TITLE>"
     print "<H1>This is my first CGI script</H1>"
     print "Hello, world!"


File: python-lib-jp.info,  Node: Using the cgi module,  Next: 高レベルインタフェース,  Prev: cgi-intro,  Up: cgi

cgi モジュールを使う
--------------------

先頭には `import cgi' と書いてください。`from cgi import *'
と書いてはいけません -- このモジュールは以前のバージョンとの互換性を
持たせるために内部で呼び出す名前を多数定義しており、それらが
ユーザの名前空間に存在する必要はありません。

新たにスクリプトを書く際には、以下の一行を付加するかどうか検討してください:

     import cgitb; cgitb.enable()

これによって、特別な例外処理が有効にされ、エラーが発生した際にブラウザ
上に詳細なレポートを出力するようになります。ユーザにスクリプトの内部を
見せたくないのなら、以下のようにしてレポートをファイルに保存できます:

     import cgitb; cgitb.enable(display=0, logdir="/tmp")

スクリプトを開発する際には、この機能はとても役に立ちます。 `cgitb'
が生成する報告はバグを追跡するためにかかる
時間を大きく減らせるような情報を提供してくれます。スクリプトを
テストし終わり、正確に動作することを確認した後はいつでも `cgitb'
の行を削除できます。

入力されたフォームデータを取得するには、 `FieldStorage' クラス
を使うのが最良の方法です。このモジュールで定義されている他のクラスの
ほとんどは以前のバージョンとの互換性のためのものです。
インスタンス生成は引数なしで必ず 1 度だけ行います。これにより、
標準入力または環境変数からフォームの内容が読み出されます
(どちらから読み出されるかは、CGI 標準に従って設定されている
複数の環境変数の値によって決められます)。インスタンスが標準入力を
使うかもしれないので、インスタンス生成を行うのは一度だけにしなければ
なりません。

`FieldStorage' のインスタンスは Python の辞書のようにインデクス
を使った参照ができ、標準の辞書に対するメソッド `has_key()' と `keys()'
をサポートしています。組み込みの関数 `len()'
もサポートされています。空の文字列を含むフォームのフィールドは
無視され、辞書上にはありません; そういった値を保持するには、
`FieldStorage' のインスタンスを生成する時にオプションの
KEEP_BLANK_VALUES キーワード引数を true に設定してください。

例えば、以下のコード (`Content-Type' ヘッダと空行は
すでに出力された後とします) は `name' および `addr'
フィールドが両方とも空の文字列に設定されていないか調べます:

     form = cgi.FieldStorage()
     if not (form.has_key("name") and form.has_key("addr")):
         print "<H1>Error</H1>"
         print "Please fill in the name and addr fields."
         return
     print "<p>name:", form["name"].value
     print "<p>addr:", form["addr"].value
     ...further form processing here...

ここで、`form[KEY]' で参照される各フィールドは それ自体が
`FieldStorage' (または `MiniFieldStorage'　。
フォームのエンコードによって変わります) のインスタンスです。
インスタンスの属性 `value' フィールドの文字列値になります。
`getvalue()' メソッドはこの文字列値を直接返します。 `getvalue()' は 2
つめの引数にオプションの値を与えることが
でき、リクエストされたキーが存在しない場合に返されるデフォルトの
値になります。

入力されたフォームデータに同じ名前のフィールドが二つ以上あれば、
`form[KEY]' で得られるオブジェクトは `FieldStorage' や
`MiniFieldStorage' のインスタンスではなく、それらインスタンスから
なるリストになります。同じく、この状況では、 `form.getvalue(KEY)'
は文字列を要素とするリストを返します。
もしこうした状況が起こりうると思われるなら (HTML
のフォームに同じ名前をもったフィールドが複数含まれているのなら) 、
組み込み関数 `getlist()' を使ってください。この関数は
常に値のリストを返します (従って、要素が単一の場合を特別扱い
しなくて済みます)。 例えば、以下のコードは任意の数のユーザ名フィールドを
結合し、コンマで分割された文字列にします:

     value = form.getlist("username", "")
     usernames = ",".join(value)

フィールドがアップロードされたファイルを表す場合、`value' 属性または
`getvalue()' メソッドを介してアクセスされた
値はファイルの内容を全て文字列としてメモリ上に読み込みます。
これは望ましくない機能かもしれません。アップロードされたファイルが
あるかどうかは `filename' 属性および `file' 属性の
いずれかで調べることができます。その後、以下のようにして `file'
属性から落ち着いてデータを読み出せます:

     fileitem = form["userfile"]
     if fileitem.file:
         # It's an uploaded file; count lines
         linecount = 0
         while 1:
             line = fileitem.file.readline()
             if not line: break
             linecount = linecount + 1

現在ドラフトとなっているファイルアップロードの標準仕様では、一つの
フィールドから (再帰的な `multipart/*' エンコーディングを 使うことで)
複数のファイルがアップロードされる可能性を受け入れています。
この場合、アイテムは辞書形式の `FieldStorage' アイテムと
なります。複数ファイルかどうかは `type' 属性が `multipart/form-data'
(または `multipart/*' に マッチする他の MIME 型)
になっているかどうか調べることで判別できます。
この場合、トップレベルのフォームオブジェクトと同様にして再帰的に
個別処理できます。

フォームが "古い" 形式で入力された場合 (クエリ文字列または
`application/x-www-form-urlencoded' データの単一の部分の場合)
アイテムは実際には `MiniFieldStorage' クラスのインスタンス
になります。この場合、`list' 、`file' 、および `filename' 属性は常に
`None' になります。


File: python-lib-jp.info,  Node: 高レベルインタフェース,  Next: 古いクラス群,  Prev: Using the cgi module,  Up: cgi

高レベルインタフェース
----------------------

_Added in Python version 2.2_ 前節では CGI フォームデータを
`FieldStorage' クラスを使って
読み出す方法について解説しました。この節では、フォームデータを
分かりやすく直感的な方法で読み出せるようにするために追加された、より
高レベルのインタフェースについて記述します。
このインタフェースは前節で記述された技術を撤廃するものでは ありません
-- 例えば、前節の技術は依然としてファイルのアップロードを
効率的に行う上で便利です。

このインタフェースは 2 つの単純なメソッドからなります。このメソッドを
使うことで、一般的な方法でフォームデータを処理でき、
一つのフィールド名に対して入力された値が一つなのかそれ以上なのか
を心配する必要がなくなります。

前節では、一つのフィールド名に対して二つ以上の値が入力される
かもしれない場合には、常に以下のようなコードを書くよう学びました:

     item = form.getvalue("item")
     if isinstance(item, list):
         # The user is requesting more than one item.
     else:
         # The user is requesting only one item.

こういった状況は、例えば以下のように、同じ名前を持った複数の
チェックボックスからなるグループがフォームに含まれているような場合に
よく起こります:

     <input type="checkbox" name="item" value="1" />
     <input type="checkbox" name="item" value="2" />

しかしながら、ほとんどの場合あるフォーム中で特定の名前を持った
コントロールはただ一つなので、その名前に関連付けられた値は
ただ一つしかないと期待され、かつ一つの値しか必要ありません。
そこで、スクリプトには例えば以下のようなコードを書くでしょう:

     user = form.getvalue("user").toupper()

このコードの問題点は、クライアント側がスクリプトに有効な入力
を提供すると期待できないところにあります。
例えば、もし好奇心旺盛なユーザがもう一つの `user=foo' ペア
をクエリ文字列に追加したら、`getvalue(``'user')' メソッドを
呼び出したときに文字列ではなくリストが返されるため、このスクリプトは
クラッシュするでしょう。 リストに対して `toupper()'
メソッドを呼び出すと、引数が 有効でない
(リスト型はその名前のメソッドを持っていない) ため、例外
`AttributeError' が送出されます。

従って、フォームデータの値を読む適切な方法は、得られた値が
単一の値なのか値のリストなのかを常に調べるコードを使うという
ものでした。これでは煩わしく、また、より読みにくいスクリプトに
なってしまいます。

より便利なアプローチは、ここで述べる高レベルのインタフェースが 提供する
`getfirst()' および `getlist()' メソッドを 使うことです。

`getfirst(name[, default])'
     フォームフィールド NAME に関連付けられた値をつねに一つだけ
     返す軽量メソッドです。このメソッドは同じ名前で 1 つ以上の値が
     ポストされた場合、最初の値だけを返します。フォームから値を受信する
     際の値が並べられる順番はブラウザ間で異なる可能性があり、特定の順番
     であるとは期待できないので注意してください。 (1)

     指定したフォームフィールドや値がない場合、このメソッドはオプションの引数
     DEFAULT を返します。このパラメタを指定しない場合、標準の 値は
     `None' に設定されます。

`getlist(name)'
     このメソッドはフォームフィールド NAME に関連付けられた値を
     常にリストで返します。NAME に指定したフォームフィールドや値が
     存在しない場合、このメソッドは空のリストを返します。値が一つだけ
     存在する場合、要素を一つだけ含むリストを返します。

これらのメソッドを使うことで、以下のようにナイスでコンパクトな
コードを書くことができます:

     import cgi
     form = cgi.FieldStorage()
     user = form.getfirst("user", "").toupper()    # This way it's safe.
     for item in form.getlist("item"):
         do_something(item)

---------- Footnotes ----------

(1) 最近のバージョンの HTML 仕様では、フィールドの値が提供される
順番を取り決めてはいますが、ある HTTP リクエストがその取り決めに
従ったブラウザから受信したのかどうか、そもそもブラウザから送信
されたのかどうかの判別は退屈で間違いやすいので注意してください。


File: python-lib-jp.info,  Node: 古いクラス群,  Next: Functions in cgi module,  Prev: 高レベルインタフェース,  Up: cgi

古いクラス群
------------

これらのクラスは、`cgi' モジュールの以前のバージョンに入って
おり、以前のバージョンとの互換性のために現在もサポートされています。
新しいアプリケーションでは `FieldStorage' クラスを使うべきです。

`SvFormContentDict' は単一の値しか持たないフォームデータの内容
を辞書として記憶します; このクラスでは、各フィールド名はフォーム中に
一度しか現れないと仮定しています。

`FormContentDict' は複数の値を持つフォームデータの内容
を辞書として記憶します (フォーム要素は値のリストです);
フォームが同じ名前を持ったフィールドを複数含む際に便利です。

他のクラス (`FormContent'、`InterpFormContentDict') は
非常に古いアプリケーションとの後方互換性のために存在します。
これらのクラスをいまだに使っていて、このモジュールの次のバージョンで
消えてしまったら非常に不便な場合は、作者まで連絡を下さい。


File: python-lib-jp.info,  Node: Functions in cgi module,  Next: セキュリティへの配慮,  Prev: 古いクラス群,  Up: cgi

関数
----

より細かくコントロールしたり、このモジュールで実装されている
アルゴリズムを他の状況で利用したい場合には、これらの関数が 便利です。

`parse(fp[, keep_blank_values[, strict_parsing]])'
     環境変数、またはファイルからからクエリを解釈します (ファイルは
     標準で `sys.stdin' になります) KEEP_BLANK_VALUES および
     STRICT_PARSING パラメタはそのまま `parse_qs()' に 渡されます。

`parse_qs(qs[, keep_blank_values[, strict_parsing]])'
     文字列引数として渡されたクエリ文字列
     (`application/x-www-form-urlencoded' 型のデータ) を
     解釈します。解釈されたデータは辞書として返されます。
     辞書のキーは一意なクエリ変数名で、値は各変数名に対する値からなる
     リストです。

     オプションの引数 KEEP_BLANK_VALUES は、 URL エンコード
     されたクエリ中で値の入っていないものを空文字列と見なすかどうか
     を示すフラグです。値が真であれば、値の入っていないフィールド
     は空文字列のままになります。標準では偽で、値の入っていない
     フィールドは無視され、そのフィールドはクエリに含まれていない
     ものとして扱われます。

     オプションの引数 STRICT_PASING はパース時のエラーをどう
     扱うかを決めるフラグです。値が偽なら (標準の設定です)、
     エラーは暗黙のうちに無視されます。値が真なら、ValueError 例外
     が送出されます。

     辞書等をクエリ文字列に変換する場合は``urllib'.
     urlencode()'関数を使用してください。

`parse_qsl(qs[, keep_blank_values[, strict_parsing]])'
     文字列引数として渡されたクエリ文字列
     (`application/x-www-form-urlencoded' 型のデータ) を
     解釈します。解釈されたデータは名前と値のペアからなるリストです。

     オプションの引数 KEEP_BLANK_VALUES は、 URL エンコード
     されたクエリ中で値の入っていないものを空文字列と見なすかどうか
     を示すフラグです。値が真であれば、値の入っていないフィールド
     は空文字列のままになります。標準では偽で、値の入っていない
     フィールドは無視され、そのフィールドはクエリに含まれていない
     ものとして扱われます。

     オプションの引数 STRICT_PASING はパース時のエラーをどう
     扱うかを決めるフラグです。値が偽なら (標準の設定です)、
     エラーは暗黙のうちに無視されます。値が真なら、ValueError 例外
     が送出されます。

     ペアのリストからクエリ文字列を生成する場合は、{`urllib'.urlencode()}
     関数を使用します。

`parse_multipart(fp, pdict)'
     (ファイル入力のための) `multipart/form-data' 型の入力を
     解釈します。引数は入力ファイルを示す FP と `Content-Type'
     ヘッダ内の他のパラメタを含む辞書 PDICT です。

     `parse_qs()' と同じく辞書を返し、キーはフィールド名で、
     対応する値は各フィールドの値によるリストです。この関数は簡単に
     使うことができますが、数メガバイトのデータがアップロードされる
     と考えられる場合にはあまり適していません -- その場合、
     より柔軟性のある `FieldStorage' を代りに使ってください。

     マルチパートデータがネストしている場合、各パートを解釈する
     ことはできないので注意してください -- 代りに `FieldStorage'
     を使ってください。

`parse_header(string)'
     (`Content-Type' のような) MIME ヘッダを解釈し、ヘッダの
     主要値と各パラメタからなる辞書にします。

`test()'
     メインプログラムから利用できる堅牢性テストを行う CGI
     スクリプトです。 最小の HTTP ヘッダと HTML
     フォームからスクリプトに提供された全ての
     情報を書式化して出力します。

`print_environ()'
     シェル変数を HTML に書式化して出力します。

`print_form(form)'
     フォームを HTML に初期化して出力します。

`print_directory()'
     現在のディレクトリを HTML に書式化して出力します。 Format the
     current directory in HTML.

`print_environ_usage()'
     意味のある (CGI の使う) 環境変数を HTML で出力します。

`escape(s[, quote])'
     文字列 S 中の文字 `&'、 `<'、 および `>' を HTML
     で正しく表示できる文字配列に変換します。 それらの文字が HTML
     に含まれるかもしれないようなテキストを出力
     する必要があるときに使ってください。 オプションの引数 QUOTE
     の値が真であれば、二重引用符文字 (`"') も変換されます;
     この機能は、例えば `<A HREF="...">' といったような HTML
     の属性値を出力に含めるのに
     役立ちます。クオートされる値が単引用符か二重引用符、またはその両方
     を含む可能性がある場合は、代りに `xml.sax.saxutils' の
     `quoteattr()' 関数の利用を検討してください。



File: python-lib-jp.info,  Node: セキュリティへの配慮,  Next: CGI スクリプトを UNIX システムにインストールする,  Prev: Functions in cgi module,  Up: cgi

セキュリティへの配慮
--------------------

重要なルールが一つあります: ( 関数 `os.system()' または `os.popen()'
、またはその他の同様の機能によって )
外部プログラムを呼び出すなら、クライアントから受信した任意の
文字列をシェルに渡していないことをよく確かめてください。
これはよく知られているセキュリティホールであり、これによって Web
のどこかにいる悪賢いハッカーが、だまされやすい CGI スクリプトに任意の
シェルコマンドを実行させることができてしまいます。URL の一部や
フィールド名でさえも信用してはいけません。CGI へのリクエストは
あなたの作ったフォームから送信されるとは限らないからです！

安全な方法をとるためには、フォームから入力された文字をシェルに
渡す場合、文字列が英数文字、ダッシュ、アンダースコア、および
ピリオドだけを含むことを確認してください。


File: python-lib-jp.info,  Node: CGI スクリプトを UNIX システムにインストールする,  Next: CGI スクリプトをテストする,  Prev: セキュリティへの配慮,  Up: cgi

CGI スクリプトを UNIX システムにインストールする
------------------------------------------------

あなたの使っている HTTP サーバのドキュメントを読んでください。そして
ローカルシステムの管理者と一緒にどのディレクトリに CGI スクリプト
をインストールすべきかを調べてください; 通常これはサーバのファイル
システムツリー内の `cgi-bin' ディレクトリです。

あなたのスクリプトが "others" によって読み取り可能および実行可能
であることを確認してください; UNIX ファイルモードは 8 進表記で `0755'
です (`chmod 0755 FILENAME' を使ってください)。 スクリプトの最初の行の
1 カラム目が、 `#!' で開始し、その後に Python
インタプリタへのパス名が続いていることを確認してください。 例えば:

     #!/usr/local/bin/python

Python インタプリタが存在し、"others" によって実行可能であることを
確かめてください。

あなたのスクリプトが読み書きする必要があるファイルが全て "others"
によってそれぞれ読み出し可能、書き込み可能である ことを確かめてください
-- それらのファイルモードは読み出し可能 については `0644'
で、書き込み可能については `0666'
になるはずです。これは、セキュリティ上の理由から、 HTTP サーバが
あなたのスクリプトを特権を全く持たないユーザ "nobody" の権限で
実行するからです。この権限下では、誰でもが読める (書ける、実行できる)
ファイルしか読む (書く、実行する) ことができません。
スクリプト実行時のディレクトリや環境変数のセットもあなたがログイン
したときの設定と異なります。特に、実行ファイルに対するシェルの 検索パス
(`PATH') や Python のモジュール検索パス
(`PYTHONPATH')が何らかの値に設定されていることを期待しては いけません。

モジュールを Python の標準設定におけるモジュール検索パス上にない
ディレクトリからロードする必要がある場合、他のモジュールを取り込む
前にスクリプト内で検索パスを変更できます。例えば:

     import sys
     sys.path.insert(0, "/usr/home/joe/lib/python")
     sys.path.insert(0, "/usr/local/lib/python")

(この方法では、最後に挿入されたディレクトリが最初に検索されます！)

非 UNIX システムにおける説明は変わるでしょう; あなたの使っている HTTP
サーバのドキュメントを調べてください (普通は CGI スクリプトに
関する節があります)。


File: python-lib-jp.info,  Node: CGI スクリプトをテストする,  Next: CGI スクリプトをデバッグする,  Prev: CGI スクリプトを UNIX システムにインストールする,  Up: cgi

CGI スクリプトをテストする
--------------------------

残念ながら、一般的に CGI スクリプトはコマンドラインから起動しよう
としても動かず、コマンドラインから起動した場合には完璧に動作する
スクリプトが、不思議なことにサーバからの起動では失敗することが
あります。しかし、スクリプトをコマンドラインから実行しなければ
ならない理由が一つあります: もしスクリプトが文法エラーを含んで
いれば、Python インタプリタはそのプログラムを全く実行しないため、 HTTP
サーバはほとんどの場合クライアントに謎めいたエラーを送信 するからです。

スクリプトが構文エラーを含まないのにうまく動作しないなら、次の
節に読み進むしかありません。


File: python-lib-jp.info,  Node: CGI スクリプトをデバッグする,  Next: よくある問題と解決法,  Prev: CGI スクリプトをテストする,  Up: cgi

CGI スクリプトをデバッグする
----------------------------

何よりもまず、些細なインストール関連のエラーでないか確認してください --
上の CGI スクリプトのインストールに関する節を注意深く読むことで、
大きく時間を節約できます。もしインストールの手続きを正しく理解
しているか不安なら、このモジュールのファイル (`cgi.py')
をコピーして、CGI スクリプトとしてインストールしてみてください。
このファイルはスクリプトとして呼び出すと、スクリプトの実行環境と
フォームの内容を HTML フォームに出力します。
正しいモードなどをフォームに与えて、リクエストを送ってみてください。
標準的な `cgi-bin' ディレクトリにインストールされていれば、
以下の形式でブラウザに URL を入力することで、リクエストを送信
できるはずです:

     http://yourhostname/cgi-bin/cgi.py?name=Joe+Blow&addr=At+Home

もしタイプ 404 のエラーになるなら、サーバはスクリプトを見つける
ことができていません - おそらくあなたはスクリプトを別のディレクトリ
に入れる必要があるでしょう。他のエラーになるなら、先に進む前に
解決しなければならないインストール上の問題があります。
もしうまく書式化された実行環境の情報とフォーム内容 (この例では、
各フィールドはフィールド名 "addr" に対して値 "At Home"、および
フィールド名 "name" に対して "Joe Blow" ) になるなら、 `cgi.py'
スクリプトは正しくインストールされています。
同じ操作をあなたの自作スクリプトに対して行えば、スクリプトをデバッグ
できるようになるはずです。 　 次のステップでは `cgi' モジュールの
`test()' 関数を 呼び出すことになります: メインプログラムコードを以下の
1 行、

     cgi.test()

と置き換えてください。この操作で `cgi.py' ファイル自体を
インストールした時と同じ結果を出力するはずです。

通常の Python スクリプトが unhandled exception 例外を送出する場合
(様々な理由: モジュール名のタイプミス、ファイルが開けなかった、など)、
Python インタプリタはナイスなトレースバックを出力して終了します。
Python インタプリタはあなたの CGI スクリプトが例外を送出した場合
にも同様にするので、大抵はトレースバックが HTTP サーバのいずれかの
ログファイルに残るか、あるいはまったく無視されます。

幸運なことに、あなたが自作のスクリプトで _何らかの_ コードを
実行できるようになったら、`cgitb' モジュールを使って
簡単にトレースバックをブラウザに送信できます。まだそうでないなら、
以下の一行:

     import cgitb; cgitb.enable()

をスクリプトの先頭に追加してください。そしてスクリプトを再度
走らせます; 問題が発生すれば、クラッシュの原因を見出せるような
詳細な報告を読めます。

`cgitb' モジュールのインポートに問題がありそうだと
思うなら、(組み込みモジュールだけを使った) もっと堅牢なアプローチを
取れます:

     import sys
     sys.stderr = sys.stdout
     print "Content-Type: text/plain"
     print
     ...your code here...

このコードは Python インタプリタがトレースバックを出力することに
依存しています。出力のコンテント型はプレーンテキストに設定されて
おり、全ての HTML 処理を無効にしています。スクリプトがうまく動作
する場合、生の HTML コードがクライアントに表示されます。スクリプト
が例外を送出する場合、最初の 2 行が出力された後、トレースバックが
表示されます。HTML の解釈は行われないので、トレースバックを
読めるはずです。


File: python-lib-jp.info,  Node: よくある問題と解決法,  Prev: CGI スクリプトをデバッグする,  Up: cgi

よくある問題と解決法
--------------------

   * ほとんどの HTTP サーバはスクリプトの実行が完了するまで CGI からの
     出力をバッファします。このことは、スクリプトの実行中にクライアントが
     進捗状況報告を表示できないことを意味します。

   * 上のインストールに関する説明を調べましょう。

   * HTTP サーバのログファイルを調べましょう。(別のウィンドウで `tail
     -f logfile' を実行すると便利かもしれません！)

   * 常に `python script.py' などとして、スクリプトが構文エラーで
     ないか調べましょう。

   * スクリプトに構文エラーがないなら、`import cgitb; cgitb.enable()'
     をスクリプトの先頭に追加してみましょう。

   * 外部プログラムを起動するときには、スクリプトがそのプログラムを
     見つけられるようにしましょう。これは通常、絶対パス名を使うことを
     意味します -- `PATH' は普通、あまり CGI スクリプトにとって
     便利でない値に設定されています。

   * 外部のファイルを読み書きする際には、CGI スクリプトを動作
     させるときに使われる userid でファイルを読み書きできるように
     なっているか確認しましょう: userid は通常、Web サーバを動作させて
     いる userid か、Web サーバの `suexec' 機能で明示的に指定 している
     userid になります。

   * CGI スクリプトを set-uid モードにしてはいけません。これはほとんど
     のシステムで動作せず、セキュリティ上の信頼性もありません。


File: python-lib-jp.info,  Node: cgitb,  Next: urllib,  Prev: cgi,  Up: インターネットプロトコルとその支援

CGI スクリプトのトレースバック管理機構
======================================

設定可能な、CGI スクリプトのトレースバック処理機構です。

_Added in Python version 2.2_

`cgitb' モジュールでは、Python スクリプトのための特殊な例外処理を
提供します。(実はこの説明は少し的外れです。このモジュールはもともと
徹底的なトレースバック情報を CGI スクリプトで生成した HTML 内に表示
するための設計されました。その後この情報を平文テキストでも
表示できるように一般化されています。)
このモジュールの有効化後に捕捉されない例外が生じた場合、
詳細で書式化された報告が Web ブラウザに送信されます。この報告には
各レベルにおけるソースコードの抜粋が示されたトレースバックと、現在動作
している関数の引数やローカルな変数が収められており、問題のデバッグを
助けます。オプションとして、この情報をブラウザに送信する代わりに
ファイルに保存することもできます。

この機能を有効化するためには、単に自作の CGI
スクリプトの最初に以下の一行を 追加します:

     import cgitb; cgitb.enable()

`enable()' 関数のオプションは、報告をブラウザに表示するか
どうかと、後で解析するためにファイルに報告をログ記録するかどうかを
制御します。

`enable([display[, logdir[, context [, format]]]])'
     この関数は、``sys'.excepthook' を設定することで、
     インタプリタの標準の例外処理を `cgitb' モジュールに肩代わり
     させるようにします。

     オプションの引数 DISPLAY は標準で `1' になっており、 この値は `0'
     にしてトレースバックをブラウザに送らないように抑制する
     こともできます。引数 LOGDIR はログファイルを配置する
     ディレクトリです。オプションの引数 CONTEXT は、トレースバック
     の中で現在の行の周辺の何行を表示するかです; この値は標準で `5'
     です。 オプションの引数 FORMAT が `"html"' の場合、出力は HTML
     に書式化されます。その他の値を指定すると平文テキストの出力を
     強制します。デフォルトの値は `"html"' です。

`handler([info])'
     この関数は標準の設定 (ブラウザに報告を表示しますがファイルには
     ログを書き込みません) を使って例外を処理します。
     この関数は、例外を捕捉した際に `cgitb' を使って報告
     したい場合に使うことができます。 オプションの INFO
     引数は、例外の型、例外の値、トレースバック オブジェクトからなる 3
     要素のタプルでなければなりません。これは ``sys'.exc_info()'
     によって返される値と全く 同じです。INFO
     引数が与えられていない場合、現在の 例外は ``sys'.exc_info()'
     から取得されます。

