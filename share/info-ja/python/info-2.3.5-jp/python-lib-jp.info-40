This is python-lib-jp.info, produced by makeinfo version 4.5 from
python-lib-jp.texi.

12 October 2005


File: python-lib-jp.info,  Node: aifc,  Next: sunau,  Prev: imageop,  Up: マルチメディアサービス

AIFFおよびAIFCファイルの読み書き
================================

AIFFあるいはAIFCフォーマットのオーディオファイルの読み書き

このモジュールはAIFFとAIFF-Cファイルの読み書きをサポートします。
AIFF（Audio Interchange File Format）はデジタルオーディオサンプルをファ
イルに保存するためのフォーマットです。
AIFF-CはAIFFの新しいバージョンで、オーディオデータの圧縮に対応していま
す。

*注意：*  操作のいくつかはIRIX上でのみ動作します；
そういう操作ではIRIXでのみ利用できる`cl'モジュールをインポート
しようとして、`ImportError'を発生します。

オーディオファイルには、オーディオデータについて記述したパラメータがたく
さん含まれています。
サンプリングレートあるいはフレームレートは、1秒あたりのオーディオサンプ
ル数です。
チャンネル数は、モノラル、ステレオ、4チャンネルかどうかを示します。
フレームはそれぞれ、チャンネルごとに一つのサンプルからなります。
サンプルサイズは、一つのサンプルの大きさをバイト数で示したものです。
したがって、一つのフレームはNCHANNELS*SAMPLESIZEバイト
からなり、1秒間ではNCHANNELS*SAMPLESIZE*FRAMERATE バイトで構成されます。

例えば、CD品質のオーディオは2バイト（16ビット）のサンプルサイズを
持っていて、2チャンネル（ステレオ）であり、44,100フレーム／秒のフレーム
レートを持っています。そのため、フレームサイズは4バイト（2*2）で、
1秒間では2*2*44100バイト（176,400バイト）になります。

`aifc'モジュールは以下の関数を定義しています：

`open(file[, mode])'
     AIFFあるいはAIFF-Cファイルを開き、後述するメソッドを持つインスタンスを返
     します。
     引数FILEはファイルを示す文字列か、ファイルオブジェクトのいずれかで
     す。 MODEは、読み込み用に開くときには`'r''か`'rb''のどちらか
     で、書き込み用に開くときには`'w''か`'wb''のどちらかでなければ
     なりません。
     もし省略されたら、`FILE.mode'が存在すればそれが使用され、なけ
     れば`'rb''が使われます。
     書き込み用にこのメソッドを使用するときには、これから全部でどれだけのサン
     プル数を書き込むのか分からなかったり、`writeframesraw()'と
     `setnframes()'を使わないなら、
     ファイルオブジェクトはシーク可能でなければなりません。

ファイルが`open()'によって読み込み用に開かれたときに返されるオ
ブジェクトには、以下のメソッドがあります：

`getnchannels()'
     オーディオチャンネル数（モノラルなら1、ステレオなら2）を返します。

`getsampwidth()'
     サンプルサイズをバイト数で返します。

`getframerate()'
     サンプリングレート（1秒あたりのオーディオフレーム数）を返します。

`getnframes()'
     ファイルの中のオーディオフレーム数を返します。

`getcomptype()'
     オーディオファイルで使用されている圧縮形式を示す4文字の文字列を返しま
     す。AIFFファイルでは`'NONE''が返されます。

`getcompname()'
     オーディオファイルの圧縮形式を人に判読可能な形にしたものを返します。
     AIFFファイルでは`'not compressed''が返されます。

`getparams()'
     以上の全ての値を上の順に並べたタプルを返します。

`getmarkers()'
     オーディオファイルのマーカーのリストを返します。
     一つのマーカーは三つの要素のタプルです。
     要素の1番目はマークID（整数）、2番目はマーク位置のフレーム数をデータの始
     めから数えた値（整数）、3番目はマークの名称（文字列）です。

`getmark(id)'
     与えられたIDのマークの要素を`getmarkers()'で述べたタプルで
     返します。

`readframes(nframes)'
     オーディオファイルの次のNFRAMES個のフレームを読み込んで返します。
     返されるデータは、全チャンネルの圧縮されていないサンプルをフレームごとに
     文字列にしたものです。

`rewind()'
     読み込むポインタをデータの始めに巻き戻します。
     次に`readframes()'を使用すると、データの始めから読み込みます。

`setpos(pos)'
     指定したフレーム数の位置にポインタを設定します。

`tell()'
     現在のポインタのフレーム位置を返します。

`close()'
     AIFFファイルを閉じます。
     このメソッドを呼び出したあとでは、オブジェクトはもう使用できません。

ファイルが`open()'によって書き込み用に開かれたときに返されるオ
ブジェクトには、`readframes()'と`setpos()'を除く上述の全て
のメソッドがあります。 さらに以下のメソッドが定義されています。
`get*()'メソッドは、対応する`set*()'を呼び出したあとでのみ
呼び出し可能です。
最初に`writeframes()'あるいは`writeframesraw()'を呼び出す
前に、フレーム数を除く全てのパラメータが設定されていなければなりません。

`aiff()'
     AIFFファイルを作ります。
     デフォルトではAIFF-Cファイルが作られますが、ファイル名が`'.aiff''で
     終わっていればAIFFファイルが作られます。

`aifc()'
     AIFF-Cファイルを作ります。
     デフォルトではAIFF-Cファイルが作られますが、ファイル名が`'.aiff''で
     終わっていればAIFFファイルが作られます。

`setnchannels(nchannels)'
     オーディオファイルのチャンネル数を設定します。

`setsampwidth(width)'
     オーディオのサンプルサイズをバイト数で設定します。

`setframerate(rate)'
     サンプリングレートを1秒あたりのフレーム数で設定します。

`setnframes(nframes)'
     オーディオファイルに書き込まれるフレーム数を設定します。
     もしこのパラメータが設定されていなかったり正しくなかったら、ファイルは
     シークに対応していなければなりません。

`setcomptype(type, name)'
     圧縮形式を設定します。
     もし設定しなければ、オーディオデータは圧縮されません。
     AIFFファイルは圧縮できません。
     変数nameは圧縮形式を人に判読可能にしたもので、変数typeは4文字の文字列で
     なければなりません。
     現在のところ、以下の圧縮形式がサポートされています： NONE, ULAW,
     ALAW, G722。

`setparams(nchannels, sampwidth, framerate, com ptype, compname)'
     上の全パラメータを一度に設定します。
     引数はそれぞれのパラメータからなるタプルです。
     つまり、`setparams()'の引数として、`getparams()'を呼び出し
     た結果を使うことができます。

`setmark(id, pos, name)'
     指定したID（1以上）、位置、名称でマークを加えます。
     このメソッドは、`close()'の前ならいつでも呼び出すことができます。

`tell()'
     出力ファイルの現在の書き込み位置を返します。
     `setmark()'との組み合わせで使うと便利です。

`writeframes(data)'
     出力ファイルにデータを書き込みます。
     このメソッドは、オーディオファイルのパラメータを設定したあとでのみ呼び出
     し可能です。

`writeframesraw(data)'
     オーディオファイルのヘッダ情報が更新されないことを除いて、
     `writeframes()'と同じです。

`close()'
     AIFFファイルを閉じます。
     ファイルのヘッダ情報は、オーディオデータの実際のサイズを反映して更新され
     ます。
     このメソッドを呼び出したあとでは、オブジェクトはもう使用できません。


File: python-lib-jp.info,  Node: sunau,  Next: wave,  Prev: aifc,  Up: マルチメディアサービス

Sun AUファイルの読み書き
========================

Sun AUサウンドフォーマットへのインターフェース

`sunau'モジュールは、Sun AUサウンドフォーマットへの便利なインター
フェースを提供します。このモジュールは、`aifc'モジュールや
`wave'モジュールと互換性のあるインターフェースを備えています。

オーディオファイルはヘッダとそれに続くデータから構成されます。
ヘッダのフィールドは以下の通りです：

フィールド                           内容
------                               -----
magic word                           4バイト文字列 `.snd'。
header size                          infoを含むヘッダのサイズをバイト数で示したもの。
data size                            データの物理サイズをバイト数で示したもの。
encoding                             オーディオサンプルのエンコード形式。
sample rate                          サンプリングレート。
# of channels                        サンプルのチャンネル数。
info                                 オーディオファイルについての説明をASCII文字列で示した
                                     もの（null バイトで埋められます）。

infoフィールド以外の全てのヘッダフィールドは4バイトの大きさです。
ヘッダフィールドはbig-endianでエンコードされた、計32ビットの符合なし整数
です。

`sunau'モジュールは以下の関数を定義しています：

`open(file, mode)'
     FILEが文字列ならその名前のファイルを開き、そうでないならファイル
     のようにシーク可能なオブジェクトとして扱います。MODEは以下のうち
     のいずれかです。

    ``'r'''
          読み込みのみのモード。

    ``'w'''
          書き込みのみのモード。

     読み込み／書き込み両方のモードで開くことはできない
     ことに注意して下さい。

     `'r''のMODEは`AU_read'オブジェクトを
     返し、`'w''と`'wb''のMODEは`AU_write'オブジェク トを返します。

`openfp(file, mode)'
     `open()'と同義。後方互換性のために残されています。

`sunau'モジュールは以下の例外を定義しています：

`Error'
     Sun
     AUの仕様や実装に対する不適切な操作により何か実行不可能となった時に発
     生するエラー。

`sunau'モジュールは以下のデータアイテムを定義しています：

`AUDIO_FILE_MAGIC'
     big-endianで保存された正規のSun
     AUファイルは全てこの整数で始まります。
     これは文字列`.snd'を整数に変換したものです。

`AUDIO_FILE_ENCODING_MULAW_8'

`AUDIO_FILE_ENCODING_LINEAR_8'

`AUDIO_FILE_ENCODING_LINEAR_16'

`AUDIO_FILE_ENCODING_LINEAR_24'

`AUDIO_FILE_ENCODING_LINEAR_32'

`AUDIO_FILE_ENCODING_ALAW_8'
     AUヘッダのencodingフィールドの値で、このモジュールでサポートしているもの
     です。

`AUDIO_FILE_ENCODING_FLOAT'

`AUDIO_FILE_ENCODING_DOUBLE'

`AUDIO_FILE_ENCODING_ADPCM_G721'

`AUDIO_FILE_ENCODING_ADPCM_G722'

`AUDIO_FILE_ENCODING_ADPCM_G723_3'

`AUDIO_FILE_ENCODING_ADPCM_G723_5'
     AUヘッダのencodingフィールドの値のうち既知のものとして追加されているもの
     ですが、このモジュールではサポートされていません。

* Menu:

* AU_read オブジェクト::
* AU_write オブジェクト::


File: python-lib-jp.info,  Node: AU_read オブジェクト,  Next: AU_write オブジェクト,  Prev: sunau,  Up: sunau

AU_read オブジェクト
--------------------

上述の`open()'によって返されるAU_readオブジェクトには、以下の
メソッドがあります：

`close()'
     ストリームを閉じ、このオブジェクトのインスタンスを使用できなくします。
     （これはオブジェクトのガベージコレクション時に自動的に呼び出されます。）

`getnchannels()'
     オーディオチャンネル数（モノラルなら`1'、ステレオなら`2'）を返
     します。

`getsampwidth()'
     サンプルサイズをバイト数で返します。

`getframerate()'
     サンプリングレートを返します。

`getnframes()'
     オーディオフレーム数を返します。

`getcomptype()'
     圧縮形式を返します。`'ULAW''、`'ALAW''、`'NONE''が
     サポートされている形式です。

`getcompname()'
     `getcomptype()'を人に判読可能な形にしたものです。
     上述の形式に対して、それぞれ`'CCITT G.711 u-law''、 `'CCITT G.711
     A-law''、`'not compressed''がサポートされて います。

`getparams()'
     `get*()'メソッドが返すのと同じ`(NCHANNELS,  SAMPWIDTH, FRAMERATE,
     NFRAMES, COMPTYPE, COMPNAME)'のタプルを返します。

`readframes(n)'
     N個のオーディオフレームの値を読み込んで、バイト
     ごとに文字に変換した文字列を返します。
     データはlinear形式で返されます。もし元のデータがu-LAW形式なら、変換され
     ます。

`rewind()'
     ファイルのポインタをオーディオストリームの先頭に戻します。

以下の2つのメソッドは共通の"位置"を定義しています。"位置"は他の関数
とは独立して実装されています。

`setpos(pos)'
     ファイルのポインタを指定した位置に設定します。
     `tell()'で返される値をPOSとして使用しなければなりません。

`tell()'
     ファイルの現在のポインタ位置を返します。
     返される値はファイルの実際の位置に対して何も操作はしません。

以下の2つのメソッドは`aifc'モジュールとの互換性のために定義さ
れていますが、何も面白いことはしません。

`getmarkers()'
     `None'を返します。

`getmark(id)'
     エラーを発生します。


File: python-lib-jp.info,  Node: AU_write オブジェクト,  Prev: AU_read オブジェクト,  Up: sunau

AU_write オブジェクト
---------------------

上述の`open()'によって返されるWave_writeオブジェクトには、
以下のメソッドがあります：

`setnchannels(n)'
     チャンネル数を設定します。

`setsampwidth(n)'
     サンプルサイズを（バイト数で）設定します。

`setframerate(n)'
     フレームレートを設定します。

`setnframes(n)'
     フレーム数を設定します。あとからフレームが書き込まれるとフレー
     ム数は変更されます。

`setcomptype(type, name)'
     圧縮形式とその記述を設定します。
     `'NONE''と`'ULAW''だけが、出力時にサポートされている形式です。

`setparams(tuple)'
     TUPLEは`(NCHANNELS, SAMPWIDTH, FRAMERATE, NFRAMES, COMPTYPE,
     COMPNAME)'
     で、それぞれ`set*()'のメソッドの値にふさわしいものでなければなり
     ません。全ての変数を設定します。

`tell()'
     ファイルの中の現在位置を返します。`AU_read.tell()'と
     `AU_read.setpos()'メソッドでお断りしたことがこのメソッドにも当
     てはまります。

`writeframesraw(data)'
     NFRAMESの修正なしにオーディオフレームを書き込みます。

`writeframes(data)'
     オーディオフレームを書き込んでNFRAMESを修正します。

`close()'
     NFRAMESが正しいか確認して、ファイルを閉じます。
     このメソッドはオブジェクトの削除時に呼び出されます。

`writeframes()'や`writeframesraw()'メソッドを呼び出したあ
とで、どんなパラメータを設定しようとしても不正となることに注意して下さ
い。


File: python-lib-jp.info,  Node: wave,  Next: chunk,  Prev: sunau,  Up: マルチメディアサービス

WAVファイルの読み書き
=====================

WAVサウンドフォーマットへのインターフェイス

`wave'モジュールは、WAVサウンドフォーマットへの便利なインター
フェイスを提供するモジュールです。

このモジュールは圧縮／展開をサポートしていませんが、モノラル／ステレオ
には対応しています。

`wave'モジュールは、以下の関数と例外を定義しています。

`open(file[, mode])'
     FILEが文字列ならその名前のファイルを開き、そうでないならファイル
     のようにシーク可能なオブジェクトとして扱います。MODEは以下のうち
     のいずれかです。

    ``'r'', `'rb'''
          　読み込みのみのモード。

    ``'w'', `'wb'''
          　書き込みのみのモード。

     WAVファイルに対して読み込み／書き込み両方のモードで開くことはできない
     ことに注意して下さい。
     `'r''と`'rb''のMODEは`Wave_read'オブジェクトを
     返し、`'w''と`'wb''のMODEは`Wave_write'オブジェク トを返します。
     MODEが省略されていて、ファイルのようなオブジェクトがFILEとし
     て渡されると、`FILE.mode'がMODEのデフォルト値として使わ
     れます（必要であれば、さらにフラグ`b'が付け加えられます）。

`openfp(file, mode)'
     `open()'と同義。後方互換性のために残されています。

`Error'
     WAVの仕様を犯したり、実装の欠陥に遭遇して何か実行不可能となった時に発生
     するエラー。

* Menu:

* Wave_read オブジェクト::
* Wave_write オブジェクト::


File: python-lib-jp.info,  Node: Wave_read オブジェクト,  Next: Wave_write オブジェクト,  Prev: wave,  Up: wave

Wave_read オブジェクト
----------------------

`open()'によって返されるWave_readオブジェクトには、以下のメソッ
ドがあります：

`close()'
     ストリームを閉じ、このオブジェクトのインスタンスを使用できなくします。
     これはオブジェクトのガベージコレクション時に自動的に呼び出されます。

`getnchannels()'
     オーディオチャンネル数（モノラルなら`1'、ステレオなら`2'）を返
     します。

`getsampwidth()'
     サンプルサイズをバイト数で返します。

`getframerate()'
     サンプリングレートを返します。

`getnframes()'
     オーディオフレーム数を返します。

`getcomptype()'
     圧縮形式を返します（`'NONE''だけがサポートされている形式です）。

`getcompname()'
     `getcomptype()'を人に判読可能な形にしたものです。
     通常、`'NONE''に対して`'not compressed''が返されます。


`getparams()'
     `get*()'メソッドが返すのと同じ`(NCHANNELS,  SAMPWIDTH, FRAMERATE,
     NFRAMES, COMPTYPE, COMPNAME)'のタプルを返します。

`readframes(n)'
     現在のポインタからN個のオーディオフレームの値を読み込んで、バイト
     ごとに文字に変換して文字列を返します。

`rewind()'
     ファイルのポインタをオーディオストリームの先頭に戻します。

以下の2つのメソッドは`aifc'モジュールとの互換性のために定義さ
れていますが、何も面白いことはしません。

`getmarkers()'
     `None'を返します。

`getmark(id)'
     エラーを発生します。

以下の2つのメソッドは共通の"位置"を定義しています。"位置"は他の関数
とは独立して実装されています。

`setpos(pos)'
     ファイルのポインタを指定した位置に設定します。

`tell()'
     ファイルの現在のポインタ位置を返します。


File: python-lib-jp.info,  Node: Wave_write オブジェクト,  Prev: Wave_read オブジェクト,  Up: wave

Wave_write オブジェクト
-----------------------

`open()'によって返されるWave_writeオブジェクトには、以下のメ
ソッドがあります：

`close()'
     NFRAMESが正しいか確認して、ファイルを閉じます。
     このメソッドはオブジェクトの削除時に呼び出されます。

`setnchannels(n)'
     チャンネル数を設定します。

`setsampwidth(n)'
     サンプルサイズをNバイトに設定します。

`setframerate(n)'
     サンプリングレートをNに設定します。

`setnframes(n)'
     フレーム数をNに設定します。あとからフレームが書き込まれるとフレー
     ム数は変更されます。

`setcomptype(type, name)'
     圧縮形式とその記述を設定します。

`setparams(tuple)'
     TUPLEは`(NCHANNELS, SAMPWIDTH, FRAMERATE, NFRAMES, COMPTYPE,
     COMPNAME)'
     で、それぞれ`set*()'のメソッドの値にふさわしいものでなければなり
     ません。全ての変数を設定します。

`tell()'
     ファイルの中の現在位置を返します。`Wave_read.tell()'と
     `Wave_read.setpos()'メソッドでお断りしたことがこのメソッドにも当
     てはまります。

`writeframesraw(data)'
     NFRAMESの修正なしにオーディオフレームを書き込みます。

`writeframes(data)'
     オーディオフレームを書き込んでNFRAMESを修正します。

`writeframes()'や`writeframesraw()'メソッドを呼び出したあ
とで、どんなパラメータを設定しようとしても不正となることに注意して下さ
い。そうすると`wave.Error'を発生します。


File: python-lib-jp.info,  Node: chunk,  Next: colorsys,  Prev: wave,  Up: マルチメディアサービス

IFFチャンクデータの読み込み
===========================

IFFチャンクデータの読み込み。

このモジュールはEA IFF 85チャンクを使用しているファイルの読み込みのため
のインターフェースを提供します。 (1) このフォーマットは少なくとも、Audio
Interchange File Format (AIFF/AIFF-C) とReal  Media File Format
(RMFF)で使われています。
WAVEオーディオファイルフォーマットも厳密に対応しているので、このモジュー
ルで読み込みできます。 チャンクは以下の構造を持っています：

Offset値                 長さ                     内容
------                   -----                    -----
0                        4                        チャンクID
4                        4                        big-endianで示したチャンクのサイズで、ヘッダは含みませ
                                                  ん
8                        N                        バイトデータで、Nはこれより先のフィールドのサイズ
8 + N                    0 or 1                   Nが奇数ならチャンクの整頓のために埋められるバイト

IDはチャンクの種類を識別する4バイトの文字列です。

サイズフィールド（big-endianでエンコードされた32ビット値）は、8バイトの
ヘッダを含まないチャンクデータのサイズを示します。

普通、IFFタイプのファイルは1個かそれ以上のチャンクからなります。
このモジュールで定義される`Chunk'クラスの使い方として提案している
のは、それぞれのチャンクの始めにインスタンスを作り、終わりに達するまでそ
のインスタンスから読み取り、その後で新しいインスタンスを作るということで
す。 ファイルの終わりで新しいインスタンスを作ろうとすると、
`EOFError'の例外が発生して失敗します。

`Chunk(file[, align, bigendian, inclheader])'
     チャンクを表現するクラス。
     引数FILEはファイルのようなオブジェクトであることが想定されていま
     す。 このクラスのインスタンスは特別にそのように認められています。
     必要とされるメソッドは`read()'だけです。
     もし`seek()'と`tell()'メソッドが呼び出されて例外を発生させ
     なかったら、これらのメソッドも動作します。
     これらのメソッドが呼び出されて例外を発生させても、オブジェクトを変化させ
     ないようになっています。

     省略可能な引数ALIGNがtrueなら、チャンクデータが偶数個で2バイトごと
     に整頓されていると想定します。
     もしALIGNがfalseなら、チャンクデータが奇数個になっていると想定しま
     す。 デフォルト値はtrueです。

     もし省略可能な引数BIGENDIANがfalseなら、チャンクサイズは
     little-endianであると想定します。
     この引数の設定はWAVEオーディオファイルで必要です。デフォルト値はtrueで
     す。

     もし省略可能な引数INCLHEADERがtrueなら、チャンクのヘッダから得られ
     るサイズはヘッダのサイズを含んでいると想定します。
     デフォルト値はfalseです。

`Chunk'オブジェクトには以下のメソッドが定義されています：

`getname()'
     チャンクの名前（ID）を返します。
     これはチャンクの始めの4バイトです。

`getsize()'
     チャンクのサイズを返します。

`close()'
     オブジェクトを閉じて、チャンクの終わりまで飛びます。
     これは元のファイル自体は閉じません。

残りの以下のメソッドは、`close()'メソッドを呼び出した後に呼び出す
と例外`IOError'を発生します。

`isatty()'
     `False'を返します。

`seek(pos[, whence])'
     チャンクの現在位置を設定します。
     引数WHENCEは省略可能で、デフォルト値は`0'（ファイルの絶対位
     置）です；他に`1'（現在位置から相対的にシークします）と`2'
     （ファイルの末尾から相対的にシークします）の値を取ります。
     何も値は返しません。
     もし元のファイルがシークに対応していなければ、前方へのシークのみが可能で
     す。

`tell()'
     チャンク内の現在位置を返します。

`read([size])'
     チャンクから最大でSIZEバイト（SIZEバイトを読み込むまで、少な
     くともチャンクの最後に行き着くまで）読み込みます。
     もし引数SIZEが負か省略されたら、チャンクの最後まで全てのデータを読
     み込みます。 バイト値は文字列のオブジェクトとして返されます。
     チャンクの最後に行き着いたら、空文字列を返します。

`skip()'
     チャンクの最後まで飛びます。
     さらにチャンクの`read()'を呼び出すと、`'''が返されます。
     もしチャンクの内容に興味がないなら、このメソッドを呼び出してファイルポイ
     ンタを次のチャンクの始めに設定します。

---------- Footnotes ----------

(1) "EA IFF 85" Standard for Interchange Format Files, Jerry Morrison,
Electronic Arts, January 1985.


File: python-lib-jp.info,  Node: colorsys,  Next: rgbimg,  Prev: chunk,  Up: マルチメディアサービス

色体系間の変換
==============

RGB 他の色体系間の変換。

`colorsys' モジュールは、計算機のディスプレイモニタで 使われている RGB
(Red Green Blue) 色空間で表された色と、他の 3 種類の色座標系: YIQ, HLS
(Hue Lightness Saturation: 色相、彩度、 飽和) および HSV (Hue
Saturation Value: 色相、彩度、明度) との
間の双方向の色値変換を定義します。
これらの色空間における色座標系は全て浮動小数点数で表されます。 YIQ
空間では、Y 軸は 0 から 1 ですが、 I および Q 軸は正の値も
負の値もとり得ます。他の色空間では、各軸は全て 0 から 1 の値を
とります。

色空間に関するより詳細な情報は <http://www.poynton.com/ColorFAQ.html>
にあります。

`colorsys' モジュールでは、以下の関数が定義されています:

`rgb_to_yiq(r, g, b)'
     RGB から YIQ に変換します。

`yiq_to_rgb(y, i, q)'
     YIQ から RGB に変換します。

`rgb_to_hls(r, g, b)'
     RGB から HLS に変換します。

`hls_to_rgb(h, l, s)'
     HLS から RGB に変換します。

`rgb_to_hsv(r, g, b)'
     RGB から HSV に変換します。

`hsv_to_rgb(h, s, v)'
     HSV から RGB に変換します。

サンプルコード:

     >>> import colorsys
     >>> colorsys.rgb_to_hsv(.3, .4, .2)
     (0.25, 0.5, 0.4)
     >>> colorsys.hsv_to_rgb(0.25, 0.5, 0.4)
     (0.3, 0.4, 0.2)


File: python-lib-jp.info,  Node: rgbimg,  Next: imghdr,  Prev: colorsys,  Up: マルチメディアサービス

"SGI RGB"ファイルを読み書きする
===============================

"SGI
RGB"フォーマットの画像ファイルを読み書きします(ですが、このモジュールはSGI特有のものでは_ありません_
!)。

`rgbimg'モジュールはPythonプログラムが(`.rgb'としても知られる)SGI
imglib画像ファイルにアクセスできるようにします。モジュールは完全にはほど遠いが、場合によっては寿分といえる機能を持っているためとにかく提供されています。現在、カラーマップファイルがサポートされていません。

_Note:_
このモジュールはデフォルトでは32ビットプラットホームでのみ構築されます。他のプラットホームで適切な動作をすることは期待できません。

モジュールは次の変数と関数を定義しています:

`error'
     例えば未サポートのファイル形式などのようなすべてのエラーに対してこの例外が発生します。

`sizeofimage(file)'
     この関数はタプル`(X,
     Y)'を返します。ここで、XとYは画素単位の画像の大きさです。4バイトRGBAピクセル、3バイトRGBピクセル、および、1バイトグレースケールピクセルが現在サポートされています。

`longimagedata(file)'
     この関数は特定ファイルの画像を読み込んでデコードし、Python文字列としてそれを返します。その文字列は4バイトRGBピクセルです。左下のピクセルが文字列の先頭です。例えば、このフォーマットは`gl.lrectwrite()'へ渡すために適しています。

`longstoimage(data, x, y, z, file)'
     この関数はDATAのRGBAデータを画像ファイルFILEへ書き込みます。XとYは画像の大きさを表します。セーブされた画像が1バイトのグレースケールの場合は、Zは1です。セーブされた画像が3バイトのRGBデータの場合は3です。セーブされた画像が4バイトのRGBA
     データの場合は4です。入力画像は常にピクセル当たり4バイト含んでいます。`gl.lrectread()'が返すフォーマットがあります。

`ttob(flag)'
     この関数はグローバルなフラグを設定します。そのフラグは画像のスキャン行が下から上に向かって読み込みや書き込みが行われるのか(フラグは0で、SGI
     GLと互換性があります)、あるいは上から下に向かって読み込みや書き込みがお壊れるのか(フラグは1で、Xと互換性があります)を定義します。デフォルトは、0です。


File: python-lib-jp.info,  Node: imghdr,  Next: sndhdr,  Prev: rgbimg,  Up: マルチメディアサービス

画像の形式を決定する
====================

ファイルやバイトストリームに含まれる画像の形式を決定する。

`imghdr'モジュールはファイルやバイトストリームに含まれる画像の形式を決定します。

`imghdr'モジュールは次の関数を定義しています:

`what(filename[, h])'
     FILENAMEという名前のファイル内の画像データをテストし、画像形式を表す文字列を返します。オプションのHが与えられた場合は、FILENAMEは無視され、テストするバイトストリームを含んでいるとHは仮定されます。

以下に`what()'からの戻り値とともにリストするように、次の画像形式が認識されます:

Value                                Image format
------                               -----
'rgb'                                SGI ImgLib Files
'gif'                                GIF 87a and 89a Files
'pbm'                                Portable Bitmap Files
'pgm'                                Portable Graymap Files
'ppm'                                Portable Pixmap Files
'tiff'                               TIFF Files
'rast'                               Sun Raster Files
'xbm'                                X Bitmap Files
'jpeg'                               JPEG data in JFIF format
'bmp'                                BMP files
'png'                                Portable Network Graphics

この変数に追加することで、あなたは`imghdr'が認識できるファイル形式のリストを拡張できます:

`tests'
     個別のテストを行う関数のリスト。それぞれの関数は二つの引数をとります:
     バイトストリームとオープンされたファイルのようにふるまうオブジェクト。`what()'がバイトストリームとともに呼び出されたときは、ファイルのようにふるまうオブジェクトは`None'でしょう。

     テストが成功した場合は、テスト関数は画像形式を表す文字列を返すべきです。あるいは、失敗した場合は`None'を返すべきです。

例:

     >>> import imghdr
     >>> imghdr.what('/tmp/bass.gif')
     'gif'


File: python-lib-jp.info,  Node: sndhdr,  Next: ossaudiodev,  Prev: imghdr,  Up: マルチメディアサービス

サウンドファイルの識別
======================

サウンドファイルの識別

`sndhdr'モジュールには、ファイルに保存されたサウンドデータの形式
を識別するのに便利な関数が定義されています。
どんな形式のサウンドデータがファイルに保存されているのか識別可能な場合、
これらの関数は`(TYPE、SAMPLING_RATE、
CHANNELS、FRAMES、BITS_PER_SAMPLE)'のタプルを返しま す。
TYPEはデータの形式を示す文字列で、`'aifc''、`'aiff''、
`'au''、`'hcom''、`'sndr''、`'sndt''、`'voc''、
`'wav''、`'8svx''、`'sb''、`'ub''、`'ul''のうち の一つです。
SAMPLING_RATEは実際のサンプリングレート値で、未知の場合や読
み取ることが出来なかった場合は`0'です。
同様に、CHANNELSはチャンネル数で、識別できない場合や読
み取ることが出来なかった場合は`0'です。FRAMESはフレーム数で、識別できない場合は
`-1'です。
タプルの最後の要素BITS_PER_SAMPLEはサンプルサイズを示すビット数
ですが、A-LAW なら`'A''、u-LAW なら `'U''です。

`what(filename)'
     `whathdr()'を使って、ファイルFILENAMEに保存されたサウン
     ドデータの形式を識別します。
     識別可能なら上記のタプルを返し、識別できない場合は`None'を返します
     。

`whathdr(filename)'
     ファイルのヘッダ情報をもとに、保存されたサウンドデータの形式を識別し
     ます。 ファイル名はFILENAMEで渡されます。
     識別可能なら上記のタプルを返し、識別できない場合は`None'を
     返します。


File: python-lib-jp.info,  Node: ossaudiodev,  Prev: sndhdr,  Up: マルチメディアサービス

OSS互換オーディオデバイスへのアクセス
=====================================

OSS互換オーディオデバイスへのアクセス。

_Added in Python version 2.3_

このモジュールを使うとOSS (Open Sound System) オーディオインターフェース
にアクセスできます。
OSSはオープンソースあるいは商用のUnixで広く利用可能で、Linux (カーネル
2.4まで) とFreeBSDで標準のオーディオインターフェースとなっています。

See also:
     ` オープンサウンドシステムプログラマーズガイド' { OSS C
     APIのための公式ドキュメント}
     このモジュールではOSSデバイスドライバーで提供される多くの定数を定義して
     います;定数のリストについてはLinuxかFreeBSDの`<sys/soundcard.h>'を
     参照してください。

`ossaudiodev'には以下の変数と関数が定義されています:

`error'
     この例外は特定のエラーを発生します。
     引数は何が誤っているかを示す文字列です。

     (もし`ossaudiodev'が`open()'、`write()'、
     `ioctl()'などのシステムコールからエラーを受け取ったら
     `IOError'を発生します。
     `ossaudiodev'モジュールによって直接検出されたエラーは
     `ossaudiodev.error'になります。)

`open([device, ]mode)'
     オーディオデバイスを開いて、OSSオーディオデバイスオブジェクトを返しま
     す。 このオブジェクトは`read()'、`write()'、`fileno()'
     などのようにファイルのような多くのメソッドをサポートしています。
     (しかし伝統的なUnixのread/writeの構文とOSSオーディオデバイスのものとの
     あいだには微妙な違いがあります) 。
     また、オーディオ特有の多くのメソッドがあります;メソッドの完全なリストに
     ついては下記を参照してください。

     呼び出しの文法が普通と異なることに注意してください:_最初の_引数が
     省略可能で、2番目が必須です。
     これは`ossaudiodev'にとって替わられた古い`linuxaudiodev'と
     の互換性のためという歴史的な産物です。

     DEVICEは使用するオーディオデバイスファイルネームです。
     もしこれが指定されないなら、このモジュールは使うデバイスとして最初に環境
     変数`AUDIODEV'を参照します。
     みつからなければ、`/dev/dsp'を参照します。

     MODEは、読み込みのみ (再生) のアクセスの`'r''、書き込みのみ (
     録音) のアクセスの`'w''、それら両方の`'rw''のうちのどれか1つで す。
     多くのサウンドカードでは一つのプロセスで同時にレコーダかプレーヤしか持て
     ないので、操作が必要なときだけデバイスを開くのが良い考えです。
     また、いくつかのサウンドカードは半二重 (half-duplex) です:
     これらでは読み込みあるいは書き込みで開けますが、同時に両方では開けませ
     ん。

`openmixer([device])'
     ミキサーデバイスを開いて、OSSミキサーデバイスオブジェクトを返します。
     DEVICEは使用するミキサーデバイスのファイルネームです。
     もしこれが指定されないなら、このモジュールは使うデバイスとして最初に環境
     変数`AUDIODEV'を参照します。
     みつからなければ、`/dev/mixer'を参照します。

* Menu:

* オーディオデバイスオブジェクト::
* ミキサーデバイスオブジェクト::


File: python-lib-jp.info,  Node: オーディオデバイスオブジェクト,  Next: ミキサーデバイスオブジェクト,  Prev: ossaudiodev,  Up: ossaudiodev

オーディオデバイスオブジェクト
------------------------------

デバイスの設定

デバイスを設定するために、3つの関数を正しい順序で呼び出さなければなりま
せん。
  1. `setfmt()'で出力フォーマットを設定し、

  2. `channels()'でチャンネル数を設定し、

  3. `speed()'でサンプリングレートを設定します。

`open()'で返されるオーディオデバイスオブジェクトには以下のメ
ソッドがあります:

`close()'
     このメソッドはデバイスを明示的に閉じます。
     他にデバイスを参照しているものがあって、オブジェクトをすぐに閉じることが
     できない場合に便利です。
     閉じられたオブジェクトを再び使うことはできません。

`fileno()'
     デバイスに関連付けられたファイルディスクリプタを返します。

`read(size)'
     オーディオ入力からサンプル数SIZEを読み込んで、Python文字列として返
     します。 この関数は必要なデータが得られるまでブロックします。

`write(data)'
     Python文字列のDATAをオーディオデバイスに書き込んで、書き込まれたバ
     イト数を返します。
     もしオーディオデバイスがブロックモードで開かれたら、文字列全体が書き込ま
     れます。
     もしデバイスが非ブロックモードで開かれたら、書き込まれないデータがあるか
     もしれません--`writeall()'を参照してください。

`writeall(data)'
     Python文字列のDATA全体をオーディオデバイスに書き込みます。
     もしデバイスがブロックモードで開かれたら`write()'と同様に働きま
     す;非ブロックモードでは、デバイスにデータを与える前にデバイスが利用可能
     になるまで待ちます。
     書き込まれたデータの量は与えたデータと常に同じ量なので、`None'を返
     します。

シンプルなI/Oコントロール:

`nonblock()'
     デバイスを非ブロックモードにします。
     いったん非ブロックモードにしたら、ブロックモードに戻すことはできません。

     I/Oコントロールに失敗したら`IOError'が発生します。

`getfmts()'
     サウンドカードでサポートされるオーディオ出力フォーマットのビットマスクを
     返します。 典型的なLinuxシステムでは以下のフォーマットがあります:

     フォーマット                       説明
     ------                             -----
     AFMT_MU_LAW                        対数エンコーディング。
                                        これは`/dev/audio'のデフォルトのフォーマットで、Sunの.auファイルで
                                        使われているフォーマットです。
     AFMT_A_LAW                         対数エンコーディング
     AFMT_IMA_ADPCM                     Interactive Multimedia
                                        Association
                                        で定められた4:1の圧縮フォーマット。
     AFMT_U8                            符号なし8ビットオーディオ。
     AFMT_S16_LE                        符号なし16ビットオーディオでリトルエンディアン
                                        (Intelプロセッサで使われ
                                        るフォーマット)
     AFMT_S16_BE                        符号なし16ビットオーディオでビッグエンディアン
                                        (68k、PowerPC、Sparcで使
                                        われるフォーマット)
     AFMT_S8                            符号つき8ビットオーディオ。
     AFMT_U16_LE                        符号つき16ビットリトルエンディアンオーディオ
     AFMT_U16_BE                        符号つき16ビットビッグエンディアンオーディオ

     たいていのシステムではこれらのフォーマットのうちのいくつかだけをサポート
     しています。
     多くのデバイスでは`AFMT_U8'だけをサポートしています;現在使われ
     ている最も一般的なフォーマットは`AFMT_S16_LE'です。

`setfmt(format)'
     現在のオーディオフォーマットをFORMATにします--
     FORMATについては`getfmts()'のリストを参照してください。
     また、現在のオーディオフォーマットを返すのにも使えます--
     これは"オーディオフォーマット"として`AFMT_QUERY'を渡すことで
     できます。
     デバイスに設定されたオーディオフォーマットが返されますが、設定するよう要
     求したフォーマットではないかもしれません。

`channels(num_channels)'
     出力チャンネル数をNUM_CHANNELSに設定します。
     値1はモノラル、2はステレオを示します。
     いくつかのデバイスでは2つより多いチャンネルを持つものもありますし、
     ハイエンドなデバイスではモノラルをサポートしないものもあります。
     デバイスに設定されたチャンネル数を返します。

`speed(samplerate)'
     サンプリングレートを1秒あたりSAMPLERATEに設定し、実際に設定された
     レートを返します。
     たいていのサウンドデバイスでは任意のサンプリングレートをサポートしていま
     せん。 一般的なレートは以下の通りです:

     8000--デフォルトのレート 11025--声の録音 22050
     44100--オーディオCD品質 (2チャンネルで16ビット/サンプル)
     96000--DVD品質

`sync()'
     サウンドデバイスがバッファ内の全てのバイトを再生するまで待って、それから
     制御が戻ります。
     これはサウンドデバイスが閉じられるときにも起こります。
     OSSの文書では`sync()'を使うよりもデバイスを単純に閉じて、再び開く
     ことを推奨しています。

`reset()'
     再生あるいは録音を中止して、デバイスをコマンド待ちの状態にします。
     OSSの文書では`reset()'を呼び出した後にデバイスを閉じて、再び開く
     ことを推奨しています。

`post()'
     簡単な`sync()'のように使われます。`post()'のI/Oコントロー
     ルによってオーディオデバイスにオーディオ出力にポーズがある--つまり、短
     いサウンドエフェクトの後や、ユーザの入力待ちの前、あるいはディスクI/Oの
     前であることを伝えます。

便利なメソッド

`setparameters(samplerate,num_channels,format,emulate)'
     サウンドデバイスを一つのメソッドで初期化します。
     SAMPLERATE、CHANNELS、FORMATは
     `speed()'、`channels()'、`setfmt()'で述べたものでな
     ければなりません。
     もしEMULATEがTrueなら、もっともマッチするフォーマットを見つけよう
     としますが、そうでないなら、指定したフォーマットをデバイスがサポートしな
     ければValueErrorを発生します。
     デフォルトではサポートしないフォーマットに対してValueErrorを発生します。

`bufsize()'
     ハードウェアのバッファサイズをサンプル数で返します。

`obufcount()'
     ハードウェアバッファにある、再生されるサンプル数を返します。

`obuffree()'
     ブロックすることなしにハードウェアのキューに書き込んで再生できるサンプル
     数を返します。


File: python-lib-jp.info,  Node: ミキサーデバイスオブジェクト,  Prev: オーディオデバイスオブジェクト,  Up: ossaudiodev

ミキサーデバイスオブジェクト
----------------------------

ミキサーオブジェクトは、2つのファイル風メソッドを提供します。

`close()'
     このメソッドは、開かれたミキサーデバイスファイルを閉じます。
     ファイルを閉じた後でミキサーを使おうとすると、IOErrorを発生します。

`fileno()'
     開いたミキサーデバイスファイルのファイルハンドルナンバーを返します。

以下はオーディオミキシング固有のメソッドです。

`controls()'
     このメソッドは、利用可能なミキサーコントロールを指定するビットマスクを返
     します
     ("コントロール"はミックス可能な特定の"チャンネル"で、たとえば
     `SOUND_MIXER_PCM'あるいは`SOUND_MIXER_SYNTH'です) 。
     このビットマスクは全ての利用可能なミキサーコントロールのサブセットを示しま
     す --定数`SOUND_MIXER_*'はモジュールレベルで定義されています。
     例えば、もし現在のミキサーオブジェクトがPCMミキサーをサポートしているか
     調べるには、以下のPythonコードを実行します:

          if mixer.controls() & (1 << ossaudiodev.SOUND_MIXER_PCM):
              # PCM is supported
              ... code ...

     たいていの目的では、`SOUND_MIXER_VOLUME' (マスターボリューム)
     と`SOUND_MIXER_PCM'コントロールで十分です--
     しかし、サウンドコントロールを選ぶときに、ミキサーを使用するコードはフレキ
     シブルでなければなりません。 例えば、Gravis
     Ultrasoundでは`SOUND_MIXER_VOLUME'は存在しませ ん。

`stereocontrols()'
     ステレオミキサーコントロールを示すビットマスクを返します。
     もしビットがセットされていたら対応するコントロールはステレオで、もしセット
     されていないならそのコントロールはモノラルか、ミキサーでサポートされていな
     いかどちらかです (そのどちらかを調べるには`controls()'を組み合わ
     せて使います) 。

     ビットマスクのデータを得る例としては、関数`controls()'のコードの
     例を参照してください。

`reccontrols()'
     録音に使用できるミキサーコントロールを特定するビットマスクを返します。
     ビットマスクから読み取る例としては、`controls()'のコードの例を参
     照してください。

`get(control)'
     与えられたミキサーコントロールのボリュームを返します。
     返される値は2要素のタプル`(left_volume,right_volume)'です。
     ボリュームの値は0 (無音) から100 (最大) で示されます。
     もしコントロールがモノラルでも2要素のタプルが返されますが、2つの要素の値は
     同じになります。

     不正なコントロールを指定した場合は`OSSAudioError'が発生しま
     す。また、サポートされていないコントロールを指定した場合には
     `IOError'が発生します。

`set(control, (left, right))'
     与えられたミキサーコントロールのボリュームを`(left,right)'に設定しま
     す。 `left'と`right'は整数で、0 (無音) から100 (最大) の間でなけれ
     ばなりません。
     成功したら、新しいボリューム値が2要素のタプルで返されます。
     あるサウンドカードではミキサーの分解能の限界のため、指定したボリューム値
     と厳密には同じにならないかもしれません。

     不正なコントロールを指定するか、指定したボリューム値が範囲外なら
     `OSSAudioError'が発生します。

`get_recsrc()'
     このメソッドは、現在録音のソースとして使われているコントロールを示すビット
     マスクを返します。

`set_recsrc(bitmask)'
     録音のソースを指定するのにこの関数を使います。
     成功したら、新たな録音のソースを示すビットマスクを返します;
     不正なソースが指定されたら`IOError'が発生します。
     現在の録音のソースとしてマイク入力を設定する方法は以下の通りです:

          mixer.setrecsrc (1 << ossaudiodev.SOUND_MIXER_MIC)



File: python-lib-jp.info,  Node: 暗号関連のサービス,  Next: Tkを用いたグラフィカルユーザインターフェイス,  Prev: マルチメディアサービス,  Up: Top

暗号関連のサービス
******************

この章で記述されているモジュールでは、暗号の本質に関わる様々な
アルゴリズムを実装しています。これらは必要に応じてインストール
することで使えます。概要を以下に示します:

あなたがハードコアなサイバーパンクなら、さらに A.M. Kuchling
の書いた暗号化モジュールに興味を持つかもしれません。このパッケージ
では組み込みの DES および IDEA 暗号を追加し、PGP 暗号化されたファイル
の読み込みや復号化を行うためのモジュールなどを提供します。
これらのモジュールは Python と一緒には配布されず、別に入手できます。
詳細は <http://www.amk.ca/python/code/crypto.html> を見てください。

* Menu:

* hmac::
* md5::
* sha::
* mpz::
* rotor::


File: python-lib-jp.info,  Node: hmac,  Next: md5,  Prev: 暗号関連のサービス,  Up: 暗号関連のサービス

メッセージ認証のための鍵付きハッシュ化
======================================

Python で実装された、メッセージ認証のための鍵付き ハッシュ化 (HMAC:
Keyed-Hashing for Message Authentication) アルゴリズム。

_Added in Python version 2.2_

このモジュールでは RFC 2104 で記述されている HMAC アルゴリズム
を実装しています。

`new(key[, msg[, digestmod]])'
     新たな hmac オブジェクトを返します。MSG が存在すれば、
     メソッド呼び出し `updateMSG' を行います。 DIGESTMOD は HMAC
     オブジェクトが使うダイジェストモジュール です。標準では `md5'
     モジュールになっています。

HMAC オブジェクトは以下のメソッドを持っています:

`update(msg)'
     hmac オブジェクトを文字列 MSG で更新します。繰り返し呼び出し
     を行うと、それらの引数を全て結合した引数で単一の呼び出しをした
     際と同じに等価になります: すなわち `m.update(a); m.update(b)' は
     `m.update(a + b)' と等価です。

`digest()'
     これまで `update()' メソッドに渡された文字列のダイジェスト値
     を返します。個の値は 16 バイトの文字列 (`md5' の場合) か、 20
     バイトの文字列 (`sha' の場合) で、NULL バイトを含む 非 ASCII
     文字が含まれることがあります。

`hexdigest()'
     `digest()' と似ていますが、ダイジェスト値が `md5' のときで長さ 32
     文字 (`sha' のときで 40文字) の 16進数字
     のみを含む文字列で返されます。この値は電子メールやその他の非バイナリ
     環境で値をやり取りする際に使うことができます。

`copy()'
     hmac オブジェクトの ("クローン" の)　コピーを返します。このコピー
     は最初の部分文字列が共通になっている文字列のダイジェスト値を効率
     よく計算するために使うことができます。


File: python-lib-jp.info,  Node: md5,  Next: sha,  Prev: hmac,  Up: 暗号関連のサービス

MD5 メッセージダイジェストアルゴリズム
======================================

RSA's MD5 message digest algorithm.

このモジュールは RSA 社の MD5 メッセージダイジェスト
アルゴリズムへのインタフェースを実装しています。 (Internet RFC 1321
も参照してください)。利用方法は極めて単純 です。まず md5 オブジェクトを
`new()' を使って生成します。 後は `update()'
メソッドを使って、生成されたオブジェクトに
任意の文字列データを入力します。オブジェクトに入力された文字列
データ全体の "digest" ("fingerprint" として知られる強力な 128-bit
チェックサム) は `digest()' を使っていつでも調べる ことができます。

例えば、文字列 `'Nobody inspects the spammish repetition''
のダイジェストを得るためには以下のようにします:

     >>> import md5
     >>> m = md5.new()
     >>> m.update("Nobody inspects")
     >>> m.update(" the spammish repetition")
     >>> m.digest()
     '\xbbd\x9c\x83\xdd\x1e\xa5\xc9\xd9\xde\xc9\xa1\x8d\xf0\xff\xe9'

もっと詰めて書くと以下のようになります:

     >>> md5.new("Nobody inspects the spammish repetition").digest()
     '\xbbd\x9c\x83\xdd\x1e\xa5\xc9\xd9\xde\xc9\xa1\x8d\xf0\xff\xe9'

以下の値はモジュールの中で定数として与えられており、`new()' で返される
md5 オブジェクトの属性としても与えられます:

`digest_size'
     返されるダイジェスト値のバイト数で表した長さ。常に `16' です。

md5 クラスオブジェクトは以下のメソッドをサポートします:

`new([arg])'
     新たな md5 オブジェクトを返します。もし ARG が存在するなら、
     `update(ARG)' を呼び出します。

`md5([arg])'
     下位互換性のために、`new()' の別名として提供されています。

md5 オブジェクトは以下のメソッドをサポートします:

`update(arg)'
     文字列 ARG を入力として md5 オブジェクトを更新します。
     このメソッドを繰り返して呼び出す操作は、それぞれの呼び出し時の引数
     ARG を結合したデータを引数として一回の呼び出す操作と同等
     になります: つまり、`m.update(a); m.update(b)' は `m.update(a+b)'
     と同等です。

`digest()'
     これまで `update()' で与えてきた文字列入力のダイジェストを
     返します。返り値は 16 バイトの文字列で、null バイトを含む非 ASCII
     文字が入っているかもしれません。

`hexdigest()'
     `digest()' に似ていますが、ダイジェストは長さ 32 の文字列
     になり、16 進表記文字しか含みません。この文字列は電子メールやその
     他のバイナリを受け付けない環境でダイジェストを安全にやりとりする
     ために使うことができます。

`copy()'
     md5 オブジェクトのコピー ("クローン")
     を返します。冒頭の部分文字列が
     共通な複数の文字列のダイジェストを効率よく計算する際に使うことができます。

See also:
     *Note sha:: Secure Hash Algorithm (SHA)
     を実装した類似のモジュール。 SHA
     アルゴリズムはより安全なハッシュアルゴリズムだと考えられています。


File: python-lib-jp.info,  Node: sha,  Next: mpz,  Prev: md5,  Up: 暗号関連のサービス

SHA-1 メッセージダイジェストアルゴリズム
========================================

NISTのセキュアハッシュアルゴリズム、SHA。

このモジュールは、 SHA-1 として知られている、 NISTの
セキュアハッシュアルゴリズムへのインターフェースを
実装しています。SHA-1 はオリジナルの SHA ハッシュアルゴリズムを改善した
バージョンです。`md5' モジュールと同じように使用します。: sha
オブジェクトを生成するために `new()' を使い、 `update()'
メソッドを使って、このオブジェクトに任意の文字列を入力し、
それまでに入力した文字列全体の "digest" をいつでも調べることができます。
SHA-1 のダイジェストは MD5 の 128 bit とは異なり、 160 bit です。

`new([string])'
     新たな sha オブジェクトを返します。もし STRING
     が存在するなら、`update(STRING)' を呼び出します。

以下の値はモジュールの中で定数として与えられており、`new()' で返される
sha オブジェクトの属性としても与えられます:

`blocksize'
     ハッシュ関数に入力されるブロックのサイズ。 このサイズは常に `1'
     です。
     このサイズは、任意の文字列をハッシュできるようにするために使われます。

`digest_size'
     返されるダイジェスト値をバイト数で表した長さ。常に 20 です。

sha オブジェクトには md5 オブジェクトと同じメソッドがあります。

`update(arg)'
     文字列 ARG を入力として sha オブジェクトを更新します。
     このメソッドを繰り返し呼び出す(操作は、それぞれの呼び出し時の引数を結合した
     データを引数として一回の呼び出す操作と同等になります。つまり、
     `m.update(a); m.update(b)' は `m.update(a+b)' と同等です。

`digest()'
     これまで update() メソッド
     で与えてきた文字列のダイジェストを返します。 戻り値は 20
     バイトの文字列で、nullバイトを含む非 ASCII 文字が入っているか
     もしれません。

`hexdigest()'
     `digits()'
     と似ていますが、ダイジェストは長さ40の文字列になり、16進表記数字しか含みません。
     電子メールやその他のバイナリを受け付けない環境で安全に値をやりとりするために使うことができます。

`copy()'
     sha オブジェクトのコピー("クローン")を返します。
     冒頭の部分文字列が共通な複数の文字列のダイジェストを効率よく計算する際に使う
     ことができます。

See also:
     `セキュアハッシュスタンダード' {セキュアハッシュアルゴリズムは
     NIST のドキュメント FIPS PUB 180-1 で定義されています。 ,
     1995年4月出版。
     プレインテキスト(少なくとも一つの図が省略されています)と
     <http://csrc.nist.gov/publications/fips/fips180-1/fip180-1.pdf>にある
     PDF でオンラインから入手できます。}

     `暗号ツールキット (セキュアハッシュ)'
     {NISTからはられているセキュアハッシュに関するさまざまな情報へのリンク}

