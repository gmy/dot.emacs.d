This is python-lib-jp.info, produced by makeinfo version 4.5 from
python-lib-jp.texi.

12 October 2005


File: python-lib-jp.info,  Node: ハイアラキカルリストボックス,  Next: タビュラーリストボックス,  Prev: ファイルセレクタ,  Up: Tixウィジェット

ハイアラキカルリストボックス
............................

`HList()'
     HListウィジェットは階層構造をもつどんなデータ(例えば、ファイルシステムディレクトリツリー)でも表示するために使用できます。リストエントリは字下げされ、階層のそれぞれの場所に応じて分岐線で接続されます。

`CheckList()'
     CheckListウィジェットは、ユーザが選ぶ項目のリストを表示します。CheckListはTkのチェックリストやラジオボタンより多くの項目を扱うことができることを除いて、チェックボタンあるいはラジオボタンウィジェットと同じように動作します。

`Tree()'
     Treeウィジェットは階層的なデータをツリー形式で表示するために使うことができます。ユーザはツリーの一部を開いたり閉じたりすることによって、ツリーの見えを調整できます。


File: python-lib-jp.info,  Node: タビュラーリストボックス,  Next: 管理ウィジェット,  Prev: ハイアラキカルリストボックス,  Up: Tixウィジェット

タビュラーリストボックス
........................

`TList()'
     TListウィジェットは、表形式でデータを表示するために使うことができます。`TList'ウィジェットのリスト・エントリは、Tkのリストボックス・ウィジェットのエントリに似ています。主な差は、(1)
     `TList'ウィジェットはリスト・エントリを二次元形式で表示でき、(2)
     リスト・エントリに対して複数の色やフォントだけでなく画像も使うことができるということです。


File: python-lib-jp.info,  Node: 管理ウィジェット,  Next: 画像タイプ,  Prev: タビュラーリストボックス,  Up: Tixウィジェット

管理ウィジェット
................

`PanedWindow()'
     PanedWindowウィジェットは、ユーザがいくつかのペインのサイズを対話的に操作できるようにします。ペインは垂直または水平のどちらかに配置されます。ユーザは二つのペインの間でリサイズ・ハンドルをドラッグしてペインの大きさを変更します。

`ListNoteBook()'
     ListNoteBookウィジェットは、`TixNoteBook'ウィジェットにとてもよく似ています。ノートのメタファを使って限られた空間をに多くのウィンドウを表示するために使われます。ノートはたくさんのページ(ウィンドウ)に分けられています。ある時には、これらのページの一つしか表示できません。ユーザは`hlist'サブウィジェットの中の望みのページの名前を選択することによって、これらのページを切り替えることができます。

`NoteBook()'
     NoteBookウィジェットは、ノートのメタファを多くのウィンドウを表示することができます。ノートはたくさんのページに分けられています。ある時には、これらのページの一つしか表示できません。ユーザはNoteBookウィジェットの一番上にある目に見える"タブ"を選択することで、これらのページを切り替えることができます。


File: python-lib-jp.info,  Node: 画像タイプ,  Next: その他のウィジェット,  Prev: 管理ウィジェット,  Up: Tixウィジェット

画像タイプ
..........

`Tix'モジュールは次のものを追加します:
   *
     全ての`Tix'と`Tkinter'ウィジェットに対してXPMファイルからカラー画像を作成するpixmap機能。

   *
     Compound画像タイプは複数の水平方向の線から構成される画像を作成するために使うことができます。それぞれの線は左から右に並べられた一連のアイテム(テキスト、ビットマップ、画像あるいは空白)から作られます。例えば、Tkの`Button'ウィジェットの中にビットマップとテキスト文字列を同時に表示するためにcompound画像は使われます。



File: python-lib-jp.info,  Node: その他のウィジェット,  Next: ジオメトリマネジャを作る,  Prev: 画像タイプ,  Up: Tixウィジェット

その他のウィジェット
....................

`InputOnly()'
     InputOnlyウィジェットは、ユーザから入力を受け付けます。それは、`bind'コマンドを使って行われます(UNIXのみ)。



File: python-lib-jp.info,  Node: ジオメトリマネジャを作る,  Prev: その他のウィジェット,  Up: Tixウィジェット

ジオメトリマネジャを作る
........................

加えて、`Tix'は次のものを提供することで`Tkinter'を補強します:

`Form()'
     Tkウィジェットに対する接続ルールに基づいたジオメトリマネジャを作成(Form)します。


File: python-lib-jp.info,  Node: Tixコマンド,  Prev: Tixウィジェット,  Up: Tix

Tixコマンド
-----------

`tixCommand()'
     tixコマンドは`Tix'の内部状態と`Tix'アプリケーション・コンテキストのいろいろな要素へのアクセスを提供します。これらのメソッドによって操作される情報の大部分は、特定のウィンドウというよりむしろアプリケーション全体かスクリーンあるいはディスプレイに関するものです。

     現在の設定を見るための一般的な方法は、
          import Tix
          root = Tix.Tk()
          print root.tix_configure()


`tix_configure([cnf,] **kw)'
     Tixアプリケーション・コンテキストの設定オプションを問い合わせたり、変更したりします。オプションが指定されなければ、利用可能なオプションすべてのディクショナリを返します。オプションが値なしで指定された場合は、メソッドは指定されたオプションを説明するリストを返します(このリストはオプションが指定されていない場合に返される値に含まれている、指定されたオプションに対応するサブリストと同一です)。一つ以上のオプション-値のペアが指定された場合は、メソッドは与えられたオプションが与えられた値を持つように変更します。この場合は、メソッドは空文字列を返します。オプションは設定オプションのどれでも構いません。

`tix_cget(option)'
     OPTIONによって与えられた設定オプションの現在の値を返します。オプションは設定オプションのどれでも構いません。

`tix_getbitmap(name)'
     ビットマップディレクトリの一つの中の`name.xpm'または`name'と言う名前のビットマップファイルの場所を見つけ出します(`tix_addbitmapdir()'メソッドを参照してください)。`tix_getbitmap()'を使うことで、アプリケーションにビットマップファイルのパス名をハードコーディングすることを避けることができます。成功すれば、文字`@'を先頭に付けたビットマップファイルの完全なパス名を返します。戻り値をTkとTixウィジェットの`bitmap'オプションを設定するために使うことができます。

`tix_addbitmapdir(directory)'
     Tixは`tix_getimage()'と`tix_getbitmap()'メソッドが画像ファイルを検索するディレクトリのリストを保持しています。標準ビットマップディレクトリは`$TIX_LIBRARY/bitmaps'です。`tix_addbitmapdir()'メソッドはDIRECTORYをこのリストに追加します。そのメソッドを使うことによって、アプリケーションの画像ファイルを`tix_getimage()'または`tix_getbitmap()'メソッドを使って見つけることができます。

`tix_filedialog([dlgclass])'
     このアプリケーションからの異なる呼び出しの間で共有される可能性があるファイル選択ダイアログを返します。最初に呼ばれた時に、このメソッドはファイル選択ダイアログ・ウィジェットを作成します。このダイアログはその後のすべての`tix_filedialog()'への呼び出しで返されます。オプションのdlgclassパラメータは、要求されているファイル選択ダイアログ・ウィジェットの型を指定するために文字列として渡されます。指定可能なオプションは`tix'、`FileSelectDialog'あるいは`tixExFileSelectDialog'です。

`tix_getimage(self, name)'
     ビットマップディレクトリの一つの中の`name.xpm'、`name.xbm'または`name.ppm'という名前の画像ファイルの場所を見つけ出します(上の`tix_addbitmapdir()'メソッドを参照してください)。同じ名前(だが異なる拡張子)のファイルが一つ以上ある場合は、画像のタイプがXディスプレイの深さに応じて選択されます。xbm画像はモノクロディスプレイの場合に選択され、カラー画像はカラーディスプレイの場合に選択されます。`tix_getimage()'を使うことによって、アプリケーションに画像ファイルのパス名をハードコーディングすることを避けられます。成功すれば、このメソッドは新たに作成した画像の名前を返し、TkとTixウィジェットの`image'オプションを設定するためにそれを使うことができます。

`tix_option_get(name)'
     Tixのスキーム・メカニズムによって保持されているオプションを得ます。

`tix_resetoptions(newScheme, newFontSet[, newScmPrio])'
     TixアプリケーションのスキームとフォントセットをNEWSCHEMEとNEWFONTSETそれぞれへと再設定します。これはこの呼び出し後に作成されたそれらのウィジェットだけに影響します。そのため、Tixアプリケーションのどんなウィジェットを作成する前にresetoptionsメソッドを呼び出すのが最も良いのです。

     オプション・パラメータNEWSCMPRIOを、Tixスキームによって設定されるTkオプションの優先度レベルを再設定するために与えることができます。

     TkがXオプションデータベースを扱う方法のため、Tixがインポートされ初期化された後に、カラースキームとフォントセットを`tix_config()'メソッドを使って再設定することができません。その代わりに、`tix_resetoptions()'メソッドを使わなければならないのです。


File: python-lib-jp.info,  Node: ScrolledText,  Next: turtle,  Prev: Tix,  Up: Tkを用いたグラフィカルユーザインターフェイス

スクロールするテキストウィジェット
==================================

垂直スクロールバーを持つテキストウィジェット。

`ScrolledText'モジュールは"正しい動作"をするように設定された垂直スクロールバーをもつ基本的なテキストウィジェットを実装する同じ名前のクラスを提供します。`ScrolledText'クラスを使うことは、テキストウィジェットとスクロールバーを直接設定するより簡単です。コンストラクタは`Tkinter.Text'クラスのものを同じです。

テキストウィジェットとスクロールバーは`Frame'の中に一緒にpackされ、`Grid'と`Pack'ジオメトリマネジャのメソッドは`Frame'オブジェクトから得られます。これによって、もっとも標準的なジオメトリマネジャの振る舞いにするために、直接`ScrolledText'ウィジェットを使えるようになります。

特定の制御が必要ならば、以下の属性が利用できます:

`frame'
     テキストとスクロールバーウィジェットを取り囲むフレーム。

`vbar'
     スクロールバーウィジェット。


File: python-lib-jp.info,  Node: turtle,  Next: Idle,  Prev: ScrolledText,  Up: Tkを用いたグラフィカルユーザインターフェイス

Tkのためのタートルグラフィックス
================================

タートルグラフィックスのための環境。

`turtle'モジュールはオブジェクト指向と手続き指向の両方の方法でタートルグラフィックス・プリミティブを提供します。グラフィックスの基礎として`Tkinter'を使っているために、Tkをサポートしたpythonのバージョンが必要です。

手続き型インターフェイスでは、関数のどれかが呼び出されたときに自動的に作られるペンとキャンバスを使います。

`turtle'モジュールは次の関数を定義しています:

`degrees()'
     角度を計る単位を度にします。

`radians()'
     角度を計る単位をラジアンにします。

`reset()'
     スクリーンを消去し、ペンを中心に持って行き、変数をデフォルト値に設定します。

`clear()'
     スクリーンを消去します。

`tracer(flag)'
     トレースをon/offにします(フラグが真かどうかに応じて)。トレースとは、線に沿って矢印のアニメーションが付き、線がよりゆっくりと引かれることを意味します。

`forward(distance)'
     DISTANCEステップだけ前に進みます。

`backward(distance)'
     DISTANCEステップだけ後ろに進みます。

`left(angle)'
     ANGLE単位だけ左に回ります。単位のデフォルトは度ですが、`degrees()'と`radians()'関数を使って設定できます。

`right(angle)'
     ANGLE単位だけ右に回ります。単位のデフォルトは度ですが、`degrees()'と`radians()'関数を使って設定できます。

`up()'
     ペンを上げます -- 線を引くことを止めます。

`down()'
     ペンを下げます -- 移動したときに線を引きます。

`width(width)'
     線幅をWIDTHに設定します。

`color(s)'

`color (r, g, b)'

`color r, g, b'
     ペンの色を設定します。最初の形式では、色は文字列としてTkの色の仕様の通りに指定されます。二番目の形式は色をRGB値(それぞれは範囲[0..1])のタプルとして指定します。三番目の形式では、色は三つに別れたパラメータとしてRGB値(それぞれは範囲[0..1])を与えて指定しています。

`write(text[, move])'
     現在のペンの位置にTEXTを書き込みます。MOVEが真ならば、ペンはテキストの右下の角へ移動します。デフォルトでは、MOVEは偽です。

`fill(flag)'
     完全な仕様はかなり複雑ですが、推奨する使い方は:
     塗りつぶしたい経路を描く前に`fill(1)'を呼び出し、経路を描き終えたときに`fill(0)'を呼び出します。

`circle(radius[, extent])'
     半径RADIUS、中心がタートルの左
     RADIUSユニットの円を描きます。EXTENTは円のどの部分を描くかを決定します:
     与えられなければ、デフォルトで完全な円になります。

     EXTENTが完全な円である場合は、弧の一つの端点は、現在のペンの位置です。RADIUSが正の場合、弧は反時計回りに描かれます。そうでなければ、時計回りです。

`goto(x, y)'

`goto (x, y)'
     座標X,
     Yへ移動します。座標は二つの別個の引数か、2-タプルのどちらかで指定することができます。

このモジュールは`from math import
*'も実行します。従って、タートルグラフィックスのために役に立つ追加の定数と関数については、`math'モジュールのドキュメントを参照してください。

`demo()'
     モジュールをちょっとばかり試しています。

`Error'
     このモジュールによって捕捉されたあらゆるエラー対して発生した例外。

例として、`demo()'関数のコードを参照してください。

このモジュールは次のクラスを定義します:

`Pen()'
     ペンを定義します。上記のすべての関数は与えられたペンのメソッドとして呼び出されます。このコンストラクタは線を描くキャンバスを自動的に作成します。

`RawPen(canvas)'
     キャンバスCANVASに描くペンを定義します。これは"実際の"プログラムでグラフィックスを作成するためにモジュールを使いたい場合に役に立ちます。

* Menu:

* PenとRawPenオブジェクト::


File: python-lib-jp.info,  Node: PenとRawPenオブジェクト,  Prev: turtle,  Up: turtle

PenとRawPenオブジェクト
-----------------------

`Pen'と`RawPen'オブジェクトは、`demo()'がメソッドとしは除かれますが、与えられたペンを操作する上記のすべてのグローバル関数を持っています。

メソッドになって強力になっているメソッドは`degrees()'だけです。

`degrees([fullcircle])'
     FULLCIRCLEはデフォルトで360です。たとえFULLCIRCLEにラジアンで2*$pi$、あるいは度で400を与えようとも、これはペンがどんな角度単位でも取ることができるようにしています。


File: python-lib-jp.info,  Node: Idle,  Next: 他のグラフィカルユーザインタフェースパッケージ,  Prev: turtle,  Up: Tkを用いたグラフィカルユーザインターフェイス

Idle
====

Idleは`Tkinter' GUIツールキットをつかって作られた Python  IDEです。

IDLEは次のような特徴があります:

   * `Tkinter' GUIツールキットを使って、100% ピュア  Python
     でコーディングされています

   * クロス-プラットホーム: WindowsとUNIXで動作します (Mac
     OSでは、現在Tcl/Tkに問題があります)

   * 多段Undo、 Python
     対応の色づけや他にもたくさんの機能(例えば、自動的な字下げや呼び出し情報の表示)をもつマルチ-ウィンドウ・テキストエディタ

   * Python シェルウィンドウ(別名、対話インタープリタ)

   *
     デバッガ(完全ではりませんが、ブレークポイントの設定や値の表示、ステップ実行ができます)

* Menu:

* メニュー::
* 基本的な編集とナビゲーション::
* 構文の色づけ::


File: python-lib-jp.info,  Node: メニュー,  Next: 基本的な編集とナビゲーション,  Prev: Idle,  Up: Idle

メニュー
--------

* Menu:

* Fileメニュー::
* Editメニュー::
* Windowsメニュー::
* Debugメニュー Python シェルウィンドウ内のみ::


File: python-lib-jp.info,  Node: Fileメニュー,  Next: Editメニュー,  Prev: メニュー,  Up: メニュー

Fileメニュー
............

`New window'
     新しい編集ウィンドウを作成します

`Open...'
     既存のファイルをオープンします

`Open module...'
     既存のモジュールをオープンします(sys.pathを検索します)

`Class browser'
     現在のファイルの中のクラスとモジュールを示します

`Path browser'
     sys.pathディレクトリ、モジュール、クラスおよびメソッドを示します

`Save'
     現在のウィンドウを対応するファイルにセーブします(未セーブのウィンドウには、ウィンドウタイトルの前後に*があります)

`Save As...'
     現在のウィンドウを新しいファイルへセーブします。そのファイルが対応するファイルになります

`Save Copy As...'
     現在のウィンドウを対応するファイルを変えずに異なるファイルにセーブします。

`Close'
     現在のウィンドウを閉じます(未セーブの場合はセーブするか質問します)

`Exit'
     すべてのウィンドウを閉じてIDLEを終了します(未セーブの場合はセーブするか質問します)


File: python-lib-jp.info,  Node: Editメニュー,  Next: Windowsメニュー,  Prev: Fileメニュー,  Up: メニュー

Editメニュー
............

`Undo'
     現在のウィンドウに対する最後の変更をUndo(取り消し)します(最大で1000個の変更)

`Redo'
     現在のウィンドウに対する最後にundoされた変更をRedo(再実行)します

`Cut'
     システムのクリップボードへ選択された部分をコピーします。それから選択された部分を削除します

`Copy'
     選択された部分をシステムのクリップボードへコピーします

`Paste'
     システムのクリップボードをウィンドウへ挿入します

`Select All'
     編集バッファの内容全体を選択します

`Find...'
     たくさんのオプションをもつ検索ダイアログボックスを開きます

`Find again'
     最後の検索を繰り返します

`Find selection'
     選択された文字列を検索します

`Find in Files...'
     検索するファイルに対する検索ダイアログボックスを開きます

`Replace...'
     検索と置換ダイアログボックスを開きます

`Go to line'
     行番号を尋ね、その行を表示します

`Indent region'
     選択された行を右へ空白4個分シフトします

`Dedent region'
     選択された行を左へ空白4個分シフトします

`Comment out region'
     選択された行の先頭に##を挿入します

`Uncomment region'
     選択された行から先頭の#あるいは##を取り除きます

`Tabify region'
     _先頭_の一続きの空白をタブに置き換えます

`Untabify region'
     _すべての_タブを適切な数の空白に置き換えます

`Expand word'
     あなたがタイプした語を同じバッファの別の語に一致するように展開します。そして、異なる展開が得るために繰り返します

`Format Paragraph'
     現在の空行で区切られた段落を再フォーマットします

`Import module'
     現在のモジュールをインポートまたはリロードします

`Run script'
     現在のファイルを__main__名前空間内で実行します


File: python-lib-jp.info,  Node: Windowsメニュー,  Next: Debugメニュー Python シェルウィンドウ内のみ,  Prev: Editメニュー,  Up: メニュー

Windowsメニュー
...............

`Zoom Height'
     ウィンドウを標準サイズ(24x80)と最大の高さの間で切り替えます

このメニューの残りはすべての開いたウィンドウの名前の一覧になっています。一つを選ぶとそれを最前面に持ってくることができます(必要ならばアイコン化をやめさせます)


File: python-lib-jp.info,  Node: Debugメニュー Python シェルウィンドウ内のみ,  Prev: Windowsメニュー,  Up: メニュー

Debugメニュー( Python シェルウィンドウ内のみ)
.............................................

`Go to file/line'
     挿入ポイントの周りからファイル名と行番号を探し、ファイルをオープンし、その行を表示します

`Open stack viewer'
     最後の例外のスタックトレースバックを表示します

`Debugger toggle'
     デバッガの下、シェル内でコマンドを実行します

`JIT Stack viewer toggle'
     トレースバック上のスタックビューアをオープンします


File: python-lib-jp.info,  Node: 基本的な編集とナビゲーション,  Next: 構文の色づけ,  Prev: メニュー,  Up: Idle

基本的な編集とナビゲーション
----------------------------

   * <Backspace>は左側を削除し、<Del>は右側を削除します

   * 矢印キーと<Page Up>/<Page Down>はそれぞれ移動します

   * <Home>/<End>は行の始め/終わりへ移動します

   * <C-Home>/<C-End>はファイルの始め/終わりへ移動します

   *
     <C-B>、<C-P>、<C-A>、<C-E>、<C-D>、<C-L>を含む、いくつかの`Emacs'バインディングも動作します

* Menu:

* 自動的な字下げ::
* Python  Shellウィンドウ::


File: python-lib-jp.info,  Node: 自動的な字下げ,  Next: Python Shellウィンドウ,  Prev: 基本的な編集とナビゲーション,  Up: 基本的な編集とナビゲーション

自動的な字下げ
..............

ブロックの始まりの文の後、次の行は4つの空白( Python
Shellウィンドウでは、一つのタブ)で字下げされます。あるキーワード(break、returnなど)の後では、次の行は字下げが解除(dedent)されます。先頭の字下げでは、<Backspace>は4つの空白があれば削除します。<Tab>は1-4つの空白(
Python
Shellウィンドウでは一つのタブ)を挿入します。editメニューのindent/dedent
regionコマンドも参照してください。


File: python-lib-jp.info,  Node: Python Shellウィンドウ,  Prev: 自動的な字下げ,  Up: 基本的な編集とナビゲーション

Python  Shellウィンドウ
.......................

   * <C-C> 実行中のコマンドを中断します

   * <C-D>
     ファイル終端(end-of-file)を送り、`>>>~'プロンプトでタイプしていた場合はウィンドウを閉じます

   * <Alt-p>
     あなたがタイプしたことに一致する以前のコマンドを取り出します

   * <Alt-n> 次を取り出します

   * <Return> 以前のコマンドを取り出しているときは、そのコマンド

   * <Alt-/> (語を展開します)ここでも便利です


File: python-lib-jp.info,  Node: 構文の色づけ,  Prev: 基本的な編集とナビゲーション,  Up: Idle

構文の色づけ
------------

色づけはバックグランド"スレッド"で適用され、そのため時折色付けされないテキストが見えます。カラースキームを変えるには、`config.txt'の`[Colors]'節を編集してください。

`Python の構文の色:'

    `キーワード'
          オレンジ

    `文字列'
          緑

    `コメント'
          赤

    `定義'
          青

`シェルの色:'

    `コンソールの出力'
          茶色

    `stdout'
          青

    `stderr'
          暗い緑

    `stdin'
          黒


* Menu:

* コマンドラインの使い方::


File: python-lib-jp.info,  Node: コマンドラインの使い方,  Prev: 構文の色づけ,  Up: 構文の色づけ

コマンドラインの使い方
......................

     idle.py [-c command] [-d] [-e] [-s] [-t title] [arg] ...
     
     -c コマンド このコマンドを実行します
     -d          デバッガを有効にします
     -e          編集モード、引数は編集するファイルです
     -s          $IDLESTARTUPまたは$PYTHONSTARTUPを最初に実行します
     -t タイトル シェルウィンドウのタイトルを設定します

引数がある場合:

  1.
     `-e'が使われる場合は、引数は編集のためにオープンされるファイルで、`sys.argv'はIDLE自体へ渡される引数を反映します。

  2.
     そうではなく、`-c'が使われる場合には、すべての引数が`sys.argv[1:...]'の中に置かれ、`sys.argv[0]'が`'-c''に設定されます。

  3.
     そうではなく、`-e'でも`-c'でも使われない場合は、最初の引数は`sys.argv[1:...]'にある残りの引数とスクリプト名に設定される`sys.argv[0]'と一緒に実行されるスクリプトです。スクリプト名が'-'のときは、実行されるスクリプトはありませんが、対話的な
     Python
     セッションが始まります。引数はまだ`sys.argv'にあり利用できます。


File: python-lib-jp.info,  Node: 他のグラフィカルユーザインタフェースパッケージ,  Prev: Idle,  Up: Tkを用いたグラフィカルユーザインターフェイス

他のグラフィカルユーザインタフェースパッケージ
==============================================

`Tkinter'へ付け加えられるたくさんの拡張ウィジェットがあります。

     ` Python メガウィジェット' {`Tkinter'モジュールを使い Python
     で高レベルの複合
     ウィジェットを構築するためのツールキットです。基本クラスと
     この基礎の上に構築された柔軟で拡張可能なメガウィジェットか
     ら構成されています。これらのメガウィジェットはノートブック、
     コンボボックス、選択ウィジェット、ペインウィジェット、スク
     ロールするウィジェット、ダイアログウィンドウなどを含みます。
     BLTに対するPmw.Bltインタフェースを持ち、busy、graph、
     stripchart、tabsetおよびvectorコマンドが利用できます。
     Pmwの最初のアイディアは、Michael McLennanによるTk `itcl'拡張
     `[incr Tk]'とMark Ulfertsによる`[incr Widgets]'から得ました。
     メガウィジェットのいくつかはitclから Python
     へ直接変換したものです。 `[incr
     Widgets]'が提供するウィジェットとほぼ同等のものを提供しま
     す。そして、Tixと同様にほぼ完成しています。しかしながら、ツリーを描く
     ためのTixの高速な`HList'ウィジェットが欠けています。  }

     `Tkinter3000 Widget Construction Kit (WCK)'{は、新しい Tkinter
     ウィジェットを、 Python  で書けるようにするライブラリで す。WCK
     フレームワークは、ウィジェットの生成、設定、スクリーンの外観、イ
     ベント操作における、完全な制御を提供します。Tk/Tcl
     レイヤーを通してデー タ転送する必要がなく、直接  Python
     のデータ構造を操作することができるので、 WCK
     ウィジェットは非常に高速で軽量になり得ます。}

Tk は  Python  にとって唯一の GUI というわけではありませんが、
もっともよく使われています。

     `wxWindows'{Qt、Tk、MotifおよびGTK+
     のもっとも魅力のある性質を一つのパッケージに結合したGUIツールキット
     です。C++で実装されています。wxWindowsは二種類のUNIX実装をサポー
     トしています: GTK+とMotif。Windowsでは、標準的なMicrosoft
     Foundation Classes
     (MFC)の外観を持っています。なぜなら、Win32ウィジェットを使っ
     ているからです。Tkinterに依存しない Python
     クラスブラウザがあります。
     wxWindowsは`Tkinter'よりさらにウィジェットが豊富で、そのへヘ
     ルプシステム、洗練されたHTMLと画像ビューアおよび他の専門分野別のウィ
     ジェット、多数のドキュメントと印刷機能を持っています。  }
     `PyQt'{PyQtは`sip'でラップされたQtツールキットへの
     バインディングです。QtはUNIX、WindowsおよびMac OS Xで利用できる大
     規模なC++ GUIツールキットです。`sip'は Python クラスとし
     てC++ライブラリに対するバインディングを生成するためのツールキット
     で、特に Python 用に設計されています。オンライン・マニュアルは
     <http://www.opendocspublishing.com/pyqt/> (正誤表は
     <http://www.valdyas.org/python/book.html>にあります)で手に入りま
     す。  }

     `PyKDE'{
     PyKDEは`sip'でラップされたKDEデスクトップライブラリに対するイ
     ンタフェースです。KDEはUNIXコンピュータ用のデスクトップ環境です。グ
     ラフィカル・コンポーネントはQtに基づいています。 } `FXPy'{
     GUIへのインタフェースを提供する Python
     拡張モジュールです。FOXは、グ
     ラフィカルユーザインタフェースを簡単かつ効率良く開発するためのC++
     ベースのツールキットです。それは幅広く、成長しているコントロール・コ
     レクションで、3Dグラフィックスの操作のためのOpenGLウィジェットと同様
     に、ドラッグアンドドロップ、選択のような最新の機能を提供します。FOX
     はアイコン、画像およびステータスライン・ヘルプやツールチップのような
     ユーザにとって便利な機能も実装しています。
     FOXはすでに大規模なコントロール・コレクションを提供していますが、単に
     既存のコントロールを使って望みの振る舞いを追加または再定義する派生クラ
     スを作成することによってプログラマが簡単に追加コントロールとGUI要素を
     構築できるようにするために、FOXはC++を利用しています。  }
     `PyGTK'{GTKウィ
     ジェットセットのための一連のバインディングです。Cのものより少しだけ
     高レベルなオブジェクト指向インタフェースを提供します。普通はC
     APIを
     使ってやらなければならない型キャストとリファレンス・カウントをすべて
     自動的に行います。GNOMEに対しても、
     バインディングがあります。チュートリアルが手に入ります。  }


File: python-lib-jp.info,  Node: 制限実行 restricted execution,  Next: Python言語サービス,  Prev: Tkを用いたグラフィカルユーザインターフェイス,  Up: Top

制限実行 (restricted execution)
*******************************

_Notice:_ [warning] Python 2.3
では、既知の容易に修正できないセキュリティーホール
のために、これらのモジュールは無効にされています。 `rexec' や `Bastion'
モジュールを使った古いコード
を読むときに助けになるよう、モジュールのドキュメントだけは
残されています。

_制限実行 (restricted execution)_ とは、信頼できるコード
と信頼できないコードを区別できるようにするための Python における
基本的なフレームワークです。このフレームワークは、信頼できる Python
コード (_スーパバイザ (supervisor)_) が、
パーミッションに制限のかけられた "拘束セル (padded cell)"
を生成し、このセル中で信頼のおけないコードを実行するという概念に
基づいています。信頼のおけないコードはこの拘束セルを破ることが
できず、信頼されたコードで提供され、管理されたインタフェースを
介してのみ、傷つきやすいシステムリソースとやりとりすることができます。
"制限実行" という用語は、"安全な Python (safe-Python)"
を裏から支えるものです。というのは、真の安全を定義する
ことは難しく、制限された環境を生成する方法によって決められるからです。
制限された環境は入れ子にすることができ、このとき内側のセルは
より縮小されることはあるが決して拡大されることのない特権を持った
サブセルを生成します。

Python の制限実行モデルの興味深い側面は、信頼されないコードに
提供されるインタフェースが、信頼されるコードに提供されるそれらと
同じ名前を持つということです。このため、制限された環境で動作
するよう設計されたコードを書く上で特殊なインタフェースを学ぶ
必要がありません。また、拘束セルの厳密な性質はスーパバイザによって
決められるため、アプリケーションによって異なる制限を課すことが
できます。例えば、信頼されないコードが指定したディレクトリ内の
何らかのファイルを読み出すが決して書き込まないということが "安全"
と考えられるかもしれません。この場合、スーパバイザは組み込みの `open()'
関数について、MODE パラメタが `'w''
の時に例外を送出するように再定義できます。また例えば、"安全" とは、
FILENAME パラメタに対して `chroot()' に似た
操作を施して、ルートパスがファイルシステム上の何らかの安全な "砂場
(sandbox)" 領域に対する相対パスになるようにすることかも
しれません。この場合でも、信頼されないコードは依然として、
もとの呼び出しインタフェースを持ったままの組み込みの`open()'
関数を制限環境中に見出します。ここでは、関数に対する意味付け
(semantics) は同じですが、許可されないパラメタが使われようとしている
とスーパバイザが判断した場合には `IOError' が送出されます。

Python のランタイムシステムは、特定のコードブロックが制限実行モード
かどうかを、グローバル変数の中の `__builtins__'
オブジェクトの一意性をもとに判断します: オブジェクトが 標準の
`__builtin__' モジュール (の辞書) の場合、
コードは非制限下にあるとみなされます。それ以外は制限下にあると
みなされます。

制限実行モードで動作する Python コードは、拘束セルから侵出しないように
設計された数多くの制限に直面します。例えば、関数オブジェクト 属性
`func_globals' や、クラスおよびインスタンスオブジェクトの 属性
`__dict__' は利用できません。

二つのモジュールが、制限実行環境を立ち上げるためのフレームワークを
提供しています:

See also:
     `Grail Home Page' {Python で書かれたインターネットブラウザ Grail
     です。Python
     で書かれたアプレットをサポートするために、上記のモジュールを使っています。Grail
     における Python 制限実行モードの利用に関する詳しい情報は、Web
     サイトで入手することができます。}

* Menu:

* rexec::
* Bastion::


File: python-lib-jp.info,  Node: rexec,  Next: Bastion,  Prev: 制限実行 restricted execution,  Up: 制限実行 restricted execution

制限実行のフレームワーク
========================

基本的な制限実行フレームワーク。 _Changed in Python version 2.3_

_Notice:_ [warning]
このドキュメントは、`rexec'モジュールを使用している古い
コードを読む際の参照用として残されています。

このモジュールには `RExec' クラスが含まれています。このクラスは、
`r_eval()'、 `r_execfile()'、 `r_exec()'および `r_import()'
メソッドをサポートし、これらは標準の Python 関数 `eval()'、
`execfile()' および `exec' と `import' 文の制限されたバージョンです。
この制限された環境で実行されるコードは、安全であると見なされた
モジュールや関数だけにアクセスします；`RExec' をサブクラス化すれば、
望むように能力を追加および削除できます。

_Notice:_ [warning] `rexec'
モジュールは、下記のように動作するべく設計されては
いますが、注意深く書かれたコードなら利用できてしまうかもしれない、
既知の脆弱性がいくつかあります。従って、"製品レベル" のセキュリティ
を要する状況では、`rexec' の動作をあてにするべきではありません。
製品レベルのセキュリティを求めるなら、サブプロセスを介した実行や、
あるいは処理するコードとデータの両方に対する非常に注意深い "浄化"
が必要でしょう。上記の代わりに、`rexec' の既知の
脆弱性に対するパッチ当ての手伝いも歓迎します。

_Notice:_ `RExec' クラスは、プログラムコードによる
ディスクファイルの読み書きや TCP/IP ソケットの利用といった、
安全でない操作の実行を防ぐことができます。しかし、
プログラムコードよる非常に大量のメモリや処理時間の消費に対して
防御することはできません。

`RExec([hooks[, verbose]])'
     `RExec' クラスのインスタンスを返します。

     HOOKS は、`RHooks' クラスあるいはそのサブクラスの
     インスタンスです。HOOKS が省略されているか `None' であれば、
     デフォルトの `RHooks' クラスがインスタンス化されます。 `rexec'
     モジュールが (組み込みモジュールを含む) あるモジュールを
     探したり、あるモジュールのコードを読んだりする時は常に、 `rexec'
     がじかにファイルシステムに出て行くことはありません。
     その代わり、あらかじめ `RHooks' クラスに渡しておいたり、
     コンストラクタで生成された `RHooks' インスタンスのメソッドを
     呼び出します。

     (実際には、`RExec' オブジェクトはこれらを呼び出しません --
     呼び出しは、`RExec' オブジェクトの一部であるモジュールローダ
     オブジェクトによって行われます。
     これによって別のレベルの柔軟性が実現されます。この柔軟性は、制限された
     環境内で`import' 機構を変更する時に役に立ちます。 )

     代替の `RHooks' オブジェクトを提供することで、モジュールを
     インポートする際に行われるファイルシステムへのアクセスを制御する
     ことができます。このとき、各々のアクセスが行われる順番を制御する
     実際のアルゴリズムは変更されません。 例えば、`RHooks'
     オブジェクトを置き換えて、ILU のような ある種の RPC
     メカニズムを介することで、全てのファイルシステムの要求を
     どこかにあるファイルサーバに渡すことができます。 Grail
     のアプレットローダは、アプレットを URL からディレクトリ上に import
     する際にこの機構を使っています。

     もし VERBOSEが true であれば、追加のデバッグ出力が標準出力に
     送られます。

制限された環境で実行するコードも、やはり `sys.exit()' 関数を
呼ぶことができることを知っておくことは大事なことです。制限された
コードがインタプリタから抜けだすことを許さないためには、いつでも、
制限されたコードが、`SystemExit' 例外をキャッチする `try'/`except'
文とともに実行するように、呼び出しを防御します。 制限された環境から
`sys.exit()'関数を除去するだけでは不十分です -
制限されたコードは、やはり `raise SystemExit'
を使うことができてしまいます。
`SystemExit'を取り除くことも、合理的なオプションではありません；
いくつかのライブラリコードはこれを使っていますし、これが利用できなくなると
中断してしまうでしょう。

See also:
     `Grail のホームページ'{Grail は すべて Python で書かれた Web
     ブラウザです。これは、 `rexec'モジュールを、Python
     アプレットをサポートするのに
     使っていて、このモジュールの使用例として使うことが できます。}

* Menu:

* RExec オブジェクト::
* 制限された環境を定義する::
* 例 15::


File: python-lib-jp.info,  Node: RExec オブジェクト,  Next: 制限された環境を定義する,  Prev: rexec,  Up: rexec

RExec オブジェクト
------------------

`RExec' インスタンスは以下のメソッドをサポートします：

`r_eval(code)'
     CODE は、Python の式を含む文字列か、あるいはコンパイルされた
     コードオブジェクトのどちらかでなければなりません。そしてこれらは制限された
     環境の `__main__' モジュールで評価されます。式あるいはコード
     オブジェクトの値が返されます。

`r_exec(code)'
     CODE は、1行以上の Python コードを含む文字列か、コンパイルされた
     コードオブジェクトのどちらかでなければなりません。そしてこれらは、
     制限された環境の `__main__' モジュールで実行されます。

`r_execfile(filename)'
     ファイル FILENAME 内の Python コードを、制限された環境の
     `__main__' モジュールで実行します。

名前が `s_' で始まるメソッドは、`r_'で始まる関数と同様ですが、
そのコードは、標準 I/O ストリーム `sys.stdin'、 `sys.stderr' および
`sys.stdout' の制限されたバージョンへの アクセスが許されています。

`s_eval(code)'
     CODE は、Python 式を含む文字列でなければなりません。そして
     制限された環境で評価されます。

`s_exec(code)'
     CODE は、1行以上のPython
     コードを含む文字列でなければなりません。そして
     制限された環境で実行されます。

`s_execfile(code)'
     ファイル FILENAME に含まれた Python コードを制限された環境で
     実行します。

`RExec' オブジェクトは、制限された環境で実行されるコードによって
暗黙のうちに呼ばれる、さまざまなメソッドもサポートしなければなりません。
これらのメソッドをサブクラス内でオーバライドすることによって、制限された環境が
強制するポリシを変更します。

`r_import(modulename[, globals[, locals[, fromlist]]])'
     モジュール MODULENAME をインポートし、もしそのモジュールが
     安全でないとみなされるなら、`ImportError' 例外を発生します。

`r_open(filename[, mode[, bufsize]])'
     `open()' が制限された環境で呼ばれるとき、呼ばれるメソッドです。
     引数は `open()'のものと同じであり、ファイルオブジェクト
     (あるいはファイルオブジェクトと互換性のあるクラスインスタンス)が
     返されます。 `RExec'のデフォルトの動作は、任意のファイルを
     読み取り用にオープンすることを許可しますが、ファイルに書き込もうとする
     ことは許しません。より制限の少ない `r_open()'の実装については、
     以下の例を見て下さい。

`r_reload(module)'
     モジュールオブジェクト MODULE
     を再ロードして、それを再解析し再初期化します。

`r_unload(module)'
     モジュールオブジェクト MODULEをアンロードします
     (それを制限された環境の `sys.modules' 辞書から取りのぞきます)。

および制限された標準 I/O ストリームへのアクセスが可能な同等のもの：

`s_import(modulename[, globals[, locals[, fromlist]]])'
     モジュール MODULENAME をインポートし、もしそのモジュールが
     安全でないとみなされるなら、`ImportError' 例外を発生します。

`s_reload(module)'
     モジュールオブジェクト MODULE
     を再ロードして、それを再解析し再初期化します。

`s_unload(module)'
     モジュールオブジェクト MODULEをアンロードします。


File: python-lib-jp.info,  Node: 制限された環境を定義する,  Next: 例 15,  Prev: RExec オブジェクト,  Up: rexec

制限された環境を定義する
------------------------

`RExec' クラスには以下のクラス属性があります。それらは、 `__init__()'
メソッドが使います。それらを既存の
インスタンス上で変更しても何の効果もありません；そうする代わりに、
`RExec' のサブクラスを作成して、そのクラス定義でそれらに
新しい値を割り当てます。そうすると、新しいクラスのインスタンスは、
これらの新しい値を使用します。これらの属性のすべては、文字列のタプルです。

`nok_builtin_names'
     制限された環境で実行するプログラムでは利用でき_ない_であろう、
     組み込み関数の名前を格納しています。 `RExec'に対する値は、
     `('open', 'reload', '__import__')' です。
     (これは例外です。というのは、組み込み関数のほとんど大多数は
     無害だからです。この変数をオーバライドしたいサブクラスは、
     基本クラスからの値から始めて、 追加した許されない関数を連結して
     いかなければなりません - 危険な関数が新しく Python
     に追加された時は、 それらも、このモジュールに追加します。)

`ok_builtin_modules'
     安全にインポートできる組み込みモジュールの名前を格納しています。
     `RExec'に対する値は、 `('audioop', 'array', 'binascii', 'cmath',
     'errno', 'imageop', 'marshal', 'math', 'md5', 'operator',
     'parser', 'regex', 'rotor', 'select', 'sha', '_sre', 'strop',
     'struct', 'time')' です。この変数をオーバーライドする場合も、
     同様な注意が適用されます - 基本クラスからの値を使って始めます。

`ok_path'
     `import'が制限された環境で実行される時に検索される
     ディレクトリーを格納しています。
     `RExec'に対する値は、(モジュールがロードされた時は)
     制限されないコードの `sys.path' と同一です。

`ok_posix_names'
     制限された環境で実行するプログラムで利用できる、 `os'
     モジュール内の関数の名前を格納しています。 `RExec'に対する値は、
     `('error', 'fstat', 'listdir', 'lstat', 'readlink', 'stat',
     'times', 'uname', 'getpid', 'getppid', 'getcwd', 'getuid',
     'getgid', 'geteuid', 'getegid')' です。

`ok_sys_names'
     制限された環境で実行するプログラムで利用できる、 `sys'
     モジュール内の関数名と変数名を格納しています。
     `RExec'に対する値は、 `('ps1', 'ps2', 'copyright', 'version',
     'platform', 'exit', 'maxint')'です。

`ok_file_types'
     モジュールがロードすることを許されているファイルタイプを格納しています。
     各ファイルタイプは、`imp'モジュールで定義された整数定数です。
     意味のある値は、`PY_SOURCE'、`PY_COMPILED' および `C_EXTENSION'
     です。`RExec'に対する値は、`(C_EXTENSION,
     PY_SOURCE)'です。サブクラスで
     `PY_COMPILED'を追加することは推奨されません；
     攻撃者が、バイトコンパイルしたでっちあげのファイル(`.pyc')を、
     例えば、あなたの公開 FTP サーバの `/tmp' に書いたり、 `/incoming'
     にアップロードしたりして、とにかくあなたのファイルシステム内に
     置くことで、制限された実行モードから抜け出ることができるかもしれないからです。


File: python-lib-jp.info,  Node: 例 15,  Prev: 制限された環境を定義する,  Up: rexec

例
--

標準の `RExec' クラスよりも、若干、もっと緩めたポリシを
望んでいるとしましょう。例えば、もし `/tmp' 内のファイルへの書き込みを
喜んで許すならば、`RExec' クラスを次のように サブクラス化できます：

     class TmpWriterRExec(rexec.RExec):
         def r_open(self, file, mode='r', buf=-1):
             if mode in ('r', 'rb'):
                 pass
             elif mode in ('w', 'wb', 'a', 'ab'):
                 # ファイル名をチェックします :  /tmp/ で始まらなければなりません
                 if file[:5]!='/tmp/':
                     raise IOError, " /tmp 以外へは書き込みできません"
                 elif (string.find(file, '/../') >= 0 or
                      file[:3] == '../' or file[-3:] == '/..'):
                     raise IOError, "ファイル名の '..' は禁じられています"
             else: raise IOError, "open() モードが正しくありません"
             return open(file, mode, buf)

上のコードは、完全に正しいファイル名でも、時には禁止する場合があることに
注意して下さい；例えば、制限された環境でのコードでは、`/tmp/foo/../bar'
というファイルはオープンできないかもしれません。これを修正するには、
`r_open()' メソッドが、そのファイル名を `/tmp/bar'に単純化
しなければなりません。そのためには、ファイル名を分割して、それにさまざまな
操作を行う必要があります。セキュリティが重大な場合には、
より複雑で、微妙なセキュリティホールを抱え込むかもしれない、一般性のある
コードよりも、 制限が余りにあり過ぎるとしても単純なコードを書く方が、
望ましいでしょう。


File: python-lib-jp.info,  Node: Bastion,  Prev: rexec,  Up: 制限実行 restricted execution

オブジェクトに対するアクセスの制限
==================================

オブジェクトに対するアクセスの制限を提供する。

_Changed in Python version 2.3_

_Notice:_ [warning]
このドキュメントは、Bastionモジュールを使用している古いコードを読む際の
参照用として残されています。

辞書によると、バスティアン (bastion、要塞) とは、"防衛された
領域や地点"、または "最後の砦と考えられているもの" であり、
オブジェクトの特定の属性へのアクセスを禁じる方法を提供する
このモジュールにふさわしい名前です。制限モード下のプログラム
に対して、あるオブジェクトにおける特定の安全な属性へのアクセス
を許可し、かつその他の安全でない属性へのアクセスを拒否する
には、要塞オブジェクトは常に `rexec' モジュールと共に
使われなければなりません。

`Bastion(object[, filter[, name[, class]]])'
     オブジェクト OBJECT を保護し、オブジェクトに対する要塞
     オブジェクトを返します。オブジェクトの属性に対するアクセスの試みは
     全て、FILTER 関数によって認可されなければなりません; アクセス
     が拒否された場合 `AttributeError' 例外が送出されます。

     FILTER が存在する場合、この関数は属性名を含む文字列を受理
     し、その属性に対するアクセスが許可される場合には真を返さなければ
     なりません; FILTER が偽を返す場合、アクセスは拒否されます。
     標準のフィルタは、アンダースコア (`_') で始まる全ての
     関数に対するアクセスを拒否します。NAME の値が与えられた場合、
     要塞オブジェクトの文字列表現は `<Bastion for NAME>' に なります;
     そうでない場合、`repr(OBJECT)' が使われます。

     CLASS が存在する場合、`BastionClass' のサブクラスで
     なくてはなりません; 詳細は `bastion.py' のコードを参照して
     ください。稀に `BastionClass' の標準設定を上書きする必要
     ほとんどないはずです。

`BastionClass(getfunc, name)'
     実際に要塞オブジェクトを実装しているクラスです。このクラスは
     `Bastion()' によって使われる標準のクラスです。 GETFUNC
     引数は関数で、唯一の引数である属性の名前を
     与えて呼び出した際、制限された実行環境に対して、開示すべき属性の値を
     返します。NAME は `BastionClass' インスタンスの `repr()'
     を構築するために使われます。


File: python-lib-jp.info,  Node: Python言語サービス,  Next: Python コンパイラパッケージ,  Prev: 制限実行 restricted execution,  Up: Top

Python言語サービス
******************

PythonにはPython言語を使って作業するときに役に立つモジュールがたくさん提供されています。これらのモジュールはトークンの切り出し、パース、構文解析、バイトコードのディスアセンブリおよびその他のさまざまな機能をサポートしています。

これらのモジュールには、次のものが含まれています:

* Menu:

* parser::
* symbol::
* token::
* keyword::
* tokenize::
* tabnanny::
* pyclbr::
* py_compile::
* compileall::
* dis::
* distutils::


File: python-lib-jp.info,  Node: parser,  Next: symbol,  Prev: Python言語サービス,  Up: Python言語サービス

Python解析木にアクセスする
==========================

Pythonソースコードに対する解析木へのアクセス。

`parser'モジュールはPythonの内部パーサとバイトコード・コンパイラへのインターフェイスを提供します。このインターフェイスの第一の目的は、PythonコードからPythonの式の解析木を編集したり、これから実行可能なコードを作成したりできるようにすることです。これは任意のPythonコードの断片を文字列として構文解析や変更を行うより良い方法です。なぜなら、構文解析がアプリケーションを作成するコードと同じ方法で実行されるからです。その上、高速です。

このモジュールについて注意すべきことが少しあります。それは作成したデータ構造を利用するために重要なことです。この文書はPythonコードの解析木を編集するためのチュートリアルではありませんが、`parser'モジュールを使った例をいくつか示しています。

もっとも重要なことは、内部パーサが処理するPythonの文法についてよく理解しておく必要があるということです。言語の文法に関する完全な情報については、を参照してください。標準のPythonディストリビューションに含まれるファイル`Grammar/Grammar'の中で定義されている文法仕様から、パーサ自身は作成されています。このモジュールが作成するASTオブジェクトの中に格納される解析木は、下で説明する`expr()'または`suite()'関数によって作られるときに内部パーサから実際に出力されるものです。`sequence2ast()'が作るASTオブジェクトは忠実にこれらの構造をシミュレートしています。言語の形式文法が改訂されるために、"正しい"と考えられるシーケンスの値がPythonのあるバージョンから別のバージョンで変化することがあるということに注意してください。しかし、Pythonのあるバージョンから別のバージョンへテキストのソースのままコードを移せば、目的のバージョンで正しい解析木を常に作成できます。ただし、インタープリタの古いバージョンへ移行する際に、最近の言語コンストラクトをサポートしていないことがあるという制限だけがあります。ソースコードが常に前方互換性があるのに対して、一般的に解析木はあるバージョンから別のバージョンへの互換性がありません。

`ast2list()'または`ast2tuple()'から返されるシーケンスのそれぞれの要素は単純な形式です。文法の非終端要素を表すシーケンスは常に一より大きい長さを持ちます。最初の要素は文法の生成規則を識別する整数です。これらの整数はCヘッダファイル`Include/graminit.h'とPythonモジュール`symbol'の中の特定のシンボル名です。シーケンスに付け加えられている各要素は、入力文字列の中で認識されたままの形で生成規則の構成要素を表しています:
これらは常に親と同じ形式を持つシーケンスです。この構造の注意すべき重要な側面は、`if_stmt'の中のキーワード`if'のような親ノードの型を識別するために使われるキーワードがいかなる特別な扱いもなくノードツリーに含まれているということです。例えば、`if'キーワードはタプル`(1,
'if')'と表されます。ここで、`1'は、ユーザが定義した変数名と関数名を含むすべての`NAME'トークンに対応する数値です。行番号情報が必要なときに返される別の形式では、同じトークンが`(1,
'if',
12)'のように表されます。ここでは、`12'が終端記号の見つかった行番号を表しています。

終端要素は同じ方法で表現されますが、子の要素や識別されたソーステキストの追加は全くありません。上記の`if'キーワードの例が代表的なものです。終端記号のいろいろな型は、Cヘッダファイル`Include/token.h'とPythonモジュール`token'で定義されています。

ASTオブジェクトはこのモジュールの機能をサポートするために必要ありませんが、三つの目的から提供されています:
アプリケーションが複雑な解析木を処理するコストを償却するため、Pythonのリストやタプル表現に比べてメモリ空間を保全する解析木表現を提供するため、解析木を操作する追加モジュールをCで作ることを簡単にするため。ASTオブジェクトを使っていることを隠すために、簡単な"ラッパー"クラスをPythonで作ることができます。

`parser'モジュールは二、三の別々の目的のために関数を定義しています。もっとも重要な目的はASTオブジェクトを作ることと、ASTオブジェクトを解析木とコンパイルされたコードオブジェクトのような他の表現に変換することです。しかし、ASTオブジェクトで表現された解析木の型を調べるために役に立つ関数もあります。

See also:
     *Note symbol:: 解析木の内部ノードを表す便利な定数。 *Note token::
     便利な解析木の葉のノードを表す定数とノード値をテストするための関数。

* Menu:

* ASTオブジェクトを作成する::
* ASTオブジェクトを変換する::
* ASTオブジェクトに対する問い合わせ::
* 例外とエラー処理::
* ASTオブジェクト::
* 例 16::


File: python-lib-jp.info,  Node: ASTオブジェクトを作成する,  Next: ASTオブジェクトを変換する,  Prev: parser,  Up: parser

ASTオブジェクトを作成する
-------------------------

ASTオブジェクトはソースコードあるいは解析木から作られます。ASTオブジェクトをソースから作るときは、`'eval''と`'exec''形式を作成するために別々の関数が使われます。

`expr(source)'
     まるで`compile(SOURCE, 'file.py',
     'eval')'への入力であるかのように、`expr()'関数はパラメータSOURCEを構文解析します。解析が成功した場合は、ASTオブジェクトは内部解析木表現を保持するために作成されます。そうでなければ、適切な例外を発生させます。

`suite(source)'
     まるで`compile(SOURCE, 'file.py',
     'exec')'への入力であるかのように、`suite()'関数はパラメータSOURCEを構文解析します。解析が成功した場合は、ASTオブジェクトは内部解析木表現を保持するために作成されます。そうでなければ、適切な例外を発生させます。

`sequence2ast(sequence)'
     この関数はシーケンスとして表現された解析木を受け取り、可能ならば内部表現を作ります。木がPythonの文法に合っていることと、すべてのノードがPythonのホストバージョンで有効なノード型であることを確認した場合は、ASTオブジェクトが内部表現から作成されて呼び出し側へ返されます。内部表現の作成に問題があるならば、あるいは木が正しいと確認できないならば、`ParserError'例外を発生します。この方法で作られたASTオブジェクトが正しくコンパイルできると決めつけない方がよいでしょう。ASTオブジェクトが`compileast()'へ渡されたとき、コンパイルによって送出された通常の例外がまだ発生するかもしれません。これは(`MemoryError'例外のような)構文に関係していない問題を示すのかもしれないし、`del
     f(0)'を解析した結果のようなコンストラクトが原因であるかもしれません。このようなコンストラクトはPythonのパーサを逃れますが、バイトコードインタープリタによってチェックされます。

     終端トークンを表すシーケンスは、`(1,
     'name')'形式の二つの要素のリストか、または`(1, 'name',
     56)'形式の三つの要素のリストです。三番目の要素が存在する場合は、有効な行番号だとみなされます。行番号が指定されるのは、入力木の終端記号の一部に対してです。

`tuple2ast(sequence)'
     これは`sequence2ast()'と同じ関数です。このエントリポイントは後方互換性のために維持されています。

