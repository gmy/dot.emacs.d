This is python-lib-jp.info, produced by makeinfo version 4.5 from
python-lib-jp.texi.

12 October 2005


File: python-lib-jp.info,  Node: threading,  Next: dummy_thread,  Prev: thread,  Up: オプションのオペレーティングシステムサービス

高水準のスレッドインタフェース
==============================

高水準のスレッドインタフェース

このモジュールでは、高水準のスレッドインタフェースを
より低水準な`thread' モジュールの上に構築しています。

また、`thread' がないために`threading' を使えないような
状況向けに`dummy_threading' を提供しています。

このモジュールでは以下のような関数とオブジェクトを定義しています:

`activeCount()'
     現在のアクティブな`Thread'オブジェクトの数を返します。 この数は
     `enumerate()' の返すリストの長さと同じです。

`Condition()'
     新しい条件変数 (condition variable)
     オブジェクトを返すファクトリ関数です。
     条件変数を使うと、ある複数のスレッドを別のスレッドの通知があるまで
     待機させられます。

`currentThread()'
     関数を呼び出している処理のスレッドに対応する `Thread'
     オブジェクトを 返します。関数を呼び出している処理のスレッドが
     `threading' モジュール
     で生成したものでない場合、限定的な機能しかもたないダミースレッドオブジェクト
     を返します。

`enumerate()'
     現在アクティブな `Thread' オブジェクト全てのリストを返します。
     リストには、デーモンスレッド (daemonic thread)、 `currentThread()'
     の生成するダミースレッドオブジェクト、
     そして主スレッドが入ります。終了したスレッドとまだ開始していないスレッド
     は入りません。

`Event()'
     新たなイベントオブジェクトを返すファクトリ関数です。 イベントは
     `set()' メソッドを使うと `True' に、 `clear()' メソッドを使うと
     `False' にセットされるような フラグを管理します。`wait()'
     メソッドは、全てのフラグが
     真になるまでブロックするようになっています。

`Lock()'
     新しいプリミティブロック (primitive lock)
     オブジェクトを返すファクトリ 関数です。
     スレッドが一度プリミティブロックを獲得すると、それ以後のロック獲得の試みは
     ロックが解放されるまでブロックします。どのスレッドでもロックを解放できます。

`RLock()'
     新しい再入可能ロックオブジェクトを返すファクトリ関数です。
     再入可能ロックはそれを獲得したスレッドによって解放されなければなりません。
     いったんスレッドが再入可能ロックを獲得すると、
     同じスレッドはブロックされずにもう一度それを獲得できます;
     そのスレッドは獲得した回数だけ解放しなければいけません。

`Semaphore([value])'
     新しいセマフォ (semaphore) オブジェクトを返すファクトリ関数です。
     セマフォは、`release()'を呼び出した数から`acquire()'
     を呼び出した数を引き、初期値を足した値を表すカウンタを管理します。
     `acquire()'メソッドは、カウンタの値を負にせずに処理を戻せるまで
     必要ならば処理をブロックします。 VALUE
     を指定しない場合、デフォルトの値は 1 になります。

`BoundedSemaphore([value])'
     新しい有限セマフォ (bounded semaphore) オブジェクトを返す
     ファクトリ関数です。有限セマフォは、現在の値が初期値を超過しないよう
     チェックを行います。超過を起こした場合、`ValueError' を
     送出します。たいていの場合、セマフォは限られた容量のリソースを
     保護するために使われるものです。従って、あまりにも頻繁なセマフォの解放は
     バグが生じているしるしです。 VALUE
     を指定しない場合、デフォルトの値は 1 になります。

`Thread'
     {} 処理中のスレッドを表すクラスです。
     このクラスは制限のある範囲内で安全にサブクラス化できます。

`Timer'
     {} 指定時間経過後に関数を実行するスレッドです。

`settrace(func)'
     `threading' モジュールを使って開始した全てのスレッドに トレース関数
     を設定します。 FUNC は各スレッドの`run()' を呼び出す前に
     スレッドの`sys.settrace()' に渡されます。 _Added in Python version
     2.3_

`setprofile(func)'
     `threading' モジュールを使って開始した全てのスレッドに
     プロファイル関数  を設定します。 FUNC は各スレッドの`run()'
     を呼び出す前に スレッドの`sys.settrace()' に渡されます。 _Added in
     Python version 2.3_

オブジェクトの詳細なインターフェースを以下に説明します。

このモジュールのおおまかな設計は Java のスレッドモデルに基づいています。
とはいえ、Java がロックと条件変数を全てのオブジェクトの基本的な挙動に
しているのに対し、 Python ではこれらを別個のオブジェクトに分けています。
Python の `Thread' クラスがサポートしているのは Java の Thread
クラスの挙動のサブセットにすぎません; 現状では、優先度 (priority)や
スレッドグループがなく、スレッドの破壊 (destroy)、中断 (stop)、
一時停止 (suspend)、復帰 (resume)、割り込み (interrupt) は行えません。
Java の Thread クラスにおける静的メソッドに対応する機能が実装されている
場合には、、モジュールレベルの関数になっています。

以下に説明するメソッドは全て原子的 (atomic) に実行されます。

* Menu:

* Lock オブジェクト::
* RLock オブジェクト::
* Condition オブジェクト::
* Semaphore オブジェクト::
* Event オブジェクト::
* Thread オブジェクト::
* Timer オブジェクト::


File: python-lib-jp.info,  Node: Lock オブジェクト,  Next: RLock オブジェクト,  Prev: threading,  Up: threading

Lock オブジェクト
-----------------

プリミティブロックとは、ロックが生じた際に特定のスレッドによって
所有されない同期プリミティブです。 Python では現在のところ
拡張モジュール`thread' で直接実装されている
最も低水準の同期プリミティブを使えます。

プリミティブロックは2つの状態、 "ロック"または"アンロック"
があります。このロックはアンロック状態で作成されます。
ロックには基本となる二つのメソッド、`acquire()'と `release()'
があります。ロックの状態がアンロックである 場合、`acquire()'
は状態をロックに変更して即座に処理を
戻します。状態がロックの場合、`acquire()'は他のスレッドが `release()'
を呼出してロックの状態をアンロックに変更するまで
ブロックします。その後、状態をロックに再度設定してから処理を戻します。
`release()' メソッドを呼び出すのはロック状態のときでなければ
なりません; このメソッドはロックの状態をアンロックに変更し、即座に
処理を戻します。複数のスレッドにおいて `acquire()' が
アンロック状態への遷移を待っているためにブロックが起きている時に
`release()' を呼び出してロックの状態をアンロックにすると、
一つのスレッドだけが処理を進行できます。どのスレッドが処理を
進行できるのかは定義されておらず、実装によって異なるかもしれません。

全てのメソッドは原子的に実行されます。

`acquire([blocking` = 1'])'
     ブロックあり、またはブロックなしでロックを獲得します。

     引数なしで呼び出した場合、ロックの状態がアンロックになるまで
     ブロックし、その後状態をロックにセットして処理を戻します。
     この場合は値を返しません。

     引数BLOCKING の値を真にして呼び出した場合、
     引数なしで呼び出したときと同じことを行ない、Trueを返します。

     引数BLOCKING の値を偽にして呼び出すとブロックしません。
     引数なしで呼び出した場合にブロックするような状況であった場合には
     直ちに偽を返します。それ以外の場合には、
     引数なしで呼び出したときと同じ処理を行い真を返します。


`release()'
     ロックを解放します。

     ロックの状態がロックのとき、状態をアンロックにリセットして処理を
     戻します。他のスレッドがロックがアンロック状態になるのを待って
     ブロックしている場合、ただ一つのスレッドだけが処理を継続できるように
     します。

     ロックがアンロック状態のとき、このメソッドを呼び出してはなりません。

     戻り値はありません。


File: python-lib-jp.info,  Node: RLock オブジェクト,  Next: Condition オブジェクト,  Prev: Lock オブジェクト,  Up: threading

RLock オブジェクト
------------------

再入可能ロック (reentrant lock)
とは、同じスレッドが複数回獲得できるような
同期プリミティブです。再入可能ロックの内部では、プリミティブロックの使う
ロック／アンロック状態に加え、 "所有スレッド (owning thread)" と
"再帰レベル (recursion level)" という概念を用いています。
ロック状態では何らかのスレッドがロックを所有しており、アンロック状態では
いかなるスレッドもロックを所有していません。

スレッドがこのロックの状態をロックにするには、ロックの`acquire()'
メソッドを呼び出します。このメソッドは、スレッドがロックを所有すると
処理を戻します。ロックの状態をアンロックにするには`release()'
メソッドを呼び出します。 `acquire()'/`release()'
からなるペアの呼び出しはネスト できます; 最後に呼び出した `release()'
(最も外側の呼び出しペア)
だけが、ロックの状態をアンロックにリセットし、`acquire()' で
ブロック中の別のスレッドの処理を進行させられます。

`acquire([blocking` = 1'])'
     ブロックあり、またはブロックなしでロックを獲得します。

     引数なしで呼び出した場合: スレッドが既にロックを所有している場合、
     再帰レベルをインクリメントして即座に処理を戻します。
     それ以外の場合、他のスレッドがロックを所有していれば、
     そのロックの状態がアンロックになるまでブロックします。その後、
     ロックの状態がアンロックになる
     (いかなるスレッドもロックを所有しない状態 になる)
     と、ロックの所有権を獲得し、再帰レベルを 1 にセットして処理を
     戻します。ロックの状態がアンロックになるのを待っているスレッドが複数
     ある場合、その中の一つだけがロックの所有権を獲得できます。この場合、
     戻り値はありません。

     BLOCKING 引数の値を真にした場合、引数なしで呼び出した場合と
     同じ処理を行って真を返します。

     BLOCKING 引数の値を偽にした場合、ブロックしません。
     引数なしで呼び出した場合にブロックするような状況であった場合には
     直ちに偽を返します。それ以外の場合には、
     引数なしで呼び出したときと同じ処理を行い真を返します。

`release()'
     再帰レベルをデクリメントしてロックを解放します。
     デクリメント後に再帰レベルがゼロになった場合、ロックの状態を
     アンロック (いかなるスレッドにも所有されていない状態)
     にリセットし、
     ロックの状態がアンロックになるのを待ってブロックしているスレッドが
     ある場合にはその中のただ一つだけが処理を進行できるようにします。
     デクリメント後も再帰レベルがゼロでない場合、ロックの状態はロックの
     ままで、呼び出し手のスレッドに所有されたままになります。

     呼び出し手のスレッドがロックを所有しているときにのみこのメソッドを
     呼び出してください。ロックの状態がアンロックの時にこのメソッドを
     呼び出してはなりません。

     戻り値はありません。


File: python-lib-jp.info,  Node: Condition オブジェクト,  Next: Semaphore オブジェクト,  Prev: RLock オブジェクト,  Up: threading

Condition オブジェクト
----------------------

条件変数(condition variable) は常にある種のロックに関連付けられています;
条件変数に関連付けるロックは明示的に引き渡したり、デフォルトで生成させたり
できます。 (複数の条件変数で同じロックを共有するような場合には、引渡し
による関連付けが便利です。)

条件変数には、`acquire()' メソッドおよび`release()'
があり、関連付けされているロックの対応するメソッドを呼び出すように
なっています。また、 `wait()', `notify()', `notifyAll()'
といったメソッドがあります。これら三つの
メソッドを呼び出せるのは、呼び出し手のスレッドがロックを獲得している
時だけです。

`wait()'メソッドは現在のスレッドのロックを解放し、他のスレッドが
同じ条件変数に対して`notify()'または`notifyAll()' を呼び
出して現在のスレッドを起こすまでブロックします。一度起こされると、
再度ロックを獲得して処理を戻します。`wait()' にはタイムアウトも
設定できます。

`notify()'メソッドは条件変数待ちのスレッドを1つ起こします。
`notifyAll()'メソッドは条件変数待ちの全てのスレッドを起こします。

注意: `notify()'と`notifyAll()'はロックを解放しません;
従って、スレッドが起こされたとき、`wait()' の呼び出しは即座に
処理を戻すわけではなく、`notify()' または`notifyAll()'
を呼び出したスレッドが最終的にロックの所有権を放棄したときに初めて
処理を返すのです。

豆知識: 条件変数を使う典型的なプログラミングスタイルでは、
何らかの共有された状態変数へのアクセスを同期させるためにロックを使います;
状態変数が特定の状態に変化したことを知りたいスレッドは、自分の望む
状態になるまで繰り返し `wait()' を呼び出します。その一方で、
状態変更を行うスレッドは、前者のスレッドが待ち望んでいる状態で
あるかもしれないような状態へ変更を行ったときに `notify()' や
`notifyAll()' を呼び出します。例えば、以下のコードは無制限の
バッファ容量のときの一般的な生産者-消費者問題です:

     # Consume one item
     cv.acquire()
     while not an_item_is_available():
         cv.wait()
     get_an_available_item()
     cv.release()
     
     # Produce one item
     cv.acquire()
     make_an_item_available()
     cv.notify()
     cv.release()

`notify()' と`notifyAll()' のどちらを使うかは、
その状態の変化に興味を持っている待ちスレッドが一つだけなのか、あるいは
複数なのかで考えます。例えば、典型的な生産者-消費者問題では、
バッファに 1 つの要素を加えた場合には消費者スレッドを 1 つしか
起こさなくてかまいません。

`Condition([lock])'
     LOCK を指定して、`None' の値にする場合、 `Lock' または`RLock'
     オブジェクトでなければなりません。 この場合、LOCK
     は根底にあるロックオブジェクトとして使われます。
     それ以外の場合には新しい `RLock' オブジェクトを生成して 使います。

`acquire(*args)'
     根底にあるロックを獲得します。
     このメソッドは根底にあるロックの対応するメソッドを呼び出します。
     そのメソッドの戻り値を返します。

`release()'
     根底にあるロックを解放します。
     このメソッドは根底にあるロックの対応するメソッドを呼び出します。
     戻り値はありません。

`wait([timeout])'
     通知 (notify) を受けるか、タイムアウトするまで待機します。
     このメソッドを呼び出してよいのは、呼び出し手のスレッドがロックを獲得
     しているときだけです。

     このメソッドは根底にあるロックを解放し、他のスレッドが同じ条件変数に
     対して`notify()'または`notifyAll()' を呼び出して現在の
     スレッドを起こすか、オプションのタイムアウトが発生するまでブロック
     します。一度スレッドが起こされると、再度ロックを獲得して処理を戻します。

     TIMEOUT引数を指定して、`None'以外の値にする場合、 タイムアウトを秒
     (または端数秒) を表す浮動小数点数でなければなりません。

     根底にあるロックが`RLock' である場合、`release()' メソッド
     ではロックは解放されません。というのも、ロックが再帰的に複数回獲得
     されている場合には、`release()' によって実際にアンロックが
     行われないかもしれないからです。その代わり、 ロックが再帰的に複数回
     獲得されていても確実にアンロックを行える`RLock' クラスの
     内部インタフェースを使います。その後ロックを再獲得する時に、
     もう一つの内部インタフェースを使ってロックの再帰レベルを復帰します。

`notify()'
     この条件変数を待っているスレッドがあれば、そのスレッドを起こします。
     このメソッドを呼び出してよいのは、呼び出し手のスレッドがロックを獲得
     しているときだけです。

     何らかの待機中スレッドがある場合、そのスレッドの一つを起こします。
     待機中のスレッドがなければ何もしません。

     現在の実装では、待機中のメソッドをただ一つだけ起こします。
     とはいえ、この挙動に依存するのは安全ではありません。
     将来、実装の最適化によって、複数のスレッドを起こすようになるかも
     しれないからです。

     注意: 起こされたスレッドは実際にロックを再獲得できるまで`wait()'
     呼出しから戻りません。`notify()'はロックを解放しないので、
     `notify()' 呼び出し手は明示的にロックを解放せねばなりません。

`notifyAll()'
     この条件を待っているすべてのスレッドを起こします。
     このメソッドは`notify()' のように動作しますが、 1
     つではなくすべての待ちスレッドを起こします。


File: python-lib-jp.info,  Node: Semaphore オブジェクト,  Next: Event オブジェクト,  Prev: Condition オブジェクト,  Up: threading

Semaphore オブジェクト
----------------------

セマフォ (semaphore)
は、計算機科学史上最も古い同期プリミティブの一つで、
草創期のオランダ計算機科学者 Edsger W. Dijkstra によって発明されました
(彼は`acquire()'と`release()'の代わりに `P()'と`V()'を使いました)。

セマフォは`acquire()' でデクリメントされ`release()'で
インクリメントされるような内部カウンタを管理します。
カウンタは決してゼロより小さくはなりません; `acquire()' は、
カウンタがゼロになっている場合、他のスレッドが`release()'
を呼び出すまでブロックします。

`Semaphore([value])'
     オプションの引数には、内部カウンタの初期値を指定します。
     デフォルトは`1'です。

`acquire([blocking])'
     セマフォを獲得します。

     引数なしで呼び出した場合: `acqure()' 処理に入ったときに
     内部カウンタがゼロより大きければ、カウンタを 1 デクリメントして
     即座に処理を戻します。`acqure()' 処理に入ったときに
     内部カウンタがゼロの場合、他のスレッドが `release()'
     を呼び出してカウンタをゼロより大きくするまでブロックします。
     この処理は、適切なインターロック (interlock) を介して行い、 複数の
     `acquire()' 呼び出しがブロックされた場合、 `release()'
     が正確に一つだけを起こせるようにします。
     この実装はランダムに一つ選択するだけでもよいので、ブロックされた
     スレッドがどの起こされる順番に依存してはなりません。
     この場合、戻り値はありません。

     BLOCKING 引数の値を真にした場合、引数なしで呼び出した場合と
     同じ処理を行って真を返します。

     BLOCKING 引数の値を偽にした場合、ブロックしません。
     引数なしで呼び出した場合にブロックするような状況であった場合には
     直ちに偽を返します。それ以外の場合には、
     引数なしで呼び出したときと同じ処理を行い真を返します。

`release()'
     内部カウンタを 1 インクリメントして、セマフォを解放します。
     `release()' 処理に入ったときにカウンタがゼロであり、
     カウンタの値がゼロより大きくなるのを待っている別のスレッドが
     あった場合、そのスレッドを起こします。

* Menu:

* Semaphore の例::


File: python-lib-jp.info,  Node: Semaphore の例,  Prev: Semaphore オブジェクト,  Up: Semaphore オブジェクト

`Semaphore' の例
................

セマフォはしばしば、容量に限りのある資源、例えばデータベースサーバなど
を保護するために使われます。リソースのサイズが固定の状況では、常に
有限セマフォを使わねばなりません。主スレッドは、作業スレッドを
立ち上げる前にセマフォを初期化します:

     maxconnections = 5
     ...
     pool_sema = BoundedSemaphore(value=maxconnections)

作業スレッドは、ひとたび立ち上がると、サーバへ接続する必要が
生じたときにセマフォの`acquire' および`release' メソッドを呼び出します:

     pool_sema.acquire()
     conn = connectdb()
     ... use connection ...
     conn.close()
     pool_sema.release()

有限セマフォを使うと、セマフォを獲得回数以上に解放してしまうという
プログラム上の間違いを見逃しにくくします。


File: python-lib-jp.info,  Node: Event オブジェクト,  Next: Thread オブジェクト,  Prev: Semaphore オブジェクト,  Up: threading

Event オブジェクト
------------------

イベントは、あるスレッドがイベントを発信し、他のスレッドはそれを
待つという、スレッド間で通信を行うための最も単純なメカニズムの一つです。

イベントオブジェクトは内部フラグを管理します。このフラグは`set()'
メソッドで値を真に、`clear()'メソッドで値を偽にリセットします。
`wait()'メソッドはフラグがTrueになるまでブロックします。

`Event()'
     内部フラグの初期値は偽です。

`isSet()'
     内部フラグの値が真である場合かつその場合にのみ真を返します。

`set()'
     内部フラグの値を真にセットします。
     フラグの値が真になるのを待っている全てのスレッドを起こします。
     一旦フラグが真になると、スレッドが`wait()' を呼び出しても
     全くブロックしなくなります。

`clear()'
     内部フラグの値を偽にリセットします。 以降は、`set()'
     を呼び出して再び内部フラグの値を真にセットするまで、 `wait()'
     を呼出したスレッドはブロックするようになります。

`wait([timeout])'
     内部フラグの値が真になるまでブロックします。 `wait()'
     処理に入った時点で内部フラグの値が真であれば、
     直ちに処理を戻します。そうでない場合、他のスレッドが`set()'を
     呼び出してフラグの値を真にセットするか、オプションのタイムアウトが
     発生するまでブロックします。

     TIMEOUT引数を指定して、`None'以外の値にする場合、 タイムアウトを秒
     (または端数秒) を表す浮動小数点数でなければなりません。


File: python-lib-jp.info,  Node: Thread オブジェクト,  Next: Timer オブジェクト,  Prev: Event オブジェクト,  Up: threading

Thread オブジェクト
-------------------

このクラスは個別のスレッド中で実行される活動 (activity) を表現します。
活動を決める方法はは 2 つあり、一つは呼出し可能オブジェクトを
コンストラクタへ渡す方法、もう一つはサブクラスで`run()' メソッドを
オーバライドする方法です。(コンストラクタを除く) その他のメソッドは
一切サブクラスでオーバライドしてはなりません。言い換えるならば、
このクラスの`__init__()'と`run()'メソッド_だけ_を
オーバライドしてくださいということです。

ひとたびスレッドオブジェクトを生成すると、スレッドの`start()'
メソッドを呼び出して活動を開始せねばなりません。`start()'
メソッドはそれぞれのスレッドの `run()' メソッドを起動します。

スレッドの活動が始まると、スレッドは '生存中 (alive)' で、 '活動中
(active)' とみなされます (これら二つの概念はほとんど
同じですが、全く同じというわけではありません; これら二つは意図的に
曖昧に定義されているのです)。
スレッドの活動は、通常終了、あるいは処理されない例外が送出されたことで
`run()' メソッドが終了すると生存中でなくなり、かつ活動中で
なくなります。`isAlive()' メソッドはスレッドが生存中であるか
どうか調べます。

他のスレッドはスレッドの `join()' メソッドを呼び出せます。
このメソッドは、`join()' を呼び出されたスレッドが終了するまで、
メソッドの呼び出し手となるスレッドをブロックします。

スレッドには名前があります。名前はコンストラクタで渡したり、
`setName()' メソッドで設定したり、`getName()'
メソッドで取得したりできます。

スレッドには "デーモンスレッド (daemon thread)" であるというフラグを
立てられます。
このフラグには、残っているスレッドがデーモンスレッドだけになった時に
Python プログラム全体を終了させるという意味があります。フラグの初期値は
スレッドを生成する側のスレッドから継承します。フラグの値は
`setDaemon()'メソッドで設定でき、`isDaemon()'メソッドで 取得できます。

スレッドには "主スレッド (main thread)" オブジェクトがあります。
主スレッドは Python プログラムを最初に制御していたスレッドです。
主スレッドはデーモンスレッドではありません。

"ダミースレッド (dumm thread)" オブジェクトを作成できる場合があります。
ダミースレッドは、 "外来スレッド (alien thread)" に相当する
スレッドオブジェクトです。ダミースレッドは、C コードから直接生成された
スレッドのような、 `threading' モジュールの外で開始された
処理スレッドです。ダミースレッドオブジェクトには限られた機能しかなく、
常に生存中、活動中かつデーモンスレッドであるとみなされ、`join()'
できません。また、外来スレッドの終了を検出するのは不可能なので、
ダミースレッドは削除できません。

`Thread(group=None, target=None, name=None, args=(), kwargs={})'
     コンストラクタは常にキーワード引数を使って呼び出さねばなりません。
     各引数は以下の通りです:

     GROUP は`None' にせねばなりません。 将来`ThreadGroup'
     クラスが実装されたときの拡張用に予約されている 引数です。

     TARGET は`run()' メソッドによって起動される
     呼出し可能オブジェクトです。
     デフォルトでは何も呼び出さないことを示す `None' になっています。

     NAMEはスレッドの名前です。デフォルトでは、 N を小さな 10
     進数として、"Thread-N" という形式の一意な名前を生成します。

     ARGS はTARGET を呼び出すときの引数タプルです。
     デフォルトは`()'です。

     KWARGS はTARGET を呼び出すときのキーワード引数の辞書です。
     デフォルトは`{}'です。

     サブクラスでコンストラクタをオーバライドした場合、
     必ずスレッドが何かを始める前に基底クラスのコンストラクタ
     (`Thread.__init__()') を呼び出しておかなくてはなりません。

`start()'
     スレッドの活動を開始します。

     このメソッドは、スレッドオブジェクトあたり一度しか呼び出しては
     なりません。`start()' は、オブジェクトの `run()'
     メソッドが個別の処理スレッド中で呼び出されるように調整します。

`run()'
     スレッドの活動をもたらすメソッドです。

     このメソッドはサブクラスでオーバライドできます。 標準の`run()'
     メソッドでは、オブジェクトのコンストラクタの TARGET
     引数に呼び出し可能オブジェクトを指定した場合、 ARGS
     およびKWARGSの引数列およびキーワード引数とともに 呼び出します。

`join([timeout])'
     スレッドが終了するまで待機します。 このメソッドは、`join()'
     を呼び出されたスレッドが、
     正常終了あるいは処理されない例外によって終了するか、オプションの
     タイムアウトが発生するまで、メソッドの呼び出し手となるスレッドを
     ブロックします。

     TIMEOUT引数を指定して、`None'以外の値にする場合、 タイムアウトを秒
     (または端数秒) を表す浮動小数点数でなければなりません。

     一つのスレッドに対して何度でも `join()' できます。

     スレッドは自分自身を`join()' できません。デッドロックを引き起こす
     からです。

     スレッドを開始するまえに`join()' を試みるのは誤りです。

`getName()'
     スレッドの名前を返します。

`setName(name)'
     スレッドの名前を設定します。

     名前は識別のためだけに使われます。名前には機能上の意味づけ
     (semantics)
     はありません。複数のスレッドに同じ名前をつけてもかまいません。
     名前の初期値はコンストラクタで設定されます。

`isAlive()'
     スレッドが生存中かどうかを返します。

     大雑把な言い方をすると、スレッドは `start()' メソッドを呼び出した
     瞬間から `run()' メソッドが終了するまでの間生存しています。

`isDaemon()'
     スレッドのデーモンフラグを返します。

`setDaemon(daemonic)'
     スレッドのデーモンフラグをブール値DAEMONIC に設定します。
     このメソッドは `start()' を呼び出す前に呼び出さねばなりません。

     初期値は生成側のスレッドから継承されます。

     デーモンでない活動中のスレッドが全てなくなると、Python
     プログラム全体 が終了します。


File: python-lib-jp.info,  Node: Timer オブジェクト,  Prev: Thread オブジェクト,  Up: threading

Timer オブジェクト
------------------

このクラスは、一定時間経過後に実行される活動、すなわちタイマ活動
を表現します。`Timer' は`Thread' のサブクラスであり、
自作のスレッドを構築した一例でもあります。

タイマは `start()' メソッドを呼び出すとスレッドとして作動し始め
します。(活動を開始する前に) `cancel()' メソッドを呼び出すと、
タイマを停止できます。タイマが活動を実行するまでの待ち時間は、ユーザ
が指定した待ち時間と必ずしも厳密には一致しません。

例:
     def hello():
         print "hello, world"
     
     t = Timer(30.0, hello)
     t.start() # after 30 seconds, "hello, world" will be printed

`Timer(interval, function, args=[], kwargs={})'
     INTERVAL 秒後にFUNCTION を引数 ARGS、キーワード引数 KWARGS
     つきで実行するようなタイマを生成します。

`cancel()'
     タイマをストップして、その動作の実行をキャンセルします。
     このメソッドはタイマがまだ活動待ち状態にある場合にのみ動作します。


File: python-lib-jp.info,  Node: dummy_thread,  Next: dummy_threading,  Prev: threading,  Up: オプションのオペレーティングシステムサービス

`thread' の代替モジュール
=========================

`thread' の代替モジュール。

このモジュールは `thread' モジュールのインターフェースをそっ
くりまねるものです。`thread' モジュールがサポートされていな
いプラットフォームで import することを意図して作られたものです。

使用例:

     try:
         import thread as _thread
     except ImportError:
         import dummy_thread as _thread

生成するスレッドが、他のブロックしたスレッドを待ち、デッドロック発生の
可能性がある場合には、このモジュールを使わないようにしてください。ブロッ
キング I/O を使っている場合によく起きます。


File: python-lib-jp.info,  Node: dummy_threading,  Next: Queue,  Prev: dummy_thread,  Up: オプションのオペレーティングシステムサービス

`threading' の代替モジュール
============================

`threading'  の代替モジュール。

このモジュールは `threading' モジュールのインターフェースを
そっくりまねるものです。`threading' モジュールがサポートされ
ていないプラットフォームで import することを意図して作られたものです。

使用例:

     try:
         import threading as _threading
     except ImportError:
         import dummy_threading as _threading

生成するスレッドが、他のブロックしたスレッドを待ち、デッドロック発生の
可能性がある場合には、このモジュールを使わないようにしてください。ブロッ
キング I/O を使っている場合によく起きます。


File: python-lib-jp.info,  Node: Queue,  Next: mmap,  Prev: dummy_threading,  Up: オプションのオペレーティングシステムサービス

同期キュークラス
================

同期キュークラス

`Queue'モジュールは、多生産者-多消費者FIFOキューを実装します。
これは、複数のスレッドの間で情報を安全に交換しなければならないときの
スレッドプログラミングで特に有益です。 このモジュールの`Queue'クラスは、
必要なすべてのロックセマンティクスを実装しています。
これはPythonのスレッドサポートの状況に依存します。

See also:
     *Note bisect:: Queueクラスを使った優先順位付きキューの例

`Queue'モジュールは以下のクラスと例外を定義します:

`Queue(maxsize)'
     クラスのコンストラクタです。
     MAXSIZEはキューに置くことのできる要素数の上限を設定する整数です。
     いったんこの大きさに達したら、挿入はキューの要素が消費されるまでブロック
     されます。
     もしMAXSIZEが0以下であるならば、キューの大きさは無限です。

`Empty'
     空またはロックされている`Queue'オブジェクトで、
     非ブロックメソッドとして`get()'(または`get_nowait()')
     が呼ばれたとき、送出される例外です。

`Full'
     満杯またはロックされている`Queue'オブジェクトで、
     非ブロックメソッドとして`put()'(または`put_nowait()')
     が呼ばれたとき、送出される例外です。

* Menu:

* キューオブジェクト::


File: python-lib-jp.info,  Node: キューオブジェクト,  Prev: Queue,  Up: Queue

キューオブジェクト
------------------

クラス`Queue'はキューオブジェクトを実装しており、
以下のメソッドを持っています。
このクラスは、他のキュー構造(例えばスタック)を実装するために
派生させられるますが、継承可能なインタフェースはここでは説明しません。
詳しいことはソースコードを見てください。 公開メソッドは次のものです:

`qsize()'
     キューの大まかなサイズを返します。
     マルチスレッドセマンティクスにおいて、この値は信頼できません。

`empty()'
     キューが空なら`True'を返し、そうでないなら`False'を返します。
     マルチスレッドセマンティクスにおいて、この値は信頼できません。

`full()'
     キューが満杯なら`True'を返し、そうでないなら`False'を返します。
     マルチスレッドセマンティクスにおいて、この値は信頼できません。

`put(item[, block[, timeout]])'
     ITEMをキューに入れます。
     もしオプション引数BLOCKがTrueでTIMEOUTがNone(デフォルト)ならば、
     フリースロットが利用可能になるまでブロックします。
     TIMEOUTが正の値の場合、最大でTIMEOUT秒間ブロックし、
     その時間内に空きスロットが利用可能にならなければ、
     例外`Full'を送出します。
     他方(BLOCKがFalse)、直ちにフリースロットが利用できるならば、
     キューにアイテムを置きます。できないならば、例外`Full'を送出します
     (この場合TIMEOUTは無視されます)。

     _Added in Python version 2.3_


`put_nowait(item)'
     `put(ITEM, False)'と同じ意味です。

`get([block[, timeout]])'
     キューからアイテムを取り除き、それを返します。
     もしオプション引数BLOCKがTrueでTIMEOUTがNone(デフォルト)ならば、
     アイテムが利用可能になるまでブロックします。
     もしTIMEOUTが正の値の場合、最大でTIMEOUT秒間ブロックし、
     その時間内でアイテムが利用可能にならなければ、
     例外`Empty'を送出します。
     他方(BLOCKがFalse)、直ちにアイテムが利用できるならば、
     それを返します。できないならば、例外`Empty'を送出します
     (この場合TIMEOUTは無視されます)。

     _Added in Python version 2.3_


`get_nowait()'
     `get(False)'と同じ意味です。


File: python-lib-jp.info,  Node: mmap,  Next: anydbm,  Prev: Queue,  Up: オプションのオペレーティングシステムサービス

メモリマップファイル
====================

UNIX とWindowsのメモリマップファイルへのインターフェース

メモリにマップされたファイルオブジェクトは、
文字列とファイルオブジェクトの両方のように振舞います。
しかし通常の文字列オブジェクトとは異なり、これらは可変です。
文字列が期待されるほとんどの場所でmmapオブジェクトを利用できます。
例えば、メモリマップファイルを探索するために
`re'モジュールを使うことができます。 それらは可変なので、 `obj[INDEX] =
'a'' のように文字を 変換できますし、スライスを使うことで  `obj[I1:I2] =
'...'' のように 部分文字列を変換することができます。
現在のファイル位置をデータの始めとする読込みや書込み、
ファイルの異なる位置へ`seek()'することもできます。

メモリマップファイルはUNIX上とWindows上とでは異なる
`mmap()'関数によって作られます。
いずれの場合も、開いたファイルのディスクリプタを、
更新のために提供しなければなりません。
すでに存在するPythonファイルオブジェクトをマップしたい場合は、
FILENOパラメータのための現在値を手に入れるために、
`fileno()'メソッドを使用して下さい。
そうでなければ、ファイル・ディスクリプタを直接返す`os.open()'関数
(呼び出すときにはまだファイルが閉じている必要があります)を使って、
ファイルを開くことができます。

関数のUNIXバージョンとWindowsバージョンのために、
オプションのキーワード・パラメータとしてACCESSを指定する
ことになるかもしれません。 ACCESSは3つの値の内の1つを受け入れます。
`ACCESS_READ'は読み込み専用、 `ACCESS_WRITE'は書き込み可能、
`ACCESS_COPY'はコピーした上での書き込みです。
ACCESSはUNIXとWindowsの両方で使用することができます。
ACCESSが指定されない場合、Windowsのmmapは書き込み可能マップを返します。
3つのアクセス型すべてに対する初期メモリ値は、
指定されたファイルから得られます。
`ACCESS_READ'を割り当てたメモリマップは `TypeError'例外を送出します。
`ACCESS_WRITE'を割り当てたメモリマップは
メモリと元のファイルの両方に影響を与えます。
`ACCESS_COPY'を割り当てたメモリマップは
メモリに影響を与えますが、元のファイルを更新することはありません。

`mmap(fileno, length[, tagname[, access]])'
     *(Windows)*バージョンはファイルハンドルFILENOによって
     指定されたファイルからLENGTHバイトをマップして、
     mmapオブジェクトを返します。 LENGTH
     が現在のファイルのサイズより大きい場合、 LENGTH
     バイトが入るようにファイルを延長します。
     LENGTHが`0'の場合、マップの最大の長さは
     `mmap()'が呼ばれたときのファイルサイズになるでしょう。
     ただし、ファイルが空の場合には、Windows は例外を送出します
     (つまり、Windows では空のマップファイルを作成できません。)

     TAGNAMEは、`None'以外で指定された場合、
     マップのタグ名を与える文字列となります。
     Windowsは同じファイルに対する様々なマップを持つことを可能にします。
     既存のタグの名前を指定すればそのタグがオープンされ、
     そうでなければこの名前の新しいタグが作成されます。
     もしこのパラメータを省略したり`None'を与えたりしたならば、
     マップは名前なしで作成されます。
     タグ・パラメータの使用の回避は、あなたのコードをUNIXとWindowsの間で
     移植可能にしておくのを助けてくれるでしょう。

`mmap(fileno, length[, flags[, prot[, access]]])'
     *(UNIX)*バージョンは、ファイル・ディスクリプタ FILENOに
     よって指定されたファイルからLENGTHバイトをマップし、
     mmapオブジェクトを返します。

     FLAGSはマップの種類を指定します。
     `MAP_PRIVATE'はプライベートなcopy-on-write(書込み時コピー)
     のマップを作成します。
     従って、mmapオブジェクトの内容への変更はこのプロセス内にのみ有効です。
     `MAP_SHARED'はファイルの同じ領域をマップする他のすべてのプロセス
     と共有されたマップを作成します。 デフォルトは`MAP_SHARED'です。

     PROTが指定された場合、希望のメモリ保護を与えます。
     2つの最も有用な値は、`PROT_READ'と`PROT_WRITE'です。
     これは、読込み可能または書込み可能を指定するものです。
     PROTのデフォルトは`PROT_READ | PROT_WRITE'です。

     ACCESSはオプションのキーワード・パラメータとして、
     FLAGSとPROTの代わりに指定してもかまいません。
     FLAGS,PROTとACCESSの両方を指定することは間違っています。
     このパラメーターを使用法についての情報は、
     ACCESSの記述を参照してください。

メモリマップフィイルオブジェクトは以下のメソッドをサポートしています:

`close()'
     ファイルを閉じます。
     この呼出しの後にオブジェクトの他のメソッドの呼出すことは、
     例外の送出を引き起こすでしょう。

`find(string[, start])'
     オブジェクト内で部分文字列STRINGが見つかった場所の最も小さい
     インデックスを返します。 失敗したとき`-1'を返します。
     STARTは探索を始めたい場所のインデックスで、デフォルトは0です。

`flush([offset, size])'
     ファイルのメモリコピー内での変更をディスクへフラッシュします。
     この呼出しを使わなかった場合、オブジェクトが破壊される前に
     変更が書き込まれる保証はありません。
     もしOFFSETとSIZEが指定された場合、与えられたバイトの範囲の
     変更だけがディスクにフラッシュされます。
     指定されない場合、マップ全体がフラッシュされます。

`move(DEST, SRC, COUNT)'
     オフセットSRCからインデックスDESTへCOUNTバイトだけ コピーします。
     もしmmapが`ACCESS_READ'で作成されていた場合、
     `TypeError'例外を送出します。

`read(NUM)'
     現在のファイル位置からNUMバイトの文字列を返します。
     ファイル位置は返したバイトの分だけ後ろの位置へ更新されます。

`read_byte()'
     現在のファイル位置から長さ1の文字列を返します。
     ファイル位置は1だけ進みます。

`readline()'
     現在のファイル位置から次の新しい行までの、1行を返します。

`resize(NEWSIZE)'
     もしmmapが`ACCESS_READ'または`ACCESS_COPY'で
     作成されたならば、マップのリサイズは`TypeError'例外を送出します。

`seek(pos[, whence])'
     ファイルの現在位置をセットします。
     WHENCE引数はオプションであり、デフォルトは`0'(絶対位置)です。
     その他の値として、`1'(現在位置からの相対位置)と
     `2'(ファイルの終わりからの相対位置)があります。

`size()'
     ファイルの長さを返します。
     メモリマップ領域のサイズより大きいかもしれません。

`tell()'
     ファイル・ポインタの現在位置を返します。

`write(STRING)'
     メモリ内のファイル・ポインタの現在位置からSTRINGのバイト列を
     書き込みます。
     ファイル位置はバイト列が書き込まれた後の位置へ更新されます。
     もしmmapが`ACCESS_READ'で作成されていた場合、
     書き込み時に`TypeError'例外が送出されるでしょう。

`write_byte(BYTE)'
     メモリ内のファイル・ポインタの現在位置から
     単一文字の文字列BYTEを書き込みます。
     ファイル位置は`1'だけ進みます。
     もしmmapが`ACCESS_READ'で作成されていた場合、
     書き込み時に`TypeError'例外が送出されるでしょう。


File: python-lib-jp.info,  Node: anydbm,  Next: dbhash,  Prev: mmap,  Up: オプションのオペレーティングシステムサービス

DBM 形式のデータベースへの汎用アクセスインタフェース
====================================================

DBM 形式のデータベースモジュールに対する汎用インタフェース。

`anydbm' は種々の DBM データベース -- (`bsddb'  を使う) `dbhash'  、
`gdbm' 、および `dbm' -- への汎用インタフェースです。
これらのモジュールがどれもインストールされていない場合、 `dumbdbm'
モジュールの 低速で単純な DBM 実装が使われます。

`open(filename[, flag[, mode]])'
     データベースファイル FILENAME を開き、対応するオブジェクトを
     返します。

     データベースファイルがすでに存在する場合、`whichdb' モジュール
     を使ってファイルタイプが判定され、適切なモジュールが使われます;
     既存のデータベースファイルが存在しなかった場合、上に挙げたモジュール中で
     最初にインポートすることができたものが使われます。

     オプションの FLAG は 既存のデータベースを読み込み専用で開く `'r''、
     既存のデータベースを読み書き用に開く `'w''、
     既存のデータベースが存在しない場合には新たに作成する `'c''、および
     常に新たにデータベースを作成する `'n'' をとることができます。
     この引数が指定されない場合、標準の値は `'r'' になります。

     オプションの MODE
     引数は、新たにデータベースを作成しなければならない 場合に使われる
     UNIX のファイルモードです。標準の値は 8 進数の `0666' です
     (この値は現在有効な umask で修飾されます)。

`error'
     サポートされているモジュールのどれかによって送出されうる例外が
     収められるタプルで、先頭の要素は `anydbm.error' になって います --
     `anydbm.error' が送出された場合、後者が使われます。

`open()' によって返されたオブジェクトは辞書とほとんど同じ
同じ機能をサポートします; キーとそれに対応付けられた値を
記憶し、引き出し、削除することができ、`has_key()' および `keys()'
メソッドを使うことができます。キーおよび値は 常に文字列です。

See also:
     *Note dbhash:: BSD `db' データベースインタフェース。 *Note dbm::
     標準の UNIX データベースインタフェース。 *Note dumbdbm:: `dbm'
     インタフェースの移植性のある実装。 *Note gdbm:: `dbm'
     インタフェースに基づいた GNU データベースインタフェース。 *Note
     shelve:: Python `dbm' インタフェース上に構築された
     汎用オブジェクト永続化機構。 *Note whichdb::
     既存のデータベースがどの形式のデータベースか判定する
     ユーティリティモジュール。


File: python-lib-jp.info,  Node: dbhash,  Next: whichdb,  Prev: anydbm,  Up: オプションのオペレーティングシステムサービス

BSD データベースライブラリへの DBM 形式のインタフェース
=======================================================

BSD データベースライブラリへの DBM 形式のインタフェース。

`dbhash' モジュールでは BSD `db' ライブラリを使って
データベースを開くための関数を提供します。このモジュールは、 DBM 形式
のデータベースへのアクセスを提供する他の Python データベースモジュールの
インタフェースをそのまま反映しています。 `dbhash' を使うには `bsddb'
モジュールが必要です。

このモジュールでは一つの例外と一つの関数を提供しています:

`error'
     `KeyError' 以外のデータベースのエラーで送出されます。
     `bsddb.error' と同じ意味です。

`open(path[, flag[, mode]])'
     データベース `db' を開き、データベースオブジェクトを返します。
     引数 PATH はデータベースファイルの名前です。

     引数 FLAG は `'r'' (標準の値)、 `'w''、`'c''
     (データベースが存在しない場合には作成する)、あるいは `'n''
     (常に新たな空のデータベースを作成する) をとることができます。 BSD
     `db' ライブラリがファイルロックをサポートするような
     プラットフォームでは、ロックを使うよう示すために `l'
     を追加することができます。

     オプションの MODE 引数は、新たにデータベースを作成しなければ
     ならないときにデータベースファイルに設定すべき UNIX ファイル権限
     ビットを表すために使われます; この値はプロセスの現在の umask 値で
     マスクされます。

See also:
     *Note anydbm:: `dbm' 形式のデータベースへの汎用インタフェース。
     *Note bsddb:: BSD `db' ライブラリへの低レベルインタフェース。
     *Note whichdb::
     既存のデータベースがどの形式のデータベースか判定する
     ユーティリティモジュール。

* Menu:

* データベースオブジェクト::


File: python-lib-jp.info,  Node: データベースオブジェクト,  Prev: dbhash,  Up: dbhash

データベースオブジェクト
------------------------

`open()' によって返されるデータベースオブジェクトは、 全ての DBM
形式データベースやマップ型オブジェクトで共通のメソッドを
提供します。それら標準のメソッドに加え、dbhash では以下のメソッドが
利用可能です。

`first()'
     このメソッドと `next()' メソッドを使って、データベースの全ての
     キー/値のペアにわたってループ処理を行えます。探索はデータベースの
     内部ハッシュ値の順番に行われ、キーの値に順に並んでいるとは限りません。
     このメソッドは最初のキーを返します。

`last()'
     データベース探索における最後のキー/値を返します。逆順探索を開始する
     際に使うことができます; `previous()' を参照してください。

`next()'
     データベースの順方向探索において、次のよりも後に来るキー/値のペアを
     返します。以下のコードはデータベース `db' に
     ついて、キー全てを含むリストをメモリ上に生成することなく
     全てのキーを出力します。

          print db.first()
          for i in xrange(1, len(db)):
              print db.next()


`previous()'
     データベースの逆方向探索において、手前に来るキー/値のペアを
     返します。`last()' と併せて、逆方向の探索に用いられます。

`sync()'
     このメソッドはディスクにまだ書き込まれていないデータを全て書き込ませます。


File: python-lib-jp.info,  Node: whichdb,  Next: bsddb,  Prev: dbhash,  Up: オプションのオペレーティングシステムサービス

どのDBMモジュールがデータベースを作ったかを推測する
===================================================

どのDBM形式のモジュールが与えられたデータベースを作ったかを推測する

このモジュールに含まれる唯一の関数はあることを推測します。つまり、与えられたファイルを開くためには、利用可能なデータベースモジュール（`dbm'、`gdbm'、`dbhash'）のどれを用いるべきかということです。

`whichdb(filename)'
     ファイルが読めないか存在しないために開くことが出来ない場合は`None'、ファイルの形式を推測できない場合は空の文字列(`''')、推測できる場合は必要なモジュール名（`'dbm''、`'gdbm''など）を含む文字列を返します。


File: python-lib-jp.info,  Node: bsddb,  Next: dumbdbm,  Prev: whichdb,  Up: オプションのオペレーティングシステムサービス

Berkeley DB ライブラリへのインタフェース
========================================

Berkeley DB ライブラリへのインタフェース

`bsddb' モジュールは Berkeley DB ライブラリへのインタフェース
を提供します。ユーザは適当な `open' 呼び出しを使うことで、
ハッシュ、B-Tree、 またはレコードに基づくデータベースファイルを生成
することができます。bsddb オブジェクトは辞書と大体同じように振る舞い
ます。しかし、キー及び値は文字列でなければならないので、
他のオブジェクトをキーとして使ったり、他の種のオブジェクトを記録
したい場合、それらのデータを何らかの方法で直列化しなければなりません。
これには通常 marshal.dumps や pickle.dumps が使われます。

Python 2.3以降の`bsddb'モジュールは、バージョン 3.1以降のBerkeley
DBライブラリのみをサポートしています。(現時点では、3.1から4.1までのバー
ジョンでの動作を確認しています。)

See also:
    <http://pybsddb.sourceforge.net/>
          新しいBerkeley DBインターフ
          ェースのドキュメントがあります。新しいインターフェースは、Berkeley
          DB
          3と4でsleepycatが提供しているオブジェクト指向インターフェースとほぼ
          同じインターフェースとなっています。

    <http://www.sleepycat.com/>
          Sleepycat Software は、最新の Berkeley
          DBライブラリを開発しています。


以下では、従来のbsddbモジュールと互換性のある、古いインターフェースを解
説しています。現在の、Db と DbEnvによるオブジェクト指向的インターフェー
スについては上記 pybsddb のURLを参照してください。

_Notice:_ [warning] このインタフェースは旧式で、Python 2.3.x
や以前のバージョンでは
スレッド安全ではありません。マルチスレッドからアクセスを行おうとすると、
データの破壊やコアダンプ、デッドロックを引き起こすことがあります。
マルチスレッドやマルチプロセスでデータベースにアクセスする必要がある場合には、
上のリンク先にある、より新しい pybsddb
インタフェースを使わねばなりません。

`bsddb' モジュールでは、適切な形式の Berkeley DB ファイルに
アクセスするオブジェクトを生成する以下の関数を定義しています。
各関数の最初の二つの引数は同じです。可搬性のために、ほとんどの
インスタンスでは最初の二つの引数だけが使われているはずです。

`hashopen(filename[, flag[, mode[, bsize[, ffactor[, nelem[, cachesize[, hash[, lorder]]]]]]]])'
     FILENAME と名づけられたハッシュ形式のファイルを開きます。 FILENAME
     に `None' を指定することで、ディスクに保存する
     つもりがないファイルを生成することもできます。 オプションの FLAG
     には、ファイルを開くためのモードを指定します。 このモードは `r'
     (読み出し専用)、 `w' (読み書き)。 `c' (読み書き -
     必要ならファイルを生成、デフォルト)、 または`n' (読み書き -
     ファイル長を 0 に切り詰め)、に
     できます。他の引数はほとんど使われることはなく、下位レベルの
     `dbopen()' 関数に渡されるだけです。他の引数の使い方
     およびその解釈については Berkeley DB のドキュメントを読んで下さい。

`btopen(filename[, flag[, mode[, btflags[, cachesize[, maxkeypage[, minkeypage[, psize[, lorder]]]]]]]])'
     FILENAME と名づけられた B-Tree 形式のファイルを開きます。 FILENAME
     に `None' を指定することで、ディスクに保存する
     つもりがないファイルを生成することもできます。 オプションの FLAG
     には、ファイルを開くためのモードを指定します。 このモードは `r'
     (読み出し専用)、 `w' (読み書き)。 `c' (読み書き -
     必要ならファイルを生成、デフォルト)、 または`n' (読み書き -
     ファイル長を 0 に切り詰め)、に
     できます。他の引数はほとんど使われることはなく、下位レベルの
     `dbopen()' 関数に渡されるだけです。他の引数の使い方
     およびその解釈については Berkeley DB のドキュメントを読んで下さい。

`rnopen(filename[, flag[, mode[, rnflags[, cachesize[, psize[, lorder[, reclen[, bval[, bfname]]]]]]]]])'
     FILENAME と名づけられた DB レコード形式のファイルを開きます、
     FILENAME に `None' を指定することで、ディスクに保存する
     つもりがないファイルを生成することもできます、 オプションの FLAG
     には、ファイルを開くためのモードを指定します、 このモードは `r'
     (読み出し専用)、 `w' (読み書き)。 `c' (読み書き -
     必要ならファイルを生成、デフォルト)、 または`n' (読み書き -
     ファイル長を 0 に切り詰め)、に
     できます。他の引数はほとんど使われることはなく、下位レベルの
     `dbopen()' 関数に渡されるだけです、他の引数の使い方
     およびその解釈については Berkeley DB のドキュメントを読んで下さい。

See also:
     *Note dbhash:: `bsddb' への DBM 形式のインタフェース

_Notice:_
2.3以降のUnix版Pythonには、`bsddb185'モジュールが存在する場合があ
ります。このモジュールは古いBerkeley DB 1.85データベースライブラリを持つ
システムをサポートするため_だけ_に存在しています。新規に開発する
コードでは、`bsddb185'を直接使用しないで下さい。

* Menu:

* ハッシュ、BTree、およびレコードオブジェクト::

