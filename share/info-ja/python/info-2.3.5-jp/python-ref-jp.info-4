This is python-ref-jp.info, produced by makeinfo version 4.5 from
python-ref-jp.texi.

12 October 2005


File: python-ref-jp.info,  Node: 添字表記 subscription,  Next: スライス表記 slicing,  Prev: 属性参照,  Up: 一次語 primary

添字表記 (subscription)
-----------------------

添字表記は、配列 (文字列、タプルまたはリスト) やマップ (辞書)
オブジェクトから、要素を一つ選択します:

`subscription `primary' "[" `expression_list' "]"'

一次語の値評価結果は、配列型かマップ型のオブジェクトでなければなりません。

一次語がマップであれば、式リストの値評価結果はマップ内のいずれかの
キー値に相当するオブジェクトにならなければなりません。添字表記は、
そのキーに対応するマップ内の値 (value) を選択します。
(式リストの要素が単独である場合を除き、式リストはタプルでなければ
なりません。)

一次語が配列の場合、式 (リスト) の値評価結果は (通常の) 整数でなければ
なりません。値が負の場合、配列の長さが加算されます (`x[-1]' が`x'
の最後の要素を指すことになります)。
加算結果は配列内の要素数よりも小さな非負の整数とならなければなりません。
添字表記は、添字と同じ配列中の (ゼロから数えた) インデクスを持つ要素を
選択します。

文字列型の要素は文字 (character) です。文字は個別の型ではなく、 1
文字だけからなる文字列です。


File: python-ref-jp.info,  Node: スライス表記 slicing,  Next: 呼び出し call,  Prev: 添字表記 subscription,  Up: 一次語 primary

スライス表記 (slicing)
----------------------

スライス表記は配列オブジェクト (文字列、タプルまたはリスト) におけるある
範囲の要素を選択します。スライス表記は式として用いたり、代入や del 文の
対象として用いたりできます。スライス表記の構文は以下のようになります:

`slicing `simple_slicing' | `extended_slicing''

`simple_slicing `primary' "[" `short_slice' "]"'

`extended_slicing `primary' "[" `slice_list' "]"'

`slice_list `slice_item' ("," `slice_item')* [","]'

`slice_item `expression' | `proper_slice' | `ellipsis''

`proper_slice `short_slice' | `long_slice''

`short_slice [`lower_bound'] ":" [`upper_bound']'

`long_slice `short_slice' ":" [`stride']'

`lower_bound `expression''

`upper_bound `expression''

`stride `expression''

`ellipsis "..."'

上記の形式的な構文法にはあいまいさがあります: 式リストに見えるものは、
スライスリストにも見えるため、添字表記はスライス表記としても解釈されうる
ということです。
この場合には、(スライスリストの評価結果が、適切なスライスや省略表記
(ellipsis) にならない場合)、スライス表記としての解釈よりも添字表記
としての解釈の方が高い優先順位を持つように定義することで、構文法をより
難解にすることなくあいまいさを取り除いています。同様に、
スライスリストが厳密に一つだけの短いスライスで、末尾にカンマが
続いていない場合、拡張スライスとしての解釈より、単純なスライスとして
の解釈が優先されます。

単純なスライスに対する意味付けは以下のようになります。
一次語の値評価結果は、配列型のオブジェクトでなければなりません。
下境界および上境界を表す式がある場合、それらの値評価結果は整数で
なくてはなりません; デフォルトの値は、それぞれゼロと `sys.maxint'
です。どちらかの境界値が負である場合、
配列の長さが加算されます。こうして、スライスは I および J
をそれぞれ指定した下境界、上境界として、 インデクス K が `I <= K < J'
となる全ての 要素を選択します。
選択の結果、空の配列になることもあります。I や J が
有効なインデクス範囲の外側にある場合でも、エラーにはなりません
(範囲外の要素は存在しないので、選択されないだけです)。

拡張スライスに対する意味付けは、以下のようになります。
一次語の値評価結果は、辞書型のオブジェクトでなければなりません。
また、辞書は以下に述べるようにしてスライスリストから生成された
キーによってインデクス指定できなければなりません。
スライスリストに少なくとも一つのカンマが含まれている場合、
キーは各スライス要素を値変換したものからなるタプルになります;
それ以外の場合、単一のスライス要素自体を値変換したものがキーになります。
一個の式でできたスライス要素の変換は、その式になります。
省略表記スライス要素の変換は、組み込みの `Ellipsis' オブジェクト
になります。適切なスライスの変換は、スライスオブジェクト (*Note
標準型の階層:: 参照) で、`start', `stop' および `step'
属性は、それぞれ指定した下境界、上境界、および とび幅 (stride)
になります。式がない場合には、`None' に置き換え られます。


File: python-ref-jp.info,  Node: 呼び出し call,  Prev: スライス表記 slicing,  Up: 一次語 primary

呼び出し (call)
---------------

呼び出し (call) は、呼び出し可能オブジェクト (callable object, 例えば
関数など) を、引数列とともに呼び出します。引数列は空の配列でも
かまいません:

`call `primary' "(" [`argument_list' [","]] ")"'

`argument_list `positional_arguments' ["," `keyword_arguments']'

`                      ["," "*" `expression']'

`                      ["," "**" `expression']'

` | `keyword_arguments' ["," "*" `expression']'

`                     ["," "**" `expression']'

` | "*" `expression' ["," "**" `expression']'

` | "**" `expression''

`positional_arguments `expression' ("," `expression')*'

`keyword_arguments `keyword_item' ("," `keyword_item')*'

`keyword_item `identifier' "=" `expression''

固定引数と引数リストの末尾にカンマがあってもよく、
構文の意味付けに影響を及ぼすことはありません。

一次語の値評価結果は、呼び出し可能オブジェクトでなければなりません
(ユーザ定義関数、組み込み関数、組み込みオブジェクトのメソッド、
クラスオブジェクト、クラスインスタンスのメソッド、そして特定の
クラスインスタンス自体が呼び出し可能です; 拡張によって、
その他の呼び出し可能オブジェクト型を定義することができます)。
引数式は全て、呼び出しを試みる前に値評価されます。 仮引数 (formal
parameter) リストの構文については、*Note 関数定義:: を参照してください。

キーワード引数が存在する場合、以下のようにして最初に固定引数
(positional argument) に変換されます。まず、値の入っていない
スロットが仮引数に対して生成されます。N 個の固定引数が
ある場合、固定引数は先頭の N スロットに配置されます。
次に、各キーワード引数について、識別子を使って対応するスロット
を決定します (識別子が最初の仮引数パラメタ名と同じなら、最初の
スロットを使う、といった具合です)。スロットがすでにすべて埋まって
いたなら、`TypeError' 例外が送出されます。
それ以外の場合、引数値をスロットに埋めていきます。 (式が `None'
であっても、その式でスロットを埋めます)。
全ての引数が処理されたら、まだ埋められていないスロットをそれぞれに
対応する関数定義時のデフォルト値で埋めます。(デフォルト値は、
関数が定義されたときに一度だけ計算されます; 従って、リストや
辞書のような変更可能なオブジェクトがデフォルト値として使われると、
対応するスロットに引数を指定しない限り、このオブジェクトが全ての
呼び出しから共有されます; このような状況は通常避けるべきです。)
デフォルト値が指定されていない、値の埋められていないスロットが
残っている場合、`TypeError' 例外が送出されます。
そうでない場合、値の埋められたスロットからなるリストが呼び出しの
引数として使われます。

仮引数スロットの数よりも多くの固定引数がある場合、構文 `*identifier'
を使って指定された仮引数がないかぎり、 `TypeError' 例外が送出されます;
仮引数 `*identifier' がある場合、
この仮引数は余分な固定引数が入ったタプル (もしくは、余分な
固定引数がない場合には空のタプル) を受け取ります。

キーワード引数のいずれかが仮引数名に対応しない場合、構文 `**identifier'
を使って指定された仮引数がない限り、 `TypeError' 例外が送出されます;
仮引数 `**identifier' がある場合、
この仮引数は余分なキーワード引数が入った (キーワードをキーとし、
引数値をキーに対応する値とした) 辞書を受け取ります。
余分なキーワード引数がない場合には、空の (新たな) 辞書を 受け取ります。

関数呼び出しの際に `*expression' 構文が使われる場合、 `expression'
の値評価結果は配列でなくてはなりません。
この配列の要素は、追加の固定引数のように扱われます; すなわち、固定引数
X1,...,XN と、 Y1,...,YM になる配列 `expression' を使った 場合、M+N
個の固定引数 X1,...,XN,Y1,...,YM を使った呼び出しと同じになります。

上記の仕様による結果として、`*expression' 構文は たとえキーワード引数
_以降に_ あっても、キーワード引数 _以前に_ (`**expression'
引数があればさらにその後に - 下記参照) 処理されます。従って:

     >>> def f(a, b):
     ...  print a, b
     ...
     >>> f(b=1, *(2,))
     2 1
     >>> f(a=1, *(2,))
     Traceback (most recent call last):
       File "<stdin>", line 1, in ?
     TypeError: f() got multiple values for keyword argument 'a'
     >>> f(1, *(2,))
     1 2

となります。

キーワード引数と `*expression' 構文を同じ呼び出しに使うことは
あまりないので、実質的には上記のような混乱が生じることはありません。

関数呼び出しで `**expression' 構文が使われた場合、 `expression'
の値評価結果は辞書 (またはそのサブクラス) で
なければなりません。辞書の内容は追加のキーワード引数として扱われ
ます。明示的なキーワード引数が `expression' 内のキーワード
と重複した場合には、`TypeError' 例外が送出されます。

`*identifier' や `**identifier' 構文を使った仮引数は、
固定引数スロットやキーワード引数名にすることができません。 `(sublist)'
構文を使った仮引数は、キーワード引数名には 使えません; sublist
は、リスト全体が一つの無名の引数スロット に対応しており、sublist
中の引数は、他の全てのパラメタに対する
処理が終わった後に、通常のタプル形式の代入規則を使ってスロットに
入れられます。

呼び出しを行うと、例外を送出しない限り、常に何らかの値を返します。
`None' を返す場合もあります。戻り値がどのように算出されるかは、
呼び出し可能オブジェクトの形態によって異なります。

呼び出し可能オブジェクトが。。。

`ユーザ定義関数のとき:'
     関数のコードブロックに引数リストが
     渡され、実行されます。コードブロックは、まず仮引数を実引数に 結合
     (bind) します; この動作については *Note 関数定義::
     で記述しています。 コードブロックで `return'
     文が実行される際に、関数呼び出しの 戻り値 (return value)
     が決定されます。

`組み込み関数や組み込みメソッドのとき:'
     結果はインタプリタに 依存します;
     組み込み関数や組み込みメソッドの詳細は、 を参照してください。

`クラスオブジェクトのとき:'
     そのクラスの新しいインスタンスが 返されます。

`クラスインスタンスメソッドのとき:'
     対応するユーザ定義の関数
     が呼び出されます。このとき、呼び出し時の引数リストより一つ長い
     引数リストで呼び出されます: インスタンスが引数リストの先頭に追加
     されます。

`クラスインスタンスのとき:'
     クラスで `__call__()' メソッドが定義されていなければなりません;
     `__call__()' メソッドが呼び出された場合と同じ効果をもたらします。



File: python-ref-jp.info,  Node: べき乗演算 power operator,  Next: 単項算術演算 unary arithmetic operation,  Prev: 一次語 primary,  Up: 式 expression

べき乗演算 (power operator)
===========================

べき乗演算は、左側にある単項演算子よりも強い結合優先順位 があります;
一方、右側にある単項演算子よりは低い結合優先順位に
なっています。構文は以下のようになります:

`power `primary' ["**" `u_expr']'

従って、べき乗演算子と単項演算子からなる演算列が丸括弧で囲われて
いない場合、演算子は右から左へと評価されます (この演算規則は、
被演算子の評価順序を縛る規則ではありません)。

べき乗演算子は、二つの引数で呼び出される組み込み関数 `pow()'
と同じ意味付けを持っています。引数はまず共通の型に変換されます。
結果の型は、型強制後の引数の型になります。

引数型を混合すると、二項算術演算における型強制規則が適用されます。
整数や長整数の被演算子の場合、第二引数が負でない限り、結果は
(型強制後の) 被演算子と同じになります; 第二引数が負の場合、
全ての引数は浮動小数点型に変換され、浮動小数点型が返されます。
例えば、`10**2' は `100' を返しますが、`10**-2' は `0.01' を返します。
(上述の仕様のうち、最後のものは Python 2.2 で追加されました。 Python
2.1 以前では、双方の引数が
整数型で、第二引数が負の場合、例外が送出されていました。)

`0.0' を負の数でべき乗すると、`ZeroDivisionError'
を送出します。負の数を小数でべき乗すると `ValueError' になります。


File: python-ref-jp.info,  Node: 単項算術演算 unary arithmetic operation,  Next: 二項算術演算 binary arithmetic operation,  Prev: べき乗演算 power operator,  Up: 式 expression

単項算術演算 (unary arithmetic operation)
=========================================

全ての単項算術演算 (およびビット単位演算子) は、同じ優先順位を
持っています:

`u_expr `power' | "-" `u_expr' | "+" `u_expr' | "{~}" `u_expr''

単項演算子 `-' (マイナス) は、引数となる数値の符号を反転 (invert)
します。

単項演算子 `+' (プラス) は、数値引数を変更しません。

単項演算子 `~' (逆転) は、整数または長整数の引数を ビット単位反転
(bit-wise invert) します。 `x' の ビット単位反転は、 `-(x+1)'
として定義されています。 この演算子は整数にのみ適用されます。

上記の三つはいずれも、引数が正しい型でない場合には `TypeError'
例外が送出されます。


File: python-ref-jp.info,  Node: 二項算術演算 binary arithmetic operation,  Next: シフト演算 shifting operation,  Prev: 単項算術演算 unary arithmetic operation,  Up: 式 expression

二項算術演算 (binary arithmetic operation)
==========================================

二項算術演算は、慣習的な優先順位を踏襲しています。
演算子のいずれかは、特定の非数値型にも適用されるので注意して
ください。べき乗 (power) 演算子を除き、演算子には二つのレベル、
すなわち乗算的 (multiplicatie) 演算子と加算的 (additie) 演算子
しかありません:

`m_expr `u_expr' | `m_expr' "*" `u_expr' | `m_expr' "//" `u_expr' | `m_expr' "/" `u_expr''

` | `m_expr' "%" `u_expr''

`a_expr `m_expr' | `a_expr' "+" `m_expr' | `a_expr' "-" `m_expr''

`*' (乗算: multiplication) 演算は、引数間の積になります。
引数の組は、双方ともに数値型であるか、片方が整数 (通常の整数または
長整数) 型で他方が配列型かのどちらかでなければなりません。
前者の場合、数値は共通の型に変換された後乗算されます。
後者の場合、配列の繰り返し操作が行われます。繰り返し数を負に
すると、空の配列になります。

`/' (除算: division) および `//' (切り捨て除算: floor division)
は、引数間の商になります。数値引数はまず共通の型に変換されます。
整数または長整数の除算結果は、同じ型の整数になります; この場合、
結果は数学的な除算に関数 `floor' を適用したものになります。
ゼロによる除算を行うと `ZeroDivisionError' 例外を送出 します。

`%' (モジュロ: modulo) 演算は、第一引数を第二引数で除算
したときの剰余になります。数値引数はまず共通の型に変換されます。
右引数値がゼロの場合には、`ZeroDivisionError' 例外が
送出されます。引数値は浮動小数点でもよく。例えば `3.14%0.7' は `0.34'
になります (`3.14' は `4*0.7 + 0.34'
だからです)。モジュロ演算子は常に第二引数と同じ符号 (またはゼロ)
の結果になります; モジュロ演算の結果の絶対値は、常に第二引数
の絶対値よりも小さくなります。(1)

整数による除算演算やモジュロ演算は、恒等式: `x == (x/y)*y + (x%y)'
と関係しています。整数除算や モジュロはまた、組み込み関数 `divmod()':
`divmod(x, y) == (x/y, x%y)' と関係しています。
これらの恒等関係は浮動小数点の場合には維持されません; `x/y' が
`floor(x/y)' や `floor(x/y) - 1' に
置き換えられた場合、これらの恒等式は近似性を維持します。 (2)

_This is deprecated in Python 2.3.
切り捨て除算演算子、モジュロ演算子、および `divmod()'
関数は、複素数に対してはもはや定義されて
いません。目的に合うならば、代わりに `abs()' を使って
浮動小数点に変換してください。_

`+' (加算) 演算は、引数を加算した値を返します。
引数は双方とも数値型か、双方とも同じ型の配列でなければなりません。
前者の場合、数値は共通の型に変換され、加算されます。
後者の場合、配列は結合 (concatenate) されます。

`-' (減算) 演算は、引数間で減算を行った値を返します。
数値引数はまず共通の型に変換されます。

---------- Footnotes ----------

(1)  `abs(x%y) < abs(y)' は数学的には真となりますが、浮動小数点
に対する演算の場合には、値丸め (roundoff) のために数値計算的に
真にならない場合があります。例えば、Python の浮動小数点型が IEEE754
倍精度数型になっているプラットフォームを仮定すると、 `-1e-100 % 1e100'
は `1e100' と同じ符号になるはず なのに、計算結果は `-1e-100 + 1e100'
となります。これは 数値計算的には厳密に `1e100' と等価です。`math'
モジュールの関数 `fmod()' は、最初の引数と符号が一致する
ような値を返すので、上記の場合には `-1e-100' を返します。
どちらのアプローチが適切かは、アプリケーションに依存します。

(2)  x が y の整数倍に非常に近い場合、丸め誤差によって `floor(x/y)'  は
`(x-x%y)/y' よりも大きな値になる可能性があります。 そのような場合、
Python は`divmod(x,y)[0] * y + x %{} y'  が `x'
に非常に近くなるという関係を保つために、後者の値を 返します。


File: python-ref-jp.info,  Node: シフト演算 shifting operation,  Next: ビット単位演算の二項演算 binary bit-wise operation,  Prev: 二項算術演算 binary arithmetic operation,  Up: 式 expression

シフト演算 (shifting operation)
===============================

シフト演算は、算術演算よりも低い優先順位を持っています:

`shift_expr `a_expr' | `shift_expr' ( "<{}<" | ">{}>" ) `a_expr''

シフトの演算子は整数または長整数を引数にとります。
引数は共通の型に変換されます。シフト演算では、最初の引数を
二つ目の引数に応じたビット数だけ、左または右にビットシフト します。

N ビットの右シフトは、`pow(2,N)' による除算 として定義されています。 N
ビットの左シフトは、 `pow(2,N)' による乗算として定義されています;
整数の場合、桁あふれ (overflow) のチェックはされないので、
演算によって末端のビットは捨てられます。また、結果の絶対値が `pow(2,
31)' よりも小さくない場合には、符号の反転が起こります。
負のビット数でシフトを行うと、 `ValueError' 例外を 送出します。


File: python-ref-jp.info,  Node: ビット単位演算の二項演算 binary bit-wise operation,  Next: 比較 comparison,  Prev: シフト演算 shifting operation,  Up: 式 expression

ビット単位演算の二項演算 (binary bit-wise operation)
====================================================

以下の三つのビット単位演算には、それぞれ異なる優先順位レベルがあります:

`and_expr `shift_expr' | `and_expr' "&" `shift_expr''

`xor_expr `and_expr' | `xor_expr' "^" `and_expr''

`or_expr `xor_expr' | `or_expr' "|" `xor_expr''

`&' 演算子は、引数間でビット単位の AND をとった値になります。
引数は整数または長整数でなければなりません。引数は共通の型に変換
されます。

`^' 演算子は、引数間でビット単位の XOR (排他的 OR) をとった値に
なります。
引数は整数または長整数でなければなりません。引数は共通の型に変換
されます。

`|' 演算子は、引数間でビット単位の OR (非排他的 OR) をとった値に
なります。
引数は整数または長整数でなければなりません。引数は共通の型に変換
されます。


File: python-ref-jp.info,  Node: 比較 comparison,  Next: ブール演算 boolean operation,  Prev: ビット単位演算の二項演算 binary bit-wise operation,  Up: 式 expression

比較 (comparison)
=================

C 言語と違って、Python における比較演算子は同じ優先順位をもっており、
全ての算術演算子、シフト演算子、ビット単位演算子よりも低くなっています。
また、`a < b < c' が数学で伝統的に用いられているのと同じ解釈に なる点も
C 言語と違います:

`comparison `or_expr' ( `comp_operator' `or_expr' )*'

`comp_operator "<" | ">" | "==" | ">=" | "<=" | "<>" | "!="'

` | "is" ["not"] | ["not"] "in"'

比較演算の結果はブール値: `True' または `False' になります。

比較はいくらでも連鎖することができます。例えば `x < y <= z' は `x < y
and y <= z' と等価になります。ただしこの場合、前者では `y'
はただ一度だけ評価される点が異なります (どちらの場合でも、 `x < y'
が偽になると `z' の値はまったく評価されません)。

形式的には、 A, B, C, ..., Y, Z が式で、OPA, OPB, ..., OPY
が比較演算子で ある場合、A OPA B OPB C ...Y OPY Z は A OPA B `and' B
OPB C `and' ...  Y OPY Z
と等価になります。ただし、前者では各式は多くても一度
しか評価されません。

A OPA B OPB C と書いた場合、 A から C までの範囲
にあるかどうかのテストを指すのではないことに注意してください。
例えば、`x < y > z' は (きれいな書き方ではありませんが)
完全に正しい文法です。

`<>' と `!=' の二つの形式は等価です; C との整合性を
持たせるためには、`!=' を推奨します; 以下で `!=' について
触れている部分では、`<>' を使うこともできます。 `<>'
のような書き方は、現在では古い書き方とみなされています。

演算子 `<', `>', `==', `>=', `<=', および `!='
は、二つのオブジェクト間の値を比較します。オブジェクトは
同じ型である必要はありません。双方のオブジェクトが数値であれば、
共通型への変換が行われます。それ以外の場合、異なる型のオブジェクトは
_常に_ 不等であるとみなされ、一貫してはいるが規定されていない
方法で並べられます。

(このような比較演算の変則的な定義は、ソートのような操作や、 `in'
および`not in' といった演算子の定義を
単純化するためのものです。将来、異なる型のオブジェクト間における
比較規則は変更されるかもしれません。)

同じ型のオブジェクト間における比較は、型によって異なります:

   * 数値間の比較では、算術的な比較が行われます。

   * 文字列間の比較では、各文字に対する等価な数値型 (組み込み関数
     `ord()' の結果) を使って辞書的な (lexicographically)
     比較が行われます。Unicode および 8
     ビット文字列は、この動作に関しては 完全に互換です。

   *
     タプルやリスト間の比較では、対応する各要素の比較結果を使って辞書的な
     比較が行われます。このため、二つの配列を等価にするためには、各要素が
     完全に等価でなくてはならず、配列は同じ型で同じ長さをもっていなければ
     なりません。

     二つの配列が等価でない場合、異なる値を持つ最初の要素間での比較に
     従った順序関係になります。例えば、`cmp([1,2,x], [1,2,y])' は
     `cmp(x,y)' と等しい結果を返します。片方の要素に対応する要素が
     他方にない場合、より短い配列が前に並びます (例えば、 `[1,2] <
     [1,2,3]' となります)。

   * マップ (辞書) 間の比較では、(key, value) からなるリストをソート
     したものが等しい場合に等価になります。(1)
     等価性評価以外の結果は一貫したやりかたで解決されるか、定義されないか
     のいずれかです。(2)

   * その他のほとんどの型の比較では、同じオブジェクトでないかぎり
     等価にはなりません。あるオブジェクトの他のオブジェクトに対する
     大小関係は任意に決定され、一つのプログラムの実行中は一貫した
     ものとなります。


演算子 `in' および `not in' は、集合内の要素であるか どうか
(メンバシップ、membership) を調べます。 `X in S' は、X が集合 S
のメンバである 場合には真となり、それ以外の場合には偽となります。 `X
not in S' は `X in S' の否定 (negation)
を返します。集合メンバシップテストは、伝統的には
配列型に限定されてきました; すなわち、あるオブジェクトがある集合
のメンバとなるのは、集合が配列型であり、配列がオブジェクトと等価な
要素を含む場合でした。しかしながら、現在ではオブジェクトが配列で
なくてもメンバシップテストをサポートしています。特に、 辞書型では、`KEY
in DICT' と書くことで、
うまい具合にメンバシップテストをサポートしています; 他のマップ型も
これに倣っているかもしれません。

リストやタプル型については、`X in Y' は `X == Y[I]'
となるようなインデクス I
が存在するとき、かつそのときに限り真になります。

Unicode 文字列または文字列型については、`X in Y' は X が Y
の部分文字列であるとき、かつそのときに限り
真になります。この演算と等価なテストは `y.find(x) != -1' です。 X
および Y は同じ型である必要はないので注意してください。
すなわち、`u'ab' in 'abc'' は `True' を返すことになります。
空文字列は、他のどんな文字列に対しても常に部分文字列とみなされます。
従って、`"" in "abc"' は `True' を返すことになります。 _Changed in
Python version 2.3_

`__contains__()' メソッドの定義されたユーザ定義クラスでは、 `X in Y'
が真となるのは `Y.__contains__(X)'
が真となるとき、かつそのときに限ります。

`__contains__()' は定義していないが `__getitem__()'
は定義しているようなユーザ定義クラスでは、 `X in Y' は `X == Y[I]'
となるような非負の整数インデクス I
が存在するとき、かつそのときにかぎり真となります。 インデクス I
が負である場合に `IndexError' 例外が 送出されることはありません。
(別の何らかの例外が送出された場合、 例外は `in'
から送出されたかのようになります)。

演算子 `not in' は、`in' の真値に対する逆転として定義されて います。

演算子 `is' および `is not' は、オブジェクトの
アイデンティティに対するテストを行います: `X is Y' は、 X と Y
が同じオブジェクト を指すとき、かつそのときに限り真になります。 `X is
not Y' は、`is' の真値を逆転したもの になります。

---------- Footnotes ----------

(1) 実装では、この
演算をリストを構築したりソートしたりすることなく効率的に 行います。

(2) Python の初期のバージョンでは、ソートされた (key, value)
のリストに対して辞書的な比較を行っていましたが、
これは等価性の計算のようなよくある操作を実現するには非常に
コストの高い操作でした。もっと以前のバージョンの Python では、辞書は
アイデンティティだけで比較されていました。しかしこの仕様は、 `{}'
との比較によって辞書が空であるか確かめられると期待して
いた人々を混乱させていました。


File: python-ref-jp.info,  Node: ブール演算 boolean operation,  Next: ラムダ lambda,  Prev: 比較 comparison,  Up: 式 expression

ブール演算 (boolean operation)
==============================

ブール演算は、全ての Python
演算子の中で、最も低い優先順位になっています:

`expression `or_test' | `lambda_form''

`or_test `and_test' | `or_test' "or" `and_test''

`and_test `not_test' | `and_test' "and" `not_test''

`not_test `comparison' | "not" `not_test''

`lambda_form "lambda" [`parameter_list']: `expression''

ブール演算のコンテキストや、式が制御フロー文中で使われる最には、
以下の値: `None' 、すべての数値型におけるゼロ、空の配列 (文字列、
タプル、およびリスト) 、空のマップ型 (辞書) 、は偽 (false) であると
解釈されます。それ以外の値は真 (true) であると解釈されます。

演算子 `not' は、引数が偽である場合には `True' を、それ以外の 場合には
`False' になります。

式 `X and Y' は、まず X を評価します; X が偽なら、X の値を返します;
それ以外の場合には、 Y の値を評価し、その結果を返します。

式 `X or Y' は、まず X を評価します; X が真なら、X の値を返します;
それ以外の場合には、 Y の値を評価し、その結果を返します。

(`and' も `not' も、返す値を `False' や `True' に
制限するのではなく、最後に評価した引数の値を返すので注意してください。
この仕様は、例えば `s' を文字列として、`s' が空文字列の
場合にデフォルトの値に置き換えるような場合に、`s or 'foo''
と書くと期待通りの値になるために便利なことがあります。 `not'
は、式の値でなく独自に値を作成して返すので、
引数と同じ型の値を返すような処理に煩わされることはありません。 例えば、
`not 'foo'' は、 `''' ではなく `False' になります)


File: python-ref-jp.info,  Node: ラムダ lambda,  Next: 式のリスト,  Prev: ブール演算 boolean operation,  Up: 式 expression

ラムダ (lambda)
===============

ラムダ形式 (lambda form, ラムダ式 (lambda expression)) は、
構文法的には式と同じ位置付けになります。ラムダは、無名関数を作成
できる省略記法です; 式 `lambda ARGUMENTS: EXPRESSION'
は、関数オブジェクトになります。ラムダが表す無名オブジェクトは、
以下のコード

     def name(arguments):
         return expression

で定義された関数と同様に動作します。

引数リストの構文法については、*Note 関数定義:: 節を参照してください。
ラムダ形式で作成された関数は、実行文 (statement) を含むことができない
ので注意してください。


File: python-ref-jp.info,  Node: 式のリスト,  Next: 評価順序,  Prev: ラムダ lambda,  Up: 式 expression

式のリスト
==========

`expression_list `expression' ( "," `expression' )* [","]'

少なくとも一つのカンマを含む式のリストは、タプルになります。
タプルの長さは、リスト中の式の数に等しくなります。
リスト中の式は左から右へと順に評価されます。

単一要素のタプル (別名_単集合 (singleton)_) を作りたければ、
末尾にカンマが必要です。単一の式だけで、末尾にカンマをつけない場合
には、タプルではなくその式の値になります (空のタプルを作りたいなら、
中身が空の丸括弧ペア: `()' を使います。)


File: python-ref-jp.info,  Node: 評価順序,  Next: まとめ,  Prev: 式のリスト,  Up: 式 expression

評価順序
========

Python は、式を左から右へと順に評価してゆきます。
ただし、代入式を評価する最には、代入演算子の右側項が左側項よりも
先に評価されるので注意してください。

以下に示す実行文の各行での評価順序は、添え字の数字順序と同じ になります:

     expr1, expr2, expr3, expr4
     (expr1, expr2, expr3, expr4)
     {expr1: expr2, expr3: expr4}
     expr1 + expr2 * (expr3 - expr4)
     func(expr1, expr2, *expr3, **expr4)
     expr3, expr4 = expr1, expr2


File: python-ref-jp.info,  Node: まとめ,  Prev: 評価順序,  Up: 式 expression

まとめ
======

以下の表は、Python における演算子を、優先順位  の最も低い
(結合度が最も低い) ものから最も高い (結合度が最も高い)
ものの順に並べたものです。
同じボックス内に示された演算子は同じ優先順位を持ちます。演算子の
文法が示されていないかぎり、演算子は全て二項演算子です。
同じボックス内の演算子は、左から右へとグループ化されます
(値のテストを含む比較演算子を除きます。比較演算子は、左から右に連鎖
します -- *Note 比較 comparison::
を参照してください。また、べき乗演算子も
除きます。べき乗演算子は右から左にグループ化されます)。

演算子                               説明
------                               -----
`lambda'                             ラムダ式
`or'                                 ブール演算 OR
`and'                                ブール演算 AND
`not' X                              ブール演算 NOT
`in', `not' `in'                     メンバシップテスト
`is', `is not'                       アイデンティティテスト
`<', `<=', `>', `>=', `<>', `!=',    比較
`=='                                 
`|'                                  ビット単位 OR
`^'                                  ビット単位 XOR
`&'                                  ビット単位 AND
`<'`<', `>'`>'                       シフト演算
`+', `-'                             加算および減算
`*', `/', `%'                        乗算、除算、剰余
`+X', `-X'                           正符号、負符号
`~X'                                 ビット単位 NOT
`**'                                 べき乗
`X.ATTRIBUTE'                        属性参照
`X[INDEX]'                           添字指定
`X[INDEX:INDEX]'                     スライス操作
`F(ARGUMENTS...)'                    関数呼び出し
`(EXPRESSIONS...)'                   式結合またはタプル表現
`[EXPRESSIONS...]'                   リスト表現
`{KEY:DATUM...}'                     辞書表現
``EXPRESSIONS...`'                   文字列への型変換


File: python-ref-jp.info,  Node: 単純文 simple statement,  Next: 複合文 compound statement,  Prev: 式 expression,  Up: Top

単純文 (simple statement)
*************************

単純文とは、単一の論理行内に収められる文です。
単一の行内には、複数の単純文をセミコロンで区切って入れることが
できます。単純文の構文は以下の通りです:

`simple_stmt `expression_stmt''

` | `assert_stmt''

` | `assignment_stmt''

` | `augmented_assignment_stmt''

` | `pass_stmt''

` | `del_stmt''

` | `print_stmt''

` | `return_stmt''

` | `yield_stmt''

` | `raise_stmt''

` | `break_stmt''

` | `continue_stmt''

` | `import_stmt''

` | `global_stmt''

` | `exec_stmt''

* Menu:

* 式文 expression statement::
* Assert 文 assert statement::
* 代入文 assignment statement::
* pass 文::
* del 文::
* print 文::
* return 文::
* yield 文::
* raise 文::
* break 文::
* continue 文::
* import 文::
* global 文::
* exec 文::


File: python-ref-jp.info,  Node: 式文 expression statement,  Next: Assert 文 assert statement,  Prev: 単純文 simple statement,  Up: 単純文 simple statement

式文 (expression statement)
===========================

式文は、 (主に対話的な使い方では) 値を計算して出力するために
使ったり、(通常は) プロシジャ (procedure: 有意な結果を返さない
関数のことです; Python では、プロシジャは値 `None' を返します)
を呼び出すために使います。その他の使い方でも式文を使うことができ
ますし、有用なこともあります。式文の構文は以下の通りです:

`expression_stmt `expression_list''

式文は式のリスト (単一の式のこともあります) を値評価します。

対話モードでは、値が `None' でない場合、値を組み込み関数 `repr()'
で文字列に変換して、 その結果のみからなる一行を標準出力に書き出します
(~*Note print 文:: 節参照)。 (`None'
になる式文の値は書き出されないので、プロシジャ呼び出しを
行っても出力は得られません。)


File: python-ref-jp.info,  Node: Assert 文 assert statement,  Next: 代入文 assignment statement,  Prev: 式文 expression statement,  Up: 単純文 simple statement

Assert 文 (assert statement)
============================

Assert 文  は、プログラム内にデバッグ用アサーション (debugging
assertion) を仕掛けるための便利な方法です:

`assert_stmt "assert" `expression' ["," `expression']'

単純な形式 `assert expression' は、

     if __debug__:
        if not expression: raise AssertionError

と等価です。拡張形式 `assert expression1, expression2' は、

     if __debug__:
        if not expression1: raise AssertionError, expression2

と等価です。

上記の等価関係は、 `__debug__'  と `AssertionError'  が、同名の組み込み
変数を参照しているという前提の上に成り立っています。
現在の実装では、組み込み変数 `__debug__' は通常は 1 であり、
インタプリタに (コマンドラインオプション -O で) 最適化を要求すると 0
になります。現状のコード生成器は、コンパイル時に最適化が要求されて
いると assert 文に対するコードを全く出力しません。
実行に失敗した式のソースコードをエラーメッセージ内に入れる必要は
ありません; メッセージはスタックトレース内で表示されます。

`__debug__' への代入は不正な操作です。組み込み変数の値は、
インタプリタが開始するときに決定されます。


File: python-ref-jp.info,  Node: 代入文 assignment statement,  Next: pass 文,  Prev: Assert 文 assert statement,  Up: 単純文 simple statement

代入文 (assignment statement)
=============================

代入文  は、名前を値に (再) 束縛したり、
変更可能なオブジェクトの属性や要素を変更したりするために使われます:

`assignment_stmt (`target_list' "=")+ `expression_list''

`target_list `target' ("," `target')* [","]'

`target `identifier''

` | "(" `target_list' ")"'

` | "[" `target_list' "]"'

` | `attributeref''

` | `subscription''

` | `slicing''

(末尾の三つのシンボルの構文については ~*Note 一次語 primary:: 節を
参照してください。)

代入文は式のリスト (これは単一の式でも、
カンマで区切られた式リストでもよく、後者はタプルになることを
思い出してください) を評価し、得られた単一の結果オブジェクトを
ターゲット (target) のリストに対して左から右へと代入してゆきます。

代入はターゲット (リスト) の形式に従って再帰的に行われます。
ターゲットが変更可能なオブジェクト (属性参照、添字表記、またはスライス)
の一部である場合、この変更可能なオブジェクトは最終的に代入を
実行して、その代入が有効な操作であるか判断しなければなりません。
代入が不可能な場合には例外を発行することもできます。型ごとに
みられる規則や、送出される例外は、そのオブジェクト型定義
で与えられています (~*Note 標準型の階層:: 節を参照してください).

ターゲットリストへのオブジェクトの代入は、以下のようにして再帰的に
定義されています。

   * ターゲットリストが単一のターゲットからなる場合: オブジェクトはその
     ターゲットに代入されます。

   * ターゲットリストが、カンマで区切られた複数のターゲットからなる
     リストの場合: オブジェクトはターゲットリスト中のターゲット数と
     同じ数の要素からなる配列でなければならず、その各要素は左から
     右へと対応するターゲットに代入されます。(これは Python 1.5
     で緩和された規則です; 以前のバージョンでは、代入するオブジェクトは
     タプルでなければなりませんでした。文字列も配列なので、今では `a, b
     = "xy"' のような代入は文字列が正しい長さを持つ限り
     正規の操作になります。)


単一のターゲットへの単一のオブジェクトの代入は、以下のようにして
再帰的に定義されています。

   * ターゲットが識別子 (名前) の場合:

        * 名前が現在のコードブロック内の `global' 文に書かれて
          いない場合: 名前は現在のローカル名前空間内のオブジェクトに
          束縛されます。

        * それ以外の場合:
          名前は現在のグローバル名前空間内のオブジェクトに
          束縛されます。


     名前がすでに束縛済みの場合、再束縛 (rebind) がおこなわれます。
     再束縛によって、以前その名前に束縛されていたオブジェクトの
     参照カウント (reference count) がゼロになった場合、オブジェクトは
     解放 (deallocate) され、デストラクタ (destructor ) が (存在すれば)
     呼び出されます。

   * ターゲットが丸括弧や角括弧で囲われたターゲットリストの場合:
     オブジェクトはターゲットリスト中のターゲット数と
     同じ数の要素からなる配列でなければならず、その各要素は左から
     右へと対応するターゲットに代入されます。

   * ターゲットが属性参照の場合: 参照されている一次語の式
     が値評価されます。値は代入可能な属性を伴うオブジェクトでなければ
     なりません; そうでなければ、 `TypeError' が送出されます。
     次に、このオブジェクトに対して、被代入オブジェクトを指定した属性
     に代入してよいか問い合わせます; 代入を実行できない場合、 例外
     (通常は `AttributeError' ですが、必然ではありません) を送出します。

   * ターゲットが添字表記の場合: 参照されている一次語の式
     が値評価されます。まず、値は変更可能な配列オブジェクト
     (例えばリスト) か、マップオブジェクト (例えば辞書)
     でなければなりません。 次に、添字表記の表す式が値評価されます。

     一次語が変更可能な配列オブジェクト (例えばリスト) の場合、
     まず添字は整数でなければなりません。添字が負数の場合、配列の
     長さが加算されます。添字は最終的に、配列の長さよりも小さな
     非負の整数でなくてはなりません。次に、添字をインデクスに
     持つ要素に非代入オブジェクトを代入してよいか、配列に問い合わせ
     ます。範囲を超えたインデクスに対しては`IndexError' が送出されます
     (添字指定された配列に代入を行っても、
     リスト要素の新たな追加はできません)。

     一次語がマップオブジェクト (例えば辞書) の場合、まず添字は
     マップのキー型と互換性のある型でなくてはなりません。
     次に、添字を被代入オブジェクトに関連付けるようなキー/データ
     の対を生成するようマップオブジェクトに問い合わせます。
     この操作では、既存のキー/値の対を同じキーと別の値で置き換えても
     よく、(同じ値を持つキーが存在しない場合)
     新たなキー/値の対を挿入しても かまいません。

   * ターゲットがスライスの場合: 参照されている一次語の式
     が値評価されます。まず、値は変更可能な配列オブジェクト
     (例えばリスト)
     でなければなりません。被代入オブジェクトは同じ型を持った配列オブジェクト
     でなければなりません。次に、スライスの下境界と上境界を示す式があれば
     評価されます; デフォルト値はそれぞれゼロと配列の長さです。
     上下境界は整数にならなければなりません。いずれかの境界が負数に
     なった場合、配列の長さが加算されます。最終的に、境界は
     ゼロから配列の長さまでの内包になるようにクリップされます。
     最後に、スライスを被代入オブジェクトで置き換えてよいか配列オブジェクトに
     問い合わせます。オブジェクトで許されている限り、スライスの長さは
     被代入配列の長さと異なっていてよく、この場合にはターゲット配列の
     長さが変更されます。


(現在の実装では、ターゲットの構文は式の構文と同じであるとみなされて
おり、無効な構文はコード生成フェーズ中に詳細なエラーメッセージを
伴って拒否されます。)

警告: 代入の定義では、左辺値と右辺値がオーバラップするような代入
(例えば、`a, b = b, a' を行うと、二つの変数を入れ替えます) を
定義しても `安全 (safe)' に代入できますが、代入対象となる 変数群
_の間で_ オーバラップがある場合は安全ではありません！
例えば、以下のプログラムは `[0, 2]' を出力してしまいます:

     x = [0, 1]
     i = 0
     i, x[i] = 1, 2
     print x

* Menu:

* 累算代入文 augmented assignment statement::


File: python-ref-jp.info,  Node: 累算代入文 augmented assignment statement,  Prev: 代入文 assignment statement,  Up: 代入文 assignment statement

累算代入文 (augmented assignment statement)
-------------------------------------------

累算代入文は、二項演算と代入文を組み合わせて一つの文にしたものです:

`augmented_assignment_stmt `target' `augop' `expression_list''

`augop "+=" | "-=" | "*=" | "/=" | "%=" | "**="'

` | ">{}>=" | "<{}<=" | "&=" | "^=" | "|="'

累算代入文は、ターゲット (通常の代入文と違って、アンパックは
起こりません) と式リストを評価し、それら二つの被演算子間で特定の累算
代入型の二項演算を行い、結果をもとのターゲットに代入します。
ターゲットは一度しか評価されません。

`x += 1' のような累算代入式は、`x = x + 1' のように書き換えて
ほぼ同様の動作にできますが、厳密に等価にはなりません。累算代入の
方では、`x' は一度しか評価されません。また、実際の処理として、
可能ならば _インプレース (in-place)_ 演算が実行されます。
これは、代入時に新たなオブジェクトを生成してターゲットに代入するの
ではなく、以前のオブジェクトの内容を変更するということです。

累算代入文で行われる代入は、タプルへの代入や、一文中に複数の
ターゲットが存在する場合を除き、通常の代入と同じように扱われます。
同様に、累算代入で行われる二項演算は、場合によって _インプレース演算_
が行われることを除き、通常の二項演算 と同じです。

属性参照のターゲットの場合、代入前の初期値は `getattr()' で
取り出され、演算結果は `setattr()' で代入されます。
二つのメソッドが同じ変数を参照するという必然性はないので注意してください。
例えば:

     class A:
         x = 3    # class variable
     a = A()
     a.x += 1     # writes a.x as 4 leaving A.x as 3

のように、`getattr()' がクラス変数を参照していても、 `setattr()'
はインスタンス変数への書き込みを行ってしまいます。


File: python-ref-jp.info,  Node: pass 文,  Next: del 文,  Prev: 代入文 assignment statement,  Up: 単純文 simple statement

`pass' 文
=========

`pass_stmt "pass"'

`pass' はヌル操作 (null operation) です -- `pass'
が実行されても、何も起きません。`pass' は、例えば:

     def f(arg): pass    # a function that does nothing (yet)
     
     class C: pass       # a class with no methods (yet)

のように、構文法的には文が必要だが、コードとしては何も実行したく
ない場合のプレースホルダとして有用です。


File: python-ref-jp.info,  Node: del 文,  Next: print 文,  Prev: pass 文,  Up: 単純文 simple statement

`del' 文
========

`del_stmt "del" `target_list''

オブジェクトの削除 (deletion) は、代入の定義と非常に似た方法で
再帰的に定義されています。ここでは完全な詳細を記述するよりも
いくつかのヒントを述べるにとどめます。

ターゲットリストに対する削除は、各々のターゲットを左から右へと
順に再帰的に削除します。

名前に対して削除を行うと、ローカルまたはグローバル名前空間での
その名前の束縛を解除します。どちらの名前空間かは、名前が同じコード
ブロック内の `global' 文で宣言されているかどうかによります。
名前が未束縛 (unbound) であるばあい、`NameError' 例外 が送出されます。

ネストしたブロック中で自由変数  になっている
ローカル名前空間上の名前に対する削除は不正な操作になります

属性参照、添字表記、およびスライスの削除操作は、対象となる一次語
オブジェクトに渡されます; スライスの削除は一般的には適切な
型の空のスライスを代入するのと等価です (が、この仕様自体も
スライスされるオブジェクトで決定されています)。


File: python-ref-jp.info,  Node: print 文,  Next: return 文,  Prev: del 文,  Up: 単純文 simple statement

`print' 文
==========

`print_stmt "print" ( [`expression' ("," `expression')* [","]]'

` | ">`>'" `expression' [("," `expression')+ [","]] )'

`print' は、式を逐次的に評価し、得られたオブジェクトを
標準出力に書き出します。オブジェクトが文字列でなければ、まず文字列
変換規則を使って文字列に変換され、次いで (得られた文字列か、オリジナル
の文字列が) 書き出されます。出力系の現在の書き出し位置が行頭にある
と考えられる場合を除き、各オブジェクトの出力前にスペースが一つ出力
されます。行頭にある場合とは、(1) 標準出力にまだ何も書き出されて
いない場合、(2) 標準出力に最後に書き出された文字が `\n' である、または
(3) 標準出力に対する最後の書き出し操作が `print'
文によるものではない場合、です。(こうした理由から、
場合によっては空文字を標準出力に書き出すと便利なことがあります。)
_Note:_ 組み込みのファイルオブジェクトでない、ファイルオブジェクト
に似た動作をするオブジェクトでは、組み込みのファイルオブジェクト
が持つ上記の性質を適切にエミュレートしていないことがあるため、
当てにしないほうがよいでしょう。

`print' 文がカンマで終了していない限り、末尾には文字 `\n'
が書き出されます。この仕様は、文に予約語 `print'
がある場合のみの動作です。

標準出力は、組み込みモジュール `sys' 内で `stdout'
という名前のファイルオブジェクトとして定義されています。
該当するオブジェクトが存在しないか、オブジェクトに `write()'
メソッドがない場合、`RuntimeError' 例外が送出されます。.

`print' には、上で説明した構文の第二形式で定義されている 拡張形式
があります。 この形式は、"山形 `print' 表記 (`print' chevron)"
と呼ばれます。この形式では、`>'`>' の直後にくる最初の 式の値評価結果は
"ファイル類似 (file-like)" なオブジェクト、とりわけ 上で述べたように
`write()' メソッドを持つオブジェクトで
なければなりません。この拡張形式では、ファイルオブジェクトを指定する
式よりも後ろの式が、指定されたファイルオブジェクトに出力されます。
最初の式の値評価結果が `None' になった場合、 `sys.stdout'
が出力ファイルとして使われます。


File: python-ref-jp.info,  Node: return 文,  Next: yield 文,  Prev: print 文,  Up: 単純文 simple statement

`return' 文
===========

`return_stmt "return" [`expression_list']'

`return' は、関数定義内で構文法的にネストして現れますが、
ネストしたクラス定義内には現れません。

式リストがある場合、リストが値評価されます。それ以外の場合は `None'
で置き換えられます。

`return' を使うと、式リスト (または `None')
を戻り値として、現在の関数呼び出しから抜け出します。

`return' によって、`finally' 節をともなう `try'
文の外に処理が引き渡されると、実際に関数から抜ける前に `finally'
節が実行されます。

ジェネレータ関数の場合には、`return' 文の中に `expression_list'
を入れることはできません。
ジェネレータ関数の処理コンテキストでは、単体の `return'
はジェネレータ処理を終了し `StopIteration' を送出させる ことを示します。


File: python-ref-jp.info,  Node: yield 文,  Next: raise 文,  Prev: return 文,  Up: 単純文 simple statement

`yield' 文
==========

`yield_stmt "yield" `expression_list''

`yield' 文は、ジェネレータ関数 (generator function) を
定義するときだけ使われ、かつジェネレータ関数の本体の中でだけ
用いられます。 関数定義中で `yield' 文を使うだけで、関数定義は通常の関数
でなくジェネレータ関数になります。

ジェネレータ関数が呼び出されると、ジェネレータイテレータ (generator
iterator)、一般的にはジェネレータ (generator) を
返します。ジェネレータ関数の本体は、ジェネレータの `next()'
が例外を発行するまで繰り返し呼び出して実行します。

`yield' 文が実行されると、現在のジェネレータの状態は 凍結 (freeze)
され、`expression_list' の値が `next()'
の呼び出し側に返されます。ここでの "凍結" は、ローカルな変数への
束縛、命令ポインタ (instruction pointer)、および内部実行スタック
(internal evaluation stack) を含む、全てのローカルな状態が保存される
ことを意味します: すなわち、必要な情報を保存しておき、次に `next()'
が呼び出された際に、関数が `yield' 文をあたかも
もう一つの外部呼出しであるかのように処理できるようにします。

`yield' 文は、`try' ... `finally' 構造の `try'
節中で使うことはできません。ジェネレータが常に
実行再開されるとは限らないので、`finally' ブロックが常に
実行される保証がないという問題があるためです。

_Notice:_ Python 2.2 では、`generators' 機能が有効になっている場合にのみ
`yield' 文を使えます。Python 2.3 では、常に有効になっています。
`__future__' import 文を使うと、この機能を有効にできます:

     from __future__ import generators

See also:
    *PEP0255 単純なジェネレータ*
          Python へのジェネレータと `yield' 文の導入提案



File: python-ref-jp.info,  Node: raise 文,  Next: break 文,  Prev: yield 文,  Up: 単純文 simple statement

`raise' 文
==========

`raise_stmt "raise" [`expression' ["," `expression' ["," `expression']]]'

式を伴わない場合、`raise' は現在のスコープで最終的に有効に
なっている式を再送出します。そのような式が現在のスコープに全く
ない場合、エラーを示す例外が送出されます。

それ以外の場合、`raise' は式を値評価して、三つのオブジェクトを
取得します。このとき、`None' を省略された式の値として使います。
最初の二つのオブジェクトは、例外の _型 (type)_ と 例外の _値 (value)_
を決定するために用いられます。

最初のオブジェクトがインスタンスである場合、例外の型はインスタンス
のクラスになり、インスタンス自体が例外の値になります。このとき
第二のオブジェクトは `None' でなければなりません。

最初のオブジェクトがクラスの場合、例外の型になります。
第二のオブジェクトは、例外の値を決めるために使われます:
第二のオブジェクトがインスタンスならば、そのインスタンスが
例外の値になります。第二のオブジェクトがタプルの場合、
クラスのコンストラクタに対する引数リストとして使われます; `None'
なら、空の引数リストとして扱われ、それ以外の型
ならコンストラクタに対する単一の引数として扱われます。
このようにしてコンストラクタを呼び出して生成したインスタンス
が例外の値になります。

第三のオブジェクトが存在し、かつ `None' でなければ、
オブジェクトはトレースバック  オブジェクト でなければなりません (~*Note
標準型の階層:: 節参照)。また、
例外が発生した場所は現在の処理位置に置き換えられます。
第三のオブジェクトが存在し、オブジェクトがトレースバック
オブジェクトでも `None' でもなければ、`TypeError'
例外が送出されます。`raise' の三連式型は、`except'
節から透過的に例外を再送出するのに便利ですが、再送出すべき
例外が現在のスコープで発生した最も新しいアクティブな例外で
ある場合には、式なしの `raise' を使うよう推奨します。

例外に関する追加情報は ~*Note 例外:: 節にあります。また、
例外処理に関する情報は ~*Note try 文:: 節にあります。


File: python-ref-jp.info,  Node: break 文,  Next: continue 文,  Prev: raise 文,  Up: 単純文 simple statement

`break' 文
==========

`break_stmt "break"'

`break' 文は `for' ループや `while' ループ内の
ネストで構文法的にのみ現れますが、ループ内の関数定義やクラス定義
には現れません。

`break' 文は、文を囲う最も内側のループを終了させ、 ループにオプションの
`else' 節がある場合には `else' 節に飛びます。

`for' ループを `break' によって終了すると、
ループ制御ターゲットはその時の値を保持します。

`break' が `finally' 節を伴う `try' 文の
外側に処理を渡す際には、ループを実際に抜ける前にその`finally'
節が実行されます。


File: python-ref-jp.info,  Node: continue 文,  Next: import 文,  Prev: break 文,  Up: 単純文 simple statement

`continue' 文
=============

`continue_stmt "continue"'

`continue' 文は `for' ループや `while' ループ内の
ネストで構文法的にのみ現れますが、ループ内の関数定義やクラス定義、
`try' 文の中には現れません。(1)

`continue' 文は、文を囲う最も内側のループの次の周期に 処理を継続します。

---------- Footnotes ----------

(1) `except' 節や `else' 節中に置くことはできます。`try' 文に置けない
という制限は、実装側の不精によるもので、そのうち改善されることでしょう。

