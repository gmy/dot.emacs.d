This is python-ref-jp.info, produced by makeinfo version 4.5 from
python-ref-jp.texi.

12 October 2005


File: python-ref-jp.info,  Node: 標準型の階層,  Next: 特殊メソッド名,  Prev: オブジェクト、値、および型,  Up: データモデル

標準型の階層
============

以下は Python に組み込まれている型のリストです。(C、Java、または
実装に使われているその他の言語で書かれた) 拡張モジュールでは、
その他に新たな型を定義することができます。将来のバージョンの Python
では、型の階層に新たな型 (整数を使って効率的に記憶される
有理数型、など) を追加することができるかもしれません。

以下に説明する型のいくつかには、`特殊属性 (special attribute)'
と題された段落が連ねられています。これらの属性は実装へのアクセス
手段を提供するもので、一般的な用途に利用するためのものではありません。
特殊属性の定義は将来変更される可能性があります。

`None'
     この型には単一の値しかありません。この値を持つオブジェクトはただ
     一つしか存在しません。このオブジェクトは組み込み名 `None'
     でアクセスされます。このオブジェクトは、様々な状況で値が
     存在しないことをしめします。例えば、明示的に値を返さない関数 は
     `None' を返します。`None' の真値 (truth value) は 偽 (false) です。

`NotImplemented'
     この型には単一の値しかありません。この値を持つオブジェクトはただ
     一つしか存在しません。このオブジェクトは組み込み名 `NotImplemented'
     でアクセスされます。数値演算に関するメソッドや拡張比較 (rich
     comparison)
     メソッドは、被演算子が該当する演算を行うための実装をもたない場合、
     この値を返すことがあります。(演算子によっては、インタプリタが
     関連のある演算を試したり、他の代替操作を行います。) 真値は真 (true)
     です。

`Ellipsis'
     この型には単一の値しかありません。この値を持つオブジェクトはただ
     一つしか存在しません。このオブジェクトは組み込み名 `Ellipsis'
     でアクセスされます。スライス内に `...' 構文がある場合に
     使われます。真値は真 (true)です。

`Numbers'
     数値リテラルによって作成されたり、算術演算や組み込みの算術関数に
     よって返されるオブジェクトです。数値オブジェクトは変更不能です;
     一度値が生成されると、二度と変更されることはありません。Python
     の数値オブジェクトはいうまでもなく数学で言うところの数値と
     強く関係していますが、コンピュータ内で数値を表現する際に伴う
     制限を受けています。

     Python は整数、浮動小数点数、複素数の間で区別を行っています:

    `整数型 (integer)'
          整数型は、全ての数 (whole numbers)
          を表す数学的集合内における要素を 表現する型です。

          以下に三つの整数型を示します:

         `(通常の) 整数型 (plain integer)'
               -2147483648 から 2147483647 までの整数を表現します
               (基本ワードサイズ: natural word size
               がより大きなマシンではより大きな定義域になることも
               あります。より小さくなることはありません。)
               演算の結果が定義域を超えた値になった場合、結果は通常長整数で
               返されます (場合によっては、 `OverflowError' が送出され
               ます) 。 シフト演算やマスク演算のために、整数は 32
               ビット以上の 2 の補数で 表されたバイナリ表現を持つ
               (すなわち、4294967296 の異なったビット
               パターン全てが異なる値を持つ) と仮定されています。

         `長整数型 (long integer)'
               長整数は無限の定義域を持ち、利用可能な (仮想)
               メモリサイズの制限
               のみをうけます。長整数はシフト演算やマスク演算のためにバイナリ表現を
               もつものと仮定されます。負の数は符号ビットが左に無限に延びているような
               錯覚を与える 2 の補数表現の変型で表されます。

         `ブール型 (boolean)'
               ブール型は、真値 False または True
               を表現します。ブール型の オブジェクトは False と True
               を表現する二つのオブジェクト
               だけです。ブール型は整数のサブタイプで、ほとんどの演算コンテキストに
               おいてブール型値はそれぞれ 0 または 1
               のように振舞います。
               ただし、文字列に変換されたときのみ、それぞれ文字列
               `"False"' および `"True"' が返されます。

          整数表現に関する規則は、シフト演算やマスク演算において、負の整数
          も含めて最も有意義な解釈ができるように、かつ通常の整数と長整数
          との間で定義域を切り替える際にできるだけ混乱しないように決められて
          います。左シフト以外の演算では、演算結果がオーバフローを起こさずに
          整数の定義域の値になる場合は、長整数を使った場合でも、被演算子に
          整数と長整数を混合した場合でも同じ結果になります。

    `浮動小数点数型 (floating point number)'
          この型は計算機レベルで倍精度とされている浮動小数点数を
          表現します。表現可能な値の範囲やオーバフローの扱いは、
          根底にある計算機アーキテクチャ (と C または Java 実装)
          次第です。 Python は単精度の浮動小数点数をサポートしません;
          単精度の
          数を使う理由は、通常プロセッサやメモリ使用量の節約ですが、
          こうした節約は Python
          でオブジェクトを扱う際のオーバヘッドに比べれば
          微々たるものにすぎません。従って、わざわざ浮動小数点型を 2
          つも 定義してPython 言語を難解にする理由はどこにもないのです。

    `複素数型 (complex number)'
          この型は、計算機レベルで倍精度とされている浮動小数点を 2
          つ一組
          にして複素数を表現します。浮動小数点について述べたのと同じ性質
          が当てはまります。複素数 `z' の実数部および虚数部は、
          それぞれ読み出し専用属性 `z.real' および `z.imag'
          で取り出すことができます。


`配列型 (sequence)'
     この型は、有限の順序集合 (ordered set) を表現します。要素は非負の
     整数でインデクス化されています。組み込み関数 `len()'
     を使うと、配列の要素数を返します。 配列の長さが N
     の場合、インデクスは 0, 1, ..., N-1 からなる集合です。配列 A
     の要素 I は `A[I]' で選択します。

     配列はスライス操作 (slice) もサポートしています: `A[I:J]'
     とすると、 I `<=' K `<' J であるインデクス K
     をもつ全ての要素を選択します。
     式表現としてスライスを用いた場合、スライスは同じ型をもつ新たな配列を
     表します。新たな配列内では、インデクス集合が 0 から始まるように
     インデクスの値を振りなおします。

     配列によっては、 第三の "ステップ (step)" パラメタを持つ
     "拡張スライス (extended slice)" もサポートしています: `A[I:J:K]'
     は、 `X = I + N*K', N `>=' `0' かつ I `<=' X `<' J であるような
     インデクス X を持つような A 全ての要素を選択します。

     配列は、変更可能なものか、そうでないかで区別されています:

    `変更不能な配列 (immutable sequence)'
          変更不能な配列型のオブジェクトは、一度生成されるとその値を
          変更することができません。 (オブジェクトに他のオブジェクトへの
          参照が入っている場合、参照されているオブジェクトは変更可能な
          オブジェクトでもよく、その値は変更される可能性があります;
          しかし、変更不能なオブジェクトが直接参照しているオブジェクトの
          集合自体は、変更することができません。)

          以下の型は変更不能な配列型です:

         `文字列型 (string)'
               文字列の各要素は文字 (character) です。文字型 (character
               type) は存在しません;
               単一の文字は、要素が一つだけの文字列として
               表現されます。各文字は (少なくとも) 8-bit
               のバイト列を表現します。 組み込み関数 `chr()'  および
               `ord()'  を使うと、文字と非負の整数で表された
               バイト値の間で変換を行えます。0-127
               の値を持つバイト値は、通常 同じ ASCII
               値をもつ文字を表現していますが、値をどう解釈するかは
               プログラムにゆだねられています。文字列データ型はまた、例えば
               ファイルから読み出されたデータを記憶するといった用途で、バイト値の
               アレイを表現するために用いられます。

               (ネイティブの文字セットが
               ASCIIでないシステムでは、`chr()' や `ord()' が ASCII と
               EBCDIC との間で対応付けを行っており、 文字列間の比較で
               ASCII 順が守られる限り、文字列の内部表現として EBCDIC
               を使ってもかまいません。誰か他にもっとましなルールをお持ちですか?)

         `Unicode 文字列型'
               Unicode オブジェクトの各要素は Unicode コード単位です。
               Unicode コード単位とは、単一の Unicode
               オブジェクトで、Unicode 序数を 表現する 16-bit または
               32-bit の値を保持できるものです (この序数の最大値は
               `sys.maxunicode' で与えられており、コンパイル時に Python
               がどう設定されているかに依存します)。 Unicode
               オブジェクト内 にサロゲートペア (surrogate pair)
               があってもよく、Python は サロゲートペアを二つの別々の
               Unicode 要素として報告します。 組み込み関数 `unichr()'
               および `ord()'  は、コード単位と非負の整数で表された
               Unicode 標準 3.0 で定義された Unicode
               序数との間で変換を行います。
               他の文字エンコード形式との相互変換は、 Unicode メソッド
               `encode' および組み込み関数 `unicode()'
               で行うことができます。

         `タプル型 (tuple)'
               タプルの要素は任意の Python オブジェクトにできます。
               二つまたはそれ以上の要素からなるタプルは、個々の要素を表現する
               式をカンマで区切って構成します。単一の要素からなるタプル
               (単集合 `singleton') を作るには、要素を表現する式の直後に
               カンマをつけます (単一の式だけではタプルを形成しません。
               これは、式をグループ化するのに丸括弧を使えるようにしなければ
               ならないからです)
               。要素の全くない丸括弧の対を作ると空のタプルに なります。


    `変更可能な配列型 (mutable sequence)'
          変更可能な配列は、作成した後で変更することができます。
          変更可能な配列では、添字表記やスライス表記を使って指定された要素に
          代入を行うことができ、`del' (delete) 文を使って要素を
          削除することができます。

          Python
          に最初から組み込まれている変更可能な配列型は、今のところ
          一つだけです:

         `リスト型 (list)'
               リストの要素は任意の Python
               オブジェクトにできます。リストは、
               角括弧の中にカンマで区切られた式を並べて作ります。
               (長さが 0 や 1
               の配列を作るために特殊な場合分けは必要ないことに
               注意してください。)


          拡張モジュール `array'  では、別の
          変更可能な配列型を提供しています。


`マップ型 (mapping)'
     任意のインデクス集合でインデクス化された、有限のオブジェクトからなる
     集合を表現します。添字表記 `a[k]' は、`k' でインデクス指定
     された要素を `a' から選択します; 選択された要素は式の中で
     使うことができ、代入や `del' 文の対象にすることができます。
     組み込み関数 `len()' は、マップ内の要素数を返します。

     Python に最初から組み込まれているマップ型は、今のところ
     一つだけです:

    `辞書型 (dictionary)'
          ほとんどどんな値でもインデクスとして使えるような、
          有限個のオブジェクトからなる集合を表します。キー値 (key)
          として使えない
          値は、リストや辞書を含む値や、アイデンティティではなく値でオブジェクトが
          比較される、その他の変更可能な型です。これは、辞書型を効率的に
          実装する上で、キーのハッシュ値が一定であることが必要だからです。
          数値型をキーに使う場合、キー値は通常の数値比較における規則に
          従います: 二つの値が等しくなる場合 (例えば `1' と `1.0')、
          互いに同じ辞書のエントリを表すインデクスとして使うことができます。

          辞書は変更可能な型です; 辞書は `{...}' 表記で生成します
          (~*Note 辞書表現:: 節, "辞書表現" を参照してください)。

          拡張モジュール `dbm'  、 `gdbm'  、および `bsddb'
          では、別のマップ型を提供 しています。


`呼び出し可能型 (callable type)'
     関数呼び出し操作 (~*Note 呼び出し call:: 節、"呼び出し (call)"
     参照) を行うことができる型です:

    `ユーザ定義関数 (user-defined function)'
          ユーザ定義関数オブジェクトは、関数定義を行うことで生成されます
          (~*Note 関数定義:: 節、"関数定義" 参照)。関数は、仮引数
          (formal parameter) リストと同じ数の要素が入った引数リストと
          ともに呼び出されます。

          特殊属性: `func_doc' または `__doc__' は
          関数のドキュメンテーション文字列です。ドキュメンテーションがない
          場合は `None' になります; `func_name' または `__name__'
          は関数の名前です; `__module__'
          は、関数が定義されているモジュールの名前です。
          モジュール名がない場合は `None' になります; `func_defaults'
          はデフォルト値を持つ引数に対するデフォルト値が
          収められたタプルで、デフォルト値を持つ引数がない場合には
          `None' になります; `func_code'
          はコンパイルされた関数本体を表現する コードオブジェクトです;
          `func_globals' は関数のグローバル変数 の入った辞書 (への参照)
          です -- この辞書は、関数が定義されている
          モジュールのグローバルな名前空間を決定します; `func_dict'
          または `__dict__'
          には、任意の関数属性をサポートするための名前空間が
          収められています; `func_closure' は、 `None' または
          関数の個々の自由変数（引数以外の変数）に対して値を結び付けている
          セル (cell) 群からなるタプルになります。

          上記のうち、`func_code' 、 `func_defaults' 、
          `func_doc'/`__doc__' 、および `func_dict'/`__dict__'
          は書き込み可能な属性です;
          他の属性は変更できません。関数定義に関するその他の情報は、
          関数のコードオブジェクトから得られます; 後述の内部型
          (internal type) に関する説明を参照してください。

    `ユーザ定義メソッド (user-defined method)'
          ユーザ定義のメソッドオブジェクトは、クラスやクラスインスタンス
          (あるいは `None') を任意の呼び出し可能オブジェクト (通常は
          ユーザ定義関数) と結合し (combine) ます。

          読み出し専用の特殊属性: `im_self' は
          クラスインスタンスオブジェクトで、`im_func' は関数オブジェクト
          です; `im_class' は結合メソッド (bound method) において
          `im_self' が属しているクラスか、あるいは非結合メソッド
          (unbound method) において、要求されたメソッドを定義している
          クラスです; `__doc__' はメソッドのドキュメンテーション文字列
          (`im_func.__doc__' と同じ) です; `__name__' はメソッドの 名前
          (`im_func.__name__' と同じ) です; `__module__' は
          メソッドが定義されているモジュールの名前になるか、モジュール名が
          ない場合は `None' になります。 _Changed in Python version 2.2_

          メソッドもまた、根底にある関数オブジェクトの任意の関数属性 に
          (値の設定はできませんが) アクセスできます。

          クラスの属性を (おそらくクラスのインスタンスを介して)
          取得する際には、
          その属性がユーザ定義の関数オブジェクト、非結合 (unbound)
          のユーザ定義
          メソッドオブジェクト、あるいはクラスメソッドオブジェクトであれば、
          ユーザ定義メソッドオブジェクトが生成されることがあります。
          属性がユーザ定義メソッドオブジェクトの場合、属性を取得する対象の
          オブジェクトが属するクラスがもとのメソッドオブジェクトが定義されている
          クラスと同じクラスであるか、またはそのサブクラスであれば、新たな
          メソッドオブジェクトだけが生成されます。
          それ以外の場合には、もとのメソッドオブジェクトがそのまま使われます。

          クラスからユーザ定義関数オブジェクトを取得する方法でユーザ定義
          メソッドオブジェクトを生成すると、 `im_self' 属性は `None'
          になり、メソッドオブジェクトは非結合 (unbound)
          であるといいます。クラスのインスタンスからユーザ定義関数
          オブジェクトを取得する方法でユーザ定義メソッドオブジェクトを
          生成すると、`im_self' 属性はインスタンスになり、
          メソッドオブジェクトは結合 (bound) であるといいます。
          どちらの場合も、新たなメソッドの `im_class' 属性は、
          メソッドの取得が行われたクラスになり、`im_func' 属性は
          もとの関数オブジェクトになります。

          クラスやインスタンスから他のユーザ定義メソッドオブジェクトを
          取得する方法でユーザ定義メソッドオブジェクトを生成した場合、
          その動作は関数オブジェクトの場合と同様ですが、新たなインスタンスの
          `im_func' 属性はもとのメソッドオブジェクトの属性ではなく、
          新たなインスタンスの属性になります。

          クラスやインスタンスからクラスメソッドオブジェクトを取得する
          方法でユーザ定義メソッドオブジェクトを生成した場合、
          `im_self' 属性はクラス自体 (`im_class' 属性と 同じ)
          となり、`im_func' 属性はクラスメソッドの根底に
          ある関数オブジェクトになります。

          非結合ユーザ定義メソッドオブジェクトの呼び出しの際には、
          根底にある関数 (`im_func') が呼び出されます。このとき、
          最初の引数は適切なクラス (`im_class') またはサブクラスの
          インスタンスでなければならないという制限が課されています。

          結合ユーザ定義メソッドオブジェクトの呼び出しの際には、
          根底にある関数 (`im_func') が呼び出されます。このとき、
          クラスインスタンス (`im_self') が引数の先頭に挿入され
          ます。例えば、関数 `f()' の定義が入ったクラスを `C' とし、`x'
          を `C' のインスタンスとすると、 `x.f(1)' の呼び出しは `C.f(x,
          1)' と同じになります。

          ユーザ定義メソッドオブジェクトがクラスオブジェクトから導出される際、
          `im_self' に記憶されている "クラスインスタンス" はクラス
          自体になります。これは、`x.f(1)' や `C.f(1)' の呼び出しが
          根底にある関数を `f' としたときの呼び出し `f(C,1)' と
          等価になるようにするためです。

          関数オブジェクトから (結合または非結合の)
          メソッドオブジェクトへの
          変換は、クラスやインスタンスから属性を取り出すたびに行われるので
          注意してください。場合によっては、属性をローカルな変数に代入して
          おき、その変数を使って関数呼び出しを行うと効果的な最適化になります。
          また、上記の変換はユーザ定義関数に対してのみ起こるので注意してください;
          その他の呼び出し可能オブジェクト
          (および呼び出し可能でない全ての オブジェクト)
          は、変換を受けずに取り出されます。それから、
          クラスインスタンスの属性になっているユーザ定義関数は、結合メソッドに
          変換できないと知っておくことも重要です; 結合メソッドへの変換が
          行われるのは、関数がクラスの一属性である場合 _だけ_ です。

    `ジェネレータ関数 (generator function)'
          `yield' 文 (~*Note yield 文:: 節、"`yield' 文" 参照)
          を使う関数またはメソッドは、"ジェネレータ関数" ("generator
          function") と呼ばれます。このような関数は、呼び出された
          際に、常にイテレータオブジェクトを返します。このイテレータオブジェクトは
          関数の本体を実行するために用いられます: イテレータの `next()'
          メソッドを呼び出すと、`yield' 文で値を出力する処理まで関数の
          実行が行われます。関数が `return'
          文を実行するか、関数を最後まで
          実行し終えると、`StopIteration' 例外が送出され、イテレータが
          返す値の集合はそこで終わります。

    `組み込み関数 (built-in function)'
          組み込み関数オブジェクトは C
          関数へのラッパです。組み込み関数の例は `len()' や
          `math.sin()' (`math' は標準の組み込み モジュール)
          です。引数の数や型は C 関数で決定されています。
          読み出し専用の特殊属性: `__doc__' は関数のドキュメンテーション
          文字列です。ドキュメンテーションがない場合は `None'
          になります; `__name__' は関数の名前です; `__self__' は `None'
          に設定されています (組み込みメソッドの節も参照してください);
          `__module__' は、関数が定義されているモジュールの名前です。
          モジュール名がない場合は `None' になります。

    `組み込みメソッド (built-in method)'
          実際には組み込み関数を別の形で隠蔽したもので、こちらの場合には
          C 関数に渡される何らかのオブジェクトを非明示的な外部引数として
          持っています。組み込みメソッドの例は、ALIST
          をリストオブジェクト としたときの `ALIST.append()' です。
          この場合には、読み出し専用の属性 `__self__' は ALIST
          で表されるオブジェクトになります。

    `クラス型 (class type)'
          クラス型、あるいは "新しいクラス型 (new-style class)"
          や呼び出し可能
          オブジェクトです。クラス型オブジェクトは通常、そのクラスの新たな
          インスタンスを生成する際のファクトリクラスとして振舞いますが、
          `__new__()' をオーバライドして、バリエーションを持たせることも
          できます。呼び出しの際に使われた引数は `__new__()' に渡され、
          さらに典型的な場合では新たなインスタンスを初期化するために
          `__init__()' に渡されます。

    `旧クラス型 (classic class)'
          (旧)
          クラスオブジェクトは後で詳しく説明します。クラスオブジェクトが
          呼び出されると、新たにクラスインスタンス (後述)
          が生成され、返されます。 この操作には、クラスの `__init__()'
          メソッドの呼び出し (定義されている場合)
          が含まれています。呼び出しの際に使われた引数は、 すべて
          `__init__()' メソッドに渡されます。 `__init__()'
          メソッドがない場合、クラスは引数なしで呼び出さなければ
          なりません。

    `クラスインスタンス (class instance)'
          クラスインスタンスは後で詳しく説明します。クラスインスタンスは
          クラスが `__call__()' メソッドを持っている場合にのみ呼び出す
          ことができます; `x(arguments)' とすると、
          `x.__call__(arguments)' 呼び出しを短く書けます。


`モジュール (module)'
     モジュールは `import' 文で import します (~*Note import 文:: 節、
     "`import' 文" 参照)。 モジュールオブジェクトは、辞書オブジェクト
     (モジュール内で定義されて いる関数が func_globals
     属性で参照している辞書です) で実装された
     名前空間を持っています。属性への参照は、この辞書に対する検索
     (lookup) に翻訳されます。例えば、`m.x' は `m.__dict__["x"]'
     と同じです。
     モジュールオブジェクトには、モジュールを初期化するために使われる
     コードオブジェクトは入っていません (一度初期化が終わればもう必要
     ないからです)。

     属性の代入を行うと、モジュールの名前空間辞書の内容を更新します。
     例えば、 `m.x = 1' は `m.__dict__["x"] = 1' と同じです。

     読み出し専用の特殊属性: `__dict__' はモジュールの名前空間で、
     辞書オブジェクトです。

     定義済みの (書き込み可能な) 属性: `__name__'
     はモジュールの名前です; `__doc__' は関数のドキュメンテーション
     文字列です。ドキュメンテーションがない場合は `None' になります;
     モジュールがファイルからロードされた場合、 `__file__' はロード
     されたモジュールファイルのパス名です。インタプリタに静的にリンクされて
     いる C{} モジュールの場合、`__file__' 属性はありません;
     共有ライブラリから動的にロードされた拡張モジュールの場合、この属性は
     共有ライブラリファイルのパス名になります。

`クラス'
     クラスオブジェクトはクラス定義 (~*Note クラス定義:: 節、
     "クラス定義" 参照)
     で生成されます。クラスは辞書で実装された名前空間を持っています。
     クラス属性への参照は、この辞書に対する検索 (lookup)
     に翻訳されます。例えば、`C.x' は `C.__dict__["x"]' と同じです。
     属性がこの検索で見つからない場合、現在のクラスの基底クラスへと
     検索を続けます。検索は深さ優先 (depth-first)、かつ基底クラスの
     挙げられているリスト中の左から右 (left-to-right) の順番で行われ
     ます。

     クラス (`C' とします) への属性参照で、要求している属性が
     ユーザ定義関数オブジェクトや、`C' やその基底クラスに関連付け
     られている非結合のユーザ定義メソッドオブジェクトである場合、
     `im_class' 属性が `C' であるような非結合ユーザ定義
     メソッドオブジェクトに変換されます。
     要求している属性がクラスメソッドオブジェクトの場合、 `im_class' と
     `im_self' 属性がどちらも `C'
     であるようなユーザ定義メソッドオブジェクトに変換されます。
     要求している属性が静的メソッドオブジェクトの場合、静的メソッド
     オブジェクトでラップされたオブジェクトに変換されます。
     クラスから取り出した属性と実際に `__dict__' に入っている
     ものが異なるような他の場合については、 ~*Note デスクリプタ
     descriptor の実装:: 節を 参照してください。

     クラス属性を代入すると、そのクラスの辞書だけが更新され、基底クラスの
     辞書は更新しません。

     クラスオブジェクトを呼び出す (上記を参照) と、クラスインスタンスを
     生成します (下記を参照)。

     特殊属性: `__name__' はクラス名です; `__module__'
     はクラスが定義されているモジュールの名前です; `__dict__'
     はクラスの名前空間が入った辞書です; `__bases__'
     は基底クラスの入った (空、あるいは単要素を取りえる)
     タプルで、基底クラスリストの順番になっています; `__doc__' は
     クラスのドキュメンテーション文字列です。ドキュメンテーション文字列が
     ない場合には `None' になります。

`クラスインスタンス'
     クラスインスタンスはクラスオブジェクト (上記参照) を呼び出して
     生成します。クラスインスタンスは辞書で実装された名前空間を持って
     おり、属性参照の時にはこの辞書が最初に検索されます。
     辞書内に属性が見つからず、かつインスタンスのクラスに該当する
     属性名がある場合、検索はクラス属性にまで広げられます。
     見つかったクラス属性がユーザ定義関数オブジェクトや、
     インスタンスのクラス (`C' とします) やその基底クラスに関連
     付けられている非結合のユーザ定義メソッドオブジェクトの場合、
     `im_class' 属性が `C' で `im_self' 属性が
     インスタンスになっている結合ユーザ定義メソッドオブジェクトに変換
     されます。静的メソッドやクラスメソッドオブジェクトもまた、 `C'
     から取り出した場合と同様に変換されます; 上記の "クラス"
     を参照してください。 クラスから取り出した属性と実際に `__dict__'
     に入っている ものが異なるような他の場合については、 ~*Note
     デスクリプタ descriptor の実装:: 節を 参照してください。
     クラス属性が見つからず、かつオブジェクトのクラスが `__getattr__()'
     メソッドを持っている場合、このメソッドを
     呼び出して属性名の検索を充足させます。

     属性の代入や削除を行うと、インスタンスの辞書を更新しますが、クラスの
     辞書を更新することはありません。クラスで `__setattr__()' や
     `__delattr__()' メソッドが定義されている場合、直接インスタンスの
     辞書を更新する代わりにこれらのメソッドが呼び出されます。

     クラスインスタンスは、ある特定の名前のメソッドを持っている
     場合、数値型や配列型、あるいはマップ型のように振舞うことが
     できます。~*Note 特殊メソッド名:: 節、 "特殊メソッド名" を参照
     してください。

     特殊属性: `__dict__' は属性の辞書です; `__class__'
     はインスタンスのクラスです。

`ファイル (file)'
     ファイル  オブジェクトは開かれたファイルを表します。
     ファイルオブジェクトは組み込み関数 `open()'

     や、 `os.popen()', `os.fdopen()', および socke オブジェクトの
     `makefile()' メソッド
     (その他の拡張モジュールで提供されている関数やメソッド) で生成
     されます。 `sys.stdin', `sys.stdout' および `sys.stderr'
     といったオブジェクトは、 インタプリタの標準入力
     、標準出力、および標準エラー出力
     ストリームに対応するよう初期化されます。ファイルオブジェクトに
     関する完全な記述については、 を参照してください。

`内部型 (internal type)'
     インタプリタが内部的に使っているいくつかの型は、ユーザに公開されています。
     これらの定義は将来のインタプリタのバージョンでは変更される可能性が
     ありますが、ここでは記述の完全性のために触れておきます。

    `コードオブジェクト'
          コードオブジェクトは _バイトコンパイルされた (byte-compiled)_
          実行可能な Python コード、別名 _バイトコード (bytecode)_ を
          表現します。コードオブジェクトと関数オブジェクトの違いは、
          関数オブジェクトが関数のグローバル変数
          (関数を定義しているモジュールの グローバル)
          に対して明示的な参照を持っているのに対し、コードオブジェクト
          にはコンテキストがないということです;
          また、関数オブジェクトでは
          デフォルト引数値を記憶できますが、コードオブジェクトではできません
          (実行時に計算される値を表現するため)。関数オブジェクトと違い、
          コードオブジェクトは変更不可能で、変更可能なオブジェクトへの参照を
          (直接、間接に関わらず) 含みません。

          読み出し専用の特殊属性: `co_name' は関数名を表します;
          `co_argcount' は固定引数 (positional argument) の数です;
          `co_nlocals' は関数が使う (引数を含めた) ローカル変数の数です;
          `co_varnames' はローカル変数名の入ったタプルです (引数名
          から始まっています); `co_cellvars' はネストされた関数で
          参照されているローカル変数の名前が入ったタプルです;
          `co_freevars' は自由変数の名前が入ったタプルです。 `co_code'
          はバイトコード列を表現している文字列です; `co_consts'
          はバイトコードで使われているリテラルの入った タプルです;
          `co_names' はバイトコードで使われている名前
          の入ったタプルです; `co_filename' はバイトコードのコンパイル
          が行われたファイル名です; `co_firstlineno' は関数の最初の
          行番号です; `co_lnotab' はバイトコードオフセットから行番号
          への対応付けをコード化した文字列です
          (詳細についてはインタプリタの
          ソースコードを参照してください); `co_stacksize' は関数で
          (ローカル変数の分も含めて) 必要なスタックサイズです;
          `co_flags' はインタプリタ用の様々なフラグをコード化した
          整数です。

          以下のフラグビットが `co_flags' で定義されています: `0x04'
          ビットは、関数が `*arguments' 構文を使って
          任意の数の固定引数を受理できる場合に立てられます; `0x08'
          ビットは、関数が `**keywords' 構文を使って
          キーワード引数を受理できる場合に立てられます; `0x20'
          ビットは、関数がジェネレータである場合に立てられます。

          将来機能 (future feature) 宣言 (`from __future__ import
          division') もまた、`co_flags'
          のビットを立てることで、コードオブジェクトが
          特定の機能を有効にしてコンパイルされていることを示します:
          `0x2000' ビットは、関数が将来機能を有効にしてコンパイルされて
          いる場合に立てられます; 以前のバージョンの Python では、`0x10'
          および `0x1000' ビットが使われていました。

          `co_flags' のその他のビットは将来に内部的に利用するために
          予約されています。

          コードオブジェクトが関数を表現している場合、`co_consts'
          の最初の 要素は関数のドキュメンテーション文字列

          になります。ドキュメンテーション文字列が定義されていない場合には
          `None' になります。

    `フレーム (frame) オブジェクト'
          フレームオブジェクトは実行フレーム (execution frame)
          を表します。
          実行フレームはトレースバックオブジェクト内に出現します
          (下記参照)。

          読み出し専用の特殊属性: `f_back' は (呼び出し側にとっての)
          以前のスタックフレームです。呼び出し側がスタックフレームの最下段で
          ある場合には `None' です; `f_code' は現在のフレームで
          実行しようとしているコードオブジェクトです; `f_locals'
          はローカル変数を検索するために使われる辞書です; `f_globals'
          はグローバル変数用です; `f_builtins' は組み込みの (Python
          固有の) 名前です; `f_restricted' は、関数が制限つき実行
          (restricted execution)
          モードで実行されているかどうかを示すフラグです; `f_lasti'
          は厳密な命令コード
          (コードオブジェクト中のバイトコード文字列への インデクス)
          です。

          書き込み可能な特殊属性: `f_trace' が `None' でない場合、
          各ソースコード行の先頭で呼び出される関数になります;
          `f_exc_type', `f_exc_value', `f_exc_traceback'
          は、現在のフレームでもっとも最近捕捉された例外を表します;
          `f_lineno' はフレーム中における現在の行番号です --
          トレース関数 (trace function)
          側でこの値に書き込みを行うと、指定した行にジャンプ します
          (最下段の実行フレームにいるときのみ) 。デバッガでは、
          f_fileno を書き込むことで、ジャンプ命令 (Set Next Statement
          命令とも 呼ばれます) を実装できます。

    `トレースバック (traceback) オブジェクト'
          トレースバックオブジェクトは例外のスタックトレースを表現します。
          トレースバックオブジェクトは例外が発生した際に生成されます。
          例外ハンドラを検索して実行スタックを戻っていく際、戻ったレベル
          毎に、トレースバックオブジェクトが現在のトレースバックの前に
          挿入されます。例外ハンドラに入ると、スタックトレースを
          プログラム側で利用できるようになります (~*Note try 文:: 節
          "`try' 文" を参照)。 トレースバックは `sys.exc_traceback'
          として得ることができ、 `sys.exc_info()'
          が返すタプルの三番目の要素としても得られます.
          インタフェースとしては後者の方が推奨されていますが、これは
          プログラムがマルチスレッドを使っている場合に正しく動作するからです。
          プログラムに適切なハンドラがない場合、スタックトレースは
          (うまく 書式化されて) 標準エラーストリームに書き出されます;
          インタプリタが
          対話的に実行されている場合、`sys.last_traceback' として
          得ることもできます。

          読み出し専用の特殊属性: `tb_next' はスタックトレース内の
          (例外の発生しているフレームに向かって) 次のレベルです。
          次のレベルが存在しない場合には `None' になります; `tb_frame'
          は現在のレベルにおける実行フレームを指します; `tb_lineno'
          は例外の発生した行番号です; `tb_lasti'
          は厳密な命令コードです。トレースバック内の行番号や最後に実行された
          命令は、`try' 文内で例外が発生し、かつ対応する `except' 節や
          `finally' 節がない場合には、
          フレームオブジェクト内の行番号とは異なるかもしれません。

    `スライス (slice) オブジェクト'
          スライスオブジェクトは _拡張スライス構文 (extended slice
          syntax)_
          が使われた際にスライスを表現するために使われます。拡張スライス構文とは、
          二つのコロンや、コンマで区切られた複数のスライスや省略符号
          (ellipse) を使ったスライスで、例えば `a[i:j:step]' 、 `a[i:j,
          k:l]' 、 あるいは `a[..., i:j]'
          です。スライスオブジェクトは組み込み関数 `slice()'
          で生成されます。

          読み出し専用の特殊属性: `start' は下境界 (lower bound) です;
          `stop' は上境界 (upper bound) です; `step' はステップ値 (step
          value) です; それぞれ省略されている場合には `None'
          になります。 これらの属性は任意の型の値をとることができます。

          スライスオブジェクトはメソッドを一つサポートします:

         `indices(self, length)'
               このメソッドは単一の整数引数 LENGTH を取り、LENGTH
               個の要素からなる配列に適用した際にスライスオブジェクトから提供
               することになる、拡張スライスに関する情報を計算します。
               このメソッドは三つの整数からなるタプルを返します;
               それぞれ START および STOP のインデクスと、STEP または
               スライス間の幅に対応します。インデクス値がないか、範囲外の値
               である場合、通常のスライスに対して一貫性のあるやりかたで扱われます。
               _Added in Python version 2.3_

    `静的メソッド (static method) オブジェクト'
          静的メソッドは、上で説明したような関数オブジェクトからメソッド
          オブジェクトへの変換を阻止するための方法を提供します。静的メソッド
          オブジェクトは他の何らかのオブジェクト、通常はユーザ定義メソッド
          オブジェクトを包むラッパです。静的メソッドをクラスやクラスインスタンス
          から取得すると、実際に返されるオブジェクトはラップされたオブジェクト
          になり、それ以上は変換の対象にはなりません。静的メソッドオブジェクト
          は通常呼び出し可能なオブジェクトをラップしますが、静的オブジェクト自体は
          呼び出すことができません。静的オブジェクトは組み込みコンストラクタ
          `staticmethod()' で生成されます。

    `クラスメソッドオブジェクト'
          クラスメソッドオブジェクトは、静的メソッドオブジェクトに似て、
          別のオブジェクトを包むラッパであり、そのオブジェクトをクラスや
          クラスインスタンスから取り出す方法を代替します。
          このようにして取得したクラスメソッドオブジェクトの動作については、
          上の "ユーザ定義メソッド (user-defined method)"
          で説明されています。
          クラスメソッドオブジェクトは組み込みのコンストラクタ
          `classmethod()' で生成されます。




File: python-ref-jp.info,  Node: 特殊メソッド名,  Prev: 標準型の階層,  Up: データモデル

特殊メソッド名
==============

特殊な名前をもったメソッドを定義することで、特殊な構文 (算術演算や
添え字表記、スライス表記のような) 特定の演算をクラスで実装することが
できます。 これは、個々のクラスが Python
言語で提供されている演算子に対応した
独自の振る舞いをできるようにするための、"演算子のオーバロード"
("operator overloading") に対する Python のアプローチです。
例えば、あるクラスが `__getitem__()' という名前のメソッドを定義
しており、`x' がこのクラスのインスタンスであるとすると、 `x[i]' は
`x.__getitem__(i)' と等価になります。特に注釈の
ない限り、適切なメソッドが定義されていない場合にこのような演算を行おうと
すると例外が送出されます。

組み込み型をエミュレーションするようなクラスを実装する際には、
エミューレーションの実装をモデル化しようとしているオブジェクトで
意味のある範囲だけにとどめることが重要です。
例えば、配列によっては個々の要素の取り出し操作が意味のある操作で
ある一方、スライスの抽出が意味をなさないことがあります。 (W3C
ドキュメントオブジェクトモデルにおける `NodeList'
インタフェースがその一例です。)

* Menu:

* 基本的なカスタマイズ::
* 属性値アクセスをカスタマイズする::
* クラス生成をカスタマイズする::
* 呼び出し可能オブジェクトをエミュレートする::
* コンテナをエミュレートする::
* 配列型エミュレーションで使われるその他のメソッド::
* 数値型をエミュレーションする::
* 型強制規則 coercion rule::


File: python-ref-jp.info,  Node: 基本的なカスタマイズ,  Next: 属性値アクセスをカスタマイズする,  Prev: 特殊メソッド名,  Up: 特殊メソッド名

基本的なカスタマイズ
--------------------

`__init__(self[, ...])'
     インスタンスが生成された際に呼び出されるコンストラクタ
     (constructor) です。
     引数はそのクラスのコンストラクタ式に渡した引数になります。
     基底クラスが`__init__()' メソッドを持っている場合、 導出クラスの
     `__init__()' メソッドでは、 例えば `BaseClass.__init__(SELF,
     [ARGS...])' の ように、必要ならば明示的に基底クラスの`__init__()'
     メソッドを
     呼び出して、インスタンスの基底クラスに関わる部分が正しく初期化される
     ようにしなければなりません。コンストラクタには、値を返してはならない
     という特殊な制限があります; 値を返すようにすると、実行時に
     `TypeError' の送出を引き起こします。

`__del__(self)'
     インスタンスが消滅させられる際に呼び出されます。このメソッドは
     デストラクタ (destructor)  とも呼ばれます。
     基底クラスが`__del__()' メソッドを持っている場合、 導出クラスの
     `__del__()' メソッドでは、必要ならば明示的に
     基底クラスの`__del__()' メソッドを
     呼び出して、インスタンスの基底クラスに関わる部分が正しく消滅処理
     されるようにしなければなりません。 `__del__()'
     メソッドでインスタンスに対する新たな参照を
     作ることで、インスタンスの消滅を遅らせることができます
     (とはいえ、推奨しません！)。このようにすると、新たに作成された
     参照がその後削除された際にもう一度 `__del__()' メソッド
     が呼び出されます。
     インタプリタが終了する際に残っているオブジェクトに対して、
     `__del__()' メソッドが呼び出される保証はありません。

     _Notice:_ `del x' は直接 `x.__del__()' を呼び出しません -- 前者は
     `x' への参照カウント (reference count) を 1 つ減らし、 後者は `x'
     への参照カウントがゼロになった際にのみ呼び出されます。
     オブジェクトへの参照カウントがゼロになるのを妨げる可能性のある
     よくある状況には、以下のようなものがあります: 複数のオブジェクト間
     における循環参照
     (二重リンクリストや、親と子へのポインタを持つツリー データ構造);
     例外を捕捉した関数におけるスタックフレーム上にある
     オブジェクトへの参照 (`sys.exc_traceback' に記憶されている
     トレースバックが、スタックフレームを生き延びさせます);
     または、対話モードでハンドルされなかった例外を送出した
     スタックフレーム上にあるオブジェクトへの参照 (`sys.last_traceback'
     に記憶されているトレースバックが、
     スタックフレームを生き延びさせます);
     最初の状況については、明示的に循環参照を壊すしか解決策は
     ありません; 後者の二つの状況は、`None' を `sys.exc_traceback' や
     `sys.last_traceback' に
     入れることで解決できます。ごみオブジェクトと化した循環参照は、
     オプションの循環参照検出機構 (cycle detector) が有効にされて
     いる場合 (これはデフォルトの設定です) には検出されますが、
     検出された循環参照を消去するのは Python レベルで `__del__()'
     メソッドが定義されていない場合だけです。 `__del__()'
     メソッドが循環参照検出機構でどのように 扱われるか、とりわけ
     `garbage' 値の記述に関しては、 `gc' モジュール の
     ドキュメントを参照してください。

     _Notice:_ [warning] `__del__()'
     メソッドの呼び出しが起きるのは不安定な状況 なので、`__del__()'
     の実行中に発生した例外は無視され、 代わりに `sys.stderr'
     に警告が出力されます。また、 (例えばプログラムの実行終了による)
     モジュールの削除に伴って `__del__()'
     が呼び出される際には、`__del__()'
     メソッドが参照している他のグローバル変数はすでに削除されている
     かもしれません。この理由から、 `__del__()' メソッドでは
     外部の不変関係を維持する上で絶対最低限必要なことだけをすべき
     です。バージョン 1.5 からは、単一のアンダースコアで始まるような
     グローバル変数は、他のグローバル変数が削除される前にモジュール
     から削除されるように Python 側で保証しています; これらの
     アンダースコア付きグローバル変数は、`__del__()' が呼び
     出された際に、import されたモジュールがまだ残っているか確認
     する上で役に立ちます。


`__repr__(self)'
     組み込み関数`repr()'  や、文字列への 変換 (逆クオート表記: reverse
     quote) の際に呼び出され、 オブジェクトを表す "公式の (official)"
     文字列を計算します。
     可能な場合には、この値は同じ値を持ったオブジェクトを
     (適切な環境で) 再生成するために使えるような有効な Python 式に
     似せるべきです。それが不可能なら、`<...SOME USEFUL
     DESCRIPTION...>' 形式の文字列を返してください。
     戻り値は文字列オブジェクトでなければなりません。 クラスが
     `__repr__()' を定義しているが `__str__()'
     を定義していない場合、そのクラスのインスタンスに対する "非公式の
     (informal)" 文字列表現が必要なときにも `__repr__()' が使われます。

     この関数はデバッグの際によく用いられるので、たくさんの情報を
     含み、あいまいでないような表記にすることが重要です。

`__str__(self)'
     組み込み関数 `str()'  および `print'  文によって呼び出され、
     オブジェクトを表す "非公式の (informa)" 文字列を計算します。
     このメソッドは、有効な Python 式を返さなくても良いという点で、
     `__repr__()' と異なります: その代わり、より便利で分かりやすい
     表現を返すようにしてください。戻り値は文字列オブジェクトで
     なければなりません。

`__lt__(self, other)'

`__le__(self, other)'

`__eq__(self, other)'

`__ne__(self, other)'

`__gt__(self, other)'

`__ge__(self, other)'
     _Added in Python version 2.1_ これらのメソッドは "拡張比較 (rich
     comparison)" メソッドと呼ばれ、 下記の `__cmp__()'
     に優先して呼び出されます。
     演算子シンボルとメソッド名の対応は以下の通りです: `X<Y' は
     `X.__lt__(Y)' を呼び出します; `X<=Y' は `X.__le__(Y)'
     を呼び出します; `X==Y' は `X.__eq__(Y)' を呼び出します; `X!=Y'
     および `X<>Y' は `X.__ne__(Y)' を呼び出します; `X>Y' は
     `X.__gt__(Y)' を呼び出します; `X>=Y' は `X.__ge__(Y)'
     を呼び出します。
     これらのメソッドは任意の値を返すことができますが、比較演算子が
     ブール値のコンテキストで使われた場合、戻り値はブール値として
     解釈可能でなければなりません。そうでない場合には `TypeError'
     が送出されます。 慣習的には、 `False' は偽値、 `True'
     は真値として用いられ ます。

     比較演算子間には、暗黙的な論理関係はありません。すなわち、 `X==Y'
     が真である場合、暗黙のうちに `X!=Y' が偽になるわけではありません。
     従って、`__eq__' を実装する際、演算子が期待通りに
     動作するようにするために `__ne__' も定義する必要があります。

     これらのメソッドには、(左引数が演算をサポートしないが、右引数は
     サポートする場合に用いられるような) 鏡像となる (引数を入れ替えた)
     バージョンは存在しません; むしろ、`__lt__()' と `__gt__()'
     は互いに鏡像であり、`__le__()' と `__ge__()' 、および `__eq__()' と
     `__ne__()' はそれぞれ互いに鏡像です。

     拡張比較メソッドの引数には型強制 (coerce) が起こりません。
     与えられた引数ペアの間で演算が実装されていない場合、拡張比較
     メソッドは `NotImplemented' を返します。

`__cmp__(self, other)'
     拡張比較 (上参照) が定義されていない場合、比較演算によって
     呼び出されます。`self < other' である場合には負の値、 `self ==
     other' ならばゼロ、`self > other' であれば
     正の値を返さなければなりません。演算 `__cmp__()' 、`__eq__()'
     および `__ne__()' がいずれも定義されていない場合、
     クラスインスタンスはオブジェクトのアイデンティティ ("アドレス")
     で比較されます。自作の比較演算をサポートするオブジェクトや、
     辞書のキーとして使えるオブジェクトを生成するには、 `__hash__()'
     に関する記述を参照してください。 (注意: `__cmp__()'
     が例外を伝播しないという制限は Python 1.5 から除去されました。)

`__rcmp__(self, other)'
     _Changed in Python version 2.1_

`__hash__(self)'
     辞書演算  の際にキーとなるオブジェクトに対して
     呼び出されたり、組み込み関数 `hash()' から呼び出されたり します。
     辞書演算におけるハッシュ値として利用できる、32 ビットの
     整数を返さなければなりません。
     このメソッドに必要な性質は、比較結果が等価であるオブジェクトは
     同じハッシュ値をもつということです; オブジェクト間で比較を
     行う際には、オブジェクトの各要素に対するハッシュ値を
     (排他的論理和をとるなどして) 何らかの方法で混合するよう勧めます。
     クラスが `__cmp__()' メソッドを定義していない場合、 `__hash__()'
     メソッドも定義してはなりません; クラスが `__cmp__()' または
     `__eq__()' を定義しているが、 `__hash__()'
     を定義していない場合、インスタンスを
     辞書のキーとして使うことはできません。
     クラスが変更可能なオブジェクトを定義しており、`__cmp__()' または
     `__eq__()' メソッドを実装している場合、`__hash__()'
     を定義してはなりません。これは、辞書の実装においてハッシュ値が変更不能
     であることが要求されているからです (オブジェクトのハッシュ値が変化
     すると、キーが誤ったハッシュバケツ: hash bucket に入っていることに
     なってしまいます)。

`__nonzero__(self)'
     真値テストや組み込み演算 `bool()' を実現するために呼び出され ます;
     `False' または `True' か、等価な整数値 `0' または `1'
     を返さなければなりません。
     このメソッドが定義されていない場合、`__len__()' (下記参照)
     が定義されていれば呼び出されます。`__len__()' と `__nonzero__()'
     のどちらもクラスで定義されていない場合、
     そのクラスのインスタンスはすべて真の値を持つものとみなされます。

`__unicode__(self)'
     組み込み関数 `unicode()'  を実現 するために呼び出されます。Unicode
     オブジェクトを返さなければ
     なりません。このメソッドが定義されていなければ、文字列への
     変換が試みられ、その結果がデフォルトの文字エンコードを用いて
     Unicode に変換されます。


File: python-ref-jp.info,  Node: 属性値アクセスをカスタマイズする,  Next: クラス生成をカスタマイズする,  Prev: 基本的なカスタマイズ,  Up: 特殊メソッド名

属性値アクセスをカスタマイズする
--------------------------------

以下のメソッドを定義して、クラスインスタンスへの属性値アクセス (
属性値の使用、属性値への代入、`x.name' の削除) の意味を
カスタマイズすることができます。

`__getattr__(self, name)'
     属性値の検索を行った結果、通常の場所に属性値が見つからなかった
     場合 (すなわち、`self' のインスタンス属性でなく、かつクラスツリー
     にも見つからなかった場合) に呼び出されます。 このメソッドは
     (計算された) 属性値を返すか、`AttributeError'
     例外を送出しなければなりません。

     通常のメカニズムを介して属性値が見つかった場合、`__getattr__()'
     は呼び出されないので注意してください。(`__getattr__()' と
     `__setattr__()' の間は意図的に非対称性にされています。
     これは`__getattr__()' および `__setattr__()' 双方に
     とっての効率性という理由と、こうしなければ `__setattr__()'
     がインスタンスの他の属性値にアクセスする方法がなくなるためです。
     少なくともインスタンス変数に対しては、値をインスタンスの属性値
     辞書に挿入しないようにして
     (代わりに他のオブジェクトに挿入することで)
     属性値が完全に制御されているように見せかけられることに注意してください。
     新形式のクラスで実際に完全な制御を行う方法は、以下の
     `__getattribute__()' メソッドを参照してください。

`__setattr__(self, name, value)'
     属性値への代入が試みられた際に呼び出されます。このメソッドは
     通常の代入メカニズム (すなわち、インスタンス辞書への値の代入)
     の代わりに呼び出されます。 NAME は属性名で、VALUE
     はその属性に代入する値です。

     `__setattr__()' の中でインスタンス属性値への代入が必要
     な場合、単に `self.NAME = value' としてはなりません --
     このようにすると、自分自身に対する再帰呼び出しがおきてしまいます。
     その代わりに、インスタンス属性の辞書に値を挿入してください。
     例えば、`self.__dict__[NAME] = value' とします。
     新しい形式のクラスでは、インスタンス辞書にアクセスするのではなく、
     基底クラスのメソッドを同じ属性名で呼び出します。例えば、
     `object.__setattr__(self, name, value)' とします。

`__delattr__(self, name)'
     `__setattr__()' に似ていますが、代入ではなく値の削除を
     行います。このメソッドを実装するのは、オブジェクトにとって `del
     obj.NAME' が意味がある場合だけにしなければなりません。

* Menu:

* 新しい形式のクラスのための別の属性アクセス::
* デスクリプタ descriptor の実装::
* デスクリプタを呼び出す::
* __slots__::

