This is python-lib-jp.info, produced by makeinfo version 4.5 from
python-lib-jp.texi.

12 October 2005


File: python-lib-jp.info,  Node: UserList,  Next: UserString,  Prev: UserDict,  Up: Python ランタイム サービス

リストオブジェクトのためのクラスラッパー
========================================

リストオブジェクトのためのクラスラッパー。

_Note:_ このモジュールは後方互換性のためだけに残されています。Python
2.2より前のバージョンのPythonで動作する必要のないコードを書いているのならば、組み込み`list'型から直接サブクラス化することを検討してください。

このモジュールはリストオブジェクトのラッパーとして働くクラスを定義します。独自のリストに似たクラスのために役に立つ基底クラスで、これを継承し既存のメソッドをオーバーライドしたり、あるいは、新しいものを追加したりすることができます。このような方法で、リストに新しい振る舞いを追加できます。

`UserList'モジュールは`UserList'クラスを定義しています:

`UserList([list])'
     リストをシミュレートするクラス。インスタンスの内容は通常のリストに保存され、`UserList'インスタンスの`data'属性を通してアクセスできます。インスタンスの内容は最初にLISTのコピーに設定されますが、デフォルトでは空リスト`[]'です。LISTは通常のPythonリストか、`UserList'(またはサブクラス)のインスタンスのどちらかです。

変更可能シーケンスのメソッドと演算(節*Note
配列型::を参照)に加えて、`UserList'インスタンスは次の属性を提供します:

`data'
     `UserList'クラスの内容を保存するために使われる実際のPythonリストオブジェクト。

*サブクラス化の要件:*
`UserList'のサブクラスは引数なしか、あるいは一つの引数のどちらかとともに呼び出せるコンストラクタを提供することが期待されます。新しいシーケンスを返すリスト演算は現在の実装クラスのインスタンスを作成しようとします。そのために、データ元として使われるシーケンスオブジェクトである一つのパラメータとともにコンストラクタを呼び出せると想定しています。

導出クラスがこの要求に従いたくないならば、このクラスがサポートしているすべての特殊メソッドはオーバーライドされる必要があります。その場合に提供される必要のあるメソッドについての情報は、ソースを参考にしてください。

_Changed in Python version 2.0_


File: python-lib-jp.info,  Node: UserString,  Next: operator,  Prev: UserList,  Up: Python ランタイム サービス

文字列オブジェクトのためのクラスラッパー
========================================

文字列オブジェクトのためのクラスラッパー。

_Note:_
このモジュールの`UserString'クラスは後方互換性のためだけに残されています。Python
2.2より前のバージョンのPythonで動作する必要のないコードを書いているのならば、`UserString'を使う代わりに組み込み`str'型から直接サブクラス化することを検討してください(組み込みの`MutableString'と等価なものはありません)。

このモジュールは文字列オブジェクトのラッパーとして働くクラスを定義します。独自の文字列に似たクラスのために役に立つ基底クラスで、これを継承し既存のメソッドをオーバーライドしたり、あるいは、新しいものを追加したりすることができます。このような方法で、文字列に新しい振る舞いを追加できます。

これらのクラスは実際のクラスやユニコードオブジェクトに比べてとても効率が悪いということに注意した方がよいでしょう。これは特に`MutableString'に対して当てはまります。

`UserString'モジュールは次のクラスを定義しています:

`UserString([sequence])'
     文字列またはユニコード文字列オブジェクトをシミュレートするクラス。インスタンスの内容は通常の文字列またはユニコード文字列オブジェクトに保存され、`UserString'インスタンスの`data'属性を通してアクセスできます。インスタンスの内容は最初にSEQUENCEのコピーに設定されます。SEQUENCEは通常のPython文字列またはユニコード文字列、`UserString'(またはサブクラス)のインスタンス、あるいは組み込み`str()'関数を使って文字列に変換できる任意のシーケンスのいずれかです。

`MutableString([sequence])'
     このクラスは上の`UserString'から導出され、_変更可能に_なるように文字列を再定義します。変更可能な文字列は辞書のキーとして使うことができません。なぜなら、辞書はキーとして_変更不能な_オブジェクトを要求するからです。このクラスの主な目的は、辞書のキーとして変更可能なオブジェクトを使うという試みを捕捉するために、継承と`__hash__()'メソッドを取り除く(オーバーライドする)必要があることを示す教育的な例を提供することです。そうしなければ、非常にエラーになりやすく、突き止めることが困難でしょう。

文字列とユニコードオブジェクトのメソッドと演算(節*Note
文字列メソッド::、"文字列メソッド"を参照)に加えて、`UserString'インスタンスは次の属性を提供します:

`data'
     `UserString'クラスの内容を保存するために使われる実際のPython文字列またはユニコードオブジェクト。


File: python-lib-jp.info,  Node: operator,  Next: inspect,  Prev: UserString,  Up: Python ランタイム サービス

関数形式の標準演算子
====================

組み込み関数形式になっている全ての Python の標準演算子。

`operator' モジュールは、Python 固有の各演算子に対応している C
言語で実装された関数セットを提供します。例えば、 `operator.add(x, y)'
は式 `x+y' と等価です。関数名は 特殊なクラスメソッドとして扱われます;
便宜上、先頭と末尾の `__' を取り除いたものも提供されています。

これらの関数はそれぞれ、オブジェクトの比較、論理演算、数学演算、
配列操作、および抽象型テストに分類されます。

オブジェクト比較関数は全てのオブジェクトで有効で、関数の名前は
サポートする大小比較演算子からとられています:

`lt(a, b)'

`le a, b'

`eq a, b'

`ne a, b'

`ge a, b'

`gt a, b'

`__lt__ a, b'

`__le__ a, b'

`__eq__ a, b'

`__ne__ a, b'

`__ge__ a, b'

`__gt__ a, b'
     これらは  A および B の大小比較を行います。 特に、 `lt(A, B)' は
     `A < B'、 `le(A, B)' は `A <= B'、 `eq(A, B)' は `A == B'、 `ne(A,
     B)' は `A != B'、 `gt(A, B)' は `A > B'、 そして `ge(A, B)' は `A
     >= B' と等価です。

     組み込み関数 `cmp()' と違って、これらの関数はどのような
     値を返してもよく、ブール代数値として解釈できてもできなくても
     かまいません。大小比較の詳細については

     を参照してください。 _Added in Python version 2.2_

論理演算もまた全てのオブジェクトに対して適用することができ、
真値テスト、同一性テストおよびブール演算をサポートします:

`not_(o)'

`__not__ o'
     `not' O の結果を返します。(オブジェクトのインスタンス には
     `__not__()' メソッドは適用されないので注意してください;
     この操作を定義しているのはインタプリタコアだけです。結果は
     `__nonzero__()' および `__len__()' メソッドによって 影響されます。)

`truth(o)'
     O が真の場合 `True' を返し、そうでない場合 `False'
     を返します。この関数は`bool'のコンストラクタ呼び出しと同等です。

`is_(a, b)'
     `A is B' を返します。オブジェクトの同一性をテストします。

`is_not(a, b)'
     `A is not B' を返します。オブジェクトの同一性をテストします。

演算子で最も多いのは数学演算およびビット単位の演算です:

`abs(o)'

`__abs__ o'
     O の絶対値を返します。

`add(a, b)'

`__add__ a, b'
     数値 A および B について A `+' B を 返します。

`and_(a, b)'

`__and__ a, b'
     A と B の論理積を返します。

`div(a, b)'

`__div__ a, b'
     `__future__.division' が有効でない場合には A `/' B
     を返します。"古い(classic)" 除算としても知られています。

`floordiv(a, b)'

`__floordiv__ a, b'
     A `//' B を返します。 _Added in Python version 2.2_

`inv(o)'

`invert o'

`__inv__ o'

`__invert__ o'
     O のビット単位反転を返します。`~'O と 同じです。Python 2.0
     では名前 `invert()' および `__invert__()' が追加されました。

`lshift(a, b)'

`__lshift__ a, b'
     A の B ビット左シフトを返します。

`mod(a, b)'

`__mod__ a, b'
     A `%' B を返します。

`mul(a, b)'

`__mul__ a, b'
     数値 A および B について A `*' B を返します。

`neg(o)'

`__neg__ o'
     O の符号反転を返します。

`or_(a, b)'

`__or__ a, b'
     A と B の論理和を返します。

`pos(o)'

`__pos__ o'
     O の符号非反転を返します。

`pow(a, b)'

`__pow__ a, b'
     数値 A および B について A `**' B を返します。 _Added in Python
     version 2.3_

`rshift(a, b)'

`__rshift__ a, b'
     A の B ビット右シフトを返します。

`sub(a, b)'

`__sub__ a, b'
     A `-' B を返します。

`truediv(a, b)'

`__truediv__ a, b'
     `__future__.division' が有効な場合 A `/' B
     を返します。除算としても知られています。 _Added in Python version
     2.2_

`xor(a, b)'

`__xor__ a, b'
     A および B の排他的論理和を返します

配列を扱う演算子には以下のようなものがあります:

`concat(a, b)'

`__concat__ a, b'
     配列 A および B について A `+' B を返します。

`contains(a, b)'

`__contains__ a, b'
     B `in' A を調べた結果を返します。
     演算子が反転しているので注意してください。関数名 `__contains__()'
     は Python 2.0 で追加されました。

`countOf(a, b)'
     A の中に B が出現する回数を返します。

`delitem(a, b)'

`__delitem__ a, b'
     A でインデクスが B の要素を削除します。

`delslice(a, b, c)'

`__delslice__ a, b, c'
     A でインデクスが B から C`-1' のスライス要素を 削除します。

`getitem(a, b)'

`__getitem__ a, b'
     A でインデクスが B の要素を削除します。 Return the value of A at
     index B.

`getslice(a, b, c)'

`__getslice__ a, b, c'
     A でインデクスが B から C`-1' のスライス要素を 返します。

`indexOf(a, b)'
     A で最初に B が出現する場所のインデクスを返します。

`repeat(a, b)'

`__repeat__ a, b'
     配列 A と整数 B について A `*' B を返します。

`sequenceIncludes(...)'
     _This is deprecated in Python 2.0.  `contains()'
     を使ってください。_ `contains()' の別名です。

`setitem(a, b, c)'

`__setitem__ a, b, c'
     A でインデクスが B の要素の値を C に設定します。

`setslice(a, b, c, v)'

`__setslice__ a, b, c, v'
     A でインデクスが B から C`-1' のスライス要素の 値を配列 V
     に設定します。

`operator' モジュールでは、オブジェクトの型を調べるための
述語演算子も定義しています。_Note:_ これらの関数が返す結果について
誤って理解しないよう注意してください; インスタンスオブジェクトに
対して常に信頼できる値を返すのは `isCallable()'
だけです。例えば以下のようになります:

     >>> class C:
     ...     pass
     ...
     >>> import operator
     >>> o = C()
     >>> operator.isMappingType(o)
     True

`isCallable(o)'
     _This is deprecated in Python 2.0.  `callable()'
     を使ってください。_ オブジェクト O
     を関数のように呼び出すことができる場合真を 返し、それ以外の場合
     false を返します。関数、バインドおよび非バインド
     メソッド、クラスオブジェクト、および `__call__()' メソッド
     をサポートするインスタンスオブジェクトは真を返します。

`isMappingType(o)'
     オブジェクト O がマップ型インタフェースをサポートする場合に
     真を返します。辞書および全てのインスタンスオブジェクトに対しては、
     この値は真になります。_インタフェース自体が誤った定義に
     なっているため、あるインスタンスが完全なマップ型プロトコルを備えて
     いるかを調べる信頼性のある方法は存在しません。このため、この関数
     によるテストはさほど便利ではありません。_

`isNumberType(o)'
     オブジェクト O が数値を表現している場合に真を返します。 C
     で実装された全ての数値型、およびそれらのインスタンスオブジェクト
     全て対して、この値は真になります。_インタフェース自体が
     誤った定義になっているため、あるインスタンスが完全な数値型の
     インタフェースをサポートしているかを調べる信頼性のある方法は存在
     しません。このため、この関数によるテストはさほど便利ではありません。_

`isSequenceType(o)'
     O が配列プロトコルをサポートする場合に真を返します。
     配列メソッドを C で定義している全てのオブジェクトに対して、この値
     は真になります。 _インタフェース自体が
     誤った定義になっているため、あるインスタンスが完全な配列型の
     インタフェースをサポートしているかを調べる信頼性のある方法は存在
     しません。このため、この関数によるテストはさほど便利ではありません。_

例: `0' から `256' までの序数を文字に対応付ける 辞書を構築します。

     >>> import operator
     >>> d = {}
     >>> keys = range(256)
     >>> vals = map(chr, keys)
     >>> map(operator.setitem, [d]*len(keys), keys, vals)

* Menu:

* 演算子から関数への対応表::


File: python-lib-jp.info,  Node: 演算子から関数への対応表,  Prev: operator,  Up: operator

演算子から関数への対応表
------------------------

下のテーブルでは、個々の抽象的な操作が、どのように Python 構文上の
各演算子や `operator' モジュールの関数に対応しているか を示しています。

操作                     構文                     関数
------                   -----                    -----
加算                     `A + B'                  `add(A, B)'
結合                     `SEQ1 + SEQ2'            `concat(SEQ1, SEQ2)'
包含テスト               `O in SEQ'               `contains(SEQ, O)'
除算                     `A / B'                  `__future__.division'
                                                  が無効な場合の `div(A,
                                                  B) #'
除算                     `A / B'                  `__future__.division'
                                                  が有効な場合の
                                                  `truediv(A, B) #'
除算                     `A // B'                 `floordiv(A, B)'
論理積                   `A & B'                  `and_(A, B)'
排他的論理和             `A ^ B'                  `xor(A, B)'
ビット反転               `~{} A'                  `invert(A)'
論理和                   `A | B'                  `or_(A, B)'
べき乗                   `A ** B'                 `pow(A, B)'
インデクス指定の代入     `O[K] = V'               `setitem(O, K, V)'
インデクス指定の削除     `del O[K]'               `delitem(O, K)'
インデクス指定           `O[K]'                   `getitem(O, K)'
左シフト                 `A <`<' B'               `lshift(A, B)'
剰余                     `A % B'                  `mod(A, B)'
乗算                     `A * B'                  `mul(A, B)'
(算術)否                 `- A'                    `neg(A)'
(論理)否                 `not A'                  `not_(A)'
右シフト                 `A >`>' B'               `rshift(A, B)'
配列の反復               `SEQ * I'                `repeat(SEQ, I)'
スライス指定の代入       `SEQ[I:J]' = VALUES      `setslice(SEQ, I, J,
                                                  VALUES)'
スライス指定の削除       `del SEQ[I:J]'           `delslice(SEQ, I, J)'
スライス指定             `SEQ[I:J]'               `getslice(SEQ, I, J)'
文字列書式化             `S % O'                  `mod(S, O)'
減算                     `A - B'                  `sub(A, B)'
真値テスト               `O'                      `truth(O)'
順序付け                 `A < B'                  `lt(A, B)'
順序付け                 `A <= B'                 `le(A, B)'
等価性                   `A == B'                 `eq(A, B)'
不等性                   `A != B'                 `ne(A, B)'
順序付け                 `A >= B'                 `ge(A, B)'
順序付け                 `A > B'                  `gt(A, B)'


File: python-lib-jp.info,  Node: inspect,  Next: traceback,  Prev: operator,  Up: Python ランタイム サービス

使用中オブジェクトの情報を取得する
==================================

使用中のオブジェクトから、情報とソースコードを取得する。

_Added in Python version 2.1_

`inspect'は、モジュール・クラス・メソッド・関数・トレースバック・
フレームオブジェクト・コードオブジェクトなどのオブジェクトから情報を取得
する関数を定義しており、クラスの内容を調べる、メソッドのソースコードを取
得する、関数の引数リストを取得して整形する、トレースバックから必要な情報
だけを取得して表示する、などの処理を行う場合に利用します。

このモジュールの機能は、型チェック・ソースコードの取得・クラス／関数から
情報を取得・インタープリタのスタック情報の調査、の4種類に分類する事がで
きます。

* Menu:

* 型とメンバ::
* ソース参照::
* クラスと関数::
* インタープリタ スタック::


File: python-lib-jp.info,  Node: 型とメンバ,  Next: ソース参照,  Prev: inspect,  Up: inspect

型とメンバ
----------

`getmembers()'は、クラスやモジュールなどのオブジェクトからメンバを取得します。
名前が"is"で始まる 11
個の関数は、`getmembers()'の2番目の引数として利用する事ができますし、以下のような特殊属性を参照できるかどうか調べる時にも使えます。

Type               Attribute          Description        Notes
------             ------             ------             ------
module             __doc__            ドキュメント文字列 
                   __file__           ファイル名(組み込みモジュールには存在しない
class              __doc__            ドキュメント文字列 
                   __module__         クラスを定義しているモジュールの名前
method             __doc__            ドキュメント文字列 
                   __name__           メソッドが定義された時の名前
                   im_class           メソッドを呼び出すために必要なクラスオブジェクト(1)
                   im_func            メソッドを実装している関数オブジェクト
                   im_self            メソッドに結合しているインスタンス、または`None'
function           __doc__            ドキュメント文字列 
                   __name__           関数が定義された時の名前
                   func_code          関数をコンパイルしたバイトコードを格納するコード
                                      オブジェクト       
                   func_defaults      引数のデフォルト値のタプル
                   func_doc           (__doc__と同じ)    
                   func_globals       関数を定義した時のグローバル名前空間
                   func_name          (__name__と同じ)   
traceback          tb_frame           このレベルのフレームオブジェクト
                   tb_lasti           最後に実行しようとしたバイトコード中のインストラク
                                      ションを示すインデックス。
                   tb_lineno          現在のPythonソースコードの行番号
                   tb_next            このオブジェクトの内側(このレベルから呼び出された)
                                      のトレースバックオブジェクト
frame              f_back             外側               
                                      (このフレームを呼び出した)のフレームオブジ
                                      ェクト             
                   f_builtins         このフレームで参照している組み込み名前空間
                   f_code             このフレームで実行しているコードオブジェクト
                   f_exc_traceback    このフレームで例外が発生した場合にはトレー
                                      スバックオブジェクト。それ以外なら`None'
                   f_exc_type         このフレームで例外が発生した場合には例外型。それ
                                      以外なら`None'     
                   f_exc_value        このフレームで例外が発生した場合には例外の値。
                                      それ以外なら`None' 
                   f_globals          このフレームで参照しているグローバル名前空間
                   f_lasti            最後に実行しようとしたバイトコードのインデックス。
                   f_lineno           現在のPythonソースコードの行番号
                   f_locals           このフレームで参照しているローカル名前空間
                   f_restricted       制限実行モードなら1、それ以外なら0
                   f_trace            このフレームのトレース関数、または`None'
code               co_argcount        引数の数(*、**引数は含まない)
                   co_code            コンパイルされたバイトコードそのままの文字列
                   co_consts          バイトコード中で使用している定数のタプル
                   co_filename        コードオブジェクトを生成したファイルのファイル名
                   co_firstlineno     Pythonソースコードの先頭行
                   co_flags           以下の値の組み合わせ:
                                      1=optimized `|'    
                                      2=newlocals  `|'   
                                      4=*arg `|'         
                                      8=**arg            
                   co_lnotab          文字列にエンコードした、行番号->バイトコード
                                      インデックスへの変換表
                   co_name            コードオブジェクトが定義されたときの名前
                   co_names           ローカル変数名のタプル
                   co_nlocals         ローカル変数の数   
                   co_stacksize       必要な仮想機械のスタックスペース
                   co_varnames        引数名とローカル変数名のタプル
builtin            __doc__            ドキュメント文字列 
                   __name__           関数、メソッドの元々の名前
                   __self__           メソッドが結合しているインスタンス、または`None'

Note:
`(1)'
     _Changed in Python version 2.2_

`getmembers(object[, predicate])'
     オブジェクトの全メンバを、(名前,
     値)の組み合わせのリストで返します。リ
     ストはメンバ名でソートされています。PREDICATEが指定されている場
     合、predicateの戻り値が真となる値のみを返します。

`getmoduleinfo(path)'
     PATHで指定したファイルがモジュールであればそのモジュールがPython
     でどのように解釈されるかを示す`(NAME, SUFFIX, MODE,
     MTYPE)'のタプルを返し、モジュールでなければ
     `None'を返します。NAMEはパッケージ名を含まないモジュール
     名、SUFFIXはファイル名からモジュール名を除いた残りの部分(ドット
     による拡張子とは限らない)、MODEは`open()'で指定されるフ
     ァイルモード(`'r''または`'rb'')、MTYPEは
     `imp'で定義している整定数のいずれかが指定されます。モジュール
     タイプに付いては`imp'を参照してください。

`getmodulename(path)'
     PATHで指定したファイルの、パッケージ名を含まないモジュール名を返
     します。この処理は、インタープリタがモジュールを検索する時と同じアルゴ
     リズムで行われます。ファイルがこのアルゴリズムで見つからない場合には
     `None'が返ります。

`ismodule(object)'
     オブジェクトがモジュールの場合は真を返します。

`isclass(object)'
     オブジェクトがクラスの場合は真を返します。

`ismethod(object)'
     オブジェクトがメソッドの場合は真を返します。

`isfunction(object)'
     オブジェクトがPythonの関数、または無名(lambda)関数の場合は真を返します。

`istraceback(object)'
     オブジェクトがトレースバックの場合は真を返します。

`isframe(object)'
     オブジェクトがフレームの場合は真を返します。

`iscode(object)'
     オブジェクトがコードの場合は真を返します。

`isbuiltin(object)'
     オブジェクトが組み込み関数の場合は真を返します。

`isroutine(object)'
     オブジェクトがユーザ定義か組み込みの関数・メソッドの場合は真を返します。

`ismethoddescriptor(object)'
     オブジェクトがメソッドデスクリプタの場合に真を返しますが、
     ismethod()、isclass() または isfunction()
     が真の場合には真を返しません。

     この機能は Python 2.2 から新たに追加されたもので、例えば
     int.__add__ は真 になります。 このテストをパスするオブジェクトは
     __get__ 属性を持ちますが __set__
     属性を持ちません。しかしそれ以上に属性のセットには様々なものがあります。
     __name__ は通常見分けることが可能ですし、__doc__ も時には可能です。

     デスクリプタを使って実装されたメソッドで、上記のいずれかのテストもパスして
     いるものは、 ismethoddescriptor() では偽を返します。これは単に
     他のテストの方がもっと確実だからです - 例えば、ismethod() をパス
     したオブジェクトは im_func 属性 (など) を持っていると期待できます。

`isdatadescriptor(object)'
     オブジェクトがデータデスクリプタの場合に真を返します。

     データデスクリプタは __get__ および __set__ 属性の両方を持ちます。
     データデスクリプタの例は (Python 上で定義された) プロパティや (C
     で定義された) getset やメンバです。通常、データデスクリプタは
     __name__ や __doc__ 属性を持ちます (プロパティ、 getset
     、メンバは両方の属性を持っています)
     が、保証されているわけではありません。 _Added in Python version
     2.3_


File: python-lib-jp.info,  Node: ソース参照,  Next: クラスと関数,  Prev: 型とメンバ,  Up: inspect

ソース参照
----------

`getdoc(object)'
     オブジェクトのドキュメンテーション文字列を取得します。タブはスペースに
     展開されます。コードブロックに合わせてインデントされているdocstringを
     整形するため、２行目以降では行頭の空白は削除されます。

`getcomments(object)'
     オブジェクトがクラス・関数・メソッドの何れかの場合は、オブジェクトの
     ソースコードの直後にあるコメント行（複数行）を、単一の文字列として返し
     ます。オブジェクトがモジュールの場合、ソースファイルの先頭にあるコメン
     トを返します。

`getfile(object)'
     オブジェクトを定義している（テキストまたはバイナリの）ファイルの名前を
     返します。オブジェクトが組み込みモジュール・クラス・関数の場合は
     `TypeError'例外が発生します。

`getmodule(object)'
     オブジェクトを定義しているモジュールを推測します。

`getsourcefile(object)'
     オブジェクトを定義しているPythonソースファイルの名前を返します。オブジ
     ェクトが組み込みのモジュール、クラス、関数の場合には、
     `TypeError'例外が発生します。

`getsourcelines(object)'
     オブジェクトのソース行のリストと開始行番号を返します。引数にはモジュー
     ル・クラス・メソッド・関数・トレースバック・フレーム・コードオブジェク
     トを指定する事ができます。戻り値は指定したオブジェクトに対応するソース
     コードのソース行リストと元のソースファイル上での開始行となります。ソー
     スコードを取得できない場合は`IOError'が発生します。

`getsource(object)'
     オブジェクトのソースコードを返します。引数にはモジュール・クラス・メソ
     ッド・関数・トレースバック・フレーム・コードオブジェクトを指定する事が
     できます。ソースコードは単一の文字列で返します。ソースコードを取得でき
     ない場合は`IOError'が発生します。


File: python-lib-jp.info,  Node: クラスと関数,  Next: インタープリタ スタック,  Prev: ソース参照,  Up: inspect

クラスと関数
------------

`getclasstree(classes[, unique])'
     リストで指定したクラスの継承関係から、ネストしたリストを作成します。ネ
     ストしたリストには、直前の要素から派生したクラスが格納されます。各要素
     は長さ2のタプルで、クラスと基底クラスのタプルを格納しています。
     UNIQUE が真の場合、各クラスは戻り値のリスト内に一つだけしか格納
     されません。真でなければ、多重継承を利用したクラスとその派生クラスは複
     数回格納される場合があります。

`getargspec(func)'
     関数の引数名とデフォルト値を取得します。戻り値は長さ4のタプルで、次の
     値を返します:`(ARGS, VARARGS, VARKW,
     DEFAULTS)'。ARGSは引数名のリストです（ネストしたリストが格
     納される場合があります）。VARARGSとVARKWは`*'引数と
     `**'引数の名前で、引数がなければ`None'となります。
     DEFAULTSは引数のデフォルト値のタプルです。引数がない場合には None
     です。このタプルにN個
     の要素があれば、各要素はARGSの後ろからN個分の引数のデフォ
     ルト値となります。

`getargvalues(frame)'
     指定したフレームに渡された引数の情報を取得します。戻り値は長さ4のタプ
     ルで、次の値を返します:`(ARGS, VARARGS, VARKW,
     LOCALS)'。ARGSは引数名のリストです（ネストしたリストが格納
     される場合があります）。VARARGSとVARKWは`*'引数と
     `**'引数の名前で、引数がなければ`None'となります。
     LOCALSは指定したフレームのローカル変数の辞書です。

`formatargspec(args[, varargs, varkw, defaults, argformat, varargsformat, varkwformat, defaultformat])'
     `getargspec()'で取得した4つの値を読みやすく整形します。残りの
     4つの引数はオプションで、名前と値を文字列に変換する整形関数を指定する
     事ができます。

`formatargvalues(args[, varargs, varkw, locals, argformat, varargsformat, varkwformat, valueformat])'
     `getargvalues()'で取得した4つの値を読みやすく整形します。残りの
     4つの引数はオプションで、名前と値を文字列に変換する整形関数を指定する
     事ができます。

`getmro(cls)'
     CLSクラスの基底クラス（CLS自身も含む）を、メソッドの優先順
     位順に並べたタプルを返します。結果のリスト内で各クラスは一度だけ格納さ
     れます。メソッドの優先順位はクラスの型によって異なります。非常に特殊な
     ユーザ定義のメタクラスを使用していない限り、CLSが戻り値の先頭要
     素となります。


File: python-lib-jp.info,  Node: インタープリタ スタック,  Prev: クラスと関数,  Up: inspect

インタープリタ スタック
-----------------------

以下の関数には、戻り値として"フレームレコード"を返す関数があります。"
フレームレコード"は長さ6のタプルで、以下の値を格納しています:フレームオ
ブジェクト・ファイル名・実行中の行番号・関数名・コンテキストのソース行の
リスト・ソース行リストの実行中行のインデックス。

_Notice:_ [warning]

フレームレコードの最初の要素などのフレームオブジェクトへの参照を保存する
と、循環参照になってしまう場合があります。循環参照ができると、Pythonの循
環参照検出機能を有効にしていたとしても関連するオブジェクトが参照している
すべてのオブジェクトが解放されにくくなり、明示的に参照を削除しないとメモ
リ消費量が増大する恐れがあります。

参照の削除をPythonの循環参照検出機能にまかせる事もできますが、
`finally'節で循環参照を解除すれば確実にフレーム（とそのローカル
変数）は削除されます。また、循環参照検出機能はPythonのコンパイルオプショ
ンや``gc'. disable()'で無効とされている場合があります
ので注意が必要です。例：

     def handle_stackframe_without_leak():
         frame = inspect.currentframe()
         try:
             # do something with the frame
         finally:
             del frame

以下の関数でオプション引数CONTEXTには、戻り値のソース行リストに何
行分のソースを含めるかを指定します。ソース行リストには、実行中の行を中心
として指定された行数分のリストを返します。

`getframeinfo(frame[, context])'
     フレーム又はトレースバックオブジェクトの情報を取得します。フレームレ
     コードの先頭要素を除いた、長さ5のタプルを返します。

`getouterframes(frame[, context])'
     指定したフレームと、その外側の全フレームのフレームレコードを返します。
     外側のフレームとはFRAMEが生成されるまでのすべての関数呼び出しを
     示します。戻り値のリストの先頭はFRAMEのフレームレコードで、末尾
     の要素はFRAMEのスタックにあるもっとも外側のフレームのフレームレ
     コードとなります。

`getinnerframes(traceback[, context])'
     指定したフレームと、その内側の全フレームのフレームレコードを返します。
     内のフレームとはFRAMEから続く一連の関数呼び出しを示します。戻り
     値のリストの先頭はTRACEBACKのフレームレコードで、末尾の要素は例
     外が発生した位置を示します。

`currentframe()'
     呼び出し元のフレームオブジェクトを返します。

`stack([context])'
     呼び出し元スタックのフレームレコードのリストを返します。最初の要素は呼
     び出し元のフレームレコードで、末尾の要素はスタックにあるもっとも外側の
     フレームのフレームレコードとなります。

`trace([context])'
     実行中のフレームと処理中の例外が発生したフレームの間のフレームレコード
     のリストを返します。最初の要素は呼び出し元のフレームレコードで、末尾の
     要素は例外が発生した位置を示します。


File: python-lib-jp.info,  Node: traceback,  Next: linecache,  Prev: inspect,  Up: Python ランタイム サービス

スタックトレースの表示や取り出し
================================

スタックトレースの表示や取り出し。

このモジュールはPythonプログラムのスタックトレースを抽出し、書式を整え、表示するための標準インターフェースを提供します。モジュールがスタックトレースを表示するとき、Pythonインタープリタの動作を正確に模倣します。インタープリタの"ラッパー"の場合のように、プログラムの制御の元でスタックとレースを表示したいと思ったときに役に立ちます。

モジュールはtracebackオブジェクトを使います --
これは変数`sys.exc_traceback'(非推奨)と`sys.last_traceback'に保存され、`sys.exc_info()'から三番目の項目として返されるオブジェクト型です。

モジュールは次の関数を定義します:

`print_tb(traceback[, limit[, file]])'
     TRACEBACKからLIMITまでスタックトレース項目を出力します。LIMITが省略されるか`None'の場合は、すべての項目が表示されます。FILEが省略されるか`None'の場合は、`sys.stderr'へ出力されます。それ以外の場合は、出力を受けるためのオープンしたファイルまたはファイルに類似したオブジェクトであるべきです。

`print_exception(type, value, traceback[, limit[, file]])'
     例外情報とTRACEBACKからLIMITまでスタックトレース項目をFILEへ出力します。これは次のようにすることで`print_tb()'とは異なります:
     (1) TRACEBACKが`None'でない場合は、ヘッダ`Traceback (most recent
     call last):'を出力します。 (2)
     スタックトレースの後に例外TYPEとVALUEを出力します。 (3)
     TYPEが`SyntaxError'であり、VALUEが適切な形式の場合は、エラーのおおよその位置を示すカレットを付けて構文エラーが起きた行を出力します。

`print_exc([limit[, file]])'
     これは`print_exception(sys.exc_type, sys.exc_value,
     sys.exc_traceback, LIMIT,
     FILE)'のための省略表現です。(非推奨の変数を使う代わりにスレッドセーフな方法で同じ情報を引き出すために、実際には`sys.exc_info()'を使います。)

`print_last([limit[, file]])'
     これは`print_exception(sys.last_type, sys.last_value,
     sys.last_traceback, LIMIT, FILE)'の省略表現です。

`print_stack([f[, limit[, file]]])'
     この関数は呼び出された時点からのスタックトレースを出力します。オプションのF引数は代わりの最初のスタックフレームを指定するために使えます。`print_exception()'に付いて言えば、オプションのLIMITとFILE引数は同じ意味を持ちます。

`extract_tb(traceback[, limit])'
     トレースバックオブジェクトTRACEBACKからLIMITまで取り出された"前処理済み"スタックトレース項目のリストを返します。スタックトレースの代わりの書式設定を行うために役に立ちます。LIMITが省略されるか`None'の場合は、すべての項目が取り出されます。"前処理済み"スタックトレース項目とは四つの部分からなる(FILENAME,
     LINE NUMBER, FUNCTION NAME,
     TEXT)で、スタックトレースに対して通常出力される情報を表しています。TEXTは前と後ろに付いている空白を取り除いた文字列です。ソースが使えない場合は`None'です。

`extract_stack([f[, limit]])'
     現在のスタックフレームから生のトレースバックを取り出します。戻り値は`extract_tb()'と同じ形式です。`print_stack()'について言えば、オプションのFとLIMIT引数は同じ意味を持ちます。

`format_list(list)'
     `extract_tb()'または`extract_stack()'が返すタプルのリストが与えられると、出力の準備を整えた文字列のリストを返します。結果として生じるリストの中の各文字列は、引数リストの中の同じインデックスの要素に対応します。各文字列は末尾に改行が付いています。その上、ソーステキスト行が`None'でないそれらの要素に対しては、文字列は内部に改行を含んでいるかもしれません。

`format_exception_only(type, value)'
     トレースバックの例外部分の書式を設定します。引数は`sys.last_type'と`sys.last_value'のような例外の型と値です。戻り値はそれぞれが改行で終わっている文字列のリストです。通常、リストは一つの文字列を含んでいます。しかし、`SyntaxError'例外に対しては、(出力されるときに)構文エラーが起きた場所についての詳細な情報を示す行をいくつか含んでいます。どの例外が起きたのかを示すメッセージは、常にリストの最後の文字列です。

`format_exception(type, value, tb[, limit])'
     スタックトレースと例外情報の書式を設定します。引数は`print_exception()'の対応する引数と同じ意味を持ちます。戻り値は文字列のリストで、それぞれの文字列は改行で終わり、そのいくつかは内部に改行を含みます。これらの行が連結されて出力される場合は、厳密に`print_exception()'と同じテキストが出力されます。

`format_tb(tb[, limit])'
     `format_list(extract_tb(TB, LIMIT))'の省略表現。

`format_stack([f[, limit]])'
     `format_list(extract_stack(F, LIMIT))'の省略表現。

`tb_lineno(tb)'
     この関数はトレースバックオブジェクトに設定された現在の行番号をかえします。この関数は必要でした。なぜなら、`-O'フラグがPythonへ渡されたとき、Pythonの2.3より前のバージョンでは`TB.tb_lineno'が正しく更新されなかったからです。この関数は2.3以降のバージョンでは役に立ちません。

* Menu:

* トレースバックの例::


File: python-lib-jp.info,  Node: トレースバックの例,  Prev: traceback,  Up: traceback

トレースバックの例
------------------

この簡単な例では基本的なread-eval-printループを実装います。それは標準的なPythonの対話インタープリタループに似ていますが、Pythonのものより便利ではありません。インタープリタループのより完全な実装については、`code'モジュールを参照してください。

     import sys, traceback
     
     def run_user_code(envdir):
         source = raw_input(">>> ")
         try:
             exec source in envdir
         except:
             print "Exception in user code:"
             print '-'*60
             traceback.print_exc(file=sys.stdout)
             print '-'*60
     
     envdir = {}
     while 1:
         run_user_code(envdir)


File: python-lib-jp.info,  Node: linecache,  Next: pickle,  Prev: traceback,  Up: Python ランタイム サービス

テキストラインにランダムアクセスする
====================================

このモジュールによりテキストファイルの各行にランダムアクセスできます。

`linecache' モジュールは、キャッシュ
(一つのファイルから何行も読んでおくのが一般的です)を使って、
内部で最適化を図りつつ、任意のファイルの任意の行を取得するのを可能にします。

このモジュールは `traceback' モジュールで、インクルードしたソースを
フォーマットされたトレースバックで復元するのに使われています。

`linecache' モジュールでは次の関数が定義されています:

`getline(filename, lineno)'
     FILENAME という名前のファイルから LINENO 行目を取得します。
     この関数は決して例外を投げません -- エラーの際には `'''
     を返します。 (行末の改行文字は、見つかった行に含まれます。)

     FILENAME という名前のファイルが見つからなかった場合、 モジュールの
     、つまり、 `sys.path' で そのファイルを探します。

`clearcache()'
     キャッシュをクリアします。 それまでに `getline()'
     を使って読み込んだファイルの行が必要でなくなったら、
     この関数を使ってください。

`checkcache()'
     キャッシュが有効かチェックします。
     キャッシュしたファイルにディスク上で変更があったかもしれなくて、更新が必要な
     ときにこの関数を使ってください。

サンプル:

     >>> import linecache
     >>> linecache.getline('/etc/passwd', 4)
     'sys:x:3:3:sys:/dev:/bin/sh\n'


File: python-lib-jp.info,  Node: pickle,  Next: cPickle,  Prev: linecache,  Up: Python ランタイム サービス

Python オブジェクトの整列化
===========================

Python オブジェクトからバイトストリームへの変換、およびその逆。

`pickle' モジュールでは、Python オブジェクトデータ構造を 直列化
(serialize) したり非直列化 (de-serialize) するための
基礎的ですが強力なアルゴリズムを実装しています。 "Pickle 化 (Pickling)"
は Python のオブジェクト階層をバイト
ストリームに変換する過程を指します。"非 Pickle 化 (unpickling)"
はその逆の操作で、バイトストリームをオブジェクト階層に戻すように
変換します。Pickle 化 (及び非 Pickle 化) は、別名 "直列化
(serialization)" や "整列化 (marshalling)" (1) 、"平坦化 (flattening)"
として知られていますが、 ここでは混乱を避けるため、用語として "Pickle
化" および "非 Pickle 化" を使います。

このドキュメントでは `pickle' モジュールおよび `cPickle'
モジュールの両方について記述します。

* Menu:

* 他の Python モジュールとの関係::
* データストリームの形式::
* 使用法::
* 何を pickle 化したり unpickle 化できるのか?::
* pickle 化プロトコル::
* Unpickler をサブクラス化する::
* 例 3::

---------- Footnotes ----------

(1) `marshal' モジュールと間違えないように注意 してください


File: python-lib-jp.info,  Node: 他の Python モジュールとの関係,  Next: データストリームの形式,  Prev: pickle,  Up: pickle

他の Python モジュールとの関係
------------------------------

`pickle' モジュールには `cPickle' と呼ばれる
最適化のなされた親類モジュールがあります。名前が示すように、 `cPickle'
は C で書かれており、このため `pickle' より 1000
倍くらいまで高速になる可能性があります。しかしながら `cPickle' では
`Pickler()' および `Unpickler()'
クラスのサブクラス化をサポートしていません。 これは `cPickle'
では、これらは関数であってクラスでは
ないからです。ほとんどのアプリケーションではこの機能は
不要であり、`cPickle' の持つ高いパフォーマンスの
恩恵を受けることができます。その他の点では、二つのモジュールに
おけるインタフェースはほとんど同じです; このマニュアルでは
共通のインタフェースを記述しており、必要に応じてモジュール間
の相違について指摘します。以下の議論では、`pickle' と `cPickle'
の総称として "pickle" という用語を使う ことにします。

これら二つのモジュールが生成するデータストリームは相互交換
できることが保証されています。

Python には `marshal' と呼ばれるより原始的な直列化モジュール
がありますが、一般的に Python オブジェクトを直列化する方法としては
`pickle' を選ぶべきです。`marshal' は基本的に `.pyc'
ファイルをサポートするために存在しています。

`pickle' モジュールはいくつかの点で `marshal' と明確に異なります:

   * `pickle' モジュールでは、同じオブジェクトが再度直列化
     されることのないよう、すでに直列化されたオブジェクトについて追跡
     情報を保持します。`marshal' はこれを行いません。

     この機能は再帰的オブジェクトと共有オブジェクトの両方に重要な
     関わりをもっています。再帰的オブジェクトとは自分自身に対する
     参照を持っているオブジェクトです。再帰的オブジェクトは marshal
     で扱うことができず、実際、再帰的オブジェクトを marshal 化しようと
     すると Python インタプリタをクラッシュさせてしまいます。
     共有オブジェクトは、直列化しようとするオブジェクト階層の異なる
     複数の場所で同じオブジェクトに対する参照が存在する場合に生じます。
     共有オブジェクトを共有のままにしておくことは、変更可能なオブジェクト
     の場合には非常に重要です。

   * `marshal' はユーザ定義クラスやそのインスタンスを
     直列化するために使うことができません。`pickle' は
     クラスインスタンスを透過的に保存したり復元したりすることができますが、
     クラス定義をインポートすることが可能で、かつオブジェクトが保存
     された際と同じモジュールで定義されていなければなりません。

   * `marshal' の直列化フォーマットは Python の異なる
     バージョンで可搬性があることを保証していません。`marshal'
     の本来の仕事は `.pyc' ファイルのサポートなので、Python
     を実装する人々には、必要に応じて直列化フォーマットを以前の
     バージョンと互換性のないものに変更する権限が残されています。
     `pickle' 直列化フォーマットには、全ての Python リリース
     間で以前のバージョンとの互換性が保証されています。


_Notice:_ [警告] `pickle' モジュールは誤りを含む、あるいは悪意を持って
構築されたデータに対して安全にはされていません。信用できない、
あるいは認証されていないデータ源から受信したデータを逆 pickle 化
しないでください。

直列化は永続化 (persisitence) よりも原始的な概念です; `pickle'
はファイルオブジェクトを読み書きしますが、永続化
されたオブジェクトの名前付け問題や、(より複雑な) オブジェクトに
対する競合アクセスの問題を扱いません。`pickle' モジュール
は複雑なオブジェクトをバイトストリームに変換することができ、
バイトストリームを変換前と同じ内部構造をオブジェクトに変換する
ことができます。このバイトストリームの最も明白な用途は
ファイルへの書き込みですが、その他にもネットワークを介して送信
したり、データベースに記録したりすることができます。 モジュール
`shelve' はオブジェクトを DBM 形式の データベースファイル上で pickle
化したり unpickle 化したりする
ための単純なインタフェースを提供しています。


File: python-lib-jp.info,  Node: データストリームの形式,  Next: 使用法,  Prev: 他の Python モジュールとの関係,  Up: pickle

データストリームの形式
----------------------

`pickle' が使うデータ形式は Python 特有です。そうする ことで、XDR
のような 外部の標準が持つ制限 (例えば XDR
ではポインタの共有を表現できません)
を課せられることがないという利点があります; しかしこれは Python
で書かれていないプログラムが pickle 化された Python オブジェクトを
再構築できない可能性があることを意味します。

標準では、`pickle' データ形式では印字可能な ASCII 表現を
使います。これはバイナリ表現よりも少しかさばるデータになります。
印字可能な ASCII の利用 (とその他の `pickle' 表現形式が 持つ特徴)
の大きな利点は、デバッグやリカバリを目的とした場合に、 pickle
化されたファイルを標準的なテキストエディタで読めるという ことです。

現在、pickle化に使われるプロトコルは、以下の 3 種類です。

   * バージョン 0 のプロトコルは、最初の ASCII
     プロトコルで、以前のバージョンのPython と後方互換です。

   * バージョン 1
     のプロトコルは、古いバイナリ形式で、以前のバージョンの Python
     と後方互換です。

   * バージョン 2 のプロトコルは、Python 2.3
     で導入されました。新しいスタイルのクラスを、より効率よく piclke
     化します。


詳細は PEP 307 を参照してください。

PROTOCOL を指定しない場合、プロトコル 0 が使われます。PROTOCOL に負値か
`HIGHEST_PROTOCOL'
を指定すると、有効なプロトコルの内、もっとも高いバージョンのものが使われます。

_Changed in Python version 2.3_

`Pickler' コンストラクタや `dump()' および `dumps()' の引数 BIN
の値を真に設定することで、少しだけ効率の高いバイナリ
形式を選ぶこともできます。 PROTOCOL version >= 1
であるとき、バイナリ形式を使用するからです。

