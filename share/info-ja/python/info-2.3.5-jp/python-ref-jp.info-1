This is python-ref-jp.info, produced by makeinfo version 4.5 from
python-ref-jp.texi.

12 October 2005


File: python-ref-jp.info,  Node: Top,  Next: 序,  Prev: (dir),  Up: (dir)

Python リファレンスマニュアル
*****************************

* Menu:

* 序::
* 導入::
* 字句解析::
* データモデル::
* 実行モデル::
* 式 expression::
* 単純文 simple statement::
* 複合文 compound statement::
* トップレベル要素::
* 歴史とライセンス::
* 日本語訳について::
* Module Index::
* Class-Exception-Object Index::
* Function-Method-Variable Index::
* Miscellaneous Index::


File: python-ref-jp.info,  Node: 序,  Next: 導入,  Prev: Top,  Up: Top

序
**

Copyright (C) 2001, 2002, 2003 Python Software Foundation.  All rights
reserved.

Copyright (C) 2000 BeOpen.com.  All rights reserved.

Copyright (C) 1995-2000 Corporation for National Research Initiatives.
All rights reserved.

Copyright (C) 1991-1995 Stichting Mathematisch Centrum.  All rights
reserved.

Translation Copyright (C) 2003 Python Document Japanese Translation
Project. All rights reserved.

ライセンスおよび許諾に関する完全な情報は、このドキュメントの末尾を
参照してください。

     Python
     はインタプリタ形式の、オブジェクト指向な高レベルプログラミング
     言語で、動的なセマンティクスを持っています。Python
     の高レベルな組み込み
     データ構造は、動的な型付け機能や動的な結合機能と組み合わせることで、
     迅速なアプリケーション開発や既存のソフトウェアコンポーネント間をつなぐ
     スクリプト言語、または糊 (glue) 言語として Python を魅力的な存在に
     しています。Python は単純で学びやすい文法なので、可読性が高まり、
     プログラムのメンテナンスにかかるコストを低減します。 Python
     は、プログラムのモジュール化や再利用を助けるモジュールとパッケージ
     をサポートします。Python インタプリタと多数の標準ライブラリは、
     ほとんどのプラットフォームでソースコード形式でもバイナリ形式でも無料で
     入手することができ、無料で配布することができます。

     このリファレンスマニュアルでは、Python 言語の文法と、"コアとなる
     セマンティクス"
     について記述します。このマニュアルはそっけない書き方
     かもしれませんが、的確かつ完璧な記述を目指しています。
     必須でない組み込みオブジェクト型や組み込み関数、組み込みモジュール
     に関するセマンティクスは、  で述べられています。 形式ばらない
     Python 言語入門には、  を参照してください。 C 言語あるいは C++
     プログラマ向けには、このマニュアルとは別に二つの
     マニュアルがあります:

     では、Python
     拡張モジュールを書くための高レベルな様式について述べています。
     また、 では、C/C++
     プログラマが利用できるインタフェースについて詳細に 記述しています。



File: python-ref-jp.info,  Node: 導入,  Next: 字句解析,  Prev: 序,  Up: Top

導入
****

このリファレンスマニュアルは、Python プログラミング言語自体に関する
記述です。チュートリアルとして書かれたものではありません。

私は本マニュアルをできるだけ正確に書こうとする一方で、文法や
字句解析以外の全てについて、形式化された仕様記述ではなく英語を
使うことにしました。そうすることで、このドキュメントが平均的な
読者にとってより読みやすくなっているはずですが、ややあいまいな
部分も残っていることでしょう。
従って、もし読者のあなたが火星から来ている人で、このドキュメントだけ
から Python を再度実装しようとしているのなら、色々と推測しなければ
ならないことがあり、実際にはおそらく全く別の言語を実装する羽目に
なるでしょう。 逆に、あなたが Python を利用しており、Python
言語のある特定の領域に
おいて、厳密な規則が何か疑問に思った場合、その答えはこのドキュメント
で確実に見つけられることでしょう。

もしより形式化された言語定義をお望みなら、あなたの時間を提供して
いただいてかまいません -- もしくは、クローン生成装置でも発明して
ください :-) 。

実装に関する詳細を言語リファレンスのドキュメントに載せすぎるのは
危険なことです -- 実装は変更されるかもしれず、同じ言語でも異なる
実装は異なった動作をするかもしれないからです。一方、広く使われている
Python 実装は現在のところ唯一 (今や第二の実装が存在しますが！) なので、
特定のクセについては、特に実装によって何らかの制限が加えられている
場合には、触れておく価値があります。従って、このテキスト全体にわたって
短い "実装に関する注釈 (imprementation notes)" がちりばめられて います。

Python 実装はいずれも、数々の組み込みモジュールと標準モジュールが
付属します。これらはここではドキュメント化されていませんが、

でドキュメント化されています。いくつかの組み込みモジュールについて
は、言語定義と重要なかかわりをもっているときについて触れています。

* Menu:

* 本マニュアルにおける表記法::


File: python-ref-jp.info,  Node: 本マニュアルにおける表記法,  Prev: 導入,  Up: 導入

本マニュアルにおける表記法
==========================

字句解析と構文に関する記述では、BNF 文法記法に手を加えたものを
使っています。この記法では、以下のような記述形式をとります:

     name:           lc_letter (lc_letter | "_")*
     lc_letter:      "a"..."z"

最初の行は、`name' が `lc_letter' の後ろに ゼロ個または それ以上の
`lc_letter' とアンダースコアが続いたものであることを 示しています。
そして、`lc_letter' は `a' から `z' までの
何らかの文字一字であることを示します (この規則は、このドキュメントに
記述されている字句規則と構文規則において定義されている名前 (name) で
一貫して使われています)。

各規則は name (規則によって定義されているものの名前) とコロン一つから
始まります。垂直線 (`|') は、複数の選択項目を分かち書きするときに
使います; この記号は、この記法において最も結合優先度の低い演算子です。
アスタリスク (`*') は、直前にくる要素のゼロ個以上の繰り返しを 表します;
同様に、プラス (`+') は一個以上の繰り返しで、角括弧 (`[ ]')
に囲われた字句は、字句がゼロ個か一個出現する
(別の言い方をすれば、囲いの中の字句はオプションである) ことを示し
ます。`*' および `+' 演算子の結合範囲は可能な限り狭く なっています;
字句のグループ化には丸括弧を使います。
リテラル文字列はクオートで囲われます。空白はトークンを分割している
ときのみ意味を持ちます。規則は通常、一行中に収められています;
多数の選択肢のある規則は、最初の行につづいて、垂直線の後ろに
各々別の行として記述されます。

(上の例のような) 字句定義では、他に二つの慣習が使われています:
三つのドットで区切られている二つのリテラル文字は、二つの文字の ASCII
文字コードにおける (包含的な) 範囲から文字を一字選ぶ
ことを示します。各カッコ中の字句 (`<...>') は、定義済みの
シンボルを記述する非形式的なやりかたです; 例えば、 `制御文字'
を書き表す必要があるときなどに使われることがあります。

字句と構文規則の定義の間で使われている表記はほとんど同じですが、
その意味には大きな違いがあります: 字句定義は入力ソース中の個々の
文字を取り扱いますが、構文定義は字句解析で生成された一連の
トークンを取り扱います。次節 ("字句解析") における BNF はすべて
字句定義のためのものです; それ以降の章では、構文定義のために
使っています。


File: python-ref-jp.info,  Node: 字句解析,  Next: データモデル,  Prev: 導入,  Up: Top

字句解析
********

Python で書かれたプログラムは _パーザ (parser)_ に読み込まれます。
パーザへの入力は、_字句解析器 (lexical analyzer)_ によって生成
された一連の _トークン (token)_ からなります。この章では、字句解析器
がファイルをトークン列に分解する方法について解説します。

Python は 7-bit の ASCII 文字セットをプログラムのテキストに 使います。
_Added in Python version 2.3_
以前のバージョンとの互換性のために、Python は 8-bit 文字が見つかっても
警告を出すだけにとどめます; こうした警告は、エンコーディングを明示
したり、バイナリデータの場合には文字ではなくエスケープシーケンス
を使うことで解決できます。

実行時の文字セットは、プログラムが接続されている I/O デバイスにもより
ますが、通常 ASCIIのサブセットです。

*将来のバージョンとの互換性に関する注意:* 8-bit
文字に対する文字セットを ISO Latin-1 (ラテン語系アルファベットを
用いるほとんどの西欧言語をカバーするASCII の上位セット) とみなし
たい気にもなるかもしれません。しかし、おそらく Unicode を編集できる
テキストエディタが将来一般的になるはずです。こうしたエディタでは
一般的に UTF-8 エンコードを使いますが、UTF-8 エンコードは ASCII
の上位セットではあるものの、文字序数 (ordinal) 128-255 の扱いが
非常に異なります。この問題に関してはまだ合意が得られていませんが、
Latin-1 と UTF-8 のどちらかとみなすのは、たとえ現在の実装が Latin-1
びいきのように思えたとしても賢明とはいえません。これはソースコード
文字セットと実行時の文字セットのどちらにも該当します。

* Menu:

* 行構造::
* その他のトークン::
* 識別子 identifier およびキーワード keyword::
* リテラル literal::
* 演算子 operator::
* デリミタ delimiter::


File: python-ref-jp.info,  Node: 行構造,  Next: その他のトークン,  Prev: 字句解析,  Up: 字句解析

行構造
======

Python プログラムは多数の _論理行 (logical lines)_ に分割されます。

* Menu:

* 論理行 logical line::
* 物理行 physical line::
* コメント::
* エンコード宣言 encoding declaration::
* 明示的な行継続::
* 非明示的な行継続::
* 空行::
* インデント::
* トークン間の空白::


File: python-ref-jp.info,  Node: 論理行 logical line,  Next: 物理行 physical line,  Prev: 行構造,  Up: 行構造

論理行 (logical line)
---------------------

論理行の終端は、トークン NEWLINE で表されます。構文上許されている場合
(複合文: compound statement 中の実行文: statement) を除いて、実行文は
論理行間にまたがることはできません。 論理行は一行またはそれ以上の
_物理行(physical line)_ からなり、
物理行の末尾には明示的または非明示的な _行連結(line joining)_
規則が続きます。


File: python-ref-jp.info,  Node: 物理行 physical line,  Next: コメント,  Prev: 論理行 logical line,  Up: 行構造

物理行 (physical line)
----------------------

物理行とは、利用しているプラットフォームで行終端として取り決めている
文字列で終端されたものです。UNIXでは、行終端は ASCII LF (行送り:
linefeed) 文字です。 Windows では、 ASCII 配列の CR LF (復帰: return
に続いて 行送り) です。Macintosh では、 ASCII CR (復帰) 文字です。


File: python-ref-jp.info,  Node: コメント,  Next: エンコード宣言 encoding declaration,  Prev: 物理行 physical line,  Up: 行構造

コメント
--------

コメントは文字列リテラル内に入っていないハッシュ文字 (`#') から
始まり、同じ物理行の末端で終わります。非明示的な行継続規則が適用されて
いない限り、コメントは論理行を終端させます。
コメントは構文上無視されます; コメントはトークンになりません。


File: python-ref-jp.info,  Node: エンコード宣言 encoding declaration,  Next: 明示的な行継続,  Prev: コメント,  Up: 行構造

エンコード宣言 (encoding declaration)
-------------------------------------

Python スクリプト中の最初の行か、二行目にあるコメントが正規表現
"coding[=:]\s*([\w-_.]+)" にマッチする場合、コメントは エンコード宣言
(encoding declaration) として処理されます;
表現に対する最初のマッチグループがソースコードファイルのエンコードを
指定します。エンコード宣言式として推奨する形式は、GNU Emacs が
認識できる形式

     # -*- coding: <encoding-name> -*-

または、Bram Moolenar による VIM が認識できる形式

     # vim:fileencoding=<encoding-name>

です。さらに、ファイルの先頭のバイト列が UTF-8 バイトオーダ記号
(`'\xef\xbb\xbf'') の場合、ファイルのエンコードは UTF-8
と宣言されているものとします (この機能は Microsoft の `notepad'
やその他のエディタでサポートされています)。

エンコードが宣言されている場合、Python はそのエンコード名を認識
できなければなりません。宣言されたエンコードは全ての字句解析、特に文字列の終端を検出する際や
Unicode リテラルの内容を翻訳する上で用いられます。
文字列リテラルは文法的な解析を行うために Unicode に変換され、
解釈が行われる前に元のエンコードに戻されます。エンコード宣言は
宣言全体が一行に収まっていなければなりません。


File: python-ref-jp.info,  Node: 明示的な行継続,  Next: 非明示的な行継続,  Prev: エンコード宣言 encoding declaration,  Up: 行構造

明示的な行継続
--------------

二つまたはそれ以上の物理行を論理行としてつなげるためには、
バックスラッシュ文字 (`\') を使って以下のようにします:
物理行が文字列リテラルやコメント中の文字でないバックスラッシュで
終わっている場合、後続する行とつなげて一つの論理行を構成し、
バックスラッシュおよびバックスラッシュの後ろにある行末文字を
削除します。例えば:
     if 1900 < year < 2100 and 1 <= month <= 12 \
        and 1 <= day <= 31 and 0 <= hour < 24 \
        and 0 <= minute < 60 and 0 <= second < 60:   # Looks like a valid date
             return 1

となります。

バックスラッシュで終わる行にはコメントを入れることはできません。
また、バックスラッシュを使ってコメントを継続することはできません。
バックスラッシュが文字列リテラル中にある場合を除き、バックスラッシュの
後ろにトークンを継続することはできません (すなわち、物理行内の文字列
リテラル以外のトークンをバックスラッシュを使って分断することは
できません)。上記以外の場所では、文字列リテラル外にあるバックスラッシュ
はどこにあっても不正となります。


File: python-ref-jp.info,  Node: 非明示的な行継続,  Next: 空行,  Prev: 明示的な行継続,  Up: 行構造

非明示的な行継続
----------------

丸括弧 (parentheses)、角括弧 (square bracket) 、および 波括弧 (curly
brace) 内の式は、バックスラッシュを使わずに
一行以上の物理行に分割することができます。 例えば:

     month_names = ['Januari', 'Februari', 'Maart',      # These are the
                    'April',   'Mei',      'Juni',       # Dutch names
                    'Juli',    'Augustus', 'September',  # for the months
                    'Oktober', 'November', 'December']   # of the year

非明示的に継続された行にはコメントを含めることができます。
継続行のインデントは重要ではありません。空の継続行を書くことが
できます。非明示的な継続行中には、NEWLINE トークンは存在しません。
非明示的な行の継続は、三重クオートされた文字列 (下記参照)
でも発生します; この場合には、コメントを含めることができません。


File: python-ref-jp.info,  Node: 空行,  Next: インデント,  Prev: 非明示的な行継続,  Up: 行構造

空行
----

スペース、タブ、フォームフィード、およびコメントのみを含む論理行は
無視されます (すなわち、NEWLINE トークンは生成されません)。
文を対話的に入力している際には、空行の扱いは行読み込み-評価-出力
(read-eval-print) ループの実装によって異なるかもしれません。
標準的な実装では、完全な空行でできた論理行 (すなわち、空白文字も
コメントも全く含まない空行) は、複数行からなる実行文の終端を示します。


File: python-ref-jp.info,  Node: インデント,  Next: トークン間の空白,  Prev: 空行,  Up: 行構造

インデント
----------

論理行の行頭にある、先頭の空白 (スペースおよびタブ) の連なりは、
その行のインデントレベルを計算するために使われます。インデントレベルは、
実行文のグループ化方法を決定するために用いられます。

まず、タブは (左から右の方向に) 1 つから 8 つのスペースで置き換えられ、
置き換え後の文字列の終わりの位置までの文字数が 8 の倍数になるように
調整されます (UNIXで使われている規則と同じになるよう意図されています)。
次に、空白文字でない最初の文字までのスペースの総数から、その行の
インデントを決定します。バックスラッシュを使ってインデントを複数の
物理行に分割することはできません; 最初のバックスラッシュまでの空白が
インデントを決定します。

*プラットフォーム間の互換性に関する注意:* 非 UNIX
プラットフォームにおけるテキストエディタの性質上、一つの
ソースファイル内でタブとインデントを混在させて使うのは賢明では
ありません。また、プラットフォームによっては、最大インデントレベルを
明示的に制限しているかもしれません。

フォームフィード文字が行の先頭にあっても構いません; フォームフィード
文字は上のインデントレベル計算時には無視されます。フォームフィード
文字が先頭の空白中の他の場所にある場合、その影響は未定義です
(例えば、スペースの数を 0 にリセットするかもしれません)。

連続する行における各々のインデントレベルは、 INDENT および DEDENT
トークンを生成するために使われます。
トークンの生成はスタックを用いて以下のように行われます。

ファイル中の最初の行を読み出す前に、スタックにゼロが一つ積まれ (push
され) ます; このゼロは決して除去 (pop) されることはありません。
スタックの先頭に積まれてゆく数字は、常にスタックの末尾から先頭にかけて
厳密に増加するようになっています。各論理行の開始位置において、
その行のインデントレベル値がスタックの先頭の値と比較されます。値が
等しければ何もしません。インデントレベル値がスタック上の値よりも
大きければ、インデントレベル値はスタックに積まれ、INDENT トークンが
一つ生成されます。インデントレベル値がスタック上の値よりも小さい場合、
その値はスタック内のいずれかの値と_等しくなければなりません_ ;
スタック上のインデントレベル値よりも大きい値はすべて除去され、
値が一つ除去されるごとに DEDENT トークンが一つ生成されます。ファイルの
末尾では、スタックに残っているゼロより大きい値は全て除去され、
値が一つ除去されるごとに DEDENT トークンが一つ生成されます。

以下の例に正しく (しかし当惑させるように) インデントされた Python
コードの一部を示します:

     def perm(l):
             # Compute the list of all permutations of l
         if len(l) <= 1:
                       return [l]
         r = []
         for i in range(len(l)):
                  s = l[:i] + l[i+1:]
                  p = perm(s)
                  for x in p:
                   r.append(l[i:i+1] + x)
         return r

以下の例は、様々なインデントエラーになります:

      def perm(l):                       # error: first line indented
     for i in range(len(l)):             # error: not indented
         s = l[:i] + l[i+1:]
             p = perm(l[:i] + l[i+1:])   # error: unexpected indent
             for x in p:
                     r.append(l[i:i+1] + x)
                 return r                # error: inconsistent dedent

(実際は、最初の 3 つのエラーはパーザによって検出されます; 最後の
エラーのみが字句解析器で見つかります -- `return r' の
インデントは、スタックから逐次除去されていくどのインデントレベル値とも
一致しません)


File: python-ref-jp.info,  Node: トークン間の空白,  Prev: インデント,  Up: 行構造

トークン間の空白
----------------

論理行の先頭や文字列の内部にある場合を除き、空白文字であるスペース、
タブ、およびフォームフィードは、トークンを分割するために自由に
利用することができます。二つのトークンを並べて書くと別のトークンと
してみなされてしまうような場合には、トークンの間に空白が必要と なります
(例えば、ab は一つのトークンですが、 a b は二つのトークンと なります)。


File: python-ref-jp.info,  Node: その他のトークン,  Next: 識別子 identifier およびキーワード keyword,  Prev: 行構造,  Up: 字句解析

その他のトークン
================

NEWLINE、INDENT、および DEDENT の他、以下のトークンのカテゴリ: _識別子
(identifier)_、_キーワード(keyword)_、_リテラル_、 _演算子 (operator)_
、_デリミタ (delimiter)_ が存在します。 空白文字
(上で述べた行終端文字以外) はトークンではありませんが、
トークンを区切る働きがあります。
トークンの解析にあいまいさが生じた場合、トークンは左から右に読んで
不正でないトークンを構築できる最長の文字列を含むように構築されます。


File: python-ref-jp.info,  Node: 識別子 identifier およびキーワード keyword,  Next: リテラル literal,  Prev: その他のトークン,  Up: 字句解析

識別子 (identifier) およびキーワード (keyword)
==============================================

識別子 (または _名前 (name)_) は、以下の字句定義で記述されます:

`identifier (`letter'|"_") (`letter' | `digit' | "_")*'

`letter `lowercase' | `uppercase''

`lowercase "a"..."z"'

`uppercase "A"..."Z"'

`digit "0"..."9"'

識別子の長さには制限がありません。大小文字は区別されます。

* Menu:

* キーワード keyword::
* 予約済みの識別子種 reserved classes of identifiers::


File: python-ref-jp.info,  Node: キーワード keyword,  Next: 予約済みの識別子種 reserved classes of identifiers,  Prev: 識別子 identifier およびキーワード keyword,  Up: 識別子 identifier およびキーワード keyword

キーワード (keyword)
--------------------

以下の識別子は、予約語、または Python 言語における _キーワード
(keyword)_ として使われ、通常の識別子として
使うことはできません。キーワードは厳密に下記の通りに綴らなければ
なりません:

     and       del       for       is        raise
     assert    elif      from      lambda    return
     break     else      global    not       try
     class     except    if        or        while
     continue  exec      import    pass      yield
     def       finally   in        print

識別子 `as' は `import' 文における構文の一部として
使われることがありますが、現在のところ予約語ではありません。

将来の Python のバージョンでは、識別子 `as' と `None'
はともにキーワードになる予定です。


File: python-ref-jp.info,  Node: 予約済みの識別子種 reserved classes of identifiers,  Prev: キーワード keyword,  Up: 識別子 identifier およびキーワード keyword

予約済みの識別子種 (reserved classes of identifiers)
----------------------------------------------------

ある種の (キーワードを除く) 識別子には、特殊な意味があります。
これらの識別子種は、先頭や末尾にあるアンダースコア文字のパターンで
区別されます:

``_*''
     この識別子は `from MODULE import *' で import されません。
     対話インタプリタでは、最も最近行われた値評価の結果を記憶するために
     特殊な識別子 `_' が使われます; この識別子は `__builtin__'
     モジュール内に記憶されます。対話モードでない場合、`_' には
     特殊な意味はなく、定義されていません。~*Note import 文:: 節、
     "`import' 文" を参照してください。

     _Note:_ 名前 `_' は、しばしば国際化 (internationalization) と共に
     用いられます; この慣習についての詳しい情報は、 `gettext' module を
     参照してください。

``__*__''
     システムで定義された (system-defined) 名前です。これらの名前は
     インタプリタと (標準ライブラリを含む) 実装上で定義されています;
     アプリケーション側では、この名前規約を使って別の名前を定義しようと
     すべきではありません。この種の名前のうち、Python で定義されている
     名前のセットは、将来のバージョンで拡張される可能性があります。
     ~*Note 特殊メソッド名:: 節、"特殊なメソッド名" を参照してください。

``__*''
     クラスプライベート (class-private) な名前です。このカテゴリに属する
     名前は、クラス定義のコンテキスト上で用いられた場合、基底クラスと
     導出クラスの "プライベートな"
     属性間で名前衝突が起こるのを防ぐために 書き直されます。 ~*Note
     識別子 identifier、または名前 name:: 節、"識別子 (名前)"
     を参照してください。



File: python-ref-jp.info,  Node: リテラル literal,  Next: 演算子 operator,  Prev: 識別子 identifier およびキーワード keyword,  Up: 字句解析

リテラル (literal)
==================

リテラル (literal) とは、いくつかの組み込み型の定数を表記したものです。

* Menu:

* 文字列リテラル::
* 文字列リテラルの結合 concatenation::
* 数値リテラル::
* 整数および長整数リテラル::
* 浮動小数点数リテラル::
* 虚数 imaginary リテラル::


File: python-ref-jp.info,  Node: 文字列リテラル,  Next: 文字列リテラルの結合 concatenation,  Prev: リテラル literal,  Up: リテラル literal

文字列リテラル
--------------

文字列リテラルは以下の字句定義で記述されます:

`stringliteral [`stringprefix'](`shortstring' | `longstring')'

`stringprefix "r" | "u" | "ur" | "R" | "U" | "UR" | "Ur" | "uR"'

`shortstring "'" `shortstringitem'* "'" | '"' `shortstringitem'* '"''

`longstring "'''" `longstringitem'* "'''"'

` | '"""' `longstringitem'* '"""''

`shortstringitem `shortstringchar' | `escapeseq''

`longstringitem `longstringchar' | `escapeseq''

`shortstringchar <any ASCII character except "\" or newline or the quote>'

`longstringchar <any ASCII character except "\">'

`escapeseq "\" <any ASCII character>'

上記の生成規則で示されていない文法的な制限が一つあります。それは
文字列リテラルの `stringprefix' と残りの部分の間に
空白を入れてはならないということです。

より平易な説明: 文字列リテラルは、対応する一重引用符 (`'') または
二重引用符 (`"') で囲われます。また、対応する三連の一重引用符
や二重引用符で囲うこともできます (通常、_三重クオート文字列:
triple-quoted string_ として 参照されます)。バックスラッシュ (`\')
文字を使って、
ある文字を例えば改行文字やバックスラッシュ自体、クオート文字といった
別の意味を持つようにエスケープすることができます。
文字列リテラルの前には、オプションとして `r' または `R'
一文字を接頭してもかまいません; このような文字列は "raw 文字列 (raw
string)" と呼ばれ、バックスラッシュによるエスケープシーケンスの
解釈規則が異なります。`u' や `U' を接頭すると、 文字列は Unicode 文字列
(Unicode string) になります。Unicode 文字列は Unicode
コンソーシアムおよび ISO~10646 で定義されている Unicode 文字セット
を使います。Unicode 文字列では、文字セットに加えて、以下で説明するような
エスケープシーケンスを利用できます。二つの接頭文字を組み合わせることも
できます; この場合、`u' は `r' より前に出現しなくては なりません。

三重クオート文字列中には、三連のエスケープされないクオート文字で
文字列を終端してしまわないかぎり、エスケープされていない改行やクオートを
書くことができます (さらに、それらはそのまま文字列中に残ります)。
(ここでいう "クオート" とは、文字列の囲みを開始するときに使った文字
を示し、`'' か `"' のいずれかです)。

`r' または `R' 接頭文字がつかないかぎり、
文字列中のエスケープシーケンスは標準 C で使われているのと同様の
法則にしたがって解釈されます。以下に Python で認識されるエスケープ
シーケンスを示します:

エスケープシーケンス     意味                     備考
------                   -----                    -----
\NEWLINE                 無視                     
\\                       バックスラッシュ (`\')   
\'                       一重引用符 (`'')         
\"                       二重引用符 (`"')         
\a                       ASCII 端末ベル (BEL)     
\b                       ASCII バックスペース     
                         (BS)                     
\f                       ASCII フォームフィード   
                         (FF)                     
\n                       ASCII 行送り (LF)        
\N{NAME}                 Unicode                  
                         データベース中で名前     
                         NAME を持つ文字          
                         (Unicode のみ)           
\r                       ASCII 復帰 (CR)          
\t                       ASCII 水平タブ (TAB)     
\uXXXX                   16-bit の 16 進数値      (1)
                         XXXX を持つ文字          
                         (Unicode のみ)           
\UXXXXXXXX               32-bit の 16 進数値      (2)
                         XXXXXXXX を持つ文字      
                         (Unicode のみ)           
\v                       ASCII 水平タブ (VT)      
\OOO                     8 進数値 OOO を持つ      (3)
                         ASCII 文字               
\xHH                     16 進数値 HH を持つ      (4)
                         ASCII 文字               

備考:

   * (1)
     サロゲートペアの断片を形成する個々のコード単位は、このエスケープ
     シーケンスでエンコードすることができます。

   * (2) Unicode 文字はすべてこの方法でエンコードできますが、 Python が
     16-bit コード単位を扱うようにコンパイルされている
     (デフォルトの設定です) 場合、基本多言語面 (Basic Multilingual
     Plane, BMP) 外の文字はサロゲートペア (surrogate pair)
     を使ってエンコードする
     ことになります。サロゲートペアの断片を形成する個々のコード単位は
     このエスケープシーケンスを使ってエンコードすることができます。

   * (3) 標準 C と同じく、最大で 3 桁の 8 進数まで受理します。

   * (4) 標準 C とは違い、最大で二桁の 16 進数しか受理されません。

標準の C とは違い、認識されなかったエスケープシーケンスはそのまま
文字列中に残されます。すなわち。
_バックスラッシュも文字列中に残ります。_ (この挙動はデバッグの
際に便利です: エスケープシーケンスを誤入力した場合、その結果として
出力に失敗しているのが用意にわかります) テーブル中で "(Unicode のみ)"
と書かれたエスケープシーケンスは、非 Unicode
文字列リテラル中では認識されないエスケープシーケンスのカテゴリに
分類されるので注意してください。

接頭文字 `r' または `R' がある場合、バックスラッシュ
の後にくる文字はそのまま文字列中に入り、_バックスラッシュは全て
文字列中に残されます_。例えば、文字列リテラル `r"\n"' は二つの文字:
バックスラッシュと小文字の `n' からなる文字列を表すことに
なります。引用符はバックスラッシュでエスケープすることができますが、
バックスラッシュ自体も残ってしまいます; 例えば、`r"\""' は不正でない
文字列リテラルで、バックスラッシュと二重引用符からなる文字列を表します;
`r"\"' は正しくない文字列リテラルです (raw 文字列を奇数個連なった
バックスラッシュで終わらせることはできません)。厳密にいえば、
(バックスラッシュが直後のクオート文字をエスケープしてしまうため) _raw
文字列を単一のバックスラッシュで終わらせることはできない_
ということになります。また、バックスラッシュの直後に改行がきても、
行継続を意味する_のではなく_ 、それら二つの文字として解釈されるので
注意してください。

`r' および `R' 接頭文字を `u' や `U' と合わせて使った場合、`\uXXXX'
エスケープ シーケンスは処理されますが、_その他のバックスラッシュは
すべて文字列中に残されます_ 。例えば、文字列リテラル `ur"\u0062\n"'
は、3つの Unicode 文字: `LATIN SMALL LETTER B' (ラテン小文字
B)、`REVERSE SOLIDUS' (逆向き斜線)、 および `LATIN SMALL LETTER N'
(ラテン小文字 N) を表します。
バックスラッシュの前にバックスラッシュをつけてエスケープすることは
できます; しかし、バックスラッシュは両方とも文字列中に残されます。
その結果、`\uXXXX' エスケープシーケンスは、バックスラッシュが
奇数個連なっている場合にのみ認識されます。


File: python-ref-jp.info,  Node: 文字列リテラルの結合 concatenation,  Next: 数値リテラル,  Prev: 文字列リテラル,  Up: リテラル literal

文字列リテラルの結合 (concatenation)
------------------------------------

複数の文字列リテラルは、互いに異なる引用符を使っていても
(空白文字で区切って) 隣接させることができ、その意味は各々の文字列を
結合したものと同じになります。したがって、`"hello" 'world'' は
`"helloworld"' と同じになります。この機能を使うと、長い文字列を
分離して、複数行にまたがらせる際に便利です。また、部分文字列ごとに
コメントを追加することもできます。例えば:

     re.compile("[A-Za-z_]"       # letter or underscore
                "[A-Za-z0-9_]*"   # letter, digit or underscore
               )

この機能は文法レベルで定義されていますが、スクリプトをコンパイルする
際の処理として実現されることに注意してください。実行時に文字列表現を
結合したければ、 `+' 演算子を使わなければなりません。また、リテラルの
結合においては、結合する各要素に異なる引用符形式を使える (raw 文字列
と三重引用符を混ぜることさえできます) ので注意してください。


File: python-ref-jp.info,  Node: 数値リテラル,  Next: 整数および長整数リテラル,  Prev: 文字列リテラルの結合 concatenation,  Up: リテラル literal

数値リテラル
------------

数値リテラルは 4 種類あります: 整数 (plain integer)、長整数 (long
integer)、浮動小数点数 (floating point number)、そして虚数 (imaginary
number) です。複素数のためのリテラルはありません (複素数は実数と
虚数の和で作ることができます)。

数値リテラルには符号が含まれていないことに注意してください; `-1'
のような句は、実際には単項演算子 (unary operator) ``-'' とリテラル `1'
を組み合わせたものです。


File: python-ref-jp.info,  Node: 整数および長整数リテラル,  Next: 浮動小数点数リテラル,  Prev: 数値リテラル,  Up: リテラル literal

整数および長整数リテラル
------------------------

整数および長整数リテラルは以下の字句定義で記述されます:

`longinteger `integer' ("l" | "L")'

`integer `decimalinteger' | `octinteger' | `hexinteger''

`decimalinteger `nonzerodigit' `digit'* | "0"'

`octinteger "0" `octdigit'+'

`hexinteger "0" ("x" | "X") `hexdigit'+'

`nonzerodigit "1"..."9"'

`octdigit "0"..."7"'

`hexdigit `digit' | "a"..."f" | "A"..."F"'

長整数を表す末尾の文字は小文字の `l' でも大文字の `L'
でもかまいませんが、`l' は `1' に良く似ているので、 常に `L'
を使うよう強く勧めます。

整数で表現できる最大の値よりも大きい整数の 10 進表現リテラル (例えば
32-bit 整数を使っている場合には 2147483647) は、
長整数として表現できる値であれば受理されます。8 進および 16 進数
のリテラルも同様にふるまいますが、整数で表現できる最大の値よりも大きく、
かつ (32-bit 算術演算を使う計算機では) 符号無しの 32-bit の整数で表現
できる最大の値、4294967296 までの間では、符号無し 32-bit 整数としての
値から 4294967296 を引いて得られる負の整数値になります。
値がメモリ上に収まるかどうかという問題を除けば、長整数リテラルには値域の
制限がありません。例えば、0xdeadbeef は 32-bit の計算機では -559038737
という値とみなされ、0xdeadbeeffeed は 244837814107885L
であるとみなされます。

整数リテラル (最初の行) と長整数リテラル (二行目および三行目) の例を
以下に示します:

     7     2147483647                        0177    0x80000000
     3L    79228162514264337593543950336L    0377L   0x100000000L
           79228162514264337593543950336             0xdeadbeeffeed


File: python-ref-jp.info,  Node: 浮動小数点数リテラル,  Next: 虚数 imaginary リテラル,  Prev: 整数および長整数リテラル,  Up: リテラル literal

浮動小数点数リテラル
--------------------

浮動小数点数リテラルは以下の字句定義で記述されます:

`floatnumber `pointfloat' | `exponentfloat''

`pointfloat [`intpart'] `fraction' | `intpart' "."'

`exponentfloat (`intpart' | `pointfloat') `exponent''

`intpart `digit'+'

`fraction "." `digit'+'

`exponent ("e" | "E") ["+" | "-"] `digit'+'

浮動小数点数における整数部と指数部は 8 進数のように見えることも
ありますが、10 を基数として解釈されるので注意してください。
例えば、`077e010' は正しい表記であり、`77e10' と同じ数を 表します。
浮動小数点数リテラルの取りうる値の範囲は実装に依存します。
浮動小数点数リテラルの例をいくつか示します:

     3.14    10.    .001    1e100    3.14e-10    0e0

数値リテラルには符号が含まれていないことに注意してください; `-1'
のような句は、実際には単項演算子 (unary operator) ``-'' とリテラル `1'
を組み合わせたものです。


File: python-ref-jp.info,  Node: 虚数 imaginary リテラル,  Prev: 浮動小数点数リテラル,  Up: リテラル literal

虚数 (imaginary) リテラル
-------------------------

虚数リテラルは以下のような字句定義で記述されます:

`imagnumber (`floatnumber' | `intpart') ("j" | "J")'

虚数リテラルは、実数部が 0.0 の複素数を表します。複素数は二つ組の
浮動小数点型の数値で表され、それぞれの数値は浮動小数点型と同じ定義域の
範囲を持ちます。実数部がゼロでない浮動小数点を生成するには、`(3+4j)'
のように虚数リテラルに浮動小数点数を加算します。以下に虚数リテラルの
例をいくつか示します:

     3.14j   10.j    10j     .001j   1e100j  3.14e-10j


File: python-ref-jp.info,  Node: 演算子 operator,  Next: デリミタ delimiter,  Prev: リテラル literal,  Up: 字句解析

演算子 (operator)
=================

以下のトークンは演算子です:

     +       -       *       **      /       //      %
     <<      >>      &       |       ^       ~
     <       >       <=      >=      ==      !=      <>

比較演算子 `<>' と `!=' は、同じ演算子について別の書き方をした
ものです。書き方としては `!=' を推奨します; `<>' は時代遅れの
書き方です。


File: python-ref-jp.info,  Node: デリミタ delimiter,  Prev: 演算子 operator,  Up: 字句解析

デリミタ (delimiter)
====================

以下のトークンは文法上のデリミタとして働きます:

     (       )       [       ]       {       }
     ,       :       .       `       =       ;
     +=      -=      *=      /=      //=     %=
     &=      |=      ^=      >>=     <<=     **=

浮動小数点数や虚数リテラル中にピリオドがあってもかまいません。
ピリオド三つの列はスライス表記における省略符号 (ellipsis) として
特別な意味を持っています。リスト後半の累算代入演算子 (augmented
assignment operator) は、字句的にはデリミタとして振舞いますが、
演算も行います。

以下の印字可能 ASCII 文字は、他のトークンの一部として特殊な意味を
持っていたり、字句解析器にとって重要な意味を持っています:

     '       "       #       \

以下の印字可能 ASCII 文字は、Python では使われていません。これらの
文字が文字列リテラルやコメントの外にある場合、無条件にエラーとなります:

     @       $       ?


File: python-ref-jp.info,  Node: データモデル,  Next: 実行モデル,  Prev: 字句解析,  Up: Top

データモデル
************

* Menu:

* オブジェクト、値、および型::
* 標準型の階層::
* 特殊メソッド名::


File: python-ref-jp.info,  Node: オブジェクト、値、および型,  Next: 標準型の階層,  Prev: データモデル,  Up: データモデル

オブジェクト、値、および型
==========================

Python における "オブジェクト (object)" とは、データを抽象的に
表したものです。Python プログラムにおけるデータは全て、オブジェクトま
たはオブジェクト間の関係として表されます。(ある意味では、プログラムコー
ドもまたオブジェクトとして表されます。これはフォン・ノイマン: Von
Neumann の "プログラム記憶方式コンピュータ: stored program computer"
のモデルに適合します。)

オブジェクトはアイデンティティ値 (identity) 、型 (type) 、そして値
(value) を持ちます。オブジェクトが一度生成されると、そのオブジェクトの
_アイデンティティ値_ は決して変化することがありません; アイデンティ
ティ値をオブジェクトのメモリ上のアドレスと考えてもかまいません。 演算子
``is'' は、二つのオブジェクト間のアイデンティティ値を比 較します; 関数
`id()'  は、オブジェクトのアイデ ンティティ値を表す整数
(現在の実装ではオブジェクトのメモリ上のアドレス) を返します。
オブジェクトの "型" もまた変わることがありません。 (1)
オブジェクトの型は、そのオブジェクトのサポートする操作
("長さを持っているか？" など) を決定し、その型のオブジェクトが
取りうる値について定義しています。 `type()'  関数は、オブジェクトの型
(型自体も一つのオブジェクトです) を返します。オブジェクトによっては、
_値 (value)_ を変えることができます。値を変えることができる
オブジェクトは _変更可能 (mutable)_ であるといいます; 値を
一度設定すると、その後は変えることができないオブジェクトは _変更不能
(immutable)_ であると呼びます。
(変更不能なコンテナオブジェクトが変更可能なオブジェクトへの参照を
含んでいる場合、その値は後者のオブジェクトの変更によって変わる
場合があります; その場合でも、コンテナの含んでいるオブジェクトの
集まりは変わらないため、コンテナは変更不能と考えます。したがって、
変更不能性 (immutability) は、厳密には変更できない値を持っている
こととは違い、もっと微妙な概念です。)
オブジェクトの変更可能性は型で決定されます; 例えば、数値、文字列、
およびタプルは変更不能であり、辞書やリストは変更可能です。

オブジェクトを明示的に破壊することはできません; しかし、オブジェクト
に到達不能 (unreachable) になると、ガベージコレクション
(garbage-collection)
によって処理されます。実装では、ごみ収集を遅らせたり、全く行わない
ようにすることができます -- 到達可能なオブジェクトをごみ収集処理して
しまわないかぎり、どう実装するかは実装品質の問題です。 (実装上の注意:
現在の実装では参照カウント (reference-counting) 手順を
使っており、(オプションとして) 循環参照を行っているごみオブジェクトを
遅延検出します。この実装ではほとんどのオブジェクトを到達不能になると
同時に処理することができますが、循環参照を含むごみオブジェクトの収集が
確実に行われるよう保証しているわけではありません。循環参照を持つごみ
オブジェクト収集の制御については、  を 参照してください。)

実装のトレース機能やデバッグ機能を使えば、通常は収集されてしまう
ようなオブジェクトを生かしておくことがあるので注意してください。 また、
``try'...`except'' 文を使って例外を捕捉できる
ようにすると、オブジェクトを生かしておくことがあります。

オブジェクトによっては、開かれたファイルやウィンドウといった、 "外部
(external) の" リソースに対する参照を行っています。
これらのリソースは、オブジェクトがごみ収集された際に解放される
ものと理解されていますが、ごみ収集が行われる保証はないので、
こうしたオブジェクトでは外部リソースを明示的に解放する 方法、大抵は
`close()' メソッドを提供しています。 こうしたオブジェクトは明示的に
close するよう強く奨めます。 操作をする際には、``try'...`finally''
文を使うと 便利です。

他のオブジェクトに対する参照をもつオブジェクトもあります; これらは
_コンテナ (container)_ と呼ばれます。コンテナオブジェクトの例
として、タプル、リスト、および辞書が挙げられます。オブジェクトへの
参照自体がコンテナの値の一部です。ほとんどの場合、コンテナの値と
いうと、コンテナに入っているオブジェクトの値のことを指し、それら
オブジェクトのアイデンティティではありません; しかしながら、
コンテナの変更可能性について述べる場合、今まさにコンテナに入っている
オブジェクトのアイデンティティのことを指します。したがって、
(タプルのように) 変更不能なオブジェクトが変更可能なオブジェクト
への参照を含む場合、その値が変化するのは変更可能なオブジェクトが
変更された時、ということになります。

型はオブジェクトの動作のほとんど全てに影響します。オブジェクトの
アイデンティティが重要かどうかでさえ、ある意味では型に左右されます:
変更不能な型では、新たな値を計算するような操作を行うと、実際には同じ
型と値を持った既存のオブジェクトへの参照を返すことがありますが、
変更可能なオブジェクトではそのような動作は起こりえません。例えば、 `a =
1; b = 1' とすると、 `a' と `b' は値 1 を持つ
同じオブジェクトを参照するときもあるし、そうでないときもあります。
これは実装に依存します。しかし、 `c = []; d = []' とすると、 `c' と `d'
はそれぞれ
二つの異なった、互いに一意な、新たに作成された空のリストを参照する
ことが保証されています。 (`c = d = []' とすると、 `c' と `d'
の両方に同じ オブジェクトを代入します)

---------- Footnotes ----------

(1) Python 2.2 以降、型とクラスの段階的な統合が始まっている
ため、このドキュメントで主張されている内容が 100% 正確で完全と
いうわけではなくなりました: 例えば、場合によっては、ある管理された
条件下でなら、オブジェクトの型を_変更することができます_。
このマニュアルに大幅な改訂が施されるまでは、このドキュメントでの
記述は、"旧クラス型 (classic class)" に関してのみ
信頼できる内容と考えねばなりません。Python 2.2 および 2.3 では、
互換性のためにクラシックなクラスがまだデフォルトとなっています。

