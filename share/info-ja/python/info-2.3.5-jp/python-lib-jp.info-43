This is python-lib-jp.info, produced by makeinfo version 4.5 from
python-lib-jp.texi.

12 October 2005


File: python-lib-jp.info,  Node: ASTオブジェクトを変換する,  Next: ASTオブジェクトに対する問い合わせ,  Prev: ASTオブジェクトを作成する,  Up: parser

ASTオブジェクトを変換する
-------------------------

作成するために使われた入力に関係なく、ASTオブジェクトはリスト木またはタプル木として表される解析木へ変換されるか、または実行可能なオブジェクトへコンパイルされます。解析木は行番号情報を持って、あるいは持たずに抽出されます。

`ast2list(ast[, line_info])'
     この関数は呼び出し側からASTにASTオブジェクトを受け取り、解析木と等価なPythonのリストを返します。結果のリスト表現はインスペクションあるいはリスト形式の新しい解析木の作成に使うことができます。リスト表現を作るためにメモリが利用できる限り、この関数は失敗しません。解析木がインスペクションのためだけにつかわれるならば、メモリの消費量と断片化を減らすために`ast2tuple()'を代わりに使うべきです。リスト表現が必要とされるとき、この関数はタプル表現を取り出して入れ子のリストに変換するよりかなり高速です。

     LINE_INFOが真ならば、トークンを表すリストの三番目の要素として行番号情報がすべての終端トークンに含まれます。与えられた行番号はトークン_が終わる_行を指定していることに注意してください。フラグが偽または省略された場合は、この情報は省かれます。

`ast2tuple(ast[, line_info])'
     この関数は呼び出し側からASTにASTオブジェクトを受け取り、解析木と等価なPythonのタプルを返します。リストの代わりにタプルを返す以外は、この関数は`ast2list()'と同じです。

     LINE_INFOが真ならば、トークンを表すリストの三番目の要素として行番号情報がすべての終端トークンに含まれます。フラグが偽または省略された場合は、この情報は省かれます。

`compileast(ast[, filename` = '<ast>''])'
     `exec'文の一部として使える、あるいは、組み込み`eval()'
     関数への呼び出しとして使えるコードオブジェクトを生成するために、PythonバイトコードコンパイラをASTオブジェクトに対して呼び出すことができます。この関数はコンパイラへのインターフェイスを提供し、FILENAMEパラメータで指定されるソースファイル名を使って、ASTからパーサへ内部解析木を渡します。FILENAMEに与えられるデフォルト値は、ソースがASTオブジェクトだったことを示唆しています。

     ASTオブジェクトをコンパイルすることは、コンパイルに関する例外を引き起こすことになるかもしれません。例としては、`del
     f(0)'の解析木によって発生させられる`SyntaxError'があります:
     この文はPythonの形式文法としては正しいと考えられますが、正しい言語コンストラクトではありません。この状況に対して発生する`SyntaxError'は、実際にはPythonバイトコンパイラによって通常作り出されます。これが`parser'モジュールがこの時点で例外を発生できる理由です。解析木のインスペクションを行うことで、コンパイルが失敗するほとんどの原因をプルグラムによって診断することができます。


File: python-lib-jp.info,  Node: ASTオブジェクトに対する問い合わせ,  Next: 例外とエラー処理,  Prev: ASTオブジェクトを変換する,  Up: parser

ASTオブジェクトに対する問い合わせ
---------------------------------

ASTが式またはsuiteとして作成されたかどうかをアプリケーションが決定できるようにする二つの関数が提供されています。これらの関数のどちらも、ASTが`expr()'または`suite()'を通してソースコードから作られたかどうか、あるいは、`sequence2ast()'を通して解析木から作られたかどうかを決定できません。

`isexpr(ast)'
     ASTが`'eval''形式を表している場合に、この関数は真を返します。そうでなければ、偽を返します。これは役に立ちます。なぜならば、通常は既存の組み込み関数を使ってもコードオブジェクトに対してこの情報を問い合わせることができないからです。このどちらのようにも`compileast()'によって作成されたコードオブジェクトに問い合わせることはできませんし、そのコードオブジェクトは組み込み`compile()'
     関数によって作成されたコードオブジェクトと同じであることに注意してください。

`issuite(ast)'
     ASTオブジェクトが(通常"suite"として知られる)`'exec''形式を表しているかどうかを報告するという点で、この関数は`isexpr()'に酷似しています。追加の構文が将来サポートされるかもしれないので、この関数が`not
     isexpr(AST)'と等価であるとみなすのは安全ではありません。


File: python-lib-jp.info,  Node: 例外とエラー処理,  Next: ASTオブジェクト,  Prev: ASTオブジェクトに対する問い合わせ,  Up: parser

例外とエラー処理
----------------

parserモジュールは例外を一つ定義していますが、Pythonランタイム環境の他の部分が提供する別の組み込み例外を発生させることもあります。各関数が発生させる例外の情報については、それぞれ関数を参照してください。

`ParserError'
     parserモジュール内部で障害が起きたときに発生する例外。普通の構文解析中に発生する組み込みの`SyntaxError'ではなく、一般的に妥当性確認が失敗した場合に引き起こされます。例外の引数としては、障害の理由を説明する文字列である場合と、`sequence2ast()'へ渡される解析木の中の障害を引き起こすシーケンスを含むタプルと説明用の文字列である場合があります。モジュール内の他の関数の呼び出しは単純な文字列値を検出すればよいだけですが、`sequence2ast()'の呼び出しはどちらの例外の型も処理できる必要があります。

普通は構文解析とコンパイル処理によって発生する例外を、関数`compileast()'、`expr()'および`suite()'が発生させることに注意してください。このような例外には組み込み例外`MemoryError'、`OverflowError'、`SyntaxError'および`SystemError'が含まれます。こうした場合には、これらの例外が通常その例外に関係する全ての意味を伝えます。詳細については、各関数の説明を参照してください。


File: python-lib-jp.info,  Node: ASTオブジェクト,  Next: 例 16,  Prev: 例外とエラー処理,  Up: parser

ASTオブジェクト
---------------

ASTオブジェクト間の順序と等値性の比較がサポートされています。(`pickle'モジュールを使った)ASTオブジェクトのピクルス化もサポートされています。

`ASTType'
     `expr()'、`suite()'と`sequence2ast()'が返すオブジェクトの型。

ASTオブジェクトは次のメソッドを持っています:

`compile([filename])'
     `compileast(AST, FILENAME)'と同じ。

`isexpr()'
     `isexpr(AST)'と同じ。

`issuite()'
     `issuite(AST)'と同じ。

`tolist([line_info])'
     `ast2list(AST, LINE_INFO)'と同じ。

`totuple([line_info])'
     `ast2tuple(AST, LINE_INFO)'と同じ。


File: python-lib-jp.info,  Node: 例 16,  Prev: ASTオブジェクト,  Up: parser

例
--

parserモジュールを使うと、バイトコードが生成される前にPythonのソースコードの解析木に演算を行えるようになります。また、モジュールは情報発見のために解析木のインスペクションを提供しています。例が二つあります。簡単な例では組み込み関数`compile()'
のエミュレーションを行っており、複雑な例では情報を得るための解析木の使い方を示しています。

* Menu:

* compileのエミュレーション::
* 情報発見::


File: python-lib-jp.info,  Node: compileのエミュレーション,  Next: 情報発見,  Prev: 例 16,  Up: 例 16

`compile()'のエミュレーション
.............................

たくさんの有用な演算を構文解析とバイトコード生成の間に行うことができますが、もっとも単純な演算は何もしないことです。このため、`parser'モジュールを使って中間データ構造を作ることは次のコードと等価です。

     >>> code = compile('a + 5', 'file.py', 'eval')
     >>> a = 5
     >>> eval(code)
     10

`parser'モジュールを使った等価な演算はやや長くなりますが、ASTオブジェクトとして中間内部解析木が維持されるようにします:

     >>> import parser
     >>> ast = parser.expr('a + 5')
     >>> code = ast.compile('file.py')
     >>> a = 5
     >>> eval(code)
     10

ASTとコードオブジェクトの両方が必要なアプリケーションでは、このコードを簡単に利用できる関数にまとめることができます:

     import parser
     
     def load_suite(source_string):
         ast = parser.suite(source_string)
         return ast, ast.compile()
     
     def load_expression(source_string):
         ast = parser.expr(source_string)
         return ast, ast.compile()


File: python-lib-jp.info,  Node: 情報発見,  Prev: compileのエミュレーション,  Up: 例 16

情報発見
........

あるアプリケーションでは解析木へ直接アクセスすることが役に立ちます。この節の残りでは、`import'を使って調査中のコードを実行中のインタープリタにロードする必要も無しに、解析木を使ってdocstrings
に定義されたモジュールのドキュメンテーションへのアクセスを可能にする方法を示します。これは信頼性のないコードを解析するためにとても役に立ちます。

一般に、例は興味のある情報を引き出すために解析木をどのような方法でたどればよいかを示しています。二つの関数と一連のクラスが開発され、モジュールが提供する高レベルの関数とクラスの定義をプログラムから利用できるようになります。クラスは情報を解析木から引き出し、便利な意味レベルでその情報へアクセスできるようにします。一つの関数は単純な低レベルのパターンマッチング機能を提供し、もう一つの関数は呼び出し側の代わりにファイル操作を行うという点でクラスへの高レベルなインターフェイスです。ここで言及されていてPythonのインストールに必要ないすべてのソースファイルは、ディストリビューションの`Demo/parser/'ディレクトリにあります。

Pythonの動的な性質によってプログラマは非常に大きな柔軟性を得ることができます。しかし、クラス、関数およびメソッドを定義するときには、ほとんどのモジュールがこれの限られた部分しか必要としません。この例では、考察される定義だけがコンテキストのトップレベルにおいて定義されるものです。例を挙げると、モジュールのゼロ列目に`def'文によって定義される関数で、`if'
...
`else'コンストラクトの枝の中に定義されていない関数(ある状況ではそうすることにもっともな理由があるのですが)。例で開発するコードによって、定義の入れ子を扱う予定です。

より上位レベルの抽出メソッドを作るために知る必要があるのは、解析木構造がどのようなものかということと、それのどの程度まで関心を持つ必要があるのかということです。Pythonはやや深い解析木を使いますので、たくさんの中間ノードがあります。Pythonが使う形式文法を読んで理解することは重要です。これは配布物に含まれるファイル`Grammar/Grammar'に明記されています。docstringsを探すときに対象として最も単純な場合について考えてみてください:
docstringの他に何も無いモジュール。(ファイル`docstring.py'を参照してください。)

     """Some documentation.
     """

インタープリタを使って解析木を調べると、数と括弧が途方に暮れるほど多くて、ドキュメンテーションが入れ子になったタプルの深いところに埋まっていることがわかります。

     >>> import parser
     >>> import pprint
     >>> ast = parser.suite(open('docstring.py').read())
     >>> tup = ast.totuple()
     >>> pprint.pprint(tup)
     (257,
      (264,
       (265,
        (266,
         (267,
          (307,
           (287,
            (288,
             (289,
              (290,
               (292,
                (293,
                 (294,
                  (295,
                   (296,
                    (297,
                     (298,
                      (299,
                       (300, (3, '"""Some documentation.\n"""'))))))))))))))))),
        (4, ''))),
      (4, ''),
      (0, ''))

木の各ノードの最初の要素にある数はノード型です。それらは文法の終端記号と非終端記号に直接に対応します。残念なことに、それらは内部表現の整数で表されていて、生成されたPythonの構造でもそのままになっています。しかし、`symbol'と`token'モジュールはノード型の記号名と整数からノード型の記号名へマッピングする辞書を提供します。

上に示した出力の中で、最も外側のタプルは四つの要素を含んでいます:
整数`257'と三つの付加的なタプル。ノード型`257'の記号名は`file_input'です。これらの各内部タプルは最初の要素として整数を含んでいます。これらの整数`264'と`4'、`0'は、ノード型`stmt'、`NEWLINE'、`ENDMARKER'をそれぞれ表しています。これらの値はあなたが使っているPythonのバージョンに応じて変化する可能性があることに注意してください。マッピングの詳細については、`symbol.py'と`token.py'を調べてください。もっとも外側のノードがファイルの内容ではなく入力ソースに主に関係していることはほとんど明らかで、差し当たり無視しても構いません。`stmt'ノードはさらに興味深いです。特に、すべてのdocstringsは、このノードが作られるのとまったく同じように作られ、違いがあるのは文字列自身だけである部分木にあります。同様の木のdocstringと説明の対象である定義されたエンティティ(クラス、関数あるいはモジュール)の関係は、前述の構造を定義している木の内部におけるdocstring部分木の位置によって与えられます。

実際のdocstringを木の変数要素を意味する何かと置き換えることによって、簡単なパターンマッチング方法で与えられたどんな部分木でもdocstringsに対する一般的なパターンと同等かどうかを調べられるようになります。例では情報の抽出の実例を示しているので、`['variable_name']'という単純な変数表現を念頭において、リスト形式ではなくタプル形式の木を安全に要求できます。簡単な再帰関数でパターンマッチングを実装でき、その関数は真偽値と変数名から値へのマッピングの辞書を返します。(ファイル`example.py'を参照してください。)

     from types import ListType, TupleType
     
     def match(pattern, data, vars=None):
         if vars is None:
             vars = {}
         if type(pattern) is ListType:
             vars[pattern[0]] = data
             return 1, vars
         if type(pattern) is not TupleType:
             return (pattern == data), vars
         if len(data) != len(pattern):
             return 0, vars
         for pattern, data in map(None, pattern, data):
             same, vars = match(pattern, data, vars)
             if not same:
                 break
         return same, vars

この構文の変数用の簡単な表現と記号のノード型を使うと、docstring部分木の候補のパターンがとても読みやすくなります。(ファイル`example.py'を参照してください。)

     import symbol
     import token
     
     DOCSTRING_STMT_PATTERN = (
         symbol.stmt,
         (symbol.simple_stmt,
          (symbol.small_stmt,
           (symbol.expr_stmt,
            (symbol.testlist,
             (symbol.test,
              (symbol.and_test,
               (symbol.not_test,
                (symbol.comparison,
                 (symbol.expr,
                  (symbol.xor_expr,
                   (symbol.and_expr,
                    (symbol.shift_expr,
                     (symbol.arith_expr,
                      (symbol.term,
                       (symbol.factor,
                        (symbol.power,
                         (symbol.atom,
                          (token.STRING, ['docstring'])
                          )))))))))))))))),
          (token.NEWLINE, '')
          ))

このパターンと`match()'関数を使うと、前に作った解析木からモジュールのdocstringを簡単に抽出できます:

     >>> found, vars = match(DOCSTRING_STMT_PATTERN, tup[1])
     >>> found
     1
     >>> vars
     {'docstring': '"""Some documentation.\n"""'}

特定のデータを期待された位置から抽出できると、次は情報を期待できる場所はどこかという疑問に答える必要がでてきます。docstringを扱う場合、答えはとても簡単です:
docstringはコードブロック(`file_input'または`suite'ノード型)の最初の`stmt'ノードです。モジュールは一つの`file_input'ノードと、正確にはそれぞれが一つの`suite'ノードを含むクラスと関数の定義で構成されます。クラスと関数は`(stmt,
(compound_stmt, (classdef, ...'または`(stmt, (compound_stmt, (funcdef,
...'で始まるコードブロックノードの部分木として簡単に識別されます。これらの部分木は`match()'によってマッチさせることができないことに注意してください。なぜなら、数を無視して複数の兄弟ノードにマッチすることをサポートしていないからです。この限界を超えるためにより念入りにつくったマッチング関数を使うことができますが、例としてはこれで充分です。

文がdocstringかどうかを決定し、実際の文字列をその文から抽出する機能について考えると、ある作業にはモジュール全体の解析木を巡回してモジュールの各コンテキストにおいて定義される名前についての情報を抽出し、その名前とdocstringsを結び付ける必要があります。この作業を行うコードは複雑ではありませんが、説明が必要です。

そのクラスへの公開インターフェイスは簡単で、おそらく幾分かより柔軟でしょう。モジュールのそれぞれの"主要な"ブロックは、問い合わせのための幾つかのメソッドを提供するオブジェクトと、少なくともそれが表す完全な解析木の部分木を受け取るコンストラクタによって記述されます。`ModuleInfo'コンストラクタはオプションのNAMEパラメータを受け取ります。なぜなら、そうしないとモジュールの名前を決められないからです。

公開クラスには`ClassInfo'、`FunctionInfo'および`ModuleInfo'が含まれます。すべてのオブジェクトはメソッド`get_name()'、`get_docstring()'、`get_class_names()'および`get_class_info()'を提供します。`ClassInfo'オブジェクトは`get_method_names()'と`get_method_info()'をサポートしますが、他のクラスは`get_function_names()'と`get_function_info()'を提供しています。

公開クラスが表すコードブロックの形式のそれぞれにおいて、トップレベルで定義された関数が"メソッド"として参照されるという違いがクラスにはありますが、要求される情報のほとんどは同じ形式をしていて、同じ方法でアクセスされます。クラスの外側で定義される関数との実際の意味の違いを名前の付け方が違うことで反映しているため、実装はこの違いを保つ必要があります。そのため、公開クラスのほとんどの機能が共通の基底クラス`SuiteInfoBase'に実装されており、他の場所で提供される関数とメソッドの情報に対するアクセサを持っています。関数とメソッドの情報を表すクラスが一つだけであることに注意してください。これは要素の両方の型を定義するために`def'文を使うことに似ています。

アクセサ関数のほとんどは`SuiteInfoBase'で宣言されていて、サブクラスでオーバーライドする必要はありません。より重要なこととしては、解析木からのほとんどの情報抽出が`SuiteInfoBase'コンストラクタに呼び出されるメソッドを通して行われるということがあります。平行して形式文法を読めば、ほとんどのクラスのコード例は明らかです。しかし、再帰的に新しい情報オブジェクトを作るメソッドはもっと調査が必要です。`example.py'の`SuiteInfoBase'定義の関連する箇所を以下に示します:

     class SuiteInfoBase:
         _docstring = ''
         _name = ''
     
         def __init__(self, tree = None):
             self._class_info = {}
             self._function_info = {}
             if tree:
                 self._extract_info(tree)
     
         def _extract_info(self, tree):
             # extract docstring
             if len(tree) == 2:
                 found, vars = match(DOCSTRING_STMT_PATTERN[1], tree[1])
             else:
                 found, vars = match(DOCSTRING_STMT_PATTERN, tree[3])
             if found:
                 self._docstring = eval(vars['docstring'])
             # discover inner definitions
             for node in tree[1:]:
                 found, vars = match(COMPOUND_STMT_PATTERN, node)
                 if found:
                     cstmt = vars['compound']
                     if cstmt[0] == symbol.funcdef:
                         name = cstmt[2][1]
                         self._function_info[name] = FunctionInfo(cstmt)
                     elif cstmt[0] == symbol.classdef:
                         name = cstmt[2][1]
                         self._class_info[name] = ClassInfo(cstmt)

初期状態に初期化した後、コンストラクタは`_extract_info()'メソッドを呼び出します。このメソッドがこの例全体で行われる情報抽出の大部分を実行します。抽出には二つの別々の段階があります:
渡された解析木のdocstringの位置の特定、解析木が表すコードブロック内の付加的な定義の発見。

最初の`if'テストは入れ子のsuiteが"短い形式"または"長い形式"かどうかを決定します。以下のコードブロックの定義のように、コードブロックが同じ行であるときに短い形式が使われます。

     def square(x): "Square an argument."; return x ** 2

長い形式では字下げされたブロックを使い、入れ子になった定義を許しています:

     def make_power(exp):
         "Make a function that raises an argument to the exponent `exp'."
         def raiser(x, y=exp):
             return x ** y
         return raiser

短い形式が使われるとき、コードブロックはdocstringを最初の`small_stmt'要素として(ことによるとそれだけを)持っています。このようなdocstringの抽出は少し異なり、より一般的な場合に使われる完全なパターンの一部だけを必要とします。実装されているように、`simple_stmt'ノードに`small_stmt'ノードが一つだけある場合には、docstringしかないことがあります。短い形式を使うほとんどの関数とメソッドがdocstringを提供しないため、これで充分だと考えられます。docstringの抽出は前述の`match()'関数を使って進み、docstringが`SuiteInfoBase'オブジェクトの属性として保存されます。

docstringを抽出した後、簡単な定義発見アルゴリズムを`suite'ノードの`stmt'ノードに対して実行します。短い形式の特別な場合はテストされません。短い形式では`stmt'ノードが存在しないため、アルゴリズムは黙って`simple_stmt'ノードを一つスキップします。正確に言えば、どんな入れ子になった定義も発見しません。

コードブロックのそれぞれの文をクラス定義(関数またはメソッドの定義、あるいは、何か他のもの)として分類します。定義文に対しては、定義された要素の名前が抽出され、コンストラクタに引数として渡される部分木の定義とともに定義に適した代理オブジェクトが作成されます。代理オブジェクトはインスタンス変数に保存され、適切なアクセサメソッドを使って名前から取り出されます。

公開クラスは`SuiteInfoBase'クラスが提供するアクセサより具体的で、必要とされるどんなアクセサでも提供します。しかし、実際の抽出アルゴリズムはコードブロックのすべての形式に対して共通のままです。高レベルの関数をソースファイルから完全な情報のセットを抽出するために使うことができます。(ファイル`example.py'を参照してください。)

     def get_docs(fileName):
         import os
         import parser
     
         source = open(fileName).read()
         basename = os.path.basename(os.path.splitext(fileName)[0])
         ast = parser.suite(source)
         return ModuleInfo(ast.totuple(), basename)

これはモジュールのドキュメンテーションに対する使いやすいインターフェイスです。この例のコードで抽出されない情報が必要な場合は、機能を追加するための明確に定義されたところで、コードを拡張することができます。


File: python-lib-jp.info,  Node: symbol,  Next: token,  Prev: parser,  Up: Python言語サービス

Python解析木と共に使われる定数
==============================

Constants representing internal nodes of the parse tree.

このモジュールは解析木の内部ノードの数値を表す定数を提供します。ほとんどのPython定数とは違い、これらは小文字の名前を使います。言語の文法のコンテキストにおける名前の定義については、Pythonディストリビューションのファイル`Grammar/Grammar'を参照してください。名前がマップする特定の数値はPythonのバージョン間で変わります。

このモジュールには、データオブジェクトも一つ付け加えられています:

`sym_name'
     ディクショナリはこのモジュールで定義されている定数の数値を名前の文字列へマップし、より人が読みやすいように解析木を表現します。

See also:
     *Note parser::
     `parser'モジュールの二番目の例で、`symbol'モジュールの使い方を示しています。


File: python-lib-jp.info,  Node: token,  Next: keyword,  Prev: symbol,  Up: Python言語サービス

Python解析木と共に使われる定数
==============================

Constants representing terminal nodes of the parse tree.

このモジュールは解析木の葉ノード(終端記号)の数値を表す定数を提供します。言語の文法のコンテキストにおける名前の定義については、Pythonディストリビューションのファイル`Grammar/Grammar'を参照してください。名前がマップする特定の数値は、Pythonのバージョン間で変わります。

このモジュールは一つのデータオブジェクトといくつかの関数も提供します。関数はPythonのCヘッダファイルの定義を反映します。

`tok_name'
     辞書はこのモジュールで定義されている定数の数値を名前の文字列へマップし、より人が読みやすいように解析木を表現します。

`ISTERMINAL(x)'
     終端トークンの値に対して真を返します。

`ISNONTERMINAL(x)'
     非終端トークンの値に対して真を返します。

`ISEOF(x)'
     Xが入力の終わりを示すマーカーならば、真を返します。

See also:
     *Note parser::
     `parser'モジュールの二番目の例で、`symbol'モジュールの使い方を示しています。


File: python-lib-jp.info,  Node: keyword,  Next: tokenize,  Prev: token,  Up: Python言語サービス

Pythonキーワードチェック
========================

文字列がPythonのキーワードか否かを調べます。

このモジュールでは、Pythonプログラムで文字列がキーワードか否かをチェック
する機能を提供します。

`iskeyword(s)'
     SがPythonのキーワードであれば真を返します。

`kwlist'
     インタープリタで定義している全てのキーワードのシーケンス。特定の
     `__future__'宣言がなければ有効ではないキーワードでもこのリストに
     は含まれます。


File: python-lib-jp.info,  Node: tokenize,  Next: tabnanny,  Prev: keyword,  Up: Python言語サービス

Pythonソースのためのトークナイザ
================================

Pythonソースコードのための字句解析器。

`tokenize'モジュールでは、Python で実装された Python
ソースコードの字句解析器を提供します。さらに、このモジュールの
字句解析器はコメントもトークンとして返します。このため、この
モジュールはスクリーン上で表示する際の色付け機能 (colorizers) を含む
"清書出力器 (pretty-printer)" を実装する上で便利です。

第一のエントリポイントはジェネレータです:

`generate_tokens(readline)'
     `generate_tokens()' ジェネレータは一つの引数READLINE
     を必要とします。この引数は呼び出し可能オブジェクトで、組み込みファイル
     オブジェクトにおける `readline()' メソッドと同じインタフェース
     を提供していなければなりません (~*Note ファイルオブジェクト::
     節を参照して
     ください)。この関数は呼び出しのたびに入力内の一行を文字列で返さなければ
     なりません。

     ジェネレータは 5 要素のタプルを返し、タプルは以下のメンバ:
     トークン型; トークン文字列;
     ソースコード中でトークンが始まる行と列を示す
     整数の2要素のタプル`(SROW, SCOL)'; ソースコード中で
     トークンが終わる行と列を示す整数の2要素のタプル `(SROW, SCOL)';
     そして、トークンが見つかった行、から
     なります。渡される行は_論理_行です; 連続する行は一行に含められ
     ます。 _Added in Python version 2.2_

後方互換性のために古いエントリポイントが残されています:

`tokenize(readline[, tokeneater])'
     `tokenize()'関数は二つのパラメータを取ります:
     一つは入力ストリームを表し、もう一つは`tokenize()'のための
     出力メカニズムを与えます。

     最初のパラメータ、READLINE は、組み込みファイルオブジェクト
     の`readline()'メソッドと同じインタフェイスを提供する呼び出し
     可能オブジェクトでなければなりません (~*Note
     ファイルオブジェクト:: 節を参照)。
     この関数は呼び出しのたびに入力内の一行を文字列で返さなければ
     なりません。

     二番目のパラメータTOKENEATERも呼び出し可能オブジェクトで
     なければなりません。この関数は各トークンに対して一度だけ呼び出され、
     `generate_tokens()' が生成するタプルに対応する 5 つの引数
     をとります。

`token' モジュールの全ての定数は`tokenize' でも
公開されており、これに加え、以下の二つのトークン値が `tokenize()' の
TOKENEATER 関数に渡される可能性があります:

`COMMENT'
     コメントであることを表すために使われるトークン値です。

`NL'
     終わりではない改行を表すために使われるトークン値。NEWLINEトークンは
     Pythonコードの論理行の終わりを表します。NLトークンはコードの論理行が
     複数の物理行にわたって続いているときに作られます。


File: python-lib-jp.info,  Node: tabnanny,  Next: pyclbr,  Prev: tokenize,  Up: Python言語サービス

あいまいなインデントの検出
==========================

ディレクトリツリー内のPythonのソースファイルで問題となる空白を検出するツール。

差し当たり、このモジュールはスクリプトとして呼び出すことを意図しています。しかし、IDE上にインポートして下で説明する関数`check()'を使うことができます。

_このモジュールが提供するAPIを将来のリリースで変更する確率が高いです。このような変更は後方互換性がないかもしれません。_

`check(file_or_dir)'
     FILE_OR_DIRがディレクトリであってシンボリックリンクでないときに、FILE_OR_DIRという名前のディレクトリツリーを再帰的に下って行き、この通り道に沿ってすべての`.py'ファイルを変更します。FILE_OR_DIRが通常のPythonソースファイルの場合には、問題のある空白をチェックします。診断メッセージはprint文を使って標準出力に書き込まれます。

`verbose'
     冗長なメッセージをプリントするかどうかを示すフラグ。スクリプトとして呼び出された場合は、`-v'オプションによって増加します。

`filename_only'
     問題のある空白を含むファイルのファイル名のみをプリントするかどうかを示すフラグ。スクリプトとして呼び出された場合は、`-q'オプションによって真に設定されます。

`NannyNag'
     あいまいなインデントを検出した場合に`tokeneater()'によって発生させられます。`check()'で捕捉され処理されます。

`tokeneater(type, token, start, end, line)'
     この関数は関数`tokenize.tokenize()'へのコールバックパラメータとして`check()'によって使われます。

See also:
     *Note tokenize:: Pythonソースコードの字句解析器。


File: python-lib-jp.info,  Node: pyclbr,  Next: py_compile,  Prev: tabnanny,  Up: Python言語サービス

Python クラスブラウザーサポート
===============================

Pythonクラスデスクリプタの情報抽出サポート

この`pyclbr'はモジュールで定義されたクラス、メソッド、および
トップレベルの関数について、限られた量の情報を定義するのに使われます。
このクラスによって提供される情報は、伝統的な 3 ペイン形式の
クラスブラウザーを実装するのに十分なだけの量になります。
情報はモジュールのインポートによらず、ソースコードから抽出します。
このため、このモジュールは信用できないソースコードに対して利用しても
安全です。この制限から、多くの標準モジュールやオプションの拡張
モジュールを含む、Python で実装されていないモジュールに対して
利用することはできません。

`readmodule(module[, path])'
     モジュールを読み込み、辞書マッピングクラスを返し、
     クラス記述オブジェクトに名前をつけます。
     パラメタMODULEはモジュール名を表す文字列でなくてはなりません;
     パッケージ内のモジュール名でもかまいません。 PATH
     パラメタは配列型でなくてはならず、 モジュールのソースコード
     がある場所を特定する際に `sys.path' の値に補完する形で使われます。

`readmodule_ex(module[, path])'
     `readmodule()' に似ていますが、返される辞書は、クラス名から
     クラス記述オブジェクトへの対応付けに加えて、トップレベル関数から
     関数記述オブジェクトへの対応付けも行っています。さらに、読み出し対象の
     モジュールがパッケージの場合、返される辞書はキー `'__path__''
     を持ち、その値はパッケージの検索パスが入ったリストになります。

* Menu:

* クラス記述オブジェクト::
* 関数記述オブジェクト Function Descriptor Object::


File: python-lib-jp.info,  Node: クラス記述オブジェクト,  Next: 関数記述オブジェクト Function Descriptor Object,  Prev: pyclbr,  Up: pyclbr

クラス記述オブジェクト
----------------------

クラス記述オブジェクトは、`readmodule()' や `readmodule()_ex'
が返す辞書の値として 使われており、以下のデータメンバを提供しています。

`module'
     クラス記述オブジェクトが記述している対象のクラスを定義している
     モジュールの名前です。

`name'
     クラスの名前です。

`super'
     クラス記述オブジェクトが記述しようとしている対象クラスの、直接の基底
     クラス群について記述しているクラス記述オブジェクトのリストです。
     スーパクラスとして挙げられているが `readmodule()' が見つけ
     られなかったクラスは、クラス記述オブジェクトではなくクラス名として
     リストに挙げられます。

`methods'
     メソッド名を行番号に対応付ける辞書です。

`file'
     クラスを定義している `class' 文が入っているファイルの名前です。

`lineno'
     `file' で指定されたファイル内にある `class' 文の数です。


File: python-lib-jp.info,  Node: 関数記述オブジェクト Function Descriptor Object,  Prev: クラス記述オブジェクト,  Up: pyclbr

関数記述オブジェクト (Function Descriptor Object)
-------------------------------------------------

`readmodule_ex()' の返す辞書内でキーに対応する値として使われて
いる関数記述オブジェクトは、以下のデータメンバを提供しています:

`module'
     関数記述オブジェクトが記述している対象の関数を定義している
     モジュールの名前です。

`name'
     関数の名前です。

`file'
     関数を定義してる `def' 文が入っているファイルの名前です。

`lineno'
     `file' で指定されたファイル内にある `def' 文の数です。


File: python-lib-jp.info,  Node: py_compile,  Next: compileall,  Prev: pyclbr,  Up: Python言語サービス

Pythonソースファイルのコンパイル
================================

Pythonソースファイルをバイトコードファイルへコンパイル。

`py_compile'モジュールには、ソースファイルからバイトコードファイ
ルを作る関数と、モジュールのソースファイルがスクリプトとして呼び出される
時に使用される関数が定義されています。

頻繁に必要となるわけではありませんが、共有ライブラリとしてモジュールをイ
ンストールする場合や、特にソースコードのあるディレクトリにバイトコードの
キャッシュファイルを書き込む権限がないユーザがいるときには、この関数は役
に立ちます。

`PyCompileError'
     ファイルをコンパイル中にエラーが発生すると、PyCompileError例外が送出されます。

`compile(file[, cfile[, dfile[, doraise]]])'
     ソースファイルをバイトコードにコンパイルして、バイトコードのキャッシュ
     ファイルに書き出します。 ソースコードはファイル名FILEで渡します。
     バイトコードはファイルCFILEに書き込まれ、デフォルトではFILE `+'
     `'c''（使用しているインタープリタで最適化が可能なら `'o''）です。
     もしDFILEが指定されたら、FILEの代わりにソースファイルの名前
     としてエラーメッセージの中で使われます。 DORAISE =
     Trueの場合、コンパイル中にエラーが発生するとPyCompileError
     を送出します。DORAISE = Falseの場合(デフォルト)はエラーメッセージは
     sys.stderrに出力し、例外は送出しません。

`main([args])'
     いくつか複数のソースファイルをコンパイルします。
     ARGSで（あるいはARGSで指定されなかったらコマンドラインで）指
     定されたファイルをコンパイルし、できたバイトコードを通常の方法で保存しま
     す。
     この関数はソースファイルの存在するディレクトリを検索しません；指定された
     ファイルをコンパイルするだけです。

このモジュールがスクリプトとして実行されると、`main()'がコマン
ドラインで指定されたファイルを全てコンパイルします。

See also:
     *Note compileall::
     ディレクトリツリー内のPythonソースファイルを全てコンパイルするライブラリ。


File: python-lib-jp.info,  Node: compileall,  Next: dis,  Prev: py_compile,  Up: Python言語サービス

Pythonライブラリをバイトコンパイル
==================================

ディレクトリに含まれるPythonソースファイルを、一括してバイトコンパイルします。

このモジュールは、指定したディレクトリに含まれるPythonソースをコンパイル
する関数を定義しています。Pythonライブラリをインストールする時、ソースフ
ァイルを事前にコンパイルしておく事により、ライブラリのインストール先ディ
レクトリに書き込み権限をもたないユーザでもキャッシュされたバイトコードフ
ァイルを利用する事ができるようになります。

このモジュールのソースコードは、Pytonソースファイルをコンパイルするスク
リプトとしても利用する事ができます。コンパイルするディレクトリは、
`sys.path'で指定されたディレクトリ、またはコマンドラインで指定され
たディレクトリとなります。

`compile_dir(dir[, maxlevels[, ddir[, force[,  rx[, quiet]]]]])'
     DIRで指定されたディレクトリを再帰的に下降し、見つかった
     `.py'を全てコンパイルします。MAXLEVELSは、下降する最大の深
     さ（デフォルトは`10'）を指定します。DDIRには、エラーメッ
     セージで使用されるファイル名の、親ディレクトリ名を指定する事ができま
     す。FORCEが真の場合、モジュールはファイルの更新日付に関わりなく
     再コンパイルされます。

     RXには、検索対象から除外するファイル名の正規表現式を指定します。
     絶対パス名をこの正規表現で`search'し、一致した場合にはコンパイル
     対象から除外します。

     QUIETが真の場合、通常処理では標準出力に何も表示しません。


`compile_path([skip_curdir[, maxlevels[, force]]])'
     `sys.path'に含まれる、全ての`.py'ファイルをバイトコンパイル
     します。SKIP_CURDIRが真（デフォルト）の時、カレントディレクトリ
     は検索されません。MAXLEVELSとFORCEはデフォルトでは`0'
     で、`compile_dir()'に渡されます。


See also:
     *Note py_compile:: Byte-compile a single source file.


File: python-lib-jp.info,  Node: dis,  Next: distutils,  Prev: compileall,  Up: Python言語サービス

Pythonバイトコードの逆アセンブラ
================================

Pythonバイトコードの逆アセンブラ。

`dis'モジュールはPythonバイトコードを逆アセンブルしてバイトコードの解析を助けます。Pythonアセンブラがないため、このモジュールがPythonアセンブリ言語を定義しています。このモジュールが入力として受け取るPythonバイトコードはファイル`Include/opcode.h'に定義されており、コンパイラとインタプリタが使用しています。

例: 関数`myfunc'を考えると:

     def myfunc(alist):
         return len(alist)

次のコマンドを`myfunc()'の逆アセンブリを得るために使うことができます:

     >>> dis.dis(myfunc)
       2           0 LOAD_GLOBAL              0 (len)
                   3 LOAD_FAST                0 (alist)
                   6 CALL_FUNCTION            1
                   9 RETURN_VALUE
                  10 LOAD_CONST               0 (None)
                  13 RETURN_VALUE

("2"は行番号です)。

`dis'モジュールは次の関数と定数を定義します:

`dis([bytesource])'
     BYTESOURCEオブジェクトを逆アセンブルします。BYTESOURCEはモジュール、クラス、関数、あるいはコードオブジェクトのいずれかを示します。モジュールに対しては、すべての関数を逆アセンブルします。クラスに対しては、すべてのメソッドを逆アセンブルします。単一のコードシーケンスに対しては、バイトコード命令ごとに一行をプリントします。オブジェクトが与えられない場合は、最後のトレースバックを逆アセンブルします。

`distb([tb])'
     トレースバックのスタックの先頭の関数を逆アセンブルします。Noneが渡された場合は最後のトレースバックを使います。例外を引き起こした命令が表示されます。

`disassemble(code[, lasti])'
     コードオブジェクトを逆アセンブルします。LASTIが与えられた場合は、最後の命令を示します。出力は次のようなカラムに分割されます:

       1. 各行の最初の命令に対する行番号。

       2. 現在の命令。`-`-'>'として示されます。

       3. ラベル付けされた命令。`>`>''とともに表示されます。

       4. the address of the instruction,

       5. 命令のアドレス。

       6. 演算コード名。

       7. 演算パラメータ。

       8. 括弧の中のパラメータのインタプリテーション。

     パラメータインタープリテーションはローカルおよびグルーバル変数名、定数値、分岐目標、そして比較演算子を認識します。

`disco(code[, lasti])'
     disassembleの別名。よりタイプしやすく、以前のPythonリリースと互換性があります。

`opname'
     演算名。一連のバイトコードを使ってインデキシングできます。

`cmp_op'
     すべての比較演算名。

`hasconst'
     定数腹メータを持つ一連のバイトコード。

`hasfree'
     自由変数にアクセスする一連のバイトコード。

`hasname'
     名前によって属性にアクセスする一連のバイトコード。

`hasjrel'
     相対ジャンプターゲットをもつ一連のバイトコード。

`hasjabs'
     絶対ジャンプターゲットをもつ一連のバイトコード。

`haslocal'
     ローカル変数にアクセスする一連のバイトコード。

`hascompare'
     ブール演算の一連のバイトコード。

* Menu:

* Pythonバイトコード命令::

