This is python-lib-jp.info, produced by makeinfo version 4.5 from
python-lib-jp.texi.

12 October 2005


File: python-lib-jp.info,  Node: sys,  Next: gc,  Prev: Python ランタイム サービス,  Up: Python ランタイム サービス

システムパラメータと関数
========================

システムパラメータと関数へのアクセス

このモジュールでは、インタープリタで使用・管理している変数や、インタープ
リタの動作に深く関連する関数を定義しています。このモジュールは常に利用可能で
す。

`argv'
     Pythonスクリプトに渡されたコマンドライン引数のリスト。`argv[0]'は
     スクリプトの名前となりますが、フルパス名かどうかは、オペレーティングシ
     ステムによって異なります。コマンドライン引数に`-c'を付けて
     Pythonを起動した場合、`argv[0]'は文字列`'-c''となります。引
     数なしでPythonを起動した場合、`argv'は長さ0のリストになります。

`byteorder'
     プラットフォームのバイト順を示します。ビッグエンディアン(最上位バ
     イトが先頭)のプラットフォームでは`'big''、リトルエンディアン(最下
     位バイトが先頭)では`'little''となります。 _Added in Python version
     2.0_

`builtin_module_names'
     コンパイル時にPythonインタープリタに組み込まれた、全てのモジュール名の
     タプル(この情報は、他の手段では取得することができません。
     `modules.keys()'は、インポートされたモジュールのみのリストを返し
     ます。)

`copyright'
     Pythonインタープリタの著作権を表示する文字列。

`dllhandle'
     Python DLLのハンドルを示す整数。 利用可能: Windows

`displayhook(VALUE)'
     VALUEが`None'以外の場合、`value'を`sys.stdout'に
     出力して`__builtin__._'に保存します。

     `sys.displayhook'は、Pythonの対話セッションで入力された式が評価さ
     れたときに呼び出されます。対話セッションの出力をカスタマイズする場合、
     `sys.displayhook'に引数の数が一つの関数を指定します。

`excepthook(TYPE, VALUE, TRACEBACK)'
     指定したトレースバックと例外を`sys.stderr'に出力します。

     例外が発生し、その例外が捕捉されない場合、インタープリタは例外クラス・
     例外インスタンス・トレースバックオブジェクトを引数として
     `sys.excepthook'を呼び出します。対話セッション中に発生した場合は
     プロンプトに戻る直前に呼び出され、Pythonプログラムの実行中に発生した場合
     はプログラムの終了直前に呼び出されます。このトップレベルでの例外情報出
     力処理をカスタマイズする場合、`sys.excepthook'に引数の数が三つの
     関数を指定します。

`__displayhook__'

`__excepthook__'
     それぞれ、起動時の`displayhook'と`excepthook'の値を保存して
     います。この値は、`displayhook'と`excepthook'に不正なオブジ
     ェクトが指定された場合に、元の値に復旧するために使用します。

`exc_info()'
     この関数は、現在処理中の例外を示す三つの値のタプルを返します。この値
     は、現在のスレッド・現在のスタックフレームのものです。現在のスタックフ
     レームが例外処理中でない場合、例外処理中のスタックフレームが見つかるま
     で次々とその呼び出し元スタックフレームを調べます。ここで、"例外処理中
     "とは"except節を実行中、または実行した"フレームを指します。どのスタ
     ックフレームでも、最後に処理した例外の情報のみを参照することができま
     す。

     スタック上で例外が発生していない場合、三つの`None'のタプルを返し
     ます。例外が発生している場合、`(TYPE, VALUE,
     TRACEBACK)'を返します。TYPEは、処理中の例外の型を示します
     (クラスオブジェクト)。VALUEは、例外パラメータ
     (例外に"関連する値"または`raise'の第二引数。TYPEが
     クラスオブジェクトの場合は常にクラスインスタンス)です。TRACEBACK
     は、トレースバックオブジェクトで、例外が発生した時点でのコールスタック
     をカプセル化したオブジェクトです(リファレンスマニュアル参照)。

     `exc_clear()'が呼び出されると、現在のスレッドで他の例外が発生するか、
     又は別の例外を処理中のフレームに実行スタックが復帰するまで、
     `exc_info()'は三つの`None'を返します。

     _例外処理中に戻り値のTRACEBACKをローカル変数に代入すると
     循環参照が発生し、関数内のローカル変数やトレースバックが参照している全
     てのオブジェクトは解放されなくなります。特にトレースバック情報が必要で
     はなければ`exctype, value = sys.exc_info()[:2]'のように例外型と例
     外オブジェクトのみを取得するようにして下さい。もしトレースバックが必要
     な場合には、処理終了後にdeleteして下さい。このdeleteは、`try' ...
     `finally' ...で行うと良いでしょう。_ _Note:_ Python 2.2
     以降では、ガベージコレクションが有効であればこのような
     到達不能オブジェクトは自動的に削除されます。しかし、循環参照を作らない
     ようにしたほうが効率的です。

`exc_clear()'
     この関数は、現在のスレッドで処理中、又は最後に発生した例外の情報を全てクリア
     します。この関数を呼び出すと、現在のスレッドで他の例外が発生するか、
     又は別の例外を処理中のフレームに実行スタックが復帰するまで、
     `exc_info()'は三つの`None'を返します。

     この関数が必要となることは滅多にありません。ロギングやエラー処理などで最後に
     発生したエラーの報告を行う場合などに使用します。また、リソースを解放して
     オブジェクトの終了処理を起動するために使用することもできますが、オブジェクト
     が実際にされるかどうかは保障の限りではありません。 _Added in
     Python version 2.3_

`exc_type'

`exc_value'

`exc_traceback'
     _This is deprecated in Python 1.5.  `exc_info()'を使用してください_
     これらの変数はグローバル変数なのでスレッド毎の情報を示すことができませ
     ん。この為、マルチスレッドなプログラムでは安全に参照することはできませ
     ん。例外処理中でない場合、`exc_type'の値は`None'となり、
     `exc_value'と`exc_traceback'は未定義となります。

`exec_prefix'
     Pythonのプラットフォーム依存なファイルがインストールされているディレク
     トリ名(サイト固有)。デフォルトでは、この値は`'/usr/local''です
     が、ビルド時に`configure'の`--exec-prefix'引数で
     指定することができます。全ての設定ファイル(`pyconfig.h'など)は
     `exec_prefix + '/lib/pythonVERSION/config''に、共有ライブラ
     リは`exec_prefix + '/lib/pythonVERSION/lib-dynload''にイン
     ストールされます(但しVERSIONは`version[:3]')。


`executable'
     Pythonインタープリタの実行ファイルの名前を示す文字列。このような名前が
     意味を持つシステムでは利用可能。

`exit([arg])'
     Pythonを終了します。`exit()'は`SystemExit'を送出す
     るので、`try'ステートメントの`finally'節に終了処理を記
     述したり、上位レベルで例外を捕捉してexit処理を中断したりすることができ
     ます。オプション引数ARGには、終了ステータスとして整数(デフォルト
     は0）または整数以外の型のオブジェクトを指定することができます。整数を
     指定した場合、シェル等は0は"正常終了"、0以外の整数を"異常終了"とし
     て扱います。多くのシステムでは、有効な終了ステータスは0-127で、これ以
     外の値を返した場合の動作は未定義です。システムによっては特定の終了コー
     ドに個別の意味を持たせている場合がありますが、このような定義は僅かしか
     ありません。UNIXプログラムでは文法エラーの場合には2を、それ以外のエ
     ラーならば1を返します。ARGにNONEを指定した場合は、数値の0
     を指定した場合と同じです。それ以外のオブジェクトを指定すると、そのオブ
     ジェクトが`sys.stderr'に出力され、終了コードをして1を返します。エ
     ラー発生時には`sys.exit("エラーメッセージ")'と書くと、簡単にプロ
     グラムを終了することができます。

`exitfunc'
     この値はモジュールに存在しませんが、ユーザプログラムでプログラム終了時
     に呼び出される終了処理関数として、引数の数が0の関数を設定することがで
     きます。この関数は、インタープリタ終了時に呼び出されます。
     `exitfunc'に指定することができる終了処理関数は一つだけですので、
     複数のクリーンアップ処理が必要な場合は`atexit'モジュールを使
     用してください。 _Note:_
     終了処理関数は、以下の場合には呼び出されません。シグナルでkillされ
     た場合・Python内部でfatail
     エラーが発生した場合・`os._exit()'が呼び 出された場合

`getcheckinterval()'
     インタプリタの "チェックインターバル (check interval)" を
     返します; `setcheckinterval()' を参照してください。 _Added in
     Python version 2.3_

`getdefaultencoding()'
     現在のUnicode処理のデフォルトエンコーディング名を返します。 _Added
     in Python version 2.0_

`getdlopenflags()'
     `dlopen()'で指定されるフラグを返します。このフラグは
     `dl'と`DLFCN'で定義されています。

     利用可能: UNIX.  _Added in Python version 2.2_

`getfilesystemencoding()'
     Unicodeファイル名をシステムのファイル名に変換する際に使用する
     エンコード名を返します。システムのデフォルトエンコーディングを使用する
     場合には`None'を返します。
        * Windows 9xでは、エンコーディングは "mbcs" となります。

        * OS Xでは、エンコーディングは "utf-8" となります。

        *
          Unixでは、エンコーディングはユーザのnl_langinfo(CODESET)の設定となります。
          nl_langinfo(CODESET)が失敗すると`None'を返します。

        * Windows
          NT+では、Unicodeをファイル名として使用することができるので
          変換の必要がありません。

     _Added in Python version 2.3_

`getrefcount(object)'
     OBJECTの参照数を返します。OBJECTは(一時的に)
     `getrefcount()'からも参照されるため、参照数は予想される数
     よりも1多くなります。

`getrecursionlimit()'
     現在の最大再帰数を返します。最大再帰数は、Pythonインタープリタスタック
     の最大の深さです。この制限はPythonプログラムが無限に再帰し、Cスタック
     がオーバーフローしてクラッシュすることを防止するために設けられていま
     す。この値は`setrecursionlimit()'で指定することができます。

`_getframe([depth])'
     コールスタックからフレームオブジェクトを取得します。オプション引数
     DEPTHを指定すると、スタックのトップからDEPTHだけ下のフレー
     ムオブジェクトを取得します。DEPTHがコールスタックよりも深けれ
     ば、`ValueError'が発生します。DEPTHのデフォルト値は0
     で、この場合はコールスタックのトップのフレームを返します。

     この関数は、内部的な、特殊な用途にのみ利用することができます。

`getwindowsversion()'
     実行中のWindowsのバージョンを示す、以下の値のタプルを返します：
     MAJOR, MINOR, BUILD, PLATFORM, TEXT。
     TEXTは文字列、それ以外の値は整数です。

     PLATFORMは、以下の値となります:

    `0 (`VER_PLATFORM_WIN32s')'
          Win32s on Windows 3.1.

    `1 (`VER_PLATFORM_WIN32_WINDOWS')'
          Windows 95/98/ME

    `2 (`VER_PLATFORM_WIN32_NT')'
          Windows NT/2000/XP

    `3 (`VER_PLATFORM_WIN32_CE')'
          Windows CE.

     この関数は、Win32 `GetVersionEx()'関数を呼び出します。詳細は
     マイクロソフトのドキュメントを参照してください。

     利用可能: Windows.  _Added in Python version 2.3_

`hexversion'
     整数にエンコードされたバージョン番号。この値は新バージョン(正規リリー
     ス以外であっても)ごとにかならず増加します。例えば、Python
     1.5.2以降で
     のみ動作するプログラムでは、以下のようなチェックを行います。

          if sys.hexversion >= 0x010502F0:
              # use some advanced feature
              ...
          else:
              # use an alternative implementation or warn the user
              ...

     `hexversion'は`hex()'で16進数に変換しなければ値の意味が
     わかりません。より読みやすいバージョン番号が必要な場合には
     `version_info'を使用してください。 _Added in Python version 1.5.2_

`last_type'

`last_value'

`last_traceback'
     通常は定義されておらず、捕捉されない例外が発生してインタープリタがエ
     ラーメッセージとトレースバックを出力した場合にのみ設定されます。この値
     は、対話セッション中にエラーが発生したとき、デバッグモジュールをロード
     (例:`import pdb; pdb.pm()'など。詳細は*Note
     Pythonデバッガ::を参照)して発
     生したエラーを調査する場合に利用します。デバッガをロードすると、プログ
     ラムを再実行せずに情報を取得することができます。

     変数の意味は、上の`exc_info()'の戻り値と同じです。対話セッシ
     ョンを実行するスレッドは常に一つだけなので、`exc_type'のようにス
     レッドに関する問題は発生しません。

`maxint'
     Pythonの整数型でサポートされる、最大の整数。この値は最低でも2**31-1で
     す。最大の負数は`-maxint-1'となります。正負の最大数が非対称です
     が、これは2の補数計算を行うためです。

`maxunicode'
     Unicode文字の最大のコードポイントを示す整数。この値は、オプション設定
     でUnicode文字の保存形式としてUSC-2とUCS-4のいずれを指定したかによって
     異なります。

`modules'
     ロード済みモジュールのモジュール名とモジュールオブジェクトの辞書。強制
     的にモジュールを再読み込みする場合などに使用します。この辞書からモジ
     ュールを削除するのは、`reload()' の呼び出
     しと等価では_ありません_。

`path'
     モジュールを検索するパスを示す文字列のリスト。`PYTHONPATH'環境
     変数と、インストール時に指定したデフォルトパスで初期化されます。

     開始時に初期化された後、リストの先頭(`path[0]')にはPythonインター
     プリタを起動するために指定したスクリプトのディレクトリが挿入されます。
     スクリプトのディレクトリがない(インタープリタで対話セッションで起
     動された時や、スクリプトを標準入力から読み込む場合など)場合、
     `path[0]'には空文字列となり、Pythonはカレントディレクトリからモジ
     ュールの検索を開始します。スクリプトディレクトリは、
     `PYTHONPATH'で指定したディレクトリの_前_に挿入されますので
     注意が必要です。

     必要に応じて、プログラム内で自由に変更することができます。

     _Changed in Python version 2.3_

`platform'
     プラットフォームを識別する文字列(例: `'sunos5'', `'linux1''
     等)。`path'にプラットフォーム別のサブディレクトリを追加する場
     合などに利用します。

`prefix'
     サイト固有の、プラットフォームに依存しないファイルを格納するディレクト
     リを示す文字列。デフォルトでは`'/usr/local''になります。この値は
     ビルド時に`configure'スクリプトの`--prefix'引数で
     指定する事ができます。Pythonライブラリの主要部分は `prefix +
     '/lib/pythonVERSION''にインストールされ、プラット
     フォーム非依存なヘッダファイル(`pyconfig.h'以外)は `prefix +
     '/include/pythonVERSION''に格納されます
     (但しVERSIONは`version[:3]')。

`ps1'

`ps2'
     インタープリタの一次プロンプト、二次プロンプトを指定する文字列。対話
     モードで実行中のみ定義され、初期値は`'>`>'> ''と `'...
     ''です。文字列以外のオブジェクトを指定した場合、インタープ
     リタが対話コマンドを読み込むごとにオブジェクトの`str()'を評価
     します。この機能は、動的に変化するプロンプトを実装する場合に利用しま
     す。

`setcheckinterval(interval)'
     インタープリタの"チェック間隔"を示す整数値を指定します。この値はスレ
     ッドスイッチやシグナルハンドラのチェックを行う周期を決定します。デフォ
     ルト値は`100'で、この場合 100
     の仮想命令を実行するとチェックを行いま
     す。この値を大きくすればスレッドを利用するプログラムのパフォーマンスが
     向上します。この値が`<=0'以下の場合、全ての仮想命令を実行するたび
     にチェックを行い、レスポンス速度と最大になりますがオーバヘッドもまた最
     大となります。

`setdefaultencoding(name)'
     現在のUnicode処理のデフォルトエンコーディング名を設定します。
     NAMEに一致するエンコーディングが見つからない場合、
     `LookupError'が発生します。この関数は、`site'モジ
     ュールの実装が、`sitecustomize'モジュールから使用するためだけに
     定義されています。`site'から呼び出された後、この関数は
     `sys'から削除されます。 _Added in Python version 2.0_

`setdlopenflags(n)'
     インタープリタが拡張モジュールをロードする時、`dlopen()'で使
     用するフラグを設定します。`sys.setdlopenflags(0)'とすれば、モジ
     ュールインポート時にシンボルの遅延解決を行う事ができます。シンボルを拡
     張モジュール間で共有する場合には、 `sys.setdlopenflags(dl.RTLD_NOW
     | dl.RTLD_GLOBAL)'と指定します。
     フラグの定義名は`dl'か`DLFCN'で定義されています。
     `DLFCN'が存在しない場合、`h2py'スクリプトを使って
     `/usr/include/dlfcn.h'から生成することができます。

     利用可能: UNIX.  _Added in Python version 2.2_

`setprofile(profilefunc)'
     システムのプロファイル関数を登録します。プロファイル関数は、
     Pythonのソースコードプロファイルを行う関数で、Pythonで記述する
     ことができます。  詳細は*Note
     リファレンス・マニュアル::を参照してく
     ださい。プロファイル関数はトレース関数(`settrace()'参照)と
     似ていますが、ソース行が実行されるごとに呼び出されるのではなく、関数の
     呼出しと復帰時のみ呼び出されます(例外が発生している場合でも、復帰時の
     イベントは発生します)。プロファイル関数はスレッド毎に設定することがで
     きますが、プロファイラはスレッド間のコンテキスト切り替えを検出すること
     はできません。従って、マルチスレッド環境でのプロファイルはあまり意味が
     ありません。`setprofile'は常に`None'を返します。

`setrecursionlimit(limit)'
     Pythonインタープリタの、スタックの最大の深さをLIMITに設定しま
     す。この制限はPythonプログラムが無限に再帰し、Cスタックがオーバーフ
     ローしてクラッシュすることを防止するために設けられています。

     LIMITの最大値はプラットフォームによって異なります。深い再帰処理
     が必要な場合にはプラットフォームがサポートしている範囲内でより大きな値
     を指定することができますが、この値が大きすぎればクラッシュするので注意
     が必要です。

`settrace(tracefunc)'
     システムのトレース関数を登録します。トレース関数
     はPythonのソースデバッガを実装するために使用することができます。
     *Note どのように動作しているか::の"How It
     Works,"を参照してください。
     トレース関数はスレッド毎に設定することができますの
     で、デバッグを行う全てのスレッドで`settrace()'を呼び出し、ト
     レース関数を登録してください。

`stdin'

`stdout'

`stderr'
     インタープリタの標準入力・標準出力・標準エラー出力に対応するファイルオ
     ブジェクト。`stdin'はスクリプトの読み込みを除く全ての入力処理で使
     用され、`input()' や`raw_input()'
     も`stdin'から読み込みます。`stdout'
     は、`print'や式の評価結果、`input()'・
     `raw_input()'のプロンプトの出力先となります。インタープリタの
     プロンプトは(ほとんど)`stderr'に出力されます。`stdout'と
     `stderr'は必ずしも組み込みのファイルオブジェクトである必要はな
     く、`write()'メソッドを持つオブジェクトであれば使用することがで
     きます。`stdout'と`stderr'を別のオブジェクトに置き換えても、
     `os.popen()'・`os.system()' ・`os'の
     `exec*()'などから起動されたプロセスが使用する標準I/Oストリー
     ムは変更されません。

`__stdin__'

`__stdout__'

`__stderr__'
     それぞれ起動時の`stdin'・`stderr'・`stdout'の値を保存し
     ます。終了処理時や、不正なオブジェクトが指定された場合に元の値に復旧す
     るために使用します。

`tracebacklimit'
     捕捉されない例外が発生した時、出力されるトレースバック情報の最大レベル
     数を指定する整数値(デフォルト値は`1000')。`0'以下の値が設定
     された場合、トレースバック情報は出力されず例外型と例外値のみが出力さ
     れます。

`version'
     Pythonインタープリタのバージョンとビルド番号・使用コンパイラなどの情
     報を示す文字列で、`'バージョン(#ビルド番号, ビルド日付,
     ビルド時間)[コンパイラ]''となります。先
     頭の三文字は、バージョンごとのインストール先ディレクトリ内を識別するた
     めに使用されます。例:

          >>> import sys
          >>> sys.version
          '1.5.2 (#0 Apr 13 1999, 10:51:12) [MSC 32 bit (Intel)]'


`api_version'
     使用中のインタープリタのC
     APIバージョン。Pythonと拡張モジュール間の不
     整合をデバッグする場合などに利用できます。_Added in Python version
     2.3_

`version_info'
     バージョン番号を示す５つの値のタプル:MAJOR, MINOR, MICRO,
     RELEASELEVEL, SERIAL RELEASELEVEL以外は
     全て整数です。RELEASELEVELの値は、`'alpha'', `'beta'',
     `'candidate'', or `'final''の何れかです。Python 2.0の
     `version_info'は、`(2, 0, 0, 'final', 0)'となります。 _Added in
     Python version 2.0_

`warnoptions'
     この値は、warnings
     framework内部のみ使用され、変更することはできませ
     ん。詳細は`warnings'を参照してください。

`winver'
     Windowsプラットフォームで、レジストリのキーとなるバージョン番号。
     Python DLLの文字列リソース 1000に設定されています。通常、この値は
     `version'の先頭三文字となります。この値は参照専用で、別の値を
     設定してもPythonが使用するレジストリキーを変更することはできません。
     利用可能: Windows.

See also:
     *Note site:: This describes how to use .pth files to extend
     `sys.path'.



File: python-lib-jp.info,  Node: gc,  Next: weakref,  Prev: sys,  Up: Python ランタイム サービス

ガベージコレクタ インターフェース
=================================

循環検出ガベージコレクタのインターフェース。

`gc'モジュールは、インタプリタのビルドオプションで循環ガベージコ
レクタを有効にした場合のみ使用することができます（デフォルトで有効）。も
し無効になっている場合にこのモジュールをインポートすると、
`ImportError'が発生します。

このモジュールは、循環ガベージコレクタの無効化・検出頻度の調整・デバッグ
オブションの設定などを行うインターフェースを提供します。また、検出した到
達不能オブジェクトのうち、解放する事ができないオブジェクトを参照する事も
できます。循環ガベージコレクタはPyhonの参照カウントを補うためのものです
ので、もしプログラム中で循環参照が発生しない事が明らかな場合には検出をす
る必要はありません。自動検出は、`gc.disable()'で停止する事ができま
す。メモリリークをデバッグするときには、
`gc.set_debug(gc.DEBUG_LEAK)'とします。

`gc'モジュールは、以下の関数を提供しています。

`enable()'
     自動ガベージコレクションを有効にします。

`disable()'
     自動ガベージコレクションを無効にします。

`isenabled()'
     自動ガベージコレクションが有効なら真を返します。

`collect()'
     全ての検出を行います。全ての世代を検査し、検出した到達不可オブジェクトの
     数を返します。

`set_debug(flags)'
     ガベージコレクションのデバッグフラグを設定します。デバッグ情報は
     `sys.stderr'に出力されます。デバッグフラグは、下の値の組み合わせ
     を指定する事ができます。

`get_debug()'
     現在のデバッグフラグを返します。

`get_objects()'
     現在、追跡しているオブジェクトのリストを返します。このリストには、戻り値
     のリスト自身は含まれていません。 _Added in Python version 2.2_

`set_threshold(threshold0[, threshold1[, threshold2]])'
     ガベージコレクションの閾値（検出頻度）を指定します。THRESHOLD0を0
     にすると、検出は行われません。

     GCは、オブジェクトを、走査された回数に従って3世代に分類します。新しいオ
     ブジェクトは最も若い（`0'世代）に分類されます。もし、そのオブジェク
     トがガベージコレクションで削除されなければ、次に古い世代に分類されます。
     もっとも古い世代は`2'世代で、この世代に属するオブジェクトは他の世代
     に移動しません。ガベージコレクタは、最後に検出を行ってから生成・削除した
     オブジェクトの数をカウントしており、この数によって検出を開始します。オブ
     ジェクトの生成数 - 削除数 がTHRESHOLD0より大きくなると、検出を開始
     します。最初は`0'世代のオブジェクトのみが検査されます。`0'世代
     の検査が`threshold1'回実行されると、`1'世代のオブジェクトの検
     査を行います。同様に、`1'世代が`threshold2'回検査されると、
     `2'世代の検査を行います。

`get_threshold()'
     現在の検出閾値を、`(THRESHOLD0, THRESHOLD1,
     THRESHOLD2)'のタプルで返します。

`get_referrers(*objs)'
     objsで指定したオブジェクトのいずれかを参照しているオブジェクトのリストを
     返します。この関数では、ガベージコレクションをサポートしているコンテナの
     みを返します。他のオブジェクトを参照していても、ガベージコレクションをサ
     ポートしていない拡張型は含まれません。

     尚、戻り値のリストには、すでに参照されなくなっているが、循環参照の一部で
     まだガベージコレクションで回収されていないオブジェクトも含まれるので注意
     が必要です。有効なオブジェクトのみを取得する場合、
     `get_referrers()'の前に`collect()'を呼び出してくださ い。 _Added
     in Python version 2.2_

`get_referents(*objs)'
     引数で指定したオブジェクトのいずれかから参照されている、全てのオブジェクト
     のリストを返します。参照先のオブジェクトは、引数で指定したオブジェクトの
     Cレベルメソッド`tp_traverse'で取得し、全てのオブジェクトが直接到達
     可能な全てのオブジェクトを返すわけではありません。`tp_traverse'は
     ガベージコレクションをサポートするオブジェクトのみが実装しており、ここで
     取得できるオブジェクトは循環参照の一部となる可能性のあるオブジェクトのみ
     です。従って、例えば整数オブジェクトが直接到達可能であっても、このオブジェクトは
     戻り値には含まれません。 _Added in Python version 2.3_

以下の変数は読み込み専用です。(変更することはできますが、再バインドする
事はできません。）

`garbage'
     到達不能であることが検出されたが、解放する事ができないオブジェクトのリス
     ト（回収不能オブジェクト）。デフォルトでは、`__del__()'メソッドを
     持つオブジェクトのみが格納されます。 (1)

     `__del__()'メソッドを持つオブジェクトが循環参照に含まれている場
     合、その循環参照全体と、循環参照からのみ到達する事ができるオブジェクトは
     回収不能となります。このような場合には、Pythonは安全に`__del__()'
     を呼び出す順番を決定する事ができないため、自動的に解放することはできませ
     ん。もし安全な解放順序がわかるのであれば、GARBAGEリストを参照して
     循環参照を破壊する事ができます。循環参照を破壊した後でも、そのオブジェク
     トはGARBAGEリストから参照されているため、解放されません。解放する
     ためには、循環参照を破壊した後、`del gc.garbage[:]'のように
     GARBAGEからオブジェクトを削除する必要があります。一般的には
     `__del__()'を持つオブジェクトが循環参照の一部とはならないように配
     慮し、GARBAGEはそのような循環参照が発生していない事を確認するため
     に利用する方が良いでしょう。

     `DEBUG_SAVEALL'が設定されている場合、全ての到達不能オブジェクト
     は解放されずにこのリストに格納されます。

以下は`set_debug()'に指定することのできる定数です。

`DEBUG_STATS'
     検出中に統計情報を出力します。この情報は、検出頻度を最適化する際に有益で
     す。

`DEBUG_COLLECTABLE'
     見つかった回収可能オブジェクトの情報を出力します。

`DEBUG_UNCOLLECTABLE'
     見つかった回収不能オブジェクト（到達不能だが、ガベージコレクションで解放
     する事ができないオブジェクト）の情報を出力します。回収不能オブジェクト
     は、`garbade'リストに追加されます。

`DEBUG_INSTANCES'
     `DEBUG_COLLECTABLE'か`DEBUG_UNCOLLECTABLE'が設定されて
     いる場合、見つかったインスタンスオブジェクトの情報を出力します。

`DEBUG_OBJECTS'
     `DEBUG_COLLECTABLE'か`DEBUG_UNCOLLECTABLE'が設定されて
     いる場合、見つかったインスタンスオブジェクト以外のオブジェクトの情報を出
     力します。

`DEBUG_SAVEALL'
     設定されている場合、全ての到達不能オブジェクトは解放されずに
     GARBAGEに追加されます。これはプログラムのメモリリークをデバッグす
     るときに便利です。

`DEBUG_LEAK'
     プログラムのメモリリークをデバッグするときに指定します。
     （`DEBUG_COLLECTABLE | DEBUG_UNCOLLECTABLE | DEBUG_INSTANCES |
     DEBUG_OBJECTS | DEBUG_SAVEALL'と同じ。）

---------- Footnotes ----------

(1) Python 2.2より前のバージョンでは、`__del__()'メソッドを
持つオブジェクトだけでなく、全ての到達不能オブジェクトが格納されてい
た。）


File: python-lib-jp.info,  Node: weakref,  Next: fpectl,  Prev: gc,  Up: Python ランタイム サービス

弱参照
======

弱参照と弱辞書のサポート。

_Added in Python version 2.1_

`weakref'モジュールは、Pythonプログラマがオブジェクトへの
"弱参照"を作成できるようにします。

以下では、用語"リファレント (referent)" は弱参照が参照するオブジェクトを
意味します。

オブジェクトに対する弱参照は、そのオブジェクトを生かしておくのに
十分な条件にはなりません: あるリファレントに対する参照が弱参照しか
残っていない場合、ガベージコレクション機構は自由にリファレントを破壊し、
そのメモリを別の用途に再利用できます。弱参照の主な用途は、
巨大なオブジェクトを保持するキャッシュやマップ型の実装において、
キャッシュやマップ型にあるという理由だけオブジェクトを存続させたくない
場合です。 例えば、巨大なバイナリ画像のオブジェクトがたくさんあり、
それぞれに名前を関連付けたいとします。 Python の辞書型を使って
名前を画像に対応付けたり画像を名前に対応付けたりすると、
画像オブジェクトは辞書内のキーや値に使われているため存続しつづける
ことになります。`weakref' モジュールが提供している `WeakKeyDictionary'
や `WeakValueDictionary' クラスは
その代用で、対応付けを構築するのに弱参照を使い、キャッシュや
マップ型に存在するという理由だけでオブジェクトを存続させないように
します。 例えば、もしある画像オブジェクトが `WeakValueDictionary' の
値になっていた場合、最後に残った画像オブジェクトへの参照を
弱参照マップ型が保持していれば、ガーベジコレクションはこのオブジェクトを
再利用でき、画像オブジェクトに対する弱参照内の対応付けはそのまま
削除されます。

`WeakKeyDictionary' や `WeakValueDictionary' は
弱参照を使って実装されていて、キーや値がガーベジコレクションによって回収された
ことを弱参照辞書に知らせるような弱参照オブジェクトのコールバック関数を
設定しています。

ほとんどのプログラムが、いずれかの弱参照辞書型を使うだけで必要を満たせるはずです
-- 自作の弱参照辞書を直接作成する必要は普通はありません。とはいえ、
弱参照辞書の実装に使われている低水準の機構は、高度な利用を行う際に恩恵を
うけられるよう `weakref' モジュールで公開されています。

すべてのオブジェクトを弱参照できるわけではありません。
弱参照できるオブジェクトは、クラスインスタンス、(Cではなく)
Pythonで書かれた関数、
(束縛および非束縛の両方の)メソッドです。弱参照をサポートするために拡張型を簡単に作れます。
詳細については、*Note fpectl::節
"拡張型における弱参照"を読んでください。

`ref(object[, callback])'
     OBJECTへの弱参照を返します。リファレントがまだ生きているならば、
     元のオブジェクトは参照オブジェクトの呼び出しで取り出せす。
     リファレントがもはや生きていないならば、参照オブジェクトを呼び出したときに
     `None' を返します。 CALLBACK に `None'
     以外の値を与えた場合、オブジェクトをまさに後始末処理しようとするときに
     呼び出します。このとき弱参照オブジェクトはCALLBACK
     の唯一のパラメタとして
     渡されます。リファレントはもはや利用できません。

     同じオブジェクトに対してたくさんの弱参照を作れます。
     それぞれの弱参照に対して登録されたコールバックは、
     もっとも新しく登録されたコールバックからもっとも古いものへと呼び出されます。

     コールバックが発生させた例外は標準エラー出力に書き込まれますが、伝搬させられません。
     それらはオブジェクトの`__del__()'メソッドが発生させる例外とまったく同様の
     方法で処理されます。

     OBJECTがハッシュ可能ならば、弱参照はハッシュ可能です。それらはOBJECTが
     削除された後でもそれらのハッシュ値を保持します。OBJECTが削除されてから初めて
     `hash()'が呼び出された場合に、その呼び出しは`TypeError'を発生させます。

     弱参照は等価性のテストをサポートしていますが、順序をサポートしていません。
     参照がまだ生きているならば、CALLBACKに関係なく二つの参照はそれらの
     リファレントと同じ等価関係を持ちます。リファレントのどちらか一方が削除された場合、
     参照オブジェクトが同じオブジェクトである場合に限り、その参照は等価です。

`proxy(object[, callback])'
     弱参照を使うOBJECTへのプロキシを返します。弱参照オブジェクトとともに
     用いられる明示的な参照外しを要求する代わりに、これはほとんどのコンテキストに
     おけるプロキシの利用をサポートします。OBJECTが呼び出し可能かどうかに依存して、
     返されるオブジェクトは`ProxyType'または`CallableProxyType'のどちらか一方の
     型を持ちます。プロキシオブジェクトはリファレントに関係なくハッシュ可能ではありません。
     これによって、それらの基本的な変更可能という性質に関係する多くの問題を避けています。
     そして、辞書のキーとしてそれらの利用を妨げます。CALLBACKは`ref()'関数の
     同じ名前のパラメータと同じものです。

`getweakrefcount(object)'
     OBJECTを参照する弱参照とプロキシの数を返します。

`getweakrefs(object)'
     OBJECTを参照するすべての弱参照とプロキシオブジェクトのリストを返します。

`WeakKeyDictionary([dict])'
     キーを弱く参照するマッピングクラス。もはやキーへの強い参照がなくなったときに、
     辞書のエントリは捨てられます。アプリケーションの他の部分が所有するオブジェクトへ
     属性を追加することもなく、それらのオブジェクトに追加データを関連づけるために
     これを使うことができます。これは属性へのアクセスをオーバーライドするオブジェクトに
     特に便利です。

     _Note:_ 注意:  `WeakKeyDictionary' は Python
     辞書型の上に作られているので、
     反復処理を行うときにはサイズ変更してはなりません。`WeakKeyDictionary'
     の場合、反復処理の最中にプログラムが行った操作が、(ガベージコレクションの副作用として)
     「魔法のように」辞書内の要素を消し去ってしまうため、確実なサイズ変更は困難なのです。

`WeakValueDictionary([dict])'
     値を弱く参照するマッピングクラス。値への強い参照がもはや存在しなくなったときに、辞書のエントリは捨てられます。

`ReferenceType'
     弱参照オブジェクトのための型オブジェクト。

`ProxyType'
     呼び出し可能でないオブジェクトのプロキシのための型オブジェクト。

`CallableProxyType'
     呼び出し可能なオブジェクトのプロキシのための型オブジェクト。

`ProxyTypes'
     プロキシのためのすべての型オブジェクトを含むシーケンス。これは両方のプロキシ型の名前付けに依存しないで、オブジェクトがプロキシかどうかのテストをより簡単にできます。

`ReferenceError'
     プロキシオブジェクトが使われても、元のオブジェクトがガーベジコレクションされてしまっているときに発生する例外。これは標準の`ReferenceError'例外と同じです。

See also:
    *PEP0205 Weak References*
          この機能の提案と理論的根拠。初期の実装と他の言語における類似の機能についての情報へのリンクを含んでいます。


* Menu:

* 弱参照オブジェクト::
* 例::
* 拡張型における弱参照::


File: python-lib-jp.info,  Node: 弱参照オブジェクト,  Next: 例,  Prev: weakref,  Up: weakref

弱参照オブジェクト
------------------

弱参照オブジェクトは属性あるいはメソッドを持ちません。しかし、リファレントがまだ存在するならば、呼び出すことでそのリファレントを取得できるようにします:

     >>> import weakref
     >>> class Object:
     ...     pass
     ...
     >>> o = Object()
     >>> r = weakref.ref(o)
     >>> o2 = r()
     >>> o is o2
     True

リファレントがもはや存在しないならば、参照オブジェクトの呼び出しは`None'を返します:

     >>> del o, o2
     >>> print r()
     None

弱参照オブジェクトがまだ生きているかどうかのテストは、式`REF() is not
None'を用いて行われます。通常、参照オブジェクトを使う必要があるアプリケーションコードはこのパターンに従います:

     # rは弱参照オブジェクト
     o = r()
     if o is None:
         # リファレントがガーベジコレクトされた
         print "Object has been allocated; can't frobnicate."
     else:
         print "Object is still live!"
         o.do_something_useful()

"生存性(liveness)"のテストを個々に行うと、スレッド化されたアプリケーションにおいて競合状態を作り出します。弱参照が呼び出される前に、他のスレッドは弱参照が無効になる原因となり得ます。上で示したイディオムは、シングルスレッド化されたアプリケーションと同じくスレッド化されたアプリケーションにおいて安全です。


File: python-lib-jp.info,  Node: 例,  Next: 拡張型における弱参照,  Prev: 弱参照オブジェクト,  Up: weakref

例
--

この簡単な例では、アプリケーションが以前に参照したオブジェクトを取り出すためにオブジェクトIDを利用する方法を示します。オブジェクトに生きたままであることを強制することなく、オブジェクトのIDは他のデータ構造の中で使えます。しかし、そうする場合は、オブジェクトはまだIDによって取り出せます。

     import weakref
     
     _id2obj_dict = weakref.WeakValueDictionary()
     
     def remember(obj):
         oid = id(obj)
         _id2obj_dict[oid] = obj
         return oid
     
     def id2obj(oid):
         return _id2obj_dict[oid]


File: python-lib-jp.info,  Node: 拡張型における弱参照,  Prev: 例,  Up: weakref

拡張型における弱参照
--------------------

実装の目的の一つは、弱参照によって恩恵を受けない数のような型のオブジェクトにオーバーヘッドを負わせることなく、どんな型でも弱参照メカニズムに加わることができるようにすることです。

弱く参照可能なオブジェクトに対して、弱参照メカニズムを使うために、拡張は`PyObject*'フィールドをインスタンス構造に含んでいなければなりません。オブジェクトのコンストラクタによって、それは`NULL'
に初期化しなければなりません。対応する型オブジェクトの`tp_weaklistoffset'フィールドをフィールドのオフセットに設定することもしなければなりません。また、`Py_TPFLAGS_HAVE_WEAKREFS'をtp_flagsスロットへ追加する必要もあります。例えば、インスタンス型は次のような構造に定義されます:

     typedef struct {
         PyObject_HEAD
         PyClassObject *in_class;       /* クラスオブジェクト */
         PyObject      *in_dict;        /* 辞書 */
         PyObject      *in_weakreflist; /* 弱参照のリスト */
     } PyInstanceObject;

インスタンスに対して静的に宣言される型オブジェクトはこのように定義されます:

     PyTypeObject PyInstance_Type = {
         PyObject_HEAD_INIT(&PyType_Type)
         0,
         "module.instance",
     
         /* 簡単のためにたくさんのものを省略... */
     
         Py_TPFLAGS_DEFAULT | Py_TPFLAGS_HAVE_WEAKREFS   /* tp_flags */
         0,                                          /* tp_doc */
         0,                                          /* tp_traverse */
         0,                                          /* tp_clear */
         0,                                          /* tp_richcompare */
         offsetof(PyInstanceObject, in_weakreflist), /* tp_weaklistoffset */
     };

型コンストラクタは弱参照リストを`NULL' に初期化する責任があります:

     static PyObject *
     instance_new() {
         /* 簡単のために他の初期化を省略 */
     
         self->in_weakreflist = NULL;
     
         return (PyObject *) self;
     }

さらに一つだけ追加すると、どんな弱参照でも取り除くためには、デストラクタは弱参照マネージャを呼び出す必要があります。オブジェクトの破壊のどんな他の部分が起きる前にこれを行うべきですが、弱参照リストが非`NULL'
である場合はこれが要求されるだけです:

     static void
     instance_dealloc(PyInstanceObject *inst)
     {
         /* 必要なら一時オブジェクトを割り当ててください。
            しかし、まだ破壊しないでください。
          */
     
         if (inst->in_weakreflist != NULL)
             PyObject_ClearWeakRefs((PyObject *) inst);
     
         /* 普通にオブジェクトの破壊を進めてください。 */
     }


File: python-lib-jp.info,  Node: fpectl,  Next: atexit,  Prev: weakref,  Up: Python ランタイム サービス

浮動小数点例外の制御
====================

Provide control for floating point exception handling.
浮動小数点例外処理の制御。

ほとんどのコンピュータはいわゆるIEEE-754標準に準拠した浮動小数点演算
を実行します。実際のどんなコンピュータでも、浮動小数点演算が普通の浮動小数点数では表せない結果になることがあります。例えば、次を試してください。

     >>> import math
     >>> math.exp(1000)
     inf
     >>> math.exp(1000) / math.exp(1000)
     nan

(上の例は多くのプラットホームで動作します。DEC
Alphaは例外かもしれません。)
"Inf"は"infinity(無限)"を意味するIEEE-754における特殊な非数値の値で、"nan"は"not
a
number(数ではない)"を意味します。ここで留意すべき点は、その計算を行うようにPythonに求めたときに非数値の結果以外に特別なことは何も起きないというです。事実、それはIEEE-754標準に規定されたデフォルトのふるまいで、それで良ければここで読むのを止めてください。

いくつかの環境では、誤った演算がなされたところで例外を発生し、処理を止めることがより良いでしょう。`fpectl'モジュールはそんな状況で使うためのものです。いくつかのハードウェア製造メーカーの浮動小数点ユニットを制御できるようにします。つまり、IEEE-754例外Division
by Zero、OverflowあるいはInvalid
Operationが起きたときはいつでも`SIGFPE'が生成させるように、ユーザが切り替えられるようにします。あなたのpythonシステムを構成しているCコードの中へ挿入される一組のラッパーマクロと協力して、`SIGFPE'は捕捉され、Python
`FloatingPointError'例外へ変換されます。

`fpectl'モジュールは次の関数を定義しています。また、所定の例外を発生します:

`turnon_sigfpe()'
     `SIGFPE'を生成するように切り替え、適切なシグナルハンドラを設定します。

`turnoff_sigfpe()'
     浮動小数点例外のデフォルトの処理に再設定します。

`FloatingPointError'
     `turnon_sigfpe()'が実行された後に、IEEE-754例外であるDivision by
     Zero、OverflowまたはInvalid
     operationの一つを発生する浮動小数点演算は、次にこの標準Python例外を発生します。

* Menu:

* 例 2::
* 制限と他に考慮すべきこと::


File: python-lib-jp.info,  Node: 例 2,  Next: 制限と他に考慮すべきこと,  Prev: fpectl,  Up: fpectl

例
--

以下の例は`fpectl'モジュールの使用を開始する方法とモジュールのテスト演算について示しています。

     >>> import fpectl
     >>> import fpetest
     >>> fpectl.turnon_sigfpe()
     >>> fpetest.test()
     overflow        PASS
     FloatingPointError: Overflow
     
     div by 0        PASS
     FloatingPointError: Division by zero
       [ more output from test elided ]
     >>> import math
     >>> math.exp(1000)
     Traceback (most recent call last):
       File "<stdin>", line 1, in ?
     FloatingPointError: in math_1


File: python-lib-jp.info,  Node: 制限と他に考慮すべきこと,  Prev: 例 2,  Up: fpectl

制限と他に考慮すべきこと
------------------------

特定のプロセッサをIEEE-754浮動小数点エラーを捕らえるように設定することは、現在アーキテクチャごとの基準に基づきカスタムコードを必要とします。あなたの特殊なハードウェアを制御するために`fpectl'を修正することもできます。

IEEE-754例外のPython例外への変換には、ラッパーマクロ`PyFPE_START_PROTECT'と`PyFPE_END_PROTECT'があなたのコードに適切な方法で挿入されていることが必要です。Python自身は`fpectl'モジュールをサポートするために修正されていますが、数値解析にとって興味ある多くの他のコードはそうではありません。

`fpectl'モジュールはスレッドセーフではありません。

See also:
     このモジュールがどのように動作するのかについてより学習するときに、ソースディストリビューションの中のいくつかのファイルは興味を引くものでしょう。インクルードファイル`Include/pyfpe.h'では、このモジュールの実装について同じ長さで議論されています。`Modules/fpetestmodule.c'には、いくつかの使い方の例があります。多くの追加の例が`Objects/floatobject.c'にあります。


File: python-lib-jp.info,  Node: atexit,  Next: types,  Prev: fpectl,  Up: Python ランタイム サービス

終了ハンドラ
============

後始末関数の登録と実行。

_Added in Python version 2.0_

`atexit'モジュールは後始末関数を登録するための一つの関数を定義します。このような登録された関数はインタープリタが終了するときに自動的に実行されます。

注意:
プログラムがシグナルで停止させられたとき、Pythonの致命的な内部エラーが検出されたとき、あるいは`os._exit()'が呼び出されたときには、このモジュールを通して登録された関数は呼び出されません。

これは`sys.exitfunc'変数がはたす機能の代わりのインターフェイスです。

注意:
`sys.exitfunc'を設定する他のコードとともに使用した場合には、このモジュールが正しく動作しないと思われます。特に、他のコアPythonモジュールはプログラマの知らないところで`atexit'を自由に使えます。`sys.exitfunc'を使う著者は、代わりに`atexit'を使うコードに変換すべきです。`sys.exitfunc'を設定するコードを変換するもっとも簡単な方法は、`atexit'をインポートして`sys.exitfunc'へ束縛されていた関数を登録することです。

`register(func[, *args[, **kargs]])'
     終了時に実行される関数としてFUNCを登録します。すべてのFUNCへ渡すオプションの引数を、`register()'へ引数としてわたさなければなりません。

     通常のプログラムの終了時、例えば`sys.exit()'が呼び出されるとき、あるいは、メインモジュールの実行が完了したときに、登録されたすべての関数は後入先出順に呼び出されます。より低レベルのモジュールは通常より高レベルのモジュールより前にインポートされ、従ってより後で後始末するということが想定されています。

See also:
     *Note readline::
     `readline'ヒストリファイルを読み書きするための`atexit'の有用な例。

* Menu:

* atexit 例::


File: python-lib-jp.info,  Node: atexit 例,  Prev: atexit,  Up: atexit

`atexit' 例
-----------

次の簡単な例では、インポートされたときにモジュールがファイルからカウンタを初期化する方法を示しています。また、プログラムが終了したときにアプリケーションがこのモジュールを明示的に呼び出さなくても、自動的にカウンタの更新された値を保存する方法を示しています。

     try:
         _count = int(open("/tmp/counter").read())
     except IOError:
         _count = 0
     
     def incrcounter(n):
         global _count
         _count = _count + n
     
     def savecounter():
         open("/tmp/counter", "w").write("%d" % _count)
     
     import atexit
     atexit.register(savecounter)

`register()'に指定した位置パラメータとキーワードパラメータは、
登録した関数を呼び出す際に渡されます。

     def goodbye(name, adjective):
         print 'Goodbye, %s, it was %s to meet you.' % (name, adjective)
     
     import atexit
     atexit.register(goodbye, 'Donny', 'nice')
     
     # or:
     atexit.register(goodbye, adjective='nice', name='Donny')


File: python-lib-jp.info,  Node: types,  Next: UserDict,  Prev: atexit,  Up: Python ランタイム サービス

組み込み型の名前
================

組み込み型の名前

このモジュールは標準のPythonインタプリタで使われているオブジェクト
の型について、名前を定義しています(拡張モジュールで定義されている型を除
く)。このモジュールは以下に列挙している以外の名前をエクスポートしないの
で、`from types import *'のように使っても安全です。このモジュールの
将来のバージョンで追加される名前は、`Type'で終わる予定です。

関数での典型的な利用方法は、以下のように引数の型によって異なる動作をする
場合です:

     from types import *
     def delete(mylist, item):
         if type(item) is IntType:
            del mylist[item]
         else:
            mylist.remove(item)

Python 2.2以降では、`int()' や `str()'のような
ファクトリ関数は、型の名前となりましたので、`types'を使用する
必要はなくなりました。上記のサンプルは、以下のように記述する事が
推奨されています。

     def delete(mylist, item):
         if isinstance(item, int):
            del mylist[item]
         else:
            mylist.remove(item)

このモジュールは以下の名前を定義しています。

`NoneType'
     `None'の型です。

`TypeType'
     typeオブジェクトの型です (`type()' などによって返 されます)。

`BooleanType'
     `bool'の`True'と`False'の型です。これは組み込み関数の
     `bool()'のエイリアスです。

`IntType'
     整数の型です(e.g. `1')。

`LongType'
     長整数の型です(e.g. `1L')。

`FloatType'
     浮動小数点数の型です(e.g. `1.0')。

`ComplexType'
     複素数の型です(e.g. `1.0j')。
     Pythonが複素数のサポートなしでコンパイルされていた場合には
     定義されません。

`StringType'
     文字列の型です(e.g. `'Spam'')。

`UnicodeType'
     Unicode文字列の型です(e.g. `u'Spam'')。
     Pythonがユニコードのサポートなしでコンパイルされていた場合には
     定義されません。

`TupleType'
     タプルの型です(e.g. `(1, 2, 3, 'Spam')')。

`ListType'
     リストの型です(e.g. `[0, 1, 2, 3]')。

`DictType'
     辞書の型です(e.g. `{'Bacon': 1, 'Ham': 0}')。

`DictionaryType'
     `DictType'の別名です。

`FunctionType'
     ユーザー定義の関数またはlambdaの型です。

`LambdaType'
     `FunctionType'の別名です。

`GeneratorType'
     ジェネレータ関数の呼び出しによって生成されたイテレータオブジェクトの型で
     す。 _Added in Python version 2.2_

`CodeType'
     `compile()' 関数などによって返されるコード オブジェクトの型です。

`ClassType'
     ユーザー定義のクラスの型です。

`InstanceType'
     ユーザー定義のクラスのインスタンスの型です。

`MethodType'
     ユーザー定義のクラスのインスタンスのメソッドの型です。

`UnboundMethodType'
     `MethodType'の別名です。

`BuiltinFunctionType'
     `len()' や `sys.exit()'のような組み込み関数の型です。

`BuiltinMethodType'
     `BuiltinFunction'の別名です。

`ModuleType'
     モジュールの型です。

`FileType'
     `sys.stdout'のようなopenされたファイルオブジェクトの型です。

`XRangeType'
     `xrange()' 関数によって返されるrangeオブジェ クトの型です。

`SliceType'
     `slice()' 関数によって返されるオブジェクトの 型です。

`EllipsisType'
     `Ellipsis'の型です。

`TracebackType'
     `sys.exc_traceback'に含まれるようなトレースバックオブジェクトの型です。

`FrameType'
     フレームオブジェクトの型です。
     トレースバックオブジェクト`tb'の`tb.tb_frame'などです。

`BufferType'
     `buffer()' 関数によって作られるバッファオブ ジェクトの型です。

`StringTypes'
     文字列型のチェックを簡単にするための`StringType'と
     `UnicodeType'を含むシーケンスです。
     `UnicodeType'は実行中の版のPythonに含まれている場合にだけ含まれるの
     で、2つの文字列型のシーケンスを使うよりこれを使う方が移植性が高くなります。
     例: `isinstance(s, types.StringTypes)'.  _Added in Python version
     2.2_


File: python-lib-jp.info,  Node: UserDict,  Next: UserList,  Prev: types,  Up: Python ランタイム サービス

辞書オブジェクトのためのクラスラッパー
======================================

辞書オブジェクトのためのクラスラッパー。

_Note:_ このモジュールは後方互換性のためだけに残されています。Python
2.2より前のバージョンのPythonで動作する必要のないコードを書いているのならば、組み込み`dict'型から直接サブクラス化することを検討してください。

このモジュールは辞書オブジェクトのラッパーとして働くクラスを定義します。独自の辞書に似たクラスのために役に立つ基底クラスで、これを継承し既存のメソッドをオーバーライドしたり、あるいは、新しいものを追加したりすることができます。このような方法で、辞書に新しい振る舞いを追加できます。

最小限のマッピングインターフェイスをすでに持っているクラスのために、モジュールはすべての辞書メソッドを定義しているmixinも定義しています。これによって、shelveモジュールのような辞書の代わりをする必要があるクラスを書くことが非常に簡単になります。

`UserDict'モジュールは`UserDict'クラスと`DictMixin'を定義しています:

`UserDict([initialdata])'
     辞書をシミュレートするクラス。インスタンスの内容は通常の辞書に保存され、`UserDict'インスタンスの`data'属性を通してアクセスできます。INITIALDATAが与えられれば、`data'はその内容で初期化されます。他の目的のために使えるように、INITIALDATAへの参照が保存されないことがあるということに注意してください。

マッピングのメソッドと演算(節*Note
マップ型::を参照)に加えて、`UserDict'インスタンスは次の属性を提供します:

`data'
     `UserDict'クラスの内容を保存するために使われる実際の辞書。

`DictMixin()'
     `__getitem__'、`__setitem__'、`__delitem__'および`keys'
     といった最小の辞書インタフェースを既に持っているクラスのために、全ての辞書メソッドを定義する
     mixin です。

     このmixinはスーパークラスとして使われるべきです。上のそれぞれのメソッドを
     追加することで、より多くの機能がだんだん追加されます。
     例えば、`__delitem__'
     以外の全てのメソッドを定義すると、使えないのは `pop'と`popitem'
     だけになります。

     4 つの基底メソッドに加えて、`__contains__'、`__iter__'
     および`iteritems'を定義すれば、順次効率化を果たすことができます。

     mixin はサブクラスのコンストラクタについて何も知らないので、
     `__init__()' や `copy()' は定義していません。


