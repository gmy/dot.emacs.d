This is python-lib-jp.info, produced by makeinfo version 4.5 from
python-lib-jp.texi.

12 October 2005


File: python-lib-jp.info,  Node: 非必須組み込み関数 Non-essential Built-in Functions,  Next: 組み込み型,  Prev: 組み込み関数,  Up: 組み込みオブジェクト

非必須組み込み関数 (Non-essential Built-in Functions)
=====================================================

いくつかの組み込み関数は、現代的な Python プログラミングを行う場合には、
必ずしも学習したり、知っていたり、使ったりする必要がなくなりました。
こうした関数は古いバージョンの Python 向け書かれたプログラムとの互換性を
維持するだけの目的で残されています。

Python
のプログラマ、教官、学生、そして本の著者は、こうした関数を飛ばしても
かまわず、その際に何か重要なことを忘れていると思う必要もありません。

`apply(function, args[, keywords])'
     引数 FUNCTION は呼び出しができるオブジェクト (ユーザ定義
     および組み込みの関数またはメソッド、またはクラスオブジェクト)
     でなければなりません。ARGS は配列型でなくてはなりません。 FUNCTION
     は引数リスト ARGS を使って呼び出されます;
     引数の数はタプルの長さになります。オプションの引数 KEYWORDS
     を与える場合、 KEYWORDS は文字列のキーを持つ辞書で
     なければなりません。これは引数リストの最後に追加されるキーワード
     引数です。 `apply()' の呼び出しは、単なる `FUNCTION(ARGS)'
     の呼び出しとは異なります。 というのは、`apply()'
     の場合、引数は常に一つだから です。`apply()' は `FUNCTION(*ARGS,
     **KEYWORDS)' を 使うのと等価です。 上のような
     "拡張された関数呼び出し構文" は `apply()'
     と全く等価なので、必ずしも `apply()' を使う必要はありません。
     _This is deprecated in Python 2.3.
     上で述べられたような拡張呼び出し構文を使って ください。_

`buffer(object[, offset[, size]])'
     引数 OBJECT を参照する新たなバッファオブジェクトが生成されます。
     引数 OBJECT は (文字列、アレイ、バッファといった) バッファ
     呼び出しインタフェースをサポートするオブジェクトでなければなりません。
     返されるバッファオブジェクトは OBJECT の先頭 (または OFFSET)
     からのスライスになります。スライスの末端は OBJECT の末端まで
     (または引数 SIZE で与えられた長さになるまで) です。

`coerce(x, y)'
     二つの数値型の引数を共通の型に変換して、変換後の値からなるタプルを
     返します。変換に使われる規則は算術演算における規則と同じです。
     変換を行えない場合には`TypeError' を送出します。

`intern(string)'
     STRING を "隔離" された文字列のテーブルに入力し、隔離された
     文字列を返します - この文字列は STRING 自体かコピーです。
     隔離された文字列は辞書検索のパフォーマンスを少しだけ向上させるのに
     有効です - 辞書中のキーが隔離されており、検索するキーが隔離されて
     いる場合、(ハッシュ化後の) キーの比較は文字列の比較ではなくポインタ
     の比較で行うことができるからです。通常、Python プログラム内で
     利用されている名前は自動的に隔離され、モジュール、クラス、
     またはインスタンス属性を保持するための辞書は隔離されたキーを持って
     います。 _Changed in Python version 2.3_


File: python-lib-jp.info,  Node: 組み込み型,  Next: 組み込み例外,  Prev: 非必須組み込み関数 Non-essential Built-in Functions,  Up: 組み込みオブジェクト

組み込み型
==========

以下のセクションでは、インタプリタに組み込まれている標準の型に
ついて記述します。これまでの Python の歴史では、組み込み型は
オブジェクト指向における継承を行う際に雛型にできないという点で、
ユーザ定義型とは異なっていました。リリース 2.2 からは状況が
変わり始めましたが、目標とするユーザ定義型と組み込み方の一元化は
まだまだ完成の域には達していません。

主要な組み込み型は数値型、配列型、マッピング型、ファイルクラス、
インスタンス型、および例外です。

演算によっては、複数の型でサポートされているものがあります;
特に、全てのオブジェクトについて、比較、真値テスト、 (``...`' 形式での)
文字列への変換を行うことができます。 `print'
使われた場合、最後の文字列への変換 が暗黙のうちに行われます。
(Information on `print' 文 やその他の文に関する情報は  および

で見つけることができます。)

* Menu:

* 真値テスト::
* ブール演算::
* 比較::
* 数値型::
* イテレータ型::
* 配列型::
* マップ型::
* ファイルオブジェクト::
* 他の組み込み型::
* 特殊な属性::


File: python-lib-jp.info,  Node: 真値テスト,  Next: ブール演算,  Prev: 組み込み型,  Up: 組み込み型

真値テスト
----------

どのオブジェクトも `if' または `while' 条件文の中や、
以下のブール演算における被演算子として真値テストを行うことができます。
以下の値は偽であると見なされます:

   * `None'

   * `False'

   * 数値型におけるゼロ。例えば `0' 、 `0L' 、 `0.0' 、 `0j' 。

   * 空の配列型。例えば `''' 、 `()' 、 `[]' 。

   * 空のマッピング型。例えば `{}' 。

   * `__nonzero__()' または `__len__()' メソッドが
     定義されているようなユーザ定義クラスのインスタンスで、それらのメソッド
     が整数値ゼロまたは `bool' 値の `False' を返すとき。 (1)


それ以外の値は全て真であると見なされます -- 従って、ほとんどの型
のオブジェクトは常に真です。

ブール値の結果を返す演算および組み込み関数は、特に注釈のない限り常に
偽値として `0' または`False' を返し、真値として `1' または `True'
を返します (重要な例外: ブール演算 `or'  および `and'  は常に被演算子
の中の一つを返します)。

---------- Footnotes ----------

(1) これらの特殊なメソッドに関する追加情報は に記載されています。


File: python-lib-jp.info,  Node: ブール演算,  Next: 比較,  Prev: 真値テスト,  Up: 組み込み型

ブール演算
----------

以下にブール演算子を示します。優先度の低いものから順に並んでいます。:

演算                     結果                     注釈
------                   -----                    -----
X or Y                   X が偽なら Y             (1)
                         、そうでなければ X       
X and Y                  X が偽なら X             (1)
                         、そうでなければ Y       
not X                    X が偽なら `True'        (2)
                         、そうでなければ         
                         `False'                  

注釈:

`(1)'
     これらの演算子は、演算を行う上で必要がない限り、二つ目の引数を評価しません。

`(2)'
     `not' は非ブール演算子よりも低い演算優先度なので、 `not A == B' は
     `not (A == B)' と評価され、 `A == not B' は構文エラーとなります。


File: python-lib-jp.info,  Node: 比較,  Next: 数値型,  Prev: ブール演算,  Up: 組み込み型

比較
----

比較演算は全てのオブジェクトでサポートされています。比較演算子は
全て同じ演算優先度を持っています (ブール演算より高い演算優先度です)。
比較は任意の形で連鎖させることができます; 例えば、`X < Y <= Z' は `X <
Y および  Y <= Z' と等価で、違うのは Y が一度だけしか評価
されないということです (どちらの場合でも、 `X < Y' が偽となった場合には
Z は評価されません) 。

以下のテーブルに比較演算をまとめます:

演算                     意味                     注釈
------                   -----                    -----
<                        より小さい               
<=                       以下                     
>                        より大きい               
>=                       以上                     
==                       等しい                   
!=                       等しくない               (1)
<>                       等しくない               (1)
is                       同一のオブジェクトである 
is not                   同一のオブジェクトでない 

注釈:

`(1)'
     `<>' および `!=' は同じ演算子を別の書き方にしたものです。 `!='
     のほうが望ましい書き方です; `<>' は廃止すべき書き方です。


数値型間の比較か文字列間の比較でないかぎり、異なる型のオブジェクトを
比較しても等価になることはありません; これらのオブジェクトの順番付けは
一貫してはいますが任意のものです (従って要素の型が一様でない配列を
ソートした結果は一貫したものになります)。
さらに、(例えばファイルオブジェクトのように) 型によっては、 その型の 2
つのオブジェクトの不等性だけの、縮退した比較の概念
しかサポートしないものもあります。繰り返しますが、
そのようなオブジェクトも任意の順番付けをされていますが、
それは一貫したものです。被演算子が複素数の場合、演算子 `<' 、 `<=' 、
`>' および `>=' は 例外 `TypeError' を送出します。

あるクラスのインスタンス間の比較は、そのクラスで `__cmp__()'
メソッドが定義されていない限り等しくなりません。
このメソッドを使ってオブジェクトの比較方法に影響を及ぼすための
情報については

を参照してください。

*実装に関する注釈:* 数値型を除き、異なる型のオブジェクトは
型の名前で順番付けされます; 適当な比較をサポートしていないある型の
オブジェクトはアドレスによって順番付けされます。

同じ優先度を持つ演算子としてさらに 2 つ、配列型でのみ `in'  および `not
in'  が サポートされています (以下を参照)。


File: python-lib-jp.info,  Node: 数値型,  Next: イテレータ型,  Prev: 比較,  Up: 組み込み型

数値型
------

4 つの異なる数値型があります: "通常の整数型" 、 "長整数型"
、"浮動小数点型" 、および "複素数型" です。

さらに、ブール方は通常の整数型のサブタイプです。通常の整数 (単に
"整数型" とも呼ばれます) は C では `long' を
使って実装されており、少なくとも 32 ビットの精度があります。
長整数型には精度の制限がありません。浮動小数点型は C では `double'
を使って実装されています。しかし使っている計算機
が何であるか分からないなら、これらの数値型の精度に関して断言はできません。

複素数型は実数部と虚数部を持ち、それぞれの C では `double' を
使って実装されています。複素数 Z から実数および虚数部を取り出す
には、`Z.real' および `Z.imag' を使います。

数値は、数値リテラルや組み込み関数や演算子の戻り値として生成されます。
修飾のない整数リテラル (16 進表現や 8 進表現の値も含みます) は、
通常の整数値を表します。値が通常の整数で表すには大きすぎる場合、 `L'
または `l' が末尾につく整数リテラル は長整数型を表します (`L'
が望ましいです。というのは `1l' は 11 と非常に紛らわしいからです！)
小数点または 指数表記のある数値リテラルは浮動小数点数を表します。
数値リテラルに `j' または `J' をつけると
実数部がゼロの複素数を表します。複素数の数値リテラルは実数部と
虚数部を足したものです。

Python は型混合の演算を完全にサポートします: ある 2 項演算子が
互いに異なる数値型の被演算子を持つ場合、より "制限された" 型の
被演算子は他方の型に合わせて広げられます。ここで通常の整数は
長整数より制限されており、長整数は浮動小数点数より制限されており、
浮動小数点は複素数より制限されています。
型混合の数値間での比較も同じ規則に従います。 (1) コンストラクタ `int()'
、`long()' 、`float()'、 および `complex()'
を使って、特定の型の数を生成することが できます。

全ての数値型（complex
は例外）は以下の演算をサポートします。これらの演算は
優先度の低いものから順に並べられています (同じボックスにある演算は
同じ優先度を持っています; 全ての数値演算は比較演算よりも
高い優先度を持っています):

演算                     結果                     注釈
------                   -----                    -----
X + Y                    X と Y の加算            
X - Y                    X と Y の減算            
X * Y                    X と Y の乗算            
X / Y                    X と Y の除算            (1)
X %{} Y                  `X / Y' の剰余           (4)
-X                       X の符号反転             
+X                       X の符号不変             
abs(X)                   X の絶対値または大きさ   
int(X)                   X の通常整数への変換     (2)
long(X)                  X の長整数への変換       (2)
float(X)                 X                        
                         の浮動小数点数への変換   
complex(RE,IM)           実数部 RE 、虚数部 IM    
                         の複素数。 IM            
                         のデフォルト値はゼロ。   
C.conjugate()            複素数 C の共役複素数    
divmod(X, Y)             `(X / Y, X %{} Y)'       (3)
                         からなるペア             
pow(X, Y)                X の Y 乗                
X ** Y                   X の Y 乗                

注釈:
`(1)'
     (通常および長) 整数の割り算では、結果は整数になります。
     この場合値は常にマイナス無限大の方向に丸められます: つまり、1/2 は
     0、 (-1)/2 は -1、1/(-1) は -1、そして (-1)/(-2) は 0 になります。
     被演算子の両方が長整数の場合、計算値に関わらず結果は長整数で返される
     ので注意してください。

`(2)'
     浮動小数点数から (通常または長) 整数への変換では、C
     におけるのと同様の 値の丸めまたは切り詰めが行われるかもしれません;
     きちんと定義された 変換については、`math'  モジュールの `floor()'
     および `ceil()' を参照してください。

`(3)'
     完全な記述については、*Note 組み込み関数::、"組み込み関数"
     を参照してください。

`(4)'
     複素数の切り詰め除算演算子、モジュロ演算子、および `divmod()'。

     _This is deprecated in Python 2.3.  適切であれば、`abs()'
     を使って浮動小数点に変換してください。_

* Menu:

* Bit-string Operations::

---------- Footnotes ----------

(1) この結果として、リスト `[1, 2]' は `[1.0, 2.0]'
と等しいと見なされます。タプルの場合も同様です


File: python-lib-jp.info,  Node: Bit-string Operations,  Prev: 数値型,  Up: 数値型

整数型におけるビット文字列演算
..............................

通常および長整数型ではさらに、ビット文字列に対してのみ意味のある
演算をサポートしています。負の数はその値の 2 の補数の値として扱われます
(長整数の場合、演算操作中にオーバフローが起こらないように十分なビット数
があるものと仮定します) 。

2 進のビット単位演算は全て、数値演算よりも低く、比較演算子よりも高い
優先度です; 単項演算 `~' は他の単項数値演算 (`+' および `-')
と同じ優先度です。

以下のテーブルでは、ビット文字列演算を優先度の低いものから順に並べています
(同じボックス内の演算は同じ優先度です):

演算                     結果                     注釈
------                   -----                    -----
X | Y                    ビット単位の X と Y の   
                         "論理和"                 
X ^{} Y                  ビット単位の X と Y の   
                         "排他的論理和"           
X &{} Y                  ビット単位の X と Y の   
                         "論理積"                 
X <{}< N                 X の N ビット左シフト    (1), (2)
X >{}> N                 X の N ビット右シフト    (1), (3)
~X                       X のビット反転           

注釈:
`(1)'
     負値のシフト数は不正であり、`ValueError' が送出 されます。

`(2)'
     N ビットの左シフトは、オーバフローチェックを行わない `pow(2, N)'
     による乗算と等価です。

`(3)'
     N ビットの右シフトは、オーバフローチェックを行わない `pow(2, N)'
     による除算と等価です。


File: python-lib-jp.info,  Node: イテレータ型,  Next: 配列型,  Prev: 数値型,  Up: 組み込み型

イテレータ型
------------

_Added in Python version 2.2_

Python はコンテナの内容にわたって反復処理を行う概念をサポートして
います。この概念は 2 つの別々のメソッドを使って実装されています;
これらのメソッドはユーザ定義のクラスで反復を行えるようにするために
使われます。後に詳しく述べる配列型はすべて反復処理メソッドを
サポートしています。

以下はコンテナオブジェクトに反復処理をサポートさせるために定義しなければ
ならないメソッドです:

`__iter__()'
     イテレータオブジェクトを返します。イテレータオブジェクトは以下で述べる
     イテレータプロトコルをサポートする必要があります。あるコンテナが
     異なる形式の反復処理をサポートする場合、それらの反復処理形式
     のイテレータを特定的に要求するようなメソッドを追加することができます
     (複数の形式での反復処理をサポートするようなオブジェクトとして
     木構造の例があります。木構造は幅優先走査と深さ優先走査の両方を
     サポートします)。 このメソッドは Python/C API において Python
     オブジェクトを表す 型構造体の `tp_iter' スロットに対応します。

イテレータオブジェクト自体は以下の 2 のメソッドをサポートする必要
があります。これらのメソッドは 2 つ合わせて "イテレータプロトコル"
を成します:

`__iter__()'
     イテレータオブジェクト自体を返します。このメソッドはコンテナとイテレータの
     両方を`for' および `in' 文で使えるようにするために
     必要です。このメソッドは Python/C API において Python
     オブジェクトを表す 型構造体の `tp_iter' スロットに対応します。

`next()'
     コンテナ内の次の要素を返します。もう要素が残っていない場合、 例外
     `StopIteration' を送出します。このメソッドは Python/C API において
     Python オブジェクトを表す型構造体の `tp_iternext'
     スロットに対応します。

Python では、いくつかのイテレータオブジェクトを定義しています。これらは
一般的および特殊化された配列型、辞書型、そして他のさらに特殊化
された形式をサポートします。特殊型であることはイテレータプロトコル
の実装が特殊になること以外は重要なことではありません。

このプロトコルの趣旨は、 一度イテレータの `next()' メソッドが
`StopIteration'
例外を送出した場合、以降の呼び出しでもずっと例外を送出しつづける
ところにあります。この特性に従わないような実装は変則であると
みなされます (この制限は Python 2.3 で追加されました; Python 2.2
では、この規則に従うと多くのイテレータが変則となります)。

Python におけるジェネレータ (generator) は、イテレータプロトコル
を実装する簡便な方法を提供します。コンテナオブジェクトの `__iter__()'
メソッドがジェネレータとして実装されて いれば、メソッドは `__iter__()'
および `next()' メソッドを提供するイテレータオブジェクト
(技術的にはジェネレータ オブジェクト) を自動的に返します。


File: python-lib-jp.info,  Node: 配列型,  Next: マップ型,  Prev: イテレータ型,  Up: 組み込み型

配列型
------

組み込み型には 6 つの配列型があります: 文字列、ユニコード文字列、
リスト、タプル、バッファ、そして xrange オブジェクトです。

文字列リテラルは `'xyzzy''、`"frobozz"' といったように、
単引用符または二重引用符の中に書かれます。
文字列リテラルについての詳細はは、

の第 2 章を読んで下さい。 Unicode
文字列はほとんど文字列と同じですが、`u'abc'' 、 `u"def"'
といったように先頭に文字 `u' を付けて 指定します。 リストは `[a, b, c]'
のように要素をコンマで区切り角括弧で 囲って生成します。タプルは `a, b,
c' のようにコンマ演算子で 区切って生成します
(角括弧の中には入れません)。
丸括弧で囲っても囲わなくてもかまいませんが、空のタプルは `()'
のように丸括弧で囲わなければなりません。 要素が一つのタプルでは、例えば
`(d,)' のように、要素の後ろに コンマをつけなければなりません。

バッファオブジェクトは Python の構文上では直接サポートされていませんが、
組み込み関数 `buffer()'

で生成することができます。バッファオブジェクトは結合や反復をサポート
していません。

xrange オブジェクトは、オブジェクトを生成するための特殊な構文がない
点でバッファに似ていて、関数 `xrange()' で生成します。 xrange
オブジェクトはスライス、結合、反復をサポートせず、 `in' 、 `not in'
、`min()' または `max()' は効率的ではありません。

ほとんどの配列型は以下の演算操作をサポートします。`in' および `not in'
は比較演算と同じ優先度を持っています。 `+' および `*'
は対応する数値演算と同じ優先度です。 (1)

以下のテーブルは配列型の演算を優先度の低いものから順に挙げたものです
(同じボックス内の演算は同じ優先度です)。テーブル内の S および T
は同じ型の配列です; N、I および J は整数です:

演算                     結果                     注釈
------                   -----                    -----
X in S                   S のある要素 X           (1)
                         と等しい場合 `1'         
                         、そうでない場合 `0'     
X not in S               S のある要素が X         (1)
                         と等しい場合 `0'         
                         、そうでない場合 `1'     
S + T                    S および T の結合        
S * N, N * S             S の浅いコピー N         (2)
                         個からなる結合           
S[I]                     S の 0 から数えて I      (3)
                         番目の要素               
S[I:J]                   S の I 番目から J        (3), (4)
                         番目までのスライス       
S[I:J:K]                 S の I 番目から J        (3), (5)
                         番目まで、K              
                         毎のスライス             
len(S)                   S の長さ                 
min(S)                   S の最小の要素           
max(S)                   S の最大の要素           

注釈:

`(1)'
     S が文字列または Unicode 文字列の場合、 演算操作 `in' および `not
     in' は部分文字列の一致テスト と同じように動作します。バージョン
     2.3 以前の Python では、 X は長さ 1 の文字列でした。Python 2.3
     以降では、X はどの長さでもかまいません。

`(2)'
     N が `0' 以下の値の場合、`0' として 扱われます (これは S
     と同じ型の空の配列を表します)。
     コピーは浅いコピーなので注意してください; 入れ子になったデータ
     構造はコピーされません。これは Python に慣れていないプログラマを
     よく悩ませます。例えば以下のコードを考えます:

          >>> lists = [[]] * 3
          >>> lists
          [[], [], []]
          >>> lists[0].append(3)
          >>> lists
          [[3], [3], [3]]

     上のコードでは、 `lists' はリスト `[[]]' (空のリストを唯一の
     要素として含んでいるリスト) の3つのコピーを要素とするリストです。
     しかし、リスト内の要素に含まれているリストは各コピー間で共有されています。
     以下のようにすると、異なるリストを要素とするリストを生成できます:

          >>> lists = [[] for i in range(3)]
          >>> lists[0].append(3)
          >>> lists[1].append(5)
          >>> lists[2].append(7)
          >>> lists
          [[3], [5], [7]]

`(3)'
     I または J が負の数の場合、インデクスは文字列の
     末端からの相対インデクスになります: `len(S) + I' または `len(S) +
     J' が代入されます。 しかし `-0' は `0'
     のままなので注意してください。

`(4)'
     S の I から J へのスライスは `I <= K < J' となるようなインデクス K
     を持つ要素からなる配列として定義されます。I または J が `len(S)'
     よりも大きい場合、`len(S)' を使います。 I が省略された場合、`0'
     を使います。 J が省略された場合、`len(S)' を使います。 I が J
     以上の場合、スライスは空の配列になります。

`(5)'
     S の I 番目から J 番目まで K 毎の スライスは、`0' `<=' N `<'
     `abs(i-j)' となるような、 インデクス`X = I + N*K'
     を持つ要素からなる配列として 定義されます。 I または J `len(S)'
     より大きい場合、`len(S)' を使います。I または J
     を省略した場合、"最後" (K の符号に依存)を示す値を使います。K
     はゼロにできないので 注意してください。


* Menu:

* 文字列メソッド::
* 文字列フォーマット操作::
* XRange 型::
* 変更可能な配列型::

---------- Footnotes ----------

(1)
パーザが被演算子の型を識別できるようにするために、このような優先度でなければならないのです。


File: python-lib-jp.info,  Node: 文字列メソッド,  Next: 文字列フォーマット操作,  Prev: 配列型,  Up: 配列型

文字列メソッド
..............

以下は 8 ビット文字列および Unicode オブジェクトでサポートされる
メソッドです:

`capitalize()'
     最初の文字を大文字にした文字列のコピーを返します。

     このメソッドの挙動は8
     ビット文字列に対してはロケール依存になります。

`center(width)'
     WIDTH の長さをもつ中央寄せされた文字列を返します。パディングには
     空白が使われます。

`count(sub[, start[, end]])'
     文字列 S`[START:END]' 中に部分文字列 SUB
     が出現する回数を返します。オプション引数 START および END
     はスライス表記と同じように解釈されます。

`decode([encoding[, errors]])'
     codec に登録された文字コード系 ENCODING を使って文字列をデコード
     します。ENCODING は標準でデフォルトの文字列エンコーディング
     になります。標準とは異なるエラー処理を行うために ERRORS を
     与えることができます。標準のエラー処理は `'strict'' で、エンコード
     に関するエラーは `ValueError' を送出します。 他に利用できる値は
     `'ignore'' および `'replace'' です。 _Added in Python version 2.2_

`encode([encoding[,errors]])'
     文字列のエンコードされたバージョンを返します。標準のエンコーディング
     は現在のデフォルト文字列エンコーディングです。
     標準とは異なるエラー処理を行うために ERRORS を
     与えることができます。標準のエラー処理は `'strict'' で、エンコード
     に関するエラーは `ValueError' を送出します。 他に利用できる値は
     `'ignore'' および `'replace'' です。 _Added in Python version 2.0_

`endswith(suffix[, start[, end]])'
     文字列の一部が SUFFIX で終わるときに `True' を返します。そう
     でない場合 `False' を返します。オプション引数 START がある場
     合、文字列の START から比較を始めます。END がある場合、文字 列の
     END で比較を終えます。

`expandtabs([tabsize])'
     全てのタブ文字が空白で展開された文字列のコピーを返します。 TABSIZE
     が与えられていない場合、タブ幅は `8' 文字分 と仮定します。

`find(sub[, start[, end]])'
     文字列中の領域 [START, END) に SUB が含まれる場合、
     その最小のインデクスを返します。 オプション引数 START および END
     はスライス表記と 同様に解釈されます。SUB が見つからなかった場合
     `-1' を返します。

`index(sub[, start[, end]])'
     `find()' と同様ですが、SUB が見つからなかった場合 `ValueError'
     を送出します。

`isalnum()'
     文字列中の全ての文字が英数文字で、かつ 1
     文字以上ある場合には真を返し、 そうでない場合は偽を返します。

     このメソッドの挙動は8
     ビット文字列に対してはロケール依存になります。

`isalpha()'
     文字列中の全ての文字が英文字で、かつ 1
     文字以上ある場合には真を返し、 そうでない場合はを返します。

     このメソッドの挙動は8
     ビット文字列に対してはロケール依存になります。

`isdigit()'
     文字列中に数字しかない場合には真を返し、その他の場合は偽を返します。

     このメソッドの挙動は8
     ビット文字列に対してはロケール依存になります。

`islower()'
     文字列中の大小文字の区別のある文字全てが小文字で、かつ 1 文字以上
     ある場合には真を返し、そうでない場合は偽を返します。

     このメソッドの挙動は8
     ビット文字列に対してはロケール依存になります。

`isspace()'
     文字列が空白文字だけからなり、かつ 1 文字以上ある場合には真を返し、
     そうでない場合は偽を返します。

     このメソッドの挙動は8
     ビット文字列に対してはロケール依存になります。

`istitle()'
     文字列がタイトルケース文字列であり、かつ 1 文字以上ある場合、
     すなわち大文字は大小文字の区別のない文字の後にのみ続き、
     小文字は大小文字の区別のある文字の後ろにのみ続く場合には真を返します。
     そうでない場合は偽を返します。

     このメソッドの挙動は8
     ビット文字列に対してはロケール依存になります。


`isupper()'
     文字列中の大小文字の区別のある文字全てが大文字で、かつ 1 文字以上
     ある場合には真を返し、そうでない場合は偽を返します。

     このメソッドの挙動は8
     ビット文字列に対してはロケール依存になります。

`join(seq)'
     配列 SEQ 中の文字列を結合した文字列を返します。文字列を
     結合するときの区切り文字は、このメソッドを適用する対象の文字列に
     なります。

`ljust(width)'
     WIDTH の長さをもつ左寄せした文字列を返します。
     パディングには空白が使われます。WIDTH が `len(S)'
     よりも小さい場合、元の文字列が返されます。

`lower()'
     文字列をコピーし、小文字に変換して返します。

     このメソッドの挙動は8
     ビット文字列に対してはロケール依存になります。

`lstrip([chars])'
     文字列をコピーし、文字列の先頭部分を除去して返します。 CHARS
     が省略されるか `None' の場合、空白文字が 除去されます。CHARS
     が与えられていてかつ `None' でない場合、CHARS
     は文字列でなければなりません;
     このメソッドを適用した対象の文字列の先頭部分から CHARS 中の
     文字が除去されます。 _Changed in Python version 2.2.2_

`replace(old, new[, count])'
     文字列をコピーし、部分文字列 OLD のある部分全てを NEW
     に置換して返します。オプション引数 COUNT が与えられて
     いる場合、先頭から COUNT 個の OLD だけを置換します。

`rfind(sub [,start [,end]])'
     文字列中の領域 [START, END) に SUB が含まれる場合、
     その最大のインデクスを返します。 オプション引数 START および END
     はスライス表記と 同様に解釈されます。SUB が見つからなかった場合
     `-1' を返します。

`rindex(sub[, start[, end]])'
     `find()' と同様ですが、SUB が見つからなかった場合 `ValueError'
     を送出します。

`rjust(width)'
     WIDTH の長さをもつ右寄せした文字列を返します。
     パディングには空白が使われます。WIDTH が `len(S)'
     よりも小さい場合、元の文字列が返されます。

`rstrip([chars])'
     文字列をコピーし、文字列の末尾部分を除去して返します。 CHARS
     が省略されるか `None' の場合、空白文字が 除去されます。CHARS
     が与えられていてかつ `None' でない場合、CHARS
     は文字列でなければなりません;
     このメソッドを適用した対象の文字列の末端部分から CHARS 中の
     文字が除去されます。 _Changed in Python version 2.2.2_

`split([sep [,maxsplit]])'
     SEP を単語の境界として文字列を単語に分割し、分割された単語
     からなるリストを返します。MAXSPLIT が与えられた場合、最大 で
     MAXSPLIT 個になるように分割します (従って、リストは最大で
     `MAXSPLIT+1' 個の要素を 持つことになります)。MAXSPLIT
     を省略したりゼロにした場合、 分割の個数は無制限
     (できる限りの分割を行う) になります。
     デリミタが連続している場合には、デリミタ同士をグループ化せず、
     空文字列に対する分割であるとみなします (たとえば
     `'1,,2'.split(',')' は `['1', '', '2']' を返します)。 SEP
     引数は複数文字からなる文字列にできます (たとえば、 `'1, 2,
     3'.split(', ')' は `['1', '2', '3']'
     を返します)。分割文字列を指定して空文字列に対する分割を行うと
     空のリストを返します。 SEP を省略したり `None'
     にした場合、通常とは違った
     分割アルゴリズムを適用します。この場合、各語は任意の長さの
     空白文字 (スペース、タブ、改行、復帰、行送り) からなる文字列
     で分割されます。連続する空白文字は単一のデリミタとして扱われ ます
     (`'1   2  3'.split()' は `['1', '2', '3']' を返します)。
     空の文字列を分割すると `['']' を返します。

`splitlines([keepends])'
     文字列を改行部分で分解し、各行からなるリストを返します。 KEEPENDS
     が与えられていて、かつその値が真でない限り、
     返されるリストには改行文字は含まれません。

`startswith(prefix[, start[, end]])'
     文字列の一部が PREFIX で始まるときに `True' を返します。そう
     でない場合 `False' を返します。オプション引数 START がある場
     合、文字列の START から比較を始めます。END がある場合、文字 列の
     END で比較を終えます。

`strip([chars])'
     文字列をコピーし、文字列の先頭および末尾部分を除去して返します。
     CHARS が省略されるか `None' の場合、空白文字が 除去されます。CHARS
     が与えられていてかつ `None' でない場合、CHARS
     は文字列でなければなりません;
     このメソッドを適用した対象の文字列の両端から CHARS 中の
     文字が除去されます。 _Changed in Python version 2.2.2_

`swapcase()'
     文字列をコピーし、大文字は小文字に、小文字は大文字に変換して返します。
     このメソッドの挙動は8
     ビット文字列に対してはロケール依存になります。

`title()'
     文字列をタイトルケースにして返します: 大文字から始まり、残りの
     文字のうち大小文字の区別があるものは全て小文字にします。

     このメソッドの挙動は8
     ビット文字列に対してはロケール依存になります。

`translate(table[, deletechars])'
     文字列をコピーし、オプション引数の文字列 DELETECHARS の中に
     含まれる文字を全て除去します。その後、残った文字を変換テーブル
     TABLE に従ってマップして返します。変換テーブルは長さ 256
     の文字列でなければなりません。

     Unicode オブジェクトの場合、`translate()' メソッドはオプションの
     DELETECHARS 引数を受理しません。その代わり、メソッドは
     すべての文字が与えられた変換テーブルで対応付けされている S の
     コピーを返します。この変換テーブルは Unicode 順 (ordinal) から
     Unicode 順、Unicode 文字列、または `None' への対応付け
     でなくてはなりません。対応付けされていない文字は何もせず放置されます。
     `None' に対応付けられた文字は削除されます。ちなみに、
     より柔軟性のあるアプローチは、自作の文字対応付けを行う codec を
     `codecs' モジュールを使って作成することです (例えば
     `encodings.cp1251' を参照してください。

`upper()'
     文字列をコピーし、大文字に変換して返します。

     このメソッドの挙動は8
     ビット文字列に対してはロケール依存になります。

`zfill(width)'
     数値文字列の左側をゼロ詰めし、幅 WIDTH にして返します。 WIDTH が
     `len(S)' よりも短い場合もとの文字列自体が 返されます。 _Added in
     Python version 2.2.2_


File: python-lib-jp.info,  Node: 文字列フォーマット操作,  Next: XRange 型,  Prev: 文字列メソッド,  Up: 配列型

文字列フォーマット操作
......................

文字列および Unicode オブジェクトには固有の操作: `%' 演算子 (モジュロ)
があります。この演算子は文字列 _フォーマット化_ または _補間_
演算としても知られています。 `FORMAT % VALUES' (FORMAT は文字列または
Unicode オブジェクト)とすると、FORMAT 中の `%' 変換指定は VALUES
中のゼロ個またはそれ以上の要素で置換されます。 この動作は C
言語における `sprintf()' に似ています。 FORMAT が Unicode
オブジェクトであるか、または `%s' 変換を使って Unicode
オブジェクトが変換される場合、その結果も Unicode
オブジェクトになります。

FORMAT が単一の引数しか要求しない場合、VALUES は
タプルでない単一のオブジェクトでもかまいません。 (1)
それ以外の場合、VALUES はフォーマット文字列中で指定された項目と
正確に同じ数の要素からなるタプルか、単一のマップオブジェクトでなければ
なりません。

一つの変換指定子は 2 またはそれ以上の文字を含み、その構成要素は
以下からなりますが、示した順に出現しなければなりません:

  1. 変換指定子が開始することを示す文字 `%'。

  2. マップキー (オプション)。 丸括弧で囲った文字配列からなります
     (例えば `(someone)') 。

  3. 変換フラグ (オプション)。一部の変換型の結果に影響します。

  4. 最小のフィールド幅 (オプション).  `*' (アスタリスク)
     を指定した場合、実際の文字列幅が VALUES タプルの次の要素から読み
     出されます。タプルには最小フィールド幅やオプションの精度指定の後に
     変換したいオブジェクトがくるようにします。

  5. 精度 (オプション)。`.' (ドット) とその後に続く精度
     で与えられます。`*' (アスタリスク) を指定した場合、精度
     の桁数はタプルの次の要素から読み出されます。タプルには精度指定の
     後に変換したい値がくるようにします。

  6. 精度長変換子 (オプション)。

  7. 変換型。

`%' 演算子の右側の引数が辞書の場合 (またはその他のマップ型の場合)、
文字列中のフォーマットには、辞書に挿入されているキーを丸括弧で囲い、文字
`%' の直後にくるようにしたものが含まれていなければ _なりません_
。マップキーはフォーマット化したい値をマップから 選び出します。例えば:

     >>> print '%(language)s has %(#)03d quote types.' % \
               {'language': "Python", "#": 2}
     Python has 002 quote types.

この場合、 `*' 指定子をフォーマットに含めてはいけません (`*'
指定子は順番付けされたパラメタのリストが必要だからです。)

変換フラグ文字を以下に示します:

フラグ                               意味
------                               -----
#                                    値の変換に (下で定義されている)
                                     "別の形式" を使います。
0                                    数値型に対してゼロによるパディングを行います。
-                                    変換された値を左寄せにします (`0'
                                     と同時に与えた 場合、`0'
                                     を上書きします) 。
{~}                                  (スペース)
                                     符号付きの変換で正の数の場合、前に一つスペースを空けます
                                     (そうでない場合は空文字になります)	。
+                                    変換の先頭に符号文字 (`+' または
                                     `-') を付けます("スペース"
                                     フラグを上書きします) 。

精度長変換子として、`h' 、 `l' 、および `L' を使う
ことができますが、Python では必要ないため無視されます。

変換型を以下に示します:

変換                     意味                     注釈
------                   -----                    -----
d                        符号付き 10 進整数。     
i                        符号付き 10 進整数。     
o                        符号なし 8 進数。        (1)
u                        符号なし 10 進数。       
x                        符号なし 16 進数         (2)
                         (小文字)。               
X                        符号なし 16 進数         (2)
                         (大文字)。               
e                        指数表記の浮動小数点数   
                         (小文字).                
E                        指数表記の浮動小数点数   
                         (大文字).                
f                        10 進浮動小数点数。      
F                        10 進浮動小数点数。      
g                        指数部が -4              
                         以上または精度以下の場合には
                         `e'                      
                         、それ以外の場合には     
                         `f' と同じ。             
G                        指数部が -4              
                         以上または精度以下の場合には
                         `E'                      
                         、それ以外の場合には     
                         `F' と同じ。             
c                        文字一文字               
                         (整数または一文字からなる文字列を受理します)。
r                        文字列 (python           (3)
                         オブジェクトを `repr()'  
                         で変換します)。          
s                        文字列 (python           (4)
                         オブジェクトを `str()'   
                         で変換します)。          
%                        引数を変換せず、返される文字列中では文字
                         `%' になります。         

注釈:
`(1)'
     別形式の出力にした場合、変換結果の先頭の数字がゼロ (`0')
     でないときには、数字の先頭と左側のパディングとの間にゼロを挿入します。

`(2)'
     別形式にした場合、変換結果の先頭の数字がゼロでないときには、
     数字の先頭と左側のパディングとの間に `'0x'' または `'0X''
     (フォーマット文字が `x' か `X' かに依存します) が挿入されます。

`(3)'
     `%r' 変換は Python 2.0 で追加されました。

`(4)'
     オブジェクトや与えられた書式が `unicode'
     文字列の場合、変換後の文字列も `unicode' になります。

Python 文字列には明示的な長さ情報があるので、`%s' 変換において `'\0''
を文字列の末端と仮定したりはしません。

安全上の理由から、浮動小数点数の精度は 50 桁でクリップされます;
絶対値が 1e25 を超える値の `%f' による変換は `%g' 変換で置換されます (2)
その他のエラーは例外を送出します。

その他の文字列操作は標準モジュール `string'  および `re'.
で定義されています。

---------- Footnotes ----------

(1)
従って、一個のタプルだけをフォーマット出力したい場合には出力したいタプルを唯一の要素とする単一のタプルを
VALUES に与えなくてはなりません。

(2) この範囲に関する値はかなり適当なものです。
この仕様は、正しい使い方では障害とならず、かつ特定のマシンにおける
浮動小数点数の正確な精度を知らなくても、際限なく長くて意味のない数字から
なる文字列を印字しないですむようにするためのものです。


File: python-lib-jp.info,  Node: XRange 型,  Next: 変更可能な配列型,  Prev: 文字列フォーマット操作,  Up: 配列型

XRange 型
.........

xrange  型は値の変更不能な配列で、広範なループ処理に
使われています。xrange 型の利点は、 xrange オブジェクトは表現する
値域の大きさに関わらず常に同じ量のメモリしか占めないということです。
はっきりしたパフォーマンス上の利点はありません。

XRange
オブジェクトは非常に限られた振る舞い、すなわち、インデクス検索、反復、
`len()' 関数のみをサポートしています。


File: python-lib-jp.info,  Node: 変更可能な配列型,  Prev: XRange 型,  Up: 配列型

変更可能な配列型
................

リストオブジェクトはオブジェクト自体の変更を可能にする追加の操作を
サポートします。他の変更可能な配列型 (を言語に追加する場合) も、
それらの操作をサポートしなければなりません。
文字列およびタプルは変更不可能な配列型です: これらのオブジェクトは
一度生成されたらそのオブジェクト自体を変更することができません。
以下の操作は変更可能な配列型で定義されています (ここで X は
任意のオブジェクトとします):

操作                     結果                     注釈
------                   -----                    -----
S[I] = X                 S の要素 S を X          
                         と入れ替えます           
S[I:J] = T               S の I から J            
                         番目までの要素を T       
                         と入れ替えます           
del S[I:J]               `S[I:J] = []'            
                         と同じです               
S[I:J:K] = T             `S[I:J:K]' の要素を T    (1)
                         と入れ替えます           
del S[I:J:K]             リストから `S[I:J:K]'    
                         の要素を削除します       
S.append(X)              `S[len(S):len(S)] =      (2)
                         [X]' と同じです          
S.extend(X)              `S[len(S):len(S)] = X'   (3)
                         と同じです               
S.count(X)               `S[I] == X' となる I     
                         の個数を返します         
S.index(X[, I[, J]])     `S[K] == X' かつ `I <=   (4)
                         K < J' となる最小の K    
                         を返します。             
S.insert(I, X)           `I >= 0' の場合の        (5)
                         `S[I:I] = [X]'           
                         と同じです               
S.pop([I])               `X = S[I]; del S[I];     (6)
                         return X' と同じです     
S.remove(X)              `del S[S.index(X)]'      (4)
                         と同じです               
S.reverse()              S                        (7)
                         の値の並びを反転します   
S.sort([CMPFUNC=NONE])   S の要素を並べ替えます   (7), (8), (9), (10)

{types}

Notes:
`(1)'
     T は入れ替えるスライスと同じ長さでなければいけません。

`(2)'
     かつての Python の C 実装では、複数パラメタを受理し、
     非明示的にそれらをタプルに結合していました。この間違った機能は
     Python 1.4 で廃用され、Python 2.0 の導入とともにエラーにする
     ようになりました。

`(3)'
     X がリストオブジェクトでない場合、例外を送出します。 `extend()'
     は実験的なメソッドであり、リスト以外の変更可能な
     配列型ではサポートされていません。

`(4)'
     X が S 中に見つからなかった場合 `ValueError' を送出します。　
     負のインデクスが二番目または三番目のパラメタとして `index()'
     メソッドに渡されると、これらの値にはスライスのインデクスと同様に
     リストの長さが加算されます。加算後もまだ負の場合、その値はスライス
     のインデクスと同様にゼロに切り詰められます。 _Changed in Python
     version 2.3_

`(5)'
     `insert()'
     の最初のパラメタとして負のインデクスが渡された場合、スライスのインデクスと同じく、リストの長さが加算されます。それでも負の値を取る場合、スライスのインデクスと同じく、0
     に丸められます。_Changed in Python version 2.3_

`(6)'
     `pop()' メソッドはリストおよびアレイ型のみでサポート
     されています。オプションの引数 I は標準で `-1' なので、
     標準では最後の要素をリストから除去して返します。

`(7)'
     `sort()' および `reverse()' メソッドは
     大きなリストを並べ替えたり反転したりする際、容量の節約のために
     リストを直接変更します。副作用があることをユーザに思い出させるために、
     これらの操作は並べ替えまたは反転されたリストを返しません。

`(8)'
     `sort()' メソッドはオプションの引数として比較関数
     をとります。この比較関数は二つの引数 (list items)
     をとり、最初の引数
     が二つ目の引数と比べてより小さいか、等しいか、より大きいかによって、
     それぞれ負、ゼロ、正の値を返します。この指定は並べ替え
     処理をかなり低速化するので注意してください;

     たとえば、リストを逆順に並べ替えるためにには、要素を反転して順序づけする
     ような比較関数で `sort()' を使うより、`sort()' の後に `reverse()'
     を呼ぶほうがはるかに高速です。比較関数として `None'
     を渡すことは、比較関数なしで `sort()' を呼ぶのと 同じ意味です。
     _Changed in Python version 2.3_

     `sort()' メソッドに CMPFUNC
     引数を使う例として、シーケンスのリストを、シーケンスの 2
     つ目の要素でソートする場合を考えてみましょう。

          def mycmp(a, b):
              return cmp(a[1], b[1])
          
          mylist.sort(mycmp)

     それなりにサイズの大きいデータ構造に対しては、より時間効率のよいアプローチが、頻繁に使われます。

          tmplist = [(x[1], x) for x in mylist]
          tmplist.sort()
          mylist = [x for (key, x) in tmplist]

`(9)'
     `sort()' メソッドが安定しているかどうかは
     言語上では定義されていません (比較結果が等しい要素の相対的な位置を
     変えないことを保証しているとき、並べ替えが安定しているといいます)。
     Python の C 実装では、Python 2.2 まで並べ替えはただ偶然に安定
     していました。Python 2.3 の C 実装は安定な `sort()' メソッド
     を導入しましたが、異なる Python
     の実装間やバージョンの間での可搬性を
     見込んだコードでは、この安定性に依存してはいけません。

`(10)'
     リストが並べ替えられている間は、リストの変更はもとより、
     その値の閲覧すらその結果は未定義です。

     Python 2.3 の C 実装では、この間リストは空に見えるようになり、
     並べ替え中にリストが変更されたことが検出されると `ValueError'
     が送出されます。


File: python-lib-jp.info,  Node: マップ型,  Next: ファイルオブジェクト,  Prev: 配列型,  Up: 組み込み型

マップ型
--------

"mapping" オブジェクトは変更不可能な値を任意のオブジェクトに
対応付けます。対応付け事態は変更可能なオブジェクトです。
現在のところは標準のマップ型、"dictionary" だけです。
辞書のキーにはほとんど任意の値をつかうことができます。使うことが
できないのはリスト、辞書、その他の変更可能な型 (オブジェクトの一致
ではなく、その値で比較されるような型) です。
キーに使われた数値型は通常の数値比較規則に従います: 二つの数字を
比較した時等価であれば (例えば `1' と `1.0' のように)、
これらの値はお互いに同じ辞書のエントリを示すために使うことが できます。

辞書は `KEY: VALUE' からなるペアを
カンマで区切ったリストを波括弧の中に入れて作ります。 例えば: `{'jack':
4098, 'sjoerd': 4127}' または `{4098: 'jack', 4127: 'sjoerd'}' です。

以下の操作がマップ型で定義されています (ここで、A および B
はマップ型で、K はキー、 V および X は任意の オブジェクトです):

操作                     結果                     注釈
------                   -----                    -----
len(A)                   A 内の要素の数です       
A[K]                     キー K を持つA           (1)
                         の要素です               
A[K] = V                 `A[K]' を V              
                         に設定します             
del A[K]                 A から `A[K]'            (1)
                         を削除します             
A.clear()                `a'                      
                         から全ての要素を削除します
A.copy()                 `a' の(浅い)コピーです   
A.has_key(K)             A にキー K があれば      
                         `True' 、                
                         そうでなければ `False'   
                         です                     
K `in' A                 A.has_key(K) と同じです  (2)
K not in A               `not' A.has_key(K)       (2)
                         と同じです               
A.items()                A における (KEY, VALUE)  (3)
                         ペアのリストのコピーです 
A.keys()                 A                        (3)
                         におけるキーのリストのコピーです
A.update(B)              `for K in B.keys():      
                         A[k] = B[k]'             
A.fromkeys(SEQ[,         SEQ                      (7)
VALUE])                  からキーを作り、値が     
                         VALUE                    
                         であるような、新しい辞書を作成します
A.values()               A                        (3)
                         における値のリストのコピーです
A.get(K[, X])            `A[K]' if `K in A',      (4)
                         else X                   
A.setdefault(K[, X])     `A[K]' if `K in A',      (5)
                         else X (also setting     
                         it)                      
A.pop(K[, X])            `A[K]' if `K in A',      (8)
                         else X (and remove k)    
A.popitem()              任意の (KEY, VALUE)      (6)
                         ペアを除去して返します   
A.iteritems()            (KEY, VALUE)             (2), (3)
                         ペアにわたるイテレータを返します
A.iterkeys()             マップのキー列にわたるイテレータを返します(2), (3)
A.itervalues()           マップの値列にわたるイテレータを返します(2), (3)

注釈:
`(1)'
     K がマップ内にない場合、例外 `KeyError' を 送出します。

`(2)'
     _Added in Python version 2.2_

`(3)'
     キー及び値はランダムな順番でリストになっています。
     途中で辞書を変更せずに `items()'、 `keys()'、 `values()'、
     `iteritems()'、 `iterkeys()'、 and `itervalues()'
     を呼んだ場合、返されるリストは直接対応しています。これにより、
     `(VALUE, KEY)' のペアを `zip()' を 使って: `pairs =
     zip(A.values(), A.keys())'
     のように生成することができます。`iterkeys()' および `itervalues()'
     メソッドの間でも同じ関係が成り立ちます: `pairs =
     zip(A.itervalues(), A.iterkeys())' は `pairs' と同じ値になります。
     同じリストを生成するもう一つの方法は `pairs = [(v, k) for (k, v)
     in A.iteritems()]' です。

`(4)'
     K がマップ中になくても例外を送出せず、代わりに X を返します。X
     はオプションです; X が与えられて おらず、かつ K
     がマップ中になければ、 `None' が返されます。

`(5)'
     `setdefault()' は `get()' に似ていますが、 K
     が見つからなかった場合、X が返されると同時に辞書の K
     に対する値として挿入されます。

`(6)'
     `popitem()' は、集合アルゴリズムでよく行われる
     ような、辞書を取り崩しながらの反復を行うのに便利です。

`(7)'
     `fromkeys()' は、新しい辞書を返すクラスメソッドです。 VALUE
     のデフォルト値は `None' です。 _Added in Python version 2.3_

`(8)'
     `pop()'
     は、デフォルト値が渡されず、かつ、キーが見つからない場合に、
     `KeyError' を送出します。 _Added in Python version 2.3_

