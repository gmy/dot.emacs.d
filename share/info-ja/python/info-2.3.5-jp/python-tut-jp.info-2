This is python-tut-jp.info, produced by makeinfo version 4.5 from
python-tut-jp.texi.

12 October 2005


File: python-tut-jp.info,  Node: 関数を定義する,  Next: 関数定義についてもう少し,  Prev: pass 文,  Up: その他の制御フローツール

関数を定義する
==============

フィボナッチ数列 (Fibonacci series) を任意の上限値まで書き出すような
関数を作成できます:

     >>> def fib(n):    # n までのフィボナッチ級数を出力する
     ...     """Print a Fibonacci series up to n."""
     ...     a, b = 0, 1
     ...     while b < n:
     ...         print b,
     ...         a, b = b, a+b
     ...
     >>> # 今しがた定義した関数を呼び出す:
     ... fib(2000)
     1 1 2 3 5 8 13 21 34 55 89 144 233 377 610 987 1597

`def' は関数の_定義 (definition)_ を導くキーワードです。 `def'
の後には、関数名と仮引数 (formal parameter) を
丸括弧で囲んだリストを続けなければなりません。関数の実体を
校正する実行文は次の行から始め、インデントされていなければなりません。
関数の本体の記述する文の最初の行は文字列リテラルにすることもできます;
その場合、文字列は関数の ドキュメンテーション文字列 (documentation
string) 、または "docstring"

です。

ドキュメンテーション文字列を使ったツールには、オンライン文書や
印刷文書を自動的に生成したり、ユーザが対話的にコードを閲覧できる
ようにするものがあります; 自分が書くコードにドキュメンテーション
文字列を入れるのはよい習慣です。書く癖をつけるようにしてください。

関数を _実行 (execution)_ すると、関数のローカル変数のために
使われる新たなシンボルテーブル (symbol table) が取り込まれます。
もっと正確にいうと、関数内で変数への代入を行うと、その値はすべて
このローカルなシンボルテーブルに記憶されます; 一方、変数の参照を
行うと、まずローカルなシンボルテーブルが検索され、その後グローバル
なシンボルテーブルを調べ、最後に組み込みの名前テーブルを調べます。
従って、関数の中では、グローバルな変数を参照することはできますが、
直接値を代入することは (`global' 文で名前を挙げておかない限り)
できません。

関数を呼び出す際の実際のパラメタ (引数) は、関数が呼び出されるときに
関数のローカルなシンボルテーブル内に取り込まれます; そうすることで、
引数は _値渡し (call by value)_ で関数に渡されることになります
(ここでの _値 (value)_ とは常にオブジェクトへの _参照 (reference)_
をいい、オブジェクトの値そのものでは ありません) (1) 。
ある関数がほかの関数を呼び出すときには、新たな呼び出しのために
ローカルなシンボルテーブルが新たに作成されます。

関数の定義を行うと、関数名は現在のシンボルテーブル内に取り入れられます。
関数名の値は、インタプリタからはユーザ定義関数 (user-defined function)
として認識される型を持ちます。この値は別の名前に代入して、
その名前を後に関数として使うこともできます。
これは一般的な名前変更のメカニズムとして働きます。

     >>> fib
     <function fib at 10042ed0>
     >>> f = fib
     >>> f(100)
     1 1 2 3 5 8 13 21 34 55 89

`fib' は関数ではなく手続き (procedure) だと異論があるかも
しれませんね。Python では C 言語と同様、手続きはただの関数で、
値を返さないに過ぎません。技術的に言えば、実際には手続きも
ややつまらない値ですが値を返しています。この値は `None' と呼ばれます
(これは組み込みの名前です)。`None' だけを
書き出そうとすると、インタプリタは通常出力を抑制します。
本当に出力したいのなら、以下のようにすると見ることができます:

     >>> print fib(0)
     None

フィボナッチ数列の数からなるリストを出力する代わりに、値を返すような
関数を書くのは簡単です:

     >>> def fib2(n): #  n までのフィボナッチ級数を返す
     ...     """Return a list containing the Fibonacci series up to n."""
     ...     result = []
     ...     a, b = 0, 1
     ...     while b < n:
     ...         result.append(b)    # 下記参照
     ...         a, b = b, a+b
     ...     return result
     ...
     >>> f100 = fib2(100)    # 関数を呼び出す
     >>> f100                # 結果を出力する
     [1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89]

例によって、この例は Python の新しい機能を示しています:

   * `return' 文では、関数から一つ値を返します。 `return'
     の引数となる式がない場合、 `None' が返ります。
     手続きが終了したときにも `None' が返ります。

   * 文 `result.append(b)' では、リストオブジェクト `result' の
     _メソッド (method)_ を呼び出しています。
     メソッドとは、オブジェクトに `属している' 関数のことで、 `obj'
     を何らかのオブジェクト (式であっても構いません)、 `methodname'
     をそのオブジェクトで定義されているメソッド名
     とすると、`obj.methodname' と書き表されます。
     異なる型は異なるメソッドを定義しています。異なる型のメソッドで
     同じ名前のメソッドを持つことができ、あいまいさを生じることはありません。
     (自前のオブジェクト型とメソッドを定義することもできます。これには、
     後でこのチュートリアルで述べる _クラス (class)_ を使います。)
     例で示されているメソッド `append()' は、リストオブジェクトで
     定義されています;
     このメソッドはリストの末尾に新たな要素を追加します。 この例での
     `append()' は `result = result + [b]' と等価
     ですが、より効率的です。


---------- Footnotes ----------

(1)  実際には、_オブジェクトへの参照渡し (call by object reference) _
と書けばよいのかもしれません。というのは、変更可能なオブジェクトが
渡されると、関数の呼び出し側は、呼び出された側の関数がオブジェクト に
(リストに値が挿入されるといった) 何らかの変更に出くわすことに
なるからです。


File: python-tut-jp.info,  Node: 関数定義についてもう少し,  Prev: 関数を定義する,  Up: その他の制御フローツール

関数定義についてもう少し
========================

可変個の引数を伴う関数も定義できます。引数の定義方法には 3
つの形式があり、それらを組み合わせられます。

* Menu:

* デフォルトの引数値::
* キーワード引数::
* 任意引数リスト::
* 引数リストのアンパック::
* ラムダ形式::
* ドキュメンテーション文字列::


File: python-tut-jp.info,  Node: デフォルトの引数値,  Next: キーワード引数,  Prev: 関数定義についてもう少し,  Up: 関数定義についてもう少し

デフォルトの引数値
------------------

もっとも便利なのは、一つ以上の引数に対してデフォルトの値を指定する
形式です。この形式を使うと、定義されている引数より少ない個数の引数
で呼び出せる関数を作成します:

     def ask_ok(prompt, retries=4, complaint='Yes or no, please!'):
         while True:
             ok = raw_input(prompt)
             if ok in ('y', 'ye', 'yes'): return True
             if ok in ('n', 'no', 'nop', 'nope'): return False
             retries = retries - 1
             if retries < 0: raise IOError, 'refusenik user'
             print complaint

この関数は、 `ask_ok('Do you really want to quit?')' のようにも、
`ask_ok('OK to overwrite the file?', 2)' のようにも呼び出せます。
上の例では、予約語 `in' も紹介しています。 `in'
は、配列中に特定の値が存在するかどうかの判定結果を 返します。

デフォルト値は、関数が定義された時点で、関数を _定義している_ 側の
スコープ (scope) で評価されるので、

     i = 5
     
     def f(arg=i):
         print arg
     
     i = 6
     f()

は `5' を出力します。

*重要な警告:*  デフォルト値は 1 度だけしか評価されません。
デフォルト値がリストや辞書のような変更可能なオブジェクトの時には
その影響がでます。例えば以下の関数は、後に続く関数呼び出しで
関数に渡されている引数を累積します:

     def f(a, L=[]):
         L.append(a)
         return L
     
     print f(1)
     print f(2)
     print f(3)

このコードは、

     [1]
     [1, 2]
     [1, 2, 3]

を出力します。

後続の関数呼び出しでデフォルト値を共有したくなければ、
代わりに以下のように関数を書くことができます:

     def f(a, L=None):
         if L is None:
             L = []
         L.append(a)
         return L


File: python-tut-jp.info,  Node: キーワード引数,  Next: 任意引数リスト,  Prev: デフォルトの引数値,  Up: 関数定義についてもう少し

キーワード引数
--------------

関数を `KEYWORD = VALUE' という形式のキーワード引数を
使って呼び出すこともできます。例えば、以下の関数:

     def parrot(voltage, state='a stiff', action='voom', type='Norwegian Blue'):
         print "-- This parrot wouldn't", action,
         print "if you put", voltage, "Volts through it."
         print "-- Lovely plumage, the", type
         print "-- It's", state, "!"

は、以下のいずれの方法でも呼び出せます:

     parrot(1000)
     parrot(action = 'VOOOOOM', voltage = 1000000)
     parrot('a thousand', state = 'pushing up the daisies')
     parrot('a million', 'bereft of life', 'jump')

しかし、以下の呼び出しはすべて不正なものです:

     parrot()                     # 必要な引数がない
     parrot(voltage=5.0, 'dead')  # キーワード引数の後に非キーワード引数がある
     parrot(110, voltage=220)     # 引数に対して値が重複している
     parrot(actor='John Cleese')  # 未知のキーワードを使用している

一般に、引数リストでは、固定引数 (positional argument) の後ろに
キーワード引数を置かねばならず、キーワードは仮引数名から選ばなければ
なりません。仮引数がデフォルト値を持っているかどうかは重要では
ありません。引数はいずれも一つ以上の値を受け取りません --
同じ関数呼び出しの中では、固定引数に対応づけられた仮引数名を
キーワードとして使うことはできません。この制限のために
実行が失敗する例を以下に示します。

     >>> def function(a):
     ...     pass
     ...
     >>> function(0, a=0)
     Traceback (most recent call last):
       File "<stdin>", line 1, in ?
     TypeError: function() got multiple values for keyword argument 'a'

仮引数の最後に `**NAME' の形式のものがあると、
仮引数に対応しないすべてのキーワード引数が入った 辞書 を受け取ります。
`**NAME' は `*NAME' の形式をとる、仮引数のリスト
を超えた固定引数の入ったタプルを受け取る引数 (次の節で述べます)
と組み合わせることができます。 (`*NAME' は `**NAME'
より前になければなりません)。 例えば、ある関数の定義を以下:

     def cheeseshop(kind, *arguments, **keywords):
         print "-- Do you have any", kind, '?'
         print "-- I'm sorry, we're all out of", kind
         for arg in arguments: print arg
         print '-'*40
         keys = keywords.keys()
         keys.sort()
         for kw in keys: print kw, ':', keywords[kw]

のようにすると、呼び出しは以下:

     cheeseshop('Limburger', "It's very runny, sir.",
                "It's really very, VERY runny, sir.",
                client='John Cleese',
                shopkeeper='Michael Palin',
                sketch='Cheese Shop Sketch')

のようになり、もちろん以下のように出力されます:

     -- Do you have any Limburger ?
     -- I'm sorry, we're all out of Limburger
     It's very runny, sir.
     It's really very, VERY runny, sir.
     ----------------------------------------
     client : John Cleese
     shopkeeper : Michael Palin
     sketch : Cheese Shop Sketch

キーワード引数名のリストに対して `sort()' を呼び出した後に `keywords'
辞書の内容を出力していることに注意してください; `sort()'
が呼び出されていないと、引数が出力される順番は 不確定となります。


File: python-tut-jp.info,  Node: 任意引数リスト,  Next: 引数リストのアンパック,  Prev: キーワード引数,  Up: 関数定義についてもう少し

任意引数リスト
--------------

最後に、最も使うことの少ない選択肢として、関数が任意の個数の引数で
呼び出せるよう指定する方法があります。これらの引数はタプルに
くるまれます。可変個の引数の前に、ゼロ個かそれ以上の引数があっても
構いません。

     def fprintf(file, format, *args):
         file.write(format % args)


File: python-tut-jp.info,  Node: 引数リストのアンパック,  Next: ラムダ形式,  Prev: 任意引数リスト,  Up: 関数定義についてもう少し

引数リストのアンパック
----------------------

引数がすでにリストやタプルになっていて、個別な固定引数を要求する
関数呼び出しに渡すためにアンパックする必要がある場合には、逆の
状況が起こります。例えば、組み込み関数 `range()' は 引数 START と STOP
を別に与える必要があります。
個別に引数を与えることができない場合、関数呼び出しを `*'
演算子を使って書き、リストやタプルから引数をアンパック します:

     >>> range(3, 6)             # 個別の引数を使った通常の呼び出し
     [3, 4, 5]
     >>> args = [3, 6]
     >>> range(*args)            # リストからアンパックされた引数での呼び出し
     [3, 4, 5]


File: python-tut-jp.info,  Node: ラムダ形式,  Next: ドキュメンテーション文字列,  Prev: 引数リストのアンパック,  Up: 関数定義についてもう少し

ラムダ形式
----------

多くの人の要望により、関数型プログラミング言語や Lisp によくある
いくつかの機能が Python に加えられました。 キーワード `lambda'
を使うと、名前のない小さな関数を生成できます。 例えば `lambda a, b:
a+b' は、二つの引数の和を返す関数です。 ラムダ形式 (lambda form)
は、関数オブジェクトが要求されている場所
にならどこでも使うことができます。ラムダ形式は、構文上単一の式に
制限されています。意味付け的には、ラムダ形式はただ通常の関数に
構文的な糖衣をかぶせたものに過ぎません。入れ子構造になった関数定義
と同様、ラムダ形式もそれを取り囲むスコープから変数を参照することが
できます。

     >>> def make_incrementor(n):
     ...     return lambda x: x + n
     ...
     >>> f = make_incrementor(42)
     >>> f(0)
     42
     >>> f(1)
     43


File: python-tut-jp.info,  Node: ドキュメンテーション文字列,  Prev: ラムダ形式,  Up: 関数定義についてもう少し

ドキュメンテーション文字列
--------------------------

ドキュメンテーション文字列については、その内容と書式に関する
慣習ができつつあります。

最初の行は、常に対象物の目的を短く簡潔にまとめたものでなくてはなりません。
簡潔に書くために、対象物の名前や型を明示する必要はありません。
名前や型は他の方法でも得られるからです (名前がたまたま関数の演算内容
を記述する動詞である場合は例外です)。
最初の行は大文字で始まり、ピリオドで終わっていなければなりません。

ドキュメンテーション文字列中にさらに記述すべき行がある場合、
二行目は空行にし、まとめの行と残りの記述部分を視覚的に分離
します。つづく行は一つまたはそれ以上の段落で、対象物の
呼び出し規約や副作用について記述します。

Python のパーザは複数行にわたる Python 文字列リテラルからインデントを
剥ぎ取らないので、ドキュメントを処理するツールでは必要に応じて
インデントを剥ぎ取らなければなりません。この処理は以下の規約に従って
行います。最初の行の _後にある_ 空行でない最初の行が、ドキュメント
全体のインデントの量を決めます。 (最初の行は通常、文字列を開始する
クオートに隣り合っているので、インデントが文字列リテラル中に現れない
ためです。) このインデント量と "等価な" 空白が、文字列のすべての
行頭から剥ぎ取られます。インデントの量が少ない行を書いてはならないの
ですが、もしそういう行があると、先頭の空白すべてが剥ぎ取られます。
インデントの空白の大きさが等しいかどうかは、タブ文字を (通常は 8 文字の
スペースとして) 展開した後に調べられます。

以下に複数行のドキュメンテーション文字列の例を示します:

     >>> def my_function():
     ...     """Do nothing, but document it.
     ...
     ...     No, really, it doesn't do anything.
     ...     """
     ...     pass
     ...
     >>> print my_function.__doc__
     Do nothing, but document it.
     
         No, really, it doesn't do anything.


File: python-tut-jp.info,  Node: データ構造,  Next: モジュール,  Prev: その他の制御フローツール,  Up: Top

データ構造
**********

この章では、すでに学んだことについてより詳しく説明するとともに、
いくつか新しいことを追加します。

* Menu:

* リスト型についてもう少し::
* del 文::
* タプルと配列::
* 辞書::
* ループのテクニック::
* 条件についてもう少し::
* 配列とその他の型の比較::


File: python-tut-jp.info,  Node: リスト型についてもう少し,  Next: del 文,  Prev: データ構造,  Up: データ構造

リスト型についてもう少し
========================

リストデータ型には、他にもいくつかメソッドがあります。リストオブジェクト
のすべてのメソッドを以下に示します:

`append(x)'
     リストの末尾に要素を一つ追加します。 `a[len(a):] = [X]'
     と等価です。

`extend(L)'
     指定したリスト中のすべての要素を対象のリストに追加し、リストを
     拡張します。 `a[len(a):] = L' と等価です。

`insert(i, x)'
     指定した位置に要素を挿入します。 第 1
     引数は、リストのインデクスで、そのインデクスを持つ要素の直前に挿入
     が行われます。従って、`a.insert(0, X)' はリストの先頭に挿入
     を行います。また `a.insert(len(a), X)' は `a.append(x)'
     と等価です。

`remove(x)'
     リスト中で、値 X を持つ最初の要素を削除します。
     該当する項目がなければエラーとなります。

`pop([i])'
     リスト中の指定された位置にある要素をリストから削除して、その要素を
     返します。インデクスが指定されなければ、`a.pop()' はリストの
     末尾の要素を返します。この場合も要素は削除されます。
     (メソッドの用法 (signature) で I の両側にある角括弧は、
     この引数がオプションであることを表しているだけなので、角括弧を
     入力する必要はありません。この表記法は

     の中で頻繁に見ることになるでしょう。)

`index(x)'
     リスト中で、値 X を持つ最初の要素のインデクスを返します。
     該当する項目がなければエラーとなります。

`count(x)'
     リストでの X の出現回数を返します。

`sort()'
     リストの項目を、インプレース演算 (in place、元のデータを演算結果で
     置き換えるやりかた) でソートします。

`reverse()'
     リストの要素を、インプレース演算で逆順にします。

以下にリストのメソッドをほぼ全て使った例を示します:

     >>> a = [66.6, 333, 333, 1, 1234.5]
     >>> print a.count(333), a.count(66.6), a.count('x')
     2 1 0
     >>> a.insert(2, -1)
     >>> a.append(333)
     >>> a
     [66.6, 333, -1, 333, 1, 1234.5, 333]
     >>> a.index(333)
     1
     >>> a.remove(333)
     >>> a
     [66.6, -1, 333, 1, 1234.5, 333]
     >>> a.reverse()
     >>> a
     [333, 1234.5, 1, 333, -1, 66.6]
     >>> a.sort()
     >>> a
     [-1, 1, 66.6, 333, 333, 1234.5]

* Menu:

* リストをスタックとして使う::
* リストをキューとして使う::
* 実用的なプログラミングツール::
* リストの内包表記::


File: python-tut-jp.info,  Node: リストをスタックとして使う,  Next: リストをキューとして使う,  Prev: リスト型についてもう少し,  Up: リスト型についてもう少し

リストをスタックとして使う
--------------------------

リスト型のメソッドのおかげで、簡単にリストをスタックとして使えます。
スタックでは、最後に追加された要素が最初に取り出されます ("last-in,
first-out") 。スタックの一番上に要素を追加するには `append()'
を使います。スタックの一番上から要素を取り出すには `pop()'
をインデクスを指定せずに使います。 例えば以下のようにします:

     >>> stack = [3, 4, 5]
     >>> stack.append(6)
     >>> stack.append(7)
     >>> stack
     [3, 4, 5, 6, 7]
     >>> stack.pop()
     7
     >>> stack
     [3, 4, 5, 6]
     >>> stack.pop()
     6
     >>> stack.pop()
     5
     >>> stack
     [3, 4]


File: python-tut-jp.info,  Node: リストをキューとして使う,  Next: 実用的なプログラミングツール,  Prev: リストをスタックとして使う,  Up: リスト型についてもう少し

リストをキューとして使う
------------------------

リストをキュー (queue) として手軽に使うこともできます。
キューでは、最初に追加された要素が最初に取り出されます ("first-in,
first-out")。キューの末尾に項目を追加するには `append()'
を使います。キューの先頭から項目を取り出すには インデクスに `0'
を指定して `pop()' を使います。 例えば以下のようにします:

     >>> queue = ["Eric", "John", "Michael"]
     >>> queue.append("Terry")           # Terry が到着 (arrive) する
     >>> queue.append("Graham")          # Graham が到着する
     >>> queue.pop(0)
     'Eric'
     >>> queue.pop(0)
     'John'
     >>> queue
     ['Michael', 'Terry', 'Graham']


File: python-tut-jp.info,  Node: 実用的なプログラミングツール,  Next: リストの内包表記,  Prev: リストをキューとして使う,  Up: リスト型についてもう少し

実用的なプログラミングツール
----------------------------

組み込み関数には、リストで使うと非常に便利なものが三つあります:
`filter()' 、 `map()' 、`reduce()' です。

`filter(FUNCTION, SEQUENCE)' は、 配列 SEQUENCE 中の要素 ITEM から、
`FUNCTION(ITEM)' が真となるような要素からなる 配列 (可能ならば SEQUENCE
と同じ型の) 配列を返します。
例えば、いくつかの素数を計算するには以下のようにします:

     >>> def f(x): return x % 2 != 0 and x % 3 != 0
     ...
     >>> filter(f, range(2, 25))
     [5, 7, 11, 13, 17, 19, 23]

`map(FUNCTION, SEQUENCE)' は、 配列 SEQUENCE の各要素 ITEM に対して
`FUNCTION(ITEM)' を呼び出し、その戻り値からなる
リストを返します。例えば、三乗された値の列を計算するには以下のように
します:

     >>> def cube(x): return x*x*x
     ...
     >>> map(cube, range(1, 11))
     [1, 8, 27, 64, 125, 216, 343, 512, 729, 1000]

     >>> seq = range(8)
     >>> def add(x, y): return x+y
     ...
     >>> map(add, seq, seq)
     [0, 2, 4, 6, 8, 10, 12, 14]

`reduce(FUNC, SEQUENCE)' は単一の値を返します。 この値は 2
つの引数をとる関数 FUNC を配列 SEQUENCE の最初の
二つの要素を引数として呼び出し、次にその結果と配列の次の要素を
引数にとり、以降これを繰り返すことで構成します。 例えば、 1 から 10
までの数の総和を計算するには以下のようにします:

     >>> def add(x,y): return x+y
     ...
     >>> reduce(add, range(1, 11))
     55

配列中にただ一つしか要素がなければ、その値自体が返されます;
配列が空なら、例外が送出されます。

3 つめの引数をわたして、初期値を指定することもできます。
この場合、空の配列を渡すと初期値が返されます。それ以外の場合には、
まず初期値と配列中の最初の要素に対して関数が適用され、次いでその結果
と配列の次の要素に対して適用され、以降これが繰り返されます。例えば
以下のようになります:

     >>> def sum(seq):
     ...     def add(x,y): return x+y
     ...     return reduce(add, seq, 0)
     ...
     >>> sum(range(1, 11))
     55
     >>> sum([])
     0

(2.3 以降では) 実際には、上の例のように `sum()' を定義しないでください:
数値の合計は広く必要とされている操作なので、すでに組み込み関数
`sum(SEQUENCE)' が提供されており、上の例と全く同様に 動作します。
_Added in Python version 2.3_


File: python-tut-jp.info,  Node: リストの内包表記,  Prev: 実用的なプログラミングツール,  Up: リスト型についてもう少し

リストの内包表記
----------------

リストの内包表記 (list comprehension) は、リストの生成を `map()' や
`filter()' や `lambda' の使用に
頼らずに行うための簡潔な方法を提供しています。
結果として得られるリストの定義は、しばしば上記の構文を使ってリストを
生成するよりも明快になります。各々のリストの内包表記は、 式、続いて
`for' 節、そしてその後ろに続くゼロ個かそれ以上の `for' 節または `if'
節からなります。
式をタプルで評価したいなら、丸括弧で囲わなければなりません。

     >>> freshfruit = ['  banana', '  loganberry ', 'passion fruit  ']
     >>> [weapon.strip() for weapon in freshfruit]
     ['banana', 'loganberry', 'passion fruit']
     >>> vec = [2, 4, 6]
     >>> [3*x for x in vec]
     [6, 12, 18]
     >>> [3*x for x in vec if x > 3]
     [12, 18]
     >>> [3*x for x in vec if x < 2]
     []
     >>> [[x,x**2] for x in vec]
     [[2, 4], [4, 16], [6, 36]]
     >>> [x, x**2 for x in vec]  # エラー - タプルには丸かっこが必要
       File "<stdin>", line 1, in ?
         [x, x**2 for x in vec]
                    ^
     SyntaxError: invalid syntax
     >>> [(x, x**2) for x in vec]
     [(2, 4), (4, 16), (6, 36)]
     >>> vec1 = [2, 4, 6]
     >>> vec2 = [4, 3, -9]
     >>> [x*y for x in vec1 for y in vec2]
     [8, 6, -18, 16, 12, -36, 24, 18, -54]
     >>> [x+y for x in vec1 for y in vec2]
     [6, 5, -7, 8, 7, -5, 10, 9, -3]
     >>> [vec1[i]*vec2[i] for i in range(len(vec1))]
     [8, 12, -54]

リストの内包表記は `map()' よりもはるかに柔軟性があり、
一つ以上の引数を持つ関数や入れ子になった関数でも利用できます:

     >>> [str(round(355/113.0, i)) for i in range(1, 6)]
     ['3.1', '3.14', '3.142', '3.1416', '3.14159']


File: python-tut-jp.info,  Node: del 文,  Next: タプルと配列,  Prev: リスト型についてもう少し,  Up: データ構造

`del' 文
========

指定された値の要素をリストから削除する代わりに、インデクスで指定する
方法があります: それが `del' 文です。この文はリストから
スライスを除去することもできます (以前はスライスに空のリストを代入
して行っていました)。例えば以下のようにします:

     >>> a
     [-1, 1, 66.6, 333, 333, 1234.5]
     >>> del a[0]
     >>> a
     [1, 66.6, 333, 333, 1234.5]
     >>> del a[2:4]
     >>> a
     [1, 66.6, 1234.5]

`del' は変数全体の削除にも使えます:

     >>> del a

この文の後で名前 `a' を参照すると、(別の値を `a' に 代入するまで)
エラーになります。`del' の別の用途について はまた後で取り上げます。


File: python-tut-jp.info,  Node: タプルと配列,  Next: 辞書,  Prev: del 文,  Up: データ構造

タプルと配列
============

リストや文字列には、インデクスやスライスを使った演算のように、
数多くの共通の性質があることを見てきました。これらは _配列 (sequence)_
データ型 の二つの例です。Python はまだ
進歩の課程にある言語なので、他の配列データ型が追加されるかも
しれません。標準の配列型はもう一つあります: _タプル (tuple)_ 型です。

タプルはコンマで区切られたいくつかの値からなります。例えば以下の
ように書きます:

     >>> t = 12345, 54321, 'hello!'
     >>> t[0]
     12345
     >>> t
     (12345, 54321, 'hello!')
     >>> # タプルを入れ子にしてもよい
     ... u = t, (1, 2, 3, 4, 5)
     >>> u
     ((12345, 54321, 'hello!'), (1, 2, 3, 4, 5))

ご覧のように、タプルは常に丸括弧で囲われています。これは、入れ子に
なったタプルが正しく解釈されるようにするためです; 入力の際には
丸括弧なしでもかまいませんが、結局 (タプルがより大きな式の
一部分の場合) たいてい必要となります。

タプルの用途はたくさんあります。例えば、(x, y) 座標対、データベースから
取り出した従業員レコードなどです。タプルは文字列と同じく、変更不能です:
タプルの個々の要素に代入を行うことはできません (スライスと連結を使って
同じ効果を実現することはできますが)。リストのような変更可能な
オブジェクトの入ったタプルを作成することもできます。

問題は 0 個または 1 個の項目からなるタプルの構築です: これらの操作を
行うため、構文には特別な細工がされています。空のタプルは
空の丸括弧ペアで構築できます; 一つの要素を持つタプルは、
値の後ろにコンマを続ける (単一の値を丸括弧で囲むだけでは不十分です)
ことで構築できます。美しくはないけれども、効果的です。例えば以下の
ようにします:

     >>> empty = ()
     >>> singleton = 'hello',    # <-- 末尾のコンマに注目
     >>> len(empty)
     0
     >>> len(singleton)
     1
     >>> singleton
     ('hello',)

文 `t = 12345, 54321, 'hello!'' は _タプルのパック (tuple packing)_
の例です: 値 `12345' 、 `54321' 、および `'hello!''
が一つのタプルにパックされます。 逆の演算も可能です:

     >>> x, y, z = t

この操作は、_配列のアンパック (sequence unpacking)_ とでも
呼ぶべきものです。配列のアンパックでは、左辺に列挙されている
変数が、右辺の配列の長さと同じであることが要求されます。
複数同時の代入が実はタプルのパックと配列のアンパックを
組み合わせたものに過ぎないことに注意してください！

この操作にはわずかな非対称性があります: 複数の値をパックすると
常にタプルが生成されますが、アンパックはどの配列にも働きます。


File: python-tut-jp.info,  Node: 辞書,  Next: ループのテクニック,  Prev: タプルと配列,  Up: データ構造

辞書
====

もう一つ、有用な型が Python に組み込まれています。それは _辞書
(dictionary)_ です。辞書は他の言語にも "連想記憶 (associated memory)"
や "連想配列 (associative array)" として存在することがあります。
ある範囲の数でインデクス化されている配列と異なり、辞書は _キー (key)_
でインデクス化されています。このキーは何らかの変更不能な型になります;
文字列、数値、およびタプルは常にキーにすることができます;
ただし、タプルに
何らかの変更可能なオブジェクトが含まれている場合にはキーに使うことは
できません。リストをキーとして使うことはできません。これは、リストの
`append()' や `extend()' メソッドを使ったり、またスライス
やインデクス指定の代入を行うと、インプレースで変更することができるため
です。

辞書は順序付けのされていない _キー(key): 値(value)_ のペアからなり、
キーが (辞書の中で) 一意でければならない、と考えると最もよいでしょう。
波括弧 (brace) のペア: `{}' は空の辞書を生成します。 カンマで区切られた
key: value のペアを波括弧ペアの間に入れると、 辞書の初期値となる key:
value が追加されます; この表現方法は
出力時に辞書が書き出されるのと同じ方法です。

辞書での主な操作は、ある値を何らかのキーを付けて記憶することと、
キーを指定して値を取り出すことです。 `del' で key: value のペアを
削除することもできます。
すでに使われているキーを使って値を記憶すると、以前そのキーに関連
づけられていた値は忘れ去られてしまいます。存在しないキーを使って
値を取り出そうとするとエラーになります。

辞書オブジェクトの `keys()' メソッドは、辞書で使われている
全てのキーからなるリストをランダムな順番で返します (リストをソート
したいなら、このキーのリストに `sort()' を使ってください)。
ある単一のキーが辞書にあるかどうか調べるには、辞書の `has_key()'
メソッドを使います。

以下に、辞書を使った小さな例を示します:

     >>> tel = {'jack': 4098, 'sape': 4139}
     >>> tel['guido'] = 4127
     >>> tel
     {'sape': 4139, 'guido': 4127, 'jack': 4098}
     >>> tel['jack']
     4098
     >>> del tel['sape']
     >>> tel['irv'] = 4127
     >>> tel
     {'guido': 4127, 'irv': 4127, 'jack': 4098}
     >>> tel.keys()
     ['guido', 'irv', 'jack']
     >>> tel.has_key('guido')
     1

`dict()' コンストラクタは、キーと値のペアをタプルにしたもの
からなるリストを使って直接辞書を生成します。キーと値のペアが
あるパターンをなしているなら、リストの内包表現を使えばキーと値の
リストをコンパクトに指定できます。

     >>> dict([('sape', 4139), ('guido', 4127), ('jack', 4098)])
     {'sape': 4139, 'jack': 4098, 'guido': 4127}
     >>> dict([(x, x**2) for x in vec])     # リスト内包表現を利用
     {2: 4, 4: 16, 6: 36}


File: python-tut-jp.info,  Node: ループのテクニック,  Next: 条件についてもう少し,  Prev: 辞書,  Up: データ構造

ループのテクニック
==================

辞書の内容にわたってループを行う際、`iteritems()' メソッドを使うと、
キーとそれに対応する値を同時に取り出せます。

     >>> knights = {'gallahad': 'the pure', 'robin': 'the brave'}
     >>> for k, v in knights.iteritems():
     ...     print k, v
     ...
     gallahad the pure
     robin the brave

配列にわたるループを行う際、`enumerate()' 関数を使うと、要素の
インデクスと要素を同時に取り出すことができます。

     >>> for i, v in enumerate(['tic', 'tac', 'toe']):
     ...     print i, v
     ...
     0 tic
     1 tac
     2 toe

二つまたはそれ以上の配列型を同時にループするために、 関数 `zip()'
を使って各要素をひと組みにすることができます。

     >>> questions = ['name', 'quest', 'favorite color']
     >>> answers = ['lancelot', 'the holy grail', 'blue']
     >>> for q, a in zip(questions, answers):
     ...     print 'What is your %s?  It is %s.' % (q, a)
     ...
     What is your name?  It is lancelot.
     What is your quest?  It is the holy grail.
     What is your favorite color?  It is blue.


File: python-tut-jp.info,  Node: 条件についてもう少し,  Next: 配列とその他の型の比較,  Prev: ループのテクニック,  Up: データ構造

条件についてもう少し
====================

前述の `while' や `if' 文 で使った条件 (condiction) には、
値の比較だけでなく、他の演算子も使うことができます、

比較演算子 `in' および `not in' は、ある値がある配列中に 存在するか
(または存在しないか) どうかを調べます。演算子 `is' および `is not'
は、二つのオブジェクトが実際に同じオブジェクト
であるかどうかを調べます; この比較は、リストのような変更可能な
オブジェクトにだけ意味があります。全ての比較演算子は同じ優先順位を
持っており、ともに数値演算子よりも低い優先順位となります。

比較は連鎖 (chain) させることができます。例えば、 `a < b == c' は、`a'
が `b' より小さく、 かつ `b' と `c' が等しいかどうか、をテストします。

比較演算をブール演算子 `and' や `or' で組み合わせることができ、
比較演算 (あるいは何らかのブール式) の結果を `not' で否定 (negate)
することもできます。これらは全て比較演算子よりもさらに低い優先順位を持ち
ます。ブール演算子の中では、`not' が最も高い順位を持ち、 `or'
が最も低くなります。これにより、 `A and not B or C' と `(A and (not B))
or C' は等価になります。
もちろん、丸括弧を使って望みの組み合わせを表現できます。

ブール演算子 `and' と `or' は、いわゆる _短絡 (short-circuit)_
演算子です: これらの演算子の引数は
左から右へと順に評価され、結果が確定した時点で評価を止めます。
例えば、`A' と `C' は真で `B' が偽のとき、 `A and B and C' は式 `C'
を評価しません。
一般に、短絡演算子の戻り値をブール値ではなくて一般的な値として用いると、
値は最後に評価された引数になります。

比較や他のブール式の結果を変数に代入することもできます。例えば、

     >>> string1, string2, string3 = '', 'Trondheim', 'Hammer Dance'
     >>> non_null = string1 or string2 or string3
     >>> non_null
     'Trondheim'

Python では、C
言語と違って、式の内部で代入を行えないので注意してください。 C
言語のプログラマは不満を呈するかもしれませんが、この仕様は、 C 言語
プログラムで遭遇する、式の中で `==' のつもりで `=' とタイプ
してしまうといったありふれた問題を回避します。


File: python-tut-jp.info,  Node: 配列とその他の型の比較,  Prev: 条件についてもう少し,  Up: データ構造

配列とその他の型の比較
======================

配列オブジェクトは同じ配列型の他のオブジェクトと比較できます。 比較には
_辞書的な (lexicographical)_ 順序が用いられます:
まず、最初の二つの要素を比較し、その値が等しくなければその時点で
比較結果が決まります。等しければ次の二つの要素を比較し、以降
配列の要素が尽きるまで続けます。比較しようとする二つの要素が
いずれも同じ配列型であれば、その配列間での辞書比較を再帰的に行います。
二つの配列の全ての要素の比較結果が等しくなれば、配列は等しいと
みなされます。片方の配列がもう一方の先頭部分にあたる部分配列
ならば、短い方の配列が小さい (劣位の) 配列とみなされます。
文字列に対する辞書的な順序づけには、個々の文字ごとに ASCII 順序を
用います。
以下に、同じ型のオブジェクトを持つ配列間での比較を行った例を示します:

     (1, 2, 3)              < (1, 2, 4)
     [1, 2, 3]              < [1, 2, 4]
     'ABC' < 'C' < 'Pascal' < 'Python'
     (1, 2, 3, 4)           < (1, 2, 4)
     (1, 2)                 < (1, 2, -1)
     (1, 2, 3)             == (1.0, 2.0, 3.0)
     (1, 2, ('aa', 'ab'))   < (1, 2, ('abc', 'a'), 4)

違う型のオブジェクト間の比較は認められていることに注意してください。
比較結果は決定性がありますが、その決め方は、型は型の名前で順番づけられる、
という恣意的なものです。従って、リスト (list) 型は常に文字列 (string)
型よりも小さく、文字列型は常にタプル (tuple) よりも小さい、といった
具合になります。型混合の数値の比較は、数値そのものに従って比較
されるので、例えば 0 は 0.0 と等しい、という結果になります。 (1)

---------- Footnotes ----------

(1)  異なる型のオブジェクトを比較するための規則を今後にわたって当てに
してはいけません; Python 言語の将来のバージョンでは変更されるかも
しれません。


File: python-tut-jp.info,  Node: モジュール,  Next: 入力と出力,  Prev: データ構造,  Up: Top

モジュール
**********

Python インタプリタを終了させ、再び起動すると、これまでに行ってきた
定義 (関数や変数) は失われています。ですから、より長いプログラムを
書きたいなら、テキストエディタを使ってインタプリタへの入力を用意して
おき、手作業の代わりにファイルを入力に使って動作させるとよいでしょう。
この作業を _スクリプト (script)_ の作成と言います; プログラムが
長くなるにつれ、メンテナンスを楽にするために、スクリプトをいくつかの
ファイルに分割したくなるかもしれません。また、いくつかのプログラムで
書いてきた便利な関数について、その定義をコピーすることなく個々の
プログラムで使いたいと思うかもしれません。

こういった要求をサポートするために、Python では定義をファイルに書いて
おき、スクリプトの中やインタプリタの対話インスタンス上で使う方法が
あります。 このファイルを _モジュール (module)_ と呼びます; モジュール
にある定義は、他のモジュールや _main_ モジュール (実行の
トップレベルや電卓モードでアクセスできる変数の集まりを指します) に
_import_ (取り込み) することができます。

モジュールは Python の定義や文が入ったファイルです。
ファイル名はモジュール名に接尾語 `,py' がついたものになります。
モジュールの中では、(文字列の) モジュール名をグローバル変数 `__name__'
で取得できます。例えば、お気に入りのテキストエディタ
を使って、現在のディレクトリに以下の内容のファイル `fibo.py' を
作成してみましょう:

     # フィボナッチ数列モジュール
     
     def fib(n):    # nまで加算されるフィボナッチ級数を印字
         a, b = 0, 1
         while b < n:
             print b,
             a, b = b, a+b
     
     def fib2(n): # nまで加算されるフィボナッチ級数を返す
         result = []
         a, b = 0, 1
         while b < n:
             result.append(b)
             a, b = b, a+b
         return result

次に Python インタプリタに入り、モジュールを以下のコマンドで import
しましょう。

     >>> import fibo

この操作では、`fibo' で定義された関数の名前を直接現在の
シンボルテーブルに入力することはありません; 単にモジュール名 `fibo'
だけをシンボルテーブルに入れます。
関数にはモジュール名を使ってアクセスします:

     >>> fibo.fib(1000)
     1 1 2 3 5 8 13 21 34 55 89 144 233 377 610 987
     >>> fibo.fib2(100)
     [1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89]
     >>> fibo.__name__
     'fibo'

関数を度々使うのなら、ローカルな名前に代入できます:

     >>> fib = fibo.fib
     >>> fib(500)
     1 1 2 3 5 8 13 21 34 55 89 144 233 377

* Menu:

* モジュールについてもうすこし::
* 標準モジュール::
* dir 関数::
* パッケージ::


File: python-tut-jp.info,  Node: モジュールについてもうすこし,  Next: 標準モジュール,  Prev: モジュール,  Up: モジュール

モジュールについてもうすこし
============================

モジュールには、関数定義に加えて実行文を入れることができます。
これらの実行文はモジュールを初期化するためのものです。
これらの実行文は、モジュールがどこかで_最初に_ import された
時にだけ実行されます。(1)

各々のモジュールは、自前のプライベートなシンボルテーブルを持っていて、
モジュールで定義されている関数はこのテーブルをグローバルな
シンボルテーブルとして使います。
したがって、モジュールの作者は、ユーザのグローバル変数と偶然的な衝突が
起こる心配をせずに、グローバルな変数をモジュールで使うことができます。
一方、自分が行っている操作をきちんと理解していれば、モジュール内の
関数を参照するのと同じ表記法 `modname.itemname' で、モジュールの
グローバル変数をいじることもできます。

モジュールが他のモジュールを import することもできます。`import'
文は全てモジュールの先頭に (さらに言えばスクリプトでも) 置きますが、
これは慣習であって必須ではありません。import されたモジュール名は
import
を行っているモジュールのグローバルなシンボルテーブルに置かれます。

`import' 文には、あるモジュール内の名前を、import を実行
しているモジュールのシンボルテーブル内に直接取り込むという変型が
あります。例えば:

     >>> from fibo import fib, fib2
     >>> fib(500)
     1 1 2 3 5 8 13 21 34 55 89 144 233 377

この操作は、import の対象となるモジュール名をローカルな
シンボルテーブル内に取り入れることはありません (従って上の例では、
`fibo' は定義されません)。

モジュールで定義されている名前を全て import するという変型もあります:

     >>> from fibo import *
     >>> fib(500)
     1 1 2 3 5 8 13 21 34 55 89 144 233 377

上の操作は、アンダースコア (`_') で開始する名前以外の全ての名前を
import します。

* Menu:

* モジュール検索パス::
* コンパイル された Python ファイル::

---------- Footnotes ----------

(1) 実際には、関数定義も `実行' される `文' です;
モジュールを実行すると、関数名はモジュールのグローバルな
シンボルテーブルに入力されます。


File: python-tut-jp.info,  Node: モジュール検索パス,  Next: コンパイル された Python ファイル,  Prev: モジュールについてもうすこし,  Up: モジュールについてもうすこし

モジュール検索パス
------------------

`spam' という名前のモジュールが import されると、インタプリタ は
`spam.py' という名前のファイルを現在のディレクトリ内で探し、
次に環境変数`PYTHONPATH' に指定されているディレクトリのリスト
から探します。`PYTHONPATH' はシェル変数 `PATH' と
同じ構文、すなわちディレクトリ名を並べたものです。`PYTHONPATH'
が設定されていないか、探しているファイルが見つからなかった場合は、
検索対象をインストール方法に依存するデフォルトのパスにして続けます;
UNIXでは、このパスは通常 `.:/usr/locall/lib/python' です。

実際には、モジュールは変数 `sys.path' で指定されたディレクトリの
リストから検索されます。`sys.path' は、入力とするスクリプトの
入ったディレクトリ (現在のディレクトリ)、`PYTHONPATH'、
およびインストール方法依存のデフォルト値を使って初期化されます。 Python
プログラマは、自分の行っている操作を理解しているなら、
この変数を使ってモジュール検索パスを修正したり置き換えたりすることが
できます。
起動しようとするスクリプトの入ったディレクトリが検索パス上にある
ため、スクリプトが標準モジュールと同じ名前をもたないようにすることが
重要です。さもなければ、Python が標準モジュールを import するときに
スクリプトをモジュールとして import しようと試みてしまうので注意
してください。このような誤りを犯すと、通常はエラーになります。 詳しくは
~*Note 標準モジュール:: 節、"標準モジュール." を参照して ください。


File: python-tut-jp.info,  Node: コンパイル された Python ファイル,  Prev: モジュール検索パス,  Up: モジュールについてもうすこし

"コンパイル" された Python ファイル
-----------------------------------

たくさんの標準モジュールを使うような短いプログラムで重要となる
起動時間の高速化を行うために、`spam.py' が見つかったディレクトリに
`spam.pyc' という名前のファイルがあった場合には、このファイルを
モジュール `spam' の "バイトコンパイルされた" バージョン
であると仮定します。 `spam.pyc' を生成するのに使われたバージョンの
`spam.py' の ファイル修正時刻が `spam.pyc' に記録されており、この値が
一致しなければ `spam.pyc' ファイルは無視されます。

通常、`spam.pyc' ファイルを生成するために何かをする必要は
ありません。`spam.py' が無事コンパイルされると、常に
コンパイルされたバージョンを `spam.pyc' へ書き出すよう
試みます。この試みが失敗してもエラーにはなりません;
何らかの理由でファイルが完全に書き出されなかった場合、作成された
`smap.pyc' は無効であるとみなされ、それ以後無視されます。 `spam.pyc'
ファイルの内容はプラットフォームに依存しないので、 Python
のモジュールのディレクトリは異なるアーキテクチャのマシン間で
共有することができます。

エキスパートへの助言:

   * Python インタプリタを `-O' フラグ付きで起動すると、 最適化
     (optimize) されたコードが生成されて `.pyo' ファイルに
     保存されます。最適化機構は今のところあまり役に立っていません;
     最適化機構は `assert' 文と `SET_LINENO' 命令を除去
     しているだけです。`-O' を使うと、_すべての_
     バイトコードが最適化されます; `.pyc' ファイルは無視され、 `.py'
     ファイルは最適化されたバイトコードにコンパイルされます。

   * 二つの `-O' フラグ (`-OO') を Python インタプリタへ
     渡すと、バイトコードコンパイラは、
     まれにプログラムが正しく動作しなくなるかもしれないような最適化を
     実行します。 現状では、ただ `__doc__'
     文字列をバイトコードから除去して、 よりコンパクトな `.pyo'
     ファイルにするだけです。
     この文字列が利用できることをあてにしているプログラムがあるかもしれない
     ので、自分の行っている操作が何かわかっているときにだけこのオプションを
     使うべきです。

   * `.pyc' ファイルや `.pyo' ファイルから
     読み出されたとしても、プログラムは何ら高速に動作するわけでは
     ありません。`.pyc' ファイルや `.pyo' ファイルで高速化される
     のは、読み込まれるときの速度だけです。

   * スクリプトの名前をコマンドラインで指定して実行した場合、
     そのスクリプトのバイトコードが `.pyc' や `.pyo' に
     書き出されることはありません。従って、スクリプトのほとんどのコードを
     モジュールに移し、そのモジュールを import
     する小さなブートストラップ
     スクリプトを作れば、スクリプトの起動時間を短縮できるときがあります。
     `.pyc' または `.pyo' ファイルの名前を直接コマンドラインに
     指定することもできます。

   * 一つのモジュールについて、ファイル `spam.py' のない `spam.pyc'
     (`-O' を使ったときは `spam.pyo')
     があってもかまいません。この仕様は、Python
     コードでできたライブラリを
     リバースエンジニアリングがやや困難な形式で配布するために使えます。

   * `compileall'{}  は、`.pyc' ファイル (または `-O'
     を使ったときは`.pyo' ファイル) を
     ディレクトリ内の全てのモジュールに対して生成することができます。



File: python-tut-jp.info,  Node: 標準モジュール,  Next: dir 関数,  Prev: モジュールについてもうすこし,  Up: モジュール

標準モジュール
==============

Python には標準モジュールのライブラリが付属しています。ライブラリは
独立したドキュメント   (以降 "ライブラリリファレンス")
で記述されています。
モジュールによってはインタプリタに組み込まれたものがあります;
インタプリタに組み込まれているモジュールが提供しているのは、
言語の中核の部分ではありませんが、効率化のためや、システムコールのような
オペレーティングシステムの根本機能へのアクセス手段を提供するための
操作です。これらのモジュールのセットは設定時に選択可能で、また
根底にあるプラットフォームにも依存します。例えば、`amoeba'
モジュールは、 Amoeba の根本機能を何らかの形でサポートしているような
システムでのみ提供されます。
とりわけ、注目に値するモジュールが一つあります: `sys' {}  はどの Python
インタプリタにも 組み込まれています。変数 `sys.ps1' と `sys.ps2'
は、それぞれ
一次プロンプトと二次プロンプトとして使われる文字列を定義しています:

     >>> import sys
     >>> sys.ps1
     '>>> '
     >>> sys.ps2
     '... '
     >>> sys.ps1 = 'C> '
     C> print 'Yuck!'
     Yuck!
     C>

これらの二つの変数は、インタプリタが対話モードにあるときだけ
定義されています。

変数 `sys.path' は文字列からなるリストで、インタプリタがモジュール
を検索するときのパスを決定します。 `sys.path' は環境変数 `PYTHONPATH'
から得たデフォルトパスに、 `PYTHONPATH'
が設定されていなければ組み込みのデフォルト値に設定
されます。標準的なリスト操作で変更することができます:

     >>> import sys
     >>> sys.path.append('/ufs/guido/lib/python')


File: python-tut-jp.info,  Node: dir 関数,  Next: パッケージ,  Prev: 標準モジュール,  Up: モジュール

`dir()' 関数
============

組込み関数 `dir()' は、あるモジュールがどんな名前を定義して
いるか調べるために使われます。 `dir()'
はソートされた文字列のリストを返します:

     >>> import fibo, sys
     >>> dir(fibo)
     ['__name__', 'fib', 'fib2']
     >>> dir(sys)
     ['__displayhook__', '__doc__', '__excepthook__', '__name__', '__stderr__',
      '__stdin__', '__stdout__', '_getframe', 'api_version', 'argv',
      'builtin_module_names', 'byteorder', 'callstats', 'copyright',
      'displayhook', 'exc_clear', 'exc_info', 'exc_type', 'excepthook',
      'exec_prefix', 'executable', 'exit', 'getdefaultencoding', 'getdlopenflags',
      'getrecursionlimit', 'getrefcount', 'hexversion', 'maxint', 'maxunicode',
      'meta_path', 'modules', 'path', 'path_hooks', 'path_importer_cache',
      'platform', 'prefix', 'ps1', 'ps2', 'setcheckinterval', 'setdlopenflags',
      'setprofile', 'setrecursionlimit', 'settrace', 'stderr', 'stdin', 'stdout',
      'version', 'version_info', 'warnoptions']

引数がなければ、`dir()' は現在定義している名前を列挙します。

     >>> a = [1, 2, 3, 4, 5]
     >>> import fibo, sys
     >>> fib = fibo.fib
     >>> dir()
     ['__name__', 'a', 'fib', 'fibo', 'sys']

変数、モジュール、関数、その他の、すべての種類の名前をリストすることに
注意してください。

`dir()' は、組込みの関数や変数の名前はリストしません。
これらの名前からなるリストが必要なら、標準モジュール `__builtin__'
で定義されています:

     >>> import __builtin__
     >>> dir(__builtin__)
     ['ArithmeticError', 'AssertionError', 'AttributeError',
      'DeprecationWarning', 'EOFError', 'Ellipsis', 'EnvironmentError',
      'Exception', 'False', 'FloatingPointError', 'IOError', 'ImportError',
      'IndentationError', 'IndexError', 'KeyError', 'KeyboardInterrupt',
      'LookupError', 'MemoryError', 'NameError', 'None', 'NotImplemented',
      'NotImplementedError', 'OSError', 'OverflowError', 'OverflowWarning',
      'PendingDeprecationWarning', 'ReferenceError',
      'RuntimeError', 'RuntimeWarning', 'StandardError', 'StopIteration',
      'SyntaxError', 'SyntaxWarning', 'SystemError', 'SystemExit', 'TabError',
      'True', 'TypeError', 'UnboundLocalError', 'UnicodeError', 'UserWarning',
      'ValueError', 'Warning', 'ZeroDivisionError', '__debug__', '__doc__',
      '__import__', '__name__', 'abs', 'apply', 'bool', 'buffer',
      'callable', 'chr', 'classmethod', 'cmp', 'coerce', 'compile', 'complex',
      'copyright', 'credits', 'delattr', 'dict', 'dir', 'divmod',
      'enumerate', 'eval', 'execfile', 'exit', 'file', 'filter', 'float',
      'getattr', 'globals', 'hasattr', 'hash', 'help', 'hex', 'id',
      'input', 'int', 'intern', 'isinstance', 'issubclass', 'iter',
      'len', 'license', 'list', 'locals', 'long', 'map', 'max', 'min',
      'object', 'oct', 'open', 'ord', 'pow', 'property', 'quit',
      'range', 'raw_input', 'reduce', 'reload', 'repr', 'round',
      'setattr', 'slice', 'staticmethod', 'str', 'string', 'sum', 'super',
      'tuple', 'type', 'unichr', 'unicode', 'vars', 'xrange', 'zip']

