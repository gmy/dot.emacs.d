This is python-lib-jp.info, produced by makeinfo version 4.5 from
python-lib-jp.texi.

12 October 2005


File: python-lib-jp.info,  Node: readline,  Next: rlcompleter,  Prev: tarfile,  Up: オプションのオペレーティングシステムサービス

GNU readline のインタフェース
=============================

Python のための GNU readline サポート。

`readline' モジュールでは、補完をしやすくしたり、 ヒストリファイルを
Python インタプリタから読み書きできるように
するためのいくつかの関数を定義しており、これらは直接使うことも
`rlcompleter' モジュールを介して使うこともできます。

`readline' モジュールでは以下の関数を定義しています:

`parse_and_bind(string)'
     readline 初期化ファイルの行を一行解釈して実行します。

`get_line_buffer()'
     行編集バッファの現在の内容を返します。

`insert_text(string)'
     コマンドラインにテキストを挿入します。

`read_init_file([filename])'
     readline 初期化ファイルを解釈します。
     標準のファイル名設定は最後に使われたファイル名です。

`read_history_file([filename])'
     readline ヒストリファイルを読み出します。 標準のファイル名設定は
     `~{}/.history' です。

`write_history_file([filename])'
     readline ヒストリファイルを保存します。 標準のファイル名設定は
     `~{}/.history' です。

`get_history_length()'
     ヒストリファイルに必要な長さを返します。負の値はヒストリファイル
     のサイズに制限がないことを示します。

`set_history_length(length)'
     ヒストリファイルに必要な長さを設定します。この値は
     `write_history_file()' がヒストリを保存する際にファイルを
     切り詰めるために使います。負の値はヒストリファイルのサイズを制限
     しないことを示します。

`get_current_history_length()'
     現在のヒストリ行数を返します(この値は`get_history_length()'で取
     得する異なります。`get_history_length()'はヒストリファイルに書
     き出される最大行数を返します)。_Added in Python version 2.3_

`get_history_item(index)'
     現在のヒストリから、INDEX 番目の項目を返します。 _Added in Python
     version 2.3_

`redisplay()'
     画面の表示を、現在のヒストリ内容によって更新します。 _Added in
     Python version 2.3_

`set_startup_hook([function])'
     startup_hook 関数を設定または除去します。FUNCTION が指定されて
     いれば、新たな startup_hook 関数として用いられます; 省略されるか
     `None' になっていれば、現在インストール
     されているフック関数は除去されます。 startup_hook 関数は readline
     が最初のプロンプトを出力する 直前に引数なしで呼び出されます。

`set_pre_input_hook([function])'
     pre_input_hook 関数を設定または除去します。FUNCTION が指定されて
     いれば、新たな pre_input_hook 関数として用いられます; 省略されるか
     `None' になっていれば、現在インストール
     されているフック関数は除去されます。 pre_input_hook 関数は
     readline が最初のプロンプトを出力した 後で、かつ readline
     が入力された文字を読み込み始める直前に 引数なしで呼び出されます。

`set_completer([function])'
     completer 関数を設定または除去します。FUNCTION が指定されて
     いれば、新たな completer 関数として用いられます; 省略されるか
     `None' になっていれば、現在インストール されている completer
     関数は除去されます。 completer 関数は `FUNCTION(TEXT, STATE)'
     の形式で、関数が文字列でない値を返すまで STATE を `0', `1', `2',
     ..., にして呼び出します。 この関数は TEXT
     から始まる文字列の補完結果として可能性の
     あるものを返さなくてはなりません。

`get_completer()'
     completer 関数を取得します。completer 関数が設定されていなければ
     `None'を返します。_Added in Python version 2.3_

`get_begidx()'
     readline タブ補完スコープの先頭のインデクスを取得します。

`get_endidx()'
     readline タブ補完スコープの末尾のインデクスを取得します。

`set_completer_delims(string)'
     タブ補完のための readline 単語区切り文字を設定します。

`get_completer_delims()'
     タブ補完のための readline 単語区切り文字を取得します。

`add_history(line)'
     1
     行をヒストリバッファに追加し、最後に打ち込まれた行のようにします。

See also:
     *Note rlcompleter:: 対話的プロンプトで Python
     識別子を補完する機能。

* Menu:

* 例 10::


File: python-lib-jp.info,  Node: 例 10,  Prev: readline,  Up: readline

例
--

以下の例では、ユーザのホームディレクトリにある `.pyhist' という
名前のヒストリファイルを自動的に読み書きするために、`readline'
モジュールによるヒストリの読み書き関数をどのように使うかを例示しています。
以下のソースコードは通常、対話セッションの中で `PYTHONSTARTUP'
ファイルから読み込まれ自動的に実行されることになります。

     import os
     histfile = os.path.join(os.environ["HOME"], ".pyhist")
     try:
         readline.read_history_file(histfile)
     except IOError:
         pass
     import atexit
     atexit.register(readline.write_history_file, histfile)
     del os, histfile


File: python-lib-jp.info,  Node: rlcompleter,  Prev: readline,  Up: オプションのオペレーティングシステムサービス

GNU readline向け補完関数
========================

GNU readline ライブラリ向けのPython識別子補完

`rlcompleter'モジュールではPythonの識別子やキーワードを定義した
`readline'モジュール向けの補完関数を定義しています。

`readline'モジュールがUNIX依存なのでこのモジュールもUNIX
に依存しています。

`rlcompleter'モジュールは`Completer'クラスを定義しています。

使用例:

     >>> import rlcompleter
     >>> import readline
     >>> readline.parse_and_bind("tab: complete")
     >>> readline. <TAB PRESSED>
     readline.__doc__          readline.get_line_buffer  readline.read_init_file
     readline.__file__         readline.insert_text      readline.set_completer
     readline.__name__         readline.parse_and_bind
     >>> readline.

`rlcompleter'モジュールは Pythonの対話モードで利用する為にデザイ
ンされています。ユーザは以下の命令を初期化ファイル
(環境変数`PYTHONSTARTUP'によって定義されます)に書き込むことで、
<Tab>キーによる補完を利用できます:

     try:
         import readline
     except ImportError:
         print "Module readline not available."
     else:
         import rlcompleter
         readline.parse_and_bind("tab: complete")

* Menu:

* Completerオブジェクト::


File: python-lib-jp.info,  Node: Completerオブジェクト,  Prev: rlcompleter,  Up: rlcompleter

Completerオブジェクト
---------------------

Completerオブジェクトは以下のメソッドを持っています:

`complete(text, state)'
     TEXTのSTATE番目の補完候補を返します。

     もしTEXTがピリオド(`.')を含まない場合、
     `__main__'、`__builtin__'で定義されて いる名前か、キーワード (
     `keyword' モジュールで定義されている) から補完されます。

     ピリオドを含む名前の場合、副作用を出さずに名前を最後まで評価しようとしま
     す(関数を明示的に呼び出しはしませんが、`__getattr__()'を呼んでし
     まうことはあります)そして、`dir()'関数でマッチする語を見つけま す。


File: python-lib-jp.info,  Node: Unix独特のサービス,  Next: Pythonデバッガ,  Prev: オプションのオペレーティングシステムサービス,  Up: Top

Unix独特のサービス
******************

本章に記述されたモジュールは、UNIXオペレーティングシステム、
あるいはそれから変形した多くのものに特有する機能のためのインター
フェイスを提供します。 その概要を以下に述べます。

* Menu:

* posix::
* pwd::
* grp::
* crypt::
* dl::
* dbm::
* gdbm::
* termios::
* TERMIOS::
* tty::
* pty::
* fcntl::
* pipes::
* posixfile::
* resource::
* nis::
* syslog::
* commands::


File: python-lib-jp.info,  Node: posix,  Next: pwd,  Prev: Unix独特のサービス,  Up: Unix独特のサービス

最も一般的な POSIX システムコール群
===================================

最も一般的な POSIX システムコール群 (通常は `os'
モジュールを介して利用されます)。

このモジュールはオペレーティングシステムの機能のうち、C 言語標準 および
POSIX 標準 (UNIX インタフェースをほんの少し隠蔽した)
で標準化されている機能に対するアクセス機構を提供します。

*このモジュールを直接 import しないで下さい。* その代わりに、
移植性のあるインタフェースを提供している `os' をインポート
してください。UNIXでは、 `os' モジュールが提供する インタフェースは
`posix' の内容を内包しています。 非 UNIX オペレーティングシステムでは
`posix' モジュール
を使うことはできませんが、その部分的な機能セットは、たいてい `os'
インタフェースを介して利用することができます。 `os' は、一度 import
してしまえば `posix' の代わり
であることによるパフォーマンス上のペナルティは _全くありません_。
その上、`os'  は `os.environ' の 内容が変更された際に自動的に
`putenv()' を呼ぶなど、 いくつかの追加機能を提供しています。

以下の説明は非常に簡潔なものです; 詳細については、 UNIX マニュアルの
(または POSIX) ドキュメントの) 対応する項目を 参照してください。PATH
で呼ばれる引数は文字列で与えられた パス名を表します。

エラーは例外として報告されます; よくある例外は型エラーです。
一方、システムコールから報告されたエラーは以下に述べるように `error'
(標準例外 `OSError' と同義です) を送出します。

* Menu:

* ラージファイルのサポート::
* モジュールの内容 2::


File: python-lib-jp.info,  Node: ラージファイルのサポート,  Next: モジュールの内容 2,  Prev: posix,  Up: posix

ラージファイルのサポート
------------------------

いくつかのオペレーティングシステム (AIX, HPIX, Irix および Solaris
が含まれます) は、`int' および `long' を 32 ビット値と する C
プログラムモデルで 2Gb を超えるサイズのファイルのサポート
を提供しています。このサポートは典型的には 64 ビット値のオフセット
値と、そこからの相対サイズを定義することで実現しています。この
ようなファイルは時にラージファイル ("large files") と呼ばれます。

Python では、`off_t' のサイズが `long' より大きく、 かつ `long long'
型を利用することができて、少なくとも `off_t'
型と同じくらい大きなサイズである場合、ラージファイルの
サポートが有効になります。この場合、ファイルのサイズ、オフセットおよび
Python の通常整数型の範囲を超えるような値の表現には Python の長整数型が
使われます。例えば、ラージファイルのサポートは Irix の最近のバージョン
では標準で有効ですが、Solaris 2.6 および 2.7 では、以下のように
する必要があります:

     CFLAGS="`getconf LFS_CFLAGS`" OPT="-g -O2 $CFLAGS" \
             ./configure

On large-file-capable Linux systems, this might work:

     CFLAGS='-D_LARGEFILE64_SOURCE -D_FILE_OFFSET_BITS=64' OPT="-g -O2 $CFLAGS" \
             ./configure


File: python-lib-jp.info,  Node: モジュールの内容 2,  Prev: ラージファイルのサポート,  Up: posix

モジュールの内容
----------------

`posix' では以下のデータ項目を定義しています:

`environ'
     インタプリタが起動した時点の環境変数文字列を表現する辞書です。
     例えば、`environ['HOME']' はホームディレクトリの パス名で、C
     言語の `getenv("HOME")' と等価です。

     この辞書を変更しても、`execv()'、`popen()' または `system()'
     などに渡される環境変数文字列には影響しません;
     そうした環境を変更するする必要がある場合、`environ' を `execve()'
     に渡すか、`system()' または `popen()' の命令文字列に変数の代入や
     export 文を 追加してください。

     _Note:_ `os' モジュールでは、もう一つの `environ'
     実装を提供しており、環境変数が変更された場合、その内容を更新する
     ようになっています。`os.environ' を更新した場合、この辞書は
     古い内容を表していることになってしまうので、このことにも注意
     してください。`posix' モジュール版を直接アクセスするよりも、 `os'
     モジュール版を使う方が推奨されています。

このモジュールのその他の内容は `os' モジュールからのみの
アクセスになっています; 詳しい説明は`os' モジュールの
ドキュメントを参照してください。


File: python-lib-jp.info,  Node: pwd,  Next: grp,  Prev: posix,  Up: Unix独特のサービス

パスワードデータベースへのアクセスを提供する
============================================

パスワードデータベースへのアクセスを提供する (`getpwnam()' など)。

このモジュールはUNIXのユーザアカウントとパスワードのデータベースへ
のアクセスを提供します。全てのUNIX系OSで利用できます。

パスワードデータベースの各エントリはタプルのようなオブジェクトで提供され、
それぞれの属性は`passwd'構造体のメンバに対応しています(下
の属性欄については、`<pwd.h>'を見てください)。

インデックス             属性                     意味
------                   -----                    -----
0                        `pw_name'                ログイン名
1                        `pw_passwd'              暗号化されたパスワード(optional))
2                        `pw_uid'                 ユーザID(UID)
3                        `pw_gid'                 グループID(GID)
4                        `pw_gecos'               実名またはコメント
5                        `pw_dir'                 ホームディレクトリ
6                        `pw_shell'               シェル

UIDとGIDは整数で、それ以外は全て文字列です。
検索したエントリが見つからないと`KeyError'が発生します。

_Note:_ 伝統的なUNIXでは、`pw_passwd'フィールドはDES由来のアルゴリ
ズムで暗号化されたパスワード(`crypy' モジュー
ルをごらんください)が含まれています。しかし、近代的なUNIX系OSでは_シャドウパスワード_とよばれる仕組みを利用しています。この場合には
`pw_passwd'フィールドにはアスタリスク(`'*'')か、`x'と
いう一文字だけが含まれており、暗号化されたパスワードは、一般には見えない
`/etc/shadow'というファイルに入っています。

このモジュールでは以下のものが定義されています:

`getpwuid(uid)'
     与えられたUIDに対応するパスワードデータベースのエントリを返します。

`getpwnam(name)'
     与えられたユーザ名に対応するパスワードデータベースのエントリを返します。

`getpwall()'
     パスワードデータベースの全てのエントリを、任意の順番で並べたリストを返し
     ます。

See also:
     *Note grp:: このモジュールに似た、グループデータベースへのアクセス
     を提供するモジュール。


File: python-lib-jp.info,  Node: grp,  Next: crypt,  Prev: pwd,  Up: Unix独特のサービス

グループデータベースへのアクセス
================================

グループデータベースへのアクセス (`getgrnam()' およびその仲間)。

このモジュールでは UNIX グループ (group) データベースへのアクセス機構を
提供します。全ての UNIX バージョンで利用可能です。

このモジュールはグループデータベースのエントリをタプルに似たオブジェクト
として報告されます。このオブジェクトの属性は `group' 構造体の各メンバ
(以下の属性フィールド、`<pwd.h>' を参照) に対応 します:

インデクス               属性                     意味
------                   -----                    -----
0                        gr_name                  グループ名
1                        gr_passwd                (暗号化された)
                                                  グループパスワード;
                                                  しばしば空文字列になります
2                        gr_gid                   数字のグループ ID
3                        gr_mem                   グループメンバの全てのユーザ名

gid は整数、名前およびパスワードは文字列、そしてメンバリストは
文字列からなるリストです。
(ほとんどのユーザは、パスワードデータベースで自分が入れられているグループ
のメンバとしてグループデータベース内では明示的に列挙されていないので
注意してください。完全なメンバ情報を取得するには両方のデータベースを
調べてください。)

このモジュールでは以下の内容を定義しています:

`getgrgid(gid)'
     与えられたグループ ID
     に対するグループデータベースエントリを返します。
     要求したエントリが見つからなかった場合、`KeyError' が
     送出されます。

`getgrnam(name)'
     与えられたグループ名に対するグループデータベースエントリを返します。
     要求したエントリが見つからなかった場合、`KeyError' が
     送出されます。

`getgrall()'
     全ての入手可能なグループエントリを返します。順番は決まっていません。

See also:
     *Note pwd::
     このモジュールと類似の、ユーザデータベースへのインタフェース。


File: python-lib-jp.info,  Node: crypt,  Next: dl,  Prev: grp,  Up: Unix独特のサービス

UNIX パスワードをチェックするための関数
=======================================

UNIX パスワードをチェックするための関数 `crypt()'。

このモジュールは DES  アルゴリズムに基づいた 一方向ハッシュ関数である
`crypt(3)'

ルーチンを実装しています。詳細については UNIX マニュアルページ
を参照してください。このモジュールは、Python スクリプトが
ユーザから入力されたパスワードを受理できるようにしたり、UNIX
パスワードに (脆弱性検査のための) 辞書攻撃を試みるのに使えます。

このモジュールは実行環境の`crypt(3)' の実装に依
存しています。そのため、現在の実装で利用可能な拡張を、このモジュールで
もそのまま利用できます。

`crypt(word, salt)'
     WORD は通常はユーザのパスワードで、プロンプトやグラフィカル
     インタフェースからタイプ入力されます。SALT は通常ランダムな 2
     文字からなる文字列で、DES アルゴリズムに 4096 通りのうち 1 つの
     方法で外乱を与えるために使われます。SALT に使う文字は集合
     "[./a-zA-Z0-9]" の要素でなければなりません。
     ハッシュされたパスワードを文字列として返します。パスワード文字列
     は SALT と同じ文字集合に含まれる文字からなります (最初の 2 文字は
     SALT 自体です).

     いくつかの拡張された`crypt(3)' は異なる値と SALT
     の長さを許しているので、パスワードをチェックする際にはcrypt
     されたパスワード文字列全体をSALTとして渡すよう勧めます。

典型的な使用例のサンプルコード:

     import crypt, getpass, pwd
     
     def login():
         username = raw_input('Python login:')
         cryptedpasswd = pwd.getpwnam(username)[1]
         if cryptedpasswd:
             if cryptedpasswd == 'x' or cryptedpasswd == '*':
                 raise "Sorry, currently no support for shadow passwords"
             cleartext = getpass.getpass()
             return crypt.crypt(cleartext, cryptedpasswd) == cryptedpasswd
         else:
             return 1


File: python-lib-jp.info,  Node: dl,  Next: dbm,  Prev: crypt,  Up: Unix独特のサービス

共有オブジェクトのC関数の呼び出し
=================================

共有オブジェクトのC関数の呼び出し

`dl'モジュールは`dlopen()'関数へのインターフェースを 定義します。
これはダイナミックライブラリにハンドルするための
UNIXプラットフォーム上の最も一般的なインターフェースです。
そのライブラリの任意の関数を呼ぶプログラムを与えます。

_Note:_ このモジュールは`sizeof(int) == sizeof(long) == sizeof(char *)'
でなければ働きません。
そうでなければimportするときに`SystemError'が送出されるでしょう。

`dl'モジュールは次の関数を定義します:

`open(name[, mode` = RTLD_LAZY'])'
     共有オブジェクトファイルを開いて、ハンドルを返します。
     モードは遅延結合(`RTLD_LAZY')または即時結合(`RTLD_NOW')
     を表します。 デフォルトは`RTLD_LAZY'です。
     いくつかのシステムは`RTLD_NOW'をサポートしていないことに
     注意してください。

     返り値は`dlobject'です。

`dl'モジュールは次の定数を定義します:

`RTLD_LAZY'
     `open()'の引数として使います。

`RTLD_NOW'
     `open()'の引数として使います。
     即時結合をサポートしないシステムでは、
     この定数がモジュールに現われないことに注意してください。
     最大のポータビリティを求めるならば、システムが即時結合をサポートする
     かどうかを決定するために`hasattr()'を使用してください。

`dl'モジュールは次の例外を定義します:

`error'
     動的なロードやリンクルーチンの内部でエラーが生じたときに送出される例外です。

例:

     >>> import dl, time
     >>> a=dl.open('/lib/libc.so.6')
     >>> a.call('time'), time.time()
     (929723914, 929723914.498)

この例はDebian GNU/Linuxシステム上で行なったもので、
このモジュールの使用はたいてい悪い選択肢であるという事実のよい例です。

* Menu:

* Dlオブジェクト::


File: python-lib-jp.info,  Node: Dlオブジェクト,  Prev: dl,  Up: dl

Dlオブジェクト
--------------

`open()'によって返されたDlオブジェクトは次のメソッドを持っています:

`close()'
     メモリーを除く全てのリソースを解放します。

`sym(name)'
     NAMEという名前の関数が参照された共有オブジェクトに存在する場合、
     そのポインター(整数値)を返します。 存在しない場合`None'を返します。
     これは次のように使えます:

          >>> if a.sym('time'):
          ...     a.call('time')
          ... else:
          ...     time.time()

     (0は`NULL'ポインターであるので、この関数は0でない数を返すだろう
     ということに注意してください)

`call(name[, arg1[, arg2...]])'
     参照された共有オブジェクトのNAMEという名前の関数を呼出します。
     引数は、Python整数(そのまま渡される)、Python文字列(ポインターが渡される)、
     `None' (`NULL'として渡される) のどれかでなければいけません。
     Pythonはその文字列が変化させられるのを好まないので、
     文字列は`const char*'として関数に渡されるべきであることに
     注意してください。

     最大で10個の引数が渡すことができ、
     与えられない引数は`None'として扱われます。 関数の返り値はC
     `long'(Python整数である)です。


File: python-lib-jp.info,  Node: dbm,  Next: gdbm,  Prev: dl,  Up: Unix独特のサービス

UNIX dbmのシンプルなインタフェース
==================================

ndbmを基にした基本的なデータベースインタフェースです。

dbmモジュールはUNIX(`n')`dbm'インタフェースの
ライブラリを提供します。dbmオブジェクトは、キーと値が必ず文字列である以外は
辞書オブジェクトのようなふるまいをします。
print文などでdbmインスタンスを出力してもキーと値は出力されません。
また、`items()'と`values()'メソッドはサポートされません。

このモジュールは、BSD DB、GNU GDBM互換インタフェースを持った
クラシックなndbmインタフェースを使うことができます。
UNIX上のビルド時に`configure'スクリプトで適切なヘッダファイルが
割り当られます。

以下はこのモジュールの定義:

`error'
     I/Oエラーのようなdbm特有のエラーが起ったときに上げられる値です。
     また、正しくないキーが与えられた場合に通常のマッピングエラーのような
     `KeyError'が上げられます。

`library'
     `ndbm'が使用している実装ライブラリ名です。

`open(filename[, flag[, mode]])'
     dbmデータベースを開いてdbmオブジェクトを返します。
     引数FILENAMEはデータベースのファイル名を指定します。
     (拡張子`.dir'や`.pag'は付けません。 また、BSD
     DBは拡張子`.db'がついたファイルが一つ作成されます。)

     オプション引数FLAGは次のような値を指定します:

     Value                              Meaning
     ------                             -----
     'r'                                存在するデータベースを読取り専用で開きます。(デフォルト)
     'w'                                存在するデータベースを読み書き可能な状態で開きます。
     'c'                                データベースを読み書き可能な状態で開きます。
                                        また、データベースが存在しない場合は新たに作成します。
     'n'                                Always create a new, empty
                                        database, open for reading and
                                        writing
     'n'                                常に空のデータベースが作成され、読み書き可能な状態で開きます。

     オプション引数MODEはデータベース作成時に使用される
     UNIXのファイルモードを指定します。デフォルトでは8進数の`0666'です

See also:
     *Note anydbm:: `dbm'スタイルの一般的なインタフェース *Note gdbm::
     GNU GDBMライブラリの類似したインタフェース *Note whichdb::
     存在しているデータベースの形式を決めるための
     ユーティリティモジュール


File: python-lib-jp.info,  Node: gdbm,  Next: termios,  Prev: dbm,  Up: Unix独特のサービス

GNU による dbm の再実装
=======================

GNU による dbm の再実装。

このモジュールは `dbm'  モジュールに よく似ていますが、`gdbm'
を使っていくつかの追加機能を提供しています。 `gdbm' と `dbm'
では生成されるファイル形式に互換性がないので 注意してください。

`gdbm' モジュールでは GNU DBM ライブラリへのインタフェースを
提供します。`gdbm' オブジェクトはキーと値が常に文字列である
ことを除き、マップ型 (辞書型) と同じように動作します。 `gdbm'
オブジェクトに対して `print' を適用しても
キーや値を印字することはなく、`items()' 及び `values()'
メソッドはサポートされていません。

このモジュールでは以下の定数および関数を定義しています:

`error'
     I/O エラーのような `gdbm' 特有のエラーで送出されます。
     誤ったキーの指定のように、一般的なマップ型のエラーに対しては
     `KeyError' が送出されます。

`open(filename, [flag, [mode]])'
     `gdbm' データベースを開いて `gdbm' オブジェクトを返します。
     FILENAME 引数はデータベースファイルの名前です。

     オプションの FLAG としては、 `'r''
     (既存のデータベースを読み込み専用で開く -- 標準の値です)、 `'w''
     (既存のデータベースを読み書き用に開く)、 `'c''
     (既存のデータベースが存在しない場合には新たに作成する)、または
     `'n'' (常に新たにデータベースを作成する)、をとることができます。

     データベースをどのように開くかを制御するために、フラグに以下の文字を
     追加することができます:

        * `'f'' --
          データベースを高速モードで開きます。このモードではデータベースへの書き込みはファイルシステムと同期されません。

        * `'s'' --
          同期モードで開きます。データベースへの変更はファイルに即座いに書き込まれます。

        * `'u'' -- データベースをロックしません。

     全てのバージョンの `gdbm' で全てのフラグが有効とは限りません。
     モジュール定数 `open_flags' はサポートされているフラグ文字
     からなる文字列です。無効なフラグが指定された場合、例外 `error'
     が送出されます。

     オプションの MODE
     引数は、新たにデータベースを作成しなければならない 場合に使われる
     UNIX のファイルモードです。標準の値は 8 進数の `0666' です。

辞書型形式のメソッドに加えて、`gdbm' オブジェクトには以下のメソッド
があります:

`firstkey()'
     このメソッドと `next()' メソッドを使って、データベースの全ての
     キーにわたってループ処理を行うことができます。探索は `gdbm' の
     内部ハッシュ値の順番に行われ、キーの値に順に並んでいるとは限りません。
     このメソッドは最初のキーを返します。

`nextkey(key)'
     データベースの順方向探索において、KEY よりも後に来るキーを
     返します。以下のコードはデータベース `db' に
     ついて、キー全てを含むリストをメモリ上に生成することなく
     全てのキーを出力します:

          k = db.firstkey()
          while k != None:
              print k
              k = db.nextkey(k)


`reorganize()'
     大量の削除を実行した後、`gdbm' ファイルの占めるスペースを
     削減したい場合、このルーチンはデータベースを再組織化します。
     この再組織化を使う以外に `gdbm' はデータベースファイルの
     大きさを短くすることはありません; そうでない場合、削除された
     部分のファイルスペースは保持され、新たな (キー、値の) ペアが追加
     される際に再利用されます。

`sync()'
     データベースが高速モードで開かれていた場合、このメソッドは
     ディスクにまだ書き込まれていないデータを全て書き込ませます。

See also:
     *Note anydbm:: `dbm' 形式のデータベースへの汎用インタフェース。
     *Note whichdb::
     既存のデータベースがどの形式のデータベースか判定する
     ユーティリティモジュール。


File: python-lib-jp.info,  Node: termios,  Next: TERMIOS,  Prev: gdbm,  Up: Unix独特のサービス

POSIX スタイルの端末制御
========================

POSIX スタイルの端末制御。

このモジュールでは端末 I/O 制御のための POSIX 準拠の関数呼び出し
インタフェースを提供します。これら呼び出しのための完全な記述については、
POSIX または UNIX マニュアルページを参照してください。 POSIX _termios_
形式の端末制御をサポートする UNIX の バージョンで
(かつインストール時に指定した場合に) のみ利用可能です。

このモジュールの関数は全て、ファイル記述子 FD を最初の引数
としてとります。この値は、`sys.stdin.fileno()' が返すような
整数のファイル記述子でも、`sys.stdin' 自体のようなファイル
オブジェクトでもかまいません。

このモジュールではまた、モジュールで提供されている関数を使う上で
必要となる全ての定数を定義しています; これらの定数は C の対応
する関数と同じ名前を持っています。これらの端末制御インタフェース
を利用する上でのさらなる情報については、あなたのシステムの
ドキュメンテーションを参考にしてください。

このモジュールでは以下の関数を定義しています:

`tcgetattr(fd)'
     ファイル記述子 FD の端末属性を含むリストを返します。その形式は:
     `['IFLAG, OFLAG, CFLAG, LFLAG, ISPEED, OSPEED, CC`]' です。CC
     は端末特殊文字のリストです (それぞれ長さ 1
     の文字列です。ただしインデクス `VMIN' および `VTIME'
     の内容は、それらのフィールドが定義されていた場合整数
     の値となります)。

     端末設定フラグおよび端末速度の解釈、および配列 CC のインデクス
     検索は、`termios' で定義されているシンボル定数を使って行わなければ
     なりません。

`tcsetattr(fd, when, attributes)'
     ファイル記述子 FD の端末属性を ATTRIBUTES から取り出して
     設定します。ATTRIBUTES は `tcgetattr()' が返すような
     リストです。引数 WHEN は属性がいつ変更されるかを決定します:
     `TCSANOW' は即時変更を行い、`TCSAFLUSH' は現在
     キューされている出力を全て転送し、全てのキューされている入力を無視
     した後に変更を行います。

`tcsendbreak(fd, duration)'
     ファイル記述子 FD にブレークを送信します。DURATION をゼロ
     にすると、 0.25-0.5 秒間のブレークを送信します; DURATION の値が
     ゼロでない場合、その意味はシステム依存です。

`tcdrain(fd)'
     ファイル記述子 FD に書き込まれた全ての出力が転送されるまで
     待ちます。

`tcflush(fd, queue)'
     ファイル記述子 FD にキューされたデータを無視します。
     どのキューかはQUEUE セレクタで指定します: `TCIFLUSH'
     は入力キュー、 `TCOFLUSH' は出力キュー、`TCIOFLUSH'
     は両方のキューです。

`tcflow(fd, action)'
     ファイル記述子 FD の入力または出力をサスペンドしたりレジューム
     したりします。引数 ACTION は出力をサスペンドする `TCOOFF'、
     出力をレジュームする `TCOON' 、入力をサスペンドする `TCIOFF'
     、入力をレジュームする `TCION' をとることが できます。

See also:
     *Note tty:: 一般的な端末制御操作のための便利な関数。

* Menu:

* termios Example::


File: python-lib-jp.info,  Node: termios Example,  Prev: termios,  Up: termios

使用例
------

以下はエコーバックを切った状態でパスワード入力を促す関数です。
ユーザの入力に関わらず以前の端末属性を正確に回復するために、 二つの
`tcgetattr()' と `try' ... `finally' 文によるテクニックが使われています:

     def getpass(prompt = "Password: "):
         import termios, sys
         fd = sys.stdin.fileno()
         old = termios.tcgetattr(fd)
         new = termios.tcgetattr(fd)
         new[3] = new[3] & ~termios.ECHO          # lflags
         try:
             termios.tcsetattr(fd, termios.TCSADRAIN, new)
             passwd = raw_input(prompt)
         finally:
             termios.tcsetattr(fd, termios.TCSADRAIN, old)
         return passwd


File: python-lib-jp.info,  Node: TERMIOS,  Next: tty,  Prev: termios,  Up: Unix独特のサービス

`termios' モジュールで使われる定数
==================================

`termios' モジュールを利用する上で必要となる シンボル定数。

_This is deprecated in Python 2.1.  必要な定数は `termios'
から取り込んでください。_

このモジュールは`termios'  モジュール
を使う上で必要となるシンボル定数を定義しています (上の節を参照して
ください)。これらの定数のリストは POSIX または UNIX のマニュアル
ページを参照してください。


File: python-lib-jp.info,  Node: tty,  Next: pty,  Prev: TERMIOS,  Up: Unix独特のサービス

端末制御のための関数群
======================

一般的な端末制御操作のためのユーティリティ関数群。

`tty' モジュールは端末を cbreak および raw モードにする
ための関数を定義しています。

このモジュールは `termios' モジュールを必要とするため、
UNIXでしか動作しません。

`tty' モジュールでは、以下の関数を定義しています:

`setraw(fd[, when])'
     ファイル記述子 FD のモードを raw モードに変えます。 WHEN
     を省略すると標準の値は `termios.TCAFLUSH' に
     なり、`termios.tcsetattr()' に渡されます。

`setcbreak(fd[, when])'
     ファイル記述子 FD のモードを cbreakモードに変えます。 WHEN
     を省略すると標準の値は `termios.TCAFLUSH' に
     なり、`termios.tcsetattr()' に渡されます。

See also:
     *Note termios:: 低レベル端末制御インタフェース。 *Note TERMIOS::
     端末制御操作で便利な定数群。


File: python-lib-jp.info,  Node: pty,  Next: fcntl,  Prev: tty,  Up: Unix独特のサービス

擬似端末ユーティリティ
======================

SGIとLinux用の擬似端末を制御する

`pty'モジュールは擬似端末(他のプロセスを実行してその制御をしてい
る端末をプログラムで読み書きする)を制御する操作を定義しています。

擬似端末の制御はプラットフォームに強く依存するので、SGIとLinux用のコード
しか存在していません。(Linux用のコードは他のプラットフォームでも動作するよ
うに作られていますがテストされていません。)

`pty'モジュールでは以下の関数を定義しています:

`fork()'
     forkします。子プロセスの制御端末を擬似端末に接続します。
     返り値は`(PID, FD)'です。子プロセスはPIDとして0、
     、FDとして_invalid_ をそれぞれ受けとります。親プロセスは
     PIDとして子プロセスのPID、FDとして子プロセスの制御端末(子プ
     ロセスの標準入出力に接続されている)のファイルディスクリプタを受けとります。

`openpty()'
     新しい擬似端末のペアを開きます。
     利用できるなら`os.openpty()'を使い、
     利用できなければSGIと一般的なUNIXシステム用の
     エミュレーションコードを使います。
     マスター、スレーブそれぞれのためのファイルディスクリプタ、
     `(MASTER, SLAVE)'のタプルを返します。

`spawn(argv[, master_read[, stdin_read]])'
     プロセスを生成して制御端末を現在のプロセスの標準入出力に接続します。
     これは制御端末を読もうとするプログラムをごまかすために利用されます。

     MASTER_READとSTDIN_READにはファイルディスクリプタから読み込む
     関数を指定してください。デフォルトでは呼ばれるたびに1024バイトずつ読み
     込もうとします。


File: python-lib-jp.info,  Node: fcntl,  Next: pipes,  Prev: pty,  Up: Unix独特のサービス

`fcntl()' および `ioctl()' システムコール
=========================================

`fcntl()' および `ioctl()' システム コール。

このモジュールでは、ファイル記述子 (file descriptor) に基づいた
ファイル制御および I/O 制御を実現します。 このモジュールは、 UNIX
のルーチンである `fcntl()' および `ioctl()' へのインタフェースです。

このモジュール内の全ての関数はファイル記述子 FD を最初の引数に
取ります。この値は `sys.stdin.fileno()' が返すような
整数のファイル記述子でも、`sys.stdin' 自体のような、純粋に
ファイル記述子だけを返す `fileno()' メソッドを提供している
ファイルオブジェクトでもかまいません。

このモジュールでは以下の関数を定義しています:

`fcntl(fd, op[, arg])'
     要求された操作をファイル記述子 FD (または `fileno()'
     メソッドを提供しているファイルオブジェクト) に対して実行します。
     操作は OP で定義され、オペレーティングシステム依存です。
     これらの操作コードは `fcntl' モジュール内にもあります。 引数 ARG
     はオプションで、標準では整数値 `0' です。
     この引数を与える場合、整数か文字列の値をとります。
     引数が無いか整数値の場合、この関数の戻り値は C 言語の `fcntl()'
     を呼び出した際の整数の戻り値になります。
     引数が文字列の場合には、`struct.pack' で作られる
     ようなバイナリの構造体を表します。
     バイナリデータはバッファにコピーされ、そのアドレスが C 言語の
     `fcntl()' 呼び出しに渡されます。
     呼び出しが成功した後に戻される値はバッファの内容で、文字列
     オブジェクトに変換されています。返される文字列は ARG 引数
     と同じ長さになます。この値は 1024 バイトに制限されています。
     オペレーティングシステムからバッファに返される情報の長さが 1024
     バイトよりも大きい場合、大抵はセグメンテーション違反となるか、
     より不可思議なデータの破損を引き起こします。

     `fcntl()' が失敗した場合、`IOError' が 送出されます。

`ioctl(fd, op, arg)'
     この関数は `fcntl()' 関数と同じですが、操作が通常ライブラリ
     モジュール `termios' で定義されており、引数の扱いがより
     複雑であるところが異なります。

     パラメタ ARG は整数か、存在しない (整数 `0' と等価なもの
     として扱われます) か、(通常の Python 文字列のような) 読み出し専用の
     バッファインタフェースをサポートするオブジェクトか、読み書き
     バッファインタフェースをサポートするオブジェクトです。

     最後の型のオブジェクトを除き、動作は `fcntl()' 関数と 同じです。

     可変なバッファが渡された場合、動作は MUTATE_FLAG 引数の
     値で決定されます。

     この値が偽の場合、バッファの可変性は無視され、動作は読み出しバッファ
     の場合と同じになりますが、上で述べた 1024
     バイトの制限は回避されます -
     従って、どれだけオペレーティングシステムが希望するより長いバッファを
     渡しても正しく動作します。

     MUTATE_FLAG が真の場合、バッファは (実際には) 根底にある `ioctl()'
     システムコールに渡され、後者の戻り値が 呼び出し側の Python
     に引き渡され、バッファの新たな内容は `ioctl' の動作を反映します。
     この説明はやや単純化されています。というのは、与えられたバッファが
     1024 バイト長よりも短い場合、バッファはまず 1024 バイト長の
     静的なバッファにコピーされてから `ioctl' に渡され、
     その後引数で与えたバッファに戻しコピーされるからです。

     MUTATE_FLAG が与えられなかった場合、2.3 ではこの値は偽となります。
     この仕様は今後のいくつかのバージョンを経た Python で変更される予定
     です: 2.4 では、 MUTATE_FLAG を提供し忘れると警告が出されますが
     同じ動作を行い、2.5 ではデフォルトの値が真となるはずです。

     以下に例を示します:

          >>> import array, fcntl, struct, termios, os
          >>> os.getpgrp()
          13341
          >>> struct.unpack('h', fcntl.ioctl(0, termios.TIOCGPGRP, "  "))[0]
          13341
          >>> buf = array.array('h', [0])
          >>> fcntl.ioctl(0, termios.TIOCGPGRP, buf, 1)
          0
          >>> buf
          array('h', [13341])


`flock(fd, op)'
     ファイル記述子 FD (`fileno()' メソッドを提供している
     ファイルオブジェクトも含む) に対してロック操作 OP を実行します。
     詳細は UNIX マニュアルの `flock(3)' を参照してください
     (システムによっては、この関数は `fcntl()' を使って
     エミュレーションされています)。

`lockf(fd, operation, [len, [start, [whence]]])'
     本質的に `fcntl()' によるロッキングの呼び出しをラップ
     したものです。FD はロックまたはアンロックするファイルの
     ファイル記述子で、OPERATION は以下の値:

        * `LOCK_UN' - アンロック

        * `LOCK_SH' - 共有ロックを取得

        * `LOCK_EX' - 排他的ロックを取得

     のうちいずれかになります。

     OPERATION が `LOCK_SH' または `LOCK_EX' の場合、`LOCK_NB' とビット
     OR にすることでロック取得時に
     ブロックしないようにすることができます。`LOCK_NB' が
     使われ、ロックが取得できなかった場合、`IOError' が送出
     され、例外は ERRNO 属性を持ち、その値は `EACCESS' または `EAGAIN'
     になります (オペレーティングシステムに 依存します;
     可搬性のため、両方の値をチェックしてください)。
     少なくともいくつかのシステムでは、 ファイル記述子が参照している
     ファイルが書き込みのために開かれている場合、`LOCK_EX'
     だけしか使うことができません。

     LENGTH はロックを行いたいバイト数、START は ロック領域先頭の
     WHENCE からの相対的なバイトオフセット、 WHENCE は `fileobj.seek()'
     と同じで、具体的には:

        * `0' - ファイル先頭からの相対位置 (`SEEK_SET')

        * `1' - 現在のバッファ位置からの相対位置 (`SEEK_CUR')

        * `2' - ファイルの末尾からの相対位置 (`SEEK_END')

     START の標準の値は 0 で、ファイルの先頭から開始することを
     意味します。WHENCE の標準の値も 0 です。

以下に (全ての SVR4 互換システムでの) 例を示します:

     import struct, fcntl
     
     file = open(...)
     rv = fcntl(file, fcntl.F_SETFL, os.O_NDELAY)
     
     lockdata = struct.pack('hhllhh', fcntl.F_WRLCK, 0, 0, 0, 0, 0)
     rv = fcntl.fcntl(file, fcntl.F_SETLKW, lockdata)

最初の例では、戻り値 RV は整数値を保持しています; 二つ目の
例では文字列値を保持しています。LOCKDATA 変数の構造体
レイアウトはシステム依存です -- 従って `flock()' を 呼ぶ方がベターです。


File: python-lib-jp.info,  Node: pipes,  Next: posixfile,  Prev: fcntl,  Up: Unix独特のサービス

シェルパイプラインへのインタフェース
====================================

Python による UNIX シェルパイプラインへのインタフェース。

`pipes' モジュールでは、_'pipeline'_ の概念 -- ある
ファイルを別のファイルに変換する機構の直列接続 -- を抽象化する
ためのクラスを定義しています。

このモジュールは `/bin/sh' コマンドラインを利用するため、 `os.system()'
および `os.popen()' のための POSIX
準拠のシェル、または互換のシェルが必要です。

`pipes' モジュールでは、以下のクラスを定義しています:

`Template()'
     パイプラインを抽象化したクラス。

使用例:

     >>> import pipes
     >>> t=pipes.Template()
     >>> t.append('tr a-z A-Z', '--')
     >>> f=t.open('/tmp/1', 'w')
     >>> f.write('hello world')
     >>> f.close()
     >>> open('/tmp/1').read()
     'HELLO WORLD'

* Menu:

* テンプレートオブジェクト::


File: python-lib-jp.info,  Node: テンプレートオブジェクト,  Prev: pipes,  Up: pipes

テンプレートオブジェクト
------------------------

テンプレートオブジェクトは以下のメソッドを持っています:

`reset()'
     パイプラインテンプレートを初期状態に戻します。

`clone()'
     元のパイプラインテンプレートと等価の新しいオブジェクトを返します。

`debug(flag)'
     FLAG が真の場合、デバッグをオンにします。そうでない場合、
     デバッグをオフにします。デバッグがオンの時には、実行されるコマンド
     が印字され、より多くのメッセージを出力するようにするために、シェルに
     `set -x' 命令を与えます。

`append(cmd, kind)'
     新たなアクションをパイプラインの末尾に追加します。CMD 変数は
     有効な bourne shell 命令でなければなりません。KIND 変数は
     二つの文字からなります。

     最初の文字は `'-'' (コマンドが標準入力からデータを読み出すことを
     意味します)、`'f'' (コマンドがコマンドライン上で与えたファイルから
     データを読み出すことを意味します)、あるいは `'.'' (コマンドは
     入力を読まないことを意味します、従ってパイプラインの先頭になります)、の
     いずれかになります。

     同様に、二つ目の文字は `'-'' (コマンドが標準出力に結果を書き込む
     ことを意味します)、`'f'' (コマンドがコマンドライン上で指定した
     ファイルに結果を書き込むことを意味します)、あるいは `'.'' (コマンド
     はファイルを書き込まないことを意味し、パイプラインの末尾になります)、
     のいずれかになります。

`prepend(cmd, kind)'
     パイプラインの先頭に新しいアクションを追加します。引数の説明については
     `append()' を参照してください。

`open(file, mode)'
     ファイル類似のオブジェクトを返します。このオブジェクトは FILE
     を開いていますが、パイプラインを通して読み書きするようになっています。
     MODE には `'r'' または `'w'' のいずれか一つしか与える
     ことができないので注意してください。

`copy(infile, outfile)'
     パイプを通して INFILE を OUTFILE にコピーします。


File: python-lib-jp.info,  Node: posixfile,  Next: resource,  Prev: pipes,  Up: Unix独特のサービス

ロック機構をサポートするファイル類似オブジェクト
================================================

ロック機構をサポートするファイル類似オブジェクト。

_This is deprecated in Python 1.5.  このモジュールが提供しているよりも
うまく処理ができ、可搬性も高いロック操作が ``fcntl'.lockf()'
で提供されています。 _

このモジュールでは、組み込みのファイルオブジェクトの上にいくつかの
追加機能を実装しています。特に、このオブジェクトはファイルのロック機構、
ファイルフラグへの操作、およびファイルオブジェクトを複製するための
簡単なインタフェースを実装しています。オブジェクトは全ての標準
ファイルオブジェクトのメソッドに加え、以下に述べるメソッドを持って
います。このモジュールはファイルのロック機構に `fcntl.fcntl()'
を用いるため、ある種の UNIXでしか動作しません。

posixfile オブジェクトをインスタンス化するには、 `posixfile'
モジュールの `open()' 関数を使います。生成されるオブジェクト
は標準ファイルオブジェクトとだいたい同じルック& フィールです。

`posixfile' モジュールでは、以下の定数を定義しています:

`SEEK_SET'
     オフセットをファイルの先頭から計算します。

`SEEK_CUR'
     オフセットを現在のファイル位置から計算します。

`SEEK_END'
     オフセットをファイルの末尾から計算します。

`posixfile' モジュールでは以下の関数を定義しています:

`open(filename[, mode[, bufsize]])'
     指定したファイル名とモードで新しい posixfile オブジェクトを作成
     します。FILENAME、MODE および BUFSIZE 引数は 組み込みの `open()'
     関数と同じように解釈されます。

`fileopen(fileobject)'
     指定した標準ファイルオブジェクトで新しい posixfile オブジェクトを
     作成します。作成されるオブジェクトは元のファイルオブジェクトと
     同じファイル名およびモードを持っています。

posixfile オブジェクトでは以下の追加メソッドを定義しています:

`lock(fmt, [len[, start[, whence]]])'
     ファイルオブジェクトが参照しているファイルの指定部分にロックをかけます。
     指定の書式は下のテーブルで説明されています。 LEN
     引数にはロックする部分の長さを指定します。標準の値は `0' です。
     START にはロックする部分の先頭オフセットを指定し、その 標準値は
     `0' です。WHENCE 引数はオフセットをどこからの
     相対位置にするかを指定します。この値は定数 `SEEK_SET'、
     `SEEK_CUR'、または `SEEK_END' のいずれかになります。 標準の値は
     `SEEK_SET' です。引数についてのより詳しい情報は システムの
     `fcntl(2)' マニュアルページを参照してください。

`flags([flags])'
     ファイルオブジェクトが参照しているファイルに指定したフラグを設定
     します。新しいフラグは特に指定しない限り以前のフラグと OR
     されます。 指定書式は下のテーブルで説明されています。FLAGS
     引数なしの 場合、現在のフラグを示す文字列が返されます (`?'
     修飾子と同じ です) 。 フラグについてのより詳しい情報はシステムの
     `fcntl(2)' マニュアルページを参照してください。

`dup()'
     ファイルオブジェクトと、背後のファイルポインタおよびファイル記述子
     を複製します。返されるオブジェクトは新たに開かれたファイルのように
     振舞います。

`dup2(fd)'
     ファイルオブジェクトと、背後のファイルポインタおよびファイル記述子
     を複製します。新たなオブジェクトは指定したファイル記述子を持ちます。
     それ以外の点では、返されるオブジェクトは新たに開かれたファイルのように
     振舞います。

`file()'
     posixfile
     オブジェクトが参照している標準ファイルオブジェクトを返します。
     この関数は標準ファイルオブジェクトを使うよう強制している関数を使う
     場合に便利です。

全てのメソッドで、要求された操作が失敗した場合には `IOError'
が送出されます。

`lock()' の書式指定文字には以下のような意味があります:

書式指定                             意味
------                               -----
u                                    指定領域のロックを解除します
r                                    指定領域の読み出しロックを要求します
w                                    指定領域の書き込みロックを要求します

これに加え、以下の修飾子を書式に追加できます:

修飾子                   意味                     注釈
------                   -----                    -----
|                        ロック操作が処理されるまで待ちます
?                        要求されたロックと衝突している第一のロックを返すか、衝突がない場合には(1)
                         `None' を返します。      

注釈:

`(1)'
     返されるロックは `(MODE, LEN, START, WHENCE, PID)' の形式で、MODE
     はロックの形式を表す文字 ('r' または 'w') です。この修飾子は
     ロック要求の許可を行わせません; すなわち、問い合わせの目的にしか
     使えません。

`flags()' の書式指定文字には以下のような意味があります:

書式                                 意味
------                               -----
a                                    追記のみ (append only) フラグ
c                                    実行時クローズ (close on exec)
                                     フラグ
n                                    無遅延 (no delay) フラグ
                                     (非ブロック (non-blocking)
                                     フラグとも呼ばれます)
s                                    同期 (synchronization) フラグ

これに加え、以下の修飾子を書式に追加できます:

修飾子                   意味                     注釈
------                   -----                    -----
!                        指定したフラグを通常の   (1)
                         'オン' にせず 'オフ'     
                         にします                 
=                        フラグを標準の 'OR'      (1)
                         操作ではなく置換します。 
?                        設定されているフラグを表現する文字からなる文字列を返します。(2)

注釈:

`(1)'
     `!' および `=' 修飾子は互いに排他の関係にあります。

`(2)'
     この文字列が表すフラグは同じ呼び出しによってフラグが置き換えられた後のものです。


以下に例を示します:

     import posixfile
     
     file = posixfile.open('/tmp/test', 'w')
     file.lock('w|')
     ...
     file.lock('u')
     file.close()


File: python-lib-jp.info,  Node: resource,  Next: nis,  Prev: posixfile,  Up: Unix独特のサービス

リソース使用状態の情報
======================

現プロセスのリソース使用状態を提供するためのインタフェース。

このモジュールでは、プログラムによって使用されているシステムリソースを
計測したり制御するための基本的なメカニズムを提供します。

特定のシステムリソースを指定したり、現在のプロセスやその子プロセスの
リソース使用情報を要求するためにはシンボル定数が使われます。

エラーを表すための例外が一つ定義されています:

`error'
     下に述べる関数は、背後にあるシステムコールが予期せず失敗した場合、
     このエラーを送出するかもしれません。

* Menu:

* リソースの制限::
* リソースの使用状態::

