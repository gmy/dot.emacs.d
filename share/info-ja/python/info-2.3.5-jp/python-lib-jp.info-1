This is python-lib-jp.info, produced by makeinfo version 4.5 from
python-lib-jp.texi.

12 October 2005


File: python-lib-jp.info,  Node: Top,  Next: 序,  Prev: (dir),  Up: (dir)

Python ライブラリリファレンス
*****************************

* Menu:

* 序::
* はじめに::
* 組み込みオブジェクト::
* Python ランタイム サービス::
* 文字列処理::
* 各種サービス::
* 汎用オペレーティングシステムサービス::
* オプションのオペレーティングシステムサービス::
* Unix独特のサービス::
* Pythonデバッガ::
* Python プロファイラ::
* インターネットプロトコルとその支援::
* インターネット上のデータの操作::
* 構造化マークアップツール::
* マルチメディアサービス::
* 暗号関連のサービス::
* Tkを用いたグラフィカルユーザインターフェイス::
* 制限実行 restricted execution::
* Python言語サービス::
* Python コンパイラパッケージ::
* SGI IRIX 特有のサービス::
* SunOS 特有のサービス::
* MS Windows 特有のサービス::
* ドキュメント化されていないモジュール::
* バグ報告::
* 歴史とライセンス::
* 日本語訳について::
* Module Index::
* Class-Exception-Object Index::
* Function-Method-Variable Index::
* Miscellaneous Index::


File: python-lib-jp.info,  Node: 序,  Next: はじめに,  Prev: Top,  Up: Top

序
**

Copyright (C) 2001, 2002, 2003 Python Software Foundation.  All rights
reserved.

Copyright (C) 2000 BeOpen.com.  All rights reserved.

Copyright (C) 1995-2000 Corporation for National Research Initiatives.
All rights reserved.

Copyright (C) 1991-1995 Stichting Mathematisch Centrum.  All rights
reserved.

Translation Copyright (C) 2003 Python Document Japanese Translation
Project. All rights reserved.

ライセンスおよび許諾に関する完全な情報は、このドキュメントの末尾を
参照してください。

     Pythonは拡張性のあるインタプリタ形式のオブジェクト指向言語です。簡単なテキスト処理スクリプトから対話型のWWWブラウザまで、幅広い用途に対応しています。

     では、言語に関する厳密な構文と意味づけを記述していますが、Python
     をすぐに役立てられるようにする上で大いに貢献する、言語とともに配付される標準ライブラリについては記述されていません。このライブラリには、ファイル
     I/O のように Python
     プログラマが直接アクセスできないシステム機能へのアクセス機能を提供する
     (Cで書かれた) 組み込みモジュール や、Python
     で記述された、日々のプログラミングで生じる多くの問題に標準的な解決策を提供するモジュールが入っています。これらのモジュールのいくつかには、Pythonプログラムに移植性を持たせ、それを高めるという明確な意図があります。

     このライブラリリファレンスマニュアルでは、Pythonの標準ライブラリだけでなく、多くのオプションのライブラリモジュール
     (プラットフォームがサポートしているかどうか、あるいはコンパイル時の設定により、使える場合と使えない場合がある)
     について説明しています。また、言語の標準の型、組み込みの関数と例外、Pythonリファレンスマニュアルに説明がなかったり不足している多くの点についても説明しています。

     このマニュアルは、読者が Python
     言語について基礎的な知識を持っていることを仮定しています。形式ばらない
     Python への入門には、を参照してください。
     は、高度な文法と意味づけについて疑問があるときに参照してください。最後に、と題されたマニュアルには、Pythonに新しい機能を追加する方法と、他のアプリケーションに
     Python を組み込む方法を記述しています。



File: python-lib-jp.info,  Node: はじめに,  Next: 組み込みオブジェクト,  Prev: 序,  Up: Top

はじめに
********

この "Python ライブラリ" には様々な内容が収録されています。

このライブラリには、数値型やリスト型のような、通常は言語の"核"
をなす部分とみなされるデータ型が含まれています。Python 言語のコア
部分では、これらの型に対してリテラル表現形式を与え、意味づけ上の
いくつかの制約を与えていますが、完全にその意味づけを定義している
わけではありません。(一方で、言語のコア部分では演算子のスペルや
優先順位のような構文法的な属性を定義しています。) 　
このライブラリにはまた、組み込み関数と例外が納められています --
組み込み関数および例外は、全ての Python で書かれたコード上で、 `import'
文を使わずに使うことができるオブジェクトです。
これらの組み込み要素のうちいくつかは言語のコア部分で定義されて
いますが、大半は言語コアの意味づけ上不可欠なものではないので
ここでしか記述されていません。

とはいえ、このライブラリの大部分に収録されているのはモジュールの
コレクションです。このコレクションを細分化する方法はいろいろあります。
あるモジュールは C 言語で書かれ、Python インタプリタに組み
込まれています; 一方別のモジュールは Python で書かれ、ソースコードの
形式で取り込まれます。またあるモジュールは、例えば実行スタックの追跡
結果を出力するといった、Python に非常に特化したインタフェースを提供
し、一方他のモジュールでは、特定のハードウェアにアクセスするといった、
特定のオペレーティングシステムに特化したインタフェースを提供
し、さらに別のモジュールでは WWW (ワールドワイドウェブ)
のような特定のアプリケーション分野に特化したインタフェースを
提供しています。モジュールによっては全てのバージョン、全ての 移植版の
Python で利用することができたり、背後にあるシステムが
サポートしている場合にのみ使えたり、Python をコンパイルして
インストールする際に特定の設定オプションを選んだときにのみ
利用できたりします。

このマニュアルの構成は "内部から外部へ:" つまり、最初に
組み込みのデータ型を記述し、組み込みの関数および例外、
そして最後に各モジュールといった形になっています。モジュール
は関係のあるものでグループ化して一つの章にしています。
章の順番付けや各章内のモジュールの順番付けは、大まかに重要性の
高いものから低いものになっています。

つまり、このマニュアルを最初から読み始め、読み飽き始めた
ところで次の章に進めば、Python ライブラリで利用できるモジュールや
サポートしているアプリケーション領域の概要をそこそこ理解できる
ということです。
もちろん、このマニュアルを小説のように読む必要は_ありません_ --
(マニュアルの先頭部分にある) 目次にざっと目を通したり、 (最後尾にある)
索引でお目当ての関数やモジュール、用語を探す
ことだってできます。もしランダムな項目について勉強してみたいの
なら、ランダムにページを選び (`random' 参照)、そこから 1, 2
節読むこともできます。このマニュアルの各節をどんな順番で
読むかに関わらず、第 *Note 組み込みオブジェクト:: 章、
"組み込み型、例外、および 関数"
から始めるとよいでしょう。マニュアルの他の部分は、
この節の内容について知っているものとして書かれているからです。

それでは、ショーの始まりです！


File: python-lib-jp.info,  Node: 組み込みオブジェクト,  Next: Python ランタイム サービス,  Prev: はじめに,  Up: Top

組み込みオブジェクト
********************

組み込み例外名、関数名、各種定数名は専用のシンボルテーブル中に存在しています。
シンボル名を参照するときこのシンボルテーブルは最後に参照されるので、
ユーザーが設定したローカルな名前やグローバルな名前によってオーバーライド
することができます。
組み込み型については参照しやすいようにここで説明されています。(1)

この章にある表では、オペレータの優先度を昇順に並べて表わしていて、
同じ優先度のオペレータは同じ箱に入れています。同じ優先度の二項演算子は左
から右への結合順序を持っています。(単項演算子は右から左へ結合しますが選択
の余地はないでしょう。) (2)
オペレータの優先順位についての詳細はの5章をごらんください。

* Menu:

* 組み込み関数::
* 非必須組み込み関数 Non-essential Built-in Functions::
* 組み込み型::
* 組み込み例外::
* 組み込み定数::

---------- Footnotes ----------

(1)
ほとんどの説明ではそこで発生しうる例外については説明されていません。この
マニュアルの将来の版で訂正される予定です。

(2) 訳者註: HTML版では、変換の過程で
表の区切り情報が消えてしまっているので、PS版やPDF版をごらんください。


File: python-lib-jp.info,  Node: 組み込み関数,  Next: 非必須組み込み関数 Non-essential Built-in Functions,  Prev: 組み込みオブジェクト,  Up: 組み込みオブジェクト

組み込み関数
============

Python インタプリタは数多くの組み込み関数を持っていて、いつでも利用
することができます。それらの関数をアルファベット順に挙げます。

`__import__(name[, globals[, locals[, fromlist]]])'
     この関数は `import'  文によって呼び出され
     ます。この関数の主な意義は、同様のインタフェースを持つ関数で
     この関数を置き換え、`import' 文の意味を変更できるように
     することです。これを行う理由とやり方の例については、標準ライブラリ
     モジュール  `ihooks'  および `rexec'  を読んで下さい。また、
     組み込みモジュール `imp'  についても 読んでみて下さい。自分で関数
     `__import__' を構築する 際に便利な操作が定義されています。

     例えば、文 `import spam' は結果として以下の呼び出し:
     `__import__('spam',' `globals(),' `locals(), [])' になります; 文
     `from spam.ham import eggs' は `__import__('spam.ham', globals(),
     locals(), ['eggs'])' です。 `locals()' および `['eggs']'
     が引数で与えられますが、 関数 `__import__()' は `eggs'
     という名のローカル変数 を設定しないので注意してください;
     この操作はそれ以後の import 文の
     ために生成されたコードで行われます。(実際、標準の実装では LOCALS
     引数を全く使わず、`import' 文のパッケージ文脈を決定するため だけに
     GLOBALS を使います。)

     変数 NAME が `package.module' の形式であった場合、 通常、NAME
     という名のモジュール _ではなく_ トップレベルの パッケージ
     (最初のドットまでの名前) が返されます。しかし、 空でない FROMLIST
     引数が与えられていれば、NAME
     と名づけられたモジュールが返されます。これは異なる種類の import
     文に対して生成されたバイトコードと互換性をもたせるために行われます;
     `import spam.ham.eggs' とすると、トップレベルのパッケージ `spam'
     はインポートする名前空間に置かれなければなりませんが、 `from
     spam.ham import eggs' とすると、変数 `eggs' を 見つけるためには
     `spam.ham' サブパッケージを使わなくては
     なりません。この振る舞いを回避するために、`getattr()' を
     使って必要なコンポーネントを展開してください。例えば、
     以下のようなヘルパー関数:

          def my_import(name):
              mod = __import__(name)
              components = name.split('.')
              for comp in components[1:]:
                  mod = getattr(mod, comp)
              return mod


を定義することができます。

`abs(x)'
     数値の絶対値を返します。引数として通常の整数、長整数、浮動小数点数を
     とることができます。引数が複素数の場合、その大きさ (magnitude) が
     返されます

`basestring()'
     この抽象型は、 `str' および `unicode' のスーパクラスです。
     この型は呼び出したりインスタンス化したりはできませんが、オブジェクトが
     `str' や `unicode' のインスタンスであるかどうかを調べる際に
     利用できます。 `isinstance(obj, basestring)' は `isinstance(obj,
     (str, unicode))' と同じです。 _Added in Python version 2.3_

`bool([x])'
     標準の真値テストを使って、値をブール値に変換します。X
     が偽なら、`False' を返します; そうでなければ `True'
     を返します。`bool' はクラスでも あり、`int'
     のサブクラスになります。`bool' クラスは
     それ以上サブクラス化できません。このクラスのインスタンス は`False'
     および `True'　だけです。

     _Added in Python version 2.2.1_

     _Changed in Python version 2.3_

`callable(object)'
     OBJECT 引数が呼び出し可能なオブジェクトの場合、真を返します。
     そうでなければ偽を返します。この関数が真を返しても OBJECT
     の呼び出しは失敗する可能性がありますが、偽を返した場合は決して
     成功することはありません。クラスは呼び出し可能 (クラスを呼び出すと
     新しいインスタンスを返します) なことと、クラスのインスタンスが
     メソッド `__call__()' を持つ場合には呼び出しが可能なので
     注意してください。

`chr(i)'
     ASCII コードが整数 I となるような文字 1 字からなる文字列を
     返します。例えば、`chr(97)' は文字列 `'a'' を返します。 この関数は
     `ord()' の逆です。引数は [0..255] の両端を含む
     範囲内に収まらなければなりません; I が範囲外の値のときには
     `ValueError' が送出されます。

`classmethod(function)'
     FUNCTION のクラスメソッドを返します。

     クラスメソッドは、インスタンスメソッドが暗黙の第一引数として
     インスタンスをとるように、第一引数としてクラスをとります。
     クラスメソッドを宣言するには、以下の書きならわしを使います:

          class C:
              def f(cls, arg1, arg2, ...): ...
              f = classmethod(f)

     このメソッドはクラスで呼び出すこと (例えば C.f() ) も、
     インスタンスとして呼び出すこと (例えば C().f()) もできます。
     インスタンスはそのクラスが何であるかを除いて無視されます。
     クラスメソッドが導出クラスに対して呼び出された場合、
     導出されたクラスオブジェクトが暗黙の第一引数として渡されます。

     クラスメソッドは C++ や Java における静的メソッドとは異なります。
     そのような機能を求めているなら、`staticmethod()' を参照してくだ
     さい。 _Added in Python version 2.2_


`cmp(x, y)'
     二つのオブジェクト X および Y を比較し、その結果に従って
     整数を返します。戻り値は `X' < `Y' のときには負、 `X == Y'
     の時にはゼロ、`X > Y' には 厳密に正の値になります。

`compile(string, filename, kind[, flags[, dont_inherit]])'
     STRING をコードオブジェクトにコンパイルします。コードオブジェクト
     は `exec' 文で実行したり、 `eval()' を呼び出して
     評価することができます。FILENAME 引数はコードを読み出すファイル
     を指定します; ファイルから読み出されない場合には、認識可能な
     ある値を渡します (一般的には `'<string>'' が使われます)。 引数
     KIND には、この種類のコードをコンパイルしなければ
     ならないのかを指定します; STRING が命令文の列からなる場合には
     `'exec'' を、単一の式からなる場合には `'eval'' が、
     単一の対話命令文からなる場合には `'single'' にします
     (後者の例では、評価する何らかの式が `None' 以外の場合には
     その式が出力されます) 。

     複数行の命令文をコンパイルする時には、2 つの注意点があります:
     行末は単一の改行文字 (`'\n'') で表さなければなりません。
     また、入力行は少なくとも 1 つの改行文字で終端されていなければ
     なりません。行末が `'\r\n'' で表現されている場合、 文字列に
     `replace()' メソッドを使って `'\n'' に変換してください。

     オプションの引数 FLAGS および DONT_INHERIT (Python 2.2
     で新たに追加) は、 STRING のコンパイル においてどの future 文 (PEP
     236 参照) が影響を受けるか を制御します。どちらも省略された場合
     (または両方ともゼロの場合)、
     コンパイルを呼び出している側のコードで有効になっている future 文
     の内容を有効にして STRING をコンパイルします。 FLAGS
     が与えられており、かつ DONT_INHERIT が与えられて いない
     (またはゼロ) の場合、上の場合に加えて FLAGS に指定 された future
     文が使われます。DONT_INHERIT がゼロでない整数で FLAGS
     はその値になります - この関数呼び出しに関係する future
     文は無視されます。

     future 文はビットで指定され、互いにビット単位の論理和を取ることで
     複数の文を指定することができます。ある機能を指定するために必要な
     ビットフィールドは、`__future__' モジュールの `_Feature'
     インスタンスにおける `compiler_flag' 属性で得ることができます。

`complex([real[, imag]])'
     値 REAL + IMAG*j の複素数型数を生成するか、文字列または
     数値を複素数型に変換します。最初の引数が文字列の場合、文字列を
     複素数として変換します。この場合関数は二つ目の引数無しで呼び出さ
     なければなりません。二つ目の引数は文字列であってはなりません。
     それぞれの引数は (複素数を含む) 任意の数値型をとることができます。
     IMAG が省略された場合、標準の値はゼロで、関数は `int' 、 `long()'
     および `float()' のような数値型への 変換関数として動作します。
     全ての引数が省略された場合、`0j' を返します。

`delattr(object, name)'
     `setattr()' の親戚となる関数です。引数はオブジェクトと
     文字列です。文字列はオブジェクトの属性のどれか一つの名前でなければ
     なりません。この関数は与えられた名前の属性を削除しますが、オブジェクト
     がそれを許す場合に限ります。例えば、 `delattr(X, 'FOOBAR')' は
     `del X.FOOBAR' と等価です。

`dict([mapping-or-sequence])'
     オプションの場所にある引数か、キーワード引数の集合から、
     新しく辞書オブジェクトを初期化して返します。
     引数が指定されていなければ、新しい空の辞書を返します。
     オプションの場所にある引数がマップ型のオブジェクトの場合、
     そのマップ型オブジェクトと同じキーと値を持つ辞書を返します。
     それ以外の場合、オプションの場所にある引数は配列型か、
     反復をサポートするコンテナ型か、イテレータオブジェクトでなければなりません。
     この場合引数中の要素もまた、上に挙げた型のどれかでなくてはならず、
     加えて正確に 2 個のオブジェクトを持っていなくてはなりません。
     最初の要素は新たな辞書のキーとして、二つ目の要素は辞書の値として
     使われます。同じキーが一度以上与えられた場合、新たな辞書中には
     最後に与えた値だけが関連付けられます。

     キーワード引数が与えられた場合、キーワードとそれに関連付けられた
     値が辞書の要素として追加されます。オプションの場所にある
     オブジェクト内とキーワード引数の両方で同じキーが指定されていた場合、
     辞書中にはキーワード引数の設定値の方が残されます。

     例えば、以下のコードはどれも、`{"one": 2, "two": 3}'
     と同じ辞書を返します:

        * `dict({'one': 2, 'two': 3})'

        * `dict({'one': 2, 'two': 3}.items())'

        * `dict({'one': 2, 'two': 3}.iteritems())'

        * `dict(zip(('one', 2), ('two', 3)))'

        * `dict([['two', 3], ['one', 2]])'

        * `dict(one=2, two=3)'

        * `dict([(['one', 'two'][i-2], i) for i in (2, 3)])'

     _Added in Python version 2.2_ _Changed in Python version 2.3_

`dir([object])'
     引数がない場合、現在のローカルシンボルテーブルにある名前のリストを
     返します。引数がある場合、そのオブジェクトの有効な属性からなるリスト
     を返そうと試みます。この情報はオブジェクトの `__dict__'
     属性が定義されている場合、そこから収集されます。また、
     クラスまたは型オブジェクトからも集められます。リストは完全なものに
     なるとは限りません。
     オブジェクトがモジュールオブジェクトの場合、リストにはモジュール属性
     の名前も含まれます。
     オブジェクトが型オブジェクトやクラスオブジェクトの場合、
     リストにはそれらの属性が含まれ、かつそれらの基底クラスの属性も
     再帰的にたどられて含まれます。
     それ以外の場合には、リストにはオブジェクトの属性名、クラス属性名、
     再帰的にたどった基底クラスの属性名が含まれます。
     返されるリストはアルファベット順に並べられています。 例えば:

          >>> import struct
          >>> dir()
          ['__builtins__', '__doc__', '__name__', 'struct']
          >>> dir(struct)
          ['__doc__', '__name__', 'calcsize', 'error', 'pack', 'unpack']

     _Note:_ `dir()' は第一に対話プロンプトのために提供されているので、
     厳密さや一貫性をもって定義された名前のセットよりも、むしろ興味深い名前
     のセットを与えようとします。また、この関数の細かい動作はリリース間で
     変わる可能性があります。

`divmod(a, b)'
     2 つの (複素数でない) 数値を引数として取り、長除法を行って
     その商と剰余からなるペアを返します。被演算子が型混合である場合、 2
     進算術演算子での規則が適用されます。通常の整数と長整数の場合、
     結果は  `(A / B, A %{} B)' と同じ です。浮動小数点数の場合、結果は
     `(Q, A %{} B)' であり、 Q は通常 `math.floor(A / B)' ですが、
     そうではなく 1 になることもあります。 いずれにせよ、`Q * B + A %{}
     B' は A に非常に近い値になり、 `A %{} B'
     がゼロでない値の場合、その符号は B と同じで、 `0 <= abs(A %{} B) <
     abs(B)' になります。

     _Changed in Python version 2.3_

`enumerate(iterable)'
     列挙オブジェクトを返します。ITERABLE は配列型、イテレータ型、
     あるいは反復をサポートする他のオブジェクト型でなければなりません。
     `enumerate()' が返すイテレータの `next()' メソッドは、
     (ゼロから始まる) カウント値と、値だけ ITERABLE を反復操作して
     得られる、対応するオブジェクトを含むタプルを返します。
     `enumerate()' はインデクス付けされた値の列: `(0, seq[0])', `(1,
     seq[1])', `(2, seq[2])', ...  を得るのに便利です。 _Added in
     Python version 2.3_

`eval(expression[, globals[, locals]])'
     引数は文字列とオプションの 2 つの辞書からなります。引数 EXPRESSION
     は Python の表現式 (技術的にいうと、条件のリストです)
     として構文解釈され、 評価されます。このとき辞書 GLOBALS および
     LOCALS はそれぞれ
     グローバルおよびローカルな名前空間として使われます。 LOCALS
     辞書が存在するが、'__builtins__' が欠けている場合、 EXPRESSION
     を解析する前に現在のグローバル変数を GLOBALS
     にコピーします。このことから、EXPRESSION は通常 標準の
     `__builtin__' モジュールへの完全なアクセス
     を有し、制限された環境が伝播するようになっています。 LOCALS
     辞書が省略された場合、標準の値として GLOBALS に
     設定されます。辞書が両方とも省略された場合、表現式は `eval' が
     呼び出されている環境の下で実行されます。構文エラーは例外として報告されます。

     以下に例を示します:

          >>> x = 1
          >>> print eval('x+1')
          2

     この関数は (`compile()' で生成されるような) 任意の
     コードオブジェクトを実行するために利用することもできます。
     この場合、文字列の代わりにコードオブジェクトを渡します。
     このコードオブジェクトは引数 KIND を `'eval'' にして
     コンパイルされていなければなりません。

     ヒント: 文の動的な実行は `exec' 文でサポートされています。
     ファイルからの文の実行は関数 `execfile()' でサポートされて
     います。関数 `globals()' および `locals()' は
     それぞれ現在のグローバルおよびローカルな辞書を返すので、 `eval()'
     や `execfile()' で使うことができます。

`execfile(filename[, globals[, locals]])'
     この関数は `exec' 文に似ていますが、文字列の代わりにファイルに
     対して構文解釈を行います。`import' 文と違って、モジュール管理
     機構を使いません -- この関数はファイルを無条件に読み込み、
     新たなモジュールを生成しません。(1)

     引数は文字列とオプションの 2 つの辞書からなります。FILE
     は読み込まれ、(モジュールのように) Python
     文の配列として評価されます。 このとき GLOBALS および LOCALS
     がそれぞれグローバル
     およびローカルな名前空間として使われます。LOCALS 辞書が
     省略された場合、標準の値として GLOBALS に設定されます。辞書が
     両方とも省略された場合、表現式は `execfiles' が呼び出されている
     環境の下で実行されます。戻り値は `None' です。

     _標準では LOCALS は後に述べる関数 `locals()'  のように動作します:
     標準の LOCALS 辞書に対する変更を試みては いけません。`execfile()'
     の呼び出しが返る時にコードが LOCALS
     に与える影響を知りたいなら、明示的に LOACALS 辞書を
     渡してください。`execfile()' は関数のローカルを変更するための
     信頼性のある方法として使うことはできません_

`file(filename[, mode[, bufsize]])'
     新たなファイルオブジェクト ( section~*Note ファイルオブジェクト::,
     "File +  Objects"参照) を返します。最初の 2 つの引数は `studio' の
     `fopen()' と同じです: FILENAME は開きたいファイルの名前で、 MODE
     はファイルをどのようにして開くかを指定します: 読み出しは
     `'r''、書き込み (ファイルがすでに存在すれば切り詰め られます) は
     `'w''、追記書き込みは `'a'' です (_いくつかの_ UNIX
     システムでは、_全て_ の書き込みが
     現在のファイルシーク位置に関係なくファイルの末尾に追加されます) 。

     `'r+''、`'w+''、および `'a+'' はファイルを更新 モードで開きます
     (`'w+'' はファイルがすでに存在すれば切り詰め
     るので注意してください) 。バイナリとテキストファイルを区別する
     システムでは、ファイルをバイナリモードで開くためには `'b''
     を追加してください (区別しないシステムでは `'b'' は無視されます)。
     ファイルを開くことができなければ、`IOError' が送出されます。

     標準の `fopen()' における MODE の値に加えて、 `'U'' または `'rU''
     を使うことができます。 Python が全改行文字サポートを行っている
     (標準ではしています)　場合,
     ファイルがテキストファイルで開かれますが、行末文字として Unix
     における 慣行である `'\n'' 、Machintosh における慣行である `'\r''、
     Windows における慣行である `'\r\n'' のいずれを使うことも
     できます。これらの改行文字の外部表現はどれも、Python
     プログラムからは `'\n'' に見えます。Python
     が全改行文字サポートなしで構築 されている場合、MODE `'U''
     は通常のテキストモードと
     同様になります。開かれたファイルオブジェクトはまた、`newlines'
     と呼ばれる属性を持っており、その値は `None' (改行が見つから
     なかった場合)、`'\n''、`'\r''、 `'\r\n''、
     または見つかった全ての改行タイプを含むタプルになります。

     MODE が省略された場合、標準の値は `'r'' になります。
     移植性を高めるためには、バイナリファイルを開くときには、MODE
     の値に `'b'' を追加しなければなりません。(バイナリファイルと
     テキストファイルを区別なく扱うようなシステムでも、ドキュメンテーション
     の代わりになるので便利です) オプションの BUFSIZE
     引数は、ファイルのために必要とする バッファのサイズを指定します: 0
     は非バッファリング、 1 は行単位
     バッファリング、その他の正の値は指定した値 (の近似値) のサイズを
     もつバッファを使用することを意味します。BUFSIZE の値が負の
     場合、システムの標準を使います。通常、端末は行単位のバッファリング
     であり、その他のファイルは完全なバッファリングです。省略された
     場合、システムの標準の値が使われます。 (2)

     `file()' コンストラクタは Python 2.2 で新たに追加されました。
     以前の関数名である `open()' は互換性のために残されており、
     `file()' の別名となっています。

`filter(function, list)'
     LIST のうち、FUNCTION が真を返すような要素からなる
     リストを構築します。LIST は配列か、反復をサポートするコンテナか、
     イテレータです。LIST が文字列型かタプル型の場合、結果も同じ型に
     なります。FUNCTION が `None' の場合、恒等関数を仮定
     します。すなわち、LIST の偽となる要素 (ゼロまたは空)
     は除去されます。

     function が `None' ではない場合、`filter(function, LIST)' は
     `[item for item in LIST if function(item)]' と同等です。 function
     が `None' の場合 `[item for item in LIST if  item]' と同等です。

`float([x])'
     文字列または数値を浮動小数点数に変換します。引数が文字列の場合、
     十進の数または浮動小数点数を含んでいなければなりません。符号が
     付いていてもかまいません。また、空白文字中に埋め込まれていても
     かまいません; これは `string.atof(X)' と同様の動作
     です。それ以外の場合、引数は通常整数、長整数、または浮動小数点
     数をとることができ、同じ値の浮動小数点数が (Python の浮動小数点
     精度で) 返されます。 引数が指定されなかった場合、`0.0' を返します。

     _Note:_ 文字列で値を渡す際、背後の C ライブラリによって NaN
     および Infinity  が返されるかもしれません。これらの
     値を返すような特殊な文字列のセットは完全に C
     ライブラリに依存しており、
     バリエーションがあることが知られています。

`getattr(object, name[, default])'
     指定された OBJECT の属性を返します。NAME は文字列で
     なくてはなりません。文字列がオブジェクトの属性名の一つであった
     場合、戻り値はその属性の値になります。例えば、 `getattr(x,
     'foobar')' は `x.foobar' と等価です。
     指定された属性が存在しない場合、DEFAULT が与えられている
     場合にはしれが返されます。そうでない場合には `AttributeError'
     が送出されます。

`globals()'
     現在のグローバルシンボルテーブルを表す辞書を返します。
     常に現在のモジュールの辞書になります (関数またはメソッドの中では
     それらを定義しているモジュールを指し、この関数を呼び出したモジュール
     ではありません)。

`hasattr(object, name)'
     引数はオブジェクトと文字列です。文字列がオブジェクトの属性名の一つ
     であった場合 `True' を、そうでない場合 `False' を返します
     (この関数は `getattr(OBJECT, NAME)' を呼び出し、
     例外を送出するかどうかを調べることで実装しています)。

`hash(object)'
     オブジェクトのハッシュ値を (存在すれれば) 返します。ハッシュ値は
     整数です。これらは辞書を検索する際に辞書のキーを高速に比較するために
     使われます。等しい値となる数値は等しいハッシュ値を持ちます (1 と
     1.0 のように型が異なっていてもです)。

`help([object])'
     組み込みヘルプシステムを起動します (この関数は対話的な使用のための
     ものです)。引数が与えられていない場合、対話的ヘルプシステムは
     インタプリタコンソール上で起動します。引数が文字列の場合、文字列は
     モジュール、関数、クラス、メソッド、キーワード、またはドキュメント
     の項目名として検索され、ヘルプページがコンソール上に印字されます。
     引数が何らかのオブジェクトの場合、そのオブジェクトに関するヘルプ
     ページが生成されます。 _Added in Python version 2.2_

`hex(x)'
     (任意のサイズの) 整数 を16進の文字列に変換します。結果は Python で
     有効な表現になります。注意: 値は常に符号無しのリテラルになります。
     例えば、 32 ビットのマシンでは、`hex(-1)' は `'0xffffffff''
     になります。同じワードサイズを持つ計算機で評価された場合、この
     文字列は -1 になります; 異なるワードサイズの計算機では、巨大な
     正の値に折り返されたり、例外 `OverflowError' を送出
     するかもしれません。

`id(object)'
     オブジェクトの '識別値' を返します。この値は整数 (または長整数)
     で、このオブジェクトの有効期間は一意かつ定数であることが保証されて
     います。 オブジェクトの有効期間が重ならない 2 つのオブジェクトは
     同じ `id()' 値を持つかもしれません。 (実装に関する注釈:
     この値はオブジェクトのアドレスです。)

`input([prompt])'
     `eval(raw_input(PROMPT))' と同じです。
     _この関数はユーザのエラーに対して安全ではありません! この関数
     では、入力は有効な Python の式であると期待しています; 入力が
     構文的に正しくない場合、`SyntaxError' が送出されます。
     式を評価する際にエラーが生じた場合、他の例外も送出されるかもしれません。
     (一方、この関数は時に、熟練者がすばやくスクリプトを書く際に必要なまさに
     そのものです)_

     `readline' モジュールが読み込まれていれば、`input()'
     は精緻な行編集およびヒストリ機能を提供します。

     一般的なユーザからの入力のための関数としては `raw_input()'
     を使うことを検討してください。

`int([x[, radix]])'
     文字列または数値を通常の整数に変換します。引数が文字列の場合、
     Python 整数として表現可能な十進の数でなければなりません。
     符号が付いていてもかまいません。また、空白文字中に埋め込まれていても
     かまいません。RADIX 引数は変換の基数を表し、範囲 [2, 36] の
     整数またはゼロをとることができます。RADIX がゼロの場合、文字列の
     内容から適切な基数を推測します; 変換は整数リテラルと同じです。
     RADIX が指定されており、X が文字列でない場合、 `TypeError'
     が送出されます。
     それ以外の場合、引数は通常整数、長整数、または浮動小数点
     数をとることができます。浮動小数点数から整数へ変換では (ゼロ方向に)
     値を丸めます。
     引数が通常整数の範囲を超えている場合、長整数が代わりに返されます。
     引数が与えられなかった場合、`0' を返します。

`isinstance(object, classinfo)'
     引数 OBJECT が引数 CLASSINFO のインスタンスであるか、
     (直接または間接的な) サブクラスのインスタンスの場合に真を返します。
     また、CLASSINFO が型オブジェクトであり、OBJECT がその
     型のオブジェクトである場合にも真を返します。OBJECT が
     クラスインスタンスや与えられた型のオブジェクトでない場合、
     この関数は常に偽を返します。CLASSINFO をクラスオブジェクト
     でも型オブジェクトにもせず、クラスや型オブジェクトからなる
     タプルや、そういったタプルを再帰的に含むタプル (他の配列型は
     受理されません) でもかまいません。CLASSINFO がクラス、型、
     クラスや型からなるタプル、そういったタプルが再帰構造をとっている
     タプルのいじれでもない場合、例外 `TypeError' が送出 されます。
     _Changed in Python version 2.2_

`issubclass(class, classinfo)'
     CLASS が CLASSINFO の (直接または間接的な) サブクラスで
     ある場合に真を返します。クラスはそのクラス自体のサブクラスと
     CLASINFO はクラスオブジェクトからなるタプルでもよく、 この場合には
     CLASSINFO のすべてのエントリが調べ られます。その他の場合では、
     例外 `TypeError' が送出されます。 _Changed in Python version 2.3_

`iter(o[, sentinel])'
     イテレータオブジェクトを返します。2 つ目の引数があるかどうかで、
     最初の引数の解釈は非常に異なります。2 つ目の引数がない場合、 O
     は反復プロトコル (`__iter__()' メソッド) か、 配列プロトコル
     (引数が `0' から開始する `__getitem__()' メソッド)
     をサポートする集合オブジェクト
     でなければなりません。これらのプロトコルが両方ともサポート
     されていない場合、 `TypeError' が送出されます。 2 つ目の引数
     SENTINEL が与えられていれば、O
     は呼び出し可能なオブジェクトでなければなりません。この場合に
     生成されるイテレータは、`next()' を呼ぶ毎に O を引数無し
     で呼び出します。返された値が SENTINEL と等しければ、
     `StopIteration' が送出されます。そうでない場合、
     戻り値がそのまま返されます。 _Added in Python version 2.2_

`len(s)'
     オブジェクトの長さ (要素の数) を返します。引数は配列型 (文字列、
     タプル、またはリスト) か、マップ型 (辞書) です。

`list([sequence])'
     SEQUENCE の要素と同じ要素をもち、かつ順番も同じなリストを
     返します。SEQUENCE は配列、反復処理をサポートするコンテナ、
     あるいはイテレータオブジェクトです。SEQUENCE がすでにリストの
     場合、`SEQUENCE[:]' と同様にコピーを作成して返します。
     例えば、`list('abc')' は `['a', 'b', 'c']' および `list(1, 2, 3)'
     は `[1, 2, 3]' を返します。
     引数が与えられなかった場合、新しい空のリスト `[]' を返します。

`locals()'
     現在のローカルシンボルテーブルを表す辞書を更新して返します。
     _この辞書の内容は変更してはいけません; 値を変更しても、
     インタプリタが使うローカル変数の値には影響しません。_

`long([x[, radix]])'
     文字列または数値を長整数値に変換します。引数が文字列の場合、
     Python 整数として表現可能な十進の数でなければなりません。
     符号が付いていてもかまいません。また、空白文字中に埋め込まれていても
     かまいません; これは `string.atol(X)' と同様の動作です。RADIX
     引数は `int()' と同じように 解釈され、X
     が文字列の時だけ与えることができます。
     それ以外の場合、引数は通常整数、長整数、または浮動小数点
     数をとることができ、同じ値の長整数が返されます。浮動小数点数から
     整数へ変換では (ゼロ方向に) 値を丸めます。
     引数が与えられなかった場合、`0L' を返します。

`map(function, list, ...)'
     FUNCTION を LIST の全ての要素に適用し、返された
     値からなるリストを返します。追加の LIST 引数を与えた場合、
     FUNCTION はそれらを引数として取らなければならず、関数は
     そのリストの全ての要素について個別に適用されます; 他のリストより
     短いリストがある場合、要素 `None' で延長されます。FUNCTION が
     `None' の場合、恒等関数であると仮定されます; すなわち、
     複数のリスト引数が存在する場合、`map()' は全てのリスト引数に
     対し、対応する要素からなるタプルからなるリストを返します
     (転置操作の ようなものです)。LIST
     引数はどのような配列型でもかまいません;
     結果は常にリストになります。

`max(s[, args...])'
     単一の引数 S の場合、空でない配列 (文字列、タプルまたはリスト)
     の要素のうち最大のものを返します。1 個よりも引数が多い場合、引数
     間で最大のものを返します。

`min(s[, args...])'
     単一の引数 S の場合、空でない配列 (文字列、タプルまたはリスト)
     の要素のうち最小のものを返します。1 個よりも引数が多い場合、引数
     間で最小のものを返します。

`object()'
     ユーザ定義の属性やメソッドを持たない、新しいオブジェクトを返します。
     `object()' は新スタイルのクラスの、基底クラスです。これは、新ス
     タイルのクラスのインスタンスに共通のメソッド群を持ちます。 _Added
     in Python version 2.2_

     _Changed in Python version 2.3_

`oct(x)'
     (任意のサイズの) 整数を 8 進の文字列に変換します。結果は有効な
     Python の表現形式になります。注意:
     値は常に符号無しのリテラルになります。 例えば、 32
     ビットのマシンでは、`oct(-1)' は `'037777777777''
     になります。同じワードサイズを持つ計算機で評価された場合、この
     文字列は -1 になります; 異なるワードサイズの計算機では、巨大な
     正の値に折り返されたり、例外 `OverflowError' を送出
     するかもしれません。

`open(filename[, mode[, bufsize]])'
     前述の関数 `file()' の別名です。

`ord(c)'
     1 文字からなる文字列または Unicode 文字の ASCII 値を返します。
     例えば、`ord('a')' は整数 `97' を返し、 `ord(u'\u2020')' は `8224'
     を返します。この値は 文字列に対する `chr()' の逆であり、Unicode
     文字に対する `unichr()' の逆です。

`pow(x, y[, z])'
     X の Y 乗を返します; Z があれば、 X の Y 乗に対する Z
     のモジュロを返します (`pow(X, Y)% Z' より効率よく計算 されます)
     。引数は数値型でなくてはなりません。型混合の場合、 2
     進算術演算における型強制規則が適用されます。通常整数
     および長整数の被演算子に対しては、二つ目の引数が負の数でない
     限り、結果は (型強制後の)被演算子と同じ型になります;
     負の場合、全ての引数は浮動小数点型に変換され、浮動小数点
     型の結果が返されます。例えば、 `10**2' は `100' を返しますが、
     `100**-2' は `0.01' を返します。 (最後に述べた機能は Python 2.2
     で追加されたものです。 Python 2.1
     以前では、双方の引数が整数で二つ目の値が負の
     場合、例外が送出されます。) 二つ目の引数が負の場合、
     三つめの引数は無視されます。Z がある場合、X および Y
     は整数型でなければならず、Y は非負
     の値でなくてはなりません。(この制限は Python 2.2 で追加
     されました。 Python 2.1 以前では、3 つの浮動小数点引数を 持つ
     `pow()' は浮動小数点の丸めに関する偶発誤差
     により、プラットフォーム依存の結果を返します。)

`property([fget[, fset[, fdel[, doc]]]])'
     新しい形式のクラス (`object' から導出されたクラス) における
     プロパティ属性を返します。

     FGET は属性値を取得するための関数で、同様に FSET は
     属性値を設定するための関数です。また、FDEL は属性を
     削除するための関数です。以下に属性 x
     を扱う典型的な利用法を示します:

          class C(object):
              def getx(self): return self.__x
              def setx(self, value): self.__x = value
              def delx(self): del self.__x
              x = property(getx, setx, delx, "I'm the 'x' property.")

     _Added in Python version 2.2_

`range([start,] stop[, step])'
     数列を含むリストを生成するための多機能関数です。`for'
     ループでよく使われます。引数は通常の整数でなければなりません。
     STEP 引数が無視された場合、標準の値 `1' になります。 START
     引数が蒸しされた場合標準の値 `0' になります。
     完全な形式では、通常の整数列 `[START, START + STEP, START + 2 *
     STEP, ...]' を返します。 STEP が正の値の場合、最後の要素は STOP
     よりも小さい `START + I * STEP' の最大値になります; STEP
     が負の値の場合、最後の要素は STOP よりも大きい `START + I * STEP'
     の最小値になります。 STEP はゼロであってはなりません (さもなければ
     `ValueError' が送出されます)。以下に例を示します:

          >>> range(10)
          [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
          >>> range(1, 11)
          [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
          >>> range(0, 30, 5)
          [0, 5, 10, 15, 20, 25]
          >>> range(0, 10, 3)
          [0, 3, 6, 9]
          >>> range(0, -10, -1)
          [0, -1, -2, -3, -4, -5, -6, -7, -8, -9]
          >>> range(0)
          []
          >>> range(1, 0)
          []


`raw_input([prompt])'
     引数 PROOMPT が存在する場合、末尾の改行を除いて標準出力に出力
     されます。次に、この関数は入力から 1 行を読み込んで文字列に変換して
     (末尾の改行を除いて) 返します。`EOF' が読み込まれると `EOFError'
     が送出されます。以下に例を示します:

          >>> s = raw_input('--> ')
          --> Monty Python's Flying Circus
          >>> s
          "Monty Python's Flying Circus"

     `readline' モジュールが読み込まれていれば、`input()'
     は精緻な行編集およびヒストリ機能を提供します。

`reduce(function, sequence[, initializer])'
     SEQUENCE の要素に対して、配列を単一の値に短縮するような形で 2
     つの引数をもつ FUNCTION を左から右に累積的に適用します。
     例えば、`reduce(labmda x, y: x+y, [1, 2, 3, 4, 5])' は
     `((((1+2)+3)+4)+5)' を計算します。左引数X は累計の値になり、右引数
     Y は`sequence' から取り出した 更新値になります。オプションの
     INITIALIZER
     が存在する場合、計算の際に配列の先頭に置かれます。また、
     配列が空の場合には標準の値になります。INITIALIZER が与えられて
     おらず、SEQUENCE が単一の要素しか持っていない場合、
     最初の要素が返されます。

`reload(module)'
     すでにインポートされた MODULE を再解釈し、再初期化します。
     引数はモジュールオブジェクトでなければならないので、予めインポート
     に成功していなければなりません。この関数はモジュールのソースコード
     ファイルを外部エディタで編集して、Python インタプリタから
     離れることなく新しいバージョンを試したい際に有効です。 戻り値は
     (MODULE 引数と同じ) モジュールオブジェクトです。

     いくつか補足説明があります:

     モジュールは文法的に正しいが、その初期化には失敗した場合、
     そのモジュールの最初の `import' 文はモジュール名を
     ローカルにはバインドしませんが、(部分的に初期化された) モジュール
     オブジェクトを `sys.modules' に記憶します。従って、モジュールを
     ロードしなおすには、`reload()' する前にまず `import'
     (モジュールの名前を部分的に初期化されたオブジェクトにバインドします)
     を再度行わなければなりません。

     モジュールが再ロードされた再、その辞書
     (モジュールのグローバル変数を 含みます)
     はそのまま残ります。名前の再定義を行うと、以前の定義を
     上書きするので、一般的には問題はありません。新たなバージョンのモジュール
     が古いバージョンで定義された名前を定義していない場合、古い定義が
     そのまま残ります。
     辞書がグローバルテーブルやオブジェクトのキャッシュを維持していれば、
     この機能をモジュールを有効性を引き出すために使うことができます --
     つまり、 `try'
     文を使えば、必要に応じてテーブルがあるかどうかをテストし、
     その初期化を飛ばすことができるのです。

     組み込みモジュールや動的にロードされるモジュールを再ロードする
     ことは、不正なやり方ではありませんが、一般的にそれほど便利では
     ありません。例外は `sys'、`__main__' および `__builtin__' です。
     しかしながら、多くの場合、拡張モジュールは 1 度以上初期化される
     ようには設計されておらず、再ロードされた場合には何らかの理由で
     失敗するかもしれません。

     一方のモジュールが `from' ... `import' ...
     を使って、オブジェクトを他方のモジュールからインポートしているなら、
     他方のモジュールを `reload()' で呼び出しても、その
     モジュールからインポートされたオブジェクトを再定義することは
     できません -- この問題を回避する一つの方法は、`from' 文を
     再度実行することで、もう一つの方法は `from' 文の代わりに `import'
     と限定的な名前 (MODULE.NAME) を使うことです。

     あるモジュールがクラスのインスタンスを生成している場合、その
     クラスを定義しているモジュールの再ロードはそれらインスタンスの
     メソッド定義に影響しません -- それらは古いクラス定義を使いつづけ
     ます。これは導出クラスの場合でも同じです。

`repr(object)'
     オブジェクトの印字可能な表現を含む文字列を返します。これは
     型変換で得られる (逆クオートの) 値と同じです。通常の関数として
     この操作にアクセスできるとたまに便利です。この関数は多くの型について、
     `eval()' に渡されたときに同じ値を持つようなオブジェクトを
     表す文字列を生成しようとします。

`round(x[, n])'
     X を小数点以下 N 桁で丸めた浮動小数点数の値を返します。 N
     が省略されると、標準の値はゼロになります。結果は浮動小数点
     数です。値は最も近い 10 のマイナス N の倍数に丸められます。
     二つの倍数との距離が等しい場合、ゼロから離れる方向に丸められます
     (従って、例えば `round(0.5)' は `1.0' になり、 `round(-0.5)' は
     `-1.0' になります)。

`setattr(object, name, value)'
     `getattr()' と対をなす関数です。引数はそれぞれオブジェクト、
     文字列、そして任意の値です。文字列はすでに存在する属性の名前でも、
     新たな属性の名前でもかまいません。この関数は指定した値を指定した属性に
     関連付けますが、指定したオブジェクトにおいて可能な場合に限ります。
     例えば、`setattr(X, 'FOOBAR', 123)' は `X.FOOBAR = 123'
     と等価です。

`slice([start,] stop[, step])'
     `range(START, STOP, STEP)' で指定される
     インデクスの集合を表すスライスオブジェクトを返します。
     `range(START)'スライスオブジェクトを返します。 引数 START および
     STEP は標準では `None' です。
     スライスオブジェクトは読み出し専用の属性 `start'、`stop' および
     `step' を持ち、これらは単に引数で使われた値 (または 標準の値)
     を返します。これらの値には、その他のはっきりとした機能は
     ありません; しかしながら、これらの値は Numerical Python
     およびその他のサードパーティによる拡張
     で利用されています。スライスオブジェクトは拡張されたインデクス指定
     構文が使われる際にも生成されます。例えば: `a[start:stop:step]' や
     `a[start:stop, i]' です。

`staticmethod(function)'
     FUNCTION の静的メソッドを返します。

     静的メソッドは暗黙の第一引数を受け取りません。
     静的メソッドの宣言は、以下のように書き慣わされます:

          class C:
              def f(arg1, arg2, ...): ...
              f = staticmethod(f)

     このメソッドはクラスで呼び出すこと (例えば C.f() ) も、
     インスタンスとして呼び出すこと (例えば C().f()) もできます。
     インスタンスはそのクラスが何であるかを除いて無視されます。

     Python における静的メソッドは Java や C++ における静的メソッドと
     類似しています。より進んだ概念については、 `classmethod()'
     を参照してください。 _Added in Python version 2.2_

`str([object])'
     オブジェクトをうまく印字可能な形に表現したものを含む文字列を返します。
     文字列に対してはその文字列自体を返します。`repr(OBJECT)'
     との違いは、`str(OBJECT)' は常に `eval()' が
     受理できるような文字列を返そうと試みるわけではないという点です;
     この関数の目的は印字可能な文字列を返すところにあります。
     引数が与えられなかった場合、空の文字列 `''' を返します。

`sum(sequence[, start])'
     START と SEQUENCE の要素を左から右へ加算してゆき、
     総和を返します。START はデフォルトで `0' です。 SEQUENCE
     の要素は通常は数値で、文字列であってはなりません。
     文字列からなる配列をを結合する高速で、正しい方法は
     `''.join(SEQUENCE)' です。 `sum(range(N), M)' は
     `reduce(operator.add, range(N), M)' と同等です。 _Added in Python
     version 2.3_

`super(type[, object-or-type])'
     TYPE の上位クラスを返します。返された上位クラスオブジェクトが非バ
     インドの場合、二つめの引数は省略されます。二つめの引数がオブジェクトの場
     合、`isinstance(OBJ, TYPE)' は真でなくてはなりません。
     二つ目の引数が型オブジェクトの場合、`issubclass(TYPE2,  TYPE)'
     は真でなくてはなりません。 `super()'
     は新スタイルのクラスにのみ機能します。

     協調する上位クラスのメソッドを呼び出す典型的な利用法を以下に示します:
          class C(B):
              def meth(self, arg):
                  super(C, self).meth(arg)

     _Added in Python version 2.2_

`tuple([sequence])'
     SEQUENCE の要素と要素が同じで、かつ順番も同じになるタプルを
     返します。SEQUENCE は配列、反復をサポートするコンテナ、
     およびイテレータオブジェクトをとることができます。 SEQUENCE
     がすでにタプルの場合、そのタプルを変更せずに返します。
     例えば、`tuple('abc')' は `('a', 'b', 'c')' を返し、 `tuple([1, 2,
     3])' は `(1, 2, 3)' を返します。

`type(object)'
     OBJECT の型を返します。返される値は型 オブジェクト
     です。標準モジュール `types'
     は、組み込み名を持っていない全ての組み込み型の名前を定義しています。
     引数が与えられない場合、新しい空のタプル `()' を返します。

     例えば:

          >>> import types
          >>> x = 'abc'
          >>> if type(x) is str: print "It's a string"
          ...
          It's a string
          >>> def f(): pass
          ...
          >>> if type(f) is types.FunctionType: print "It's a function"
          ...
          It's a function

     オブジェクトの型のテストには、組み込み関数 `isinstance()'
     が推奨されています。

`unichr(i)'
     Unicode におけるコードが整数 I になるような文字 1 文字からなる
     Unicode 文字列を返します。例えば、`unichr(97)' は文字列 `u'a''
     を返します。この関数は Unicode 文字列に対する `ord()' の逆
     です。引数は両端を含めて [0..65535] の範囲でなければなりません。
     それ以外の値に対しては  `ValueError' が送出されます。 _Added in
     Python version 2.0_

`unicode([object[, encoding [, errors]]])'
     以下のモードのうち一つを使って、OBJECT のUnicode 文字列
     バージョンを返します:

     もし ENCODING かつ/または ERRORS が与えられていれば、 `unicode()'
     は 8 ビットの文字列または文字列バッファになっている オブジェクトを
     ENCODING の codec を使ってデコードします。 ENCODING
     パラメタはエンコーディング名を与える文字列です;
     未知のエンコーディングの場合、`LookupError' が送出されます。
     エラー処理は ERRORS に従って行われます; このパラメタは
     入力エンコーディング中で無効な文字の扱い方を指定します。ERRORS が
     `'strict'' (標準の設定です) の場合、エラー発生時には `ValueError'
     が送出されます。一方、`'ignore'' では、
     エラーは暗黙のうちに無視されるようになり、`'replace'' では
     公式の置換文字、`U+FFFD' を使って、デコードできなかった
     文字を置き換えます。`codecs' モジュールについても参照して
     ください。

     オプションのパラメタが与えられていない場合、 `unicode()' は
     `str()' の動作をまねます。ただし、8 ビット文字列ではなく、 Unicode
     文字列を返します。もっと詳しくいえば、 OBJECT が Unicode
     文字列かそのサブクラスなら、デコード処理を一切介する ことなく
     Unicode 文字列を返すということです。

     `__unicode__()' メソッドを提供しているオブジェクトの場合、
     `unicode()' はこのメソッドを引数なしで呼び出して Unicode
     文字列を生成します。それ以外のオブジェクトの場合、 8
     ビットの文字列か、オブジェクトのデータ表現 (representation)
     を呼び出し、その後デフォルトエンコーディングで `'strict'' モードの
     codec を使って Unicode 文字列に変換します。

     _Added in Python version 2.0_ _Changed in Python version 2.2_

`vars([object])'
     引数無しでは、現在のローカルシンボルテーブルに対応する辞書を
     返します。モジュール、クラス、またはクラスインスタンスオブジェクト
     (またはその他 `__dict__' 属性を持つもの) を引数として与えた場合、
     そのオブジェクトのシンボルテーブルに対応する辞書を返します。
     返される辞書は変更すべきではありません:
     変更が対応するシンボルテーブル にもたらす影響は未定義です。(3)

`xrange([start,] stop[, step])'
     この関数は `range()' に非常によく似ていますが、リストの代わり に
     "xrange オブジェクト" を返します。このオブジェクトは不透明な
     配列型で、対応するリストと同じ値を持ちますが、それらの値全てを
     同時に記憶しません。`ragne()' に対する `xrange()'
     の利点は微々たるものです (`xrange()' は要求に応じて
     値を生成するからです) ただし、メモリ量の厳しい計算機で
     巨大な範囲の値を使う時や、(ループがよく `break' で中断
     されるといったように) 範囲中の全ての値を使うとは限らない場合は
     その限りではありません。

`zip(seq1, ...)'
     この関数はタプルのリストを返します。このリストの I 番目のタプルは
     各引数の配列中の I 番目の要素を含みます。少なくとも 1 つの
     配列が引数に必要で、そうでない場合には `TypeError' が
     送出されます。返されるリストは引数の配列のうち長さが最小のものの
     長さに切り詰められます。引数の配列が全て同じ長さの際には、 `zip()'
     は初期値引数が `None' の `map()'
     と似ています。引数が単一の配列の場合、1 要素のタプルからなる
     リストを返します。 _Added in Python version 2.0_

---------- Footnotes ----------

(1) この関数は比較利用されない
方なので、将来構文にするかどうかは保証できません。

(2)  現状では、`setvbuf()' を持っていないシステムでは、
バッファサイズを指定しても効果はありません。バッファサイズを指定
するためのインタフェースは `setvbuf()' を使っては 行われていません。
何らかの I/O が実行された後で呼び出されるとコアダンプすることが
あり、どのような場合にそうなるかを決定する信頼性のある方法が
ないからです。

(3) 現在の実装では、ローカルな値
のバインディングは通常は影響を受けませんが、(モジュールのような)
他のスコープから取り出した値は影響を受けるかもしれません。また
この実装は変更されるかもしれません。

