This is python-lib-jp.info, produced by makeinfo version 4.5 from
python-lib-jp.texi.

12 October 2005


File: python-lib-jp.info,  Node: ファイルオブジェクト,  Next: 他の組み込み型,  Prev: マップ型,  Up: 組み込み型

ファイルオブジェクト
--------------------

ファイルオブジェクト  は C の`stdio' パッケージを使って実装されており、
*Note 組み込み関数:: 節の "組み込み関数"
で解説されている組み込みのコンストラクタ `file()'
で生成することができます。 (1)

ファイルオブジェクトはまた、`os.popen()' や `os.fdopen()'
、ソケットオブジェクトの `makefile()'
メソッドのような、他の組み込み関数およびメソッドによっても返されます。

ファイル操作が I/O 関連の理由で失敗した場合例外 `IOError'
が送出されます。この理由には例えば `seek()' を端末デバイスに
行ったり、読み出し専用で開いたファイルに書き込みを行うといった、
何らかの理由によってそのファイルで定義されていない操作を行った
ような場合も含まれます。

ファイルは以下のメソッドを持ちます:

`close()'
     ファイルを閉じます。閉じられたファイルはそれ以後読み書きすることは
     できません。ファイルが開かれていることが必要な操作は、ファイルが
     閉じられた後はすべて `ValueError' を送出します。 `close'
     を一度以上呼び出してもかまいません。

`flush()'
     `stdio' の `fflush()' のように、内部バッファを
     フラッシュします。ファイル類似のオブジェクトによっては、この
     操作は何も行いません。

`fileno()'
     背後にある実装系がオペレーティングシステムに I/O
     操作を要求するために 用いる、整数の "ファイル記述子"
     を返します。この値は他の用途として、 `fcntl'  モジュールや
     `os.read()'
     やその仲間のような、ファイル記述子を必要とする低レベルのインタフェース
     で役に立ちます。 _Note:_
     ファイル類似のオブジェクトが実際のファイルに関連付けられていない
     場合、このメソッドを提供すべきでは_ありません。_

`isatty()'
     ファイルが tty (または類似の) デバイスに接続されている場合 `True'
     を返し、そうでない場合 `False' を返します。 _Note:_
     ファイル類似のオブジェクトが実際のファイルに関連付けられていない
     場合、このメソッドを実装_すべきではありません。_

`next()'
     ファイルオブジェクトはそれ自身がイテレータです。すなわち、
     `iter(F)' は (F が閉じられていない限り) F を返します。`for' ループ
     (例えば `for line in f: print line')
     のようにファイルがイテレータとして 使われた場合、`next()'
     メソッドが繰り返し呼び出されます。
     個のメソッドは次の入力行を返すか、または `EOF' に到達したときに
     `StopIteration' を送出します。ファイル内の各行に対する `for'
     ループ (非常によくある操作です) を効率的な方法で
     行うために、`next()' メソッドは隠蔽された先読みバッファ
     を使います。先読みバッファを使った結果として、(`readline()'
     のような) 他のファイルメソッドと `next()' を組み合わせて使うと
     うまく動作しません。しかし、`seek()' を使ってファイル位置
     を絶対指定しなおすと、先読みバッファはフラッシュされます。

     _Added in Python version 2.3_

`read([size])'
     最大で SIZE バイトをファイルから読み込みます (SIZE バイト
     を取得する前に `EOF' に到達した場合、それ以下の長さになります)
     SIZE 引数が負であるか省略された場合、`EOF' に到達するまでの
     全てのデータを読み込みます。読み出されたバイト列は文字列オブジェクト
     として返されます。直後に `EOF'
     に到達した場合、空の文字列が返されます。
     (端末のようなある種のファイルでは、 `EOF' に到達した後でファイルを
     読みつづけることにも意味があります。) このメソッドは、SIZE
     バイトに可能な限り近くデータを取得するために、背後の C 関数
     `fread()' を 1 度以上呼び出すかもしれないので注意してください。
     また、非ブロック・モードでは、SIZE パラメータが与えられなくても、
     要求されたよりも少ないデータが返される場合があることに注意してください。

`readline([size])'
     ファイルから一行を読み出します。末尾の改行文字は文字列中に
     残されます (2)
     (ファイルが改行のない不完全な行の場合には、改行文字がないかも
     しれませんが) 。引数 SIZE が指定されていて非負の場合、
     (末尾の改行を含めて) 読み込む最大のバイト数です。この場合、
     不完全な行が返されるかもしれません。空文字列が返されるのは、
     直後に `EOF' に到達した場合 _だけ_ です。 _Note:_ `stdio' の
     `fgets()' と違い、入力中に ヌル文字 (`'\0'')
     が含まれていれば、ヌル文字を含んだ 文字列が返されます。

`readlines([sizehint])'
     `readline()' を使ってに到達するまで読み出し、`EOF'
     読み出された行を含むリストを返します。オプションの SIZEHINT
     引数が存在すれば、`EOF'まで読み出す代わりに 完全な行を全体で大体
     SIZEHINT バイトになるように
     (おそらく内部バッファサイズを切り詰めて) 読み出します。
     ファイル類似のインタフェースを実装しているオブジェクトは、
     SIZEHINT を実装できないか効率的に実装できない場合には
     無視してもかまいません。

`xreadlines()'
     個のメソッドは `iter(f)' と同じ結果を返します。 _Added in Python
     version 2.1_ _This is deprecated in Python 2.3.  代わりに `for
     line in file' を使ってください。_

`seek(offset[, whence])'
     `stdio' の `fseek()' と同様に、ファイルの現在位置を
     返します。WHENCE 引数はオプションで、標準の値は `0' (絶対位置指定)
     です; 他に取り得る値は `1' (現在のファイル位置 から相対的に seek
     する) および `2' (ファイルの末端から相対的に seek する)
     です。戻り値はありません。ファイルを追記モード (モード `'a''
     または `'a+'') で開いた場合、書き込みを行う までに行った`seek()'
     操作はすべて元に戻されるので注意してください。
     ファイルが追記のみの書き込みモード (`'a'') で開かれた場合、
     このメソッドは実質何も行いませんが、読み込みが可能な追記モード
     (`'a+'') で開かれたファイルでは役に立ちます。
     ファイルをテキストモード (`'t'') で開いた場合、 `tell()'
     が返すオフセットのみが正しい値になります。
     他のオフセット値を使った場合、その振る舞いは未定義です。

     全てのファイルオブジェクトが seek
     できるとは限らないので注意してください。

`tell()'
     `stdio' の `ftell()' と同様、ファイルの現在位置を 返します。

`truncate([size])'
     ファイルのサイズを切り詰めます。オプションの SIZE が存在
     すれば、ファイルは (最大で) 指定されたサイズに切り詰められます。
     標準設定のサイズの値は、現在のファイル位置までのファイルサイズです。
     現在のファイル位置は変更されません。指定されたサイズがファイルの
     現在のサイズを越える場合、その結果はプラットフォーム依存なので
     注意してください: 可能性としては、ファイルは変更されないか、
     指定されたサイズまでゼロで埋められるか、指定されたサイズまで
     未定義の新たな内容で埋められるか、があります。 利用可能な環境:
     Windows, 多くの UNIX 系。

`write(str)'
     文字列をファイルに書き込みます。戻り値はありません。バッファリング
     によって、`flush()' または `close()' が呼び出されるまで
     実際にファイル中に文字列が書き込まれないこともあります。

`writelines(sequence)'
     文字列からなる配列をファイルに書き込みます。配列は文字列を生成
     する反復可能なオブジェクトなら何でもかまいません。よくあるのは
     文字列からなるリストです。戻り値はありません。 (関数の名前は
     `readlines()' と対応づけてつけられました; `writelines()'
     は行間の区切りを追加しません)

ファイルはイテレータプロトコルをサポートします。各反復操作では
`FILE.readline()' と同じ結果を返し、反復は `readline()'
メソッドが空文字列を返した際に終了します。

ファイルオブジェクトはまた、多くの興味深い属性を提供します。
これらはファイル類似オブジェクトでは必要ではありませんが、
特定のオブジェクトにとって意味を持たせたいなら実装しなければ
なりません。

`closed'
     現在のファイルオブジェクトの状態を示すブール値です。この値は
     読み出し専用の属性です; `close()' メソッドがこの値を
     変更します。全てのファイル類似オブジェクトで利用可能とは
     限りません。

`encoding'
     このファイルが使っているエンコーディングです。Unicode 文字列が
     ファイルに書き込まれる際、Unicode 文字列はこのエンコーディングを
     使ってバイト文字列に変換されます。さらに、ファイルが端末に
     接続されている場合、この属性は端末が使っているとおぼしきエンコーディング
     (この情報は端末がうまく設定されていない場合には不正確なこともあります)
     を与えます。この属性は読み出し専用で、すべてのファイル類似オブジェクト
     にあるとは限りません。またこの値は `None' のこともあり、
     この場合、ファイルはUnicode
     文字列の変換のためにシステムのデフォルト
     エンコーディングを使います。

     _Added in Python version 2.3_

`mode'
     ファイルの I/O モードです。ファイルが組み込み関数 `open()'
     で作成された場合、この値は引数 MODE の値になります。
     この値は読み出し専用の属性で、全てのファイル類似オブジェクトに
     存在するとは限りません。

`name'
     ファイルオブジェクトが `open()' を使って生成された時の
     ファイルの名前です。そうでなければ、ファイルオブジェクト生成の
     起源を示す何らかの文字列になり、`<...>' の形式を
     とります。この値は読み出し専用の属性で、全てのファイル類似オブジェクトに
     存在するとは限りません。

`newlines'
     Python をビルドするとき、`--with-universal-newlines' オプションが指
     定された場合（デフォルト）、この読み出し専用の属性が存在します。一般的な
     改行に変換する読み出しモードで開かれたファイルにおいて、この属性はファイ
     ルの読み出し中に遭遇した改行コードを追跡します。取り得る値は
     `'\r''、`'\n''、`'\r\n''、`None' (不明または、まだ改行
     していない）、見つかった全ての改行文字を含むタプルのいずれかです。最後の
     タプルは、複数の改行慣例に遭遇したことを示します。一般的な改行文字を使う
     読み出しモードで開かれていないファイルの場合、この属性の値は `None'
     です。

`softspace'
     `print' 文を使った場合、他の値を出力する前にスペース文字を
     出力する必要があるかどうかを示すブール値です。
     ファイルオブジェクトをシミュレート仕様とするクラスは書き込み可能な
     `softspace' 属性を持たなければならず、この値はゼロに初期化
     されなければなりません。この値は Python で実装されているほとんどの
     クラスで自動的に初期化されます (属性へのアクセス手段を上書きする
     ようなオブジェクトでは注意が必要です); C で実装された型では、
     書き込み可能な `softspace' 属性を提供しなければなりません。
     _Note:_ この属性は `print' 文を制御するために用いられますが、
     `print' の内部状態を乱さないために、その実装を行うことは
     できません。

---------- Footnotes ----------

(1)  `file()' は Python 2.2 で新しく追加されました。
古いバージョンの組み込み関数 `open()' は `file()' の別名です。

(2) 改行を残す利点は、空の文字列が返ると `EOF'
を示し、紛らわしくなくなるからです。また、ファイルの最後の行
が改行で終わっているかそうでない (ありえることです！) か
(例えば、ファイルを行単位で読みながらその完全なコピーを作成
した場合には問題になります) を調べることができます。


File: python-lib-jp.info,  Node: 他の組み込み型,  Next: 特殊な属性,  Prev: ファイルオブジェクト,  Up: 組み込み型

他の組み込み型
--------------

インタプリタはその他の種類のオブジェクトをいくつかサポート
します。これらのほとんどは 1 または 2 つの演算だけをサポート します。

* Menu:

* モジュール::
* Classes and Instances::
* 関数::
* メソッド::
* コードオブジェクト::
* 型オブジェクト::
* ヌルオブジェクト::
* 省略表記オブジェクト::
* ブール値::
* 内部オブジェクト::


File: python-lib-jp.info,  Node: モジュール,  Next: Classes and Instances,  Prev: 他の組み込み型,  Up: 他の組み込み型

モジュール
..........

モジュールに対する唯一の特殊な演算は属性へのアクセス: `M.NAME'
です。ここで M はモジュールで、 NAME は M
のシンボルテーブル上に定義された名前に
アクセスします。モジュール属性も代入することができます。 (`import'
文は、厳密にいえば、モジュールオブジェクトに 対する演算です; `import
FOO' は FOO と名づけられた
モジュールオブジェクトが存在することを必要とはせず、 むしろ FOO
と名づけられた (外部の) モジュールの_定義_ を必要とします。)

各モジュールの特殊なメンバは `__dict__' です。
これはモジュールのシンボルテーブルを含む辞書です。
この辞書を修正すると、実際にはモジュールのシンボルテーブルを変更
しますが、`__dict__' 属性を直接代入することはできません
(`M.__dict__['a'] = 1' と書いて `M.a' を `1'
に定義することはできますが、`M.__dict__ = {}' と 書くことはできません)
。

インタプリタ内に組み込まれたモジュールは、 `<module 'sys' (built-in)>'
のように書かれます。 ファイルから読み出された場合、 `<module 'os' from
'/usr/local/lib/python2.3/os.pyc'>' と書かれます。


File: python-lib-jp.info,  Node: Classes and Instances,  Next: 関数,  Prev: モジュール,  Up: 他の組み込み型

クラスおよびクラスインスタンス
..............................

これらに関しては、 の 3 章および 7 章を読んで下さい。


File: python-lib-jp.info,  Node: 関数,  Next: メソッド,  Prev: Classes and Instances,  Up: 他の組み込み型

関数
....

関数オブジェクトは関数定義によって生成されます。関数オブジェクトに
対する唯一の操作は、それを呼び出すことです: `FUNC(ARGUMENT-LIST)'.

関数オブジェクトには実際には 2 つの種: 組み込み関数とユーザ定義関数
があります。両方とも同じ操作 (関数の呼び出し) をサポートしますが、
実装は異なるので、オブジェクトの型も異なります。

関数の実装では、 2 つの読み出し専用属性を追加しています: `F.func_code'
は関数の "コードオブジェクト"  (以下を参照) であり、 `F.func_globals'
は関数のグローバル名前空間として使われる辞書です (F
が定義されているモジュールを M としたときの `M.__dict__' と同じです)。

関数オブジェクトはまた、例えば関数のメタ情報を関数に
付属させるといったことに使える、任意の属性の取得や設定をサポート
しています。それらの属性の取得や設定には、正規の属性をドット表記する
方法が使われます。_現在の実装では、関数の属性をサポートしている
のはユーザ定義関数のみなので注意してください。組み込み関数の属性は
将来サポートされるかもしれません。_

関数はもう一つの特殊な属性 `F.__dict__' (`F.func_dict'
として知られています) を持っており、
関数属性をサポートするために使われる名前空間を含んでいます。 `__dict__'
および `func_dict' は直接アクセスしたり、
辞書オブジェクトを設定することができます。関数の辞書は削除する
ことができません。


File: python-lib-jp.info,  Node: メソッド,  Next: コードオブジェクト,  Prev: 関数,  Up: 他の組み込み型

メソッド
........

メソッドは属性表記を使って呼び出される関数です。メソッドには二つの
種類があります: (リストへの`append()'のような) 組み込みメソッド
と、クラスインスタンスのメソッドです。組み込みメソッドはそれをサポート
する型と一緒に記述されています。

実装では、クラスインスタンスのメソッドに 2 つの読み込み専用の属性
を追加しています: `M.im_self' はメソッドが操作するオブジェクト
で、`M.im_func' はメソッドを実装している関数です。 `M(ARG-1, ARG-2,
..., ARG-N)' の呼び出しは、`M.im_func(M.im_self, ARG-1, ARG-2, ...,
ARG-N)' の呼び出しと完全に等価です。

クラスインスタンスメソッドには、 メソッドがインスタンスからアクセス
されるかクラスからアクセスされるかによって、それぞれ_バインド_ または
_非バインド_　があります。メソッドが非バインドメソッドの
場合、`im_self' 属性は `None' になるため、呼び出す際 には `self'
オブジェクトを明示的に第一引数として指定しなければ
なりません。この場合、`self' は非バインドメソッドのクラス (サブクラス)
のインスタンスでなければならず、そうでなければ `TypeError'
が送出されます。

関数オブジェクトと同じく、メソッドオブジェクトは任意の属性を取得
できます。しかし、メソッド属性は実際には背後の関数オブジェクト
(`meth.im_func') に記憶されているので、バインド、ヒバインド
メソッドへのメソッド属性の設定は許されていません。
メソッド属性の設定を試みると `TypeError' が送出されます。
メソッド属性を設定するためには、その背後の関数オブジェクトで 明示的に:

     class C:
         def method(self):
             pass
     
     c = C()
     c.method.im_func.whoami = 'my name is c'

のように設定しなければなりません。 詳しくは

を読んで下さい。


File: python-lib-jp.info,  Node: コードオブジェクト,  Next: 型オブジェクト,  Prev: メソッド,  Up: 他の組み込み型

コードオブジェクト
..................

コードオブジェクトは、関数本体のような "擬似コンパイルされた" Python
の実行可能コードを表すために実装系によって使われます。
コードオブジェクトはグローバルな実行環境への参照を持たない点で
関数オブジェクトとは異なります。コードオブジェクトは 組み込み関数
`compile()' によって返され、関数オブジェクト の `func_code'
属性として取り出すことができます。

コードオブジェクトは `exec' 文や組み込み関数 `eval()'
に(ソースコード文字列の代わりに) 渡すことで、実行したり値評価したり
することができます。

詳しくは

を読んで下さい。


File: python-lib-jp.info,  Node: 型オブジェクト,  Next: ヌルオブジェクト,  Prev: コードオブジェクト,  Up: 他の組み込み型

型オブジェクト
..............

型オブジェクトは様々なオブジェクト型を表します。オブジェクトの型は
組み込み関数 `type()' でアクセスされます。型オブジェクトには
特有の操作はありません。標準モジュール `types' には全ての
組み込み型名が定義されています。

型は `<type 'int'>' のように書き表されます。


File: python-lib-jp.info,  Node: ヌルオブジェクト,  Next: 省略表記オブジェクト,  Prev: 型オブジェクト,  Up: 他の組み込み型

ヌルオブジェクト
................

このオブジェクトは明示的に値を返さない関数によって返されます。
このオブジェクトには特有の操作はありません。ヌルオブジェクト
は一つだけで、`None' (組み込み名) と名づけられています。

`None' と書き表されます。


File: python-lib-jp.info,  Node: 省略表記オブジェクト,  Next: ブール値,  Prev: ヌルオブジェクト,  Up: 他の組み込み型

省略表記オブジェクト
....................

このオブジェクトは拡張スライス表記によって使われます ( を参照して
ください)。特殊な操作は何もサポートしていません。省略表記オブジェクト
は一つだけで、その名前は `Ellipsis' (組み込み名) です。

`Ellipsis' と書き表されます。


File: python-lib-jp.info,  Node: ブール値,  Next: 内部オブジェクト,  Prev: 省略表記オブジェクト,  Up: 他の組み込み型

ブール値
........

ブール値とは二つの定数オブジェクト `False' および `True' です。
これらは真偽値を表すために使われます (他の値も偽または真とみなされ
ます) 数値処理のコンテキスト (例えば算術演算子の引数として使われた
場合) では、これらはそれぞれ 0 および 1 と同様に振舞います。
任意の値に対して真偽値を変換できる場合、組み込み関数 `bool()' は
値をブール値にキャストするのに使われます (真値テストの節を参照
してください)

これらはそれぞれ `False' および `True' と書き表されます。


File: python-lib-jp.info,  Node: 内部オブジェクト,  Prev: ブール値,  Up: 他の組み込み型

内部オブジェクト
................

この情報については  を読んで
下さい。このオブジェクトではスタックフレーム、トレースバック、
スライスオブジェクトを記述しています。


File: python-lib-jp.info,  Node: 特殊な属性,  Prev: 他の組み込み型,  Up: 組み込み型

特殊な属性
----------

実装では、いくつかのオブジェクト型に対して、数個の読み出し専用の特殊な
属性を追加しています。それぞれ:

`__dict__'
     オブジェクトの (書き込み可能な)
     属性を保存するために使われる辞書または
     他のマップ型オブジェクトです。

`__methods__'
     _This is deprecated in Python 2.2.
     オブジェクトの属性からなるリストを取得するには、 組み込み関数
     `dir()' を使ってください。この属性はもう 利用できません。_

`__members__'
     _This is deprecated in Python 2.2.
     オブジェクトの属性からなるリストを取得するには、 組み込み関数
     `dir()' を使ってください。この属性はもう 利用できません。_

`__class__'
     クラスインスタンスが属しているクラスです。

`__bases__'
     クラスオブジェクトの基底クラスからなるタプルです。基底クラスを
     持たない場合、空のタプルになります。


File: python-lib-jp.info,  Node: 組み込み例外,  Next: 組み込み定数,  Prev: 組み込み型,  Up: 組み込みオブジェクト

組み込み例外
============

標準の例外クラス群

例外はクラスオブジェクトです。 例外はモジュール `exceptions'
で定義されています。
このモジュールを明示的にインポートする必要はありません: 例外は
`exceptions' モジュールと同様に組み込み名前空間で 与えられます。

_Note:_  過去の Python
のバージョンでは、文字列の例外がサポートされていました。 Python 1.5
よりも新しいバージョンでは、全ての標準的な例外は
クラスオブジェクトに変換され、ユーザにも同様にするよう奨励しています。
文字列による例外は `PendingDeprecationWarning' を
送出するようになります。
将来のバージョンでは、文字列による例外のサポートは削除されます。
同じ値を持つ別々の文字列オブジェクトは異なる例外と見なされます。
これはプログラマに対して、例外処理を指定する際に、
文字列ではなく例外名を使わせるための変更です。組み込み例外の文字列値は
全てその名前となりますが、ユーザ定義の例外やライブラリモジュールで定義される
例外についてもそうするように要求しているわけではありません。

`try'  文の中で、`except'

節を使って特定の例外クラスについて記述した場合、その節は
指定した例外クラスから導出されたクラスも扱います (指定した例外
クラスを導出した元のクラスは含みません)
サブクラス化の関係にない例外クラスが二つあった場合、それらに同じ
名前を付けたとしても、等しくなることはありません。

以下に列挙した組み込み例外はインタプリタや組み込み関数によって生成
されます。特に注記しないかぎり、これらの例外は エラーの詳しい原因を
示している、 "関連値 (associated value)" を持ちます。
この値は文字列または複数の情報 (例えばエラーコードや、エラーコード
を説明する文字列) を含むタプルです。この関連値は `raise'
文の二つ目の引数です。 文字列の例外の場合、関連値自体は `except' 節
(あった場合) の二つ目の引数として与えた名前を持つ変数に記憶されます。
クラス例外の場合、この値は例外クラスのインスタンスです。
例外が標準のルートクラスである `Exception' から
導出された場合、関連値は例外インスタンスの `args' 属性中
に他の属性と同様に置かれます。

ユーザによるコードも組み込み例外を送出することができます。
これは例外処理をテストしたり、インタプリタがある例外を送出する 状況と
"ちょうど同じような" エラー条件であることを報告させるために
使うことができます。しかし、ユーザが適切でないエラーを送出するよう
コードするのを妨げる方法はないので注意してください。

組み込み例外クラスは新たな例外を定義するためにサブクラス化する
ことができます; プログラマには、新しい例外を少なくとも `Exception'
基底クラスから導出するよう勧めます。 例外を定義する上での詳しい情報は、
の "ユーザ定義の例外" の項目にあります。

以下の例外クラスは他の例外クラスの基底クラスとしてのみ使われます。

`Exception'
     例外のルートクラスです。全ての組み込み例外はこのクラスから導出
     されています。全てのユーザ定義例外はこのクラスから導出される
     べきですが、(今のところまだ) それは強制ではありません。 `str()'
     をこのクラス (またはほとんどの導出クラス) の
     インスタンスに適用すると、引数を文字列にしたが返されるか、
     インスタンスのコンストラクタが引数なしの場合には空の文字列が返されます。
     インスタンスを配列として使うと、コンストラクタに渡された引数にアクセス
     することができます (古いコードとの互換性のために便利です)。
     引数はまた、インスタンスの `args' 属性として、タプルで
     得ることもできます。

`StandardError'
     `StopIteration' および `SystemExit' 以外の、
     全ての組み込み例外の基底クラスです。 `StandardError'
     自体はルートクラス `Exception' から導出されています。

`ArithmeticError'
     算術上の様々なエラーにおいて送出される組み込み例外:
     `OverflowError'、`ZeroDivisionError'、 `FloatingPointError'
     の基底クラスです。

`LookupError'
     マップ型または配列型に使ったキーやインデクスが無効な値の場合に
     送出される例外:`IndexError'、`KeyError'
     の基底クラスです。`sys.setdefaultencoding()'
     によって直接送出されることもあります。

`EnvironmentError'
     Python システムの外部で起こっているはずの例外: `IOError'、
     `OSError' の基底クラスです。この型の例外が 2 つの要素を
     もつタプルで生成された場合、最初の要素はインスタンスの `errno'
     属性で得ることができます
     (この値はエラー番号と見なされます)。二つめの 要素は `strerror'
     属性です (この値は通常、エラーに関連する
     メッセージです)。タプル自体は `args' 属性から得ることもできます。
     _Added in Python version 1.5.2_

     `EnvironmentError' 例外が 3 要素のタプルで生成された場合、 最初の
     2 つの要素は上と同様に得ることができる一方、3 つ目の要素は
     `filename' 属性で得ることができます。しかしながら、以前の
     バージョンとの互換性のために、`args' 属性にはコンストラクタに渡した
     最初の 2 つの引数からなる 2 要素のタプルしか含みません。

     この例外が 3 つ以外の引数で生成された場合、`filename' 属性は
     `None' になります。この例外が 2 または 3 つ以外の引数で生成
     された場合、`errno' および `strerror' 属性も `None'
     になります。後者のケースでは、`args' が
     コンストラクタに与えた引数をそのままタプルの形で含んでいます。

以下の例外は実際に送出される例外です。

`AssertionError'
     `assert' 文が失敗した場合に送出されます。

`AttributeError'
     属性の参照や代入が失敗した場合に送出されます。(対照のオブジェクトが
     属性の参照や属性の代入をまったくサポートしていない場合には
     `TypeError' が送出されます。)

`EOFError'
     組み込み関数 (`input()' または  `raw_input()')
     のいずれかで、データを全く読まないうちにファイルの終端 (`EOF') に
     到達した場合に送出されます。 (注意: ファイルオブジェクトの
     `read()' および `readline()'
     メソッドの場合、データを読まないうちに
     `EOF'にたどり着くと空の文字列 を返します。)

`FloatingPointError'
     浮動小数点演算が失敗した場合に送出されます。この例外はどの Python
     のバージョンでも常に定義されていますが、Python が `--with-fpectl'
     オプションをつけた状態に設定されて いるか、`pyconfig.h'
     ファイルにシンボル `WANT_SIGFPE_HANDLER' が定義されている場合にのみ
     送出されます。

`IOError'
     (`print' 文、組み込みの `open()' またはファイル
     オブジェクトに対するメソッドといった) I/O 操作が、例えば
     "ファイルが存在しません" や "ディスクの空き領域がありません"
     といった I/O に関連した理由で失敗した場合に送出されます。

     このクラスは `EnvironmentError' から導出されています。
     この例外クラスのインスタンス属性に関する情報は上記の
     `EnvironmentError' に関する議論を参照してください。

`ImportError'
     `import' 文でモジュール定義を見つけられなかった場合や、 `from
     ...import' 文で指定した名前をインポート
     することができなかった場合に送出されます。

`IndexError'
     配列のインデクス指定が配列の範囲を超えている場合に送出
     されます。(スライスのインデクスは配列の範囲に収まるように暗黙のうちに
     調整されます; インデクスが通常の整数でない場合、`TypeError'
     が送出されます。)

`KeyError'
     マップ型 (辞書型) オブジェクトのキーが、オブジェクトのキー集合内に
     見つからなかった場合に送出されます。

`KeyboardInterrupt'
     ユーザが割り込みキー (通常は <Control-C> または <Delete> キー
     です)
     を押した場合に送出されます。割り込みが起きたかどうかはインタプリタ
     の実行中に定期的に調べられます。 組み込み関数 `input()' や
     `raw_input()' がユーザの
     入力を待っている間に割り込みキーを押しても、この例外が送出されます。

`MemoryError'
     ある操作中にメモリが不足したが、その状況は (オブジェクトをいくつか
     消去することで) まだ復旧可能かもしれない場合に送出されます。
     例外に関連づけられた値は、どの種の (内部)
     操作がメモリ不足になっている
     かを示す文字列です。背後にあるメモリ管理アーキテクチャ (C の
     `malloc()' 関数) によっては、インタプリタが常にその状況
     を完璧に復旧できるとはかぎらないので注意してください; プログラムの
     暴走が原因の場合にも、やはり実行スタックの追跡結果を出力
     できるようにするために例外が送出されます。

`NameError'
     ローカルまたはグローバルの名前が見つからなかった場合に送出されます。
     これは非限定の名前のみに適用されます。関連付けられた値は見つからなかった
     名前を含むエラーメッセージです。

`NotImplementedError'
     この例外は `RuntimeError' から導出されています。ユーザ定義の
     基底クラスにおいて、そのクラスの導出クラスにおいてオーバライドする
     ことが必要な抽象化メソッドはこの例外を送出しなくてはなりません。
     _Added in Python version 1.5.2_

`OSError'
     このクラスは `EnvironmentError' から導出されており、 主に `os'
     モジュールの `os.error' 例外で使われて
     います。例外に関連付けられる可能性のある値については、上記の
     `EnvironmentError' を参照してください。 _Added in Python version
     1.5.2_

`OverflowError'
     算術演算の結果、表現するには大きすぎる値になった場合に送出されます。
     これは長整数の演算では起こりません (長整数の演算ではむしろ
     `MemoryError' が送出されることになるでしょう)。 C
     では浮動小数点演算における例外処理の標準化が行われていないので、
     ほとんどの浮動小数点演算もチェックされていません。通常の整数では、
     オーバフローを起こす全ての演算がチェックされます。例外は左シフトで、
     典型的なアプリケーションでは左シフトのオーバフローでは例外を送出する
     よりもむしろ、オーバフローしたビットを捨てるようにしています。

`ReferenceError'
     ``weakref'.proxy()' によって生成された弱参照 (weak reference)
     プロキシを使って、ガーベジコレクションによって処理
     された後の参照対象オブジェクトの属性にアクセスした場合に送出されます。
     弱参照については `weakref' モジュールを参照してください。 _Added
     in Python version 2.2_

`RuntimeError'
     他のカテゴリに分類できないエラーが検出された場合に送出されます。
     関連付けられた値は何が問題だったのかをより詳細に示す文字列です。
     (この例外はほとんど過去のバージョンのインタプリタにおける遺物です;
     この例外はもはやあまり使われることはありません)

`StopIteration'
     イテレータの `next()' メソッドにより、それ以上要素がないことを
     知らせるために送出されます。
     この例外は、通常のアプリケーションではエラーとはみなされないので、
     `StandardError' ではなく `Exception' から導出 されています。
     _Added in Python version 2.2_

`SyntaxError'
     パーザが構文エラーに遭遇した場合に送出されます。この例外は
     `import' 文、`exec' 文、組み込み関数 `evel()' や
     `input()'、初期化スクリプトの 読み込みや標準入力で
     (対話的な実行時にも) 起こる可能性があります。

     このクラスのインスタンスは、例外の詳細に簡単にアクセスできるように
     するために、属性 `filename'、`lineno'、 `offset' および `text'
     を持ちます。 例外インスタンスに対する `str()'
     はメッセージのみを返します。

`SystemError'
     インタプリタが内部エラーを発見したが、その状況は全ての望みを
     棄てさせるほど深刻ではないように思われる場合に送出されます。
     関連づけられた値は (控えめな言い方で)
     何がまずいのかを示す文字列です。

     Python の作者か、あなたの Python インタプリタを保守している人に
     このエラーを報告してください。このとき、 Python インタプリタの
     バージョン (`sys.version'; Python の対話的セッションを開始した
     際にも出力されます)、正確なエラーメッセージ
     (例外に関連付けられた値) を忘れずに報告してください。
     そしてもし可能ならエラーを引き起こしたプログラムのソースコードを
     報告してください。

`SystemExit'
     この例外は `sys.exit()' 関数によって送出されます。この例外が
     処理されなかった場合、Python インタプリタは終了します; スタックの
     トレースバックは全く印字されません。関連付けられた値が通常の整数
     である場合、システム終了状態を指定しています (`exit()' 関数に
     渡されます); 値が `None'の場合、終了状態はゼロです;
     (文字列のような)
     他の型の場合、そのオブジェクトの値が印字され、終了状態は 1
     になります。

     この例外のインスタンスは属性 `code' を持ちます。この値は
     終了状態またはエラーメッセージ (標準では `None' です) に
     設定されます。また、この例外は技術的にはエラーではないため、
     `StandardError' からではなく、`Exception' から 導出されています。

     `sys.exit()' は、後始末のための処理 (`try' 文の `finally' 節)
     が実行されるようにするため、またデバッガが
     制御不能になるリスクを冒さずにスクリプトを実行できるようにするために
     例外に翻訳されます。即座に終了することが真に強く必要であるとき
     (例えば、`fork()' を呼んだ後の子プロセス内) には `os._exit()'
     関数を使うことができます。

`TypeError'
     組み込み演算または関数が適切でない型のオブジェクトに対して適用
     された際に送出されます。関連付けられる値は型の不整合に関して
     詳細を述べた文字列です。

`UnboundLocalError'
     関数やメソッド内のローカルな変数に対して参照を行ったが、その変数には
     値がバインドされていなかった際に送出されます。`NameError'
     のサブクラスです。 _Added in Python version 2.0_

`UnicodeError'
     Unicode に関するエンコードまたはデコードのエラーが発生した際に送出
     されます。`ValueError' のサブクラスです。 _Added in Python version
     2.0_

`UnicodeEncodeError'
     Unicode 関連のエラーがエンコード中に発生した際に送出されます。
     `UnicodeError' のサブクラスです。 _Added in Python version 2.3_

`UnicodeDecodeError'
     Unicode 関連のエラーがデコード中に発生した際に送出されます。
     `UnicodeError' のサブクラスです。 _Added in Python version 2.3_

`UnicodeTranslateError'
     Unicode 関連のエラーがコード翻訳に発生した際に送出されます。
     `UnicodeError' のサブクラスです。 _Added in Python version 2.3_

`ValueError'
     組み込み演算や関数が、正しい型だが適切でない値を受け取った場合、
     および `IndexError' のように、より詳細な説明のできない
     状況で送出されます。

`WindowsError'
     Windows 特有のエラーか、エラー番号が `errno' 値に対応しない
     場合に送出されます。`errno' および `strerror' 値は Windows
     プラットフォーム API の関数、 `GetLastError()' と
     `FormatMessage()' の戻り値から生成されます。 `OSError'
     のサブクラスです。 _Added in Python version 2.0_

`ZeroDivisionError'
     除算またモジュロ演算における二つ目の引数がゼロであった場合に
     送出されます。関連付けられている値は文字列で、その演算における
     被演算子の型を示します。

以下の例外は警告カテゴリとして使われます; 詳細については `warnings'
モジュールを参照してください。

`Warning'
     警告カテゴリの基底クラスです。

`UserWarning'
     ユーザコードによって生成される警告の基底クラスです。

`DeprecationWarning'
     廃用された機能に対する警告の基底クラスです。

`PendingDeprecationWarning'
     将来廃用されることになっている機能に対する警告の基底クラスです。

`SyntaxWarning'
     曖昧な構文に対する警告の基底クラスです。

`RuntimeWarning'
     あいまいなランタイム挙動に対する警告の基底クラスです。

`FutureWarning'
     将来意味構成が変わることになっている文の構成に対する警告の基底クラスです。

組み込み例外のクラス階層は以下のようになっています:

         Exception
          +-- SystemExit
          +-- StopIteration
          +-- StandardError
          |    +-- KeyboardInterrupt
          |    +-- ImportError
          |    +-- EnvironmentError
          |    |    +-- IOError
          |    |    +-- OSError
          |    |         +-- WindowsError
          |    +-- EOFError
          |    +-- RuntimeError
          |    |    +-- NotImplementedError
          |    +-- NameError
          |    |    +-- UnboundLocalError
          |    +-- AttributeError
          |    +-- SyntaxError
          |    |    +-- IndentationError
          |    |         +-- TabError
          |    +-- TypeError
          |    +-- AssertionError
          |    +-- LookupError
          |    |    +-- IndexError
          |    |    +-- KeyError
          |    +-- ArithmeticError
          |    |    +-- OverflowError
          |    |    +-- ZeroDivisionError
          |    |    +-- FloatingPointError
          |    +-- ValueError
          |    |    +-- UnicodeError
          |    |        +-- UnicodeEncodeError
          |    |        +-- UnicodeDecodeError
          |    |        +-- UnicodeTranslateError
          |    +-- ReferenceError
          |    +-- SystemError
          |    +-- MemoryError
          +---Warning
     	  +-- UserWarning
     	  +-- DeprecationWarning
     	  +-- PendingDeprecationWarning
     	  +-- SyntaxWarning
     	  +-- OverflowWarning
     	  +-- RuntimeWarning
     	  +-- FutureWarning


File: python-lib-jp.info,  Node: 組み込み定数,  Prev: 組み込み例外,  Up: 組み込みオブジェクト

組み込み定数
============

組み込み空間には少しだけ定数があります。以下にそれらの定数を示します:

`False'
     `bool' 型における、偽を表す値です。 _Added in Python version 2.3_

`True'
     `bool' 型における、真を表す値です。 _Added in Python version 2.3_

`None'
     ``types'.NoneType' の唯一の値です。 `None'
     は、例えば関数にデフォルトの値が渡されないときのように、
     値がないことを表すためにしばしば用いられます。

`NotImplemented'
     "特殊な比較 (rich comparison)" を行う特殊メソッド
     (`__eq__()'、`__lt__()'、およびその仲間) に対して、
     他の型に対しては比較が実装されていないことを示すために返される値です。

`Ellipsis'
     拡張スライス文と同時に用いられる特殊な値です。


File: python-lib-jp.info,  Node: Python ランタイム サービス,  Next: 文字列処理,  Prev: 組み込みオブジェクト,  Up: Top

Python ランタイム サービス
**************************

この章では、PythonインタープリタやPython環境に深く関連する各種の機能を解説します。以下に一覧を示します:

* Menu:

* sys::
* gc::
* weakref::
* fpectl::
* atexit::
* types::
* UserDict::
* UserList::
* UserString::
* operator::
* inspect::
* traceback::
* linecache::
* pickle::
* cPickle::
* copy_reg::
* shelve::
* copy::
* marshal::
* warnings::
* imp::
* pkgutil::
* code::
* codeop::
* pprint::
* repr::
* new::
* site::
* user::
* __builtin__::
* __main__::
* __future__::

