This is python-tut-jp.info, produced by makeinfo version 4.5 from
python-tut-jp.texi.

12 October 2005


File: python-tut-jp.info,  Node: クラスオブジェクト,  Next: インスタンスオブジェクト,  Prev: クラス定義の構文,  Up: クラス初見

クラスオブジェクト
------------------

クラス・オブジェクトでは２種類の演算: 属性参照とインスタンス生成を
サポートしています。

_属性参照 (attribute reference)_ は、Python におけるすべての
属性参照で使われている標準的な構文、 `obj.name' を使います。
クラスオブジェクトが生成された際にクラスの名前空間にあった名前すべてが
有効な属性名です。従って、以下のようなクラス定義:

     class MyClass:
         "A simple example class"
         i = 12345
         def f(self):
             return 'hello world'

では、`MyClass.i' と `MyClass.f' は妥当な属性参照であり、
それぞれ整数とメソッド・オブジェクトを返します。
クラス属性に代入を行うこともできます。従って、`MyClass.i' の値を
代入して変更できます。 `__doc__' も有効な属性で、そのクラスに属している
docstring、 この場合は `"A simple example class"' を返します。

クラスの _インスタンス生成 (instantiation)_ には関数のような
表記法を使います。クラスオブジェクトのことを、単にクラスの新しい
インスタンスを返すパラメタを持たない関数かのように扱います。 例えば
(上記のクラスでいえば):

     x = MyClass()

は、クラスの新しい_インスタンス (instance)_ を生成し、
そのオブジェクトをローカル変数 `x' へ代入します。

インスタンス生成操作 (クラスオブジェクトの "呼出し") を行うと、
空のオブジェクト (empty object) を生成します。多くのクラスは、
オブジェクトを作成する際に、既知の初期状態になってほしいと望んで
います。従って、クラスでは `__init__()' という名前の特別な
メソッド定義することができます。例えば以下のようにします:

         def __init__(self):
             self.data = []

クラスが `__init__()' メソッドを定義している場合、
クラスのインスタンスを生成すると、新しく生成された
クラスインスタンスに対して自動的に `__init__()' を呼び出します。
従って、この例では、新たな初期済みのインスタンスを以下のように
して得ることができます:

     x = MyClass()

もちろん、より大きな柔軟性を持たせるために、`__init__()'
メソッドに複数の引数をもたせることができます。
その場合、クラスのインスタンス生成操作に渡された引数は `__init__()'
に渡されます。例えば以下のように:

     >>> class Complex:
     ...     def __init__(self, realpart, imagpart):
     ...         self.r = realpart
     ...         self.i = imagpart
     ...
     >>> x = Complex(3.0, -4.5)
     >>> x.r, x.i
     (3.0, -4.5)


File: python-tut-jp.info,  Node: インスタンスオブジェクト,  Next: メソッドオブジェクト,  Prev: クラスオブジェクト,  Up: クラス初見

インスタンスオブジェクト
------------------------

ところで、インスタンスオブジェクトを使うと何ができるのでしょうか？
インスタンスオブジェクトが理解できる唯一の操作は、属性の参照です。
有効な属性の名前には二種類あります。

一つ目の属性の種類は _データ属性 (data attribute)_ と呼ぶことに
しましょう。これは、これは Smalltalk の "インスタンス変数" (instance
variable) や C++の "データメンバ" (data member) に相当します。
データ属性を宣言する必要はありません; ローカルな変数と同様に、
これらの属性は最初に代入された時点で湧き出てきます。例えば、
上で生成した `MyClass' のインスタンス `x' に対して、
以下のコード断片を実行すると、値 `16' を印字し、`x' の
痕跡は残りません。

     x.counter = 1
     while x.counter < 10:
         x.counter = x.counter * 2
     print x.counter
     del x.counter

インスタンスオブジェクトが理解できる属性の参照の二つ目は _メソッド
(method)_ です。メソッドとは、オブジェクトに "属している"
関数のことです。(Python では、メソッドという用語はクラスインスタンス
だけのものではありません:
オブジェクト型にもメソッドを持つことができます。
例えば、リストオブジェクトには、 append, insert, remove, sort
などといった
メソッドがあります。とはいえ、以下では特に明記しない限り、クラスの
インスタンスオブジェクトのメソッドだけを意味するものとして使うことに
します。)

インスタンスオブジェクトで有効なメソッドは、そのクラスによって決まります。
定義により、クラスの全ての属性は、(ユーザが定義した) 関数オブジェクト
インスタンスオブジェクトの妥当なメソッド名は、そのクラスによって
決まります。 定義により、(利用者定義の)
関数オブジェクトになっているクラス属性は全て、
そのインスタンスの対応するメソッドとなります。従って、例では、
`MyClass.f' は関数なので、 `x.f' はメソッドの参照として有効です。
しかし、`MyClass.i' は関数ではないので、 `x.i' はメソッドの参照
として有効ではありません。`x.f' は `MyClass.f' と同じものでは
ありません -- 関数オブジェクトではなく、 _メソッドオブジェクト (method
object)_ です。


File: python-tut-jp.info,  Node: メソッドオブジェクト,  Prev: インスタンスオブジェクト,  Up: クラス初見

メソッドオブジェクト
--------------------

普通、メソッドはその場ですぐに呼び出されます:

     x.f()

私たちの例では、上のコードは文字列 `'hello world'' を返すでしょう。
しかしながら、必ずしもメソッドを正しい方法で呼び出さなければならない
わけではありません: `x.f' はメソッドオブジェクトであり、
どこかに記憶しておいて後で呼び出すことができます。例えば以下のコード:

     xf = x.f
     while True:
         print xf()

は、 `hello world' を時が終わるまで印字し続けるでしょう。

メソッドが呼び出されるときには実際には何が起きているのでしょうか？ `f'
の関数定義では引数を一つ指定していたにもかかわらず、 上記では `x.f()'
が引数なしで呼び出されたことに気付いているかも
しれませんね。引数はどうなったのでしょうか？ たしか、引数が必要な関数を
引数無しで呼び出すと、Python が例外を送出するはずです -- たとえその
引数が実際には使われなくても…。

実際、もう答は想像できているかもしれませんね: メソッドについて
特別なこととして、オブジェクトが関数の第 1 引数として渡される、
ということがあります。我々の例では、`x.f()' という呼び出しは、
`MyClass.f(x)' と厳密に等価なものです。 一般に、N
個の引数リストもったメソッドの呼出しは、
そのメソッドのオブジェクトを最初の引数の前に挿入した引数リストで
メソッドに対応する関数を呼び出すことと等価です。

もしもまだメソッドの働きかたを理解できなければ、一度実装を見てみると
事情がよく分かるかもしれません。
データ属性ではないインスタンス属性が参照された時は、
そのクラスが検索されます。その名前が有効なクラス属性を表している
関数オブジェクトなら、インスタンスオブジェクトと見つかった
関数オブジェクト (へのポインタ) を抽象オブジェクト: すなわちメソッド
オブジェクトにパック (pack) して作成します。
メソッドオブジェクトは、引数リストを伴って呼び出される際に再度
アンパック (unpack) され、新たな引数リストがインスタンスオブジェクト
とオリジナルの引数リストから新たな引数リストが構成され、新たな引数
リストを使って関数オブジェクトを呼び出します。


File: python-tut-jp.info,  Node: いろいろな注意点,  Next: 継承,  Prev: クラス初見,  Up: クラス

いろいろな注意点
================

データ属性は同じ名前のメソッド属性を上書きしてしまいます;
大規模なプログラムでみつけにくいバグを引き起こすことがある
この偶然的な名前の衝突を避けるには、衝突の可能性を最小限にするような
規約を使うのが賢明です。
可能な規約としては、メソッド名を大文字で始める、データ属性名の先頭に
短い一意的な文字列 (あるいはただの下線) をつける、またメソッドには動詞、
データ属性には名詞を用いる、などがあります。

データ属性は、メソッドから参照できると同時に、通常のオブジェクトの
ユーザ ("クライアント") からも参照できます。言い換えると、
クラスは純粋な抽象データ型として使うことができません。実際、 Python
では、データ隠蔽を補強するための機構はなにもありません --
データの隠蔽はすべて規約に基づいています。(逆に、C 言語で書かれた
Python の実装では実装の詳細を完全に隠蔽し、必要に応じてオブジェクト
へのアクセスを制御できます; この機構は C 言語で書かれた Python 拡張
で使うことができます)

クライアントはデータ属性を注意深く扱うべきです -- クライアントは、
メソッドを使うことで維持しているデータ属性の不変式を踏みにじり、
台無しにするかもしれません。
クライアントは、名前の衝突が回避されている限り、メソッドの有効性に
影響を及ぼすことなくインスタンスに独自の属性を追加することができる、
ということに注意してください -- ここでも、名前付けの規約は
頭痛の種を無くしてくれます。

データ属性を (またはその他のメソッドも！) メソッドの中で参照するための
短縮された記法はありません。私は、この仕様が実際にメソッドの
可読性を高めていると考えています: あるメソッドを眺めているときに
ローカルな変数とインスタンス変数を混同する可能性はまったくありません。

慣習として、メソッドの最初の引数を、しばしば `self' と呼びます。
この名前付けは単なる慣行でしかありません: `self' という名前は、 Python
では何ら特殊な意味を持ちません。 (とはいえ、この慣行に従わないと、
コードは他の Python プログラマにとってやや読みにくいものとなります。
また、 _クラスブラウザ (class browser)_ プログラムがこの慣行を
あてにして書かれていないとも限りません。)

クラス属性である関数オブジェクトはいずれも、そのクラスのインスタンス
のためのメソッドを定義しています。関数定義は、テキスト上では
クラス定義の中に入っていなければならないわけではありません:
関数オブジェクトをクラスのローカルな変数の中に代入するのも OK です。
例えば以下のコードのようにします:

     # クラスの外側で定義された関数
     def f1(self, x, y):
         return min(x, x+y)
     
     class C:
         f = f1
         def g(self):
             return 'hello world'
         h = g

これで、`f'、 `g' 、および `h' は、すべて `C'
の属性であり関数オブジェクトを参照しています。
従って、これら全ては、`C' のインスタンスのメソッドとなります -- `h' は
`g' と全く等価です。これを実践しても、大抵は
単にプログラムの読者に混乱をもたらすだけなので注意してください。

メソッドは、`self' 引数のメソッド属性を使って、
他のメソッドを呼び出すことができます:

     class Bag:
         def __init__(self):
             self.data = []
         def add(self, x):
             self.data.append(x)
         def addtwice(self, x):
             self.add(x)
             self.add(x)

メソッドは、通常の関数と同じようにして、グローバルな名前を参照しても
かまいません。あるメソッドに関連付けられたグローバルなスコープは、
クラス定義の入っているモジュールになります。 (クラス自体はグローバルな
スコープとして用いられることはありません！) メソッドでグローバルな
データを使う良い理由はほとんどありませんが、グローバルなスコープを
使う合法的な使い方は多々あります: 一つ挙げると、メソッド内では、
グローバルなスコープに import された関数やモジュールや、
その中で定義された関数やクラスを使うことができます。
通常、メソッドの入っているクラス自体はグローバルなスコープ内で
定義されています。次の章では、メソッドが自分のクラスを参照する理由
として正当なものを見てみましょう！


File: python-tut-jp.info,  Node: 継承,  Next: プライベート変数,  Prev: いろいろな注意点,  Up: クラス

継承
====

言うまでもなく、継承の概念をサポートしない言語機能は "クラス" と呼ぶに
値しません。導出クラス (derived class) を定義する構文は以下のように
なります:

     class DerivedClassName(BaseClassName):
         <文-1>
         .
         .
         .
         <文-N>

基底クラス (base class) の名前 `BaseClassName' は、
派生クラス定義の入っているスコープで定義されていなければなりません。
基底クラス名のかわりに式を入れることもできます。 これは以下のように、

     class DerivedClassName(modname.BaseClassName):

基底クラスが別モジュールで定義されているとき便利です。

導出クラス定義の実行は、基底クラスの場合と同じように進められます。
クラスオブジェクトが構築される時、基底クラスが記憶されます。
記憶された基底クラスは、属性参照を解決するために使われます:
要求された属性がクラスに見つからなかった場合、基底クラスから検索
されます。この規則は、基底クラスが他の何らかのクラスから導出された
ものであった場合、再帰的に適用されます。

導出クラスのインスタンス化では、特別なことは何もありません:
`DerivedClassName()' はクラスの新たなインスタンスを生成します。
メソッドの参照は以下のようにしてい解決されます: まず対応するクラス属性
が検索されます。検索は、必要に応じ、基底クラス連鎖を下って行われ、
検索の結果として何らかの関数オブジェクトがもたらされた場合、
メソッド参照は有効なものとなります。

導出クラスは基底クラスのメソッドを上書き (override) してもかまいません。
メソッドは同じオブジェクトの別のメソッドを呼び出す際に何ら特殊な権限を
持ちません。このため、ある基底クラスのメソッドが、同じ基底クラスで
定義されているもう一つのメソッド呼び出しを行っている場合、実際には
導出クラスで上書きされた何らかのメソッドが呼び出されることになる
かもしれません。 (C++ プログラマへ:  Python では、すべてのメソッドは
事実上 `virtual' です。)

導出クラスで上書きしているメソッドでは、実際は単に基底クラスの
同名のメソッドを置き換えるだけではなく、拡張を行いたいかもしれません。
基底クラスのメソッドを直接呼び出す簡単な方法があります: 単に
`BaseClassName.methodname(self, arguments)' を呼び出すだけです。
この仕様は、場合によってはクライアントでも役に立ちます。
(この呼び出し方が動作するのは、基底クラスがグローバルなスコープ内で
定義されているか、直接 import
されている場合だけなので注意してください。)

* Menu:

* 多重継承::


File: python-tut-jp.info,  Node: 多重継承,  Prev: 継承,  Up: 継承

多重継承
--------

Python では、限られた形式の多重継承 (multiple inheritance) も
サポートしています。複数の基底クラスをもつクラス定義は以下のように
なります:

     class DerivedClassName(Base1, Base2, Base3):
         <文-1>
         .
         .
         .
         <文-N>

多重継承への意味付けを説明する上で必要な唯一の規則は、クラス属性の
参照を行うときに用いられる名前解決の規則 (resolution rule) です。
解決規則は深さ優先 (depth-first)、左から右へ (left-to-right) と
なっています。従って、ある属性が `DerivedClassName' で 見つからなければ
`Base1' で検索され、次に `Base1' の 基底クラスで (再帰的に)
検索されます。それでも見つからなければ はじめて `Base2'
で検索される、といった具合です。

(人によっては、幅優先 (breadth first) -- `Base2' と `Base3'
を検索してから `Base1' の基底クラスで検索する --
のほうが自然のように見えます。しかしながら、幅優先の検索では、 `Base1'
の特定の属性のうち、実際に定義されているのが `Base1'
なのか、その基底クラスなのかを知らなければ、 `Base2'
の属性との名前衝突がどんな結果をもたらすのか
分からないことになります。深さ優先規則では、 `Base1' の直接の
属性と継承された属性とを区別しません。)

Python では偶然的な名前の衝突を慣習に頼って回避しているので、
見境なく多重継承の使用すると、メンテナンスの悪夢に陥ることは明らかです。
多重継承に関するよく知られた問題は、二つのクラスから導出された
クラスがたまたま共通の基底クラスを持つ場合です。
この場合になにが起こるかを結論することは簡単です (インスタンスは
共通の基底クラスで使われている "インスタンス変数" の単一の
コピーを持つことになります) が、この意味付けが何の役に立つのかは
明らかではありません。


File: python-tut-jp.info,  Node: プライベート変数,  Next: 残りのはしばし,  Prev: 継承,  Up: クラス

プライベート変数
================

クラスプライベート (class-private) の識別子に関して限定的なサポート
がなされています。`__spam' (先頭に二個以上の下線文字、末尾に
高々一個の下線文字) という形式の識別子、テキスト上では
`_classname__spam' へと置換されるようになりました。 ここで `classname'
は、現在のクラス名から先頭の下線文字を
はぎとった名前になります。このような難号化 (mangle) は、識別子の
文法的な位置にかかわらず行われるので、クラスプライベートな
インスタンス変数やクラス変数、メソッド、そしてグローバル変数を
定義するための利用できます。また、このクラスにとってプライベートな
インスタンス変数を _他の_ クラスのインスタンスに格納するために
使うことさえできます。難号化した名前が 255 文字より長くなるときは、
切り詰めが起こるかもしれません。
クラスの外側や、クラス名が下線文字だけからできているときには、
難号化加工は起こりません。

名前の難号化は、クラスにおいて、 "プライベートな" インスタンス変数や
メソッドを定義する際に、導出クラスで定義されるインスタンス変数を気に
したり、クラスの外側のコードからインスタンス変数をいじりまわすことが
ないように簡単に定義できるようにするためのものです。
難号化の規則は主に不慮の事故を防ぐためのものだということに注意して
ください; 確信犯的な方法で、プライベートとされている変数にアクセス
したり変更することは依然として可能なのです。デバッガのような特殊な
状況では、この仕様は便利ですらあります。そのため、この抜け穴は
塞がれていません。 (些細なバグ:
基底クラスと同じ名前のクラスを導出すると、基底クラスの
プライベート変数を使えるようになります。)

`exec' や `eval()' や `evalfile()' へ渡されたコードでは、
呼出し元のクラス名を現在のクラスと見なさないことに注意してください;
この仕様は `global' 文の効果と似ており、その効果もまた同様に、
バイトコンパイルされたコードに制限されています。 同じ制約が `getattr()'
と `setattr()' と `delattr()' にも適用されます。また、`__dict__'
を直接参照するときにも適用されます。


File: python-tut-jp.info,  Node: 残りのはしばし,  Next: イテレータ iterator,  Prev: プライベート変数,  Up: クラス

残りのはしばし
==============

Pascal の "レコード (record)" や、C 言語の "構造体 (struct)"
のような、名前つきのデータ要素を一まとめにするデータ型があると
便利なことがたまにあります。空のクラス定義を使うとうまくできます:

     class Employee:
         pass
     
     john = Employee() # 空の従業員レコードを造る
     
     # Fill the fields of the record
     john.name = 'John Doe'
     john.dept = 'computer lab'
     john.salary = 1000

ある特定の抽象データ型を要求する Python コードの断片には、
そのデータ型のメソッドをエミュレーションするクラスを代わりに渡す
ことができます。例えば、ファイルオブジェクトから何らかのデータを書式化
する関数がある場合、`read()' と `readline()' を持つクラス
を定義して、ファイルではなく文字列バッファからデータを書式するように
しておき、引数として渡すことができます。

インスタンスメソッドオブジェクトにもまた、属性があります: `m.im_self'
はメソッドの属しているインスタンスオブジェクトで、 `m.im_func'
はメソッドに対応する関数オブジェクトです。

* Menu:

* 例外はクラスであってもよい::


File: python-tut-jp.info,  Node: 例外はクラスであってもよい,  Prev: 残りのはしばし,  Up: 残りのはしばし

例外はクラスであってもよい
--------------------------

ユーザ定義の例外をクラスとして識別することもできます。このメカニズムを
使って、拡張可能な階層化された例外を作成することができます。

新しく二つの (意味付け的な) 形式の raise 文ができました:

     raise Class, instance
     
     raise instance

第一の形式では、`instance' は `Class' またはその導出クラスの
インスタンスでなければなりません。 第二の形式は以下の表記:

     raise instance.__class__, instance

の短縮された記法です。

except
節には、文字列オブジェクトだけでなくクラスを並べることができます。
except 節のクラスは、同じクラスか基底クラスの例外のときに互換
(compatible) となります (逆方向では成り立ちません --
導出クラスの例外がリストされている except
節は基底クラスの例外と互換ではありません)。 例えば、次のコードは、 B,
C, D を順序通りに出力します:

     class B:
         pass
     class C(B):
         pass
     class D(C):
         pass
     
     for c in [B, C, D]:
         try:
             raise c()
         except D:
             print "D"
         except C:
             print "C"
         except B:
             print "B"

except 節が逆に並んでいた場合 (`except B' が最初にくる場合)、 B, B, B
と出力されるはずだったことに注意してください -- 最初に 一致した except
節が駆動されるのです。

処理されないクラスの例外に対してエラーメッセージが出力されるとき、
まずクラス名が出力され、続いてコロン、スペース、最後に組み込み関数
`str()' を使って文字列に変換したインスタンスが出力されます。


File: python-tut-jp.info,  Node: イテレータ iterator,  Next: ジェネレータ generator,  Prev: 残りのはしばし,  Up: クラス

イテレータ (iterator)
=====================

すでに気づいているでしょうが、`for' 文を使うとほとんどの
コンテナオブジェクトにわたってループを行えます:

     for element in [1, 2, 3]:
         print element
     for element in (1, 2, 3):
         print element
     for key in {'one':1, 'two':2}:
         print key
     for char in "123":
         print char
     for line in open("myfile.txt"):
         print line

こうしたアクセス方法は明確で、簡潔で、かつ便利なものです。イテレータの使用は
Python 全体に普及していて、統一性をもたらしています。背後では、`for'
文はコンテナオブジェクトの `iter()' を呼び出しています。この関数は
`next()' メソッドの定義されたイテレータオブジェクトを返します。
`next()' メソッドは一度コンテナ内の要素に一度に一つづつアクセスします。
コンテナ内にアクセスすべき要素がなくなると、`next()' は `StopIteration'
例外を送出し、`for' ループを終了させます。
実際にどのように動作するかを以下の例に示します:

     >>> s = 'abc'
     >>> it = iter(s)
     >>> it
     <iterator object at 0x00A1DB50>
     >>> it.next()
     'a'
     >>> it.next()
     'b'
     >>> it.next()
     'c'
     >>> it.next()
     
     Traceback (most recent call last):
       File "<pyshell#6>", line 1, in -toplevel-
         it.next()
     StopIteration

イテレータプロトコルの背後にあるメカニズムを一度目にすれば、自作のクラスに
イテレータとしての振る舞いを追加するのは簡単です。`__iter__()' メソッド
を定義して、`next()'
メソッドを持つオブジェクトを返すようにしてください。 クラス自体で
`next()' を定義している場合、`__iter__()' では 単に `self'
を返すようにできます:

     >>> class Reverse:
         "Iterator for looping over a sequence backwards"
         def __init__(self, data):
             self.data = data
             self.index = len(data)
         def __iter__(self):
             return self
         def next(self):
             if self.index == 0:
                 raise StopIteration
             self.index = self.index - 1
             return self.data[self.index]
     
     >>> for char in Reverse('spam'):
     	print char
     
     m
     a
     p
     s


File: python-tut-jp.info,  Node: ジェネレータ generator,  Prev: イテレータ iterator,  Up: クラス

ジェネレータ (generator)
========================

ジェネレータは、イテレータを作成するための簡潔で強力なツールです。
ジェネレータは通常の関数のように書かれますが、何らかのデータを返すときには
`yield' 文を使います。 `next()' が呼び出されるたびに、
ジェネレータは以前に中断した処理を再開します
(ジェネレータは、全てのデータ値と
最後にどの文が実行されたかを記憶しています)。以下の例を見れば、ジェネレータ
がとても簡単に作成できることがわかります:

     >>> def reverse(data):
     	for index in range(len(data)-1, -1, -1):
     		yield data[index]
     
     >>> for char in reverse('golf'):
     	print char
     
     f
     l
     o
     g

ジェネレータを使ってできることは、前節で記述したクラスに基づいたイテレータを
使えばできます。ジェネレータを使うとコンパクトに記述できるのは、
`__iter__()' と `next()' メソッドが自動的に作成されるからです。

ジェネレータのもう一つの重要な機能は、呼び出しごとにローカル変数と実行状態が
自動的に保存されるということです。これにより、`self.index' や
`self.data' といったクラス変数を使ったアプローチよりも簡単に
関数を書くことができるようになります。

メソッドを自動生成したりプログラムの実行状態を自動保存するほかに、
ジェネレータは終了時に自動的に `StopIteration' を送出します。
これらの機能を組み合わせると、通常の関数を書くのに比べ、全く苦労する
ことなく簡単にイテレータを生成することができます。


File: python-tut-jp.info,  Node: 標準ライブラリの簡単なツアー,  Next: さあ何を？,  Prev: クラス,  Up: Top

標準ライブラリの簡単なツアー
****************************

* Menu:

* オペレーティングシステムへのインタフェース::
* ファイルのワイルドカード表記::
* コマンドライン引数::
* エラー出力のリダイレクトとプログラムの終了::
* 文字列のパターンマッチング::
* 数学::
* インターネットへのアクセス::
* 日付と時刻::
* データ圧縮::
* パフォーマンスの計測::
* 品質管理::
* 一揃いあつらえ済み::


File: python-tut-jp.info,  Node: オペレーティングシステムへのインタフェース,  Next: ファイルのワイルドカード表記,  Prev: 標準ライブラリの簡単なツアー,  Up: 標準ライブラリの簡単なツアー

オペレーティングシステムへのインタフェース
==========================================

`os' モジュールは、
オペレーティングシステムと対話するための何ダースもの関数を
提供しています:

     >>> import os
     >>> os.system('time 0:02')
     0
     >>> os.getcwd()      # 現在の作業ディレクトリを返す
     'C:\\Python24'
     >>> os.chdir('/server/accesslogs')

`from os import *' ではなく、 `import os' 形式を使う
ようにしてください。そうすることで、 動作が大きく異なる組み込み関数
`open()' が `os.open()' で隠蔽されるのを避けられます。

組み込み関数 `dir()' および `help()' は、 `os'
のような大規模なモジュールで作業をするときに、対話的な
操作上の助けになります:

     >>> import os
     >>> dir(os)
     <returns a list of all module functions>
     >>> help(os)
     <returns an extensive manual page created from the module's docstrings>

ファイルやディレクトリの日常的な管理作業のために、
より簡単に使える高レベルインタフェースが `shutil'
モジュールで提供されています:

     >>> import shutil
     >>> shutil.copyfile('data.db', 'archive.db')
     >>> shutil.move('/build/executables', 'installdir')


File: python-tut-jp.info,  Node: ファイルのワイルドカード表記,  Next: コマンドライン引数,  Prev: オペレーティングシステムへのインタフェース,  Up: 標準ライブラリの簡単なツアー

ファイルのワイルドカード表記
============================

`glob' モジュールでは、
ディレクトリのワイルドカード検索からファイルのリストを生成する
ための関数を提供しています:

     >>> import glob
     >>> glob.glob('*.py')
     ['primes.py', 'random.py', 'quote.py']


File: python-tut-jp.info,  Node: コマンドライン引数,  Next: エラー出力のリダイレクトとプログラムの終了,  Prev: ファイルのワイルドカード表記,  Up: 標準ライブラリの簡単なツアー

コマンドライン引数
==================

広く使われているユーティリティスクリプトでは、しばしばコマンドライン
引数の処理を呼び出します。これらの引数は `sys' モジュールの ARGV
属性にリストとして記憶されます。例えば、以下の出力は、 `python demo.py
one two three' をコマンドライン上で起動した際に 得られるものです:

     >>> import sys
     >>> print sys.argv
     ['demo.py', 'one', 'two', 'three']

`getopt' モジュールは、SYS.ARGV を UNIX の `getopt()' 関数の
慣習に従って処理します。より強力で柔軟性のあるコマンドライン処理機能は、
`optparse' モジュールで 提供されています。


File: python-tut-jp.info,  Node: エラー出力のリダイレクトとプログラムの終了,  Next: 文字列のパターンマッチング,  Prev: コマンドライン引数,  Up: 標準ライブラリの簡単なツアー

エラー出力のリダイレクトとプログラムの終了
==========================================

`sys' モジュールには、 STDIN、 STDOUT、および STDERR を表す属性値も
存在します。後者の STDERR は、警告やエラーメッセージを出力して、 STDOUT
がリダイレクトされた場合でもそれらが読めるようにする 上で便利です:

     >>> sys.stderr.write('Warning, log file not found starting a new one')
     Warning, log file not found starting a new one

`sys.exit()' は、スクリプトを終了させるもっとも直接的な方法です。


File: python-tut-jp.info,  Node: 文字列のパターンマッチング,  Next: 数学,  Prev: エラー出力のリダイレクトとプログラムの終了,  Up: 標準ライブラリの簡単なツアー

文字列のパターンマッチング
==========================

`re' モジュールでは、より高度な文字列処理のための正規表現 (regular
expression)
を提供しています。正規表現は複雑な一致検索や操作に対して簡潔で最適化
された解決策を与えます:

     >>> import re
     >>> re.findall(r'\bf[a-z]*', 'which foot or hand fell fastest')
     ['foot', 'fell', 'fastest']
     >>> re.sub(r'(\b[a-z]+) \1', r'\1', 'cat in the the hat')
     'cat in the hat'

最小限の機能だけが必要なら、読みやすくデバッグしやすい文字列メソッドの
方がお勧めです:

     >>> 'tea for too'.replace('too', 'two')
     'tea for two'


File: python-tut-jp.info,  Node: 数学,  Next: インターネットへのアクセス,  Prev: 文字列のパターンマッチング,  Up: 標準ライブラリの簡単なツアー

数学
====

`math' モジュールでは、 根底にある浮動小数点演算のための C
言語ライブラリ関数にアクセス する手段を提供しています:

     >>> import math
     >>> math.cos(math.pi / 4.0)
     0.70710678118654757
     >>> math.log(1024, 2)
     10.0

`random'
モジュールでは、乱数に基づいた要素選択のためのツールを提供しています:

     >>> import random
     >>> random.choice(['apple', 'pear', 'banana'])
     'apple'
     >>> random.sample(xrange(100), 10)   # 要素を戻さないサンプリング
     [30, 83, 16, 4, 8, 81, 41, 50, 18, 33]
     >>> random.random()    # ランダムな浮動小数点数
     0.17970987693706186
     >>> random.randrange(6)    # range(6) からランダムに選ばれた整数
     4


File: python-tut-jp.info,  Node: インターネットへのアクセス,  Next: 日付と時刻,  Prev: 数学,  Up: 標準ライブラリの簡単なツアー

インターネットへのアクセス
==========================

インターネットにアクセスしたり、インターネットプロトコルを処理したり
するための数多くのモジュールがあります。その中でも最も単純な二つ
のモジュールは、URL を指定してデータを取得するための `urllib2'
と、メイルを送信するための `smtplib' です:

     >>> import urllib2
     >>> for line in urllib2.urlopen('http://tycho.usno.navy.mil/cgi-bin/timer.pl'):
     ...     if 'EST' in line:      # look for Eastern Standard Time
     ...         print line
     
     <BR>Nov. 25, 09:43:32 PM EST
     
     >>> import smtplib
     >>> server = smtplib.SMTP('localhost')
     >>> server.sendmail('soothsayer@tmp.org', 'jceasar@tmp.org',
     """To: jceasar@tmp.org
     From: soothsayer@tmp.org
     
     Beware the Ides of March.
     """)
     >>> server.quit()


File: python-tut-jp.info,  Node: 日付と時刻,  Next: データ圧縮,  Prev: インターネットへのアクセス,  Up: 標準ライブラリの簡単なツアー

日付と時刻
==========

`datetime' モジュールは、
日付や時刻を操作するためのクラスを、単純な方法と複雑な方法の両方で
供給しています。日付や時刻に対する算術がサポートされている一方、
実装では出力の書式化や操作のための効率的なデータメンバ抽出に
重点を置いています。
このモジュールでは、タイムゾーンに対応したオブジェクトもサポート
しています。

     # dates are easily constructed and formatted
     >>> from datetime import date
     >>> now = date.today()
     >>> now
     datetime.date(2003, 12, 2)
     >>> now.strftime("%m-%d-%y or %d%b %Y is a %A on the %d day of %B")
     '12-02-03 or 02Dec 2003 is a Tuesday on the 02 day of December'
     
     # dates support calendar arithmetic
     >>> birthday = date(1964, 7, 31)
     >>> age = now - birthday
     >>> age.days
     14368


File: python-tut-jp.info,  Node: データ圧縮,  Next: パフォーマンスの計測,  Prev: 日付と時刻,  Up: 標準ライブラリの簡単なツアー

データ圧縮
==========

データの書庫化や圧縮で広く使われている形式については、 `zlib'、 `gzip'、
`bz2'、 `zipfile'、および `tarfile' と
いったモジュールで直接サポートしています。

     >>> import zlib
     >>> s = 'witch which has which witches wrist watch'
     >>> len(s)
     41
     >>> t = zlib.compress(s)
     >>> len(t)
     37
     >>> zlib.decompress(t)
     'witch which has which witches wrist watch'
     >>> zlib.crc32(t)
     -1438085031


File: python-tut-jp.info,  Node: パフォーマンスの計測,  Next: 品質管理,  Prev: データ圧縮,  Up: 標準ライブラリの簡単なツアー

パフォーマンスの計測
====================

Python ユーザの中には、同じ問題を異なったアプローチで解いた
際の相対的なパフォーマンスについて知りたいという深遠な興味を
抱いている人がいます。Python では、そういった疑問に即座に答える
計測ツールを提供しています。

例えば、引数の入れ替え操作に対して、伝統的なアプローチの代わりに
タプルのパックやアンパックを使ってみたい気持ちになるかもしれません。
`timeit' モジュールを
使うと、伝統的なアプローチのほうが高速であることがすぐに実証 されます:

     >>> from timeit import Timer
     >>> Timer('t=a; a=b; b=t', 'a=1; b=2').timeit()
     0.60864915603680925
     >>> Timer('a,b = b,a', 'a=1; b=2').timeit()
     0.8625194857439773

`timeit' では高い粒度レベルを提供しているのに対し、 `profile' や
`pstats' モジュールではより大きなコードブロックにおいて律速となる部分を
判定するためのツールを提供しています。


File: python-tut-jp.info,  Node: 品質管理,  Next: 一揃いあつらえ済み,  Prev: パフォーマンスの計測,  Up: 標準ライブラリの簡単なツアー

品質管理
========

高い品質のソフトウェアを開発するための一つのアプローチは、全ての関数
に対して開発と同時にテストを書き、開発の過程で頻繁にテストを走らせる
というものです。

`doctest' モジュールでは、 モジュールを検索して、プログラムの docstring
に埋め込まれたテストの
評価を行うためのツールを提供しています。テストの作り方は単純で、
典型的な呼び出し例とその結果を docstring にカット& ペーストすると
いうものです。この作業は、ユーザに使用例を与えるという意味で
ドキュメントの情報を増やすと同時に、ドキュメントに書かれている内容が
正しいかどうか doctest モジュールが確認できるようにしています:

     def average(values):
         """Computes the arithmetic mean of a list of numbers.
     
         >>> print average([20, 30, 70])
         40.0
         """
         return sum(values, 0.0) / len(values)
     
     import doctest
     doctest.testmod()   # automatically validate the embedded tests

`unittest' モジュールは `doctest'
モジュールほど気楽に使えるものではありませんが、
より網羅的なテストセットを別のファイルで管理することができます:

     import unittest
     
     class TestStatisticalFunctions(unittest.TestCase):
     
         def test_average(self):
             self.assertEqual(average([20, 30, 70]), 40.0)
             self.assertEqual(round(average([1, 5, 7]), 1), 4.3)
             self.assertRaises(ZeroDivisionError, average, [])
             self.assertRaises(TypeError, average, 20, 30, 70)
     
     unittest.main() # Calling from the command line invokes all tests


File: python-tut-jp.info,  Node: 一揃いあつらえ済み,  Prev: 品質管理,  Up: 標準ライブラリの簡単なツアー

一揃いあつらえ済み
==================

Python には "一揃いあつらえ済み (batteries included)" 哲学が
あります。この哲学は、洗練され、安定した機能を持つ Python の膨大な
パッケージ群に如実に表れています。例えば:

* The `xmlrpclib' および `SimpleXMLRPCServer'
モジュールは、遠隔手続き呼び出し (remote procedure call) を全く
たいしたことのない作業に変えてしまいます。名前とは違い、XML を扱う
ための直接的な知識は必要ありません。

* The `email' パッケージは、MIME やその他の  RFC 2822
に基づくメッセージ文書を含む
電子メイルメッセージを管理するためのライブラリです。
実際にメッセージを送信したり受信したりする `smtplib' や `poplib'
と違って、email パッケージには (添付文書を 含む)
複雑なメッセージ構造の構築やデコードを行ったり、
インターネット標準のエンコードやヘッダプロトコルの実装を行ったり
するための完全なツールセットを備えています。

* `xml.dom' および `xml.sax' パッケージでは、
一般的なデータ交換形式である XML を解析するための頑健なサポートを
提供しています。同様に、`csv' モジュールでは、広く用いられている
データベース形式のデータを直接読み書きする機能をサポートしています。
これらのモジュールやパッケージは併用することで、Python アプリケーション
と他のツール群との間でのデータ交換を劇的に簡単化します。

* 国際化に関する機能は、 `gettext'、 `locale'、および `codecs'
パッケージ といったモジュール群でサポートされています。


File: python-tut-jp.info,  Node: さあ何を？,  Next: 対話入力編集とヒストリ置換,  Prev: 標準ライブラリの簡単なツアー,  Up: Top

さあ何を？
**********

このチュートリアルを読んだことで、おそらく Python を使ってみようと
いう関心はますます強くなったことでしょう -- 現実世界の問題を解決
するために、Python を適用してみたくなったはずです。さて、それでは
何をしたらよいのでしょうか？

を読むか、
少なくともざっと読み流すとよいでしょう。ライブラリリファレンスでは、
データ型、関数、そして Python プログラムを書く上で大いに時間の節約
となるモジュールについて、(簡潔ではあるけれども) 完全なリファレンス
マニュアルを提供しています。 標準的な Python の配布物には、C 言語と
Python の両方のコードが _たくさん_ 収められています; UNIX
メールボックスを読み出したり、 HTTP
を介してドキュメントを取得したり、乱数を生成したり、コマンドライン
オプションを解析したり、 CGI プログラムを書いたり、データを圧縮したり、
その他にももっとたくさんのモジュールがあります; ライブラリリファレンス
にざっと目を通すだけでも、Python で何ができるかアイデアを得ることが
できるでしょう。

主要な Python Web サイトは <http://www.python.org/> です;
このサイトには、コード、ドキュメント、そして Web のあちこちの Python
に関連したページへのポインタがあります。 この Web
サイトは世界のあちこちのさまざまな場所、例えばヨーロッパ、
日本、オーストラリアなどでミラーされています。地理的な位置によっては、
メインのサイトよりミラーのほうが速いかもしれません。 非公式なサイトには
<http://starship.python.net/> があります。 ここには、一群の Python
関連の個人的ホームページがあります;
多くの人がここにダウンロード可能なソフトウェアを置いています。

Python Package Index (PyPI).  にあるサードパーティ製モジュール
リポジトリに行けば、さらに多くのユーザによって作成された Python
モジュール を見つけることができます。

Python に関する質問をしたり、問題を報告するために、 ニュースグループ
`comp.lang.python' に投稿したり、 <python-list@python.org>
のメーリングリストに送信することが
できます。ニュースグループとメーリングリストは相互接続されて
いるので、どちらかにポストされたメッセージは自動的にもう一方にも
転送されます。 一日に約 120 通程度、 質問を
(そしてその解凍)、新機能の提案、新たなモジュールのアナウンス
が投稿されています。 投稿する前に、必ず よく出される質問 (Frequently
Asked Questions, FAQ とも言います) のリストを確認するか、Python
ソースコード配布物の `Misc/' ディレクトリを探すようにしてください。
メーリングリストのアーカイブは <http://www.python.org/pipermail/> で
入手することができます。 FAQ
では、何度も繰り返し現れる質問の多くに答えています。読者の抱えている
問題に対する解答がすでに入っているかもしれません。


File: python-tut-jp.info,  Node: 対話入力編集とヒストリ置換,  Next: 浮動小数点演算、その問題と制限,  Prev: さあ何を？,  Up: Top

対話入力編集とヒストリ置換
**************************

あるバージョンの Python インタプリタでは、Korn シェルや GNU Bash
シェルに見られる機能に似た、現在の入力行に対する編集機能や
ヒストリ置換機能をサポートしています。 この機能は _GNU Readline_
ライブラリを使って実装されています。 このライブラリは Emacs スタイルと
vi スタイルの編集をサポート
しています。ライブラリには独自のドキュメントがあり、ここでそれを
繰り返すつもりはありません; とはいえ、基本について簡単に解説する
ことにします。ここで述べる対話的な編集とヒストリについては、 UNIX 版と
CygWin 版のインタプリタでオプションとして利用 することができます。

この章では、Mark Hammond の PythonWin パッケージや、 Python
とともに配布される Tk ベースの環境である IDLE にある
編集機能については解説_しません_。 NT 上の DOS ボックスやその他の DOS
および Windows 類で働く コマンド行ヒストリ呼出しもまた別のものです。

* Menu:

* 行編集::
* ヒストリ置換::
* キー割り当て::
* 解説::


File: python-tut-jp.info,  Node: 行編集,  Next: ヒストリ置換,  Prev: 対話入力編集とヒストリ置換,  Up: 対話入力編集とヒストリ置換

行編集
======

入力行の編集がサポートされている場合、インタプリタが一次または二次
プロンプトを出力している際にはいつでも有効になっています。現在の行は、
慣例的な Emacs 制御文字を使って編集することができます。
そのうち最も重要なものとして、以下のようなキーがあります: <C-A>
(Control-A) はカーソルを行の先頭へ移動させます。 <C-E>
は末尾へ移動させます。 <C-B> は逆方向へ一つ移動させます。 <C-F>
は順方向へ移動させます。 Backspace は逆方向に向かって文字を消します。
<C-D> は順方向に向かって消します。 <C-K> は順方向に向かって行の残りを
kill し (消し) ます 、 <C-Y> は最後に kill された文字列を再び yank し
(取り出し) ます。 <C-underscore> 最後の変更を元に戻します;
これは、繰り返して どんどんさかのぼることができます。


File: python-tut-jp.info,  Node: ヒストリ置換,  Next: キー割り当て,  Prev: 行編集,  Up: 対話入力編集とヒストリ置換

ヒストリ置換
============

ヒストリ置換は次のように働きます。入力された行のうち、空行でない
実行された行はすべてヒストリバッファに保存されます。そして、プロンプト
が呈示されるときには、ヒストリバッファの最も下の新たな行に移動
します。<C-P> はヒストリバッファの中を一行だけ上に移動し (戻し)
ます。<C-N> は 1 行だけ下に移動します。ヒストリバッファの
どの行も編集することができます。行が編集されると、それを示すために
プロンプトの前にアスタリスクが表示されます (1)。 <Return>
キーを押すと現在行がインタプリタへ渡されます。 <C-R>
はインクリメンタルな逆方向サーチ (reverse search) を開始し、 <C-S>
は順方向サーチ (forward search) を開始します。

---------- Footnotes ----------

(1)  訳注: これはデフォルト設定の Readline では現れません。 `set
mark-modified-lines on' という行を `~{}/.inputrc' または 環境変数
`INPUTRC' が指定するファイルに置くことによって 現れるようになります。


File: python-tut-jp.info,  Node: キー割り当て,  Next: 解説,  Prev: ヒストリ置換,  Up: 対話入力編集とヒストリ置換

キー割り当て
============

Readline ライブラリのキー割り当て (key binding) やその他のパラメタ
は、`~{}/.inputrc'
という初期化ファイル(1)にコマンドを置くことでカスタマイズできます。
キー割り当ての形式は

     key-name: function-name

または

     "string": function-name

で、オプションの設定方法は

     set option-name value

です。例えば、以下のように設定します:

     # vi スタイルの編集を選択する:
     set editing-mode vi
     
     # 一行だけを使って編集する:
     set horizontal-scroll-mode On
     
     # いくつかのキーを再束縛する:
     Meta-h: backward-kill-word
     "\C-u": universal-argument
     "\C-x\C-r": re-read-init-file

Python では、<Tab> に対するデフォルトの割り当ては TAB の挿入です。
Readline のデフォルトであるファイル名補完関数ではないので注意して
ください。 もし、どうしても Readline のデフォルトを割り当てたいのなら、
`~{}/.inputrc' に

     Tab: complete

を入れれば設定を上書きすることができます。 (もちろん、<Tab>
を使って補完を行うのに慣れている場合、この設定を行うと
インデントされた継続行を入力しにくくなります。)

変数名とモジュール名の自動的な補完がオプションとして利用できます。
補完をインタプリタの対話モードで有効にするには、
以下の設定をスタートアップファイルに追加します: (2)

     import rlcompleter, readline
     readline.parse_and_bind('tab: complete')

この設定は、<Tab> キーを補完関数に束縛します。従って、 <Tab>
キーを二回たたくと補完候補が示されます; 補完機能は Python
の文の名前、現在のローカル変数、および利用可能なモジュール名を
検索します。`string.a' のようなドットで区切られた式については、 最後の
`.' までの式を評価し、結果として得られたオブジェクトの
属性から補完候補を示します。 `__getattr__()'
メソッドを持ったオブジェクトが式に含まれている 場合、`__getattr__()'
がアプリケーション定義のコードを実行する
かもしれないので注意してください。

より良くできたスタートアップファイルは以下例のようになります。
この例では、作成した名前が不要になると削除されるので気をつけてください;
これは、スタートアップファイルが対話コマンドと同じ名前空間で実行され
ているので、不要な名前を除去して対話環境に副作用を生まないように
するためです。import されたモジュールのうち、`os' のような
インタプリタのほとんどのセッションで必要なものについては、残しておくと
便利に思うかもしれません。

     # Add auto-completion and a stored history file of commands to your Python
     # interactive interpreter. Requires Python 2.0+, readline. Autocomplete is
     # bound to the Esc key by default (you can change it - see readline docs).
     #
     # Store the file in ~/.pystartup, and set an environment variable to point
     # to it, e.g. "export PYTHONSTARTUP=/max/home/itamar/.pystartup" in bash.
     #
     # Note that PYTHONSTARTUP does *not* expand "~", so you have to put in the
     # full path to your home directory.
     
     import atexit
     import os
     import readline
     import rlcompleter
     
     historyPath = os.path.expanduser("~/.pyhistory")
     
     def save_history(historyPath=historyPath):
         import readline
         readline.write_history_file(historyPath)
     
     if os.path.exists(historyPath):
         readline.read_history_file(historyPath)
     
     atexit.register(save_history)
     del os, atexit, readline, rlcompleter, save_history, historyPath

---------- Footnotes ----------

(1)  訳注: このファイル名は 環境変数 `INPUTRC'
がもしあればその指定が優先されます。

(2)  Python は、対話インタプリタを開始する時に `PYTHONSTARTUP'
環境変数が指定するファイルの内容を実行します。


File: python-tut-jp.info,  Node: 解説,  Prev: キー割り当て,  Up: 対話入力編集とヒストリ置換

解説
====

この機能は、初期の版のインタプリタに比べれば大きな進歩です;
とはいえ、まだいくつかの要望が残されています: 例えば、
行を継続するときに正しいインデントが呈示されたら快適でしょう (パーサは
次の行でインデントトークンが必要かどうかを知っています)。
補完機構がインタプリタのシンボルテーブルを使ってもよいかもしれません。
かっこやクォートなどの対応をチェックする (あるいは指示する) コマンドも
有用でしょう。


File: python-tut-jp.info,  Node: 浮動小数点演算、その問題と制限,  Next: 歴史とライセンス,  Prev: 対話入力編集とヒストリ置換,  Up: Top

浮動小数点演算、その問題と制限
******************************

浮動小数点数は、計算機ハードウェアの中では、 基数を 2 とする (2進法の)
分数として表現されています。 例えば、小数

     0.125

は、 1/10 + 2/100 + 5/1000 という値を持ちますが、これと同様に、 2
進法の分数

     0.001

は 0/2 + 0/4 + 1/8 という値になります。これら二つの分数は同じ値を
持っていますが、ただ一つ、最初の分数は基数 10 で記述されており、
二番目の分数は基数 2 で記述されていることが違います。

残念なことに、ほとんどの小数は 2 進法の分数として正確に表わすことが
できません。その結果、一般に、入力した 10 進の浮動小数点数は、 2
進法の浮動小数点数で近似された後、実際にマシンに記憶されます。

最初は基数 10 を使うと問題を簡単に理解できます。分数 1/3 を考えて
みましょう。分数 1/3 は、基数 10 の分数として、以下のように近似する
ことができます:

     0.3

さらに正確な近似は、

     0.33

です。さらに正確に近似すると、

     0.333

となり、以後同様です。何個桁数を増やして書こうが、結果は決して厳密な
1/3 にはなりません。しかし、少しづつ正確な近似にはなっていくでしょう。

同様に、基数を 2 とした表現で何桁使おうとも、10 進数の 0.1 は 基数を 2
とした分数で正確に表現することはできません。 基数 2 では、1/10
は循環小数 (repeating fraction)

     0.0001100110011001100110011001100110011001100110011...

となります。どこか有限の桁で止めると、近似値を得ることになります。
これこそが、以下のような事態:

     >>> 0.1
     0.10000000000000001

に出くわす理由です。

今日では、ほとんどのマシンでは、0.1 を Python のプロンプトから入力すると
上のような結果を目にします。そうならないかもしれませんが、これは
ハードウェアが浮動小数点数を記憶するのに用いているビット数がマシンに
よって異なり、Python は単にマシンに 2 進で記憶されている、真の 10 進の
値を近似した値を、されに 10 進で近似して出力するだけだからです。
ほとんどのマシンでは、Python が 0.1 を記憶するために 2 進近似した
真の値を 10 進で表すと、以下のような出力

     >>> 0.1
     0.1000000000000000055511151231257827021181583404541015625

になるでしょう！ Python プロンプトは、文字列表現を得るために
何に対しても `repr()' を (非明示的に) 使います。 浮動小数点数の場合、
`repr(FLOAT)' は真の 10 進値を 有効数字 17 桁で丸め、以下のような表示

     0.10000000000000001

を行います。

`repr(FLOAT)' が有効数字 17桁 の値を生成するのは、この値 が
(ほとんどのマシン上で) 、全ての有限の浮動小数点数 X について
`eval(repr(X)) == X' が成り立つのに十分で、 かつ有効数字 16
桁に丸めると成り立たないからです。

これは 2 進法の浮動小数点の性質です: Python のバグでも、ソースコードのバ
グでもなく、浮動小数点演算を扱えるハードウェア上の、すべての言語で同じ
類の現象が発生します (ただし、言語によっては、デフォルトのモードや
全ての出力モードでその差を _表示しない_ かもしれません)。

Python の組み込みの `str()' 関数は有効数字 12 桁しか生成
しません。このため、この関数を代わりに使用したいと思うかもしれません。
この関数は `eval(str(X))' としたときに X を再現
しないことが多いですが、出力を目で見るには好ましいかもしれません:

     >>> print str(0.1)
     0.1

現実という考えからは、上の表示は錯覚であると気づくのは重要なことです:
マシン内の値は厳密に 1/10 ではなく、単に真のマシン内の _表示される値_
を丸めているだけなのです。

まだ驚くべきことがあります。例えば、以下

     >>> 0.1
     0.10000000000000001

を見て、`round()' 関数を使って桁を切り捨て、期待する 1 桁に
したい誘惑にかられたとします。しかし、結果は依然同じ値です:

     >>> round(0.1, 1)
     0.10000000000000001

問題は、"0.1" を表すために記憶されている 2 進表現の浮動小数点数の値は、
すでに 1/10 に対する最良の近似になっており、値を再度丸めようとしても
これ以上ましにはならないということです: すでに値は、`round()'
で得られる値になっているというわけです。

もう一つの重要なことは、0.1 が正確に 1/10 ではないため、0.1 どうしを 10
回加算すると厳密に 1.0 にはならないこともある、ということです:

     >>> sum = 0.0
     >>> for i in range(10):
     ...     sum += 0.1
     ...
     >>> sum
     0.99999999999999989

2 進の浮動小数点数に対する算術演算は、このような意外性をたくさん持って
います。"0.1" に関する問題は、以下の "表現エラー"
の章で詳細に説明します。 2
進法の浮動小数点演算にともなうその他のよく知られた意外な事象に関しては

を参照してください。

究極的にいうと、"容易な答えはありません"。ですが、浮動小数点数の
ことを過度に警戒しないでください！ Python の float 型操作における
エラーは浮動小数点処理ハードウェアから受けついたものであり、
ほとんどのマシン上では一つの演算あたり高々 2**53 分の 1 です。
この誤差はほとんどの作業で相当以上のものですが、浮動小数点演算は 10
進の演算えはなく、浮動小数点の演算を新たに行うと、新たな
丸め誤差の影響を受けることを心にとどめておいてください。

異常なケースが存在する一方で、普段の浮動小数点演算の利用では、
単に最終的な結果の値を必要な 10 進の桁数に丸めて表示するのなら、
最終的には期待通りの結果を得ることになるでしょう。 こうした操作は普通
`str()' で事足りますし、よりきめ細かな 制御をしたければ、 Python の `%'
書式化演算子についての議論を 参照してください: `%g' 、`%f' 、および
`%e' といった
書式化コードでは、浮動小数点数を表示用に丸めるための柔軟性のある、
簡単な手段を提供しています。

* Menu:

* 表現エラー::

