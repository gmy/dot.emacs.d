This is python-tut-jp.info, produced by makeinfo version 4.5 from
python-tut-jp.texi.

12 October 2005


File: python-tut-jp.info,  Node: パッケージ,  Prev: dir 関数,  Up: モジュール

パッケージ
==========

パッケージ (package) は、Python のモジュール名前空間 を
"ドット付きモジュール名 (dotted module names)" を使って
構造化する手段です。例えば、モジュール名 `A.B' は、 `A'
というパッケージのサブモジュール `B' を表します。
ちょうど、モジュールを利用すると、別々のモジュールの著者が互いの
グローバル変数名について心配しなくても済むようになるのと同じように、
ドット付きモジュール名を利用すると、 NumPy や Python Imaging Library
のように複数モジュールからなる
パッケージの著者が、互いのモジュール名について心配しなくても済むように
なります。

音声ファイルや音声データを一様に扱うためのモジュールのコレクション
("パッケージ") を設計したいと仮定しましょう。音声ファイルには
多くの異なった形式がある (通常は拡張子、例えば `.wav', `.aiff', `.au'
などで認識されます) ので、
様々なファイル形式間で変換を行うためのモジュールからなる、
次第に増えていくモジュールのコレクションを作成したりメンテナンス
したりする必要がありかもしれません。また、音声データに対して
実行したい様々な独自の操作 (ミキシング、エコーの追加、
イコライザ関数の適用、人工的なステレオ効果の作成など) があるかも
しれません。そうなると、こうした操作を実行するモジュールを果てしなく
書くことになるでしょう。以下に (階層的なファイルシステムで表現した)
パッケージの構造案を示します:

     Sound/                          トップレベルのパッケージ
           __init__.py               サウンドパッケージを初期化する
           Formats/                  ファイルフォーマット変換用の下位パッケージ
                   __init__.py
                   wavread.py
                   wavwrite.py
                   aiffread.py
                   aiffwrite.py
                   auread.py
                   auwrite.py
                   ...
           Effects/                  サウンド効果用の下位パッケージ
                   __init__.py
                   echo.py
                   surround.py
                   reverse.py
                   ...
           Filters/                  フィルタ用の下位パッケージ
                   __init__.py
                   equalizer.py
                   vocoder.py
                   karaoke.py
                   ...

パッケージを import する際、 Python は `sys.path' 上のディレクトリ
を検索して、トップレベルのパッケージの入ったサブディレクトリを探します。

あるディレクトリを、パッケージが入ったディレクトリとしてPython に
扱わせるには、ファイル `__init__.py' が必要です:
このファイルを置かなければならないのは、`string' のような
よくある名前のディレクトリにより、モジュール検索パスの後の方で見つかる
正しいモジュールが意図せず隠蔽されてしまうのを防ぐためです。
最も簡単なケースでは `__init__.py' はただの空ファイルで
構いませんが、`__init__.py' ではパッケージのための初期化コード
を実行したり、後述の `__all__' 変数を設定してもかまいません。

パッケージのユーザは、個々のモジュールをパッケージから import
することができます。例えば:

     import Sound.Effects.echo

この操作はサブモジュール `Sound.Effects.echo' をロードします。
このモジュールは、以下のように完全な名前で参照しなければなりません:

     Sound.Effects.echo.echofilter(input, output, delay=0.7, atten=4)

サブモジュールを import するもう一つの方法を示します:

     from Sound.Effects import echo

これもサブモジュール `echo' をロードし、`echo' を
パッケージ名を表す接頭辞なしで利用できるようにします。従って以下のように
用いることができます:

     echo.echofilter(input, output, delay=0.7, atten=4)

さらにもう一つのバリエーションとして、必要な関数や変数を直接 import する
方法があります:

     from Sound.Effects.echo import echofilter

この操作も同様にサブモジュール `echo' をロードしますが、 `echofilter'
を直接利用できるようにします。

     echofilter(input, output, delay=0.7, atten=4)

`from PACKAGE import ITEM' を使う場合、ITEM は パッケージ PACKAGE
のサブモジュール (またはサブパッケージ) でも
かまいませんし、関数やクラス、変数のような、PACKAGE で定義されて
いる別の名前でもかまわないことに注意してください。 `import'
文はまず、ITEM がパッケージ内で定義されているか どうか調べます;
定義されていなければ、ITEM はモジュール
名であると仮定して、モジュールをロードしようと試みます。もし
モジュールが見つからなければ、`ImportError' が送出されます。

反対に、`import ITEM.SUBITEM.SUBSUBITEM' のような構文を
使った場合、最後の `subsubitem' を除く各要素はパッケージで
なければなりません; 最後の要素はモジュールかパッケージにできますが、
一つ前の要素で定義されているクラスや関数や変数にはできません。

* Menu:

* パッケージから * を import する::
* パッケージ内での参照::
* 複数ディレクトリ中のパッケージ::


File: python-tut-jp.info,  Node: パッケージから * を import する,  Next: パッケージ内での参照,  Prev: パッケージ,  Up: パッケージ

パッケージから * を import する
-------------------------------

それでは、ユーザが `from Sound.Effects import *' と書いたら、
どうなるのでしょうか？ 理想的には、何らかの方法でファイルシステムが
調べられ、そのパッケージにどんなサブモジュールがあるかを調べ上げ、
全てを import する、という処理を望むことでしょう。残念ながら、
この操作は Mac や Windows のプラットフォームではうまく動作しません。
これらのプラットフォームでは、ファイルシステムはファイル名の
大小文字の区別について正しい情報をもっているとは限らないからです！
こうしたプラットフォームでは、ファイル `ECHO.PY' を モジュール `echo'
として import すべきか、`Echo' と
すべきかが分かる確かな方法がないからです (例えば、 Windows 95 は
すべてのファイル名の最初の文字を大文字にして表示するという困った
慣習があります)。また、DOS の 8+3 のファイル名制限のせいで、
長いモジュール名に関して別の奇妙な問題が追加されています。

唯一の解決策は、パッケージの作者にパッケージの索引を明示的に提供
させるというものです。 import 文は次の規約を使います: パッケージの
`__init__.py' コード に `__all__' という名前のリストが定義されていれば、
`from PACKAGE import *' が現れたときに import する
リストとして使います。新たなパッケージがリリースされるときに
リストを最新の状態に更新するのはパッケージの作者の責任となります。
自分のパッケージから * を import するという使い方に同意できなければ、
パッケージの作者は `__init__.py' をサポートしないことにしても
かまいません。 例えば、ファイル `Sounds/Effects/__init__.py'
には、次のような コードを入れてもよいかもしれません:

     __all__ = ["echo", "surround", "reverse"]

このコードは、 `from Sound.Effects import *' とすると、 `Sound'
パッケージから指定された 3 つのサブモジュールが import
されることになっている、ということを意味します。

もしも `__all__' が定義されていなければ、実行文 `from Sound.Effects
import *' は、パッケージ `Sound.Effects'
の全てのサブモジュールを現在の名前空間の中へ import _しません_;
この文は単に (場合によっては初期化コード `__init__.py' を実行して)
パッケージ `Sound.Effects' が import されたということを確認し、
そのパッケージで定義されている名前を全て import するだけです。 import
される名前には、`__init__.py' で定義された名前
(と、明示的にロードされたサブモジュール) が含まれます。
パッケージのサブモジュールで、以前の import 文で明示的にロードされた
ものも含みます。以下のコードを考えてください:

     import Sound.Effects.echo
     import Sound.Effects.surround
     from Sound.Effects import *

上の例では、echo と surround モジュールが現在の名前空間に import
されます。これらのモジュールは `from...import' 文が 実行された際に
`Sound.Effects' 内で定義されているからです (この機構は`__all__'
が定義されているときにも働きます)。

一般的には、モジュールやパッケージから `*' を import するという
やり方には賛同できません。というのは、この操作を行うとしばしば可読性に
乏しいコードになるからです。しかし、対話セッションでキータイプの量を
減らすために使うのは構わないでしょう。それに、特定のモジュールでは、
特定のパターンに従った名前のみを公開 (export)
するように設計されています。

`from package import specific_submodule' を使っても何も問題は
ないことに留意してください！実際この表記法は、import を行うモジュールが
他のパッケージかと同じ名前を持つサブモジュールを使わなければ
ならない場合を除いて推奨される方式です。


File: python-tut-jp.info,  Node: パッケージ内での参照,  Next: 複数ディレクトリ中のパッケージ,  Prev: パッケージから * を import する,  Up: パッケージ

パッケージ内での参照
--------------------

サブモジュール同士で互いに参照を行う必要がしばしば起こります。
例えば、`surround' モジュールは `echo' モジュールを
使うかもしれません。実際には、このような参照はよくあることなので、
`import' 文を実行すると、まず最初に import 文の入っている
パッケージを検索し、その後になって標準のモジュール検索パスを
見に行きます。こうして、surround モジュールは単に `import echo' や
`from echo import echofilter' を使うことができます。 import
されたモジュールが現在のパッケージ (現在のモジュールを
サブモジュールにしているパッケージ) 内に見つからなかった場合、 `import'
文は指定した名前のトップレベルのモジュールを検索 します。

パッケージが (前述の例の `Sound' パッケージのように)
サブパッケージの集まりに構造化されている場合、兄弟関係にある
パッケージを短縮された記法で参照する方法は存在しません - サブパッケージ
の完全な名前を使わなければなりません。例えば、モジュール
`Sound.Filters.vocoder' で `Sound.Effects' パッケージの `echo'
モジュールを使いたいとすると、 `from Sound.Effects import echo'
を使うことはできます。


File: python-tut-jp.info,  Node: 複数ディレクトリ中のパッケージ,  Prev: パッケージ内での参照,  Up: パッケージ

複数ディレクトリ中のパッケージ
------------------------------

パッケージのサポートする特殊な属性には、もう一つ `__path__' が
あります。この属性は、パッケージの `__init__.py' 中のコードが
実行されるよりも前に、`__init__.py' の収められているディレクトリ名
の入ったリストになるよう初期化されます。
この変数は変更することができます; 変更を加えると、以降そのパッケージに
入っているモジュールやサブパッケージの検索に影響します。

この機能はほとんど必要にはならないのですが、パッケージ内に見つかる
モジュールのセットを拡張するために使うことができます。


File: python-tut-jp.info,  Node: 入力と出力,  Next: エラーと例外,  Prev: モジュール,  Up: Top

入力と出力
**********

プログラムの出力をもたらす方法はいくつかあります; データは人間が可読
な形で出力することも、将来使うためにファイルに書くこともできます。
この章では、こうした出力のいくつかの可能性について議論します。

* Menu:

* ファンシーな出力の書式化::
* ファイルを読み書きする::


File: python-tut-jp.info,  Node: ファンシーな出力の書式化,  Next: ファイルを読み書きする,  Prev: 入力と出力,  Up: 入力と出力

ファンシーな出力の書式化
========================

これまでのところ、値を出力する二つの方法: _式でできた文 (expression
statement)_ と `print' 文が出てきました。(第三は ファイルオブジェクトの
`write()' を使う方法です; 標準出力 を表すファイルは `sys.stdout'
で参照できます。詳細は ライブラリリファレンスを参照してください。)

出力を書式化する際に、単に値をスペースで区切って出力するよりも
もっときめ細かな制御をしたいと思うことがしばしばあるでしょう。
出力を書式化するには二つの方法があります; 第一の方法は、全ての
文字列を自分で処理するというものです;
文字列のスライスや結合といった操作を
使えば、思い通りのレイアウトを作成することができます。 標準モジュール
`string'  には、
文字列を指定されたカラム幅にそろえるための便利な操作がいくつか
あります; これらの操作については、後で簡単に説明します。 第二の方法は
`%' 演算子を使い、文字列を演算子の左引数 (left argument)
として使う方法です。`%' 演算子は、左引数を `sprintf()'
のような形式で解釈して右引数に適用し、
その書式化操作で得られた文字列を返します。

もちろん、一つ問題があります。値をどうやって文字列に変換したら
いいのでしょうか？幸運なことに、Python には値を文字列に変換する方法が
あります: 値を `repr()' か `str()' 関数に渡して ください。逆クオート
(```') は `repr()' と等しい 操作ですが、利用はお勧めしません。

`str()' 関数は、値を表現するときにかなり人間にとって可読な
ものにするためのものです。一方、`repr()' は
インタプリタで読めるような表現にする (あるいは、等価な値を表現する
ための構文がない場合には `SyntaxError' を送出させる) ためのものです。
人間が利用するための特別な表現をもたないオブジェクトでは、 `str()' は
`repr()' と同じ値を返します。
数値や、リストや辞書といった構造体のような多くの値は、どちらの関数でも
同じ表現になります。文字列と浮動小数点は特別で、二つの
別個の表現となります。

下にいくつか例を挙げます:

     >>> s = 'Hello, world.'
     >>> str(s)
     'Hello, world.'
     >>> repr(s)
     "'Hello, world.'"
     >>> str(0.1)
     '0.1'
     >>> repr(0.1)
     '0.10000000000000001'
     >>> x = 10 * 3.25
     >>> y = 200 * 200
     >>> s = 'The value of x is ' + repr(x) + ', and y is ' + repr(y) + '...'
     >>> print s
     The value of x is 32.5, and y is 40000...
     >>> # 文字列への repr() はクォートとバックスラッシュが付加される:
     ... hello = 'hello, world\n'
     >>> hellos = repr(hello)
     >>> print hellos
     'hello, world\n'
     >>> # repr() の引数は Python オブジェクトの場合もある:
     ... repr((x, y, ('spam', 'eggs')))
     "(32.5, 40000, ('spam', 'eggs'))"
     >>> # 逆クォートは対話セッショで便利である:
     ... `x, y, ('spam', 'eggs')`
     "(32.5, 40000, ('spam', 'eggs'))"

以下に 2 乗と 3 乗の値からなる表を書く二つの方法を示します:

     >>> for x in range(1, 11):
     ...     print repr(x).rjust(2), repr(x*x).rjust(3),
     ...     # 上の行の末尾のコンマに注意
     ...     print repr(x*x*x).rjust(4)
     ...
      1   1    1
      2   4    8
      3   9   27
      4  16   64
      5  25  125
      6  36  216
      7  49  343
      8  64  512
      9  81  729
     10 100 1000
     >>> for x in range(1,11):
     ...     print '%2d %3d %4d' % (x, x*x, x*x*x)
     ...
      1   1    1
      2   4    8
      3   9   27
      4  16   64
      5  25  125
      6  36  216
      7  49  343
      8  64  512
      9  81  729
     10 100 1000

(各カラムの間のスペース一個は `print' の働きで追加されて
いることに注意してください: `print' は引数間に常に 空白を追加します)

この例では、メソッド `rjust()' を実際に利用しています。 `rjust()'
は文字列を指定された幅のフィールド内に
右詰めで入るように、左に空白を追加します。同様のメソッドとして、
`ljust()' と `center()' が
あります。これらのメソッドは何か出力を行うわけではなく、ただ新しい文字列を
返します。入力文字列が長すぎる場合、文字列を切り詰めることはせず、
ただ値をそのまま返します; この仕様のために、カラムのレイアウトが
滅茶苦茶になるかもしれませんが、嘘の値が代わりに書き出される
よりはましです。(本当に切り詰めを行いたいのなら、全てのカラムに
`ljust(x,~n)[0:n]') のようにスライス表記を加える こともできます。)

もう一つのメソッド、 `zfill()' は、数値文字列
の左側をゼロ詰めします。このメソッドは正と負の符号を正しく扱います:

     >>> '12'.zfill(5)
     '00012'
     >>> '-3.14'.zfill(7)
     '-003.14'
     >>> '3.14159265359'.zfill(5)
     '3.14159265359'

`%' 演算子を使う場合は以下のようになります:

     >>> import math
     >>> print 'The value of PI is approximately %5.3f.' % math.pi
     The value of PI is approximately 3.142.

文字列の中に複数の書式がある場合には、以下の例のように、右側の被演算子
にタプルを渡す必要があります:

     >>> table = {'Sjoerd': 4127, 'Jack': 4098, 'Dcab': 7678}
     >>> for name, phone in table.items():
     ...     print '%-10s ==> %10d' % (name, phone)
     ...
     Jack       ==>       4098
     Dcab       ==>       7678
     Sjoerd     ==>       4127

ほとんどの書式化は C 言語と同じように動作し、正しい型を渡す
必要があります; しかし、正しい型を渡さなかった場合にはコアダンプ
ではなく例外の送出になります。書式 `%s' はもっと寛大です:
対応する引数が文字列オブジェクトでなければ、組込み関数 `str()'
を使って文字列に変換してくれます。また、数値表現の桁幅や精度を別個の
(整数の) 引数として渡せるよう、`*' がサポートされています。 C
言語の書式 `%n' と `%p' はサポートされていません。

もしも長い書式化文字列があり、それを分割したくない場合には、
変数を引数の位置ではなく、変数の名前で参照できるとよいでしょう。
以下の形式 `%(name)format' を使えば可能になります:

     >>> table = {'Sjoerd': 4127, 'Jack': 4098, 'Dcab': 8637678}
     >>> print 'Jack: %(Jack)d; Sjoerd: %(Sjoerd)d; Dcab: %(Dcab)d' % table
     Jack: 4098; Sjoerd: 4127; Dcab: 8637678

全てのローカルな変数が入った辞書を返す、新たに紹介する組み込み関数
`vars()' と組み合わせると特に便利です。


File: python-tut-jp.info,  Node: ファイルを読み書きする,  Prev: ファンシーな出力の書式化,  Up: 入力と出力

ファイルを読み書きする
======================

`open()'  はファイルオブジェクトを 返します。  `open()' は、
`open(FILENAME, MODE)' のように二つの引数を伴って
呼び出されることがほとんどです。

     >>> f = open('/tmp/workfile', 'w')
     >>> print f
     <open file '/tmp/workfile', mode 'w' at 80a0960>

最初の引数はファイル名の入った文字列です。二つめの引数もまた文字列で、
ファイルをどのように使うかを示す数個の文字が入っています。 MODE
は、ファイルが読み出し専用なら `'r'' 、 書き込み専用
(同名の既存のファイルがあれば消去されます) なら `'w'' とします。`'a''
はファイルを追記用に開きます; ファイルに書き込まれた
内容は自動的にファイルの終端に追加されます。`'r+'' はファイルを読み
書き両用に開きます。MODE 引数はオプションです; 省略された場合には `'r''
であると仮定します。

Windows や Macintosh では、MODE に `'b'' を追加すると
ファイルをバイナリモードで開きます。したがって、 `'rb'', `'wb'',
`'r+b'' といったモードがあります。 Windows
はテキストファイルとバイナリファイルを区別しています;
テキストファイルでは、読み書きの際に行末文字が自動的に少し変更
されます。 この舞台裏でのファイルデータ変更は、ASCII
でできたテキストファイル では差し支えないものですが、JPEG や `.EXE'
ファイルのような バイナリデータは破損してしまうことになるでしょう。
こうしたファイルを読み書きする際にはバイナリモードを使うよう十分
注意してください。 (Macintosh では、テキストモードに対する
厳密な意味付けは、根底にある使用中の C 言語ライブラリに依存する
ので注意してください。)

* Menu:

* ファイルオブジェクトのメソッド::
* pickle モジュール::


File: python-tut-jp.info,  Node: ファイルオブジェクトのメソッド,  Next: pickle モジュール,  Prev: ファイルを読み書きする,  Up: ファイルを読み書きする

ファイルオブジェクトのメソッド
------------------------------

この節の以降の例は、`f' というファイルオブジェクトが既に
生成されているものと仮定します。

ファイルの内容を読み出すには、`f.read(SIZE)' を呼び出します。
このメソッドはある量のデータを読み出して、文字列として返します。 SIZE
はオプションの数値引数です。SIZE が省略されたり
負の数であった場合、ファイルの内容全てを読み出して返します; ただし、
ファイルがマシンのメモリの二倍の大きさもある場合にはどうなるか
わかりません。 SIZE が負でない数ならば、最大で SIZE バイトを読み出して
返します。ファイルの終端にすでに達していた場合、`f.read()' は
空の文字列 (`""') を返します。

     >>> f.read()
     'This is the entire file.\n'
     >>> f.read()
     ''

`f.readline()' はファイルから 1 行だけを読み取ります; 改行文字 (`\n')
は読み出された文字列の終端に残ります。
改行が省略されるのは、ファイルが改行で終わっていない場合の最終行
のみです。これは、戻り値があいまいでないようにするためです;
`f.readline()' が空の文字列を返したら、ファイルの終端に
達したことが分かります。一方、空行は `'\n'' 、すなわち 改行 1
文字だけからなる文字列で表現されます。

     >>> f.readline()
     'This is the first line of the file.\n'
     >>> f.readline()
     'Second line of the file\n'
     >>> f.readline()
     ''

`f.readlines()' は、ファイルに入っているデータの全ての行からなる
リストを返します。オプションのパラメタ SIZEHINT が指定されて
いれば、ファイルから指定されたバイト数を読み出し、さらに一行を完成
させるのに必要なだけを読み出して、読み出された行からなる
リストを返します。このメソッドは巨大なファイルを行単位で効率的に
読み出すためによく使われます。未完成の行が返されることはありません。

     >>> f.readlines()
     ['This is the first line of the file.\n', 'Second line of the file\n']

`f.write(STRING)' は、 STRING の内容をファイルに 書き込み、`None'
を返します。

     >>> f.write('This is a test\n')

文字列以外をファイルに書き込みたければ、まず文字列に変換
しておかねばなりません:

     >>> value = ('the answer', 42)
     >>> s = str(value)
     >>> f.write(s)

`f.tell()' は、ファイルオブジェクトが指しているあるファイル中の
位置を示す整数を、ファイルの先頭からのバイト数で図った値で返します。
ファイルオブジェクトの位置を変更するには、`f.seek(OFFSET,  FROM_WHAT)'
を使います。ファイル位置は基準点 (reference point) にオフセット値
OFFSET を足して計算されます; 参照点は FROM_WHAT 引数で選びます。
FROM_WHAT の値が 0 ならばファイルの先頭から測り、 1
ならば現在のファイル位置を使い、2 ならばファイルの終端を
参照点として使います。 FROM_WHAT は省略できます。デフォルトの値は 0
、すなわち 参照点としてファイルの先頭を使います。

     >>> f = open('/tmp/workfile', 'r+')
     >>> f.write('0123456789abcdef')
     >>> f.seek(5)     # ファイルの第6バイトへ行く
     >>> f.read(1)
     '5'
     >>> f.seek(-3, 2) # 終端から前へ第3バイトへ行く
     >>> f.read(1)
     'd'

ファイルが用済みになったら、`f.close()' を呼び出してファイルを
閉じ、ファイルを開くために取られていたシステム資源を解放します。
`f.close()' を呼び出した後、そのファイルオブジェクトを使おうと
すると自動的に失敗します。

     >>> f.close()
     >>> f.read()
     Traceback (most recent call last):
       File "<stdin>", line 1, in ?
     ValueError: I/O operation on closed file

ファイルオブジェクトには、他にも `isatty()' や `truncate()'
といった、あまり使われないメソッドがあります;
ファイルオブジェクトについての完全なガイドは、ライブラリリファレンスを
参照してください。


File: python-tut-jp.info,  Node: pickle モジュール,  Prev: ファイルオブジェクトのメソッド,  Up: ファイルを読み書きする

`pickle' モジュール
-------------------

文字列をファイルに読み書きするのは簡単にできます。数値でもほんの
わずかに苦労するくらいです。というのは、`read()' は文字列だけを
返すので、`'123'' のような文字列を受け取って、その数値 123 を返す
`int()' のような関数に対して文字列を渡してやらなければ
ならないからです。ところが、リストや辞書、クラスのインスタンスのように、
もっと複雑なデータ型を保存したいなら、事態はもっと複雑になります。

複雑なデータ型を保存するためのコードを利用者に毎回毎回書かせて
デバッグさせる代わりに、Python では `pickle' という標準
モジュールを用意しています。`pickle' は驚くべきモジュールで、
ほとんどどんな Python オブジェクトも (ある形式の Python コード
でさえも!) 受け取って文字列表現へ変換できます。 この変換過程は
"pickling" (ピクルス (漬物) 化、以降 pickle 化)
と呼ばれます。文字列表現からオブジェクトを再構成する操作は "unpickling"
(逆 pickle 化)と呼びます。 pickle 化や unpickle
化の間、オブジェクトを表現する文字列は
ファイルやデータに保存したり、ネットワーク接続を介して離れたマシンに
送信したりできます。

オブジェクト `x' と、書込み用に開かれているファイルオブジェクト `f'
があると仮定すると、オブジェクトを pickle 化する最も簡単な
方法は、たった一行のコードしか必要ありません:

     pickle.dump(x, f)

逆 pickle 化して再びオブジェクトに戻すには、 `f'
を読取り用に開かれているファイル・オブジェクトと仮定して:

     x = pickle.load(f)

とします。

(逆 pickle 化にはいくつか変型があり、たくさんのオブジェクトを pickle 化
したり、 pickle 化されたデータをファイルに書きたくないときに使われます。
完全なドキュメントについては、  の `pickle' を調べてください。)

`pickle' は、Python のオブジェクトを保存できるようにし、
他のプログラムや、同じプログラムが将来起動されたときに再利用
できるようにする標準の方法です; 技術的な用語でいうと "persistent"
(永続性) オブジェクトです。 `pickle' はとても広範に使われている
ので、Python 拡張モジュールの多くの作者は、行列のような新たなデータ型が
正しく pickle 化/unpickle 化できるよう気をつけています。


File: python-tut-jp.info,  Node: エラーと例外,  Next: クラス,  Prev: 入力と出力,  Up: Top

エラーと例外
************

これまでエラーメッセージについては簡単に触れるだけでしたが、チュートリアル
中の例を自分で試していたら、実際にいくつかのエラーメッセージを見ている
ことでしょう。エラーには (少なくとも)
二つのはっきり異なる種類があります: それは _構文エラー (syntax error)_
と_例外 (exception)_ です。

* Menu:

* 構文エラー::
* 例外::
* 例外を処理する::
* 例外を送出する::
* ユーザ定義の例外::
* 後片付け動作を定義する::


File: python-tut-jp.info,  Node: 構文エラー,  Next: 例外,  Prev: エラーと例外,  Up: エラーと例外

構文エラー
==========

構文エラーは構文解析エラー (parsing error) としても知られており、 まだ
Python を学習中なら、おそらくもっともよく受け取る種の文句でしょう:

     >>> while True print 'Hello world'
       File "<stdin>", line 1, in ?
         while True print 'Hello world'
                        ^
     SyntaxError: invalid syntax

パーサは違反の起きている行を繰り返し、小さな `矢印' を表示して、
違反の起きている行中でエラーが検出された最初の位置を示します。
エラーは矢印の_直前の_ トークンでひき起こされています (または、
少なくともそこで検出されています)。 上述の例の中では、エラーは `print'
で検出されています。 コロン (`:') がその前に無いからです。
入力がスクリプトから来ている場合は、どこを見ればよいか分かるように
ファイル名と行番号が出力されます。


File: python-tut-jp.info,  Node: 例外,  Next: 例外を処理する,  Prev: 構文エラー,  Up: エラーと例外

例外
====

たとえ文や式が構文的に正しくても、実行しようとしたときにエラーが
発生するかもしれません。 実行中に検出されたエラーは _例外 (exception)_
と呼ばれ、 常に致命的とは限りません: Python
プログラムで例外をどのように扱うかは、
すぐに習得することでしょう。ほとんどの例外はプログラムで処理されず、
以下に示されるようなメッセージになります:

     >>> 10 * (1/0)
     Traceback (most recent call last):
       File "<stdin>", line 1, in ?
     ZeroDivisionError: integer division or modulo by zero
     >>> 4 + spam*3
     Traceback (most recent call last):
       File "<stdin>", line 1, in ?
     NameError: name 'spam' is not defined
     >>> '2' + 2
     Traceback (most recent call last):
       File "<stdin>", line 1, in ?
     TypeError: cannot concatenate 'str' and 'int' objects

エラーメッセージの最終行は何が起こったかを示しています。
例外は様々な例外型 (type) で起こり、その型がエラーメッセージの
一部として出力されます: 上の例での型は `ZeroDivisionError',
`NameError', `TypeError' です。
例外型として出力される文字列は、発生した組み込み例外の名前です。
これは全ての組み込み例外について成り立ちますが、 ユーザ定義の例外では
(成り立つようにするのは有意義な慣習ですが) 必ずしも成り立ちません。
標準例外の名前は組み込みの識別子です (予約語ではありません)。

残りの行は例外の詳細で、その解釈は例外の型に依存します;
これらの行の意味するところは例外の型に依存します。

エラーメッセージの先頭部分では、例外が発生した実行コンテキスト
(context) を、スタックのバックトレース (stack backtrace) の
形式で示しています。一般には、この部分にはソースコード行を
リストしたバックトレースが表示されます; しかし、標準入力から
読み取られた行については表示しません。

には、組み込み例外とその意味がリストされています。


File: python-tut-jp.info,  Node: 例外を処理する,  Next: 例外を送出する,  Prev: 例外,  Up: エラーと例外

例外を処理する
==============

例外を選別して処理するようなプログラムを書くことができます。
以下の例を見てください。この例では、有効な文字列が入力されるまで
ユーザに入力を促しますが、ユーザがプログラムに (<Control-C>
か、またはオペレーティングシステムがサポート
している何らかのキーを使って) 割り込みをかけてプログラムを
中断させることができるようにしています; ユーザが生成した割り込みは、
`KeyboardInterrupt' 例外が送出されることで通知される
ということに注意してください。

     >>> while True:
     ...     try:
     ...         x = int(raw_input("Please enter a number: "))
     ...         break
     ...     except ValueError:
     ...         print "Oops! That was no valid number.  Try again..."
     ...

`try' 文は下記のように動作します。

   * まず、 _try 節 (try clause)_ (キーワード `try' と `except'
     のあいだの文) が実行されます。

   * 何も例外が発生しなければ、_except 節_ をスキップして `try'
     文の実行を終えます。

   * try 節内の実行中に例外が発生すると、その節の残りは飛ばされます。
     次に、例外型が `except' キーワードの後に指定されている
     例外に一致する場合、try 節の残りはスキップして、 except 節が実行
     された後、 `try' 節の後の文に実行が継続されます。

   * もしも except 節で指定された例外と一致しない例外が発生すると、
     その例外は `try' 文の外側に渡されます。例外に対する ハンドラ
     (handler、処理部) がどこにもなければ、 _処理されない例外
     (unhandled exception)_ となり、
     上記に示したようなメッセージを出して実行を停止します。


一つの `try' 文に複数の except 節を設けて、さまざまな例外に
対するハンドラを指定することができます。同時に一つ以上のハンドラが
実行されることはありません。ハンドラは対応する try 節内で発生した
例外だけを処理し、同じ try 節内の別の例外ハンドラで起きた例外は
処理しません。except 節には複数の例外を丸括弧で囲ったリストにして
渡すことができます。例えば以下のようにします:

     ... except (RuntimeError, TypeError, NameError):
     ...     pass

最後の except 節では例外名を省いて、ワイルドカード (wildcard、総称記号)
にすることができます。ワイルドカードの except 節は非常に注意して使って
ください。というのは、ワイルドカードは通常のプログラムエラーをたやすく
隠してしまうからです！ワイルドカードの except 節はエラーメッセージを
出力した後に例外を再送出する (関数やメソッドの呼び出し側が同様にして
例外を処理できるようにする) 用途にも使えます:

     import sys
     
     try:
         f = open('myfile.txt')
         s = f.readline()
         i = int(s.strip())
     except IOError, (errno, strerror):
         print "I/O error(%s): %s" % (errno, strerror)
     except ValueError:
         print "Could not convert data to an integer."
     except:
         print "Unexpected error:", sys.exc_info()[0]
         raise

`try' ... `except' 文には、オプションで _else 節 (else clause)_
を設けることができます。`else' 節を設ける場合、全ての `except'
節よりも後ろに置かねばなりません。 `except' 節は、try
節で全く例外が送出されなかったときに
実行されるコードを書くのに役立ちます。例えば以下のようにします:

     for arg in sys.argv[1:]:
         try:
             f = open(arg, 'r')
         except IOError:
             print 'cannot open', arg
         else:
             print arg, 'has', len(f.readlines()), 'lines'
             f.close()

追加のコードを追加するのは `try' 節の後ろよりも `else'
節の方がよいでしょう。なぜなら、そうすることで `try' ... `except'
文で保護したいコードから
送出されたもの以外の例外を偶然に捕捉してしまうという事態を避けられる
からです。

例外が発生するとき、例外に関連付けられた値を持つことができます。
この値は例外の例外の_引数 (argument)_ としても知られています。
引数の有無と引数の型がどうなっているかは例外の型に依存します。

except 節では、例外名 (または例外名リスト) の後に変数を指定することが
できます。この変数は例外インスタンスに結び付けられており、
`instance.args' に例外インスタンス生成時の引数が入っています。
例外インスタンスには `__getitem__' および `__str__' が
定義されており、`.args' を参照しなくても引数に直接アクセスしたり
印字したりできるように利便性が図られています。

     >>> try:
     ...    raise Exception('spam', 'eggs')
     ... except Exception, inst:
     ...    print type(inst)     # 例外インスタンス
     ...    print inst.args      # .args に記憶されている引数
     ...    print inst           # __str__ で引数を直接出力できる
     ...    x, y = inst          # __getitem__ で引数を直接アンパックできる
     ...    print 'x =', x
     ...    print 'y =', y
     ...
     <type 'instance'>
     ('spam', 'eggs')
     ('spam', 'eggs')
     x = spam
     y = eggs

処理されない例外の場合、例外が引数を持っていれば、メッセージの 最後の
(`詳細説明の') 部分に出力されます。

例外ハンドラは、try 節でじかに発生した例外を処理するだけではなく、 その
try 節から呼び出された関数の内部で発生した例外も処理します
(間接的に呼ばれていてもです) 。例えば:

     >>> def this_fails():
     ...     x = 1/0
     ...
     >>> try:
     ...     this_fails()
     ... except ZeroDivisionError, detail:
     ...     print 'Handling run-time error:', detail
     ...
     Handling run-time error: integer division or modulo


File: python-tut-jp.info,  Node: 例外を送出する,  Next: ユーザ定義の例外,  Prev: 例外を処理する,  Up: エラーと例外

例外を送出する
==============

`raise' 文を使うと、プログラマは指定した例外を強制的に
送出させられます。例えば:

     >>> raise NameError, 'HiThere'
     Traceback (most recent call last):
       File "<stdin>", line 1, in ?
     NameError: HiThere

`raise' の第一引数には、ひき起こすべき例外を指定します。
オプションの第二引数では例外の引数を指定します。

例外が発生したかどうかは判定したいが、その処理を行おうとは思っていない
場合、単純な形式の `raise' 文を使って例外を再送出させることが できます:

     >>> try:
     ...     raise NameError, 'HiThere'
     ... except NameError:
     ...     print 'An exception flew by!'
     ...     raise
     ...
     An exception flew by!
     Traceback (most recent call last):
       File "<stdin>", line 2, in ?
     NameError: HiThere


File: python-tut-jp.info,  Node: ユーザ定義の例外,  Next: 後片付け動作を定義する,  Prev: 例外を送出する,  Up: エラーと例外

ユーザ定義の例外
================

プログラム上で新しい例外クラスを作成することで、独自の例外を指定する
ことができます。例外は、典型的に `Exception' クラスから、
直接または間接的に導出したものです。例えば:

     >>> class MyError(Exception):
     ...     def __init__(self, value):
     ...         self.value = value
     ...     def __str__(self):
     ...         return repr(self.value)
     ...
     >>> try:
     ...     raise MyError(2*2)
     ... except MyError, e:
     ...     print 'My exception occurred, value:', e.value
     ...
     My exception occurred, value: 4
     >>> raise MyError, 'oops!'
     Traceback (most recent call last):
       File "<stdin>", line 1, in ?
     __main__.MyError: 'oops!'

例外クラスでは、他のクラスができることなら何でも定義することが
できますが、通常は単純なものにしておきます。たいていは、いくつかの
属性だけを提供し、例外が発生したときにハンドラがエラーに関する情報
を取り出せるようにする程度にとどめます。
複数の別個の例外を送出するようなモジュールを作成する際には、
そのモジュールで定義されている例外の基底クラスを作成するのが
一般的なならわしです:

     class Error(Exception):
         """Base class for exceptions in this module."""
         pass
     
     class InputError(Error):
         """Exception raised for errors in the input.
     
         Attributes:
             expression -- input expression in which the error occurred
             message -- explanation of the error
         """
     
         def __init__(self, expression, message):
             self.expression = expression
             self.message = message
     
     class TransitionError(Error):
         """Raised when an operation attempts a state transition that's not
         allowed.
     
         Attributes:
             previous -- state at beginning of transition
             next -- attempted new state
             message -- explanation of why the specific transition is not allowed
         """
     
         def __init__(self, previous, next, message):
             self.previous = previous
             self.next = next
             self.message = message

ほとんどの例外は、標準の例外の名前付けと同様に、 "Error,"
で終わる名前で定義されています。

多くの標準モジュールでは、モジュールで定義されている関数内で発生する
可能性のあるエラーを報告させるために、独自の例外を定義しています。
クラスについての詳細な情報は *Note クラス:: 章、 "クラス" で
提供されています。


File: python-tut-jp.info,  Node: 後片付け動作を定義する,  Prev: ユーザ定義の例外,  Up: エラーと例外

後片付け動作を定義する
======================

`try' 文にはもう一つオプションの節があります。この節は
クリーンアップ動作を定義するためのもので、どんな状況でも必ず
実行されます。例えば:

     >>> try:
     ...     raise KeyboardInterrupt
     ... finally:
     ...     print 'Goodbye, world!'
     ...
     Goodbye, world!
     Traceback (most recent call last):
       File "<stdin>", line 2, in ?
     KeyboardInterrupt

_finally 節 (finally clause)_ は、 try
節で例外が発生したかどうかに関係なく実行されます。
例外が発生した時は、finally 節を実行した後、その例外を再送出します。
finally 節はまた、`try' 文から `break' 文や `return'
文経由で抜ける際にも、 "抜ける途中で" 実行されます。

finally 節中のコードは (ファイルやネットワーク接続のような) 外部の資源
について、資源の利用が成功したかどうかに関係なく解放を行うのに便利です。

`try' 文には、一個以上の except 節か、または一個の finally
節を持たねばなりませんが、両方持つことはできません。


File: python-tut-jp.info,  Node: クラス,  Next: 標準ライブラリの簡単なツアー,  Prev: エラーと例外,  Up: Top

クラス
******

Python では、最小限の構文と意味付けを使ってクラス (class) のメカニズム
を言語に追加しています。Python のクラスは、C++ と Modula-3 で
見られるクラスメカニズムを混合したものです。モジュールがそうであるように、
Python におけるクラスでは、クラス定義とユーザとの間に絶対的な障壁を
おかず、ユーザが礼儀正しく、 "定義に首を突っ込む" ことはないと
あてにしています。とはいえ、クラスにおける最も重要な機能はそのままに、
完全な力を持っています: クラスの継承 (inheritance) メカニズムでは、
複数の基底クラスを持つことができ、導出されたクラスでは基底クラスの
任意のメソッドをオーバライド (override, 上書き) することができます。
メソッドでは、基底クラスのメソッドを同じ名前で呼び出すことができます。
オブジェクトには任意のプライベートなデータを入れることができます。

C++ の用語では、全てのクラスメンバ (データメンバも含む) は _public_
(公開されたデータ) であり、メンバ関数はすべて _仮想関数 (virtual)_
です。特別なコンストラクタ (constructor、 生成関数) やデストラクタ
(destructor、破壊関数) はありません。 Module-3
にあるような、オブジェクトのメンバをメソッドから参照する
ために短縮した記法を使うことはできません: メソッド関数の宣言では、
オブジェクト自体をあらわす明示的な第一の引数を伴います。オブジェクトは
メソッド呼び出しの際に非明示的に渡されます。Smalltalk にあるように、
クラス自体もオブジェクトです。ただし広義のオブジェクトですが: Python
では全てのデータ型はオブジェクトです。このことが、 import
や名前変更といった操作の意味付けを提供しています。 しかし、C++ や
Modula-3 と違って、
ユーザが組込みの型を基底クラスにして拡張することはできません。
また、C++ と同じで、Modula-3 とは違い、特別な構文を伴う
ほとんどの組み込み演算子 (算術演算子 (arithmetic operator) や 添字表記)
はクラスインスタンスで使うために再定義することができます。

* Menu:

* 用語について一言::
* Python のスコープと名前空間::
* クラス初見::
* いろいろな注意点::
* 継承::
* プライベート変数::
* 残りのはしばし::
* イテレータ iterator::
* ジェネレータ generator::


File: python-tut-jp.info,  Node: 用語について一言,  Next: Python のスコープと名前空間,  Prev: クラス,  Up: クラス

用語について一言
================

クラスに関して広範に受け入れられている用語定義がないので、 Smalltalk と
C++ の用語を場合に応じて使っていくことに します。
(オブジェクト指向における意味付けの方法は C++よりも Modula-3 のほうが
Python に近いので Modula-3 の用語を使いたいのですが、
ほとんどの読者はそれを耳にしたことがないと思います。)

また、オブジェクト指向派の読者にとって用語上の落し穴があることを、
警告しておかねばなりません:  Python では、"オブジェクト" という言葉は
必ずしもクラスのインスタンスを意味しません。 C++ や Modula-3
と同じく、そして Smalltalk とは違い、Python では
すべての型がクラスで定義されているとは限りません。
整数やリストのような基本的な組込み型はクラスではなく、
ファイルのような幾分珍しい型ですらクラスではありません。
とはいえ、Python の型は _すべて_、オブジェクトという言葉を使って
記述するのが最適な、ちょっとした共通の意味付けを共有しています。

オブジェクトには個体性があり、同一のオブジェクトに (複数のスコープの)
複数の名前を割り当てることができます。この機能は他の言語では 別名
(ailias) づけとして知られています。Python を一見しただけでは、
別名づけの重要性は分からないことが多く、変更不能な基本型 (数値、文字列、
タプル) を扱うときには無視して差し支えありません。
しかしながら、別名付けには、リストや辞書、またプログラムの外部
にある実体 (ファイル、ウィンドウ、など) を表現するためのほとんどの型
が入った Python コードで意味付けを行う上で (意図的な！) 効果があります。
別名付けはいくつかの点でポインタのように振舞うので、通常はプログラムに
利するように使われます。例えば、オブジェクトの受け渡しは、実装上は
ポインタが渡されるだけなのでコストの低い操作になります; また、関数が
あるオブジェクトを引数として渡されたとき、関数の呼び出し側から
オブジェクトに対する変更を見ることができます -- これにより、 Pascal
にあるような二つの引数渡し機構をもつ必要をなくしています。


File: python-tut-jp.info,  Node: Python のスコープと名前空間,  Next: クラス初見,  Prev: 用語について一言,  Up: クラス

Python のスコープと名前空間
===========================

クラスを紹介する前に、Python のスコープ規則についてあることを話して
おかなければなりません。クラス定義はある巧みなトリックを名前空間に
施すので、何が起こっているのかを完全に理解するには、スコープと
名前空間がどのように動作するかを理解する必要があります。
ちなみに、この問題に関する知識は全ての Python プログラマにとって
有用です。

まず定義から始めましょう。

_名前空間 (namespace)_ とは、 名前からオブジェクトへの対応付け
(mapping) です。 ほとんどの名前空間は、現状では Python
の辞書として実装されていますが、 そのことは通常は
(パフォーマンス以外では) 目立つことはないし、
将来は変更されるかもしれません。 名前空間の例には、組込み名の集合
(`abs()' 等の関数や組込み 例外名)、モジュールないのグローバルな名前;
関数を呼び出したときの
ローカルな名前、があります。その意味では、オブジェクトの属性から
なる集合もまた、名前空間を形成します。名前空間について知っておくべき
重要なことは、異なった名前空間にある名前の間には全く関係がないと
いうことです; 例えば、二つの別々のモジュールの両方で関数 "maximize"
という関数を定義することができ、定義自体は混同され ることはありません
-- モジュールのユーザは名前の前にモジュール名を つけなければなりません。

ところで、_属性_という言葉は、ドットに続く名前すべてに対して
使っています -- 例えば式 `z.real' で、`real' は オブジェクト `z'
の属性です。厳密にいえば、モジュール内の名前に
対する参照は属性の参照です: 式 `modname.funcname' では、 `modname'
はあるモジュールオブジェクトで、`funcname' は
その属性です。この場合には、たまたまモジュールの属性とモジュール内の
グローバルな名前の間には
この場合はたまたま、モジュールの属性とモジュールで定義されている
グローバル名の間には、直接的な対応付けがされます: これらの名前は
同じ名前空間を共有しているのです！ (1)

属性は読取り専用にも、書き込み専用にもできます。
後者の場合、属性に代入することができます。
モジュール属性は書込み可能です: `modname.the_answer = 42' と書く
ことができます。書込み可能な属性は、`del' 文で削除することも
できます。例えば、`del modname.the_answer' は、`modname'
で指定されたオブジェクトから属性 `the_answer' を除去します。

名前空間は様々な時点で作成され、その寿命も様々です。
組み込みの名前が入った名前空間は Python インタプリタが起動するときに
作成され、決して削除されることはありません。モジュールのグローバルな
名前空間は、モジュール定義が読み込まれたときに作成されます; 通常、
モジュールの名前空間は、インタプリタが終了するまで残ります。
インタプリタのトップレベルで実行された文は、スクリプトファイルから
読み出されたものでも対話的に読み出されたものでも、`__main__'
という名前のモジュールの一部分であるとみなされるので、独自の
名前空間を持つことになります。(組み込みの名前は実際にはモジュール内
に存在します; そのモジュールは `__builtin__' と呼ばれています。)

関数のローカルな名前空間は、関数が呼び出されたときに作成され、
関数から戻ったときや、関数内で例外が送出され、かつ関数内で処理され
なかった場合に削除されます。
(実際には、忘れられる、と言ったほうが起きていることをよく表して
います。) もちろん、再帰呼出しのときには、各々の呼び出しで各自の
ローカルな名前空間があります。

_スコープ (scope)_ とは、ある名前空間が直接アクセスできる (directly
accessible) ような、Python プログラムのテキスト上の領域 です。
"直接アクセス可能" とは、限定なし (unqualified) である名前を参照
した際に、その名前空間から名前を見つけようと試みることを意味します。

スコープは静的に決定されますが、動的に使用されます。
実行中はいつでも、直接名前空間にアクセス可能な、少なくとも三つの
入れ子になったスコープがあります:
最初に検索される最も内側のスコープには、ローカルな名前が入っています;
あるいは、最も内側のスコープを囲んでいる関数群のスコープで、最も
近傍のスコープから検索を始めます; 中間のスコープが次に検索され、
このスコープには現在のモジュールのグローバルな名前が入っています;
(最後に検索される) 最も外側のスコープは、組み込みの名前が入った
名前空間です。

名前がグローバルであると宣言されている場合、その名前に対する参照や
代入は全て、モジュールのグローバルな名前の入った中間のスコープに
対して直接行われます。そうでない場合、最も内側のスコープより外側に
ある変数は全て読み出し専用となります。

通常、ローカルスコープは (プログラムテキスト上の) 現在の関数の
ローカルな名前を参照します。関数の外側では、ローカルスコープは
グローバルな名前空間と同じ名前空間: モジュールの名前空間を参照します。
クラスを定義すると、ローカルスコープの中にもう一つ名前空間が置かれ
ます。

スコープはテキスト上で決定されていると理解することが重要です:
モジュール内で定義される関数のグローバルなスコープは、
関数がどこから呼び出されても、どんな別名をつけて呼び出されても、
そのモジュールの名前空間になります。反対に、実際の名前の検索は
実行時に動的に行われます -- とはいえ、言語の定義は、"コンパイル"
時の静的な名前解決の方向に進化しているので、
動的な名前解決に頼ってはいけません！ (事実、ローカルな変数は既に
静的に決定されています。)

Python 特有の癖として、代入を行うと名前がいつも最も内側のスコープに
入るというものがあります。代入はデータのコピーを行いません --
単に名前をオブジェクトに結びつける (bind) だけです。オブジェクトの削除
でも同じです: `del x' は、`x' をローカルスコープが参照している
名前空間から削除します。実際、新たな名前を導入する操作は全てローカル
スコープを用います: とりわけ、 import 文や関数定義は、モジュールや
関数の名前をローカルスコープに結び付けます。(`global' 文を使えば、
特定の変数がグローバルスコープにあることを示せます。)

---------- Footnotes ----------

(1) 例外が一つあります。
モジュールオブジェクトには、秘密の読取り専用の属性 `__dict__'
があり、モジュールの名前空間を実装するために使われている辞書を返します;
`__dict__' という名前は属性ですが、グローバルな名前では
ありません。この属性を利用すると名前空間の実装に対する抽象化を
侵すことになるので、プログラムを検死するデバッガのような用途に限る
べきです。


File: python-tut-jp.info,  Node: クラス初見,  Next: いろいろな注意点,  Prev: Python のスコープと名前空間,  Up: クラス

クラス初見
==========

クラスでは、新しい構文を少しと、三つの新たなオブジェクト型、そして
新たな意味付けをいくつか取り入れています。

* Menu:

* クラス定義の構文::
* クラスオブジェクト::
* インスタンスオブジェクト::
* メソッドオブジェクト::


File: python-tut-jp.info,  Node: クラス定義の構文,  Next: クラスオブジェクト,  Prev: クラス初見,  Up: クラス初見

クラス定義の構文
----------------

クラス定義の最も単純な形式は、以下のようになります:

     class ClassName:
         <文-1>
         .
         .
         .
         <文-N>

関数定義 (`def' 文) と同様、クラス定義が効果をもつには
まず実行しなければなりません。 (クラス定義を `if'
文の分岐先や関数内部に置くことも、 考え方としてはありえます。)

実際には、クラス定義の内側にある文は、通常は関数定義になりますが、
他の文を書くこともでき、それがそれが役に立つこともあります --
これについては後で述べます。クラス内の関数定義は通常、メソッドの
呼び出し規約で決められた独特の形式の引数リストを持ちます --
これについても後で述べます。

クラス定義に入ると、新たな名前空間が作成され、ローカルな
名前空間として使われます -- 従って、ローカルな変数に対する
全ての代入はこの新たな名前空間に名要ります。特に、関数定義を
行うと、新たな関数の名前はこの名前空間に結び付けられます。

クラス定義から普通に (定義の終端に到達して) 抜けると、
_クラスオブジェクト (class object) _ が生成されます。
クラスオブジェクトは、基本的にはクラス定義で作成された名前空間の
内容をくるむラッパ (wrapper) です; クラスオブジェクトについては
次の節で詳しく学ぶことにします。(クラス定義に入る前に有効だった)
元のローカルスコープが復帰し、生成されたクラスオブジェクトは
復帰したローカルスコープにクラス定義のヘッダで指定した名前 (上の例では
`ClassName') で結び付けられます。

