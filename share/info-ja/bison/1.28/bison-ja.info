-*- coding: utf-8 -*-
START-INFO-DIR-ENTRY
* bison-ja: (bison-ja). GNU Project parser generator (yacc replacement).
END-INFO-DIR-ENTRY

   このファイルはBison構文解析器生成器の説明文書です。

   Copyright (C) 1988, 89, 90, 91, 92, 93, 95, 98, 1999 Free Software
Foundation, Inc.

   Permission is granted to make and distribute verbatim copies of this
manual provided the copyright notice and this permission notice are
preserved on all copies.

   Permission is granted to copy and distribute modified versions of
this manual under the conditions for verbatim copying, provided also
that the sections entitled "GNU General Public License" and "Conditions
for Using Bison" are included exactly as in the original, and provided
that the entire resulting derived work is distributed under the terms
of a permission notice identical to this one.

   Permission is granted to copy and distribute translations of this
manual into another language, under the above conditions for modified
versions, except that the sections entitled "GNU General Public
License", "Conditions for Using Bison" and this permission notice may be
included in translations approved by the Free Software Foundation
instead of in the original English.


File: bison-ja.info,  Node: Top,  Next: Introduction,  Prev: (dir),  Up: (dir)

   このマニュアルはBison 1.28の説明文書です。

* Menu:

* Introduction::
* Conditions::
* Copying::           GNU一般使用公有許諾書はBisonを複製したり共有したり
                        する方法を示している

チュートリアル部分:
* Concepts::          Bisonを理解するための基本概念.
* Examples::          Bisonの利用を簡単に説明した3つの例.

参照部分:
* Grammar File::      Bisonの宣言と規則を書く.
* Interface::         解析器関数`yyparse'へのC言語のインターフェース.
* Algorithm::         Bison解析器が実行時に動作する方法.
* Error Recovery::    エラー回復の規則を書く.
* Context Dependency::  言語構文がBisonが率直に扱うには複雑すぎるときに
                        何をすべきか.
* Debugging::         間違った解析をするBison解析器のデバッグをする.
* Invocation::        (解析器ソースファイルを生成するために)Bisonを実行
                      する方法.
* Table of Symbols::  Bisonの全てのキーワードの説明.
* Glossary::          基本概念の説明.
* Index::             テキストへの相互参照.

 --- The Detailed Node Listing ---

Bisonの概念

* Language and Grammar::  数学の発想と同じ、言語と文脈に依存しない文法.
* Grammar in Bison::  Bisonのために文法を表現する方法.
* Semantic Values::   それぞれのトークンや文法グループは意味値
                        （整数の値、識別子の名前、など。）
                         を取ることができる.
* Semantic Actions::  それぞれの規則はCコードを含んだアクションを持つこ
                        とができる.
* Bison Parser::      Bisonの入力と出力な何で、出力はどのように使われる
                       か。
* Stages::            Bisonの文法を書いて実行させる手順.
* Grammar Layout::    Bison文法ファイルの全体の構造.

例

* RPN Calc::          逆ポーランド記法電卓;
                        演算子の優先順位が無い、最初の例.
* Infix Calc::        中間（代数）記法電卓.
                        演算子の優先順位が導入された.
* Simple Error Recovery::  構文エラーの後も続行する.
* Multi-function Calc::  メモリと三角関数付きの電卓.
                           意味値に複数のデータ型を使用する.
* Exercises::         多機能電卓を改善するための着想.

逆ポーランド記法電卓

* Decls: Rpcalc Decls.  rpcalcのためのBisonとCの宣言.
* Rules: Rpcalc Rules.  rpcalcのための文法規則。説明付き.
* Lexer: Rpcalc Lexer.  字句解析器.
* Main: Rpcalc Main.    制御関数.
* Error: Rpcalc Error.  エラー報告関数.
* Gen: Rpcalc Gen.      文法ファイルでBisonを実行する.
* Comp: Rpcalc Compile. 出力コードにCコンパイラを実行する.

`rpcalc'のための文法規則

* Rpcalc Input::
* Rpcalc Line::
* Rpcalc Expr::

多機能電卓：`mfcalc'

* Decl: Mfcalc Decl.      多機能電卓のためのBisonの宣言.
* Rules: Mfcalc Rules.    電卓のための文法規則.
* Symtab: Mfcalc Symtab.  記号表を管理するサブルーチン.

Bison文法ファイル

* Grammar Outline::   文法ファイルの概略.
* Symbols::           終端記号と非終端記号.
* Rules::             文法規則の書き方.
* Recursion::         再帰的規則の書き方.
* Semantics::         意味値とアクション.
* Declarations::      全ての種類のBison宣言の説明.
* Multiple Parsers::  一つのプログラムに一つより多くのBison構文解析器を
                        入れる.

Bison文法の概要

* C Declarations::    C宣言部の構文と使用法.
* Bison Declarations::  Bison宣言部の構文と使用法.
* Grammar Rules::     文法規則部の構文と使用法.
* C Code::            追加のCコード部の構文と使用法.

言語の意味の定義

* Value Type::        全ての意味値に一つのデータ型を指定する.
* Multiple Types::    複数の別のデータ型を指定する.
* Actions::           アクションは文法規則の意味的定義.
* Action Types::      アクションが操作するデータ型を指定する.
* Mid-Rule Actions::  ほとんどのアクションは規則の最後に行く.
                      これは規則の最中で、いつ、なぜ、どのように
                        例外アクションを使用するかを指示する.

Bison宣言

* Token Decl::        終端記号を宣言する.
* Precedence Decl::   優先順位と結合規則とともに終端を宣言する.
* Union Decl::        全ての意味値の型の集合を宣言する.
* Type Decl::         非終端記号のための型の選択を宣言する.
* Expect Decl::       シフト/還元衝突の警告を抑制する.
* Start Decl::        開始記号を指定する.
* Pure Decl::         再入構文解析器を要求する.
* Decl Summary::      全てのBison宣言の表.

構文解析器のC言語インターフェイス

* Parser Function::   `yyparse'の呼び方と、それが返すもの.
* Lexical::           トークンを読み込む関数`yylex'を提供しなければ
                        ならない.
* Error Reporting::   関数`yyerror'を提供しなければならない.
* Action Features::   アクションで使える特別な機能.

字句解析器関数`yylex'

* Calling Convention::  `yyparse'が`yylex'を呼ぶ方法.
* Token Values::      `yylex'がどのように読み込んだトークンの
                        意味値を返さなければならないか.
* Token Positions::   アクションが望むときに、どのように`yylex'が
                        テキストの位置（行数など）を返さなければならない
                        か。
* Pure Calling::      純粋な構文解析器で呼び出し型の習慣がどのように
                        違うか (*note A Pure (Reentrant) Parser: Pure Decl.).

Bison構文解析器のアルゴリズム

* Look-Ahead::        構文解析器は何をするかを決めるときに一つ先のトーク
                        ンを見る.
* Shift/Reduce::      衝突: シフトと還元の両方が有効なとき.
* Precedence::        演算子の優先順位は衝突を解決することで動作する.
* Contextual Precedence::  演算子の優先順位が文脈に依存するとき.
* Parser States::     構文解析器はスタック付きの有限状態機械.
* Reduce/Reduce::     同じ状況に2つの規則が適用可能なとき.
* Mystery Conflicts::  正しくないように見える還元/還元衝突.
* Stack Overflow::    スタックが一杯になったときに何が起こるうか. それを
                        避ける方法.

演算子の優先順位

* Why Precedence::    優先順位が必要なことを示す例.
* Using Precedence::  Bison文法で優先順位を指定する方法.
* Precedence Examples::  前の例でこれらの機能が使われた方法.
* How Precedence::    どのように動作するか.

文脈依存性の処理

* Semantic Tokens::   トークン構文解析は意味的文脈に依存する.
* Lexical Tie-ins::   トークン構文解析は構文的文脈に依存する.
* Tie-in Recovery::   字句結び付きはエラー回復規則を書く方法に影響する.

Bisonの実行

* Bison Options::     全てのオプションが詳しく、短いオプションでアルファ
                        ベット順に説明されている.
* Option Cross Key::  長いオプションのアルファッベット順のリスト.
* VMS Invocation::    VMSでのBisonのコマンド構文.


File: bison-ja.info,  Node: Introduction,  Next: Conditions,  Prev: Top,  Up: Top

まえがき
********

Bisonは、LALR(1)文脈自由文法の文法定義を、
その文法を解析するためのCで書かれたプログラムに変換する、
汎用の構文解析器生成ツールです。 あなたがBisonに熟練すれば、
簡単な電卓から複雑なプログラミング言語まで、
広い範囲の言語解析器を開発できるようになるでしょう。

   BisonはYaccの上位互換です。
正しく書かれたすべてのYacc文法を、変更なくBisonで処理できます。
Yaccに親しんでいるすべての人は、ちょっと考えるだけで、
Bisonを使えるようになるでしょう。 Bisonを使い、本書を理解するためには、
C言語に精通している必要があります。

1章と2章は入門の章です。1章では、Bisonを使うための基本的な概念を説明し、
2章では3つの具体例を示します。 BisonやYaccを知らない方は、
1章から読みはじめてください。
3章以降では、Bisonの仕様を詳細に解説します。

   Bisonは、最初にRobert Corbettによって開発され、 Richard
StallmanがYacc互換にしました。 カーネギーメロン大学のWilfred Hansenが、
文字列リテラル(1)といくつかの機能を追加しました。

   本書は、Bisonのバージョン1.28に基づいています。

日本語訳にあたって
==================

本書は、株式会社アスキーの 支援を受けて、慶應義塾の石川直太
（`naota@sfc.keio.ac.jp、http://www.sfc.keio.ac.jp/~naota/'）
が翻訳しました。

   なお、「GNU一般公有使用許諾書」の日本語訳については、
引地さんのところの日本語訳を使わせていただいたことを
ここに記して感謝いたします。

   日本語訳したtexinfoファイルは、
`http://www.ascii.co.jp/pub/GNU/bison-1.25-man-jp.tgz'
にあります。コマンドtexi2dviなどでdviファイルを生成したり、GNU Emacsで
infoファイルへ変換したりできます。

   バージョン1.25 からバージョン1.28の変更はgnujdocプロジェクトの
一環として林芳樹 (<t90553@mail.ecc.u-tokyo.ac.jp>) が 行いました。

   gnujdoc の詳細は、
`http://duff.kuicr.kyoto-u.ac.jp/%7Eokuji/gnujdoc/' を参照してください。

   ---------- Footnotes ----------

   (1) 【訳注】2文字以上の文字列、たとえば`=='を、
トークン名に使う機能。


File: bison-ja.info,  Node: Conditions,  Next: Copying,  Prev: Introduction,  Up: Top

Bisonの利用条件
***************

Bisonバージョン1.24において、フリーでないプログラムへのBisonの出力の
利用を許可するために、`yyparse'の配布条件を変えました。
それまでは、Bisonによって生成された構文解析器は、
フリーソフトウェアのプログラム中でのみ、利用可能でした。

   GNU Cコンパイラなど他のGNUプログランミングツールには、
このような制限がありません。
それらは、いつでも、フリーでないソフトウェアの開発に利用できます。
Bisonの利用条件が異なっていた理由は、特別な政治的判断によるものではありません。
BisonのすべてのソースコードにGPLを適用した結果です。

   Bisonの出力であるBison構文解析器ファイルには、
`yyparse'関数のためのコードである、
かなりの量のBisonのソースコードの一部分が、そのまま含まれます
（あなたが定義した文法によるアクションは、
この関数の1か所に挿入されるだけで、残りの関数は変わりません）。
われわれFSFが`yyparse'のコードにGPLを適用した結果、
Bisonの出力をフリーソフトウェアのみに利用するという制約ができたのです。

   ソフトウェアを専売しようとする人々への思いやりによって、
われわれが条件を変えることはありませんでした。
*ソフトウェアはフリーであるべきです。*
しかし、われわれは、Bisonの利用をフリーソフトウェアに限定したことは、
他のソフトウェアをフリーにしようとする人々を勇気づけるために、
少なからず役立っただろうと、結論を下しました。
そこで、われわれは、その他のGNUツールの現実的な利用条件に合わせて、
Bisonの現実的な利用条件を決定することにしました。


File: bison-ja.info,  Node: Copying,  Next: Concepts,  Prev: Conditions,  Up: Top

GNU GENERAL PUBLIC LICENSE
**************************

                         Version 2, June 1991

     Copyright (C) 1989, 1991 Free Software Foundation, Inc.
     59 Temple Place, Suite 330, Boston, MA  02111-1307  USA

     Everyone is permitted to copy and distribute verbatim copies
     of this license document, but changing it is not allowed.

Preamble
========

The licenses for most software are designed to take away your freedom
to share and change it.  By contrast, the GNU General Public License is
intended to guarantee your freedom to share and change free
software--to make sure the software is free for all its users.  This
General Public License applies to most of the Free Software
Foundation's software and to any other program whose authors commit to
using it.  (Some other Free Software Foundation software is covered by
the GNU Library General Public License instead.)  You can apply it to
your programs, too.

   When we speak of free software, we are referring to freedom, not
price.  Our General Public Licenses are designed to make sure that you
have the freedom to distribute copies of free software (and charge for
this service if you wish), that you receive source code or can get it
if you want it, that you can change the software or use pieces of it in
new free programs; and that you know you can do these things.

   To protect your rights, we need to make restrictions that forbid
anyone to deny you these rights or to ask you to surrender the rights.
These restrictions translate to certain responsibilities for you if you
distribute copies of the software, or if you modify it.

   For example, if you distribute copies of such a program, whether
gratis or for a fee, you must give the recipients all the rights that
you have.  You must make sure that they, too, receive or can get the
source code.  And you must show them these terms so they know their
rights.

   We protect your rights with two steps: (1) copyright the software,
and (2) offer you this license which gives you legal permission to copy,
distribute and/or modify the software.

   Also, for each author's protection and ours, we want to make certain
that everyone understands that there is no warranty for this free
software.  If the software is modified by someone else and passed on, we
want its recipients to know that what they have is not the original, so
that any problems introduced by others will not reflect on the original
authors' reputations.

   Finally, any free program is threatened constantly by software
patents.  We wish to avoid the danger that redistributors of a free
program will individually obtain patent licenses, in effect making the
program proprietary.  To prevent this, we have made it clear that any
patent must be licensed for everyone's free use or not licensed at all.

   The precise terms and conditions for copying, distribution and
modification follow.

    TERMS AND CONDITIONS FOR COPYING, DISTRIBUTION AND MODIFICATION
  0. This License applies to any program or other work which contains a
     notice placed by the copyright holder saying it may be distributed
     under the terms of this General Public License.  The "Program",
     below, refers to any such program or work, and a "work based on
     the Program" means either the Program or any derivative work under
     copyright law: that is to say, a work containing the Program or a
     portion of it, either verbatim or with modifications and/or
     translated into another language.  (Hereinafter, translation is
     included without limitation in the term "modification".)  Each
     licensee is addressed as "you".

     Activities other than copying, distribution and modification are
     not covered by this License; they are outside its scope.  The act
     of running the Program is not restricted, and the output from the
     Program is covered only if its contents constitute a work based on
     the Program (independent of having been made by running the
     Program).  Whether that is true depends on what the Program does.

  1. You may copy and distribute verbatim copies of the Program's
     source code as you receive it, in any medium, provided that you
     conspicuously and appropriately publish on each copy an appropriate
     copyright notice and disclaimer of warranty; keep intact all the
     notices that refer to this License and to the absence of any
     warranty; and give any other recipients of the Program a copy of
     this License along with the Program.

     You may charge a fee for the physical act of transferring a copy,
     and you may at your option offer warranty protection in exchange
     for a fee.

  2. You may modify your copy or copies of the Program or any portion
     of it, thus forming a work based on the Program, and copy and
     distribute such modifications or work under the terms of Section 1
     above, provided that you also meet all of these conditions:

       a. You must cause the modified files to carry prominent notices
          stating that you changed the files and the date of any change.

       b. You must cause any work that you distribute or publish, that
          in whole or in part contains or is derived from the Program
          or any part thereof, to be licensed as a whole at no charge
          to all third parties under the terms of this License.

       c. If the modified program normally reads commands interactively
          when run, you must cause it, when started running for such
          interactive use in the most ordinary way, to print or display
          an announcement including an appropriate copyright notice and
          a notice that there is no warranty (or else, saying that you
          provide a warranty) and that users may redistribute the
          program under these conditions, and telling the user how to
          view a copy of this License.  (Exception: if the Program
          itself is interactive but does not normally print such an
          announcement, your work based on the Program is not required
          to print an announcement.)

     These requirements apply to the modified work as a whole.  If
     identifiable sections of that work are not derived from the
     Program, and can be reasonably considered independent and separate
     works in themselves, then this License, and its terms, do not
     apply to those sections when you distribute them as separate
     works.  But when you distribute the same sections as part of a
     whole which is a work based on the Program, the distribution of
     the whole must be on the terms of this License, whose permissions
     for other licensees extend to the entire whole, and thus to each
     and every part regardless of who wrote it.

     Thus, it is not the intent of this section to claim rights or
     contest your rights to work written entirely by you; rather, the
     intent is to exercise the right to control the distribution of
     derivative or collective works based on the Program.

     In addition, mere aggregation of another work not based on the
     Program with the Program (or with a work based on the Program) on
     a volume of a storage or distribution medium does not bring the
     other work under the scope of this License.

  3. You may copy and distribute the Program (or a work based on it,
     under Section 2) in object code or executable form under the terms
     of Sections 1 and 2 above provided that you also do one of the
     following:

       a. Accompany it with the complete corresponding machine-readable
          source code, which must be distributed under the terms of
          Sections 1 and 2 above on a medium customarily used for
          software interchange; or,

       b. Accompany it with a written offer, valid for at least three
          years, to give any third party, for a charge no more than your
          cost of physically performing source distribution, a complete
          machine-readable copy of the corresponding source code, to be
          distributed under the terms of Sections 1 and 2 above on a
          medium customarily used for software interchange; or,

       c. Accompany it with the information you received as to the offer
          to distribute corresponding source code.  (This alternative is
          allowed only for noncommercial distribution and only if you
          received the program in object code or executable form with
          such an offer, in accord with Subsection b above.)

     The source code for a work means the preferred form of the work for
     making modifications to it.  For an executable work, complete
     source code means all the source code for all modules it contains,
     plus any associated interface definition files, plus the scripts
     used to control compilation and installation of the executable.
     However, as a special exception, the source code distributed need
     not include anything that is normally distributed (in either
     source or binary form) with the major components (compiler,
     kernel, and so on) of the operating system on which the executable
     runs, unless that component itself accompanies the executable.

     If distribution of executable or object code is made by offering
     access to copy from a designated place, then offering equivalent
     access to copy the source code from the same place counts as
     distribution of the source code, even though third parties are not
     compelled to copy the source along with the object code.

  4. You may not copy, modify, sublicense, or distribute the Program
     except as expressly provided under this License.  Any attempt
     otherwise to copy, modify, sublicense or distribute the Program is
     void, and will automatically terminate your rights under this
     License.  However, parties who have received copies, or rights,
     from you under this License will not have their licenses
     terminated so long as such parties remain in full compliance.

  5. You are not required to accept this License, since you have not
     signed it.  However, nothing else grants you permission to modify
     or distribute the Program or its derivative works.  These actions
     are prohibited by law if you do not accept this License.
     Therefore, by modifying or distributing the Program (or any work
     based on the Program), you indicate your acceptance of this
     License to do so, and all its terms and conditions for copying,
     distributing or modifying the Program or works based on it.

  6. Each time you redistribute the Program (or any work based on the
     Program), the recipient automatically receives a license from the
     original licensor to copy, distribute or modify the Program
     subject to these terms and conditions.  You may not impose any
     further restrictions on the recipients' exercise of the rights
     granted herein.  You are not responsible for enforcing compliance
     by third parties to this License.

  7. If, as a consequence of a court judgment or allegation of patent
     infringement or for any other reason (not limited to patent
     issues), conditions are imposed on you (whether by court order,
     agreement or otherwise) that contradict the conditions of this
     License, they do not excuse you from the conditions of this
     License.  If you cannot distribute so as to satisfy simultaneously
     your obligations under this License and any other pertinent
     obligations, then as a consequence you may not distribute the
     Program at all.  For example, if a patent license would not permit
     royalty-free redistribution of the Program by all those who
     receive copies directly or indirectly through you, then the only
     way you could satisfy both it and this License would be to refrain
     entirely from distribution of the Program.

     If any portion of this section is held invalid or unenforceable
     under any particular circumstance, the balance of the section is
     intended to apply and the section as a whole is intended to apply
     in other circumstances.

     It is not the purpose of this section to induce you to infringe any
     patents or other property right claims or to contest validity of
     any such claims; this section has the sole purpose of protecting
     the integrity of the free software distribution system, which is
     implemented by public license practices.  Many people have made
     generous contributions to the wide range of software distributed
     through that system in reliance on consistent application of that
     system; it is up to the author/donor to decide if he or she is
     willing to distribute software through any other system and a
     licensee cannot impose that choice.

     This section is intended to make thoroughly clear what is believed
     to be a consequence of the rest of this License.

  8. If the distribution and/or use of the Program is restricted in
     certain countries either by patents or by copyrighted interfaces,
     the original copyright holder who places the Program under this
     License may add an explicit geographical distribution limitation
     excluding those countries, so that distribution is permitted only
     in or among countries not thus excluded.  In such case, this
     License incorporates the limitation as if written in the body of
     this License.

  9. The Free Software Foundation may publish revised and/or new
     versions of the General Public License from time to time.  Such
     new versions will be similar in spirit to the present version, but
     may differ in detail to address new problems or concerns.

     Each version is given a distinguishing version number.  If the
     Program specifies a version number of this License which applies
     to it and "any later version", you have the option of following
     the terms and conditions either of that version or of any later
     version published by the Free Software Foundation.  If the Program
     does not specify a version number of this License, you may choose
     any version ever published by the Free Software Foundation.

 10. If you wish to incorporate parts of the Program into other free
     programs whose distribution conditions are different, write to the
     author to ask for permission.  For software which is copyrighted
     by the Free Software Foundation, write to the Free Software
     Foundation; we sometimes make exceptions for this.  Our decision
     will be guided by the two goals of preserving the free status of
     all derivatives of our free software and of promoting the sharing
     and reuse of software generally.

                                NO WARRANTY
 11. BECAUSE THE PROGRAM IS LICENSED FREE OF CHARGE, THERE IS NO
     WARRANTY FOR THE PROGRAM, TO THE EXTENT PERMITTED BY APPLICABLE
     LAW.  EXCEPT WHEN OTHERWISE STATED IN WRITING THE COPYRIGHT
     HOLDERS AND/OR OTHER PARTIES PROVIDE THE PROGRAM "AS IS" WITHOUT
     WARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING, BUT
     NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
     FITNESS FOR A PARTICULAR PURPOSE.  THE ENTIRE RISK AS TO THE
     QUALITY AND PERFORMANCE OF THE PROGRAM IS WITH YOU.  SHOULD THE
     PROGRAM PROVE DEFECTIVE, YOU ASSUME THE COST OF ALL NECESSARY
     SERVICING, REPAIR OR CORRECTION.

 12. IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN
     WRITING WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MAY
     MODIFY AND/OR REDISTRIBUTE THE PROGRAM AS PERMITTED ABOVE, BE
     LIABLE TO YOU FOR DAMAGES, INCLUDING ANY GENERAL, SPECIAL,
     INCIDENTAL OR CONSEQUENTIAL DAMAGES ARISING OUT OF THE USE OR
     INABILITY TO USE THE PROGRAM (INCLUDING BUT NOT LIMITED TO LOSS OF
     DATA OR DATA BEING RENDERED INACCURATE OR LOSSES SUSTAINED BY YOU
     OR THIRD PARTIES OR A FAILURE OF THE PROGRAM TO OPERATE WITH ANY
     OTHER PROGRAMS), EVEN IF SUCH HOLDER OR OTHER PARTY HAS BEEN
     ADVISED OF THE POSSIBILITY OF SUCH DAMAGES.

                      END OF TERMS AND CONDITIONS
How to Apply These Terms to Your New Programs
=============================================

If you develop a new program, and you want it to be of the greatest
possible use to the public, the best way to achieve this is to make it
free software which everyone can redistribute and change under these
terms.

   To do so, attach the following notices to the program.  It is safest
to attach them to the start of each source file to most effectively
convey the exclusion of warranty; and each file should have at least
the "copyright" line and a pointer to where the full notice is found.

     ONE LINE TO GIVE THE PROGRAM'S NAME AND AN IDEA OF WHAT IT DOES.
     Copyright (C) 19YY  NAME OF AUTHOR

     This program is free software; you can redistribute it and/or
     modify it under the terms of the GNU General Public License
     as published by the Free Software Foundation; either version 2
     of the License, or (at your option) any later version.

     This program is distributed in the hope that it will be useful,
     but WITHOUT ANY WARRANTY; without even the implied warranty of
     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
     GNU General Public License for more details.

     You should have received a copy of the GNU General Public License along
     with this program; if not, write to the Free Software Foundation, Inc.,
     59 Temple Place, Suite 330, Boston, MA 02111-1307, USA.

   Also add information on how to contact you by electronic and paper
mail.

   If the program is interactive, make it output a short notice like
this when it starts in an interactive mode:

     Gnomovision version 69, Copyright (C) 19YY NAME OF AUTHOR
     Gnomovision comes with ABSOLUTELY NO WARRANTY; for details
     type `show w'.  This is free software, and you are welcome
     to redistribute it under certain conditions; type `show c'
     for details.

   The hypothetical commands `show w' and `show c' should show the
appropriate parts of the General Public License.  Of course, the
commands you use may be called something other than `show w' and `show
c'; they could even be mouse-clicks or menu items--whatever suits your
program.

   You should also get your employer (if you work as a programmer) or
your school, if any, to sign a "copyright disclaimer" for the program,
if necessary.  Here is a sample; alter the names:

     Yoyodyne, Inc., hereby disclaims all copyright
     interest in the program `Gnomovision'
     (which makes passes at compilers) written
     by James Hacker.

     SIGNATURE OF TY COON, 1 April 1989
     Ty Coon, President of Vice

   This General Public License does not permit incorporating your
program into proprietary programs.  If your program is a subroutine
library, you may consider it more useful to permit linking proprietary
applications with the library.  If this is what you want to do, use the
GNU Library General Public License instead of this License.


File: bison-ja.info,  Node: Concepts,  Next: Examples,  Prev: Copying,  Up: Top

1 Bisonの概念
*************

この章では、Bisonの詳細を理解するのに欠くことのできない、
多くの基礎概念を説明します。 まだBisonやyaccの使い方を知らない方は、
この章を注意深く読むことから始めてください。

* Menu:

* Language and Grammar::  数学の発想と同じ、言語と文脈に依存しない文法.
* Grammar in Bison::  Bisonのために文法を表現する方法.
* Semantic Values::   それぞれのトークンや文法グループは意味値
                        （整数の値、識別子の名前、など。）
                         を取ることができる.
* Semantic Actions::  それぞれの規則はCコードを含んだアクションを持つこ
                        とができる.
* Bison Parser::      Bisonの入力と出力な何で、出力はどのように使われる
                       か。
* Stages::            Bisonの文法を書いて実行させる手順.
* Grammar Layout::    Bison文法ファイルの全体の構造.


File: bison-ja.info,  Node: Language and Grammar,  Next: Grammar in Bison,  Up: Concepts

1.1 言語と文脈自由文法
======================

Bisonが言語を解析するためには、その言語が "文脈自由文法（context-free
grammar）"で記述されている必要があります。
すなわち、1個以上の"文法グループ（syntactic groupings）"を定め、
その文法グループを部品から組み立てる規則を与える必要があります。
たとえば、C言語では、ある種のグループは「式」と呼ばれます。
式を作る規則の1つは、
「1つの式とは、別の式にマイナス記号を付けたものでもよい」かもしれません。
別の規則は、「1つの式とは、整数でもよい」かもしれません。
ここから解るように、規則はしばしば再帰的になりますが、
再帰を始めるための少なくとも1個の規則が必要です。

このような規則を人間が読めるように表現する、もっとも一般的な形式的な方法は、
"バッカス-ナウア記法（Backus-Naur form）"略して"BNF"です。
これは、Algol 60言語を定義するために開発されました。
BNFで表現された任意の言語は、文脈自由言語です。
Bisonへの入力は、本質的には、機械可読なBNFです。

   すべての文脈自由言語をBisonで扱えるわけではありません。
LALR(1)だけを扱えます。
簡単に説明すると、ちょうど1個のトークンを先読みすることによって、
入力文字列の任意の部分を解析できる必要があるということです。
厳密に説明すると、これはLR(1)文法の説明で、
LALR(1)には簡単に説明できない追加の制限があります。
しかし、LALR(1)になれないLR(1)文法は、現実にはまれです。
より詳しい説明は *Note Mysterious Reduce/Reduce Conflicts: Mystery
Conflicts。

   ある言語についての形式文法的な規則では、
文法的な単位またはグループを"記号（symbol）"と呼びます。
文法規則に従って小さい部分から組み立てられた記号を
"非終端記号（nonterminal symbol）"といい、 "終端記号（terminal
symbol）"または"トークン型（token type）"と呼ばれる ものに分解できます。
本書では、1個の終端記号に対応する入力の一部分を"トークン（token）"、
1個の非終端記号に対応する入力の一部分を"グループ（grouping）"と呼びます。

   何が終端記号で何が非終端記号かを示すために、
例としてC言語を使います。
Cのトークンは、識別子、定数（数値または文字列）、さまざまな予約語、
算術演算子、区切り記号です。
C言語の終端記号には、「識別子」、「数値」、「文字列」、そして、
予約語、演算子、区切り記号のそれぞれに対する記号、
すなわち、「if」、「return」、「const」、「static」、「int」、「char」、
「プラス記号」、「開きブレース」、「閉じブレース」、「カンマ」、
などが含まれます （これらのトークンは文字に分解できますが、
それは文法の問題ではなく、字句解析の問題です）。

   次の例は、トークンに分解されたCの関数です。

     int             /* 予約語 `int' */
     square (x)      /* 識別子, 開きかっこ, */
                     /* 識別子, 閉じかっこ */
          int x;     /* 予約語 `int', 識別子, セミコロン */
     {               /* 開きブレース */
       return x * x; /* 予約語 `return', 識別子, */
                     /* アスタリスク, 識別子, セミコロン */
     }               /* 閉じブレース */

   Cの文法的なグループには、式、文、宣言、関数定義が含まれます。
これらは、Cの文法で、非終端記号、「式」、「文」、「宣言」、
「関数定義」として表されます。
完全な文法では、上記の4つの意味を表現するために、
それぞれの非終端記号について、数十個の追加の言語構築が必要です。
上記の例で、関数定義は、宣言と文を含みます。
文の中で、それぞれの`x'は式であり、 `x * x'も式です。

それぞれの非終端記号には、それがより単純な構成要素からどのように作られるか
示すために、文法規則が必要です。
たとえば、Cの文の1つである`return'文について、
文法規則を形式ばらずに書くと、次のようになります。

     「文」は、キーワード「`return'」、「式」、「セミコロン」から
     作ることができる。

Cの各種の文について、「文」には多くの他の規則があるでしょう。

   1つの非終端記号が、言語の全体を表現するように、
特別なものとして識別される必要があります。 これを"開始記号（start
symbol）"と呼びます。
コンパイラでは、これは完全な入力プログラムを意味します。
C言語では、非終端記号「定義と宣言の並び」が、この働きをします。

   たとえば、`1 + 2'は有効なCの式で、
Cのプログラムの有効な一部分ですが、 Cプログラム_全体_としては無効です。
したがって、Cの文脈自由文法では、「式」は開始記号でないとわかります。

   Bison構文解析器は、入力としてトークンの列を読み、
文法規則を使ってトークンをグループにします。
もし入力が有効であれば、最終的な結果として、トークンの列全体が
文法の開始記号である1つのグループの記号に還元されます。
もしわれわれがCの文法を使うならば、入力全体は
「定義と宣言の列」の必要があります。
もしそうでなければ、構文解析器が文法エラーを報告します。


File: bison-ja.info,  Node: Grammar in Bison,  Next: Semantic Values,  Prev: Language and Grammar,  Up: Concepts

1.2 形式規則からBisonの入力へ
=============================

形式文法（formal grammer）は、数学的な構成です。
Bisonのために言語を定義するためには、Bisonの書式で文法を記述した
"Bison文法（Bison grammer）"ファイルを書く必要があります。 *Note Bison
Grammar Files: Grammar File。

   形式文法の中での1つの非終端記号は、Bisonの入力の中で、
Cの識別子のような、1つの識別子として表現されます。
`expr'、`stmt'、`declaration'のように、
通常、非終端記号は小文字で書きます。

   終端記号に対するBisonの表現は、 "トークン型（token
type）"ともいいます。
トークン型は、C言語で使われるような識別子であるかもしれません。
通常、非終端記号からこれらを区別するために、大文字で書きます。
たとえば、`INTEGER'、`IDENTIFIER'、`IF'、`RETURN' のように書きます。
言語の個々のキーワードを表す終端記号は、
キーワードを大文字に変換してから命名するべきです。 終端記号`error'は、エラーからの回復処理のために予約されています。
*Note Symbols::。

   ある終端記号は、C言語の文字定数のような、1文字リテラルを表している
かもしれません。
トークンがちょうど1文字である（たとえば、かっこ、プラス記号など）ならば必ず、
そのトークンに対する終端記号として、同じ文字を使うべきです。

   終端記号を表す第3の方法は、何文字かを含むC言語の文字列定数です。
詳細は*Note Symbols::。

   文法規則は、Bisonの文法の中で、もう1つの式を持ちます。
たとえば、C言語の`return'文に対するBisonの規則があります。
クォート（'）で囲まれたセミコロンは、文に対するC言語の文法の一部分を表す、
1文字のリテラルトークンです。
クォートで囲まれていないセミコロンとコロンは、
あらゆる規則の中で使われる、Bisonの区切り文字です。

     stmt:   RETURN expr ';'
             ;

*Note Syntax of Grammar Rules: Rules。


File: bison-ja.info,  Node: Semantic Values,  Next: Semantic Actions,  Prev: Grammar in Bison,  Up: Concepts

1.3 意味値
==========

形式文法は、トークンを分類法に基づいてのみ、選びます。
たとえば、ある規則が`integer
constant'という終端記号について言及するならば、
それは、文法的にそこに現れてよい_任意の_整数型定数を意味します。
その定数の正確な値は、入力が解析される方法と無関係です。
もし、`x+4'が文法的に正しいならば、`x+1'も、`x+3989'も、
同様に文法的に正しいのです。

しかし、いったん解析されれば、入力にとって正確な値はきわめて重要です。
プログラム中の定数として4と1と3989を区別できないコンパイラは、
役に立ちません。
そこで、Bison文法の中のそれぞれのトークンは、トークン型のほかに、
"意味値（semantic value）"を持ちます。詳細については、 *Note Defining
Language Semantics: Semantics。

   トークン型は、`INTEGER'、`IDENTIFIER'、`',''のように、
文法の中で定義される終端記号です。
これは、そのトークンが正しい位置に現れているか確かめ、
他のトークンとどのようにグループ化するか決めるために必要な、
すべての情報を含んでいます。
文法規則は、トークンの型以外の何も知りません。

意味値は、トークンに関する、たとえば、整数の値や識別子の名前のような、
トークン型以外のあらゆる情報を持っています
（`',''のような区切り記号であるトークンは、
意味値を持つ必要がありません）。

   たとえば、ある入力されたトークンは、トークン型が`INTEGER'で、
意味値が4であると分類されるかもしれません。
別の入力されたトークンは、同じ`INTEGER'型で、
値が3989であるかもしれません。 文法規則が`INTEGER'の出現を許すのならば、
どちらのトークンも`INTEGER'型なので、受け入れられます。
構文解析器は、トークンを受け入れるときに、その意味値を記憶します。

それぞれのグループ化は、それに対応する非終端記号とともに、意味値を持てます。
たとえば、電卓の中では、1つの式は、通常、数値である意味値を持ちます。
プログラミング言語のコンパイラの中では、1つの式は、通常、
式の意味を表す木構造の意味値を持ちます。


File: bison-ja.info,  Node: Semantic Actions,  Next: Bison Parser,  Prev: Semantic Values,  Up: Concepts

1.4 意味アクション
==================

役に立つようにするためには、プログラムは、入力を解析するだけでなく、
入力に基づくなんらかの出力を生成する必要があります。
Bison文法の中では、文法規則は、
Cで書かれた"アクション（action）"を持てます。
そのルールへのマッチを構文解析器が認識するたびに、アクションが実行されます。
*Note Actions::

   多くの場合に、アクションの目的は、部品の意味値から全体の意味値を
計算することです。
たとえば、1つの式とは2つの式の和でありうると仮定します。
構文解析器が和を認識すると、
部分式それぞれは、それがどのように構成されたかを表す意味値を持っています。
アクションは、新しく認識された合成式について、
同様の意味値を構成するべきです。

   以下に、1つの式が2つの部分式の和となる規則の例を示します。

     expr: expr '+' expr   { $$ = $1 + $3; }
             ;

   このアクションは、2個の部分式の値から、
式の和の意味値を生成する方法を示しています。


File: bison-ja.info,  Node: Bison Parser,  Next: Stages,  Prev: Semantic Actions,  Up: Concepts

1.5 Bisonの出力——構文解析器ファイル
=====================================

Bisonを使うときには、入力としてBison文法ファイルを指定します。
文法で記述された言語を解析する、Cのソースファイルが出力になります。
このファイルを"Bison構文解析器（Bison parser）"と呼びます。
BisonユーティリティとBison構文解析器は、
別のプログラムであることに注意してください。
Bisonユーティリティの出力がBison構文解析器で、
あなたのプログラムの一部分になるのです。

Bison構文解析器の仕事は、文法規則に従って、トークンをグループ化することです。
たとえば、識別子と演算子から式を組み立てます。
このために、文法規則に対応するアクションを実行します。

   トークンは、"字句解析器（lexical
analyzer）"と呼ばれる関数によって得られ、
その関数を（Cで書くような）なんらかの方法で与える必要があります。
Bison構文解析器は、新しいトークンを必要とするたびに、
字句解析器を呼び出します。
Bison構文解析器は、トークンの「内部」がなんであるか知りません
（しかし、トークンの意味値は関係します）。
一般に、字句解析器は、テキスト中の文字を解析してトークンを得ますが、
Bisonはその方法を知りません。 *Note The Lexical Analyzer Function
`yylex': Lexical。

   Bison構文解析器ファイルは、Cのプログラムで、`yyparse'という名前の、
文法を実装する関数を定義します。
この関数は、完全なCのプログラムを構成しません。
いくつかの関数を補ってやる必要があります。 1つは、字句解析器です。
もう1つは、エラーを報告するために構文解析器が呼び出す、
エラー報告関数です。
さらに、完全なCプログラムは`main'関数から実行を始める必要がありますので、
これを補って、そこから`yyparse'を呼び出してください。 *Note Parser
C-Language Interface: Interface。

   あなたが書くアクションの中でのトークンの型名と記号に関係なく、
Bison構文解析器の中で使われるすべての変数と関数の名前は、
`yy'または`YY'で始まります。
これは、字句解析関数`yylex'とエラー報告関数`yyerror'および
構文解析関数`yyparse'のようなインターフェイス関数も含みます。
また、内部で使われる多数の識別子も同様です。
したがって、本書で定義されている場合を除いて、
Bison文法ファイルの中で`yy'または`YY'で始まる
Cの識別子の利用は避けるべきです。


File: bison-ja.info,  Node: Stages,  Next: Grammar Layout,  Prev: Bison Parser,  Up: Concepts

1.6 Bisonを使う手順
===================

Bisonを使って、文法の定義から実際に動くコンパイラやインタープリタを作るまでの、
言語設計手順は、次のようになります。

  1. Bisonが認識できる形式で、文法を形式的に指定します （*note Bison
     Grammar Files: Grammar File.）。 言語の各文法規則に対して、
     その規則のインスタンスが認識されたときに実行される
     アクションを記述します。 アクションは、C言語の文の並びで書きます。

  2.
     入力を処理し、トークンを構文解析器に渡すために、字句解析器を書きます。
     字句解析器は、Cで手作業で書いてもかまいません （*note The Lexical
     Analyzer Function `yylex': Lexical.）。
     Lexを使って生成することも可能ですが、本書ではLexの使い方については解説
     していません。

  3. Bisonが生成した構文解析器を呼び出す、制御関数を書きます。

  4. エラー報告関数を書きます。


   このソースプログラムを実行可能なプログラムにするために、
次の手順が必要です。

  1. 構文解析器を生成するために、Bisonを実行します。

  2. Bisonが生成したソースプログラムとその他のソースプログラムを、
     コンパイルします。

  3. オブジェクトファイルをリンクして、最終的なプログラムを得ます。



File: bison-ja.info,  Node: Grammar Layout,  Prev: Stages,  Up: Concepts

1.7 Bison文法の全体像
=====================

Bisonユーティリティへの入力は、 "Bison文法ファイル（Bison grammar
file）"です。 Bison文法ファイルの一般的な書式は、次のとおりです。

     %{
     C惜言不（C DECLARATIONS）
     %}

     BISON惜言不（BISON DECLARATIONS）

     %%
     文法規則部（GRAMMAR RULES）
     %%
     追加のCプネグドダ不（ADDITIONAL C CODE）

   Bison文法ファイル中の`%%'、`%{'、`%}'は、
ファイルを節に分ける区切り記号です。

   "C宣言部"では、 アクションの中で使われる型と変数を定義できます。
マクロを定義するためのプリプロセッサディレクティブや、
ヘッダファイルをインクルードするための`#include'命令も使用できます。

   "Bison宣言部"には、終端記号、非終端記号、さらに、
演算子の優先順位、さまざまな記号の意味値のデータ型を記述できます。

   "文法規則部"では、各非終端記号をその部品から組み立てる方法を
定義します。

   "追加のCプログラム部"には、 あなたが望むCプログラムを記述できます。
よく字句解析関数`yylex'や
文法規則の中のアクションから呼ばれる関数をここに書きます。
単純なプログラムでは、(1)ここに 残りのプログラム全部を書きます。

   ---------- Footnotes ----------

   (1) 【訳注】他のファイルに書くのではなく


File: bison-ja.info,  Node: Examples,  Next: Grammar File,  Prev: Concepts,  Up: Top

2 例
****

本章では、Bison文法を使って書いた例を3つ示します。
逆ポーランド記法電卓、算術（中置）記法電卓、多機能電卓です。 すべてBSD
UNIX 4.3上でテストしました。
限定的ではありますが、対話的な電卓として利用可能です。

   これらの例は単純ですが、現実のプログラミング言語に対する
Bison文法も、書き方は同じです。

   これらの例をInfoファイルから取り出してソースファイルにコピーし、
試すことができます。

* Menu:

* RPN Calc::          逆ポーランド記法電卓;
                        演算子の優先順位が無い、最初の例.
* Infix Calc::        中間（代数）記法電卓.
                        演算子の優先順位が導入された.
* Simple Error Recovery::  構文エラーの後も続行する.
* Multi-function Calc::  メモリと三角関数付きの電卓.
                           意味値に複数のデータ型を使用する.
* Exercises::         多機能電卓を改善するための着想.


File: bison-ja.info,  Node: RPN Calc,  Next: Infix Calc,  Up: Examples

2.1 逆ポーランド記法電卓
========================

最初の例は、"逆ポーランド記法（reverse polish notation）"を使う
倍精度の電卓で、演算子を後に書きます。
この例は、演算子の優先順位の問題がないので、入門には適しています。
第2の例では、演算子の優先順位をどのように扱うかを示します。

   この電卓のソースファイルを`rpcalc.y'とします。
Bisonの入力ファイルには、通常`.y'という拡張子を付けます。

* Menu:

* Decls: Rpcalc Decls.  rpcalcのためのBisonとCの宣言.
* Rules: Rpcalc Rules.  rpcalcのための文法規則。説明付き.
* Lexer: Rpcalc Lexer.  字句解析器.
* Main: Rpcalc Main.    制御関数.
* Error: Rpcalc Error.  エラー報告関数.
* Gen: Rpcalc Gen.      文法ファイルでBisonを実行する.
* Comp: Rpcalc Compile. 出力コードにCコンパイラを実行する.


File: bison-ja.info,  Node: Rpcalc Decls,  Next: Rpcalc Rules,  Up: RPN Calc

2.1.1 `rpcalc'のための宣言
--------------------------

逆ポーランド記法電卓のためのCとBisonの宣言を示します。
Cと同様に`/*...*/'はコメントです。

     /* 逆ポーランド記法電卓 */

     %{
     #define YYSTYPE double
     #include <math.h>
     %}

     %token NUM

     %% /* 文法規則とアクションが続く */

   C宣言部（*note The C Declarations Section: C Declarations.）には、
2つのプリプロセッサディレクティブがあります。

   `#define'ディレクティブで、トークンとグループの意味値に対する
Cのデータ型を指定するために、マクロ`YYSTYPE'を定義します （*note Data
Types of Semantic Values: Value Type.）。
Bison構文解析器は、`YYSTYPE'に定義された型を使います。
定義しないと、`int'型が使用されます。
各トークンと式は、浮動小数点数である記録値を持つので、
ここでは`double'を指定します。

   べき乗関数`pow'の宣言を使うために、
`#include'ディレクティブを使っています。

第2の部、Bison宣言は、Bisonのためにトークン型についての情報を用意します
（*note The Bison Declarations Section: Bison Declarations.）。
1文字リテラルでない終端記号は、ここで宣言する必要があります
（通常、1文字のリテラルを宣言する必要はありません）。
この例では、すべての算術演算子が1文字リテラルなので、
数値定数に対するトークン型`NUM'だけを、 終端記号として宣言します。


File: bison-ja.info,  Node: Rpcalc Rules,  Next: Rpcalc Lexer,  Prev: Rpcalc Decls,  Up: RPN Calc

2.1.2 `rpcalc'のための文法規則
------------------------------

逆ポーランド記法電卓のための文法規則を示します。

     input:    /* 空 */
             | input line
     ;

     line:     '\n'
             | exp '\n'  { printf ("\t%.10g\n", $1); }
     ;

     exp:      NUM             { $$ = $1;         }
             | exp exp '+'     { $$ = $1 + $2;    }
             | exp exp '-'     { $$ = $1 - $2;    }
             | exp exp '*'     { $$ = $1 * $2;    }
             | exp exp '/'     { $$ = $1 / $2;    }
           /* べき乗関数 */
             | exp exp '^'     { $$ = pow ($1, $2); }
           /* 単項のマイナス    */
             | exp 'n'         { $$ = -$1;        }
     ;
     %%

   ここで定義されるrpcalc「言語」のグループは、
式（`exp'）と、入力行（`line'）と、 完全な入力の写し（`input'）です。
これらの非終端記号には、「論理和」という`|'記号で区切られた、
いくつかの規則があります。 以下の項で、これらの規則の意味を説明します。

言語の意味は、グループが認識されたときのアクションによって決まります。
アクションとは、ブレースで囲まれたCのプログラムです。 *Note Actions::。

   これらのアクションをCで書く必要がありますが、
Bisonには規則の間で意味値を受け渡しする方法があります。
それぞれのアクションで、擬似変数`$$'は、
その規則が構成しようとしているグループの意味値を示します。
`$$'に値を代入することが、アクションの主な仕事です。
規則の部品の意味値は、`$1'、`$2'などの 名前で参照されます。

* Menu:

* Rpcalc Input::
* Rpcalc Line::
* Rpcalc Expr::


File: bison-ja.info,  Node: Rpcalc Input,  Next: Rpcalc Line,  Up: Rpcalc Rules

2.1.2.1 `input'の説明
.....................

`input'の定義について考えます。

     input:    /* 空 */
             | input line
     ;

   この定義の意味は、「完全な入力とは、空文字列であるか、あるいは、
完全な入力に入力行が続いたものである」ということです。
「完全な入力」が、それ自身を使って定義されていることに注意してください。
列の中で`input'が常に左端の記号なので、 このような定義を"左再帰（left
recursive）"と呼びます。 *Note Recursive Rules: Recursion。

   最初の選択肢は、`:'と`|'の間に記号がないので空です。
これは、（トークンを含まない）空の入力文字列にマッチします。
電卓を起動した直後に`Ctrl-d' (1)を
押しても、正しい入力と扱われるように、この規則を入れました。
通常、空に対応する選択肢を最初に置き、そこに`/* 空 */'と 書きます。

   2つめの選択肢である規則（`input line'）は、
自明（空）でないすべての入力を扱います。
その意味は、「任意の数の行を読み込んだ後で、もし可能ならば、
もう1行読み込む」ということです。 左再帰が、この規則を繰り返しにします。
最初の選択肢が空の入力にマッチするので、
0回以上任意の回数の繰り返しになります。

   構文解析器関数`yyparse'は、文法エラーが発生するか、あるいは、
字句解析器がもうトークンがないと判定するまで、 入力の処理を続けます。
ファイルの終わりで起きることについては、後で考慮します。

   ---------- Footnotes ----------

   (1) 【訳注】UNIXの標準的なコンソールの
設定で、入力の終わりを示す制御文字で、MS-DOSでは代わりに`Ctrl-z'。


File: bison-ja.info,  Node: Rpcalc Line,  Next: Rpcalc Expr,  Prev: Rpcalc Input,  Up: Rpcalc Rules

2.1.2.2 `line'の説明
....................

次に、`line'の定義について考えます。

     line:     '\n'
             | exp '\n'  { printf ("\t%.10g\n", $1); }
     ;

   最初の選択肢は、改行文字であるトークンです。
これは、rpcalcが空行を受け入れ、それに対応するアクションがないので、
無視することを示します。 第2の選択肢は、式の後に改行が続いたものです。
これが、rpcalcを有用にする選択肢です。
問い合わせの中の`exp'が、この選択肢に現れる最初の記号なので、
`exp'グループの意味値は、`$1'の値です。
アクションは、問い合わされた計算の結果である、 この値を表示します。

   このアクションは、値を`$$'に代入しないので、例外的です。
したがって、`line'に対応する意味値は、初期化されず、
その値は予想できなくなります。
もし、その値が使われると、この仕様はバグになりますが、われわれはこの値を使い
ません。ユーザーが入力した行に対する値を表示したら、
その値はもはや必要ありません。


File: bison-ja.info,  Node: Rpcalc Expr,  Prev: Rpcalc Line,  Up: Rpcalc Rules

2.1.2.3 `expr'の説明
....................

`exp'グループは、いくつかの規則を持ち、
それぞれが式の種類に対応しています。
最初の規則は、数値そのものであるもっとも単純な式を処理します。
第2の規則は、2個の式に加算記号が続くような、加算式を処理します。
第3の規則は、減算式を処理する、といった具合です。

     exp:      NUM
             | exp exp '+'     { $$ = $1 + $2;    }
             | exp exp '-'     { $$ = $1 - $2;    }
             ...
             ;

   すべての`exp'規則をまとめるために`|'を使っていますが、
次のように別々に書くことも可能です。

     exp:      NUM ;
     exp:      exp exp '+'     { $$ = $1 + $2;    } ;
     exp:      exp exp '-'     { $$ = $1 - $2;    } ;
             ...

   規則のほとんどは、式の部品の値から式の値を計算するための、
アクションを持っています。
たとえば、加算のための規則では、`$1'は式の第1の部品を、
`$2'は式の第2の部品を表します。
第3の部品`'+''は、意味値には関連する情報を持ちませんが、
もし値を持っていれば、`$3'として参照できます。
`yyparse'がこの規則を使って加算式を認識すると、
式全体の値として、2個の部分式の値の和が生成されます。 *Note Actions::。

   すべての規則に対してアクションを書く必要はありません。
アクションを省略すると、Bisonは`$1'の値を`$$'に複写します。
第1の規則では、`NUM'の値をそのまま複写するために、
このようになっています。

   ここで示したリストは、望ましい書式ですが、
Bisonがこのように要求するわけではありません。
必要に応じて、空白、タブ、改行を置けます。 次のような書き方も可能です。

     exp   : NUM | exp exp '+' {$$ = $1 + $2; } | ...

   これは、次のリストと等価です。

     exp:      NUM
             | exp exp '+'    { $$ = $1 + $2; }
             | ...

   しかし、後者のほうが可読性が優れています。


File: bison-ja.info,  Node: Rpcalc Lexer,  Next: Rpcalc Main,  Prev: Rpcalc Rules,  Up: RPN Calc

2.1.3 `rpcalc'字句解析器
------------------------

字句解析器の仕事は、低水準の構文解析で、文字または文字列を
トークンに変換します。
Bison構文解析器は、字句解析器を呼び出してトークンを得ます。 *Note The
Lexical Analyzer Function `yylex': Lexical。

   RPN（逆ポーランド記法）電卓には、簡単な字句解析器のみが必要です。
この字句解析器は、空白とタブを読み飛ばし、
数値を読み込んで`double'型の`NUM'トークンとして返します。
数値の一部分ではないその他の文字は、独立のトークンです。
1文字トークンのトークン符号はその文字自身であることに注意してください。

   字句解析関数の戻り値は、トークン型を表す数値です。
Bison規則の中でトークン型を表すために使われる文字列と同じものが、
その型の数値符号を表すCの式でもあります。
これには、2種類の働きがあります。 もし、トークン型が文字リテラルならば、
その数値符号は文字のASCII符号であり、
数値を表すために字句解析器の中と同じ文字リテラルを使えます。
もし、トークン型が識別子ならば、適切な番号を定義するCのマクロとして、
その識別子がBisonによって定義されます。
したがって、この例では、`NUM'は、`yylex'のために使える
マクロにもなります。

   トークンの意味値は、もし存在すれば、大域変数`yylval'に記憶され、
Bison構文解析器はそこを見にいきます
（`yylval'のCデータ型は、文法の最初で定義される`YYSTYPE'です。 *note
Declarations for `rpcalc': Rpcalc Decls.）。

   ファイルの終わりに達すると、トークン型のコード0が返されます
（Bisonは、正でない任意の値を入力の終わりと認識します）。

   字句解析器のプログラムの例を示します。

     /*
      * 字句解析器は、数値を読めば、double型の値をスタックに積んで
      * トークン「NUM」を返し、数値以外を読めば、その文字のアスキー符号を返す。
      * 空白とタブは読み飛ばされる。ファイルが終わると0を返す。
      */

     #include <ctype.h>

     yylex ()
     {
       int c;

       /* 空白類を読み飛ばす  */
       while ((c = getchar ()) == ' ' || c == '\t')
         ;
       /* 数値を処理する   */
       if (c == '.' || isdigit (c))
         {
           ungetc (c, stdin);
           scanf ("%lf", &yylval);
           return NUM;
         }
       /* ファイルの終わりを処理する  */
       if (c == EOF)
         return 0;
       /* 1文字を返す */
       return c;
     }


File: bison-ja.info,  Node: Rpcalc Main,  Next: Rpcalc Error,  Prev: Rpcalc Lexer,  Up: RPN Calc

2.1.4 制御関数
--------------

この例の精神に則って、制御関数は、飾りのない最小限のものです。
唯一必要なことは、構文解析の処理を始めるために、
`yyparse'関数を呼び出すことです。

     main ()
     {
       yyparse ();
     }

   (1)

   ---------- Footnotes ----------

   (1)
【訳注】古いK&R-C処理系を使う場合には前述の例のままでよいのですが、
ANSI-C処理系を使う場合には、`main'関数が返す値が
`int'型なので、次のように書くべきです。
他の関数についても同様です。本書の例のすべては古い書式で書かれています。

     int main ()
     {
       return yyparse ();
     }


File: bison-ja.info,  Node: Rpcalc Error,  Next: Rpcalc Gen,  Prev: Rpcalc Main,  Up: RPN Calc

2.1.5 エラー報告関数
--------------------

`yyparse'は、構文エラーを検出すると、エラーメッセージ
（必ずそうとはかぎりませんが、通常は`"parse error"'）を
表示するために、エラー報告関数`yyerror'を呼び出します。

     #include <stdio.h>

     yyerror (s)  /* エラーが起きるとyyparseから呼び出される */
          char *s;
     {
       printf ("%s\n", s);
     }

   `yyerror'から戻った後に、Bison構文解析器は、
文法に適切なエラー規則（*note Error Recovery::）があれば、
エラーから回復し、解析を継続できます。
そうでない場合には、`yyparse'が0でない値を返します。
この例では、エラー規則を書いていないので、
不正な入力はすべて電卓プログラムを終了させます。
これは、実際の電卓としてはきれいな動作ではありませんが、
最初の例としては十分です。


File: bison-ja.info,  Node: Rpcalc Gen,  Next: Rpcalc Compile,  Prev: Rpcalc Error,  Up: RPN Calc

2.1.6 構文解析器を生成するためにBisonを実行
-------------------------------------------

構文解析器を生成するためにBisonを実行する前に、
1つ以上のソースファイルのすべてをどのように整えるか、
決める必要があります。
このような単純な例では、すべてを1個のファイルに詰め込む方法が
いちばん簡単です。 `yylex'、`yyerror'、`main'の定義を、
ファイルの「追加のCコード」部の最後に置きます （*note The Overall
Layout of a Bison Grammar: Grammar Layout.）。

   大きなプロジェクトでは、ソースコードを複数のファイルに分け、
まとめてリコンパイルするために`make'を使うでしょう。

   1つのファイルにすべてのソースが入っているならば、
次のコマンドで、それを構文解析器ファイルに変換できます。

     bison FILE_NAME.y

   この例では、ファイルは`rpcalc.y'（逆ポーランド記法電卓）と
呼ばれています。Bisonは、元のファイル名から`.y'を取り除いて、
`FILE_NAME.tab.c'というファイルを生成します。
Bisonが出力したファイルには、`yyparse'のソースコードが含まれています。
入力ファイル中の追加の関数（`yylex'、`yyerror'、`main'）は、
出力にそのまま複写されます。


File: bison-ja.info,  Node: Rpcalc Compile,  Prev: Rpcalc Gen,  Up: RPN Calc

2.1.7 構文解析器ファイルのコンパイル
------------------------------------

構文解析器ファイルをコンパイルする方法を示します。 (1)

     # カレントディレクトリのファイルの一覧を見る。
     % ls
     rpcalc.tab.c  rpcalc.y

     # Bison構文解析器をコンパイルする。
     # 数学ライブラリ内の`pow'関数をリンクするために`-lm'を指定する。
     % cc rpcalc.tab.c -lm -o rpcalc

     # 再び、ファイルの一覧を見る。
     % ls
     rpcalc  rpcalc.tab.c  rpcalc.y

   できた`rpcalc'ファイルは、実行可能プログラムです。
`rpcalc'を実行させる例を示します。

     % rpcalc
     4 9 +
     13
     3 7 + 3 4 5 *+-
     -13
     3 7 + 3 4 5 * + - n              単項マイナスを示す`n'に注意
     13
     5 6 / 4 n +
     -3.166666667
     3 4 ^                            べき乗関数
     81
     ^D                               入力の終わり
     %

   ---------- Footnotes ----------

   (1)
【訳注】UNIX上で`cc'コマンドを使ってコンパイルする方法を示します。


File: bison-ja.info,  Node: Infix Calc,  Next: Simple Error Recovery,  Prev: RPN Calc,  Up: Examples

2.2 中間記法電卓：`calc'
========================

後置記法演算子に代わって中間記法演算子を扱うように rpcalcを変更します。
中間記法には、演算子の優先順位の概念と、
適切な深さに入れ子できるかっこが必要です。
中間記法電卓を作るためのBisonソースファイル `calc.y'を示します。

     /* 中間記法電卓 -- calc */

     %{
     #define YYSTYPE double
     #include <math.h>
     %}

     /* BISON宣言 */
     %token NUM
     %left '-' '+'
     %left '*' '/'
     %left NEG     /* negation--単項マイナス */
     %right '^'    /* べき乗関数        */

     /* 文法規則が続く */
     %%
     input:    /* 空文字列 */
             | input line
     ;

     line:     '\n'
             | exp '\n'  { printf ("\t%.10g\n", $1); }
     ;

     exp:      NUM                { $$ = $1;         }
             | exp '+' exp        { $$ = $1 + $3;    }
             | exp '-' exp        { $$ = $1 - $3;    }
             | exp '*' exp        { $$ = $1 * $3;    }
             | exp '/' exp        { $$ = $1 / $3;    }
             | '-' exp  %prec NEG { $$ = -$2;        }
             | exp '^' exp        { $$ = pow ($1, $3); }
             | '(' exp ')'        { $$ = $2;         }
     ;
     %%

   `yylex'、`yyerror'、`main'関数は、 前の例のものと同じです。

   このプログラムには、2つの重要な特徴があります。

   第2の部分（Bison宣言部）では、
`%left'がトークンの型とそれが左結合演算子であると宣言します。
宣言`%left'と`%right'（右結合演算子）は、
結合性を持たないトークン型名を宣言するために使われる`%token'の代わりに
なります
（1文字のリテラルであるトークンは、通常、宣言する必要がありません。
ここでは、結合性を宣言します）。

   演算子の優先順位は、宣言が書かれる行の順序で決まります。
後から宣言された演算子ほど、高い優先順位を持ちます。
したがって、べき乗の優先順位がもっとも高く、
単項の負（`NEG'）、「`*'」と「`/'」と続きます。 *Note Operator
Precedence: Precedence。

   もう1つの重要な特徴は、単項の負の演算子のために文法部分にある
`%prec'です。 `%prec'は、単純にBisonに対して、規則`| '-' exp'は
`NEG'と同じ優先順位を持つように指示し、
この例ではどちらも2番目に高い優先順位を持ちます。

   以下は`calc.y'の実行例です。

     % calc
     4 + 4.5 - (34/(8*3+-3))
     6.880952381
     -56 + 2
     -54
     3 ^ 2
     9


File: bison-ja.info,  Node: Simple Error Recovery,  Next: Multi-function Calc,  Prev: Infix Calc,  Up: Examples

2.3 単純なエラー回復
====================

今まで、本書では、"エラー回復（error recovery）"、
つまり、構文エラーを検出した後で構文解析を続ける方法については
言及していませんでした。
今までに扱ったことは、`yyerror'を使ってエラーを報告することだけでした。
`yyerror'を呼び出した後で、特に指定しないと`yyparse'は
処理を終わることを思い出してください。
つまり、エラーを含む入力行が、電卓プログラムを終了させます。
この欠陥をどのように改善するか示しましょう。

   Bison言語の文法規則には、予約語`error'があります。
次の例では、`line'に対する選択肢群に`error'を追加する 方法を示します。

     line:     '\n'
             | exp '\n'   { printf ("\t%.10g\n", $1); }
             | error '\n' { yyerrok;                  }
     ;

   文法へのこの追加によって、構文解析エラーが発生した場合に、
簡単なエラー回復が可能になります。 評価不可能な式が読み込まれると、
`line'に対する第3の規則によってエラーが認識され、
構文解析が続けられます。 この場合にも、関数`yyerror'は呼び出され、
メッセージを表示します。 アクションは、
Bisonによって自動的に定義されるマクロである`yyerrok'文を実行します。
これはエラー回復の完了を意味します（*note Error Recovery::）。
`yyerrok'と`yyerror'の違いに注意してください。

   この形式のエラー回復は、構文エラーを扱います。
他の種類のエラーもあります。
たとえば、0による除算は、例外シグナルを発生し、通常は致命的です。
実際の電卓プログラムは、このシグナルをつかまえて、`longjmp'を使って
`main'に戻り、入力行の構文解析を続ける必要があります。
さらに、現在の入力行の残りは破棄されるべきです。
しかし、これらの問題は、Bisonのプログラムに固有の問題ではないので、
本書では解説しません。


File: bison-ja.info,  Node: Multi-function Calc,  Next: Exercises,  Prev: Simple Error Recovery,  Up: Examples

2.4 多機能電卓：`mfcalc'
========================

Bisonの基礎についての説明が終わったので、より高度な話題に移りましょう。
前述の電卓は、5種類の機能、`+'、`-'、`*'、`/'、 `^'を持っています。
この電卓に、その他の数学関数、たとえば、`sin'、`cos'などを
追加するとよいでしょう。

   中間記法電卓への新しい演算子の追加は、
その演算子が1文字リテラルならば簡単です。
字句解析器`yylex'は、数値以外のすべての文字をトークンとして渡すので、
追加の演算子に対応する文法規則を追加するだけです。
しかし、次のような表記方法の、より柔軟な組み込み関数が必要です。

     関尽名 (畏尽)

   さらに、電卓にメモリを追加し、名前付き変数を作り、そこに値を記憶し、
後で使えるようにしましょう。 以下に多機能電卓を使う作業の例を示します。

     % mfcalc
     pi = 3.141592653589
     3.1415926536
     sin(pi)
     0.0000000000
     alpha = beta1 = 2.3
     2.3000000000
     alpha
     2.3000000000
     ln(alpha)
     0.8329091229
     exp(ln(beta1))
     2.3000000000
     %

   複数の代入(1)と 関数の入れ子(2)が 許されることに注意してください。

* Menu:

* Decl: Mfcalc Decl.      多機能電卓のためのBisonの宣言.
* Rules: Mfcalc Rules.    電卓のための文法規則.
* Symtab: Mfcalc Symtab.  記号表を管理するサブルーチン.

   ---------- Footnotes ----------

   (1) 【訳注】例の`alpha = beta1 = 2.3'

   (2) 【訳注】例の`exp(ln(beta1))'


File: bison-ja.info,  Node: Mfcalc Decl,  Next: Mfcalc Rules,  Up: Multi-function Calc

2.4.1 `mfcalc'のための定義
--------------------------

以下には、多機能電卓のための、CとBisonの宣言があります。

     %{
     #include <math.h>  /* cos(), sin()などの数学関数のため */
     #include "calc.h"  /* `symrec'の定義を含む             */
     %}
     %union {
     double     val;    /* 数値を返すため                   */
     symrec  *tptr;     /* 記号表へのポインタを返すため     */
     }

     %token <val>  NUM        /* 単純な倍精度数値 */
     %token <tptr> VAR FNCT   /* 変数と関数       */
     %type  <val>  exp

     %right '='
     %left '-' '+'
     %left '*' '/'
     %left NEG     /* 否定 -- 単項の負 */
     %right '^'    /* べき乗           */

     /* 文法が続く */

     %%

   この文法の導入部分では、Bison言語の新しい2つの機能を使っています。
これらの機能によって、意味値がいろいろなデータ型を持てます （*note More
Than One Value Type: Multiple Types.）。

   `%union'宣言は、`YYSTYPE'の定義の代わりで、
可能な型の一覧を指定します。
ここで許される型は、（`exp'と`NUM'のための）倍精度浮動小数点型と、
記号表の項目へのポインタです。 *Note The Collection of Value Types:
Union Decl。

   値がいろいろな型を持つことができるので、
意味値を使うそれぞれの文法記号に対して、 型を関連づける必要があります。
これらの記号は`NUM'、`VAR'、`FNCT'、`exp'です。
それらの宣言は、不等号で囲まれた（`<...>'）データ型に関する
情報を付加されています。

   Bisonは、ちょうど`%token'がトークン型の宣言に使われるのと同じように、
`%type'が非終端記号の宣言に使われるようにします。
非終端記号は通常それらを定義する規則によって暗黙に宣言されるので、
`%type'をその規則よりも先に使ってはいけません。
しかし、`exp'は、その値の型を指定するので、
明示的に宣言する必要があります。 *Note Nonterminal Symbols: Type Decl。


File: bison-ja.info,  Node: Mfcalc Rules,  Next: Mfcalc Symtab,  Prev: Mfcalc Decl,  Up: Multi-function Calc

2.4.2 `mfcalc'のための文法規則
------------------------------

多機能電卓のための文法規則を示します。
大部分は、`calc'の文法規則からの複写です。
`VAR'、`FUNCT'に関連する3つの規則が新しいものです。

     input:   /* 空 */
             | input line
     ;

     line:
               '\n'
             | exp '\n'   { printf ("\t%.10g\n", $1); }
             | error '\n' { yyerrok;                  }
     ;

     exp:      NUM                { $$ = $1;                         }
             | VAR                { $$ = $1->value.var;              }
             | VAR '=' exp        { $$ = $3; $1->value.var = $3;     }
             | FNCT '(' exp ')'   { $$ = (*($1->value.fnctptr))($3); }
             | exp '+' exp        { $$ = $1 + $3;                    }
             | exp '-' exp        { $$ = $1 - $3;                    }
             | exp '*' exp        { $$ = $1 * $3;                    }
             | exp '/' exp        { $$ = $1 / $3;                    }
             | '-' exp  %prec NEG { $$ = -$2;                        }
             | exp '^' exp        { $$ = pow ($1, $3);               }
             | '(' exp ')'        { $$ = $2;                         }
     ;
     /* 文法の終わり */
     %%


File: bison-ja.info,  Node: Mfcalc Symtab,  Prev: Mfcalc Rules,  Up: Multi-function Calc

2.4.3 `mfcalc'の記号表
----------------------

変数と関数の名前と意味を保持するために、
多機能電卓は記号表を必要とします。
これは、アクションを除く文法規則とBison宣言には影響しませんが、
追加のCの関数がいくつか必要です。

   記号表は、レコードのリンクリストからなります。
その定義は、後述の、ヘッダファイル`calc.h'にあります。
関数と変数の両方を表に置くことができます。

     /* 記号表のリンクを表すデータ型                 */
     struct symrec
     {
       char *name;  /* 記号の名前                    */
       int type;    /* 記号の種類：VARまたはFNCT     */
       union {
         double var;           /* VARの値            */
         double (*fnctptr)();  /* FNCTの値           */
       } value;
       struct symrec *next;    /* 次の項目へのリンク */
     };

     typedef struct symrec symrec;

     /* `struct symrec'のリンクである記号表          */
     extern symrec *sym_table;

     symrec *putsym ();
     symrec *getsym ();

   新しい`main'関数は、記号表を初期化する関数である
`init_table'を呼びます。 `main'と`init_table'を以下に示します。

     #include <stdio.h>

     main ()
     {
       init_table ();
       yyparse ();
     }

     yyerror (s)  /* エラーがあるとyyparseから呼び出される */
          char *s;
     {
       printf ("%s\n", s);
     }

     struct init
     {
       char *fname;
       double (*fnct)();
     };

     struct init arith_fncts[]
       = {
           "sin", sin,
           "cos", cos,
           "atan", atan,
           "ln", log,
           "exp", exp,
           "sqrt", sqrt,
           0, 0
         };

     /* 記号表：`struct symrec'のリスト       */
     symrec *sym_table = (symrec *)0;

     init_table ()  /* 数学関数を表に登録する */
     {
       int i;
       symrec *ptr;
       for (i = 0; arith_fncts[i].fname != 0; i++)
         {
           ptr = putsym (arith_fncts[i].fname, FNCT);
           ptr->value.fnctptr = arith_fncts[i].fnct;
         }
     }

単純に初期化リストを編集して、必要なインクルードファイルを追加するだけで、
電卓に関数を追加できます。

   記号表に記号を登録して検索するために、2個の重要な関数があります。
関数`putsym'は、登録すべきオブジェクトの
名前と型（`VAR'や`FNCT'）を渡されます。
オブジェクトはリストの先頭にリンクされ、
オブジェクトへのポインタが返されます。
関数`getsym'は、検索すべき記号の名前を渡されます。
もし見つかれば記号へのポインタが返され、 見つからなければ0が返されます。

     symrec *
     putsym (sym_name,sym_type)
          char *sym_name;
          int sym_type;
     {
       symrec *ptr;
       ptr = (symrec *) malloc (sizeof (symrec));
       ptr->name = (char *) malloc (strlen (sym_name) + 1);
       strcpy (ptr->name,sym_name);
       ptr->type = sym_type;
       ptr->value.var = 0; /* 関数の場合にも値を0にする */
       ptr->next = (struct symrec *)sym_table;
       sym_table = ptr;
       return ptr;
     }

     symrec *
     getsym (sym_name)
          char *sym_name;
     {
       symrec *ptr;
       for (ptr = sym_table; ptr != (symrec *) 0;
            ptr = (symrec *)ptr->next)
         if (strcmp (ptr->name,sym_name) == 0)
           return ptr;
       return 0;
     }

   今度の関数`yylex'は、変数、数値、1文字の算術演算子を
認識する必要があります。
英字で始まり英数字からなる文字列は、記号表にどう書かれているかに応じて、
変数と関数のどちらとも認識されます。

   文字列は、記号表を検索するために`getsym'に渡されます。
もし名前が表にあれば、その場所へのポインタと
名前の型（`VAR'または`FNCT'）が、 `yyparse'に返されます。
名前がまだ表になければ、`putsym'を使って、 `VAR'として登録されます。
そして、ポインタと型（この場合には必ず`VAR'）が `yyparse'に返されます。

   `yylex'の中で、数値と算術演算子の扱いに関する部分は、
変更する必要がありません。

     #include <ctype.h>
     yylex ()
     {
       int c;

       /* 空白を読み飛ばし、空白以外を得る         */
       while ((c = getchar ()) == ' ' || c == '\t');

       if (c == EOF)
         return 0;

       /* 数値を読む   */
       if (c == '.' || isdigit (c))
         {
           ungetc (c, stdin);
           scanf ("%lf", &yylval.val);
           return NUM;
         }

       /* 識別子を読む */
       if (isalpha (c))
         {
           symrec *s;
           static char *symbuf = 0;
           static int length = 0;
           int i;

           /* バッファの長さの初期値は40文字       */
           if (length == 0)
             length = 40, symbuf = (char *)malloc (length + 1);

           i = 0;
           do
             {
               /* あふれたのでバッファを大きくする */
               if (i == length)
                 {
                   length *= 2;
                   symbuf = (char *)realloc (symbuf, length + 1);
                 }
               /* 文字をバッファに変える           */
               symbuf[i++] = c;
               /* 次の文字を読む                   */
               c = getchar ();
             }
           while (c != EOF && isalnum (c));

           ungetc (c, stdin);
           symbuf[i] = '\0';

           s = getsym (symbuf);
           if (s == 0)
             s = putsym (symbuf, VAR);
           yylval.tptr = s;
           return s->type;
         }

       /* その他の文字は文字リテラルトークン       */
       return c;
     }

   このプログラムは、強力かつ柔軟です。 新しい関数の追加は簡単です。
`pi'や`e'のようにあらかじめ定義された変数を追加するために
プログラムを変更することは、簡単な仕事でしょう。


File: bison-ja.info,  Node: Exercises,  Prev: Multi-function Calc,  Up: Examples

2.5 練習問題
============

  1. `math.h'にある関数のいくつかを、初期化リストに追加しなさい。

  2. 定数の名前と値を記憶する別の配列を追加しなさい。
     そして、`init_table'を変更し、定数を記号表に追加しなさい。
     定数に型`VAR'を与えれば簡単でしょう。

  3. 初期化されていない変数について、値を書き込むのではなく、
     値を使おうとするとエラーを報告するように、プログラムを改良しなさい。


File: bison-ja.info,  Node: Grammar File,  Next: Interface,  Prev: Examples,  Up: Top

3 Bison文法ファイル
*******************

Bisonは、文脈自由文法の仕様を入力として受け取り、
その文法の正しいインスタンスを認識する、 C言語の関数を生成します。

   Bison文法ファイルの名前は、通常`.y'で終わります。

* Menu:

* Grammar Outline::   文法ファイルの概略.
* Symbols::           終端記号と非終端記号.
* Rules::             文法規則の書き方.
* Recursion::         再帰的規則の書き方.
* Semantics::         意味値とアクション.
* Declarations::      全ての種類のBison宣言の説明.
* Multiple Parsers::  一つのプログラムに一つより多くのBison構文解析器を
                        入れる.


File: bison-ja.info,  Node: Grammar Outline,  Next: Symbols,  Up: Grammar File

3.1 Bison文法の概要
===================

Bison文法ファイルは4つの主要な部分からなります。
それらを、適切な区切り文字とともに示します。

     %{
     C惜言不（C DECLARATIONS）
     %}

     BISON惜言不（BISON DECLARATIONS）

     %%
     文法規則部（GRAMMAR RULES）
     %%

     追加のCプネグドダ不（ADDITIONAL C CODE）

   `/* ... */'で囲まれたコメントは、どの部分にも書けます。

* Menu:

* C Declarations::    C宣言部の構文と使用法.
* Bison Declarations::  Bison宣言部の構文と使用法.
* Grammar Rules::     文法規則部の構文と使用法.
* C Code::            追加のCコード部の構文と使用法.


File: bison-ja.info,  Node: C Declarations,  Next: Bison Declarations,  Up: Grammar Outline

3.1.1 C宣言部
-------------

"C宣言部（C declarations）"には、マクロ定義と、文法定義のアクションで
使うための関数と変数の宣言があります。
これらは、`yyparse'の定義に優先するように、構文解析器ファイルの最初に
複写されます。 ヘッダファイルから宣言を得るには`#include'を使います。
C宣言がまったく必要ない場合は、この部分を囲む `%{'と`%}'を省略できます。


File: bison-ja.info,  Node: Bison Declarations,  Next: Grammar Rules,  Prev: C Declarations,  Up: Grammar Outline

3.1.2 Bison宣言部
-----------------

"Bison宣言部（Bison declarations）"は、終端記号と非終端記号の宣言、
演算子の優先順位の指定などを含みます。
単純な例では、宣言を省略できます。 *Note Bison Declarations:
Declarations。


File: bison-ja.info,  Node: Grammar Rules,  Next: C Code,  Prev: Bison Declarations,  Up: Grammar Outline

3.1.3 文法規則部
----------------

"文法規則部（grammar rules）"は、1つ以上のBison文法規則を含み、
それ以外は含みません。 *Note Syntax of Grammar Rules: Rules。

   少なくとも1つの文法規則が存在する必要があります。
また、文法規則より先に`%%'が必要で、
もしそれ以前に何も記述されていなくても、省略できません。


File: bison-ja.info,  Node: C Code,  Prev: Grammar Rules,  Up: Grammar Outline

3.1.4 追加のCプログラム部
-------------------------

"追加のCプログラム部（additional C
code）"は、"C宣言部"が構文解析器ファイルの先頭に複写
されるのと同じように、構文解析器ファイルの末尾にそのまま複写されます。
構文解析器ファイル中に置く必要があって、
`yyparse'の定義よりも前に置く必要のないものを、ここに置くと便利です。
たとえば、`yylex'と`yyerror'の定義は、 よくここに置かれます。 *Note
Parser C-Language Interface: Interface。

   もし直前の部が空ならば、文法規則と区別するための `%%'を省略できます。

   Bison構文解析器は、名前が`yy'で始まる多くの静的変数と、
名前が`YY'で始まる多くのマクロを含んでいます。
本書で解説しているものを意図的に使う場合を除いて、
そのような名前を文法ファイルの追加のCプログラム部で使うのは避けるべきです。


File: bison-ja.info,  Node: Symbols,  Next: Rules,  Prev: Grammar Outline,  Up: Grammar File

3.2 記号、終端と非終端
======================

Bison文法の"記号（symbols）"は、 言語の文法的分類を表現します。

   "終端記号（terminal symbol）" （"トークン型（tokens
types）"ともいいます）は、 構文的に等価なトークンのクラスを表します。
そのクラスのトークンが許されることを表すために、
文法規則の中で記号を使えます。
その記号は、Bison構文解析器の中で番号で表現され、
`yylex'関数は、どのような種類のトークンが読み込まれたかを示すために、
トークン番号を返します。
これを表す記号を知っていればよく、その番号を知っている必要はありません。

   "非終端記号（nonterminal symbol）"は、
構文的に等価なグループを表現します。
記号名は文法規則の記述に使われます。
通常、非終端記号名を小文字で書きます。

記号名は、英字、先頭以外での数字、下線記号（`_'）とピリオドからなります。
ピリオド記号（`.'）は、非終端記号の名前には使えますが、
終端記号の名前には使えません。

   文法中で終端記号を記述するには3種類の方法があります。

   * "名前付きトークン型（named token type）"を、
     C言語における識別子と同様な、識別子とともに書きます。
     通常、大文字で書きます。
     これらは`%token'のようなBison宣言とともに定義する必要があります。
     *Note Token Type Names: Token Decl。

   * "文字トークン型（character token type）"、
     すなわち"リテラル文字トークン（literal character token）"は、
     C言語の文字定数と同じ構文で書かれ、
     たとえば`'+''は文字トークン型です。 意味値データ型（*note Data
     Types of Semantic Values: Value Type.）、 結合性、優先順位（*note
     Operator Precedence: Precedence.）を 指定する必要がなければ、
     文字トークン型を宣言する必要はありません。

     通常、文字トークン型は、特別な文字(1)から
     なるトークンを表すためだけに使います。
     たとえば、トークン型`'+''を、
     トークンとしての`+'文字を表すために使います。
     このようにする義務はありませんが、そうしないと、
     あなたが書いたプログラムを読む人が混乱するでしょう。

     C言語の文字リテラルで使われる通常のエスケープシーケンス
     (2)を、Bisonでも使えます。 しかし、`'\0''だけはASCII符号の0を表し、
     `yylex'がファイルの終わりを示す符号なので、
     文字リテラルとしては使えません （*note Calling Convention for
     `yylex': Calling Convention.）。

   * "リテラル文字列トークン（literal string token）"は、
     C言語における文字列定数と同様に書きます。
     たとえば、`"<="'がリテラル文字列トークンです。 意味値（*note Value
     Type::）、 結合性、優先順位（*note Operator Precedence:
     Precedence.）を 指定する必要がなければ、
     リテラル文字列トークンを宣言する必要はありません。

     `%token'宣言（*note Token Declarations: Token Decl.）を使って、
     リテラル文字列トークンを、記号名の別名として関連づけられます。
     そうしないと、字句解析器は、 `yytname'表（*note Calling
     Convention::）を使って、
     リテラル文字列トークンからトークン番号を検索する必要があります。

     *【警告】*`yacc'ではリテラル文字列トークンを使えません。

     通常、特殊文字の列からなるトークンの表現にのみ、
     リテラル文字列トークンを使います。
     たとえば、トークンとしての`<='を表すために、
     トークン型`"<="'を使うべきです。
     そうする義務はありませんが、そうしないと、
     あなたが書いたプログラムを読む人が混乱するでしょう。

     C言語で使えるエスケープシーケンスはすべてBisonでも使えます。
     リテラル文字列トークンは、2文字以上からなります。
     もし、トークンが1文字ならば、前述の1文字トークンを使ってください。

   終端記号を書く方法は、終端記号の文法的意味に関係なく、
規則の中に現れる位置と、 構文解析器関数が記号を返す方法に関係します。

   `yylex'が返す値は、終端記号のどれかを表し、 入力の終わりでは0です。
文法規則の中でどの方法でトークン型を書いても、
`yylex'を定義する書き方は同じです。
1文字トークン型に対する符号は、その文字のASCII符号なので、
`yylex'は必要な符号を生成するために同一の文字定数を使えます。
名前を付けられたトークン型はそれぞれ、
構文解析器ファイルの中でCのマクロになるので、
`yylex'は符号に対するマクロ名を使えます。
これが、終端記号の名前にピリオド記号を使えない理由です。 *Note Calling
Convention for `yylex': Calling Convention。

   `yylex'が構文解析器と別のソースファイルの中に書かれる場合には、
そこでトークン型マクロ定義を使えるように準備する必要があります。
`-d'オプションを付けてBisonを実行してください。
すると、マクロ定義が`NAME.tab.h'というファイルに書かれ、
必要に応じて別のソースファイルからインクルードできます。 *Note Invoking
Bison: Invocation。

   記号`error'は、エラー回復用に予約された終端記号（*note Error
Recovery::） で、他の目的に使うべきではありません。
実際に、`yylex'がこの値を返すことは決してありません。

   ---------- Footnotes ----------

   (1) 【訳注】英数字以外の文字。

   (2) 【訳注】`\'に続く表現。


File: bison-ja.info,  Node: Rules,  Next: Recursion,  Prev: Symbols,  Up: Grammar File

3.3 文法規則の構文
==================

Bison文法規則は、一般的に次の書式です。

     RESULT: COMPONENTS...
             ;

   RESULTは、この規則が記述する非終端記号で、
COMPONENTSは、この規則で一緒に置かれるさまざまな
終端および非終端記号です。 例を示します。

     exp:      exp '+' exp
             ;

   この例では、`+'トークンを間にはさんで
型`exp'の2つのグループ化が行われ、
型`exp'のより大きなグループができます。

   規則の中の空白(1)は、 記号を分けるだけの意味を持ちます。
必要に応じて、余分な空白を書いてもかまいません。

   COMPONENTSの周辺にあるものは、
規則の意味を決定するアクシデビ（ACTION）になることができます。
アクションは、次のようになります。

     {C STATEMENTS}

   通常、1つだけのアクションと、それに続くCOMPONENTSがあります。 *Note
Actions::。

   同一のRESULTに対する複数の規則は、 別々に書くこともできますし、
次の例のように縦線記号`|'で区切ってまとめて書くことも可能です。

     RESULT:   RULE1-COMPONENTS...
             | RULE2-COMPONENTS...
             ...
             ;

   まとめて書いても、それぞれの規則は別々のものとみなされます。

   もし、規則中のCOMPONENTSが空ならば、
RESULTが空の列にマッチできることを意味します。
例として、カンマで区切られた0個以上の`exp'のグループを
定義する方法を示します。

     expseq:   /* 空 */
             | expseq1
             ;

     expseq1:  exp
             | expseq1 ',' exp
             ;

   空のCOMPONENTを持つ規則には、通常 `/* 空 */'という注釈を書きます。

   ---------- Footnotes ----------

   (1) 【訳注】任意の数の空白文字、タブ符号、改行符号。


File: bison-ja.info,  Node: Recursion,  Next: Semantics,  Prev: Rules,  Up: Grammar File

3.4 再帰的規則
==============

RESULTである非終端記号が規則の右側にも現れる場合に、
その規則は"再帰的（recursive）"であるといいます。
Bison文法の大部分は再帰的規則を使います。
なぜならば、任意の数の並びを定義する唯一の方法が、
再帰的規則だからです。
1つ以上のカンマで区切られた式の並びの定義を考えてみましょう。

     expseq1:  exp
             | expseq1 ',' exp
             ;

`expseq1'で使われている再帰は、規則の右側の中でもっとも左側にあるので、
このような再帰を"左再帰（left recursion）"と呼びます。
逆に、同じ構造を"右再帰（right recursion）"を使って書いてみます。

     expseq1:  exp
             | exp ',' expseq1
             ;

   あらゆる並びを、左再帰を使っても、右再帰を使っても、定義できます。
しかし、限られたスタック容量で任意の数の並びを走査できるので、
つねに左再帰を使うべきです。
右再帰では、規則が適用される前にすべての要素をスタックに積む必要があるので、
要素の数に比例するスタック領域を消費します。 詳細については、*Note The
Bison Parser Algorithm: Algorithm。

   規則の結果が直接その右側には含まれず、
右側にある非終端記号の中に含まれるとき、
"間接（indirect）"すなわち"相互（mutual）"再帰が起きます。

   例を示します。

     expr:     primary
             | primary '+' primary
             ;

     primary:  constant
             | '(' expr ')'
             ;

   この例では、それぞれの規則が互いに参照しているので、
2個の相互再帰が定義されています。


File: bison-ja.info,  Node: Semantics,  Next: Declarations,  Prev: Recursion,  Up: Grammar File

3.5 言語の意味の定義
====================

言語に対する文法規則は、文法だけを決めます。
意味は、各種のトークンとグループ化に対応する意味値により、
各種のグループ化が認識されるときに、決定されます。

   電卓の例では、式のそれぞれに対応する値が適切な数値なので、
電卓は正確に計算できます。 グループ`X + Y'に
対応するアクションが、XとYに関する数値の和を計算します。

* Menu:

* Value Type::        全ての意味値に一つのデータ型を指定する.
* Multiple Types::    複数の別のデータ型を指定する.
* Actions::           アクションは文法規則の意味的定義.
* Action Types::      アクションが操作するデータ型を指定する.
* Mid-Rule Actions::  ほとんどのアクションは規則の最後に行く.
                      これは規則の最中で、いつ、なぜ、どのように
                        例外アクションを使用するかを指示する.


File: bison-ja.info,  Node: Value Type,  Next: Multiple Types,  Up: Semantics

3.5.1 データ型と意味値
----------------------

単純なプログラムでは、言語の要素のすべての意味値に対して同じデータ型を
使えば十分です。 逆ポーランド記法と中間記法電卓の例では、そうでした
（*note Reverse Polish Notation Calculator: RPN Calc.）。

   特に指定しないと、Bisonはすべての意味値に対して`int'型を使います。
他の型を使うには、次の例のように、マクロ`YYSTYPE'を定義します。

     #define YYSTYPE double

   このマクロ定義は、文法ファイルのC宣言部に置く必要があります （*note
Outline of a Bison Grammar: Grammar Outline.）。


File: bison-ja.info,  Node: Multiple Types,  Next: Actions,  Prev: Value Type,  Up: Semantics

3.5.2 複数の値型
----------------

多くのプログラムでは、異なる種類のトークンとグループに対して、
異なるデータ型が必要です。
たとえば、数値定数は`int'型や`long'型を必要とし、 文字列定数は`char
*'型を必要とし、 識別子は記号表の項目へのポインタを必要とするでしょう。

   同一の構文解析器内で、意味値に対して2つ以上のデータ型を使うには、
次の2項目が必要です。

   * Bison宣言の`%union'で、考えられるデータ型全体の集合を指定します
     （*note The Collection of Value Types: Union Decl.）。

   * 終端または非終端記号のそれぞれについて、
     その意味値を使うために、上記の型のどれか1つを選びます。
     トークンに対する型の指定には、Bison宣言の`%token'を使います
     （*note Token Type Names: Token Decl.）。
     グループ化に対する型の指定には、Bison宣言の`%type'を使います
     （*note Nonterminal Symbols: Type Decl.）。


File: bison-ja.info,  Node: Actions,  Next: Action Types,  Prev: Multiple Types,  Up: Semantics

3.5.3 アクション
----------------

文法規則にともなうアクションは、その規則が認識されるたびに実行される
Cのプログラムからなります。
アクションの仕事のほとんどは、関連するトークンまたは小さいグループから
規則にしたがって構成されるグループの、意味値の計算です。

   アクションは、Cの複文のように、ブレースで囲まれたCの文からなります。
アクションは、規則のどの場所にも置け、その場所で実行されます。
規則のほとんどは、規則の終わりの構成要素の並びの後に、
1つだけアクションを持ちます。
規則の途中に置かれたアクションは、手の込んだ方法で特別な目的に使われます
（*note Actions in Mid-Rule: Mid-Rule Actions.）。

   アクションの中のCで書かれたプログラムは、
規則の第N番目の要素に対応する意味値を、 `$N'という書式で参照できます。
また、その規則が構成するグループの意味値を、
`$$'という書式で参照できます。
アクションが構文解析器ファイルに複写されるときに、Bisonは、
上記の構成要素を配列要素への参照に変換します。

   例を示します。

     exp:    ...
             | exp '+' exp
                 { $$ = $1 + $3; }

   この規則は、加算記号で結び付けられた2つの小さい`exp'グループから、
1つの`exp'を構成します。 このアクションの中で、`$1'と`$3'は、
規則の右側の最初と3番目の記号である`exp'グループの 意味値を参照します。
この規則によって認識される加算式の値になるように、
和が`$$'に代入されます。 もし、`+'トークンに有用な値があるならば、
それを`$2'として参照できるでしょう。

   規則に対してアクションを指定しなければ、Bisonは、
省略時アクション`$$ = $1'を補います。
したがって、規則の最初の記号の値が規則全体の値になります。
もちろん、両者の型が一致する場合にのみ、省略時アクションは有効です。
空規則に対する省略時アクションは無意味です。
すべての空規則は、その規則の値が必要ならば、
明示的なアクションを持つ必要があります。

   `$N'のNは0または負が許され、
現在の規則にマッチする_前に_スタックに積まれていた
トークンとグループの意味値を参照します。
これは非常に危険な手法で、安全に使うためには、
その規則が適用される文脈をあなたが完全に理解している必要があります。
これを安全に使える例を示します。

     foo:      expr bar '+' expr  { ... }
             | expr bar '-' expr  { ... }
             ;

     bar:      /* 空 */
             { previous_expr = $0; }
             ;

   `bar'がここに書かれた方法でのみ使われるならば、
`foo'の定義の中で`bar'より前の `expr'の値を`$0'が参照します。


File: bison-ja.info,  Node: Action Types,  Next: Mid-Rule Actions,  Prev: Actions,  Up: Semantics

3.5.4 アクション中の値のデータ型
--------------------------------

すべての意味値に対して同一のデータ型を使っているのならば、
`$$'と`$N'はそのデータ型を持ちます。

   さまざまなデータ型を指定するために`%union'を使っているならば、
意味値を持つ終端記号と非終端記号のそれぞれに対して、
データ型の中から適切なものを選ぶように宣言する必要があります。
すると、`$$'と`N'を使うたびに、
規則の中でそれらがどの記号を参照するかに応じて、
データ型が決められます。 例を示します。

     exp:    ...
             | exp '+' exp
                 { $$ = $1 + $3; }

   `$1'と`$3'は`exp'という種類の記号を参照するので、
`$1'と`$3'は、非終端記号`exp'に対して宣言された データ型を持ちます。
もし、`$2'が使われるならば、どのような型であれ、
終端記号`+'に対して宣言されたデータ型が使われます。

   別の方法として、値を参照するときにそのデータ型を指定できます。
そのためには、参照のための`$'記号の後に`<TYPE>'を
挿入します。例を示します。

     %union {
       int itype;
       double dtype;
     }

   この場合に、`$<itype>1'と書けば、
最初の要素を`int'型として参照でき、`$<dtype>1'と書けば、
`double'型として参照できます。


File: bison-ja.info,  Node: Mid-Rule Actions,  Prev: Action Types,  Up: Semantics

3.5.5 規則の途中のアクション
----------------------------

まれに、アクションを規則の途中に置くと便利な場合があります。
これらのアクションは、通常の規則の終わりに置かれたアクションと同様に
記述されますが、構文解析器が後に続く要素を認識する前に実行されます。

   規則の途中のアクションは、そのアクションよりも前にある要素を
`$N'を使って参照できますが、後に続く要素は
まだ構文解析されていないので参照できません。

   規則の途中のアクション自身は、規則の要素の1つとして数えられます。
同じ規則の中に別のアクションが続く場合（通常は最後）に問題が起きます。
`$N'に使う番号Nに
規則の途中のアクションを数えるのを忘れないように注意してください。

   規則の途中のアクションは、意味値を持てます。
そのアクションは、`$$'への代入で値を定め、
後に続くアクションの中で、`$N'で値を参照できます。
アクションに記号名を対応させる方法がないので、
アクションのデータ型を宣言できません。
そこで、アクションの意味を参照するときに、
`$<...>'を使ってデータ型を指定する必要があります。

   規則の途中のアクションでは、`$$'への代入が規則の値に関係しないので、
規則全体の値を設定する方法はありません。
規則全体の値を設定する唯一の方法は、
規則の最後に置かれた通常のアクションです。

   架空のコンパイラの例を示します。 ここでは、`let (VARIABLE)
STATEMENT'のような書式の `let'文を使え、STATEMENTの持続期間中に一時的に
VARIABLEという名前の変数を作ります。
これを構文解析するために、STATEMENTを解析している間、
VARIABLEを記号表に置いておき、 後で記号表から削除する必要があります。
これを実現する方法を示します。

     stmt:   LET '(' var ')'
                     { $<context>$ = push_context ();
                       declare_variable ($3); }
             stmt    { $$ = $6;
                       pop_context ($<context>5); }

   `let (VARIABLE)'が認識されるとすぐに、
最初のアクションが実行されます。
そのアクションは、現在の意味文脈、すなわち参照可能な変数の表の複製を、
データ型共用体の中の`context'型で、 アクションの意味値として保存します。
そして、`declare_variable'を呼び出して、
新しい変数を記号表に追加します。
最初のアクションが終わると、後続する`stmt'の解析が可能になります。
規則の途中のアクションが5番目の要素であることに注意してください。
したがって、`stmt'は6番目の要素になります。

   後続する文が解析されると、その意味値が`let'文全体の意味値になります。
そして、最初のアクションの意味値は、
変数の表を元に戻すために使われます。
そこで、`let'文中での一時変数が表から削除され、
構文解析されるプログラムの残りの部分では一時変数が存在しません。

   構文解析器は、アクションを実行する順序を決めるために、
構文解析する必要があるので、
規則が完全に認識される前にアクションを実行することは、
しばしば不整合を起こします。
たとえば、後述の2個の規則は、規則の途中のアクションを持たないので、
実行可能な構文解析器の中で共存できます。
それは、構文解析器は開きブレーストークンをシフトでき、
宣言があるかどうか調べるために後に続くものを先読みできるからです。

     compound: '{' declarations statements '}'
             | '{' statements '}'
             ;

   しかし、次の例のように、規則の途中のアクションを加えると、
この規則は働かなくなります。

     compound: { prepare_for_local_variables (); }
               '{' declarations statements '}'
             | '{' statements '}'
             ;

   ここでは、開きブレースを見つけた時点で、
規則の途中のアクションを実行する必要があるかどうかの決定を迫られます。
言い換えれば、正しく判断するための十分な情報なしに、
ある規則か別の規則のどちらかにゆだねる必要があります。
開きブレーストークンは、これを読んだ時点では構文解析器が
何をすべきか決定する途中なので、"先読み（look-ahead）"トークンと
呼ばれます。*Note Look-Ahead Tokens: Look-Ahead。

   次のように同一のアクションを置くことで、
この問題を解決できるように思えるかもしれません。

     compound: { prepare_for_local_variables (); }
               '{' declarations statements '}'
             | { prepare_for_local_variables (); }
               '{' statements '}'
             ;

   しかし、Bisonには2つのアクションが同一であるかどうかわからないので、
問題は解決しません。 Bisonは、アクションの中のCで書かれたプログラムを、
決して解釈しようとしません。

   C言語のように、最初のトークンによって文と宣言を区別できるような
文法ならば、実現可能な解決方法の1つは、次の例のように、
開きブレースの後にアクションを置くことです。

     compound: '{' { prepare_for_local_variables (); }
               declarations statements '}'
             | '{' statements '}'
             ;

   これで、続く宣言または文の最初のトークンによって、
Bisonがどちらの規則を使うべきかわかります。

   別の解決方法は、サブルーチンとして働く非終端記号の内側に、
アクションを埋め込むことです。

     subroutine: /* 空 */
               { prepare_for_local_variables (); }
             ;

     compound: subroutine
               '{' declarations statements '}'
             | subroutine
               '{' statements '}'
             ;

   これで、Bisonは`compound'に対してどちらの規則を使うべきか決めずに、
`subroutine'に対する規則中のアクションを実行できます。
任意の規則中のアクションは、この方法によって、
規則の最後のアクションに変換できます。
実際に、Bisonの内部では、このようにして、
規則中のアクションという機能が実現されています。


File: bison-ja.info,  Node: Declarations,  Next: Multiple Parsers,  Prev: Semantics,  Up: Grammar File

3.6 Bison宣言
=============

Bison文法ファイルの"Bison宣言（Bison declarations）"部では、
文法の定式化に使う記号を定義し、意味値のデータ型を定義します。 *Note
Symbols::。

   `'+''や`'*''のような1文字リテラルトークンを除く
すべてのトークンの型名を宣言する必要があります。
非終端記号については、その意味値に対してどのデータ型を使うか
指定したければ、宣言する必要があります （*note More Than One Value
Type: Multiple Types.）。

   特に指定しないと、文法ファイル中の最初の規則は、
開始記号を特定します。
他の記号を開始記号にしたければ、明示的に宣言する必要があります （*note
Languages and Context-Free Grammars: Language and Grammar.）。

* Menu:

* Token Decl::        終端記号を宣言する.
* Precedence Decl::   優先順位と結合規則とともに終端を宣言する.
* Union Decl::        全ての意味値の型の集合を宣言する.
* Type Decl::         非終端記号のための型の選択を宣言する.
* Expect Decl::       シフト/還元衝突の警告を抑制する.
* Start Decl::        開始記号を指定する.
* Pure Decl::         再入構文解析器を要求する.
* Decl Summary::      全てのBison宣言の表.


File: bison-ja.info,  Node: Token Decl,  Next: Precedence Decl,  Up: Declarations

3.6.1 トークン型名
------------------

トークン型名、すなわち終端記号を、基本的には次のように宣言します。

     %token NAME

Bisonは、これを、構文解析器の中の`#define'ディレクティブに変換します。
したがって、関数`yylex'が構文解析器ファイルの中にあれば、
そこで名前NAMEをこのトークン型を表すために使えます。

   優先順位を指定したければ、`%token'の代わりに、
`%left'、`%right'、`%nonassoc'のどれかを使います。 *Note Operator
Precedence: Precedence Decl。

   トークンの名前の直後に整数値を書くことで、
そのトークン型に対応する数値符号を明示的に指定できます。

     %token NUM 300

   しかし、Bisonにすべてのトークン型に対する数値符号の割り当てをまかせる
ことがいちばんです。Bisonは、トークン型どうしやASCII文字符号と
衝突が起きないように、自動的に数値符号を割り当てます。

   スタック型が共用体である場合には、
`%token'あるいは他のトークン宣言に、
小なり記号と大なり記号で区切った型名を追加する必要があります （*note
More Than One Value Type: Multiple Types.）。

   例を示します。

     %union {              /* スタックのデータ型を定義する */
       double val;
       symrec *tptr;
     }
     %token <val> NUM      /* トークン「NUM」とその型を定義する */

   トークン型名を宣言する`%token'宣言の末尾に
リテラル文字列を書くことで、リテラル文字列トークンと
トークン型名を関連づけできます。

     %token arrow "=>"

   C言語に対する文法では、次の例のように、
等価なリテラル文字列トークンに名前を指定しています。

     %token  <operator>  OR      "||"
     %token  <operator>  LE 134  "<="
     %left  OR  "<="

   リテラル文字列とトークン名を等価にすれば、それ以降の文法規則の
宣言の中で、両者を同様に使えます。
`yylex'関数は、トークン型の数値符号を得るために、
トークン名とリテラル文字列の両方を使えます （*note Calling
Convention::）。


File: bison-ja.info,  Node: Precedence Decl,  Next: Union Decl,  Prev: Token Decl,  Up: Declarations

3.6.2 演算子の優先順位
----------------------

トークンの宣言とトークンの優先順位および結合規則の指定をまとめて行いたいならば、
`%left'、`%right'、`%nonassoc'のどれかを使います。
これらは、"優先順位宣言（precedence declarations）"と呼ばれます。
演算子の優先順位の詳細については、 *Note Operator Precedence:
Precedence。

   優先順位宣言の構文は、`%token'を使う宣言の構文と同じです。

     %left SYMBOLS...

   次のようにも書けます。

     %left <TYPE> SYMBOLS...

   これらの宣言は、`%token'を使う宣言が目的とする
すべての機能を持っています。
それに加えて、次のように結合性と、すべてのSYMBOLSについての優先順位を指定します。

   * 演算子OPの結合性は、この演算子が繰り返し使われた場合の
     動作を指定します。つまり、`X OP Y OP Z'が
     構文解析された場合に、最初にXとYがグループ化されるか、
     それともYとZがグループ化されるかを指定します。
     `%left'は、左結合性、つまりXとYが先に結合されることを
     指定します。`%right'は、右結合性、つまり、
     YとZが先に結合されることを指定します。
     `%nonassoc'は、無結合性を指定し、その場合、 `X OP Y OP Z'は
     構文エラーとみなされます。

   * 演算子の優先順位は、その演算子が他の演算子とともに使われた場合の
     動作を指定します。同一の優先順位宣言で宣言されたすべてのトークンは、
     同じ優先順位を持ち、その結合性にしたがって処理されます。
     2個のトークンが別々の優先順位宣言で宣言されているならば、
     文法ファイルの中で後で宣言されたほうの演算子が強い優先順位を持ちます。



File: bison-ja.info,  Node: Union Decl,  Next: Type Decl,  Prev: Precedence Decl,  Up: Declarations

3.6.3 値型の集合
----------------

`%union'宣言は、意味値に対して可能なデータ型すべての集合を指定します。
キーワード`%union'に続いて、C言語における共用体の宣言と同様に、
ブレースで囲んだ宣言の並びを書きます。

   例を示します。

     %union {
       double val;
       symrec *tptr;
     }

   これは、2つの選択可能な型`double'と`symrec *'があると、
宣言しています。 それぞれの型には、名前`val'と`tptr'が与えられています。
これらの名前は、`%token'と`type'宣言の中で、
終端記号あるいは非終端記号に対する型を選ぶために使えます （*note
Nonterminal Symbols: Type Decl.）。

   C言語での共用体宣言とは異なり、閉じブレースの後にセミコロンを
_書いてはいけない_ことに注意してください。


File: bison-ja.info,  Node: Type Decl,  Next: Expect Decl,  Prev: Union Decl,  Up: Declarations

3.6.4 非終端記号
----------------

`%union'を複数の値型を指定するために使うならば、
値を持つ各非終端記号の値型を宣言する必要があります。
そのためには、次のように`%type'宣言を使います。

     %type <TYPE> NONTERMINAL...

   ここで、NONTERMINALは非終端記号の名前で、
TYPEは`%union'で指定した名前の中からあなたが選んだものです （*note The
Collection of Value Types: Union Decl.）。
同じ値型を持つ任意の数の非終端記号を、
1つの`%type'宣言の中に記述できます。
その場合、記号名を空白で区切ってください。

   同様に終端記号の値型の宣言も可能です。
そのためには、終端記号の宣言の中で、同じ`<TYPE>'の 書式を使います。
すべてのトークン宣言で、`<TYPE>'が許可されています。


File: bison-ja.info,  Node: Expect Decl,  Next: Start Decl,  Prev: Type Decl,  Up: Declarations

3.6.5 衝突警告の回避
--------------------

文法の中に衝突（*note Shift/Reduce Conflicts: Shift/Reduce.）があると、
Bisonは通常警告を表示します。
しかし、実際の文法のほとんどは、無害なシフト還元衝突を含み、
その衝突は、予測可能な方法で回避できますが、除去は困難です。
衝突の数が変わらないかぎり、このような衝突の警告は 抑制させるべきです。
そのために、`%expect'宣言を使います。

   次のように宣言します。

     %expect N

   ここで、Nは10進の整数です。
この宣言によって、N個のシフト還元衝突があって、
還元/還元衝突がなければ、警告が表示されません。
シフト還元衝突の数がNでなかったり、
1つでも還元/還元衝突があった場合は、通常の警告が表示されます。

   一般に、次のような手順で`%expect'を使います。

   * `%expect'なしで文法ファイルをコンパイルします。
     衝突が起こる位置の詳細な目録を得るために、`-v'オプションを指定します。
     Bisonは、衝突の数も表示します。

   * 衝突のそれぞれについて、Bisonの省略時の解決方法が、
     あなたの望みどおりであるか、確かめます。
     もし不都合があれば、文法ファイルを書き直して、最初に戻ります。

   * Bisonが表示した衝突の数Nを書き写して、 `%expect'宣言を追加します。


   すると、Bisonはチェックした衝突について文句をいわなくなりますが、
文法ファイルを書き換えて衝突の数が変わると、 再び警告を表示します。


File: bison-ja.info,  Node: Start Decl,  Next: Pure Decl,  Prev: Expect Decl,  Up: Declarations

3.6.6 開始記号
--------------

Bisonは、文法定義部にある最初の非終端記号を、
省略時の開始記号と仮定します。
次のような`%start'宣言で、明示的に開始記号を指定できます。

     %start SYMBOL


File: bison-ja.info,  Node: Pure Decl,  Next: Decl Summary,  Prev: Start Decl,  Up: Declarations

3.6.7 純粋（再入可能）構文解析器
--------------------------------

"再入可能（reentrant）"プログラムとは、進路を変えないプログラム、
いいかえれば、完全に"純粋な（pure）"（読み出し専用）コードからなる
プログラムです。 (1) 再入可能性は、非同期実行が可能な場合に重要です。
たとえば、再入可能でないプログラムを、
シグナルハンドラから呼び出すことは危険です。マルチスレッド制御システムでは、
再入不能プログラムはインターロックからしか呼び出せません。

   通常は、Bisonは再入可能でない構文解析器を生成します。
これはほとんどの使用に合い、YACCとの互換性も保ちます。
（標準のYACCインターフェースは継続的に非再入可能であります。
というのは、`yylex'、`yylval' や `yylloc' との通信に
静的に確保された変数 (2) を使うからです。

   代わりに、純粋な、再入可能な構文解析器を生成することができます。
次のような`%pure_parser' Bison宣言は、
再入可能な構文解析器を生成します。

     %pure_parser

   この宣言によって、上記の2個の通信用変数`yylval'と`yylloc'が、
`yyparse'の局所変数になり、
`yylex'字句解析関数を呼び出す方法が変わります。 詳細については、*Note
Calling Conventions for Pure Parsers: Pure Calling。
`yyparse'の中の`yynerrs'変数も局所変数になります （*note The Error
Reporting Function `yyerror': Error Reporting.）。
`yypase'関数自体を呼び出す方法は変わりません。

   解析器が純粋かどうかは文法規則には全く関係しません。
全ての有効な文法から、純粋な解析器と非再入可能な解析器の
どちらかを生成するこができます。

   ---------- Footnotes ----------

   (1) 【訳注】ある手続きの終了を待たずに、その手続きを再度呼び出せる
ことでもあります。

   (2) 【訳注】他のソースファイルから見えないとう意味ではなく、
メモリ上の固定番地に置かれるという意味。


File: bison-ja.info,  Node: Decl Summary,  Prev: Pure Decl,  Up: Declarations

3.6.8 Bison宣言の要約
---------------------

Bison宣言の要約を示します。

`%union'
     意味値が持ちうるデータ型の集合を宣言します （*note The Collection
     of Value Types: Union Decl.）。

`%token'
     優先順位と結合性を指定せずに、終端記号（トークン型名）を宣言します
     （*note Token Type Names: Token Decl.）。

`%right'
     右結合的な終端記号（トークン型名）を宣言します （*note Operator
     Precedence: Precedence Decl.）。

`%left'
     左結合的な終端記号（トークン型名）を宣言します （*note Operator
     Precedence: Precedence Decl.）。

`%nonassoc'
     結合性がない、つまり、結合して使おうとすると構文エラーになる、
     終端記号（トークン型名）を宣言します （*note Operator Precedence:
     Precedence Decl.）。

`%type'
     非終端記号に対する意味値の型を宣言します （*note Nonterminal
     Symbols: Type Decl.）。

`%start'
     文法の開始記号を宣言します （*note The Start-Symbol: Start
     Decl.）。

`%expect'
     予想されるシフト還元衝突の数を宣言します （*note Suppressing
     Conflict Warnings: Expect Decl.）。

`%pure_parser'
     純粋な（再入可能な）構文解析器を生成します （*note A Pure
     (Reentrant) Parser: Pure Decl.）。

`%no_lines'
     構文解析器ファイルに、`#line'プリプロセッサディレクティブを生成しません。
     Bisonは、通常、Cコンパイラとデバッガがエラーとあなたのソースファイル
     （文法ファイル）を関連づけられるように、構文解析器ファイルに
     `#line'ディレクティブを書き込みます。
     `%no_lines'宣言は、エラーを構文解析器ファイルの行数と関連づけ、
     構文解析器ファイルをそれ自身で独立したソースファイルと
     みなすことを意味します。

`%raw'
     通常、出力ファイル`NAME.h'は、 Yacc互換トークン番号を定義します。
     このオプションが指定されると、代わりに、Bison内部の番号が使われます
     （Yacc互換番号は、1文字リテラルトークンを除いて、257から始まりますが、
     Bison内部のトークン番号は常に3から始まる連番になります）。

`%token_table'
     構文解析器ファイルの中に、トークン名の表を生成します。
     その表の名前は`yytname'で、`yytname[I]'が
     Bison内部トークン番号Iのトークンの名前です。
     最初の3個の要素は常に、`"$"'、`"error"'、`"$illegal"'で、
     この後に文法ファイルで定義された記号が続きます。

     表の中で、1文字リテラルトークンにはシングルクォート記号が、
     文字列リテラルトークンにはダブルクォート記号が含まれます。
     たとえば、`"'+'"'は1文字リテラルトークンで、
     `"\"<=\""'は文字列リテラルトークンです。
     文字列リテラルトークンのすべての文字はそのまま表に現れ、
     ダブルクォート記号もエスケープされません。
     たとえば、トークンが3文字`*"*'からなれば、
     `yytname'中の文字列は`"*"*"'となります
     （Cでは`"\"*\"*\""'と書きます）。

     `%token_table'を指定すると、Bisonは、マクロ
     `YYNTOKENS'、`YYNNTS'、`YYNRULES'、`YYNSTATES'の 定義も生成します。

    `YYNTOKENS'
          最大のトークン番号＋1。

    `YYNNTS'
          非終端記号の数。

    `YYNRULES'
          文法規則の数。

    `YYNSTATES'
          構文解析器の状態の数（*note Parser States::）。


File: bison-ja.info,  Node: Multiple Parsers,  Prev: Declarations,  Up: Grammar File

3.7 同一プログラム中の複数の構文解析器
======================================

Bisonを使うプログラムのほとんどは、言語を1つだけ構文解析し、
したがって、Bison構文解析器を1つだけ含みます。
しかし、1つのプログラムで2種類以上の言語を構文解析したいときは、
どうすればよいでしょうか？　そうするためには、`yyparse'、`yylval'
などの2重定義の衝突を防ぐ必要があります。

   これを容易にする方法が、オプション`-p PREFIX'の利用です （*note
Invoking Bison: Invocation.）。
これによって、Bison構文解析器のインターフェイス関数と変数の名前が、
`yy'で始まる代わりにPREFIXで始まります。
これでそれぞれの構文解析器に、衝突しないような異なる名前を与えられます。

   変更される名前は、 `yyparse'、`yylex'、`yyerror'、`yynerrs'、
`yylval'、`yychar'、`yydebug'で全部です。 たとえば、`-p
c'オプションを使えば、これらの名前は、
`cparse'、`clex'などに変わります。

   *Bisonに関連する上記以外の変数とマクロのすべての
名前は変わりません。*これらは、広域ではないので、
異なる構文解析器で同じ名前が使われても衝突しません。
たとえば、`YYSTYPE'の名前は変わりませんが、
この定義は構文解析器ごとに異なる方法で行われるので、問題ありません
（*note Data Types of Semantic Values: Value Type.）。

   `-p'オプションは、さらに、構文解析器ソースファイルの始めで、
`yyparse'を`PREFIXparse'と定義するように、 マクロを定義します。
この結果、構文解析器ソースファイル全体で、ある名前を別の名前に変えます。


File: bison-ja.info,  Node: Interface,  Next: Algorithm,  Prev: Grammar File,  Up: Top

4 構文解析器のC言語インターフェイス
***********************************

Bison構文解析器の正体は、`yyparse'という名前のCの関数です。
ここでは、`yyparse'とほかに使う必要がある関数の間の
インターフェイスの方法を示します。

   構文解析器の内部では、多くの`yy'または`YY'で始まるCの識別子が
使われていることに注意してください。
本書で説明しているものを除いて、そのような識別子を
文法ファイルのアクションや追加のCプログラムの中で使うと、
問題が起きるでしょう。

* Menu:

* Parser Function::   `yyparse'の呼び方と、それが返すもの.
* Lexical::           トークンを読み込む関数`yylex'を提供しなければ
                        ならない.
* Error Reporting::   関数`yyerror'を提供しなければならない.
* Action Features::   アクションで使える特別な機能.


File: bison-ja.info,  Node: Parser Function,  Next: Lexical,  Up: Interface

4.1 構文解析器関数`yyparse'
===========================

構文解析を始めるには、関数`yyparse'を呼び出します。
この関数は、トークンを読み、アクションを実行し、最後には入力ファイルの
終わりに達するか回復不可能な構文エラーに達して、戻ります。
読み込みを打ち切って`yyparse'関数から戻るような
アクションを書くことも可能です。

   構文解析が成功する、つまり入力ファイルの終わりに達すると、
`yyparse'からの戻り値が0になります。

   構文解析が失敗する、つまり構文エラーが発生すると、
戻り値が1になります。

   アクションの中で、次のマクロを使って、
`yyparse'からただちに戻れます。

`YYACCEPT'
     成功の印である戻り値0をともなって、ただちに戻ります。

`YYABORT'
     失敗の印である戻り値1をともなって、ただちに戻ります。



File: bison-ja.info,  Node: Lexical,  Next: Error Reporting,  Prev: Parser Function,  Up: Interface

4.2 字句解析器関数`yylex'
=========================

"字句解析器（lexical analyzer）"関数`yylex'は、
入力からトークンを認識し、構文解析器に返します。
Bisonはこの関数を自動的に生成しないので、
`yyparse'から呼び出されるように`yylex'を書く必要があります。
関数`yylex'は"lexical scanner"と呼ばれることもあります。

   単純なプログラムでは、よく文法ファイルの最後で`yylex'を
定義します。`yylex'が別のソースファイルの中で定義する場合は、
そこでトークン型マクロ定義を使えるように準備する必要があります。
そのためには、`-d'オプションを指定してBisonを実行してください。
すると、マクロ定義がヘッダファイル`NAME.tab.h'に
書き込まれ、それを必要とするソースファイルにインクルードできます。
*Note Invoking Bison: Invocation。

* Menu:

* Calling Convention::  `yyparse'が`yylex'を呼ぶ方法.
* Token Values::      `yylex'がどのように読み込んだトークンの
                        意味値を返さなければならないか.
* Token Positions::   アクションが望むときに、どのように`yylex'が
                        テキストの位置（行数など）を返さなければならない
                        か。
* Pure Calling::      純粋な構文解析器で呼び出し型の習慣がどのように
                        違うか (*note A Pure (Reentrant) Parser: Pure Decl.).


File: bison-ja.info,  Node: Calling Convention,  Next: Token Values,  Up: Lexical

4.2.1 `yylex'を呼び出す方法
---------------------------

`yylex'が返す値は、見つかったトークンの型に対する番号で、
入力ファイルの終わりに達した場合には0を返します。

   トークンが文法規則の中で名前で参照される場合、
構文解析器ファイルの中でのその名前は、
トークン型に対する適切な番号にCのマクロとして定義されます。
したがって、`yylex'は型を示すためにその名前を使用できます。 *Note
Symbols::。

   文法規則の中でトークンが1文字リテラルとして参照される場合には、
その文字の文字符号がトークン型に対する番号でもあります。
そこで、`yylex'は、単純に文字符号を返します。
しかし、戻り値0は入力ファイルの終わりを意味するので、
ヌル文字（`'\0''）の文字符号を返してはいけません。

   以下に例を示します。

     yylex ()
     {
       ...
       if (c == EOF)     /* ファイルの終わりか調べる。 */
         return 0;
       ...
       if (c == '+' || c == '-')
         return c;      /* `+' に対するトークン型が '+' であると仮定する。 */
       ...
       return INT;      /* トークン型を返す。 */
       ...
     }

   このようなインターフェイスは、 `lex'が生成した字句解析器を、
`yylex'の定義を変えずに使えるように設計されています。

   文法規則が文字列リテラルトークンを使っている場合には、
`yylex'がそれに対するトークン型番号を使う、 2つの方法があります。

   * 文法が文字列リテラルトークンに対する別名として記号トークン名を
     定義しているならば、`yylex'はその記号名を他のトークンの記号名と
     同様に使えます。この場合、文法ファイルの中での文字列リテラルトークンの
     利用は、`yylex'にまったく影響しません。

   * `yylex'は、`yytname'表の中で、 複数文字トークンを見つけられます。
     トークンに対する表の添え字は、そのトークン型の番号です。
     複数文字トークンは`yytname'の中にダブルクォート記号で囲まれて
     記憶されます。 トークンに含まれる文字はエスケープされず、
     表の中の文字列にそのまま書き込まれています。

     トークンを構成する文字列が`token_buffer'に記憶されていると仮定して、
     `yytname'からトークンを探し出すプログラムを示します。

          for (i = 0; i < YYNTOKENS; i++)
            {
              if (yytname[i] != 0
                  && yytname[i][0] == '"'
                  && strncmp (yytname[i] + 1, token_buffer,
                              strlen (token_buffer))
                  && yytname[i][strlen (token_buffer) + 1] == '"'
                  && yytname[i][strlen (token_buffer) + 2] == 0)
                break;
            }

     `yytname'表は、`%token_table'宣言をした場合にのみ生成されます。
     *Note Decl Summary::。



File: bison-ja.info,  Node: Token Values,  Next: Token Positions,  Prev: Calling Convention,  Up: Lexical

4.2.2 トークンの意味値
----------------------

通常の再入可能でない構文解析器では、
トークンの意味値が広域変数`yylval'に代入される必要があります。
意味値に対してただ1つのデータ型を使っている場合には、
`yylval'の型もそうです。
したがって、たとえば、宣言を省略して型が`int'ならば、
次のように書けます。

       ...
       yylval = value;  /* 値をBisonスタックに積む。 */
       return INT;      /* トークン型を返す。 */
       ...

   複数のデータ型を使っている場合には、
`%union'宣言で作られた共用体が`yylval'の型になります （*note The
Collection of Value Types: Union Decl.）。
そこで、トークンの値を代入するには、
共用体のメンバの名前を指定する必要があります。
`%union'宣言の例を示します。

     %union {
       int intval;
       double val;
       symrec *tptr;
     }

   すると、`yylex'の中のプログラムは次のようになります。

       ...
       yylval.intval = value; /* 値をBisonスタックに積む。 */
       return INT;          /* トークン型を返す。 */
       ...


File: bison-ja.info,  Node: Token Positions,  Next: Pure Calling,  Prev: Token Values,  Up: Lexical

4.2.3 トークンのテキスト中の位置
--------------------------------

アクションの中で`@N'機能 （*note Special Features for Use in Actions:
Action Features.）を
使っている場合には、トークンとグループのテキスト中の位置を
見失わないように、`yylex'の中で位置情報を提供する必要があります。
関数`yyparse'は、ちょうど解析されたトークンのテキスト中の位置が、
広域変数`yylloc'に記憶されていると仮定します。
そこで、`yylex'は、`yyloc'に正しいデータを記憶する必要があります。
変数`yylloc'は構造体で、アクションの中で使われる場合にのみ、
メンバを初期化する必要があります。
メンバは、`first_line'、`first_column'、
`last_line'、`last_column'の4つです。
この機能を使うと、構文解析器が著しく遅くなることに注意してください。

   `yylloc'のデータ型は、`YYLTYPE'という名前を持っています。


File: bison-ja.info,  Node: Pure Calling,  Prev: Token Positions,  Up: Lexical

4.2.4 再入可能構文解析器を呼び出す方法
--------------------------------------

純粋な、つまり再入可能な、構文解析器を生成するために、
`%pure_parser'をBison宣言すると、広域変数`yylval'と
`yylloc'を使えなくなります （*note A Pure (Reentrant) Parser: Pure
Decl.）。 このような構文解析器では、2つの広域変数の代わりに、
`yylex'への引数として渡されるポインタを使います。
`yylex'を次のように宣言し、
これらのポインタを通して情報を受け渡しする必要があります。

     yylex (lvalp, llocp)
          YYSTYPE *lvalp;
          YYLTYPE *llocp;
     {
       ...
       *lvalp = value;  /* 値をBisonスタックに積む。  */
       return INT;      /* トークン型を返す。 */
       ...
     }

   文法ファイルがテキスト中の位置を参照するための`@'機能を
使っていない場合は、`YYLTYPE'は定義されません。
この場合、第2引数を省略し、`yylex'は
1個の引数をともなって呼び出されます。

   再入可能な構文解析器を使っている場合、
再入可能な方法で構文解析器に追加の引数を渡す方法があります。
そのためには、マクロ`YYPARSE_PARAM'を変数名として定義します。
すると、関数`yyparse'は、定義された名前で、型が`void *'の
追加の引数を受け取ります。

   `yyparse'を呼び出すときに、オブジェクトの番地を `void
*'型にキャストして渡します。
文法のアクションは、ポインタを適切な型へのポインタへキャストし、
逆参照して、オブジェクトの内容を参照できます。 例を示します。

     %{
     struct parser_control
     {
       int nastiness;
       int randomness;
     };

     #define YYPARSE_PARAM parm
     %}

   次のように構文解析器を呼び出します。

     struct parser_control
     {
       int nastiness;
       int randomness;
     };

     ...

     {
       struct parser_control foo;
       ...  /* `foo'に正しいデータを記憶  */
       value = yyparse ((void *) &foo);
       ...
     }

文法アクションの中では、データを参照するために次のような式を使います。

     ((struct parser_control *) parm)->randomness

   `yylex'に追加の引数を渡したい場合には、
`YYPARSE_PARAM'と同様に、マクロ`YYLEX_PARAM'を定義します。
例を示します。

     %{
     struct parser_control
     {
       int nastiness;
       int randomness;
     };

     #define YYPARSE_PARAM parm
     #define YYLEX_PARAM parm
     %}

   そして、`yylex'が追加の引数、`parm'の値を受け取るように、
`yylex'を定義する必要があります
（型`YYLTYPE'のどの引数が渡されるかに応じて、
引数の合計が2個または3個になります）。
引数を正しいオブジェクト型として宣言できます。すなわち`void *'として
宣言し、上記の番地を参照できます。

   `YYPARSE_PARAM'を使わずに、`%pure_parser'を使って、
再入可能な構文解析器を生成することも可能です。
その場合、引数をつけずに`yyparse'を呼び出すべきです。


File: bison-ja.info,  Node: Error Reporting,  Next: Action Features,  Prev: Lexical,  Up: Interface

4.3 エラー報告関数`yyerror'
===========================

Bison構文解析器は、文法規則に適合しないトークンを読むたびに、
"構文解析エラー（parse error）"すなわち"文法エラー（syntax error）"を
検出します。文法中のアクションは、マクロ`YYERROR'を使って、
明示的にエラーを示せます （*note Special Features for Use in Actions:
Action Features.）。

   Bison構文解析器は、`yyerror'という名前の関数を使って、
エラーを報告するようになっています。 事前に用意が必要な
この関数は、文法エラーが発生するたびに、1個の引数をともなって、
`yyparse'から呼び出されます。
構文解析エラーに対して、引数の文字列は通常`"parse error"'です。

   Bison定義部（*note The Bison Declarations Section: Bison
Declarations.）で、 マクロ`YYERROR_VERBOSE'を定義すると、
`"parse error"'の代わりに、 エラーを詳細に報告する文字列が用意されます。
マクロ`YYERROR_VERBOSE'の定義はなんでもかまいません。

   構文解析器は、もう1種類のエラーであるスタックオーバーフローを検出する
可能性があります。これは、入力がきわめて深い入れ子からなっていると
起こることがあります。Bison構文解析器は自動的にスタックの限界を大きく拡張し
ているので、スタックオーバーフローはめったに起きません。
しかし、もしスタックオーバーフローが起きれば、
`"parser stack overflow"'という
文字列の引数をともなって、`yyerror'が呼び出されます。

   単純なプログラムでは、次の例のように`yyerror'を定義できます。

     yyerror (s)
          char *s;
     {
       fprintf (stderr, "%s\n", s);
     }

   `yyerror'から戻った後、`yyparse'は、 適切なエラー回復文法規則（*note
Error Recovery::）があれば、 エラーからの回復を試みます。
もし、回復が不可能ならば、`yyparse'は即座に1を返します。

変数`yynerrs'には、それまでに出くわした文法エラーの数が記憶されています。
通常、この変数は広域変数です。 しかし、再入可能な構文解析器（*note A
Pure (Reentrant) Parser: Pure Decl.）
を生成した場合には、アクションからのみ参照可能な局所変数になります。


File: bison-ja.info,  Node: Action Features,  Prev: Error Reporting,  Up: Interface

4.4 アクション中で使える特別な機能
==================================

ここの表では、アクション中で有用な、Bisonの構造物、変数、
マクロを示します。

`$$'
     現在の規則で作られるグループに対する意味値を保持する変数のように働きます。
     *Note Actions::。

`$N'
     現在の規則のN番目の構成要素に対する意味値を保持する変数のように
     働きます。*Note Actions::。

`$<TYPEALT>$'
     `$$'に似ていますが、`%union'宣言で指定された共用体の中の
     TYPEALTを選びます。 *Note Data Types of Values in Actions: Action
     Types。

`$<TYPEALT>N'
     `$N'に似ていますが、`%union'宣言で指定された共用体の中の
     TYPEALTを選びます。 *Note Data Types of Values in Actions: Action
     Types。

`YYABORT;'
     `yyparse'からただちに戻り、失敗を示します。 *Note The Parser
     Function `yyparse': Parser Function。

`YYACCEPT;'
     `yyparse'からただちに戻り、成功を示します。 *Note The Parser
     Function `yyparse': Parser Function。

`YYBACKUP (TOKEN, VALUE);'
     トークンを逆シフトします。
     1個の値を還元する規則の中で、先読みトークンがない場合にのみ、
     このマクロが使えます。
     このマクロは、トークン型がTOKENで意味値がVALUEのトークンを、
     先読みトークンとして格納し、この規則で還元されるはずだった値を捨てます。

     先読みトークンがすでにあるような、このマクロが無効な状況で
     このマクロを使うと、メッセージ`cannnot back up'をともなう
     文法エラーが報告され、通常のエラー回復が行われます。

     どちらの場合も、アクションの残りの部分は実行されません。

`YYEMPTY'
     先読みトークンがない場合に、変数`yychar'に記憶されている値です。

`YYERROR;'
     ただちに文法エラーを発生させます。この文は、構文解析器がエラーを検出したように
     エラー回復を始めますが、`yyerror'を呼び出さず、
     メッセージは表示されません。
     もし、エラーメッセージを表示したければ、`YYERROR'文よりも先に、
     明示的に`yyerror'を呼び出してください。 *Note Error Recovery::。

`YYRECOVERING'
     このマクロの値は、字句解析器が文法エラーからの回復中ならば1、
     そうでなければ0です。 *Note Error Recovery::。

`yychar'
     現在の先読みトークンを含んでいる変数です
     （再入可能構文解析器では、`yyparse'の局所変数です）。
     先読みトークンがない場合には、この変数に
     `YYEMPTY'という値が入っています。 *Note Look-Ahead Tokens:
     Look-Ahead。

`yyclearin;'
     現在の先読みトークンを捨てます。エラー規則の中で有用です。 *Note
     Error Recovery::。

`yyerrok;'
     後に続く文法エラーに対して、エラーメッセージの生成を再開します。
     これは、エラー規則で特に重要です。 *Note Error Recovery::。

`@N'
     現在の規則の第N要素の、行番号と列番号を含む、
     配列変数のように働きます。 次のようなメンバがあります。

          struct {
            int first_line, last_line;
            int first_column, last_column;
          };

     たとえば、第3要素の開始行番号を知るには、 `@3.first_line'とします。

     この構造体のメンバを有効な情報にするためには、
     `yylex'がそれぞれのトークンに対して、
     情報を提供する必要があります。 一部分のメンバだけが必要ならば、
     `yylex'はそのメンバの値を設定するだけでかまいません。 (1)

     この機能を使うと、字句解析器が著しく遅くなります。

   ---------- Footnotes ----------

   (1) 【訳注】`yylex'は、変数`yylloc'に、
トークンの位置情報を代入します。


File: bison-ja.info,  Node: Algorithm,  Next: Error Recovery,  Prev: Interface,  Up: Top

5 Bison構文解析器のアルゴリズム
*******************************

Bison構文解析器は、トークンを読むと、トークンの意味値とともにスタックに積みます。
このスタックを"構文解析器スタック（parser stack）"と呼びます。
トークンをスタックに積むことを、伝統的に
"シフト（shifting）"と呼びます。

   たとえば、中間記法電卓が、`1 + 5 *'をすでに読んでいて、
`3'を受け取ったと仮定します。
スタックには4個の要素があり、トークンそれぞれがシフトされています。

   しかし、スタックに常に読み込まれたトークンそれぞれに対する
要素があるわけではありません。
最後のN個のトークンとグループが文法規則に当てはまる場合には、
それらは規則に従って組み合わされます。
これを、"還元（reduction）"と呼びます。
スタックにあったトークンとグループは、
規則の結果、つまり左側にある記号である、1個のグループに置き換えられます。
規則のアクションの実行は、結果のグループの意味値を計算するので、
還元の手順の1つです。

たとえば、中間記法電卓の構文解析器スタックの内容は次のようになります。

     1 + 5 * 3

   そして、入力された次のトークンが改行符号ならば、
次の規則に従って、最後の3個の要素が15に還元されます。

     expr: expr '*' expr;

   そして、スタックは3個の要素を持ちます。

     1 + 15

   この時点で、別の還元が可能になり、1個の値16を得ます。
そして、改行符号がシフトされます。

   構文解析器は、シフトと還元によって、入力全体を
文法の開始記号である1個のグループに還元しようとします （*note Languages
and Context-Free Grammars: Language and Grammar.）。

   この種類の構文解析器は、ボトムアップ構文解析器として知られています。

* Menu:

* Look-Ahead::        構文解析器は何をするかを決めるときに一つ先のトーク
                        ンを見る.
* Shift/Reduce::      衝突: シフトと還元の両方が有効なとき.
* Precedence::        演算子の優先順位は衝突を解決することで動作する.
* Contextual Precedence::  演算子の優先順位が文脈に依存するとき.
* Parser States::     構文解析器はスタック付きの有限状態機械.
* Reduce/Reduce::     同じ状況に2つの規則が適用可能なとき.
* Mystery Conflicts::  正しくないように見える還元/還元衝突.
* Stack Overflow::    スタックが一杯になったときに何が起こるうか. それを
                        避ける方法.


File: bison-ja.info,  Node: Look-Ahead,  Next: Shift/Reduce,  Up: Algorithm

5.1 先読みトークン
==================

Bison構文解析器は、必ずしも文法規則に適合する最後のN個のトークン
またはグループが見つかるとすぐに還元を行う_わけではありません_。
そのような単純な方法は、多くの言語の処理に適さないからです。
その代わりに、還元が可能な場合に、構文解析器は次のトークンを
「先読み」し、次に何をするべきかを決定します。

   トークンが読まれると、それはすぐにシフトされるのではなく、
まず、"先読みトークン（look-ahead token）"になり、
スタックには置かれません。
先読みトークンを残したまま、構文解析器が、スタック上のトークンまたは
グループに対して1個以上の還元を実行します。
それ以上の還元が起こりえない場合に、
先読みトークンはスタックにシフトされます。
これは、すべての可能な還元が実行されたことを意味しません。
先読みトークンのトークン型に応じて、
いくつかの規則は適用を遅らされているかもしれません。

   先読みが必要な簡単な例を示します。
下記の3個の規則は、2項加算演算子、単項階乗演算子（`!'）、
グループのためのかっこを含みます。

     expr:     term '+' expr
             | term
             ;

     term:     '(' expr ')'
             | term '!'
             | NUMBER
             ;

   トークン`1 + 2'が読み込まれてシフトされているときに、
何が起きるでしょうか。もし、続くトークンが`)'ならば、
最初の3個のトークンは`expr'の形式に還元される必要があります。
これが、唯一有効な道です。
なぜならば、`)'をシフトして、`term ')''という記号列も
生成可能ですが、どの規則もそのような記号列を許していないからです。

   もし、続くトークンが`!'ならば、それはただちにシフトされる必要があり、
`2 !'から`term'が還元されます。
そうではなく、構文解析器がシフトの前に還元していれば、
`1 + 2'が`expr'に還元されます。
しかし、そのような還元をしようとすると`expr '!''という記号列を
スタックに生成しようとするので、`!'をシフトするのは不可能です。
そのような記号列は許されません。

   現在の先読みトークンは、変数`yychar'に記憶されています *Note Special
Features for Use in Actions: Action Features。


File: bison-ja.info,  Node: Shift/Reduce,  Next: Precedence,  Prev: Look-Ahead,  Up: Algorithm

5.2 シフト還元衝突
==================

次の2個の規則で定められる、"if-then"と"if-then-else"文を持つ
言語の構文解析について考えます。

     if_stmt:
               IF expr THEN stmt
             | IF expr THEN stmt ELSE stmt
             ;

   ここで、`IF'、`THEN'、`ELSE'は、
キーワードトークンを表す終端記号であると仮定します。

   `ELSE'トークンが読まれて先読みトークンになったときに、
入力が正しいと仮定して、スタックの内容はちょうど
最初の規則で還元される右辺になっています。
しかし、いずれ起こるはずの第2の規則の還元のために、
`ELSE'トークンをシフトすることも有効です。

   この、シフトと還元の両方が有効な場合を、
"シフト還元衝突（shift/reduce conflict）"と呼びます。
Bisonは、演算子優先規則宣言で特に指定されていないかぎり、
シフトを選ぶことで衝突を解決するように設計されています。
この理由を理解するために、別の選択肢と比較してみましょう。

   構文解析器は`ELSE'のシフトを選ぶので、その結果、
else節はもっとも内側のif文に対応し、次の2つの入力は等価になります。

     if x then if y then win (); else lose;

     if x then do; if y then win (); else lose; end;

   しかし、字句解析器がシフトでなく還元を選ぶと、その結果、
else節がもっとも外側のif文に対応し、次の2つの入力は等価になります。

     if x then if y then win (); else lose;

     if x then do; if y then win (); end; else lose;

   文法があいまいに書かれているために、衝突が起きます。
つまり、入れ子になったif文について、どちらの構文解析結果も正当なのです。
確立された習慣では、else節をもっとも内側のif文に対応させて、
あいまいさを解決しています。
これが、Bisonが還元よりもシフトを選ぶ理由です
（理想的には、あいまいでない文法を書くべきですが、この場合には困難です）。
この問題は、Algol 60の仕様の中に現れたのが最初で、
「ぶらさがり`else'（dangling `else'）」問題と呼ばれています。

予測可能で正当なシフト還元衝突について、Bisonが警告を表示しないように、
`%expect N'宣言を使えます。
すると、ちょうどN個のシフト還元衝突があるかぎり、 警告は表示されません。
*Note Suppressing Conflict Warnings: Expect Decl。

   上記の`if_stmt'の定義は、衝突をわざと発生させるために書きましたが、
追加の規則がなければ実際には衝突が起きません。
次に、実際に衝突を含む完全なBison入力ファイルの例を示します。

     %token IF THEN ELSE variable
     %%
     stmt:     expr
             | if_stmt
             ;

     if_stmt:
               IF expr THEN stmt
             | IF expr THEN stmt ELSE stmt
             ;

     expr:     variable
             ;


File: bison-ja.info,  Node: Precedence,  Next: Contextual Precedence,  Prev: Shift/Reduce,  Up: Algorithm

5.3 演算子の優先順位
====================

シフト還元衝突が起きる別の可能性は、算術式の中にあります。
この場合には、シフトの選択が望ましい解決策であるとは限りません。
どのような場合にシフトしてどのような場合に還元するべきか指定するために、
演算子の優先順位についてのBison宣言を使えます。

* Menu:

* Why Precedence::    優先順位が必要なことを示す例.
* Using Precedence::  Bison文法で優先順位を指定する方法.
* Precedence Examples::  前の例でこれらの機能が使われた方法.
* How Precedence::    どのように動作するか.


File: bison-ja.info,  Node: Why Precedence,  Next: Using Precedence,  Up: Precedence

5.3.1 優先順位が必要な場合
--------------------------

次のあいまいな文法の一部を見てください。
入力`1 - 2 * 3'が2通りに構文解析されうるので、 この文法はあいまいです。

     expr:     expr '-' expr
             | expr '*' expr
             | expr '<' expr
             | '(' expr ')'
             ...
             ;

   構文解析器が、`1'、`-'、`2'というトークンを
読み込んだと仮定します。構文解析器は、減算演算子の規則に従って、
これらのトークンを還元するべきでしょうか。
それは、次のトークンに依存します。
もちろん、次のトークンが`)'ならば、還元する必要があります。
なぜならば、もしシフトすると、`- 2 )'またはそれで始まる
記号列を還元する必要が生じ、そのような規則はないからです。
しかし、次のトークンが`*'または`<'ならば、
シフトと還元のどちらも可能です。
どちらを選んでも構文解析を完了できますが、解析の結果は異なります。

   Bison字句解析器がどちらの処理をすべきか決めるために、
構文解析の結果を考慮する必要があります。
もし、次の演算子トークンOPがシフトされるならば、
還元して差を求める可能性を許すために、
OPは最初に還元される必要があります。
その結果は、`1 - (2 OP 3)'となります。
逆に、OPをシフトする前に減算を還元するならば、
結果は`(1 - 2) OP 3'となります。
明らかに、シフトと還元のどちらが起こるべきかの選択は、
演算子`-'とOPの相対的な優先順位に依存します。
`*'は先にシフトされるべきですが、`<'は違います。

   `1 - 2 - 5'のような例ではどうなるでしょうか。
`(1 - 2) - 5'と処理するべきでしょうか。
それとも、`1 - (2 - 5)'と処理するべきでしょうか。
ほとんどの演算子については前者が適し、これを、 "左結合性（left
association）"と呼びます。 後者の"右結合性（right
association）"は、代入演算子に適します。
左結合性か右結合性かの判断は、スタックに`1 - 2'が含まれ、
先読みトークンが`-'である場合の、シフトか還元かの選択です。
シフトを選ぶと、右結合的になります。


File: bison-ja.info,  Node: Using Precedence,  Next: Precedence Examples,  Prev: Why Precedence,  Up: Precedence

5.3.2 演算子の優先順位の指定
----------------------------

演算子優先順位宣言`%left'と`%right'によって、
演算子の優先順位と結合規則を指定できます。
どちらの宣言も、優先順位と結合規則を指定したい演算子である、
トークンの並びからなります。 `%left'宣言はすべての演算子を左結合的に、
`%right'宣言はすべての演算子を右結合的に宣言します。
第3の選択肢は`%nonassoc'宣言で、これで宣言した演算子が
続けて2回以上現れると、構文解析器が文法エラーを指摘します。

異なる演算子の相対的な優先順位は、それらが宣言される順序で決まります。
文法ファイルの中の最初の`%left'宣言または`%right'宣言で
宣言された演算子が、もっとも低い優先順位を持ちます。
後から宣言される演算子ほど、高い優先順位を持ちます。


File: bison-ja.info,  Node: Precedence Examples,  Next: How Precedence,  Prev: Using Precedence,  Up: Precedence

5.3.3 優先順位の例
------------------

先ほどの例では、次のように宣言するべきでした。

     %left '<'
     %left '-'
     %left '*'

   もっと複雑な例では、より多くの演算子を使うだけでなく、
同じ優先順位を持つ演算子があります。
次の例では、`'+''演算子と`'-''演算子が同じ優先順位を持ちます。

     %left '<' '>' '=' NE LE GE
     %left '+' '-'
     %left '*' '/'

   （この例で、`NE'は「等しくない」演算子を表し、他も同様です。
これらのトークンは、2文字以上からなるので、
1文字リテラルではなく名前で表されると仮定しています）


File: bison-ja.info,  Node: How Precedence,  Prev: Precedence Examples,  Up: Precedence

5.3.4 優先順位が働く仕組み
--------------------------

優先順位宣言の最初の働きは、宣言された終端記号への優先順位の割り当てです。
第2の働きは、規則に含まれる最後の終端記号が優先順位を示すように、
ある規則に優先順位を割り当てることです
（規則に対して、明示的に優先順位を指定することも可能です。 *Note
Context-Dependent Precedence: Contextual Precedence）。

   最後に、衝突の解決は、問題になっている規則の優先順位と、
先読みトークンの優先順位の比較によって行われます。
もし、先読みトークンの優先順位が高ければ、還元されます。
もし、規則の優先順位が高ければ、シフトされます。
もし、優先順位が同じならば、その優先順位での結合規則によって決定されます。
`-v'オプションを付けてBisonを実行し、冗長な出力ファイルを得ると、
どのように衝突が解決されているかがわかります （*note Invoking Bison:
Invocation.）。

   すべての規則とトークンが優先順位を持っているとはかぎりません。
もし、規則と先読みトークンが優先順位を持っていなければ、
シフトが行われます。


File: bison-ja.info,  Node: Contextual Precedence,  Next: Parser States,  Prev: Precedence,  Up: Algorithm

5.4 文脈依存優先順位
====================

しばしば、演算子の優先順位は文脈に依存します。
これは、最初は奇異に感じるかもしれませんが、
実際によく起きていることなのです。 たとえば、通常、減算演算子（`-'）は、
単項演算子としては非常に高い優先順位を持ちますが、
2項演算子としては乗除算よりも低い優先順位を持ちます。

   Bisonの優先順位宣言、`%left'、`%right'、`%nonassoc'は、
あるトークンに対して1回のみ使え、この方法では、
トークンは唯一の優先順位を宣言されます。
文脈に依存する優先順位のためには、別の方法、すなわち、
`%prec'で規則を修飾する方法が必要になります。

   `%prec'修飾子は、ある規則で使われるべき終端記号の優先順位を指定して、
その規則の優先順位を宣言します。
その記号がその規則の中以外に現れる必要はありません。
修飾子の記法は、次のようになっています。

     %prec TERMINAL-SYMBOL

   これは、規則の構成要素の後に書かれます。
これによって、通常の方法で導かれる優先順位に代わって、
TERMINAL-SYMBOLの優先順位を規則に割り当てます。
規則の優先順位が変更されて、その規則が関係している衝突の解決に影響します
（*note Operator Precedence: Precedence.）。

   `%prec'がどのように単項負記号を解決するかを示します。
まず、`UMINUS'という名前の終端記号に対する優先順位を宣言します。
この型のトークンは存在しませんが、
この記号が優先順位を表現するために使われます。

     ...
     %left '+' '-'
     %left '*'
     %left UMINUS

   さて、`UNIMIS'の優先順位を、規則の中で使えます。

     exp:    ...
             | exp '-' exp
             ...
             | '-' exp %prec UMINUS


File: bison-ja.info,  Node: Parser States,  Next: Reduce/Reduce,  Prev: Contextual Precedence,  Up: Algorithm

5.5 構文解析器の状態
====================

関数`yyparse'は、有限状態機械を使って実装されています。
構文解析器のスタックに積まれる値は、トークン型番号だけでなく、
スタックの先頭またはその近くにある終端記号と非終端記号の列を
表現しています。現在の状態は、次にすべきことに関連する、
今までの入力の情報全体の集まりです。

   先読みトークンが読まれるたびに、先読みトークンの型と
現在の構文解析器の状態によって、表が引かれます。
この表の項目には、「先読みトークンをシフトしなさい」というような
ことが書かれています。この場合、その表の項目は、
先読みトークンが構文解析器スタックのトップに置かれた、
構文解析器の新しい状態をも示しています。
「N番目の規則を使って還元しなさい」というような項目もあります。
これによって、決められた数のトークンまたはグループがスタックのトップから
取り除かれ、1個のグループがスタックのトップに置かれます。
言い換えると、その数の状態がスタックからポップされ、
新しい1個の状態がスタックにプッシュされます。

   これには、1つの例外があります。
先読みトークンが現在の状態に対してエラーであるという項目もあります。
この場合には、エラー処理が起こります （*note Error Recovery::）。


File: bison-ja.info,  Node: Reduce/Reduce,  Next: Mystery Conflicts,  Prev: Parser States,  Up: Algorithm

5.6 還元/還元衝突
=================

同一の入力列に対して2個以上の規則が適用可能であると、
還元/還元衝突が起きます。 これは、通常、文法の重大なエラーを意味します。

   0個以上の`word'の並びをグループ化する、 誤った試みの例を示します。

     sequence: /* 空 */
                     { printf ("empty sequence\n"); }
             | maybeword
             | sequence word
                     { printf ("added word %s\n", $2); }
             ;

     maybeword: /* 空 */
                     { printf ("empty maybeword\n"); }
             | word
                     { printf ("single word %s\n", $1); }
             ;

   エラーは、あいまいさにあります。
つまり、1個の`word'を`sequence'に構文解析する、
2個以上の方法があります。 `word'は、`maybeword'に還元され、
第2の規則によって`sequence'になりえます。
また、最初の規則で、空データが`sequence'に還元され、
それが第3の規則によって`word'と組み合わされて `sequence'になりえます。

   さらに、空データが`sequence'に還元される方法が2つ以上あります。
第1の規則で直接還元される方法と、
`maybeword'を経由して第2の規則で還元される方法です。

   この違いは、特定の入力が正当であるかどうかに関係ないので、
ささいなことに思えるかもしれません。
しかし、これは、どのアクションが実行されるかに影響します。
ある構文解析手順では第2の規則のアクションが実行され、
別の構文解析手順では第1の規則のアクションと第3の規則のアクションが
実行されます。 この例では、プログラムの出力が異なります。

   Bisonは、最初に現れた文法を選ぶことで、還元/還元衝突を解決しますが、
これに頼ることは非常に危険です。
還元/還元衝突のそれぞれは、人間によって解析され、
通常は取り除かれるべきです。 `sequence'を定義する正しい方法を示します。

     sequence: /* 空 */
                     { printf ("empty sequence\n"); }
             | sequence word
                     { printf ("added word %s\n", $2); }
             ;

   還元/還元衝突を起こす、別のありがちなエラーの例を示します。

     sequence: /* 空 */
             | sequence words
             | sequence redirects
             ;

     words:    /* 空 */
             | words word
             ;

     redirects:/* 空 */
             | redirects redirect
             ;

   ここは、`word'または`redirect'グループのどちらかを含む
列の定義が目的です。 `sequence'、`words'、`redirects'それぞれ個別の
定義にエラーはありません。しかし、3個を合わせると、あいまいになります。
空の入力には、無限個の構文解析方法があります。

   空データが`words'になったと仮定しましょう。
それは、2個の`words'にも、3個の`words'にも、
何個の`words'にもなりえます。
あるいは、1個の`words'に3個の`redirects'ともう1個の`word'が
続くことも考えられます。同様に、無限の解釈が可能です。

   これらの規則を直す方法が2つあります。
第1に、1段階の列にする方法です。

     sequence: /* 空 */
             | sequence word
             | sequence redirect
             ;

   第2に、`words'と`redirects'が空になるのを防ぐ方法です。

     sequence: /* 空 */
             | sequence words
             | sequence redirects
             ;

     words:    word
             | words word
             ;

     redirects:redirect
             | redirects redirect
             ;


File: bison-ja.info,  Node: Mystery Conflicts,  Next: Stack Overflow,  Prev: Reduce/Reduce,  Up: Algorithm

5.7 不可解な還元/還元衝突
=========================

そうなるはずがないように見えるのに、ときどき
還元/還元衝突が起きることがあります。 例を示します。

     %token ID

     %%
     def:    param_spec return_spec ','
             ;
     param_spec:
                  type
             |    name_list ':' type
             ;
     return_spec:
                  type
             |    name ':' type
             ;
     type:        ID
             ;
     name:        ID
             ;
     name_list:
                  name
             |    name ',' name_list
             ;

この文法は、1個のトークンの先読みによって、構文解析できるように見えます。
たとえば、`pram_spec'が読まれた後で、
`ID'はカンマかセミコロンが続くならば`name'、
そうでなければ`type'となります。 言い換えれば、この文法はLR(1)です。

   しかし、Bisonは、多くの構文解析器生成器と同様に、
すべてのLR(1)文法を扱えるわけではありません。
前述の例では、`ID'の後で、そこが`param_spec'の先頭であるという
文脈と、そこが`return_spec'の先頭であるという文脈は、
Bisonが同一であるとみなしてしまうほど似ています。
これらの文脈が似てしまう原因は、同じ規則の集合が有効になる、つまり、
`name'へ還元するための規則と、`type'へ還元するための規則の
両方が有効なことです。
Bisonは、その規則が2つの文脈で異なる先読みトークンを要求するような、
処理の段階を決定できず、両者から1つの構文解析器状態ができてしまいます。
2個の文脈の組み合わせは、後で衝突を起こします。
構文解析器の用語でいえば、この問題の発生は、
文法がLALR(1)でないことを意味します。

   一般に、このような欠点は解決して、文書化するべきです。
しかし、この問題は本質的に解決困難です。
LR(1)文法を扱える構文解析器生成器は、作成困難で、
生成される構文解析器が巨大になってしまいます。
実用上、Bisonは今のままでも有用です。

   このような問題が現れた場合に、混乱の元になっている2種類の構文解析器の
状態を区別し、それらが違うという目印か何かを追加することによって、
しばしば問題を解決できます。
前述の例では、次のように`return_spec'に規則を追加して、
問題を解決できます。

     %token BOGUS
     ...
     %%
     ...
     return_spec:
                  type
             |    name ':' type
              /* この規則は決して使われない。  */
             |    ID BOGUS
             ;

   `ID'の次で`return_spec'の先頭である文脈で、
追加の規則が有効になる可能性を導入して、問題を解決しています。
この規則は、`param_spec'に関連する文脈では有効にならないので、
2個の文脈は、異なる構文解析器状態を持ちます。
`BOGUS'は`yylex'によっては決して生成されないので、
追加された規則は入力が実際に構文解析される方法には影響しません。

   この具体例では、問題を解決する別の方法があります。
つまり、`return_spec'の規則を、`name'経由ではなく
`ID'を直接使うように書き換えるのです。
`return_spec'に対する規則は、`name'に対する規則ではなく、
`return_spec'に対する規則を有効にするので、
2つの混乱していた文脈は異なる有効な規則の集まりを持ちます。

     param_spec:
                  type
             |    name_list ':' type
             ;
     return_spec:
                  type
             |    ID ':' type
             ;


File: bison-ja.info,  Node: Stack Overflow,  Prev: Mystery Conflicts,  Up: Algorithm

5.8 スタックオーバーフローと防ぎ方
==================================

Bison構文解析器のスタックは、あまりにも多くのトークンがシフトされて
還元されないでいると、オーバーフローする可能性があります。
スタックがオーバーフローすると、オーバーフローを報告するために`yyerror'
を呼び出して、関数`yyparse'は0でない値を返します。

マクロ`YYMAXDEPTH'を定義して、スタックオーバーフローが起こらないように、
構文解析器のスタックの深さを調節できます。
マクロの値として、整数値を定義してください。
この値は、オーバーフローする前に、シフトされたが還元されていないトークンの
最大数になります。
マクロの値として、コンパイル時に決定可能な定数式を指定してください。

   指定されたスタック領域は、割り当てられる必要はありません。
大きな`YYMAXDEPTH'を指定すると、
構文解析器はまず小さなスタック領域を割り当て、
必要に応じてより大きなスタック領域を割り当てます。
この割り当ての増加は、何も表示せずに、自動的に行われます。
したがって、スタックをあまり必要としない通常の入力に対して
メモリを節約するために、`YYMAXDEPTH'を小さくする必要はありません。

   特に指定しないと、`YYMAXDEPTH'の値は10000になります。

   マクロ`YYINIDEPTH'を指定して、最初に割り当てられるスタックの量を
調節できます。この値は、コンパイル時に決定可能な整定数の必要があります。
特に指定しないと、200になります。


File: bison-ja.info,  Node: Error Recovery,  Next: Context Dependency,  Prev: Algorithm,  Up: Top

6 エラーからの回復
******************

構文解析エラーが起きた場合に、構文解析プログラムが止まることは、
通常望ましくありません。
たとえば、コンパイラは入力の残りを構文解析して他のエラーを探せるように
エラーから回復するべきですし、電卓は次の式を受け入れるべきです。

   入力を1行ごとに処理する単純な対話的構文解析器は、
エラーが発生した場合に`yyparse'が1を返し、 入力行の残りを無視し、
`yyparse'をもう一度呼び出してもかまいません。
しかし、コンパイラでこのように処理すると、
エラーに先立つ文法的文脈を忘れてしまうので不都合です。
深い関数呼び出しの中で構文エラーが発生した場合に、
コンパイラがエラーに続く行をソースファイルの先頭のように
扱うべきではありません。

   特別なトークン`error'を認識するような規則を書くことによって、
構文エラーから回復する方法を定義できます。
`error'は定義済みの終端記号で、自分で宣言する必要はなく、
エラー処理のために予約されています。
Bison構文解析器は、構文エラーが起こるたびに、`error'トークンを生成します。
現在の文脈で`error'トークンを認識できる規則を書いていれば、
構文解析を継続できます。

   例を示します。

     stmnts:  /* 空文字列 */
             | stmnts '\n'
             | stmnts exp '\n'
             | stmnts error '\n'

   第4の規則は、`error'とそれに続く改行が、任意の`stmnts'に
続くことを認めます。

   `exp'の中で構文エラーが発生するとどうなるでしょうか。
エラー回復規則は、厳密に解釈され、`stmnts'、`error'、改行からなる
列に適用されます。
`exp'の中で構文エラーが起きると、おそらく、いくつかの余分なトークンまたは
部分式がスタック上の最後の`stmnts'の後に存在し、
したがって、次の改行を読む前に読むべきトークンが存在するでしょう。
したがって、この通常の方法では規則を適用できません。

   しかし、意味文脈と入力の一部を捨てることによって、
Bisonは強制的にこの場合に規則を適用できます。
まず、`error'トークンが受理可能な状態に戻るまで、
状態とオブジェクトがスタックから捨てられます
（これは、すでに構文解析された部分式が捨てられ、
最後の完全な`stmnts'に状態が戻ることを意味します）。
この時点で、`error'トークンがシフトされます。
そして、古い先読みトークンのシフトは受理不可能なので、
受理可能なトークンを見つけるまで、
構文解析器はトークンを読んで捨てます。
前述の例では、次の改行がくるまで入力が読み捨てられ、
したがって、第4の規則が適用可能になります。

   文法中のエラー規則の選択は、エラー回復の戦略の選択です。
単純で便利な戦略の1つは、エラーを検出したら、
単純に現在の入力行または文を読み飛ばすことです。

     stmnt: error ';'  /* エラーがあれば、「;」がくるまで読み飛ばす。 */

   すでに構文解析された開き区切りトークン
を、閉じ区切りトークンに対応させることは、
エラー処理のうまい方法です。そうしなければ、閉じ区切りトークンが
後で不適切に現れて、別の重大なエラーを引き起こすでしょう。

     primary:  '(' expr ')'
             | '(' error ')'
             ...
             ;

   エラー回復の戦略は熟慮されるべきです。
戦略が悪いと、1つの構文エラーがしばしば別のエラーを引き起こします。
前述の例では、エラー回復規則は、1個の`stmnt'の中で起きると
仮定されています。
そうでない可能性として、有効な`stmnt'の中に誤ってセミコロンが
まぎれ込んでいることを考えてみましょう。
エラー回復規則が最初のエラーを回復した後で、まぎれ込んだセミコロンに続く
入力も無効な`stmnt'なので、もう1つの構文エラーがただちにみつかります。

   エラー報告の洪水を避けるために、
最初の構文エラーが起きた直後の他の構文エラーに対しては、
構文解析器はエラー報告を表示しないべきでしょう。
3個の連続する入力トークンのシフトに成功してから、
エラー報告を再開するべきです。

   `error'トークンを受け付ける規則も、他の規則と同様に
アクションを持てることに注意してください。

   アクションの中でマクロ`yyerrok'を使って、
ただちにエラー報告を再開できます。
もし、エラー規則のアクションの中でこのマクロを使えば、
エラー報告は抑制されません。
このマクロに引数は不要で、`yyerrok;'は有効なCの文です。

   直前の先読みトークンは、エラーの直後に再解析されます。
これが不都合ならば、マクロ`yyclearin'によって先読みトークンを
消してください。すなわち、エラー規則のアクションに
`yyclearin;'文を書いてください。

たとえば、構文エラーにおいて、構文解析を再開すべき場所まで入力を進めるような、
エラー処理手続きを考えてみましょう。
字句解析器から返される次の記号は、おそらく正しいでしょう。
以前の先読みトークンは`yyclearin;'によって捨てられるべきです。

   マクロ`YYRECOVERING'は、式を表し、構文解析器がエラーから回復する
途中にあるならば値が1になり、通常の状態ならば値が0になります。
値が1であるということは、新たな構文エラーに対するエラーの報告が、
現在は抑制されていることを示します。


File: bison-ja.info,  Node: Context Dependency,  Next: Debugging,  Prev: Error Recovery,  Up: Top

7 文脈依存性の処理
******************

Bisonの枠組みは、まずトークンを読み、
次にトークンをより大きな文法的単位にグループ化することです。
多くの言語では、トークンの意味は文脈の影響を受けます。
文脈依存性によってBisonの枠組みが壊れますが、
（"kludges"として知られる）いくつかの技術を使って、
このような言語に対するBison構文解析器を書けます。

* Menu:

* Semantic Tokens::   トークン構文解析は意味的文脈に依存する.
* Lexical Tie-ins::   トークン構文解析は構文的文脈に依存する.
* Tie-in Recovery::   字句結び付きはエラー回復規則を書く方法に影響する.

   （実際に、「kludge」は、仕事を可能にしますが、
美しくも頑丈でもない技術を意味します）


File: bison-ja.info,  Node: Semantic Tokens,  Next: Lexical Tie-ins,  Up: Context Dependency

7.1 トークン型の意味情報
========================

C言語は文脈依存性をもっています。
すなわち、識別子の使われ方は、それの現在の意味に依存します。
次の例を考えてみてください。

     foo (x);

   これは、関数を呼び出す文のように見えます。
しかし、もし、`foo'が`typedef'された型名ならば、
この文は`x'の宣言になります。
C言語に対するBison構文解析器は、この入力を構文解析する方法を
どのように決定できるでしょうか。

   GNU Cで使っている方法は、`IDENTIFIER'と`TYPENAME'という、
2種類の異なるトークン型を使うことです。
`yylex'が識別子を見つけると、どちらのトークン型を返すか決めるために、
識別子の現在の宣言を検索し、`typedef'として宣言されていれば
`TYPENAME'を返し、そうでなければ`IDENTIFIER'を返します。

   そして、認識するトークン型を選ぶことによって、
文法規則は文脈依存性を表現できます。
`IDENTIFIER'は、式として受け入れられますが、
`TYPENAME'は受け入れられません。
`TYPENAME'は、宣言の始まりとして受け入れられますが、
`IDENTIFIER'は受け入れられません。
識別子の意味の区別が_必要のない_文脈、
たとえば`typedef'名を隠す宣言の中では、
`TYPENAME'と`IDENTIFIER'の両方が受け入れられます。
すなわち、2個のトークン型に対してそれぞれ1個の規則を書くことが可能です。

   この方法は、どの種類の識別子が許されるかの判断が、
その識別子が構文解析される場所の近くで行われるならば、 単純に使えます。
しかし、C言語で、いつもそうであるとは限りません。
次の例のように、以前に指定された明示的な型に規定された`typedef'名の
再宣言が許されているからです。

     typedef int foo, bar, lose;
     static foo (bar);        /* `bar'を静的変数として再宣言する。 */
     static int foo (lose);   /* `foo'を関数として再宣言する。 */

   不幸にも、込み入った文法構造「宣言子(declarator)」によって、
宣言された名前は、その宣言の構造自身から切り離されます。

   結果として、C言語に対するBison構文解析器は、
すべての非終端記号の名前を変えて、二重化されました。
第1は、`typedef'名が再定義されているかもしれない宣言を構文解析し、
第2は、再定義が起こりえない宣言を構文解析します。
二重化したものの一部分を、簡単にするためにアクションを省略して、示します。

     initdcl:
               declarator maybeasm '='
               init
             | declarator maybeasm
             ;

     notype_initdcl:
               notype_declarator maybeasm '='
               init
             | notype_declarator maybeasm
             ;

   ここで、`initdcl'は`typedef'名を再宣言できますが、
`notype_initdcl'は再宣言できません。
`declarator'と`notype_declarator'の違いも同様です。

   前述の技術と、後述の字句解析結び付きには、
字句解析に影響する情報が入力の別の部分を構文解析しているときに
変化させられるという、共通点があります。
前者では、情報が広域的で、プログラム(1)の別の目的に
使われることが異なります。
本当の字句解析結び付きは、文脈によって制御される、
特別の目的のフラグを持ちます。

   ---------- Footnotes ----------

   (1) 【訳注】構文解析器。


File: bison-ja.info,  Node: Lexical Tie-ins,  Next: Tie-in Recovery,  Prev: Semantic Tokens,  Up: Context Dependency

7.2 字句解析結び付き
====================

文脈依存性を処理する1つの方法は、"字句解析結び付き（lexical
tie-in）"で、 Bisonのアクションによって設定されるフラグが、
トークンが構文解析される方法に影響します。

   たとえば、C言語によく似ていて、`hex (HEX-EXPR)'という
特別な構造を持つ言語について、考えてみましょう。
予約語`hex'がきた後にかっこで囲まれた式が続いて、
そのかっこの中ではすべての整数が16進数になります。
特に、トークン`a1b'は、このような文脈に現れれば、
識別子ではなく整数として扱われる必要があります。
どのようにすればよいかを示します。

     %{
     int hexflag;
     %}
     %%
     ...
     expr:   IDENTIFIER
             | constant
             | HEX '('
                     { hexflag = 1; }
               expr ')'
                     { hexflag = 0;
                        $$ = $4; }
             | expr '+' expr
                     { $$ = make_sum ($1, $3); }
             ...
             ;

     constant:
               INTEGER
             | STRING
             ;

   `yylex'は、`hexflag'の値が0でなければ、
すべての整数が16進数であると字句解析し、
英字で始まるトークンも可能な限り整数と解釈すると、仮定します。

   `hexflag'の宣言は、アクションから参照可能なように、
文法ファイルのC宣言部に書かれる必要があります （*note The C
Declarations Section: C Declarations.）。
同様に、`yylex'のプログラムにも、`hexflag'の宣言が必要です。


File: bison-ja.info,  Node: Tie-in Recovery,  Prev: Lexical Tie-ins,  Up: Context Dependency

7.3 字句解析結び付きとエラー回復
================================

字句解析結び付きは、厳密なエラー回復規則を要求します。 *Note Error
Recovery::。

   その理由は、エラー回復規則の目的が、ある構成物の構文解析を中断し、
より大きな構成物の構文解析を再開することです。
前述のC言語に似ている言語の例では、次のように、
標準的なエラー回復規則は、次のセミコロンまでトークンを読み捨て、
新しい文の構文解析を再開します。

     stmt:   expr ';'
             | IF '(' expr ')' stmt { ... }
             ...
             error ';'
                     { hexflag = 0; }
             ;

   もし、`hex (EXPR)'の途中で構文エラーが発生すれば、
このエラー回復規則が適用され、完了した`hex EXPR)'に対する
アクションは決して実行されません。
すると、`hexflag'は、入力の残りの間ずっと設定されたままでいるか、
次の`hex'予約語の出現までそのままの状態でいて、
識別子が16進整数と誤解されます。

   この問題を防ぐためには、エラー回復規則が
`hexflag'を元に戻すべきです。

   さらに、式の内部で働くエラー回復規則があるかもしれません。
たとえば、次の例のように、かっこの中でエラーが発生すると、
閉じかっこまで読み捨てるようなエラー回復規則が考えられます。

     expr:   ...
             | '(' expr ')'
                     { $$ = $2; }
             | '(' error ')'
             ...

   もし、この規則が`hex'構造の中で働くならば、
その構造の中の内側のかっこに適用されるので、
構造を中断するべきではありません。
したがって、このアクションではフラグを戻すべきではなく、
`hex'構造の残りはフラグを有効にしたまま構文解析されるべきです。

状況に応じて、`hex'構造を中断できるかもしれないし、そうでないかもしれない
エラー回復規則があれば、どうなるでしょうか。
`hex'構造を中断すべきかどうか決定できるアクションを書けません。
そこで、もし、字句解析結び付きを使っているならば、
あなたが書いたエラー回復規則がそのようになっていないことを確かめるべきです。
それぞれの規則は、常にフラグを戻すべきか、あるいは常にフラグを戻さないべきか、
決定できるべきです。


File: bison-ja.info,  Node: Debugging,  Next: Invocation,  Prev: Context Dependency,  Up: Top

8 構文解析器のデバッグ
**********************

もし、Bison文法ファイルが正しくコンパイルされたのに、
生成された構文解析器が思いどおりに動かない場合には、
`yydebug'構文解析器追跡機能が、調査の役に立つでしょう。

   追跡機能のコンパイルを有効にするためには、
構文解析器をコンパイルするときに、マクロ`YYDEBUG'を定義する必要があります。
そのためには、コンパイラのオプションに`-DYYDEBUG=1'を指定するか、
あるいは、文法ファイルのC宣言部に`#define YYDEBUG 1'と書いておく
必要があります（*note The C Declarations Section: C Declarations.）。
あるいは、Bisonを実行するときに(*note Invoking Bison: Invocation.)、
`-t'オプションを指定しておくと、
`YYDEBUG'が定義され、追跡が可能になります。

   追跡機能は`stderr'を使うので、C宣言部に
`#include <stdio.h>'と書いておく必要があります。

   追跡機能付で構文解析器をコンパイルしたら、構文解析器の実行時に、
追跡機能を有効にするために、`yydebug'変数を0でない値にしてください。
C言語のプログラム(おそらく`main'関数の中)でこの変数に代入するか、
あるいは、デバッガでこの変数の値を変えればいいでしょう。

   `yydebug'が0でない場合、構文解析器はそれぞれの段階で、
1行まはた2行の追跡情報を生成し、`stderr'に出力します。
追跡情報には、次のような情報が含まれています。

   * 構文解析器が`yylex'を呼ぶたびに、
     読み込まれたトークンの種類が記録されます。

   * トークンがシフトされるたびに、状態スタックの深さと完全な内容が
     表示されます（*note Parser States::）。

   * 規則が還元されるたびに、どの規則が使われるか、そして、
     還元後の状態スタックの完全な内容が記録されます。


   この情報を理解するためには、Bisonに`-v'オプション （*note Invoking
Bison: Invocation.）を付けて実行すると生成される
明細ファイルが参考になるでしょう。
このファイルには、さまざまな規則の中での位置による表現で
各状態の意味が示され、また、
各状態がそれぞれの可能な入力トークンによって
どのように動作するかが示されています。
連続する追跡の意味を読むことによって、
明細ファイルで仕様が示されている構文解析器の機能について、理解できるでしょう。
何か望ましくないことが起きている部分を確認すれば、
文法ファイルのどこに問題があるかわかるでしょう。

   構文解析器ファイルはC言語のプログラムなので、
Cのデバッガを使えますが、 何が起きているか調べることは困難です。
構文解析器関数は、有限状態機械インタープリタで、
アクションが実行されると、
プログラムの同じ部分が何度も何度も実行されます。
実用的なのは文法の中で変数の値を調べることだけでしょう。

   デバッグ情報には、通常、それぞれのトークンのトークン型だけが含まれ、
トークンの意味値は含まれません。 マクロ`YYPRINT'を定義することで、
トークンの意味値を表示させられます。
`YYPRINT'の定義には、3個の引数がともないます。
構文解析器は、`YYPRINT'に、標準入出力ストリーム、
トークン型の数値番号、トークンの値（`yylval'による）を渡します。

   多機能電卓に適する`YYPRINT'の例を示します （*note Declarations for
`mfcalc': Mfcalc Decl.）。

     #define YYPRINT(file, type, value)   yyprint (file, type, value)

     static void
     yyprint (file, type, value)
          FILE *file;
          int type;
          YYSTYPE value;
     {
       if (type == VAR)
         fprintf (file, " %s", value.tptr->name);
       else if (type == NUM)
         fprintf (file, " %d", value.val);
     }


File: bison-ja.info,  Node: Invocation,  Next: Table of Symbols,  Prev: Debugging,  Up: Top

9 Bisonの実行
*************

通常、Bisonは次のように実行します。

     bison INFILE

   ここで、INFILEは文法ファイルで、名前が通常`.y'で終わります。
生成される構文解析器ファイルは、文法ファイルの名前の`.y'を
`.tab.c'に変えたものです。 したがって、`bison
foo.y'によって`foo.tab.c'を得られますし、 `bison
hack/foo.y'によって`hack/foo.tab.c'を得られます。

* Menu:

* Bison Options::     全てのオプションが詳しく、短いオプションでアルファ
                        ベット順に説明されている.
* Option Cross Key::  長いオプションのアルファッベット順のリスト.
* VMS Invocation::    VMSでのBisonのコマンド構文.


File: bison-ja.info,  Node: Bison Options,  Next: Option Cross Key,  Up: Invocation

9.1 Bisonのオプション
=====================

Bisonは、伝統的な1文字のオプションと、記憶しやすい長いオプション名の
両方を受け付けます。長いオプション名は、`-'の代わりに、
`--'で指定します。
一意性を失わない範囲で、長いオプション名を省略できます。
長いオプションが引数をともなう場合、たとえば、`--file-prefix'では、
オプション名と引数の間に`='を入れます。

Bisonに対して指定可能なオプションの一覧を、アルファベット順に示します。
さらに、長い名前のアルファベット順の対応を示します。

`-b FILE-PREFIX'
`--file-prefix=PREFIX'
     Bisonが生成するすべてのファイルの名前の前半部分を指定します。
     入力される文法ファイルの名前が`PREFIX.y'であった場合と、
     同じ結果を得られます。

`-d'
`--defines'
     文法ファイル中で定義されたトークン型名に対するマクロ定義、
     意味値型`YYSTYPE'、いくつかの`extern'変数宣言を含む、
     追加の出力ファイルを生成します。

     生成される構文解析ファイルの名前が`NAME.c'ならば、
     このファイルの名前は`NAME.h'になります。

     `yylex'関数を独立なソースファイルの中で定義しているならば、
     それはトークン型番号と変数`yylval'を必要とするので、
     このファイルを`#include'する必要があります *Note Semantic Values
     of Tokens: Token Values。

`-l'
`--no-lines'
     構文解析器ファイルの中に、`#line'プリプロセッサディレクティブを生成しません。
     通常、Bisonはこれを生成し、Cコンパイラとデバッガが、
     文法ファイルのどこでエラーが発生したかを見つけるために使います。
     このオプションは、エラーと構文解析器の行番号を結び付け、
     構文解析器を独立なソースファイルとして扱います。

`-n'
`--no-parser'
     構文解析器にCのプログラムを含めず、表だけを生成します。
     構文解析器ファイルは、`#define'ディレクティブと
     静的変数の宣言のみからなります。

     このオプションにより、`FILENAME.act'という名前のファイルに、
     文法アクションに対するC言語のプログラムが書かれます。
     その書式は、`switch'文に対応するブレースで囲まれたブロックです。

`-o OUTFILE'
`--output-file=OUTFILE'
     生成される構文解析器ファイルの名前を指定します。

     他の出力ファイルのファイル名の指定は
     `-v'と`-d'オプションの項を参照してください。

`-p PREFIX'
`--name-prefix=PREFIX'
     構文解析器が使う外部名を`yy'でなくPREFIXで始まるように変えます。
     影響を受ける名前は、 `yyparse'、`yylex'、`yyerror'、`yynerrs'、
     `yylval'、`yychar'、`yydebug'です。

     たとえば、`-p c'オプションを指定すれば、
     名前は`cparse'、`clex'などになります。

     *Note Multiple Parsers in the Same Program: Multiple Parsers。

`-r'
`--raw'
     `%raw'が指定されたように振る舞います。 *Note Decl Summary::。

`-t'
`--debug'
     デバッグ機能がコンパイルされるように、
     マクロ`YYDEBUG'の定義を構文解析器ファイルに入れます *Note
     Debugging Your Parser: Debugging。

`-v'
`--verbose'
     構文解析器の状態についての詳細な説明と、
     それらの状態でそれぞれの先読みトークンが現れると何が起きるか記述した、
     追加のファイルを生成します。

     このファイルは、演算子の優先順位によって解決したものも解決しなかった
     ものも含めて、衝突についての説明を含んでいます。

     生成されるファイルの名前は、構文解析器のファイルの名前から、
     `.tab.c'または`.c'を取り除いて、
     代わりに`.output'を付けたものです。

     したがって、入力の文法ファイルの名前が`foo.y'ならば、
     特に指定しないと、構文解析器ファイルの名前は`foo.tab.c'になり、
     詳細な説明のファイルの名前は`foo.output'になります。

`-V'
`--version'
     バージョン番号を表示して、Bisonを終了させます。

`-h'
`--help'
     コマンドラインオプションの要約を表示して、Bisonを終了させます。

`-y'
`--yacc'
`--fixed-output-files'
     `-o y.tab.c'と等価です。構文解析器ファイルの名前は
     `y.tab.c'になり、他の出力ファイルの名前は`y.output'と
     `y.tab.h'になります。このオプションの目的は、
     出力ファイルの名前をYaccに合わせることです。
     次のシェルスクリプトは、Yaccの代用になります。

          bison -y $*


File: bison-ja.info,  Node: Option Cross Key,  Next: VMS Invocation,  Prev: Bison Options,  Up: Invocation

9.2 オプション対応表
====================

オプションを、長い名前のアルファベット順に一覧表記して、
対応する1文字オプションを書きます。

     --debug                               -t
     --defines                             -d
     --file-prefix=PREFIX                  -b FILE-PREFIX
     --fixed-output-files --yacc           -y
     --help                                -h
     --name-prefix=PREFIX                  -p NAME-PREFIX
     --no-lines                            -l
     --no-parser                           -n
     --output-file=OUTFILE                 -o OUTFILE
     --raw                                 -r
     --token-table                         -k
     --verbose                             -v
     --version                             -V


File: bison-ja.info,  Node: VMS Invocation,  Prev: Option Cross Key,  Up: Invocation

9.3 VMS上での実行
=================

VMS上のBisonのコマンドライン構文は、VMSの慣習に合わせて、
他のシステム上のBisonのコマンドライン構文と異なっています。

   VMSでは、すべてのBisonのオプションについて、
`--'の代わりに`/'に続く長い名前のオプションを書き、
オプション名中の`-'を`_'に変えます。 VMS上での実行例を示します。

     bison /debug/name_prefix=bar foo.y

   これは、POSIX上での次のコマンドラインと等価です。

     bison --debug --name-prefix=bar foo.y

VMSファイルシステムでは、`foo.tab.c'のようなファイル名が許されないので、
構文解析器の名前は、上記の例の場合には、`foo_tab.c'になります。


File: bison-ja.info,  Node: Table of Symbols,  Next: Glossary,  Prev: Invocation,  Up: Top

Appendix A Bisonの記号一覧
**************************

`error'
     エラー回復のために予約されているトークン名です。
     このトークンが文法規則の中で使われていると、Bison構文解析器は、
     構文エラーを認識し、プロセスの実行を中断しません。
     実質的には、エラーを含む文が、有効であると認識されます。
     エラーが起きると、`error'トークンが現在の先読みトークンになります。
     `error'に対応するアクションが実行されて、
     先読みトークンがエラーの原因になったトークンに戻されます。 *Note
     Error Recovery::。

`YYABORT'
     回復不可能な構文エラーが発生した場合のためのマクロで、
     実行するとただちに`yyparse'が1を返します。
     エラー報告関数`yyerror'は呼び出されません。 *Note The Parser
     Function `yyparse': Parser Function。

`YYACCEPT'
     構文解析器が言語を完全に読み終えた場合のためのマクロで、
     実行するとただちに`yyparse'が0を返します。 *Note The Parser
     Function `yyparse': Parser Function。

`YYBACKUP'
     構文解析器のスタックから1個の値を捨て、先読みトークンのふりをさせます。
     *Note Special Features for Use in Actions: Action Features。

`YYERROR'
     構文エラーがちょうど検出された場合のためのマクロで、
     `yyerror'を呼び、可能ならば通常のエラー回復処理 （*note Error
     Recovery::）を実行し、不可能ならば `yyparse'が1を返します。 *Note
     Error Recovery::。

`YYERROR_VERBOSE'
     Bison宣言部で`#define'によってこのマクロを定義すると、
     `yyerror'が呼ばれたときに表示されるエラー報告が詳しくなります。

`YYINITDEPTH'
     構文解析器スタックの最初の大きさを指定するマクロです。 *Note Stack
     Overflow::。

`YYLEX_PARAM'
     `yyparse'が`yylex'に渡すための、追加の引数または
     引数の並びを指定するためのマクロです。 *Note Calling Conventions
     for Pure Parsers: Pure Calling。

`YYLTYPE'
     `yyloc'のデータ型を示すマクロで、4個のメンバからなる構造体です。
     *Note Textual Positions of Tokens: Token Positions。

`yyltype'
     `YYLTYPE'の省略時の値です。

`YYMAXDEPTH'
     構文解析器のスタックの最大の大きさを指定するマクロです。 *Note
     Stack Overflow::。

`YYPARSE_PARAM'
     `yyparse'が受け取るべき引数の名前を指定するマクロです。 *Note
     Calling Conventions for Pure Parsers: Pure Calling。

`YYRECOVERING'
     構文解析器が構文エラーから回復している途中かどうかを示す値のマクロです。
     *Note Special Features for Use in Actions: Action Features。

`YYSTYPE'
     意味値のデータ型を指定するためのマクロで、省略すると`int'になります。
     *Note Data Types of Semantic Values: Value Type。

`yychar'
     広域的な`int'型の変数で、現在の先読みトークンの番号を記憶しています
     （再入可能な構文解析器では、この変数は`yyparse'に局所的です）。
     エラー回復規則のアクションは、この変数の値を調べられます。 *Note
     Special Features for Use in Actions: Action Features。

`yyclearin'
     エラー回復規則のアクションで使われるマクロです。
     直前の先読みトークンを消去します。 *Note Error Recovery::。

`yydebug'
     `int'型の広域変数で、初期値は0です。
     `yydebug'の値が0でないと、構文解析器は、
     読み込んだ記号と構文解析器のアクションに関する情報を表示します。
     *Note Debugging Your Parser: Debugging。

`yyerrok'
     構文エラーの後で、構文解析器をただちに通常の状態に戻すためのマクロです。
     *Note Error Recovery::。

`yyerror'
     エラーが起きたときに`yyparse'から呼び出される、ユーザー定義関数です。
     この関数は1個の引数を受け取り、その引数はエラーの報告を含む文字列への
     ポインタです。 *Note The Error Reporting Function `yyerror': Error
     Reporting。

`yylex'
     ユーザー定義の字句解析関数で、次のトークンを得るために、
     引数なしで呼び出されます。 *Note The Lexical Analyzer Function
     `yylex': Lexical。

`yylval'
     トークンに関連する意味値を`yylex'が置くための広域変数です
     （再入可能な構文解析器では、これは`yyparse'の局所変数で、
     その番地が`yylex'に渡されます）。 *Note Semantic Values of Tokens:
     Token Values。

`yylloc'
     トークンに関連する行番号と桁番号を`yylex'が置くための
     広域変数です（再入可能な構文解析器では、この変数は`yyparse'に
     局所的で、その番地が`yylex'に渡されます）。
     文法アクションで`@'機能を使わないならば、
     この値を無視してかまいません。 *Note Textual Positions of Tokens:
     Token Positions。

`yynerrs'
     構文エラーが発生するたびにBisonが値を1増やす広域変数です
     （再入可能な構文解析器では、この変数は`yyparse'に局所的です）。
     *Note The Error Reporting Function `yyerror': Error Reporting。

`yyparse'
     Bisonによって生成される構文解析器関数で、
     この関数を呼び出すことによって構文解析が始まります。 *Note The
     Parser Function `yyparse': Parser Function。

`%left'
     トークンに左結合性を与えるBison宣言です。 *Note Operator
     Precedence: Precedence Decl。

`%no_lines'
     構文解析器ファイルの中に`#line'ディレクティブを生成しないための
     Bison宣言です。 *Note Decl Summary::。

`%nonassoc'
     トークンに非結合性を与えるためのBison宣言です。 *Note Operator
     Precedence: Precedence Decl。

`%prec'
     指定された規則に優先順位を与えるためのBison宣言です。 *Note
     Context-Dependent Precedence: Contextual Precedence。

`%pure_parser'
     再入可能な構文解析器を生成するためのBison宣言です。 *Note A Pure
     (Reentrant) Parser: Pure Decl。

`%raw'
     通常のYacc互換トークン番号の代わりに、
     トークン表のBison内部トークン番号を使うための、Bison宣言です。
     *Note Decl Summary::。

`%right'
     トークンに右結合性を与えるためのBison宣言です。 *Note Operator
     Precedence: Precedence Decl。

`%start'
     開始記号を指定するためのBison宣言です。 *Note The Start-Symbol:
     Start Decl。

`%token'
     優先順位を指定せずにトークンを宣言するためのBison宣言です。 *Note
     Token Type Names: Token Decl。

`%token_table'
     構文解析器ファイルの中でトークン名の表を挿入するためのBison宣言です。
     *Note Decl Summary::。

`%type'
     非終端記号を宣言するためのBison宣言です。 *Note Nonterminal
     Symbols: Type Decl。

`%union'
     意味値として可能ないくつかのデータ型を指定するためのBison宣言です。
     *Note The Collection of Value Types: Union Decl.

   Bison文法ファイルの中で使う、区切り記号があります。

`%%'
     Bison宣言部、文法規則部、（省略可能な）Cプログラム部を区切る記号です。
     *Note The Overall Layout of a Bison Grammar: Grammar Layout。

`%{ %}'
     文法ファイルの`%{'と`%}'の間に書かれたすべてのプログラムは、
     そのまま構文解析器ファイルに複写されます。
     このようなプログラムが、文法ファイルのC宣言部を構成します。 *Note
     Outline of a Bison Grammar: Grammar Outline。

`/*...*/'
     C言語と同様のコメントです。

`:'
     規則の結果と構成要素を分離する記号です。 *Note Syntax of Grammar
     Rules: Rules。

`;'
     規則の終わりの記号です。 *Note Syntax of Grammar Rules: Rules。

`|'
     同一の非終端記号を結果とする複数の規則を区切る記号です。 *Note
     Syntax of Grammar Rules: Rules。


File: bison-ja.info,  Node: Glossary,  Next: Index,  Prev: Table of Symbols,  Up: Top

Appendix B 用語集
*****************

Backus-Naur Form（BNF）（バッカス-ナウア記法）
     文脈自由文法を形式的に表現する方法です。
     BNFは、1963年の報告`ALGOL-60'で初めて使われました。 *Note
     Languages and Context-Free Grammars: Language and Grammar。

Context-free grammars（文脈自由文法）
     文脈に関係なく適用される規則によって定められる文法です。
     したがって、もし、整数は式として使われてもよいという規則があれば、
     式が許される_あらゆる場所で_整数の利用が許されます。 *Note
     Languages and Context-Free Grammars: Language and Grammar。

Dynamic allocation（動的割り当て）
     プログラムをコンパイルするときでも、関数の実行を始めるときでもなく、
     実行の途中でメモリを割り当てることです。

Empty string（空文字列）
     集合論での空集合と同様に、空文字列とは長さが0の文字列です。

Finite-state stack machine（有限状態スタック機械）
     その完全な状態が、各瞬間での状態で記述される「機械」です。
     機械への入力が処理されると、機械の論理に応じて、
     機械の状態が別の状態に変わります。
     本書では、入力とは構文解析されている言語で、
     状態とは文法規則のさまざまな段階です。 *Note The Bison Parser
     Algorithm: Algorithm。

Grouping（グループ）
     言語の構成要素で、（一般的に）文法的に分割可能なのもです。
     たとえば、C言語の「式」や「宣言」です。 *Note Languages and
     Context-Free Grammars: Language and Grammar。

Infix operator（中間記法演算子）
     演算の対象となるオペランドの中間に置かれる算術演算子です。

Input stream（入力ストリーム）
     入出力装置またはプログラムの間での、連続的なデータの流れです。

Language construct（言語構文）
     言語の概要を示す典型的な方法の1つです。
     たとえば、C言語の構文の1つは`if'文です。 *Note Languages and
     Context-Free Grammars: Language and Grammar。

Left associativity（左結合性）
     左結合性を持つ演算子は、左から右に向かって構文解析されます。
     たとえば、`a+b+c'では、まず`a+b'が計算され、
     次に`c'との和が計算されます。 *Note Operator Precedence:
     Precedence。

Left recursion（左再帰）
     結果の記号が構成要素の最初の記号と等しいような規則です。
     たとえば、`expseq1 : expseq1 ',' exp;'が左再帰です。 *Note
     Recursive Rules: Recursion。

Left-to-right parsing（LR構文解析）
     左側から右側に向かって、トークンを次々に解析していくような、
     言語の構文解析方法です。 *Note The Bison Parser Algorithm:
     Algorithm。

Lexical analyzer（scanner）（字句解析器）
     入力ストリームを読んで、トークンを1つずつ返す関数です。 *Note The
     Lexical Analyzer Function `yylex': Lexical。

Lexical tie-in（字句解析結び付き）
     文法規則によって設定されるフラグが、トークンが字句解析される方法に
     影響することです。 *Note Lexical Tie-ins::。

Literal string token（リテラル文字列トークン）
     2文字以上の決まった文字列からなるトークンです。 *Note Symbols::。

Look-ahead token（先読みトークン）
     すでに読み込まれていて、シフトされていないトークンです。 *Note
     Look-Ahead Tokens: Look-Ahead。

LALR(1)
     Bison（または似ているほとんどの構文解析器）によって扱える、
     文脈自由文法の一部分で、LR(1)の部分集合です。 *Note Mysterious
     Reduce/Reduce Conflicts: Mystery Conflicts。

LR(1)
     任意の入力のあいまいでない構文解析に対して、
     単に1個の先読みトークンを必要とするような、
     文脈自由文法の一部分です。

Nonterminal symbol（非終端記号）
     文法的構成要素を表す文法記号で、文法規則によってより小さな構成要素に
     分解できるものです。言い換えると、トークンでない構成要素です。
     *Note Symbols::。

Parse error（構文エラー）
     入力ストリームを構文解析しているときに、誤った文法によって発生するエラーです。
     *Note Error Recovery::。

Parser（構文解析器）
     字句解析器から渡されたトークンの集合の文法的構造を解析して、
     言語の有効な文を認識する関数です。

Postfix operator（後置演算子）
     演算の対象のオペランドの後に置かれる算術演算子です。

Reduction（還元）
     文法規則に従って、非終端記号または終端記号の列を、
     1個の非終端記号に置き換えることです。 *Note The Bison Parser
     Algorithm: Algorithm。

Reentrant（再入可能）
     再入可能な手続きとは、複数の呼び出しの間での相互作用なしに、
     並行して任意の数を呼び出せる手続きです。 (1) *Note A Pure
     (Reentrant) Parser: Pure Decl。

Reverse polish notation（逆ポーランド記法）
     すべての演算子が後置記法演算子であるような言語です。

Right recursion（右再帰）
     規則の結果の記号が、規則の最後の構成要素と同じ記号であるような規則です。
     たとえば、`expseq1: exp ',' expseq1;'は右再帰です。 *Note
     Recursive Rules: Recursion.

Semantics（意味）
     計算機言語では、言語の各インスタンスが起こすアクションによって、
     意味が指定されます。すなわち、各文の意味です。 *Note Defining
     Language Semantics: Semantics。

Shift（シフト）
     構文解析器がシフトするとは、
     すでに認識されているある規則によってただちに還元する代わりに、
     ストリームからのさらなる入力を分析することです。 *Note The Bison
     Parser Algorithm: Algorithm。

Single-character literal（1文字リテラル）
     そのままに解釈される(2)1文字です。 *Note From Formal Rules to
     Bison Input: Grammar in Bison。

Start symbol（開始記号）
     構文解析された有効な言語の全体を表す非終端記号です。
     通常、言語仕様に書かれた最初の非終端記号です。 *Note The
     Start-Symbol: Start Decl。

Symbol table（記号表）
     繰り返し使われる記号の情報を認識して使うために、
     構文解析の途中で、記号の名前と関連する情報を記憶するデータ構造です。
     *Note Multi-function Calc::。

Token（トークン）
     言語の、基本的で、文法的に分割できない単位です。
     文法の中のトークンを記述する記号を終端記号といいます。
     Bison構文解析器の入力は、字句解析器からの、 トークンの流れです。
     *Note Symbols::。

Terminal symbol（終端記号）
     文法規則を持たず、したがって文法的に分割できない文法記号です。
     これが表す文字の集まりをトークンといいます。 *Note Languages and
     Context-Free Grammars: Language and Grammar。

   ---------- Footnotes ----------

   (1) 【訳注】ある関数が終了する前に、
その同じ関数を非同期に呼び出してもよいということ。

   (2) 【訳注】字句解析器によって


File: bison-ja.info,  Node: Index,  Prev: Glossary,  Up: Top

索引
****

 [index ]
* Menu:

* $$:                                    Actions.             (line   6)
* $N:                                    Actions.             (line   6)
* %expect:                               Expect Decl.         (line   6)
* %left:                                 Using Precedence.    (line   6)
* %nonassoc:                             Using Precedence.    (line   6)
* %prec:                                 Contextual Precedence.
                                                              (line   6)
* %pure_parser:                          Pure Decl.           (line   6)
* %right:                                Using Precedence.    (line   6)
* %start:                                Start Decl.          (line   6)
* %token:                                Token Decl.          (line   6)
* %type:                                 Type Decl.           (line   6)
* %union:                                Union Decl.          (line   6)
* 1文字リテラル:                         Symbols.             (line  34)
* @N:                                    Action Features.     (line  78)
* action:                                Actions.             (line   6)
* action data types:                     Action Types.        (line   6)
* action fetures summary:                Action Features.     (line   6)
* actions in mid-rule:                   Mid-Rule Actions.    (line   6)
* actions, semantic:                     Semantic Actions.    (line   6)
* additional C code section:             C Code.              (line   6)
* algorithm of parser:                   Algorithm.           (line   6)
* associativity:                         Why Precedence.      (line  39)
* Backus-Naur form:                      Language and Grammar.
                                                              (line  17)
* Bison declaration summary:             Decl Summary.        (line   6)
* Bison declarations:                    Declarations.        (line   6)
* Bison declarations (introduction):     Bison Declarations.  (line   6)
* Bison grammar:                         Grammar in Bison.    (line   6)
* Bison invocation:                      Invocation.          (line   6)
* Bison parser:                          Bison Parser.        (line   6)
* Bison parser algorithm:                Algorithm.           (line   6)
* Bison symbols, table of:               Table of Symbols.    (line   6)
* Bison utility:                         Bison Parser.        (line   6)
* Bison 文法:                            Grammar in Bison.    (line   6)
* Bisonの記号一覧:                       Table of Symbols.    (line   6)
* Bisonの使用方法:                       Stages.              (line   6)
* Bisonの実行 <1>:                       Invocation.          (line   6)
* Bisonの実行:                           Rpcalc Gen.          (line   6)
* Bisonユーティリティ:                   Bison Parser.        (line   6)
* Bison構文解析器:                       Bison Parser.        (line   6)
* Bison構文解析器のアルゴリズム:         Algorithm.           (line   6)
* Bison実行のオプション:                 Invocation.          (line   6)
* Bison宣言:                             Declarations.        (line   6)
* Bison宣言（導入）:                     Bison Declarations.  (line   6)
* Bison宣言の要約:                       Decl Summary.        (line   6)
* BNF:                                   Language and Grammar.
                                                              (line  17)
* C code, section for additional:        C Code.              (line   6)
* C declarations section:                C Declarations.      (line   6)
* C-language interface:                  Interface.           (line   6)
* calc:                                  Infix Calc.          (line   6)
* calculator, infix notation:            Infix Calc.          (line   6)
* calculator, multi-function:            Multi-function Calc. (line   6)
* calculator, simple:                    RPN Calc.            (line   6)
* character token:                       Symbols.             (line  34)
* compiling the parser:                  Rpcalc Compile.      (line   6)
* conflicts:                             Shift/Reduce.        (line   6)
* conflicts, reduce/reduce:              Reduce/Reduce.       (line   6)
* conflicts, suppressing warnings of:    Expect Decl.         (line   6)
* context-dependent precedence:          Contextual Precedence.
                                                              (line   6)
* context-free grammar:                  Language and Grammar.
                                                              (line   6)
* controlling function:                  Rpcalc Main.         (line   6)
* Cプログラム, 追加の:                   C Code.              (line   6)
* C言語インターフェイス:                 Interface.           (line   6)
* C宣言部:                               C Declarations.      (line   6)
* dangling else:                         Shift/Reduce.        (line   6)
* data types in actions:                 Action Types.        (line   6)
* data types of semantic values:         Value Type.          (line   6)
* debugging:                             Debugging.           (line   6)
* declaration summary:                   Decl Summary.        (line   6)
* declarations, Bison:                   Declarations.        (line   6)
* declarations, Bison (introduction):    Bison Declarations.  (line   6)
* declarations, C:                       C Declarations.      (line   6)
* declaring literal string tokens:       Token Decl.          (line   6)
* declaring operator precedence:         Precedence Decl.     (line   6)
* declaring the start symbol:            Start Decl.          (line   6)
* declaring token type names:            Token Decl.          (line   6)
* declaring value types:                 Union Decl.          (line   6)
* declaring value types, nonterminals:   Type Decl.           (line   6)
* default action:                        Actions.             (line  38)
* default data type:                     Value Type.          (line   6)
* default stack limit:                   Stack Overflow.      (line  26)
* default start symbol:                  Start Decl.          (line   6)
* defining language semantics:           Semantics.           (line   6)
* else, dangling:                        Shift/Reduce.        (line   6)
* else, ぶらさがり:                      Shift/Reduce.        (line   6)
* error <1>:                             Grammar in Bison.    (line  22)
* error:                                 Error Recovery.      (line  20)
* error recovery:                        Error Recovery.      (line   6)
* error recovery, simple:                Simple Error Recovery.
                                                              (line   6)
* error reporting function:              Error Reporting.     (line   6)
* error reporting routine:               Rpcalc Error.        (line   6)
* examples, simple:                      Examples.            (line   6)
* exercises:                             Exercises.           (line   6)
* file format:                           Grammar Layout.      (line   6)
* finite-state machine:                  Parser States.       (line   6)
* formal grammar:                        Grammar in Bison.    (line   6)
* format of grammar file:                Grammar Layout.      (line   6)
* glossary:                              Glossary.            (line   6)
* grammar file:                          Grammar Layout.      (line   6)
* grammar rule syntax:                   Rules.               (line   6)
* grammar rules section:                 Grammar Rules.       (line   6)
* grammar, Bison:                        Grammar in Bison.    (line   6)
* grammar, context-free:                 Language and Grammar.
                                                              (line   6)
* grouping, syntactic:                   Language and Grammar.
                                                              (line  33)
* infix notation calculator:             Infix Calc.          (line   6)
* interface:                             Interface.           (line   6)
* introduction:                          Introduction.        (line   6)
* invoking Bison:                        Invocation.          (line   6)
* invoking Bison under VMS:              VMS Invocation.      (line   6)
* LALR(1):                               Mystery Conflicts.   (line  36)
* language semantics, defining:          Semantics.           (line   6)
* layout of Bison grammar:               Grammar Layout.      (line   6)
* left recursion:                        Recursion.           (line  17)
* lexical analyzer:                      Lexical.             (line   6)
* lexical analyzer, purpose:             Bison Parser.        (line   6)
* lexical analyzer, writing:             Rpcalc Lexer.        (line   6)
* lexical tie-in:                        Lexical Tie-ins.     (line   6)
* literal string token:                  Symbols.             (line  55)
* literal token:                         Symbols.             (line  34)
* look-ahead token:                      Look-Ahead.          (line   6)
* LR(1):                                 Mystery Conflicts.   (line  36)
* main function in simple example:       Rpcalc Main.         (line   6)
* main関数:                              Rpcalc Main.         (line   6)
* mfcalc:                                Multi-function Calc. (line   6)
* mid-rule actions:                      Mid-Rule Actions.    (line   6)
* multi-character literal:               Symbols.             (line  55)
* multi-function calculator:             Multi-function Calc. (line   6)
* mutual recursion:                      Recursion.           (line  32)
* nonterminal symbol:                    Symbols.             (line   6)
* operator precedence:                   Precedence.          (line   6)
* operator precedence, declaring:        Precedence Decl.     (line   6)
* options for invoking Bison:            Invocation.          (line   6)
* overflow of parser stack:              Stack Overflow.      (line   6)
* parse error:                           Error Reporting.     (line   6)
* parser:                                Bison Parser.        (line   6)
* parser stack:                          Algorithm.           (line   6)
* parser stack overflow:                 Stack Overflow.      (line   6)
* parser state:                          Parser States.       (line   6)
* polish notation calculator:            RPN Calc.            (line   6)
* precedence declarations:               Precedence Decl.     (line   6)
* precedence of operators:               Precedence.          (line   6)
* precedence, context-dependent:         Contextual Precedence.
                                                              (line   6)
* precedence, unary operator:            Contextual Precedence.
                                                              (line   6)
* preventing warnings about conflicts:   Expect Decl.         (line   6)
* pure parser:                           Pure Decl.           (line   6)
* recovery from errors:                  Error Recovery.      (line   6)
* recursive rule:                        Recursion.           (line   6)
* reduce/reduce conflict:                Reduce/Reduce.       (line   6)
* reduction:                             Algorithm.           (line   6)
* reentrant parser:                      Pure Decl.           (line   6)
* reverse polish notation:               RPN Calc.            (line   6)
* right recursion:                       Recursion.           (line  17)
* rpcalc:                                RPN Calc.            (line   6)
* rule syntax:                           Rules.               (line   6)
* rules section for grammar:             Grammar Rules.       (line   6)
* running Bison (introduction):          Rpcalc Gen.          (line   6)
* semantic actions:                      Semantic Actions.    (line   6)
* semantic value:                        Semantic Values.     (line   6)
* semantic value type:                   Value Type.          (line   6)
* shift/reduce conflicts:                Shift/Reduce.        (line   6)
* shifting:                              Algorithm.           (line   6)
* simple examples:                       Examples.            (line   6)
* single-character literal:              Symbols.             (line  34)
* stack overflow:                        Stack Overflow.      (line   6)
* stack, parser:                         Algorithm.           (line   6)
* stages in using Bison:                 Stages.              (line   6)
* start symbol:                          Language and Grammar.
                                                              (line  81)
* start symbol, declaring:               Start Decl.          (line   6)
* state (of parser):                     Parser States.       (line   6)
* string token:                          Symbols.             (line  55)
* summary, action features:              Action Features.     (line   6)
* summary, Bison declaration:            Decl Summary.        (line   6)
* suppressing conflict warnings:         Expect Decl.         (line   6)
* symbol:                                Symbols.             (line   6)
* symbol table example:                  Mfcalc Symtab.       (line   6)
* symbols (abstract):                    Language and Grammar.
                                                              (line  33)
* symbols in Bison, table of:            Table of Symbols.    (line   6)
* syntactic grouping:                    Language and Grammar.
                                                              (line  33)
* syntax error:                          Error Reporting.     (line   6)
* syntax of grammar rules:               Rules.               (line   6)
* terminal symbol:                       Symbols.             (line   6)
* token:                                 Language and Grammar.
                                                              (line  33)
* token type:                            Symbols.             (line   6)
* token type names, declaring:           Token Decl.          (line   6)
* tracing the parser:                    Debugging.           (line   6)
* unary operator precedence:             Contextual Precedence.
                                                              (line   6)
* using Bison:                           Stages.              (line   6)
* value type, semantic:                  Value Type.          (line   6)
* value types, declaring:                Union Decl.          (line   6)
* value types, nonterminals, declaring:  Type Decl.           (line   6)
* value, semantic:                       Semantic Values.     (line   6)
* VMS:                                   VMS Invocation.      (line   6)
* warnings, preventing:                  Expect Decl.         (line   6)
* writing a lexical analyzer:            Rpcalc Lexer.        (line   6)
* YYABORT:                               Parser Function.     (line  25)
* YYACCEPT:                              Parser Function.     (line  22)
* YYBACKUP:                              Action Features.     (line  36)
* yychar:                                Look-Ahead.          (line  51)
* yyclearin:                             Error Recovery.      (line  99)
* YYDEBUG:                               Debugging.           (line   6)
* yydebug:                               Debugging.           (line   6)
* YYEMPTY:                               Action Features.     (line  49)
* yyerrok:                               Error Recovery.      (line  93)
* YYERROR:                               Action Features.     (line  52)
* yyerror:                               Error Reporting.     (line   6)
* YYERROR_VERBOSE:                       Error Reporting.     (line  18)
* YYINITDEPTH:                           Stack Overflow.      (line  28)
* yylex:                                 Lexical.             (line   6)
* YYLEX_PARAM:                           Pure Calling.        (line  71)
* yylloc:                                Token Positions.     (line   6)
* YYLTYPE:                               Token Positions.     (line  19)
* yylval:                                Token Values.        (line   6)
* YYMAXDEPTH:                            Stack Overflow.      (line  11)
* yynerrs:                               Error Reporting.     (line  43)
* yyparse:                               Parser Function.     (line   6)
* YYPARSE_PARAM:                         Pure Calling.        (line  29)
* YYPRINT:                               Debugging.           (line  60)
* YYRECOVERING:                          Error Recovery.      (line 109)
* |:                                     Rules.               (line  34)
* ぶらさがりelse:                        Shift/Reduce.        (line   6)
* まえがき:                              Introduction.        (line   6)
* アクション <1>:                        Actions.             (line   6)
* アクション:                            Semantic Actions.    (line   6)
* アクション, 規則の途中:                Mid-Rule Actions.    (line   6)
* アクションのデータ型:                  Action Types.        (line   6)
* アクションの要約:                      Action Features.     (line   6)
* インターフェイス:                      Interface.           (line   6)
* エラーからの回復:                      Error Recovery.      (line   6)
* エラー回復:                            Simple Error Recovery.
                                                              (line   6)
* エラー報告関数 <1>:                    Error Reporting.     (line   6)
* エラー報告関数:                        Rpcalc Error.        (line   6)
* オーバーフロー, 構文解析器のスタック:  Stack Overflow.      (line   6)
* オプション, Bison実行:                 Invocation.          (line   6)
* グループ:                              Language and Grammar.
                                                              (line  33)
* コンパイル:                            Rpcalc Compile.      (line   6)
* シンボル:                              Language and Grammar.
                                                              (line  33)
* シフト:                                Algorithm.           (line   6)
* シフト還元衝突:                        Shift/Reduce.        (line   6)
* スタック, 構文解析器:                  Algorithm.           (line   6)
* スタックの限界, 省略時:                Stack Overflow.      (line  26)
* スタックオーバーフロー:                Stack Overflow.      (line   6)
* データ型, アクション:                  Action Types.        (line   6)
* トークン:                              Language and Grammar.
                                                              (line  33)
* トークン型:                            Symbols.             (line   6)
* トークン型名, 宣言:                    Token Decl.          (line   6)
* トークン型名の宣言:                    Token Decl.          (line   6)
* リテラルトークン:                      Symbols.             (line  34)
* リテラル文字列トークン:                Symbols.             (line  55)
* リテラル文字列トークンの宣言:          Token Decl.          (line   6)
* バッカス-ナウア記法:                   Language and Grammar.
                                                              (line  17)
* ファイル書式:                          Grammar Layout.      (line   6)
* 意味アクション:                        Semantic Actions.    (line   6)
* 意味値:                                Semantic Values.     (line   6)
* 意味値のデータ型:                      Value Type.          (line   6)
* 意味値型:                              Value Type.          (line   6)
* 右再帰:                                Recursion.           (line  17)
* 演算子の優先順位 <1>:                  Precedence.          (line   6)
* 演算子の優先順位:                      Precedence Decl.     (line   6)
* 回避, 衝突警告:                        Expect Decl.         (line   6)
* 回復:                                  Error Recovery.      (line   6)
* 開始記号:                              Language and Grammar.
                                                              (line  81)
* 開始記号の宣言:                        Start Decl.          (line   6)
* 還元:                                  Algorithm.           (line   6)
* 還元/還元衝突:                         Reduce/Reduce.       (line   6)
* 規則の構文:                            Rules.               (line   6)
* 規則の途中のアクション:                Mid-Rule Actions.    (line   6)
* 規則部,文法に対する:                   Grammar Rules.       (line   6)
* 記号 <1>:                              Symbols.             (line   6)
* 記号:                                  Language and Grammar.
                                                              (line  33)
* 記号一覧, Bison:                       Table of Symbols.    (line   6)
* 記号表の例:                            Mfcalc Symtab.       (line   6)
* 逆ポーランド記法:                      RPN Calc.            (line   6)
* 形式文法:                              Grammar in Bison.    (line   6)
* 結合性:                                Why Precedence.      (line  39)
* 警告, 衝突:                            Expect Decl.         (line   6)
* 言語の意味の定義:                      Semantics.           (line   6)
* 構文, 文法規則:                        Rules.               (line   6)
* 構文解析エラー:                        Error Reporting.     (line   6)
* 構文解析器:                            Bison Parser.        (line   6)
* 構文解析器のスタック:                  Algorithm.           (line   6)
* 構文解析器のスタックオーバーフロー:    Stack Overflow.      (line   6)
* 構文解析器の状態:                      Parser States.       (line   6)
* 構文解析器の追跡:                      Debugging.           (line   6)
* 左再帰:                                Recursion.           (line  17)
* 再帰的規則:                            Recursion.           (line   6)
* 再入可能構文解析器:                    Pure Decl.           (line   6)
* 使用方法:                              Stages.              (line   6)
* 字句解析器 <1>:                        Rpcalc Lexer.        (line   6)
* 字句解析器 <2>:                        Bison Parser.        (line   6)
* 字句解析器:                            Lexical.             (line   6)
* 字句解析結び付き:                      Lexical Tie-ins.     (line   6)
* 実行, Bison:                           Invocation.          (line   6)
* 実行, VMS上:                           VMS Invocation.      (line   6)
* 終端記号 <1>:                          Symbols.             (line   6)
* 終端記号:                              Language and Grammar.
                                                              (line  33)
* 純粋構文解析器:                        Pure Decl.           (line   6)
* 衝突:                                  Shift/Reduce.        (line   6)
* 衝突, 還元/還元:                       Reduce/Reduce.       (line   6)
* 衝突, 警告の回避:                      Expect Decl.         (line   6)
* 衝突警告の回避:                        Expect Decl.         (line   6)
* 省略時のスタックの限界:                Stack Overflow.      (line  26)
* 省略時アクション:                      Actions.             (line  38)
* 省略時データ型:                        Value Type.          (line   6)
* 省略時開始記号:                        Start Decl.          (line   6)
* 状態, 構文解析器:                      Parser States.       (line   6)
* 制御関数:                              Rpcalc Main.         (line   6)
* 先読みトークン:                        Look-Ahead.          (line   6)
* 宣言, Bison:                           Declarations.        (line   6)
* 宣言, Bison（導入）:                   Bison Declarations.  (line   6)
* 宣言, C:                               C Declarations.      (line   6)
* 宣言, 演算子の優先順位:                Precedence Decl.     (line   6)
* 宣言, 開始記号:                        Start Decl.          (line   6)
* 宣言, 値型:                            Union Decl.          (line   6)
* 宣言, 非終端記号の値型:                Type Decl.           (line   6)
* 宣言の要約:                            Decl Summary.        (line   6)
* 相互再帰:                              Recursion.           (line  32)
* 多機能電卓:                            Multi-function Calc. (line   6)
* 単項演算子の優先順位:                  Contextual Precedence.
                                                              (line   6)
* 単純な例:                              Examples.            (line   6)
* 単純な例のmain関数:                    Rpcalc Main.         (line   6)
* 中間記法:                              Infix Calc.          (line   6)
* 値:                                    Semantic Values.     (line   6)
* 値型, 意味:                            Value Type.          (line   6)
* 値型の宣言:                            Union Decl.          (line   6)
* 値型の宣言, 非終端記号:                Type Decl.           (line   6)
* 追加のCプログラム部:                   C Code.              (line   6)
* 追跡, 構文解析器:                      Debugging.           (line   6)
* 定義, 言語の意味:                      Semantics.           (line   6)
* 電卓:                                  RPN Calc.            (line   6)
* 電卓, 多機能:                          Multi-function Calc. (line   6)
* 非終端記号 <1>:                        Language and Grammar.
                                                              (line  33)
* 非終端記号:                            Symbols.             (line   6)
* 非終端記号, 値型の宣言:                Type Decl.           (line   6)
* 複数文字リテラル:                      Symbols.             (line  55)
* 文字トークン:                          Symbols.             (line  34)
* 文字列トークン:                        Symbols.             (line  55)
* 文法:                                  Language and Grammar.
                                                              (line   6)
* 文法エラー:                            Error Reporting.     (line   6)
* 文法グループ:                          Language and Grammar.
                                                              (line  33)
* 文法ファイル:                          Grammar Layout.      (line   6)
* 文法規則の構文:                        Rules.               (line   6)
* 文法規則部:                            Grammar Rules.       (line   6)
* 文脈依存優先順位:                      Contextual Precedence.
                                                              (line   6)
* 文脈自由文法:                          Language and Grammar.
                                                              (line   6)
* 優先順位, 演算子:                      Precedence.          (line   6)
* 優先順位, 単項演算子:                  Contextual Precedence.
                                                              (line   6)
* 優先順位, 文脈依存:                    Contextual Precedence.
                                                              (line   6)
* 優先順位宣言:                          Precedence Decl.     (line   6)
* 有限状態機械:                          Parser States.       (line   6)
* 要約, Bison宣言:                       Decl Summary.        (line   6)
* 要約, アクション:                      Action Features.     (line   6)
* 用語集:                                Glossary.            (line   6)
* 例:                                    Examples.            (line   6)
* 練習問題:                              Exercises.           (line   6)



Tag Table:
Node: Top1318
Node: Introduction7703
Ref: Introduction-Footnote-19551
Node: Conditions9626
Node: Copying11094
Node: Concepts30255
Node: Language and Grammar31162
Node: Grammar in Bison35526
Node: Semantic Values37282
Node: Semantic Actions39155
Node: Bison Parser40138
Node: Stages42265
Node: Grammar Layout43474
Ref: Grammar Layout-Footnote-144645
Node: Examples44690
Node: RPN Calc45610
Node: Rpcalc Decls46421
Node: Rpcalc Rules47734
Node: Rpcalc Input49309
Ref: Rpcalc Input-Footnote-150670
Node: Rpcalc Line50780
Node: Rpcalc Expr51751
Node: Rpcalc Lexer53517
Node: Rpcalc Main55764
Ref: Rpcalc Main-Footnote-156133
Node: Rpcalc Error56429
Node: Rpcalc Gen57263
Node: Rpcalc Compile58395
Ref: Rpcalc Compile-Footnote-159343
Node: Infix Calc59418
Node: Simple Error Recovery61737
Node: Multi-function Calc63449
Ref: Multi-function Calc-Footnote-164792
Ref: Multi-function Calc-Footnote-264834
Node: Mfcalc Decl64871
Node: Mfcalc Rules66679
Node: Mfcalc Symtab68018
Node: Exercises73495
Node: Grammar File73972
Node: Grammar Outline74649
Node: C Declarations75319
Node: Bison Declarations75766
Node: Grammar Rules76104
Node: C Code76523
Node: Symbols77346
Ref: Symbols-Footnote-181968
Ref: Symbols-Footnote-282003
Node: Rules82035
Ref: Rules-Footnote-183598
Node: Recursion83655
Node: Semantics85128
Node: Value Type86022
Node: Multiple Types86633
Node: Actions87553
Node: Action Types89933
Node: Mid-Rule Actions91137
Node: Declarations96311
Node: Token Decl97474
Node: Precedence Decl99298
Node: Union Decl100843
Node: Type Decl101625
Node: Expect Decl102387
Node: Start Decl103735
Node: Pure Decl104022
Ref: Pure Decl-Footnote-1105564
Ref: Pure Decl-Footnote-2105654
Node: Decl Summary105760
Node: Multiple Parsers108817
Node: Interface110268
Node: Parser Function111098
Node: Lexical111892
Node: Calling Convention113205
Node: Token Values115759
Node: Token Positions116837
Node: Pure Calling117710
Node: Error Reporting120383
Node: Action Features122345
Ref: Action Features-Footnote-1125575
Node: Algorithm125652
Node: Look-Ahead127845
Node: Shift/Reduce129828
Node: Precedence132330
Node: Why Precedence132952
Node: Using Precedence134808
Node: Precedence Examples135607
Node: How Precedence136249
Node: Contextual Precedence137286
Node: Parser States138873
Node: Reduce/Reduce140085
Node: Mystery Conflicts143290
Node: Stack Overflow146405
Node: Error Recovery147753
Node: Context Dependency152248
Node: Semantic Tokens152987
Ref: Semantic Tokens-Footnote-1155863
Node: Lexical Tie-ins155892
Node: Tie-in Recovery157370
Node: Debugging159378
Node: Invocation162615
Node: Bison Options163313
Node: Option Cross Key167225
Node: VMS Invocation168103
Node: Table of Symbols168790
Node: Glossary175672
Ref: Glossary-Footnote-1181657
Ref: Glossary-Footnote-2181749
Node: Index181784

End Tag Table
