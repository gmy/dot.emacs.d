Info file: elisp-ja,    -*-Text-*-
produced by `texinfo-format-buffer'
from file `elisp.texi'
using `texinfmt.el' version 2.38 of 3 July 1998.


INFO-DIR-SECTION Editors
START-INFO-DIR-ENTRY
* Elisp-ja: (elisp-ja).	The Emacs Lisp Reference Manual(Japanese).
END-INFO-DIR-ENTRY



Emacs Lispリファレンスマニュアル2.5版であり, Emacs 20.3版に対応します.

Published by the Free Software Foundation 59 Temple Place, Suite 330
Boston, MA 02111-1307 USA

Copyright (C) 1990, 1991, 1992, 1993, 1994, 1995, 1996, 1998 Free
Software Foundation, Inc.

Permission is granted to make and distribute verbatim copies of this
manual provided the copyright notice and this permission notice are
preserved on all copies.

Permission is granted to copy and distribute modified versions of this
manual under the conditions for verbatim copying, provided that the
entire resulting derived work is distributed under the terms of a
permission notice identical to this one.

Permission is granted to copy and distribute translations of this
manual into another language, under the above conditions for modified
versions, except that this permission notice may be stated in a
translation approved by the Foundation.

Permission is granted to copy and distribute modified versions of this
manual under the conditions for verbatim copying, provided also that
the section entitled "GNU General Public License" is included exactly
as in the original, and provided that the entire resulting derived
work is distributed under the terms of a permission notice identical
to this one.

Permission is granted to copy and distribute translations of this
manual into another language, under the above conditions for modified
versions, except that the section entitled "GNU General Public
License" may be included in a translation approved by the Free
Software Foundation instead of in the original English.






File: elisp-ja, Node: List Motion, Next: Skipping Characters, Prev: Screen Lines, Up: Motion

式単位の移動
------------

ここでは, 釣り合った括弧で囲まれた式（Emacs内でそれらを単位に移動する
ときには"S式"（sexps）とも呼ばれる）を扱う関数について述べます.  構文
テーブルは, これらの関数がさまざまな文字をどのように解釈するかを制御し
ます.  *Note Syntax Tables::を参照してください.  S式やその一部を走査す
る下位レベルの基本関数については, *Note Parsing Expressions::.  ユーザー
レベルのコマンドに関しては, *Note リストとS式に対するコマンド:
(emacs-ja)List Commands.を参照してください。

 -- コマンド: forward-list ARG
     この関数は, 釣り合った括弧で囲まれたものをARG個前方へ飛び越えて移
     動する.  （単語や文字列のクォート対などの他の構文要素は無視す
     る. ）

 -- コマンド: backward-list ARG
     この関数は, 釣り合った括弧で囲まれたものをARG個後方へ飛び越えて移
     動する.  （単語や文字列のクォート対などの他の構文要素は無視す
     る. ）

 -- コマンド: up-list ARG
     この関数は, 前方へ向けてARG個の括弧のレベルを抜ける.  負の引数で
     は後方へ向けて浅いレベルへ移動する.

 -- コマンド: down-list ARG
     この関数は, 前方へ向けてARG個の括弧のレベルだけ深く入る.  負の引
     数では後方へ向けて括弧の深い（-ARG）レベルへ移動する.

 -- コマンド: forward-sexp ARG
     この関数は, ARG個の釣り合った式を前方へ向けて飛び越えて移動する. 
     釣り合った式には, 括弧で区切られたものに加えて, 単語や文字列定数
     などの他の種類も含まれる.  たとえばつぎのとおり.

          ---------- Buffer: foo ----------
          (concat-!- "foo " (car x) y z)
          ---------- Buffer: foo ----------

          (forward-sexp 3)
               => nil

          ---------- Buffer: foo ----------
          (concat "foo " (car x) y-!- z)
          ---------- Buffer: foo ----------

 -- コマンド: backward-sexp ARG
     この関数は, ARG個の釣り合った式を後方へ向けて飛び越えて移動する.

 -- コマンド: beginning-of-defun ARG
     この関数は, 前方へ向けてARG個目の関数定義の先頭へ移動する.  ARGが
     負であると, 後方へ向けて, 関数定義の末尾ではなく関数定義の先頭へ
     移動する.

 -- コマンド: end-of-defun ARG
     この関数は, 前方へ向けてARG個目の関数定義の末尾へ移動する.  ARGが
     負であると, 後方へ向けて, 関数定義の先頭ではなく関数定義の末尾へ
     移動する.

 -- User Option: defun-prompt-regexp
     この変数が`nil'以外であると, 関数定義を始める開き括弧のまえに現れ
     うるテキストを指定する正規表現を保持する.  つまり, 関数定義は, 行
     の先頭がこの正規表現に一致するテキストで始まり, それに開き括弧の
     構文に属する文字が続く行で始まる.



File: elisp-ja, Node: Skipping Characters, Next: Excursions, Prev: List Motion, Up: Motion

文字群の飛び越し
----------------

つぎの2つの関数は, 指定した種類の文字を飛び越えてポイントを移動します. 
たとえば, 白文字を飛び越すためにこれらはしばしば使われます.  関連する
関数については, *Note Motion and Syntax::を参照してください.

 -- Function: skip-chars-forward CHARACTER-SET &optional LIMIT
     この関数は, 指定した文字の集まりを飛び越えて, カレントバッファ内
     で前方にポイントを移動する.  ポイントのあとの文字を調べ, その文字
     がCHARACTER-SETに一致するとポイントを進める.  これをCHARACTER-SET
     に一致しない文字に達するまで繰り返す.  この関数は飛び越えた文字の
     個数を返す.

     引数CHARACTER-SETは, 正規表現の`[...]'の内側と同じであるが, `]'は
     特別扱いせず, `\'は`^'や`-'や`\'をクォートする.  したがって,
     `"a-zA-Z"'はすべての英文字を飛び越えて最初の英文字でない文字のま
     えで止まる.  `"^a-zA-Z"'は英文字でない文字を飛び越えて最初の英文
     字で止まる.  *Note Regular Expressions::.

     LIMITを指定すると（数かマーカであること）, ポイントを移動できるバッ
     ファ内の最大位置を指定する.  ポイントは, LIMITで止まるかLIMITに達
     するまえに止まる.

     つぎの例では, ポイントは最初は`T'の直前に位置している.  フォーム
     を評価後には, ポイントはその行末（`hat'の`t'と改行のあいだ）に位
     置している.  この関数は, すべての英文字と空白を飛び越えるが, 改行
     は飛び越えない.

          ---------- Buffer: foo ----------
          I read "-!-The cat in the hat
          comes back" twice.
          ---------- Buffer: foo ----------

          (skip-chars-forward "a-zA-Z ")
               => nil

          ---------- Buffer: foo ----------
          I read "The cat in the hat-!-
          comes back" twice.
          ---------- Buffer: foo ----------

 -- Function: skip-chars-backward CHARACTER-SET &optional LIMIT
     この関数は, LIMITに達するまで, 後方へ向かってCHARACTER-SETに一致
     する文字を飛び越えてポイントを移動する.  これは
     `skip-chars-forward'と同様であるが, 移動方向が異なる.

     移動距離を表す値を返す.  それは0以下の整数である.



File: elisp-ja, Node: Excursions, Next: Narrowing, Prev: Motion, Up: Positions

エクスカージョン
================

プログラムの局所的な部分で『一時的に』ポイントを移動したり, 一時的にバッ
ファを切り替えられるとしばしば有用です.  これを"エクスカージョン"
（excursion, 周遊）と呼び, スペシャルフォーム`save-excursion'で行いま
す.  この構文は, カレントバッファとそのポイントやマーカの値を保存し, 
エクスカージョンの完了後にそれらを復元します.

ウィンドウの構成を保存したり復元するフォームは, 別のところで述べてあり
ます（*Note Window Configurations::と*Note Frame Configurations::）.

 -- Special form: save-excursion FORMS...
     スペシャルフォーム`save-excursion'は, カレントバッファの識別子と
     そのポイントやマーカの値を保存し, FORMSを評価し, 最後に, バッファ
     と保存しておいたポイントやマーカの値を復元する.  `throw'やエラー
     による異常脱出（*Note Nonlocal Exits::）であっても, これらの保存
     した値を復元する.

     スペシャルフォーム`save-excursion'は, プログラムの一部分だけでバッ
     ファやポイントを移動しプログラムの他の部分への影響を防ぐ標準的な
     方法である.  EmacsのLispソースでは4000回以上も使われている.

     `save-excursion'は他のバッファのポイントやマークの値は保存しない
     ので, 他のバッファでの変更は`save-excursion'から抜けても持続する.

     同様に, `save-excursion'は, `switch-to-buffer'などの関数で変更さ
     れたウィンドウとバッファの対応関係は復元しない.  これらの対応関係
     や選択されているウィンドウを復元する1つの方法は, `save-excursion'
     の内側で`save-window-excursion'を使うことである（*Note Window
     Configurations::）.

     `save-excursion'の戻り値は, FORMSの最後の結果であるか, FORMSを与
     えなければ`nil'である.

          (save-excursion FORMS)
          ==
          (let ((old-buf (current-buffer))
                (old-pnt (point-marker))
                (old-mark (copy-marker (mark-marker))))
            (unwind-protect
                (progn FORMS)
              (set-buffer old-buf)
              (goto-char old-pnt)
              (set-marker (mark-marker) old-mark)))

  *警告：*` '保存されたポイント値の箇所に普通にテキストを挿入すると, 
すべてのマーカを再配置するように保存されたポイント値を再配置する.  し
たがって, 保存されたポイント値が復元されると, ポイントは挿入されたテキ
ストのまえに普通どおりにくる.

`save-excursion'はマーカの位置を保存しますが, バッファを変更する関数が
`deactivate-mark'を行うことを防ぎませんから, コマンドが終了するとマー
カが不活性になってしまいます.  *Note The Mark::.



File: elisp-ja, Node: Narrowing, Next: Markers, Prev: Excursions, Up: Positions

ナロイング
==========

"ナロイング"（narrowing）とは, Emacsの編集コマンドが参照できるテキスト
をバッファの制限された文字の範囲に限定することです.  参照できるテキス
トのことをバッファの"参照可能部分"（accessible portion）と呼びます.

ナロイングは, 参照可能部分の先頭と末尾になる2つのバッファ内位置で指定
します.  ほとんどの編集コマンドやほとんどのEmacs基本関数にとっては, こ
れらの位置はバッファの先頭や末尾の値を置き換えることになります.  ナロ
イングしていると, 参照可能部分の外側のテキストは表示されませんし, ポイ
ントは参照可能部分の外側へは移動できません.

通常はバッファの先頭から数える位置や行番号などの値はナロイングしていて
も同様に数えますが, それらを使う関数は参照できないテキストを操作するこ
とを拒否します.

バッファを保存するコマンドはナロイングの影響を受けません.  つまり, ナ
ロイングに関係なくバッファ全体を保存します.

 -- コマンド: narrow-to-region START END
     この関数は, カレントバッファのSTARTで始まりENDで終る部分を参照可
     能部分にする.  どちらの引数も文字の位置であること.

     対話的に呼び出されると, STARTとENDは現在のリージョンの境界（ポイ
     ントとマークの小さいほうがさきにくる）である.

 -- コマンド: narrow-to-page MOVE-COUNT
     このコマンドは, カレントバッファの参照可能部分を現在のページのみ
     を含むようにする.  省略可能な第1引数MOVE-COUNTが`nil'以外であると,
     MOVE-COUNTページだけ前方か後方へ移動してから1ページ分にナロイング
     する.  変数`page-delimiter'がページの開始箇所と終了箇所を指定する
     （*Note Standard Regexps::）.

     対話的に呼び出されると, MOVE-COUNTは数値前置引数である.

 -- コマンド: widen
     この関数は, カレントバッファのナロイングを解除し, 全体を参照でき
     るようにする.  これを"ワイドニング"（widening）と呼ぶ.  これはつ
     ぎの式と等価である.

          (narrow-to-region 1 (1+ (buffer-size)))

 -- Special form: save-restriction BODY...
     このスペシャルフォームは, 現在の参照可能部分の境界を保存し, フォー
     ムBODYを評価し, 最後に, 保存した境界を復元してまえと同じナロイン
     グ状態（あるいはナロイングなし）に復元する.  `throw'やエラーによ
     る異常脱出（*Note Nonlocal Exits::）であっても, ナロイング状態を
     復元する.

     `save-restriction'の戻り値は, BODYの最後の結果であるか, BODYを与
     えなければ`nil'である.

     *注意：*` '構文`save-restriction'を使うときにはまちがいやすい. 
     使うまえにこの説明全体を読むこと.

     BODYでカレントバッファを切り替えても`save-restriction'はもとのバッ
     ファ（バッファの制限を保存したバッファ）に制限を復元するが, もと
     のカレントバッファには戻さない.

     `save-restriction'はポイントやマークは復元*しない*.  それには
     `save-excursion'を使う.  `save-restriction'と`save-excursion'の両
     者を一緒に使うときには, `save-excursion'が先に（外側に）くること. 
     さもないと, 古いポイント値は一時的なナロイングが有効な状態で復元
     される.  古いポイント値が一時的なナロイングの範囲外にあると正しく
     復元できない.

     スペシャルフォーム`save-restriction'は, 参照可能部分の先頭と末尾
     をバッファの先頭と末尾からの距離として記録する.  いいかえれば, 参
     照可能部分の前後の参照できないテキストの量を記録する.

     この方法は, BODYでさらにナロイングしても正しい結果を生じる.  しか
     し, BODYでワイドニングして保存されているナロイングの範囲外を変更
     すると`save-restriction'が混乱する.  このようにしたいときには,
     `save-restriction'は正しい解法ではない.  つぎのようにする必要があ
     る.

          (let ((beg (point-min-marker))
                (end (point-max-marker)))
            (unwind-protect
                (progn BODY)
              (save-excursion
                (set-buffer (marker-buffer beg))
                (narrow-to-region beg end))))

     `save-restriction'の正しい使い方の簡単な例を示す.

          ---------- Buffer: foo ----------
          This is the contents of foo
          This is the contents of foo
          This is the contents of foo-!-
          ---------- Buffer: foo ----------

          (save-excursion
            (save-restriction
              (goto-char 1)
              (forward-line 2)
              (narrow-to-region 1 (point))
              (goto-char (point-min))
              (replace-string "foo" "bar")))

          ---------- Buffer: foo ----------
          This is the contents of bar
          This is the contents of bar
          This is the contents of foo-!-
          ---------- Buffer: foo ----------


File: elisp-ja, Node: Markers, Next: Text, Prev: Positions, Up: Top

マーカ
******

"マーカ"（marker）とは, バッファ内位置をそれを取り巻くテキストを基準に
指定するために使われるLispオブジェクトです.  テキストが挿入されたり削
除されると, バッファの先頭からマーカまでの距離は自動的に変更され, マー
カは同じ前後の文字のあいだに留まります.

* Menu:

* Overview of Markers::      The components of a marker, and how it relocates.
* Predicates on Markers::    Testing whether an object is a marker.
* Creating Markers::         Making empty markers or markers at certain places.
* Information from Markers:: Finding the marker's buffer or character position.
* Marker Insertion Types::   Two ways a marker can relocate when you
                               insert where it points.
* Moving Markers::           Moving the marker to a new buffer or position.
* The Mark::                 How "the mark" is implemented with a marker.
* The Region::               How to access "the region".



File: elisp-ja, Node: Overview of Markers, Next: Predicates on Markers, Prev: Markers, Up: Markers

マーカの概要
============

マーカは, バッファとそのバッファ内での位置を指定します.  マーカは, 位
置を必要とする関数に対して位置を表すものとして使えます.  バッファ内の
位置について詳しくは*Note Positions::.

マーカには2つの属性, つまり, マーカ位置とマーカバッファがあります.  マー
カ位置は, 当該バッファ内の位置としてのマーカに（その時点で）等価な整数
です.  しかし, マーカの生存期間中, マーカ位置の値はしばしば変化します. 
バッファにテキストを挿入したり削除すると, マーカは再配置されます.  こ
れは, バッファの任意の箇所で挿入したり削除したとしても, 2つの文字のあ
いだに置かれたマーカが同じ文字のあいだに留まるようにするためです.  再
配置によって, マーカに等価な整数は変わります.

マーカ位置の周りのテキストを削除すると, 削除されたテキストの前後の文字
のあいだにマーカは留まります.  マーカの位置にテキストを挿入すると,
`insert-before-markers'（*Note Insertion::）で挿入しない限り, マーカの
"挿入型"（insertion type）（*Note Marker Insertion Types::）に依存して, 
マーカは挿入されたテキストのまえかうしろに留まります.

バッファに対する挿入や削除では, すべてのマーカを検査し, 必要ならばマー
カを再配置する必要があります.  マーカを多数抱えるバッファでは, このた
めに処理が遅くなります.  そのため, マーカが不要であると確信したときに
は, マーカがどこも指さないようにしておくのがよいです.  参照されていな
いマーカは最終的には（ガベッジコレクションで）回収されますが, それまで
は, マーカがどこかを指していると処理時間を浪費します.

マーカ位置にはよく算術演算を施すので, （`+'や`-'を含む）ほとんどの算術
演算は引数としてマーカを受け付けます.  そのような場合, マーカはその現
在位置を表します.

マーカを作って位置を設定し, ポイントをマーカへ移動する例を示します.

     ;; どこも指していない新しいマーカを作る
     (setq m1 (make-marker))
          => #<marker in no buffer>

     ;; マーカm1の位置をカレントバッファの
     ;; 99番目と100番目の文字のあいだにする
     (set-marker m1 100)
          => #<marker at 100 in markers.texi>

     ;; バッファの先頭に1文字挿入する
     (goto-char (point-min))
          => 1
     (insert "Q")
          => nil

     ;; それにしたがって`m1'が更新される
     m1
          => #<marker at 101 in markers.texi>

     ;; 同じ位置を指す2つのマーカは`eq'ではないが
     ;; `equal'である
     (setq m2 (copy-marker m1))
          => #<marker at 101 in markers.texi>
     (eq m1 m2)
          => nil
     (equal m1 m2)
          => t

     ;; マーカを使い終ったら, どこも指していないようにする
     (set-marker m1 nil)
          => #<marker in no buffer>



File: elisp-ja, Node: Predicates on Markers, Next: Creating Markers, Prev: Overview of Markers, Up: Markers

マーカ向けの述語
================

オブジェクトがマーカであるかどうかや, オブジェクトが整数かマーカである
かどうかを検査できます.  マーカと整数の両者を扱う算術関数に関連して, 
後者の検査は有用です.

 -- Function: markerp OBJECT
     この関数は, OBJECTがマーカであれば`t'を返し, さもなければ`nil'を
     返す.  多くの関数がマーカや整数を受け付けるが, 整数はマーカではな
     いことに注意すること.

 -- Function: integer-or-marker-p OBJECT
     この関数は, OBJECTが整数かマーカであると`t'を返し, さもなければ
     `nil'を返す.

 -- Function: number-or-marker-p OBJECT
     この関数は, OBJECTが数（整数か浮動小数点数）かマーカであると`t'を
     返し, さもなければ`nil'を返す.



File: elisp-ja, Node: Creating Markers, Next: Information from Markers, Prev: Predicates on Markers, Up: Markers

マーカ作成関数
==============

新たにマーカを作成するときには, そのマーカが, どこも指していない, 現在
のポイント位置を指している, バッファの参照可能部分の先頭や末尾を指して
いる, 別のマーカと同じ箇所を指しているのいずれかにできます.

 -- Function: make-marker
     この関数は, どこも指していない新たに作成したマーカを返す.

          (make-marker)
               => #<marker in no buffer>

 -- Function: point-marker
     この関数は, カレントバッファの現在のポイント位置を指す新たに作成
     したマーカを返す.  *Note Point::.  例については, 下記の
     `copy-marker'を参照.

 -- Function: point-min-marker
     この関数は, バッファの参照可能部分の先頭を指す新たに作成したマー
     カを返す.  ナロイングしていなければ, これはバッファの先頭である.
     *Note Narrowing::.

 -- Function: point-max-marker
     この関数は, バッファの参照可能部分の末尾を指す新たに作成したマー
     カを返す.  ナロイングしていなければ, これはバッファの末尾である.
     *Note Narrowing::.

     本章のソースファイル（の原文）を入れたバッファでのこの関数と
     `point-min-marker'の例を示す.

          (point-min-marker)
               => #<marker at 1 in markers.texi>
          (point-max-marker)
               => #<marker at 15573 in markers.texi>

          (narrow-to-region 100 200)
               => nil
          (point-min-marker)
               => #<marker at 100 in markers.texi>
          (point-max-marker)
               => #<marker at 200 in markers.texi>

 -- Function: copy-marker MARKER-OR-INTEGER &optional INSERTION-TYPE
     引数としてマーカを渡されると, `copy-marker'は, MARKER-OR-INTEGER
     が指すのと同じバッファとバッファ内位置を指す新たなマーカを返す. 
     引数として整数を渡されると, `copy-marker'は, カレントバッファで位
     置MARKER-OR-INTEGERを指す新たなマーカを返す.

     新たなマーカの挿入型は引数INSERTION-TYPEで指定する.  *Note Marker
     Insertion Types::.

     渡された整数引数が1未満であると, `copy-marker'は, カレントバッファ
     でバッファの先頭を指す新たなマーカを返す.  渡された整数引数がバッ
     ファの長さより大きいと, `copy-marker'は, バッファの末尾を指す新た
     なマーカを返す.

          (copy-marker 0)
               => #<marker at 1 in markers.texi>

          (copy-marker 20000)
               => #<marker at 7572 in markers.texi>

     MARKER-OR-INTEGERがマーカでも整数でもないと, エラーを通知する.

2つの異なるマーカが, 同じバッファの同じバッファ内位置であるか, どちら
もどこも指していないときには, 両者を（`eq'ではないが）`equal'とみなし
ます.

     (setq p (point-marker))
          => #<marker at 2139 in markers.texi>

     (setq q (copy-marker p))
          => #<marker at 2139 in markers.texi>

     (eq p q)
          => nil

     (equal p q)
          => t



File: elisp-ja, Node: Information from Markers, Next: Marker Insertion Types, Prev: Creating Markers, Up: Markers

マーカの情報
============

本節では, マーカオブジェクトの構成要素を参照する関数について述べます.

 -- Function: marker-position MARKER
     この関数は, MARKERが指す位置を返す.  あるいは, MARKERがどこも指し
     ていなければ`nil'を返す.

 -- Function: marker-buffer MARKER
     この関数は, MARKERが指すバッファを返す.  あるいは, MARKERがどこも
     指していなければ`nil'を返す.

          (setq m (make-marker))
               => #<marker in no buffer>
          (marker-position m)
               => nil
          (marker-buffer m)
               => nil

          (set-marker m 3770 (current-buffer))
               => #<marker at 3770 in markers.texi>
          (marker-buffer m)
               => #<buffer markers.texi>
          (marker-position m)
               => 3770



File: elisp-ja, Node: Marker Insertion Types, Next: Moving Markers, Prev: Information from Markers, Up: Markers

マーカの挿入型
==============

マーカが指す箇所に直接テキストを挿入すると, マーカの再配置方法には2つ
の可能性, つまり, 挿入したテキストのまえに留まるか, あとにくるかのどち
らかです.  マーカの"挿入型"（insertion type）を設定することで, あるマー
カではどちらを選ぶか指定できます.  `insert-before-markers'を使うとマー
カの挿入型は無視され, マーカは挿入したテキストのうしろにつねに再配置さ
れることに注意してください.

 -- Function: set-marker-insertion-type MARKER TYPE
     この関数は, マーカMARKERの挿入型をTYPEとする.  TYPEが`t'であると, 
     テキストが挿入されるとMARKERはその位置へ進む.  TYPEが`nil'である
     と, テキストが挿入されてもMARKERはその位置へ進まない.

 -- Function: marker-insertion-type MARKER
     この関数は, MARKERの現在の挿入型を報告する.



File: elisp-ja, Node: Moving Markers, Next: The Mark, Prev: Marker Insertion Types, Up: Markers

マーカ位置の移動
================

本節では, 既存のマーカの位置を変更する方法について述べます.  これを行
うときには, 読者のプログラムの外側で当該マーカが使われているかどうか, 
使われているときには移動による効果はなにかを確実に理解してください. 
さもないと, Emacsの別の部分で混乱を生じるかもしれません.

 -- Function: set-marker MARKER POSITION &optional BUFFER
     この関数は, BUFFERにおいてMARKERをPOSITIONへ移動する.  BUFFERを与
     えないと, デフォルトはカレントバッファである.

     POSITIONが1未満であると, `set-marker'はMARKERをバッファの先頭へ移
     動する.  POSITIONがバッファのサイズよりも大きいと, `set-marker'は
     MARKERをバッファの末尾へ移動する.  POSITIONが`nil'であったりどこ
     も指していないマーカであると, MARKERはどこも指さないようにする.

     戻り値はMARKERである.

          (setq m (point-marker))
               => #<marker at 4714 in markers.texi>
          (set-marker m 55)
               => #<marker at 55 in markers.texi>
          (setq b (get-buffer "foo"))
               => #<buffer foo>
          (set-marker m 0 b)
               => #<marker at 1 in foo>

 -- Function: move-marker MARKER POSITION &optional BUFFER
     これは`set-marker'の別名である.



File: elisp-ja, Node: The Mark, Next: The Region, Prev: Moving Markers, Up: Markers

マーク
======

各バッファの1つの特別なマーカを"マーク"（mark）として区別します.  これ
は, `kill-region'や`indent-rigidly'などのコマンド向けにユーザーのため
に位置を記録するものです.  Lispプログラムでは, ユーザーが使う可能性の
ある値だけをマークに設定し, プログラムの内部向けにはけっしてマークを使
いません.  たとえば, コマンド`replace-regexp'は, 置換を行うまえのポイ
ント値をマークに設定します.  置換を完了したあとに, ユーザーが手軽にま
えの位置に戻れるようにするためです.

多くのコマンドは, 対話的に呼ばれるとポイントとマークのあいだのテキスト
に作用するように設計されています.  読者がそのようなコマンドを書くとき
には, マークを直接検査しないでください.  そのかわりに, `r'を指定した
`interactive'を使います.  こうすると, 対話的に呼ばれるとポイントとマー
クの値がコマンドの引数に与えられますが, 別のLispプログラムからは引数を
明示できます.  *Note Interactive Codes::.

各バッファには, 他のバッファのマークの値とは独立な独自のマークの値があ
ります.  バッファが作成されると, マークは存在しますがどこも指さない状
態です.  これを『バッファのマークは欠如している』状態とみなします.

バッファでいったんマークが『存在』するようになれば, マークが存在しなく
なることは普通はありません.  しかし, 暫定マーク（transient-mark）モー
ドをオンにすると, マークが"不活性"になることはあります.  すべてのバッ
ファでつねにバッファローカルな変数`mark-active'がマークが活性かどうか
を表します.  その値が`nil'以外であるとマークは活性です.  コマンドで
`deactivate-mark'に`nil'以外の値を設定すると, エディタコマンドループに
戻ったときにマークを不活性にするようにできます（ただし, 暫定マーク
（transient-mark）モードがオンの場合に限る）.

暫定マーク（transient-mark）モードを使う主な目的は, マークが活性である
とこのモードはリージョンを強調表示するからです.  *Note Display::.

マークに加えて, 各バッファには"マークリング"（mark ring）, つまり, マー
クの以前の値を保持したリストがあります.  編集コマンドがマークを変更す
ると, 通常, 編集コマンドはマークの古い値をマークリングに保存します. 
変数`mark-ring-max'で, マークリングに収める要素の最大個数を指定します. 
リストがこの長さに達すると, 新たな要素を加えるたびに古い要素を削除しま
す.

 -- Function: mark &optional FORCE
     この関数は, カレントバッファのマーク位置を整数で返す.

     マークが不活性であると, 通常, `mark'はエラーを通知する.  しかし,
     FORCEが`nil'以外であると`mark'はマーク位置を返すが, 当該バッファ
     でマークが設定されたことがなければ`nil'を返す.

 -- Function: mark-marker
     この関数は, カレントバッファのマークを返す.  これは, Emacs内部の
     マーク位置を記録したマーカそのものであり, コピーではない.  したがっ
     て, このマーカの位置を変更すると, マークの位置に直接影響する.  こ
     の効果を望まない限り, そのようにしないこと.

          (setq m (mark-marker))
               => #<marker at 3420 in markers.texi>
          (set-marker m 100)
               => #<marker at 100 in markers.texi>
          (mark-marker)
               => #<marker at 100 in markers.texi>

     他のマーカと同様に, このマーカは任意のバッファでポイントを指すよ
     うにできる.  マークが指しているバッファ以外のバッファ内位置を指す
     ことは勧めない.  そのようにすると, 一貫性はあるが妙な結果を生じる.


 -- Function: set-mark POSITION
     この関数は, 位置POSITIONにマークを設定し, マークを活性にする.  マー
     クの古い値はマークリングに保存し*ない*.

     *注意：*` 'ユーザーにマークが移動したことを示し, かつ, まえのマー
     ク位置を破棄したい場合にのみこの関数を使うこと.  通常, 新たにマー
     クを設定したときには, 古いマークを`mark-ring'に入れるべきである. 
     この理由から, ほとんどのアプリケーションでは, `set-mark'ではなく
     `push-mark'と`pop-mark'を使うべきである.

     Emacs Lispの初心者プログラマは, 誤った目的にマークを使いがちであ
     る.  マークはユーザーの便宜のための位置を保存する.  編集コマンド
     は, コマンドのユーザーレベルの機能の一部としてマークを変更する以
     外には, マークを変更してはならない.  （変更する場合には, その効果
     を明文化しておくべきである. ）Lispプログラムの内部で使う位置を記
     録するには, Lisp変数に保存する.  たとえばつぎのようにする.

          (let ((beg (point)))
            (forward-line 1)
            (delete-region beg (point))).


 -- Function: push-mark &optional POSITION NOMSG ACTIVATE
     この関数は, カレントバッファのマークをPOSITIONとし, 以前のマーク
     のコピーを`mark-ring'へ入れる.  POSITIONが`nil'であると, ポイント
     の値を使う.  `push-mark'は`nil'を返す.

     関数`push-mark'は, 通常, マークを活性に*しない*.  活性にするには
     引数ACTIVATEに`t'を指定する.

     NOMSGが`nil'であると, メッセージ`Mark set'を表示する.

 -- Function: pop-mark
     この関数は, `mark-ring'から先頭要素を取り出し, そのマークをカレン
     トバッファの実際のマークとする.  バッファのポイントは移動しない. 
     また, `mark-ring'が空であるとなにもしない.  マークを不活性にする.

     戻り値に意味はない.

 -- User Option: transient-mark-mode
     この変数が`nil'以外であると暫定マーク（transient-mark）モードがオ
     ンであるが, バッファを変更する各基本関数は`deactivate-mark'に設定
     する.  つまり, バッファを変更するコマンドは, 通常, マークを不活性
     にする.

 -- User Option: mark-even-if-inactive
     これが`nil'以外であると, LispプログラムやEmacsユーザーは, マーク
     が不活性であってもマークを使える.  このオプションは, 暫定マーク
     （transient-mark）モードのふるまいに影響する.  このオプションが
     `nil'以外であると, マークが不活性になるとリージョンの強調表示を止
     めるが, マークを使うコマンドはマークが活性であるものとして動作す
     る.

 -- Variable: deactivate-mark
     編集コマンドがこの変数に`nil'以外を設定すると, エディタコマンドルー
     プは（暫定マーク（transient-mark）モードがオンであると）コマンド
     から戻るとマークを不活性にする.  コマンドが終了したらマークを不活
     性にするために, バッファを変更するすべての基本関数は
     `deactivate-mark'に設定する.

 -- Function: deactivate-mark
     この関数は, 暫定マーク（transient-mark）モードがオンであるとマー
     クを不活性にする.  さもなければなにもしない.

 -- Variable: mark-active
     この変数が`nil'以外であると, マークは活性である.  この変数は各バッ
     ファにおいてつねにバッファローカルである.

 -- Variable: activate-mark-hook
 -- Variable: deactivate-mark-hook
     これらのノーマルフックは, それぞれ, マークが活性になったとき, 不
     活性になったときに実行される.  マークが活性でありリージョンが変更
     されたときには, フック`activate-mark-hook'はコマンドの終りでも実
     行される.

 -- Variable: mark-ring
     このバッファローカルな変数の値は, カレントバッファで保存したマー
     クを最新のものから順に並べたリストである.

          mark-ring
          => (#<marker at 11050 in markers.texi> 
              #<marker at 10832 in markers.texi>
              ...)

 -- User Option: mark-ring-max
     この変数の値は, `mark-ring'の最大の大きさである.  これより多くの
     マークを`mark-ring'に積むと, `push-mark'は新しいものを追加すると
     きに古いものを削除する.



File: elisp-ja, Node: The Region, Next: Text, Prev: The Mark, Up: Markers

リージョン
==========

ポイントとマークのあいだのテキストを"リージョン"（region）といいます. 
さまざまな関数がポイントとマークで区切られたテキストに作用しますが, リー
ジョンそのものに特に関連した関数だけについてここで述べます.

 -- Function: region-beginning
     この関数は, リージョンの先頭の位置を（整数で）返す.  これは, ポイ
     ントかマークの小さいほうの位置である.

     マークがどこも指していなければ, エラーを通知する.

 -- Function: region-end
     この関数は, リージョンの末尾の位置を（整数で）返す.  これは, ポイ
     ントかマークの大きいほうの位置である.

     マークがどこも指していなければ, エラーを通知する.

関数`region-beginning'や`region-end'を使う必要があるプログラムはほとん
どないはずです.  リージョンに作用するように設計されたコマンドは, 普通,
`r'を指定した`interactive'を使ってリージョンの先頭と末尾をみつけます. 
これにより, Lispプログラムからは引数として境界を明示的に指定できます. 
（*Note Interactive Codes::. ）


File: elisp-ja, Node: Text, Next: Non-ASCII Characters, Prev: Markers, Up: Top

テキスト
********

本章では, バッファ内のテキストを扱う関数について述べます.  それらのほ
とんどは, カレントバッファ内のテキストを調べたり挿入したり削除しますが, 
しばしばポイント付近で行います.  多くは対話的に使えます.  テキストを変
更するすべての関数は, 変更を取り消せます（*Note Undo::）.

テキスト関連の多くの関数は, STARTとENDという名前の引数で渡された2つの
バッファ内位置で定義されるテキストの領域に作用します.  これらの引数は, 
マーカ（*Note Markers::）であるか文字の位置を表す数値（*Note
Positions::）である必要があります.  これらの引数の順番は関係なく,
STARTが領域の終了位置でENDが開始位置であってもまったく問題ありません. 
たとえば, `(delete-region 1 10)'と`(delete-region 10 1)'は同値です.
STARTやENDがバッファの参照可能部分の外側にあるとエラー
`args-out-of-range'を通知します.  対話的な呼び出しでは, ポイントとマー
クをこれらの引数として使います.

本章では, バッファ内の文字を（関係あるときには）それらのテキスト属性を
含めて『テキスト』と呼びます.

* Menu:

* Near Point::       Examining text in the vicinity of point.
* Buffer Contents::  Examining text in a general fashion.
* Comparing Text::   Comparing substrings of buffers.
* Insertion::        Adding new text to a buffer.
* Commands for Insertion::  User-level commands to insert text.
* Deletion::         Removing text from a buffer.
* User-Level Deletion::     User-level commands to delete text.
* The Kill Ring::    Where removed text sometimes is saved for later use.
* Undo::             Undoing changes to the text of a buffer.
* Maintaining Undo:: How to enable and disable undo information.
			How to control how much information is kept.
* Filling::          Functions for explicit filling.
* Margins::          How to specify margins for filling commands.
* Adaptive Fill::    Adaptive Fill mode chooses a fill prefix from context.
* Auto Filling::     How auto-fill mode is implemented to break lines.
* Sorting::          Functions for sorting parts of the buffer.
* Columns::          Computing horizontal positions, and using them.
* Indentation::      Functions to insert or adjust indentation.
* Case Changes::     Case conversion of parts of the buffer.
* Text Properties::  Assigning Lisp property lists to text characters.
* Substitution::     Replacing a given character wherever it appears.
* Transposition::    Swapping two portions of a buffer.
* Registers::        How registers are implemented.  Accessing the text or
                       position stored in a register.
* Change Hooks::     Supplying functions to be run when text is changed.



File: elisp-ja, Node: Near Point, Next: Buffer Contents, Prev: Text, Up: Text

ポイント付近のテキストを調べる
==============================

多くの関数は, ポイント付近の文字を調べるためのものです.  ここでは, 数
個の単純な関数について述べます.  *Note Regexp Search::の`looking-at'も
参照してください.

 -- Function: char-after &optional POSITION
     この関数は, カレントバッファ内の位置POSITIONにある（つまり直後の）
     文字を返す.  POSITIONがバッファの先頭のまえや末尾のうしろにあるな
     どしてこの目的に適した範囲の外側にあると, 値は`nil'である.
     POSITIONのデフォルトはポイントである.

     つぎの例では, バッファの最初の文字は`@'であると仮定する.

          (char-to-string (char-after 1))
               => "@"

 -- Function: char-before &optional POSITION
     この関数は, カレントバッファ内の位置POSITIONのまえにある文字を返
     す.  POSITIONがバッファの先頭のまえや末尾のうしろにあるなどしてこ
     の目的に適した範囲の外側にあると, 値は`nil'である.  POSITIONのデ
     フォルトはポイントである.

 -- Function: following-char
     この関数は, カレントバッファのポイントのうしろにある文字を返す. 
     これは`(char-after (point))'と同様である.  しかし, ポイントがバッ
     ファの末尾にあると, `following-char'は0を返す.

     ポイントはつねに文字のあいだにあり, 端末のカーソルはポイントの直
     後の文字に重ねて表示されることに注意してほしい.  したがって,
     `following-char'が返す文字は, カーソルが重なっている文字である.

     つぎの例では, ポイントは`a'と`c'のあいだにある.

          ---------- Buffer: foo ----------
          Gentlemen may cry "Pea-!-ce! Peace!,"
          but there is no peace.
          ---------- Buffer: foo ----------

          (char-to-string (preceding-char))
               => "a"
          (char-to-string (following-char))
               => "c"

 -- Function: preceding-char
     この関数は, カレントバッファのポイントのまえの文字を返す.  例につ
     いては上記の`following-char'を参照.  ポイントがバッファの先頭にあ
     ると, `preceding-char'は0を返す.

 -- Function: bobp
     この関数は, ポイントがバッファの先頭にあると`t'を返す.  ナロイン
     グしていると, これはバッファの参照可能部分の先頭を意味する.
     *Note Point::の`point-min'も参照.

 -- Function: eobp
     この関数は, ポイントがバッファの末尾にあると`t'を返す.  ナロイン
     グしていると, これはバッファの参照可能部分の末尾を意味する.
     *Note Point::の`point-max'も参照.

 -- Function: bolp
     この関数は, ポイントが行頭にあると`t'を返す.  *Note Text Lines::. 
     バッファ（あるいはその参照可能部分）の先頭は, つねに行頭とみなす.

 -- Function: eolp
     この関数は, ポイントが行末にあると`t'を返す.  *Note Text Lines::. 
     バッファ（あるいはその参照可能部分）の末尾は, つねに行末とみなす.



File: elisp-ja, Node: Buffer Contents, Next: Comparing Text, Prev: Near Point, Up: Text

バッファの内容を調べる
======================

本節では, Lispプログラムでバッファ内の任意の部分のテキストを文字列に変
換するための2つの関数について述べます.

 -- Function: buffer-substring START END
     この関数は, カレントバッファのSTARTとENDの位置で定義される領域の
     テキストのコピーを含んだ文字列を返す.  引数がバッファの参照可能部
     分の内側の位置でないと, `buffer-substring'はエラー
     `args-out-of-range'を通知する.

     STARTがENDより小さい必要はなく, 引数の順番はどちらでもよい.  しか
     し, ほとんどの場合, 小さい引数を先に書く.

     コピーされるテキストにテキスト属性がある場合, テキスト属性もそれ
     が属する文字とともに文字列へコピーされる.  *Note Text
     Properties::.  しかし, バッファのオーバレイ（*Note Overlays::）と
     それらの属性は無視されコピーされない.

          ---------- Buffer: foo ----------
          This is the contents of buffer foo

          ---------- Buffer: foo ----------

          (buffer-substring 1 10)
          => "This is t"
          (buffer-substring (point-max) 10)
          => "he contents of buffer foo
          "

 -- Function: buffer-substring-no-properties START END
     この関数は`buffer-substring'と同様であるが, テキスト属性をコピー
     せずに文字だけをコピーする点が異なる.  *Note Text Properties::.

 -- Function: buffer-string
     この関数は, カレントバッファの参照可能部分全体の内容を文字列とし
     て返す.  これは, つぎと等価である.

          (buffer-substring (point-min) (point-max))

          ---------- Buffer: foo ----------
          This is the contents of buffer foo

          ---------- Buffer: foo ----------

          (buffer-string)
               => "This is the contents of buffer foo
          "

 -- Function: thing-at-point THING
     ポイントの周りやそのうしろにあるTHINGを文字列として返す.

     引数THINGは, 構文上の要素の種類を指定するシンボルである.  可能な
     値は, `symbol', `list', `sexp', `defun', `filename', `url',
     `word', `sentence', `whitespace', `line', `page'などである.

          ---------- Buffer: foo ----------
          Gentlemen may cry "Pea-!-ce! Peace!,"
          but there is no peace.
          ---------- Buffer: foo ----------

          (thing-at-point 'word)
               => "Peace"
          (thing-at-point 'line)
               => "Gentlemen may cry "Peace! Peace!,"\n"
          (thing-at-point 'whitespace)
               => nil



File: elisp-ja, Node: Comparing Text, Next: Insertion, Prev: Buffer Contents, Up: Text

テキストの比較
==============

この関数により, バッファ内のテキストの部分同士を文字列にコピーせずに比
較できます.

 -- Function: compare-buffer-substrings BUFFER1 START1 END1 BUFFER2 START2 END2
     この関数は, 同一バッファ内の2つの部分文字列, あるいは, 異なる2つ
     のバッファの部分文字列を比較する.  始めの3つの引数は, バッファと
     そのバッファ内の2つの位置を与え, 1つの部分文字列を指定する.  残り
     の3つの引数も同様にして別の部分文字列を指定する.  カレントバッファ
     を表すために, BUFFER1とBUFFER2のいずれか, あるいは, 両方に`nil'を
     指定できる.

     始めの文字列のほうが小さければ値は負であり, 始めのほうが大きけれ
     ば値は正であり, 等しければ0である.  結果の絶対値は, 部分文字列の
     中で最初に異なる文字の添字足す1である.

     この関数は, `case-fold-search'が`nil'以外であると, 文字の比較では
     大文字小文字を区別しない.  テキスト属性はつねに無視する.

     カレントバッファにはテキスト`foobarbar haha!rara!'があるとする. 
     すると, この例の2つの部分文字列は`rbar 'と`rara!'である.  2番目の
     文字で最初の文字列のほうが大きいので, 結果は2である.

          (compare-buffer-substring nil 6 11 nil 16 21)
               => 2



File: elisp-ja, Node: Insertion, Next: Commands for Insertion, Prev: Comparing Text, Up: Text

テキストの挿入
==============

"挿入"（insertion）とは, バッファに新たなテキストを追加することです. 
挿入されたテキストはポイント位置に, つまり, ポイントのまえの文字とポイ
ントのあとの文字のあいだに入ります.  挿入されたテキストのまえにポイン
トを留める関数もあれば, そのうしろに留める関数もあります.  前者を"ポイ
ントのうしろへ"挿入と呼び, 後者を"ポイントのまえへ"挿入と呼びます.

挿入により, 挿入箇所よりうしろの位置を指すマーカは再配置されて同じ周り
の文字に留まります（*Note Markers::）.  マーカが挿入箇所を指している場
合には, マーカの挿入型（*Note Marker Insertion Types::）に依存して, 挿
入するとマーカが再配置されたりされなかったりします.
`insert-before-markers'などの特定の特殊な関数は, マーカの挿入型に関わ
らず, 挿入されたテキストのうしろを指すようにそのようなすべてのマーカを
再配置します.

カレントバッファが読み出し専用であると, 挿入関数はエラーを通知します.

これらの関数は, テキストの文字群をそれらの属性とともに文字列からバッファ
へコピーします.  挿入された文字群は, コピーされるまえとまったく同じ属
性を持ちます.  対照的に, 文字列やバッファの一部ではない孤立した引数と
して指定された文字群は, 周りのテキストからテキスト属性を継承します.

挿入関数は, 文字列由来やバッファ由来のテキストの場合には, マルチバイト
バッファへ挿入するためにユニバイトからマルチバイトへテキストを変換し, 
逆向きの変換も行います.  しかし, カレントバッファがたとえマルチバイト
バッファであっても, 128から255のユニバイト文字コードはマルチバイト文字
には変換しません.  *Note Converting Representations::.

 -- Function: insert &rest ARGS
     この関数は, 文字列や文字群ARGSをカレントバッファのポイント位置に
     挿入し, ポイントを先へ進める.  いいかえれば, ポイントのまえにテキ
     ストを挿入する.  ARGSが文字列でも文字でもないと, エラーを通知する. 
     値は`nil'である.

 -- Function: insert-before-markers &rest ARGS
     この関数は, 文字列や文字群ARGSをカレントバッファのポイント位置に
     挿入し, ポイントを先へ進める.  ARGSが文字列でも文字でもないと, エ
     ラーを通知する.  値は`nil'である.

     挿入箇所を指していたマーカを挿入されたテキストのうしろを指すよう
     に再配置する点で, この関数は他の挿入関数と異なる.  挿入箇所でオー
     バレイが始まるときには, 挿入されたテキストはオーバレイの範囲外に
     出る.  空でないオーバレイが挿入箇所で終るときには, 挿入されたテキ
     ストはオーバレイの範囲内に入る.

 -- Function: insert-char CHARACTER &optional COUNT INHERIT
     この関数は, カレントバッファのポイントのまえに文字CHARACTERを
     COUNT個挿入する.  引数COUNTは数（`nil'は1を意味する）であり,
     CHARACTERは文字であること.  値は`nil'である.

     この関数は, カレントバッファがたとえマルチバイトバッファであって
     も, 128から255のユニバイト文字コードはマルチバイト文字には変換し
     ない.  *Note Converting Representations::.

     INHERITが`nil'以外であると, 挿入された文字は, 挿入箇所の前後の2つ
     の文字からスティッキテキスト属性を継承する.

 -- Function: insert-buffer-substring FROM-BUFFER-OR-NAME &optional START END
     この関数は, バッファFROM-BUFFER-OR-NAME（既存であること）の部分を
     カレントバッファのポイントのまえへ挿入する.  挿入されるテキストは
     STARTからENDまでの領域である.  （これらの引数のデフォルトは, 当該
     バッファの参照可能部分の先頭と末尾である. ）この関数は`nil'を返す.

     この例では, バッファ`bar'をカレントバッファとしてフォームを実行す
     る.  バッファ`bar'は最初は空であると仮定する.

          ---------- Buffer: foo ----------
          We hold these truths to be self-evident, that all
          ---------- Buffer: foo ----------

          (insert-buffer-substring "foo" 1 20)
               => nil

          ---------- Buffer: bar ----------
          We hold these truth-!-
          ---------- Buffer: bar ----------

挿入に加えて周りのテキストからテキスト属性を継承する他の関数については,
*Note Sticky Properties::.  字下げ関数が挿入した白文字もテキスト属性を
継承します.



File: elisp-ja, Node: Commands for Insertion, Next: Deletion, Prev: Insertion, Up: Text

ユーザーレベルの挿入コマンド
============================

本節では, テキストを挿入する上位レベルのコマンドについて述べます.  こ
れらはLispプログラムでも有用ですが主にユーザー向けのコマンドです.

 -- コマンド: insert-buffer FROM-BUFFER-OR-NAME
     このコマンドは, FROM-BUFFER-OR-NAME（既存であること）の全内容をカ
     レントバッファのポイントのうしろに挿入する.  挿入されたテキストの
     うしろにマークを置く.  値は`nil'である.

 -- コマンド: self-insert-command COUNT
     このコマンドは, 最後に打たれた文字を挿入する.  ポイントのまえに
     COUNT回挿入して`nil'を返す.  ほとんどの印字文字はこのコマンドにバ
     インドされている.  普通の状況では, `self-insert-command'はEmacsに
     おいてもっとも頻繁に呼び出される関数であるが, プログラムではキー
     マップに登録する以外にはほとんど使わない.

     対話的に呼ばれると, COUNTは数値前置引数である.

     このコマンドは, 挿入した文字が空白や改行であると,
     `auto-fill-function'が`nil'以外であると`auto-fill-function'を呼び
     出す（*Note Auto Filling::）.

     このコマンドは, 略語（abbrev）モードがオンであり, かつ, 挿入した
     文字が単語構成構文でないと, 略語展開を行う.  （*Note Abbrevs::と
     *Note Syntax Class Table::. ）

     挿入した文字が閉じ括弧構文であるときに`blink-paren-function'を呼
     び出す責任も持つ（*Note Blinking::）.

 -- コマンド: newline &optional NUMBER-OF-NEWLINES
     このコマンドは, カレントバッファのポイントのまえに改行を挿入する.
     NUMBER-OF-NEWLINESを指定すると, その個数だけ改行文字を挿入する.

     この関数は, 現在のコラム番号が`fill-column'の値よりも大きく
     NUMBER-OF-NEWLINESが`nil'であると`auto-fill-function'を呼び出す.
     `auto-fill-function'の典型的な仕事は改行を挿入することである.  こ
     こでの全体としての効果は, 改行を2つの異なる位置, つまり, ポイント
     位置と行のまえの箇所に挿入することである.  `newline'は,
     NUMBER-OF-NEWLINESが`nil'以外であると自動詰め込みを行わない.

     このコマンドは, 左端の余白が0以外であるとその分だけ字下げする.
     *Note Margins::.

     戻り値は`nil'である.  対話的に呼ばれると, COUNTは数値前置引数であ
     る.

 -- コマンド: split-line
     このコマンドは, 行のポイントのうしろの部分を垂直に降ろして変更前
     の真下に行を移動することで現在行を分割する.  関数`indent-to'を用
     いて, 降ろした行の先頭に必要に応じて白文字を挿入する.

     プログラムではまったくこの関数を使わない.

 -- Variable: overwrite-mode
     この変数は, 上書き（overwrite）モードがオンかどうかを制御する. 
     この値は, `overwrite-mode-textual', `overwrite-mode-binary',
     `nil'のいずれかであること.  `overwrite-mode-textual'は, テキスト
     の上書きモード（改行とタブを特別に扱う）を指定し,
     `overwrite-mode-binary'は, バイナリの上書きモード（改行やタブも他
     の文字と同様に扱う）を指定する.



File: elisp-ja, Node: Deletion, Next: User-Level Deletion, Prev: Commands for Insertion, Up: Text

テキストの削除
==============

削除とは, バッファ内のテキストのある部分をキルリング（*Note The Kill
Ring::）に保存せずに取りさることです.  削除したテキストはヤンクはでき
ませんが, アンドゥ機構（*Note Undo::）を使って再度挿入できます.  特別
な場合にはキルリングにテキストを保存する削除関数もあります.

すべての削除関数はカレントバッファに作用し, `nil'の値を返します.

 -- コマンド: erase-buffer
     この関数は, カレントバッファから全テキストを削除して空にする.  バッ
     ファが読み出し専用であると, エラー`buffer-read-only'を通知する. 
     さもなければ, いっさい確認を取らずにテキストを削除する.  `nil'を
     返す.

     バッファから多量のテキストを削除すると, 通常, 『バッファが縮小し
     た』としてそのバッファの自動保存を禁止する.  しかし,
     `erase-buffer'はこうしない.  これまでのテキストと将来のテキストに
     は関連がなく, これまでのテキストのサイズと比較すべきでないと考え
     るからである.

 -- コマンド: delete-region START END
     このコマンドは, STARTとENDで定義されるカレントバッファのテキスト
     を削除する.  戻り値は`nil'である.  削除された領域の内側にポイント
     があると, その値は削除後にはSTARTになる.  さもなければ, マーカと
     同様にポイントは周りのテキストに留まるように再配置される.

 -- コマンド: delete-char COUNT &optional KILLP
     このコマンドは, ポイントの直後の, あるいは, COUNTが負であるとポイ
     ントの直前のCOUNT個の文字を削除する.  KILLPが`nil'以外であると, 
     削除した文字をキルリングに保存する.

     対話的に呼ばれると, COUNTは数値前置引数であり, KILLPは未処理の前
     置引数である.  つまり, 前置引数を指定すると, テキストをキルリング
     に保存する.  前置引数を指定しないと1文字だけを削除するが, キルリ
     ングには保存しない.

     戻り値はつねに`nil'である.

 -- コマンド: delete-backward-char COUNT &optional KILLP
     このコマンドは, ポイントの直前の, あるいは, COUNTが負であるとポイ
     ントの直後のCOUNT個の文字を削除する.  KILLPが`nil'以外であると, 
     削除した文字をキルリングに保存する.

     対話的に呼ばれると, COUNTは数値前置引数であり, KILLPは未処理の前
     置引数である.  つまり, 前置引数を指定すると, テキストをキルリング
     に保存する.  前置引数を指定しないと1文字だけを削除するが, キルリ
     ングには保存しない.

     戻り値はつねに`nil'である.

 -- コマンド: backward-delete-char-untabify COUNT &optional KILLP
     このコマンドは, タブを空白にかえながら後向きにCOUNT個の文字を削除
     する.  つぎに削除する文字がタブであると, まずタブを配置を保つだけ
     の等価な個数の空白に置換してから, タブのかわりにそれらの空白を削
     除する.  KILLPが`nil'以外であると, このコマンドは削除した文字をキ
     ルリングに保存する.

     COUNTが正である場合に限って, タブを空白に変換する. 
     COUNTが負であると, ポイントのうしろのちょうど
     -COUNT個の文字を削除する.

     対話的に呼ばれると, COUNTは数値前置引数であり, KILLP は未処理の前
     置引数である.  つまり, 前置引数を指定すると, テキストをキルリング
     に保存する.  前置引数を指定しないと1文字だけを削除するが, キルリ
     ングには保存しない.

     戻り値はつねに`nil'である.

 -- User Option: backward-delete-char-untabify-method
     このオプションは, `backward-delete-char-untabify'での白文字の扱い
     方を指定する.  可能な値は, タブを空白に変換してから空白を削除する
     ことを意味するデフォルトの`untabify', 1回の呼び出しでポイントのま
     えにある白文字をすべて削除することを意味する`hungry', 白文字に対
     して特別なことをしないことを意味する`nil'である.



File: elisp-ja, Node: User-Level Deletion, Next: The Kill Ring, Prev: Deletion, Up: Text

ユーザーレベルの削除コマンド
============================

本節では, テキストを削除する上位レベルのコマンドについて述べます.  こ
れらはLispプログラムでも有用ですが主にユーザー向けのコマンドです.

 -- コマンド: delete-horizontal-space
     この関数は, ポイントの周りの空白やタブをすべて削除する.  `nil'を
     返す.

     つぎの例では, 毎回ポイントを2番目と3番目の文字のあいだに置いて, 
     各行につき1回ずつ`delete-horizontal-space'を計4回呼び出す.

          ---------- Buffer: foo ----------
          I -!-thought
          I -!-     thought
          We-!- thought
          Yo-!-u thought
          ---------- Buffer: foo ----------

          (delete-horizontal-space)   ; Four times.
               => nil

          ---------- Buffer: foo ----------
          Ithought
          Ithought
          Wethought
          You thought
          ---------- Buffer: foo ----------

 -- コマンド: delete-indentation &optional JOIN-FOLLOWING-P
     この関数は, ポイントがある行をそのまえの行に連結する.  連結箇所の
     白文字は削除し, 場合によっては空白1個に置き換える.
     JOIN-FOLLOWING-Pが`nil'以外であると, `delete-indentation'は, この
     行を後続の行に連結する.  関数は`nil'を返す.

     詰め込み接頭辞があり, かつ, 連結対象の2番目の行がその接頭辞で始まっ
     ている場合には, `delete-indentation'は連結するまえに詰め込み接頭
     辞を削除する.  *Note Margins::.

     以下の例では, ポイントは`events'で始まる行にあり, そのまえの行の
     行末に空白があっても違いはない.

          ---------- Buffer: foo ----------
          When in the course of human
          -!-    events, it becomes necessary
          ---------- Buffer: foo ----------

          (delete-indentation)
               => nil

          ---------- Buffer: foo ----------
          When in the course of human-!- events, it becomes necessary
          ---------- Buffer: foo ----------

     行を連結したあと, 関数`fixup-whitespace'には, 連結箇所に空白を置
     くかどうかを決定する責任がある.

 -- Function: fixup-whitespace
     この関数は, 文脈に応じて, ポイントを囲む白文字すべてを1つの空白に
     置換するかまったくなくす.  `nil'を返す.

     行の先頭や末尾では, 空白の適切な量は0である.  閉じ括弧構文の文字
     のまえや, 開き括弧構文や式前置子構文の文字のうしろでも空白はない
     ほうが適している.  それ以外では, 空白1個が適している.  *Note
     Syntax Class Table::.

     以下の例では, 最初の行の単語`spaces'のまえにポイントがあるときに
     最初に`fixup-whitespace'が呼ばれる.  2度目に呼ばれるときには, ポ
     イントは`('の直後にある.

          ---------- Buffer: foo ----------
          This has too many     -!-spaces
          This has too many spaces at the start of (-!-   this list)
          ---------- Buffer: foo ----------

          (fixup-whitespace)
               => nil
          (fixup-whitespace)
               => nil

          ---------- Buffer: foo ----------
          This has too many spaces
          This has too many spaces at the start of (this list)
          ---------- Buffer: foo ----------

 -- コマンド: just-one-space
     このコマンドは, ポイントの周りのすべての空白やタブを1個の空白に置
     き換える.  `nil'を返す.

 -- コマンド: delete-blank-lines
     この関数は, ポイントを囲む空行を削除する.  前後に複数の空行がある
     空行にポイントがある場合, 1つの空行を残してそれ以外はすべて削除す
     る.  孤立した1つの空行にポイントがある場合には, その行を削除する. 
     空行でない行にポイントがある場合には, その行のうしろにある空行を
     すべて削除する.

     空行とは, タブや空白のみから成る行と定義する.

     `delete-blank-lines'は`nil'を返す.



File: elisp-ja, Node: The Kill Ring, Next: Undo, Prev: User-Level Deletion, Up: Text

キルリング
==========

"キル関数"は削除関数のようにテキストを削除しますが, ユーザーが"ヤンク"
（yank）で再度挿入できるように保存します.  これらの関数の多くは, その
名前に`kill-'があります.  対照的に, `delete-'で始まる名前の関数は, ヤ
ンクできるようにテキストを保存しません（アンドゥはできる）.  それらは
『削除』関数です.

キルコマンドの多くは主に対話的に使うものであり, ここではそれらについて
は述べません.  ここで述べるのは, そのようなコマンドを書くために使う関
数についてです.  これらの関数は読者がテキストをキルするコマンドを書く
ために使えます.  Lisp関数において内部目的のためにテキストを削除する必
要があるときには, キルリングの内容を乱さないように普通は削除関数を用い
るべきです.  *Note Deletion::.

キルしたテキストはあとでヤンクできるように"キルリング"（kill ring）に
保存されます.  これは, 最後にキルしたテキストだけでなく, 最近キルした
ものを多数保持するリストです.  これを『リング』と呼ぶのは, 要素が循環
しているようにヤンクが扱うからです.  このリストは変数`kill-ring'に保持
されていて, リスト向けの通常の関数で操作できますが, 本節で述べるように, 
それをリングとして扱う特別な関数もあります.

単語『キル』の使い方が不適当だと考える人々がいます.  『キル』したもの
を特に破壊*しない*操作を表すために使っているからです.  日常生活に照ら
してみると, 死は恒久的であり『キル』したものが生き返ることはありません. 
したがって, 別の隠喩も提案されています.  たとえば, 原稿を鋏で切り貼り
することに慣れていた前計算機世代の人々には『カットリング』のほうが意味
が通じるでしょう.  しかし, いまさら用語を変更するのは困難です.

* Menu:

* Kill Ring Concepts::     What text looks like in the kill ring.
* Kill Functions::         Functions that kill text.
* Yank Commands::          Commands that access the kill ring.
* Low-Level Kill Ring::	   Functions and variables for kill ring access.
* Internals of Kill Ring:: Variables that hold kill-ring data.



File: elisp-ja, Node: Kill Ring Concepts, Next: Kill Functions, Prev: The Kill Ring, Up: The Kill Ring

キルリングの概念
----------------

キルリングは, もっとも最近にキルされたものを先頭にして, キルされたテキ
ストを文字列としてリストに記録します.  たとえば, 短いキルリングはつぎ
のようになります.

     ("some text" "a different piece of text" "even older text")

リストの長さが`kill-ring-max'に達すると, 新たな項目を追加すると自動的
に最後の項目を削除します.

キルコマンドが他のコマンドと混在する場合, 各キルコマンドはキルリングに
新たな項目を追加します.  連続した複数のキルコマンドは, キルリングに1つ
の項目を作りあげ, それを1個としてヤンクできます.  2番目以降の連続した
キルコマンドは, 最初のキルコマンドが作った項目にテキストを追加していき
ます.

ヤンクでは, キルリングの1つの項目をリングの『先頭』として区別します. 
リングの別の項目を『先頭』と指定することでリングを『回転』するコマンド
もあります.



File: elisp-ja, Node: Kill Functions, Next: Yank Commands, Prev: Kill Ring Concepts, Up: The Kill Ring

キル向けの関数
--------------

`kill-region'は, テキストをキルするための普通のサブルーティンです.  こ
の関数を呼び出す任意のコマンドは『キルコマンド』です（その名前には
`kill'があるはず）.  `kill-region'は, 新たにキルされたテキストをキルリ
ングの先頭に新たな項目として追加したり, もっとも最近の項目に加えます. 
まえのコマンドがキルコマンドであるかどうかを（`last-command'を使って）
自動的に判定し, もしそうならば, キルされたテキストをもっとも最近の項目
に加えます.

 -- コマンド: kill-region START END
     この関数は, STARTとENDで定義される領域のテキストをキルする.  テキ
     ストは削除されるが, テキスト属性とともにキルリングに保存される. 
     値はつねに`nil'である.

     対話的に呼ばれると, STARTとENDはポイントとマークである.

     バッファが読み出し専用であると, `kill-region'はキルリングを同様に
     変更するが, バッファを変更せずにエラーを通知する.  読み出し専用バッ
     ファからキルリングへテキストをコピーするために, ユーザーはすべて
     のキルコマンドを使えるのでこれは便利である.

 -- User Option: kill-read-only-ok
     このオプションが`nil'以外であると, `kill-region'は, バッファが読
     み出し専用であってもエラーとしない.  そのかわりに, キルリングを更
     新しバッファは変更せずに戻る.

 -- コマンド: copy-region-as-kill START END
     このコマンドは, STARTとENDで定義される領域を（テキスト属性ととも
     に）キルリングに保存するが, バッファからテキストを削除しない.
     `nil'を返す.  また, カーソルを一時的に移動してコピーしたテキスト
     の範囲を示すか, あるいは, エコー領域にメッセージを表示する.

     このコマンドは`this-command'に`kill-region'を設定しないので, これ
     以降のキルコマンドはキルリングの同じ項目には加えない.

     Emacs 18版でも使うつもりがない限り, Lispプログラムからは
     `copy-region-as-kill'を呼ばないこと.  Emacsの新しい版では, そのか
     わりに`kill-new'や`kill-append'を使うほうがよい.  *Note Low-Level
     Kill Ring::.



File: elisp-ja, Node: Yank Commands, Next: Low-Level Kill Ring, Prev: Kill Functions, Up: The Kill Ring

ヤンク向けの関数
----------------

"ヤンク"（yank）とは, キルリングからまえにキルされたテキストの項目を再
度挿入することです.

 -- コマンド: yank &optional ARG
     このコマンドは, キルリングの先頭項目のテキストをポイントのまえに
     挿入する.  そのテキストの先頭にマークを末尾にポイントを置く.

     ARGがリスト（対話的な呼び出しではユーザーが数字文字なしに`C-u'を
     打ったとき）であると, `yank'は上に述べたようにテキストを挿入する
     が, ヤンクしたテキストの先頭にポイントを末尾にマークを置く.

     ARGが数であると, `yank'はARG番目のもっとも最近にキルされたテキス
     ト, つまり, キルリングリストのARG番目の項目を挿入する.

     `yank'はキルリングの内容を変更したり回転しない.  `nil'を返す.

 -- コマンド: yank-pop ARG
     このコマンドは, キルリングからヤンクした項目をキルリングの別の項
     目で置き換える.

     これは`yank'や別の`yank-pop'の直後でのみ許される.  そのような場合, 
     リージョンにはヤンクしたばかりのテキストが含まれる.  `yank-pop'は
     そのテキストを削除し, その位置にキルされた別のテキストを挿入する. 
     削除したテキストはすでにキルリングのどこかにあるので, キルリング
     には追加しない.

     ARGが`nil'であると, キルリングの古い項目で置き換える.  ARGが数で
     あると, ARG番古いキルで置き換える.  ARGが負であると, より最近のキ
     ルで置き換える.

     キルリング内でのキルの順番は, 最古のもののつぎに最新のものがあり, 
     最新のもののまえに最古のものがあるように折り返されている.

     戻り値はつねに`nil'である.



File: elisp-ja, Node: Low-Level Kill Ring, Next: Internals of Kill Ring, Prev: Yank Commands, Up: The Kill Ring

下位レベルのキルリング
----------------------

これらの関数と変数は, 下位レベルでキルリングを参照するためのものですが,
Lispプログラムで使っても便利です.  これらはウィンドウシステムのセレク
ション（*Note Window System Selections::）との相互作用の面倒をみてくれ
るからです.

 -- Function: current-kill N &optional DO-NOT-MOVE
     関数`current-kill'は, キルリングの『先頭』として区別するヤンクポ
     インタを（新しいキルから古いキルへ向けて）N個分回転し, リングのそ
     の位置のテキストを返す.

     省略可能な第2引数DO-NOT-MOVEが`nil'以外であると, `current-kill'は, 
     ヤンクポインタは変更せずに, 現在のヤンクポインタから数えてN番目の
     キルを返す.

     Nが0であると, もっとも最近のキルを要求することを表し,
     `current-kill'は, キルリングを調べるまえに（以下に述べる）
     `interprogram-paste-function'の値を呼び出す.

 -- Function: kill-new STRING
     この関数は, テキストSTRINGを新たな項目としてキルリングの先頭に置
     く.  必要ならば最古の項目を破棄する.  `interprogram-cut-function'
     （下記参照）の値も起動する.

 -- Function: kill-append STRING BEFORE-P
     この関数は, キルリングの先頭項目にテキストSTRINGを追加する.  通常,
     STRINGはその項目の末尾に加わるが, BEFORE-Pが`nil'以外であるとその
     項目の先頭に加わる.  この関数は, `interprogram-cut-function'（下
     記参照）の値も起動する.

 -- Variable: interprogram-paste-function
     この変数は, ウィンドウシステムを使っているときに別のプログラムか
     らキルされたテキストを転送する方法を提供する.  その値は, `nil'で
     あるか, 引数なしの関数であること.

     値が関数であると, 『もっとも最近のキル』を得るために
     `current-kill'が呼び出す.  関数が`nil'以外の値を返すと, その値は
     『もっとも最近のキル』として使われる.  `nil'を返せば, `kill-ring'
     の先頭項目が使われる.

     このフックの普通の用途は, セレクションが別のアプリケーションに属
     する場合であっても, ウィンドウシステムの一次セレクションをもっと
     も最近のキルとして得ることである.  *Note Window System
     Selections::.

 -- Variable: interprogram-cut-function
     この変数は, ウィンドウシステムを使っているときにキルされたテキス
     トを別のプログラムへ転送する方法を提供する.  その値は, `nil'であ
     るか, 引数なしの関数であること.

     値が関数であると, `kill-new'と`kill-append'がキルリングの新たな先
     頭項目を引数として呼び出す.

     このフックの普通の用途は, 新たにキルされたテキストをウィンドウシ
     ステムの一次セレクションにすることである.  *Note Window System
     Selections::.



File: elisp-ja, Node: Internals of Kill Ring, Next: Undo, Prev: Low-Level Kill Ring, Up: The Kill Ring

キルリングの内部
----------------

変数`kill-ring'は, 文字列のリストの形でキルリングの内容を保持します. 
もっとも最近のキルがつねにリストの先頭にあります.

変数`kill-ring-yank-pointer'は, CARがつぎにヤンクすべきテキストである
ようなキルリングリストの項目を指しています.  この変数がリングの『先頭』
を識別するといいます.  `kill-ring-yank-pointer'を別の項目へ動かすこと
を"キルリングを回転する"と呼びます.  ヤンクポインタを動かす関数は, リ
ストの末尾からリストの先頭へ折り返しその逆も行うので, キルリングを『リ
ング』と呼ぶのです.  リングの回転は仮想的なものであり, `kill-ring'の値
は変更しません.

`kill-ring'も`kill-ring-yank-pointer'もLisp変数であり, それらの値は普
通のリストです.  `kill-ring-yank-pointer'の名前の単語『ポインタ』は, 
つぎのヤンクコマンドで使うリストの項目を識別することが変数の目的である
ことを表します.

`kill-ring-yank-pointer'の値は, キルリングリストの1つの項目とつねに
`eq'です.  これが識別する項目は, その項目のCARです.  キルリングを変更
するキルコマンドも, `kill-ring'の値をこの変数の値とします.  その効果は, 
新たにキルされたテキストが先頭にくるようにリングを回転することです.

キルリング`("some text" "a different piece of text" "yet older text")'
の第2項目を変数`kill-ring-yank-pointer'が指しているようすをつぎに示し
ます.

     kill-ring                  ---- kill-ring-yank-pointer
       |                       |
       |                       v
       |     -- ---          -- ---      -- ---
        --> |   |   |------> |   |   |--> |   |   |--> nil
             -- ---          -- ---      -- ---
              |                |            |            
              |                |            |            
              |                |             -->"yet older text" 
              |                |
              |                 --> "a different piece of text" 
              |
               --> "some text"

`C-y'（`yank'）の直後に`M-y'（`yank-pop'）を使うとこの状態になります.

 -- Variable: kill-ring
     この変数は, もっとも最近にキルされたものを最初にしてキルされたテ
     キストを順に並べたリストを保持する.

 -- Variable: kill-ring-yank-pointer
     この変数の値は, キルリングのどの要素がヤンクするためのリングの
     『先頭』であるかを表す.  より正確には, その値は`kill-ring'のリス
     トの一部であり, そのCARは`C-y'がヤンクするキルされた文字列である.

 -- User Option: kill-ring-max
     この変数の値は, 末尾の要素が破棄されるまでにキルリングが増大でき
     る最大の長さである.  `kill-ring-max'のデフォルト値は30である.



File: elisp-ja, Node: Undo, Next: Maintaining Undo, Prev: The Kill Ring, Up: Text

アンドゥ
========

ほとんどのバッファには, バッファのテキストに対する変更をアンドゥ（もと
に戻す）できるようにすべての変更を記録する"アンドゥリスト"（undo list）
があります.  （アンドゥリストのないバッファは, Emacsがアンドゥは有用で
はないと仮定する特殊目的のバッファである. ）バッファのテキストを変更す
るすべての基本関数は, 変数`buffer-undo-list'に収めたアンドゥリストの先
頭に自動的に要素を追加します.

 -- Variable: buffer-undo-list
     この変数の値は, カレントバッファのアンドゥリストである.  値`t'は
     アンドゥ情報の記録を禁止する.

アンドゥリストの要素として可能なものをつぎに示します.

`POSITION'
     この種の要素は, まえのポイント値を記録する.  この要素をアンドゥす
     るとポイントをPOSITIONへ移動する.  通常のカーソル移動では, いかな
     る種類のアンドゥ記録も作らないが, 削除操作ではコマンド実行前のポ
     イント位置を記録するためにこの項目を作る.

`(BEG . END)'
     この種の要素は, 挿入されたテキストを削除する方法を表す.  挿入され
     たテキストはバッファのBEGからENDまでの範囲を占める.

`(TEXT . POSITION)'
     この種の要素は, 削除されたテキストを再度挿入する方法を表す.  削除
     されたテキストそのものは文字列TEXTである.  再度挿入する位置は
     `(abs POSITION)'である.

`(t HIGH . LOW)'
     この種の要素は, 未変更のバッファが変更されたことを表す.  HIGHと
     LOWは2つの整数であり, それぞれ, まえに訪問したときや保存したとき
     の訪問しているファイルの更新時刻の16ビットを記録している.
     `primitive-undo'はこれらの値を用いて, バッファを再度未変更と印を
     付けるかどうか判定する.  ファイルの更新時刻がこれに一致するときに
     のみ再度未変更とする.

`(nil PROPERTY VALUE BEG . END)'
     この種の要素は, テキスト属性の変更を記録する.  変更をアンドゥする
     にはつぎのようにする.

          (put-text-property BEG END PROPERTY VALUE)

`(MARKER . ADJUSTMENT)'
     この種の要素は, 周りのテキストが削除されたためにマーカMARKERを再
     配置しADJUSTMENT文字分位置を移動したことを記録する.  この要素をア
     ンドゥすると, MARKER - ADJUSTMENT文字に移動する.

`nil'
     この要素は境界である.  2つの境界のあいだの要素群を"変更グループ"
     （change group）と呼ぶ.  通常, 各変更グループは1つのキーボードコ
     マンドに対応し, アンドゥコマンドはグループ全体を1個としてアンドゥ
     する.

 -- Function: undo-boundary
     この関数は, アンドゥリストに境界要素を置く.  アンドゥコマンドはそ
     のような境界で停止し, 連続したアンドゥコマンドはよりまえの境界ま
     でアンドゥする.  この関数は`nil'を返す.

     エディタコマンドループは, 各キー列を実行するまえにアンドゥの境界
     を自動的に作る.  したがって, 各アンドゥは, 1つのコマンドの効果を
     普通は取り消す.  自己挿入の入力文字は例外である.  コマンドループ
     はそのような最初の文字に境界を作り, つぎの19個の連続する自己挿入
     の入力文字では境界を作らず, 20番目で境界を作るということを自己挿
     入の入力文字が続く限り行う.

     別のバッファでアンドゥ可能な変更を行うたびにバッファのすべての変
     更で境界を追加する.  これは, 各コマンドが変更した箇所で各バッファ
     に境界を作ることを保証するためである.

     1つのコマンドの効果を複数に分けるためにこの関数を直接呼ぶことは有
     用である.  たとえば, `query-replace'は各置換のあとで
     `undo-boundary'を呼び出し, ユーザーが個々の置換を1つ1つアンドゥで
     きるようにする.

 -- Function: primitive-undo COUNT LIST
     これは, アンドゥリストの要素をアンドゥする基本的な関数である.
     LISTの先頭のCOUNT個の要素をアンドゥし, LISTの残りを返す.  この関
     数をLispで書くこともできるが, Cで書いたほうが便利である.

     `primitive-undo'は, バッファを変更するとバッファのアンドゥリスト
     に要素を追加する.  アンドゥコマンドは一連のアンドゥ操作を始めると
     きにアンドゥリストを保存して混乱を避ける.  アンドゥ操作では, 保存
     しておいた値を使い更新する.  アンドゥによって追加される新たな要素
     はこの保存された値の一部ではないので, それらはアンドゥを続行して
     も干渉しない.



File: elisp-ja, Node: Maintaining Undo, Next: Filling, Prev: Undo, Up: Text

アンドゥリストの管理
====================

本節では, 指定されたバッファでアンドゥ情報の記録をオン／オフする方法に
ついて述べます.  また, アンドゥリストが大きくなりすぎないように自動的
に切り詰める方法についても説明します.

新たに作成されたバッファのアンドゥ情報の記録は普通は始めオンですが, バッ
ファ名が空白で始まる場合は最初からオフです.  つぎの2つの関数を使うか, 
読者自身が`buffer-undo-list'に設定すれば, アンドゥ記録を明示的にオン／
オフできます.

 -- コマンド: buffer-enable-undo &optional BUFFER-OR-NAME
     このコマンドは, バッファBUFFER-OR-NAMEでのアンドゥ記録をオンにし, 
     以降の変更を取り消せるようにする.  引数を指定しないと, カレントバッ
     ファを使う.  当該バッファでアンドゥ記録がすでにオンであると, この
     関数はなにもしない.  `nil'を返す.

     対話的に呼ばれると, BUFFER-OR-NAMEはカレントバッファである.  他の
     バッファを指定できない.

 -- コマンド: buffer-disable-undo &optional BUFFER
 -- コマンド: buffer-flush-undo &optional BUFFER
     この関数はバッファBUFFERのアンドゥリストを破棄し, 以降のアンドゥ
     情報の記録をオフにする.  その結果, これ以前の変更も以降の変更も取
     り消すことはできない.  BUFFERのアンドゥリストがすでにオフであると, 
     この関数にはなんの効果もない.

     この関数は`nil'を返す.

     名前`buffer-flush-undo'は廃れているとはみなさないが, 好ましい名前
     は`buffer-disable-undo'である.

編集を続けるにしたがってアンドゥリストはどんどん長くなります.  これら
がメモリを使い尽くさないように, 読者が設定した上限サイズにガベッジコレ
クションが切り詰めます.  （この目的においてアンドゥリストの『サイズ』
は, リストを構成するコンスセルの個数と削除された文字列の和である. ）2
つの変数`undo-limit'と`undo-strong-limit'は, 許容できるサイズの範囲を
制御します.

 -- Variable: undo-limit
     これはアンドゥリストの許容できるサイズの緩い制限である.  このサイ
     ズを越える位置にある変更グループは保持される最古のものである.

 -- Variable: undo-strong-limit
     これはアンドゥリストの許容できるサイズの上限である.  このサイズを
     越える位置にある変更グループは（これより古いものも含めて）削除さ
     れる.  例外が1つあり, 最新の変更グループはそれがどれほど大きくて
     もけっして破棄しない.



