Info file: elisp-ja,    -*-Text-*-
produced by `texinfo-format-buffer'
from file `elisp.texi'
using `texinfmt.el' version 2.38 of 3 July 1998.


INFO-DIR-SECTION Editors
START-INFO-DIR-ENTRY
* Elisp-ja: (elisp-ja).	The Emacs Lisp Reference Manual(Japanese).
END-INFO-DIR-ENTRY



Emacs Lispリファレンスマニュアル2.5版であり, Emacs 20.3版に対応します.

Published by the Free Software Foundation 59 Temple Place, Suite 330
Boston, MA 02111-1307 USA

Copyright (C) 1990, 1991, 1992, 1993, 1994, 1995, 1996, 1998 Free
Software Foundation, Inc.

Permission is granted to make and distribute verbatim copies of this
manual provided the copyright notice and this permission notice are
preserved on all copies.

Permission is granted to copy and distribute modified versions of this
manual under the conditions for verbatim copying, provided that the
entire resulting derived work is distributed under the terms of a
permission notice identical to this one.

Permission is granted to copy and distribute translations of this
manual into another language, under the above conditions for modified
versions, except that this permission notice may be stated in a
translation approved by the Foundation.

Permission is granted to copy and distribute modified versions of this
manual under the conditions for verbatim copying, provided also that
the section entitled "GNU General Public License" is included exactly
as in the original, and provided that the entire resulting derived
work is distributed under the terms of a permission notice identical
to this one.

Permission is granted to copy and distribute translations of this
manual into another language, under the above conditions for modified
versions, except that the section entitled "GNU General Public
License" may be included in a translation approved by the Free
Software Foundation instead of in the original English.






File: elisp-ja  Node: Copying-Footnotes, Up: Copying

(1) 【注意】現在, このバージョン2の発行者(FSF)住所は, 正式に新し
い住所の 
 　59 Temple Place, Suite 330, Boston, MA 02111-1307,
USA 
 に変わっている.

(2) 【注意】現在, このバージョン2の発行者(FSF)住所は, 正式に新し
い住所の59 Temple Place, Suite 330, Boston, MA 02111-1307, USA に
変わっている.



File: elisp-ja, Node: Introduction, Next: Lisp Data Types, Prev: Copying, Up: Top

はじめに
********

GNU Emacsテキストエディタの大部分は, Emacs Lispと呼ばれるプログラム言
語で記述してあります.  Emacs Lispで新たなコードを書いて, それをエディ
タの拡張としてインストールできます.  しかし, Emacs Lispは, 単なる『拡
張言語』ではありません.  それ自身, れっきとしたプログラム言語です.  他
のプログラム言語でできることは, Emacs Lispでできます.

Emacs Lispは, エディタで使うために設計してあるため, ファイル, バッファ, 
ディスプレイ, サブプロセスなどを扱う機能に加えて, テキストを走査し解析
する特別な機能もあります.  Emacs Lispは編集機構に密に組み込まれていま
す.  このため, 編集コマンドはLispプログラムからも呼び出せる関数ですし, 
カスタマイズのためのパラメータは普通のLisp変数です.

本書は, Emacs Lispを完全に記述することを目指しています.  初心者向けの
入門には, Free Software Foundation刊, Bob Chassellの`An Introduction
to Emacs Lisp Programming' (1) (*Note Introduction-Footnotes::) をご覧
ください.  本書では, Emacsの操作を熟知しているものと仮定します.  操作
に関する基本的な情報は, `The GNU Emacs Manual' (2) (*Note
Introduction-Footnotes::) を参照してください.

おおまかにいえば, 始めのほうの章では, 多くのプログラム言語に見られる機
能に相当するEmacs Lispの機能を説明し, あとのほうの章では, Emacs Lispに
特有の機能や編集に特化した機能を説明します.

本書は, 2.5版です.

* Menu:

* Caveats::             Flaws and a request for help.
* Lisp History::        Emacs Lisp is descended from Maclisp.
* Conventions::         How the manual is formatted.
* Version Info::        Which Emacs version is running?
* Acknowledgements::    The authors, editors, and sponsors of this manual.


File: elisp-ja  Node: Introduction-Footnotes, Up: Introduction

(1) 【訳注】日本語訳：『Emacs Lispプログラミング入門』, アスキー出版局,
ISBN 4-7561-1805-4

(2) 【訳注】日本語訳：『GNU Emacsマニュアル』, アスキー出版局, ISBN
4-7561-3002-X



File: elisp-ja, Node: Caveats, Next: Lisp History, Prev: Introduction, Up: Introduction

警告
====

本書は, 数多くの草稿を重ねてきました.  ほぼ完璧に近いはずですが, 誤り
は皆無ではありません.  ふれていない話題も少なからずあります.  （大部分
の個別のモードのような）副次的と捉えている話題や, まだ執筆していない話
題もあります.  完全にはこれらに対処しきれませんので, 意図的に省いたこ
とがらもあります.  たとえば, VMSにおける利用方法に関する情報です.

本書で取り上げたことがらに関しては, 本書は完璧であるべきですから, 例題
や記述内容から章や節の構成順序といったことまで, 広く意見を求めています. 
混乱を招くような記述や, 本書でふれていないことがらを学ぶためにソースや
実験で調べる必要があるときには, 本書を改訂すべきなのでしょう.  そのと
きは, ぜひ, 教えてください.


本書を読むときには, 訂正箇所をみつけたらすぐ送ってくださるようにお願い
します.  1つの関数や一連の関数向けに, 簡素で実用に即した例を思い付いた
ならば, それを書き上げて, 送ってください.  章／節／関数の名前を適宜入
れてください.  それから, どの版に対する意見かも書いてください.

意見や訂正は, 下記へメイルしてください.

     bug-lisp-manual@gnu.org

ここに蓄積されたメイルは, 誰かが改訂作業を始めるまでは, 読み出しません. 
改訂までに, 数か月, ときには, 数年経過することもあります.  ですから, 
返事がないと憤慨しないでください.  あなたのメイルは, そのうち処理*され
ます*.  Emacs保守グループに迅速に連絡したい場合には,
`bug-gnu-emacs@gnu.org'にメイルしてください.



File: elisp-ja, Node: Lisp History, Next: Conventions, Prev: Caveats, Up: Introduction

Lispの歴史
==========

Lisp（LISt Processing language, リスト処理言語）は, 人工知能の研究向け
に1950年代末にMITで初めて開発されました.  Lisp言語はとても強力なので, 
エディタコマンドを記述するなどの他の目的にも理想的なのです.

長年にわたって何ダースものLispが実装されており, それぞれが独自の特徴を
有しています.  その多くは, 1960年代のMITのMACプロジェクトで開発された
Maclispの影響を受けています.  最終的には, Maclispの系統の実装者達は共
同して, Common Lispと呼ばれるLispシステムの規格を開発しました.  そうこ
うするうちに, MITのGerry SussmanとGuy Steeleは, 単純化してあるが非常に
強力なSchemeと呼ばれるLispの方言を開発しました.

GNU EmacsはMaclispの影響を強く受けていますが, Common Lispからの影響は
少ないです.  Common Lispを知っている読者は, Common Lispとの多くの類似
点に気づかれるでしょう.  しかしながら, Common Lispの多くの機能は, 省い
てあるか, 単純化してあります.  これは, GNU Emacsが必要とするメモリ量を
削減するためです.  ときには, 劇的に単純化してあるために, Common Lispユー
ザーは混乱するかもしれません.  GNU Emacs LispとCommon Lispとの相違点は, 
ことあるごとに指摘するつもりです.  Common Lispを知らない読者は, 何も心
配することはありません.  本書は自己完結しています.

`cl'ライブラリにより, Common Lispをかなりエミュレートできます.  *Note
Common Lisp Extension: (cl)Top.

Emacs LispはSchemeの影響をまったく受けていません.  しかし, GNUプロジェ
クトには, Guileと呼ばれるSchemeの実装があります.  拡張が必要なすべての
新たなGNUソフトウェアではGuileを使います.



File: elisp-ja, Node: Conventions, Next: Version Info, Prev: Lisp History, Up: Introduction

表記法
======

本節では, 本書で用いる表記法を説明します.  本節を読み飛ばして, あとで
参照してもかまいません.

* Menu:

* Some Terms::               Explanation of terms we use in this manual.
* nil and t::                How the symbols `nil' and `t' are used.
* Evaluation Notation::      The format we use for examples of evaluation.
* Printing Notation::        The format we use when examples print text.
* Error Messages::           The format we use for examples of errors.
* Buffer Text Notation::     The format we use for buffer contents in examples.
* Format of Descriptions::   Notation for describing functions, variables, etc.



File: elisp-ja, Node: Some Terms, Next: nil and t, Prev: Conventions, Up: Conventions

用語
----

本書では, 『Lispリーダ』および『Lispプリンタ』という言葉で, Lispオブジェ
クトのテキスト表現を実際のLispオブジェクトに変換するLisp内部のルーティ
ン群, および, 逆の変換を行うルーティン群を指します.  詳しくは, *Note
Printed Representation::.  本書の読者を『プログラマ』と考えて『読者』
と呼びます.  『ユーザー』とは作者自身を含めたLispプログラムを使う人の
ことです.

Lispコードの例は, `(list 1 2 3)'という形式で, このフォントで記します. 
メタな変数の名前や説明対象の関数に対する引数の名前は, FIRST-NUMBERとい
う形式で, このフォントで書きます.



File: elisp-ja, Node: nil and t, Next: Evaluation Notation, Prev: Some Terms, Up: Conventions

`nil'と`t'
----------

Lispでは, シンボル`nil'には3つの異なる意味があります.  まず, `nil'とい
う名前のシンボルです.  2つめは, 真理値の偽（false）です.  3つめは, 空
リスト, つまり, 要素数が0個のリストです.  変数として使った場合, `nil'
の値はつねに`nil'です.

Lispリーダにとっては, `()'と`nil'は同一です.  どちらも, 同じオブジェク
ト, シンボル`nil'を表します.  シンボルを異なった書き方にするのは, 完全
に人間向けです.  `()'や`nil'をLispリーダが読み取ったあとでは, プログラ
マが実際にどちらの表記を用いたかわかりません.

本書では, 空リストを強調するときには`()'を使い, 真理値の偽を強調すると
きには`nil'を使います.  これは, Lispプログラムでも使うとよい慣習です.

     (cons 'foo ())                ; 空リストであることを強調する
     (not nil)                     ; 真理値の偽であることを強調する

真理値の真を必要とする場面では, `nil'以外の値は, 真（true）であるとみ
なします.  しかし, 真を表す望ましい書き方は`t'です.  真を表す値が必要
なとき, 適当な判断基準がない場合には`t'を使います.  シンボル`t'の値は
つねに`t'です.

Emacs Lispでは, `nil'と`t'は特別なシンボルであり, 評価するとそれ自身に
なります.  そのため, これらをプログラム内で定数として使うとき, これら
をクォートする必要はありません.  これらの値を変更しようとすると, エラー
`setting-constant'になります.  コロン（`:'）で始まる名前のシンボルも同
様です.  *Note Constant Variables::.



File: elisp-ja, Node: Evaluation Notation, Next: Printing Notation, Prev: nil and t, Up: Conventions

評価の表記法
------------

評価可能なLisp式を"フォーム"（form, 形式）と呼びます.  フォームを評価
すると, Lispオブジェクトである結果を生じます.  本書の例題では, これを
`=>'で表します.

     (car '(1 2))
          => 1

これは, 『`(car '(1 2))'を評価すると1になる』と読みます.

フォームがマクロ呼び出しの場合には, Lispが評価すべき新たなフォームに展
開します.  展開結果を`==>'で表します.  展開したフォームの評価結果を示
す場合もあれば, 示さない場合もあります.

     (third '(a b c))
          ==> (car (cdr (cdr '(a b c))))
          => c

あるフォームを説明するときに, 同一の結果を生じる別のフォームを示すこと
があります.  2つのまったく等価なフォームを`=='で表します.

     (make-sparse-keymap) == (list 'keymap)



File: elisp-ja, Node: Printing Notation, Next: Error Messages, Prev: Evaluation Notation, Up: Conventions

結果表示の表記法
----------------

本書の数多くの例題は, 評価するとテキストを表示します.  （`*scratch*'バッ
ファのような）Lisp対話バッファで例題のコードを実行すると, 表示テキスト
はバッファに挿入されます.  （関数`eval-region'で評価するなどの）別の手
段で例題を実行すると, 表示テキストはエコー領域に表示されます.  エコー
領域に表示されるテキストは, 1行に切り詰められていることに注意してくだ
さい.

本書の例題では, 表示場所には無関係に, 表示テキストを`-|'で表します. 
フォームを評価した結果返される値（ここでは`bar'）は, 後続の行に分けて
書きます.

     (progn (print 'foo) (print 'bar))
          -| foo
          -| bar
          => bar



File: elisp-ja, Node: Error Messages, Next: Buffer Text Notation, Prev: Printing Notation, Up: Conventions

エラーメッセージ
----------------

エラーを通知する例題もあります.  これは, 通常, エコー領域にエラーメッ
セージを表示します.  エラーメッセージは, `error-->'で始まる行に示しま
す.  エコー領域には, `error-->'は表示されないことに注意してください.

     (+ 23 'x)
     error--> Wrong type argument: number-or-marker-p, x



File: elisp-ja, Node: Buffer Text Notation, Next: Format of Descriptions, Prev: Error Messages, Up: Conventions

バッファ内のテキストの表記法
----------------------------

バッファ内のテキストを修正する例題もあります.  このような場合, 『実行
前』と『実行後』のテキストを示します.  それらの例題では, バッファ名を
含めたダッシュから成る2行で挟んで, 当該バッファの内容を示します.  さら
に, ポイント位置を`-!-'で表します.  （もちろん, ポイントを表す記号は, 
バッファ内のテキストの一部ではない.  現在ポイントが位置する2つの文字の
*あいだ*を表す. ）

     ---------- Buffer: foo ----------
     This is the -!-contents of foo.
     ---------- Buffer: foo ----------

     (insert "changed ")
          => nil
     ---------- Buffer: foo ----------
     This is the changed -!-contents of foo.
     ---------- Buffer: foo ----------



File: elisp-ja, Node: Format of Descriptions, Next: Version Info, Prev: Buffer Text Notation, Up: Conventions

記述形式
--------

関数, 変数, マクロ, コマンド, ユーザーオプション, スペシャルフォームは, 
本書では統一した形式で記述します.  第1行目は, それぞれの名前と, 引数が
あれば引数群です.  関数, 変数, マクロ, コマンド, ユーザーオプションの
分類を行頭に書きます.  これに説明文が続き, 場合によっては例題も示しま
す.

* Menu:

* A Sample Function Description::       A description of an imaginary
                                          function, `foo'.
* A Sample Variable Description::       A description of an imaginary
                                          variable,
                                          `electric-future-map'.  



File: elisp-ja, Node: A Sample Function Description, Next: A Sample Variable Description, Prev: Format of Descriptions, Up: Format of Descriptions

関数の記述例
............

関数の記述では, まず始めに説明対象の関数名があります.  同じ行には, 引
数名の並びも続きます.  これらの名前は, 説明文の中で引数の値を参照する
ために使います.

引数ならびにキーワード`&optional'が現れていれば, それ以降の引数を省略
できることを示します（省略した引数の値は`nil'）.  関数を呼び出すときに
`&optional'を書いてはいけません.

キーワード`&rest' （このあとには1つの引数名だけが続く）は, 残りの引数
が何個でもよいことを示します.  直後にある1つの引数名は, 変数としての値
を持ち, その値は残りのすべての引数のリストです.  関数を呼び出すときに
`&rest'を書いてはいけません.

では, 仮想的な関数`foo'の記述を以下に示します.

 -- Function: foo INTEGER1 &optional INTEGER2 &rest INTEGERS
     関数`foo'は, INTEGER2からINTEGER1を引き算し, 残りのすべての引数を
     減算結果に加える.  INTEGER2を指定しないと, デフォルトでは, 数19か
     ら引き算する.

          (foo 1 5 3 9)
               => 16
          (foo 5)
               => 14

     より一般的には, つぎのとおり.

          (foo W X Y...)
          ==
          (+ (- X W) Y...)

（INTEGER, INTEGER1, BUFFERなどの）型名を名前とする引数は, その型の値
であると仮定します.  （BUFFERSのように）型を複数形にした場合には, しば
しば, その型のオブジェクトのリストを意味します.  OBJECTという名前の引
数は, 任意の型でかまいません.  （Emacsオブジェクトの型の一覧については,
*Note Lisp Data Types::）.  （NEW-FILEなどの）その他の名前の引数は, 関
数の説明文の中で言及します.  複数の関数の引数に共通する特徴について, 
節の始めで説明する場合もあります.

`&optional'と`&rest'についての詳しい説明は, *Note Lambda
Expressions::.

コマンド, マクロ, スペシャルフォームの記述も同じ形式ですが, 「関数」の
かわりに「コマンド」, 「マクロ」, 「スペシャルフォーム」のいずれかです. 
コマンドは, 対話的に呼び出せる単なる関数です.  マクロは関数とは違った
方法で引数を処理します（引数を評価しない）が, 同じ方法で引数を記します.

スペシャルフォームの記述では, 省略可能な引数や繰り返される引数を示すた
めに, より複雑な記法を使います.  というのは, 引数並びを個々の引数に分
離する方法が複雑だからです.  `[OPTIONAL-ARG]'は, OPTIONAL-ARGが省略可
能であることを示します.  また, `REPEATED-ARGS...'は, 0個以上の引数を示
します.  いくつかの引数をリスト構造の内側にまとめるときには, 括弧を使
います.

 -- Special form: count-loop (VAR [FROM TO [INC]]) BODY...
     この仮想的なスペシャルフォームは, フォーム群BODYを実行してから変
     数VARを増やすことを反復するループを実現する.  最初は, 変数の値は
     FROMである.  以降の反復では, 変数を1（あるいは, 指定があればINCだ
     け）増やす.  VARがTOに等しくなると, BODYを実行せずにループから抜
     ける.  例を示す.

          (count-loop (i 0 10)
            (prin1 i) (princ " ")
            (prin1 (aref vector i))
            (terpri))

     FROMとTOを省略すると, ループ開始前にVARに`nil'を束縛し, 各反復の
     開始時にVARが`nil'以外であるとループから抜け出る.

          (count-loop (done)
            (if (pending)
                (fixit)
              (setq done t)))

     このスペシャルフォームでは, 引数FROMとTOは省略できるが, 両者を同
     時に指定するか, 同時に省略すること.  これらを指定した場合, INCを
     指定してもよい.  これらの引数は, 引数VARとともにリストにまとめる. 
     これはBODYと区別するためであり, BODYは残りのフォームの要素すべて
     を含む.



File: elisp-ja, Node: A Sample Variable Description, Next: Version Info, Prev: A Sample Function Description, Up: Format of Descriptions

変数の記述例
............

"変数"（variable）は, 値を保持するための名前です.  ユーザーはどんな変
数でも設定できますが, ユーザーが変更可能な特定の変数群があり, それらを
"ユーザーオプション"（user options）と呼びます.  普通の変数もユーザー
オプションも関数の記述と同じ形式で示しますが, それらに引数はありません.

仮想的な変数`electric-future-map'の記述例を示します.

 -- Variable: electric-future-map
     この変数の値は, Electric Command Futureモードで使用する完全なキー
     マップである.  このマップに含まれる関数は, まだ実行していないコマ
     ンドの編集を可能にする.

ユーザーオプションの記述も同じ形式ですが, 「変数」のかわりに「ユーザー
オプション」です.



File: elisp-ja, Node: Version Info, Next: Acknowledgements, Prev: Conventions, Up: Introduction

版情報
======

これらの機構は, 使用中のEmacsの版に関する情報を提供します.

 -- コマンド: emacs-version
     この関数は, 実行中のEmacsの版を記述した文字列を返す.  この文字列
     はバグの報告に含めると有益である.

          (emacs-version)
            => "GNU Emacs 20.3.5 (i486-pc-linux-gnulibc1, X toolkit)
           of Sat Feb 14 1998 on psilocin.gnu.org"

     対話的に呼び出すと, この関数は同じ情報をエコー領域に表示する.

 -- Variable: emacs-build-time
     この変数の値は, ローカルのサイトでEmacsを構築した日時を示す.  3つ
     の整数から成るリストであり, `current-time'と同様のもの（*Note
     Time of Day::）.

          emacs-build-time
               => (13623 62065 344633)

 -- Variable: emacs-version
     この変数の値は, 実行中のEmacsの版番号.  `"20.3.1"'のような文字列
     である.  この文字列の最後の数字は, Emacsのリリース版番号の一部で
     はなく, 特定のディレクトリでEmacsを構築するたびに増える.

つぎの2つの変数は, Emacs 19.23以降に存在します.

 -- Variable: emacs-major-version
     Emacsのメジャー版番号を表す整数.  Emacs 20.3では, 値は20.

 -- Variable: emacs-minor-version
     Emacsのマイナ版番号を表す整数.  Emacs 20.3では, 値は3.



File: elisp-ja, Node: Acknowledgements, Next: Coding Conventions, Prev: Version Info, Up: Introduction

謝辞
====

本書は, Robert Krawitz, Bil Lewis, Dan LaLiberte, Richard M. Stallman,
Chris Welty, GNUマニュアルプロジェクトのボランティアによる何年にもわた
る努力で執筆されました.  Computational Logic社のWarren A. Hunt, Jr.が
手配した国防省Advanced Research Projects Agency, ARPA Order 6082の援助
のもと, Robert J. Chassellは本書のレビューと編集に協力してくれました.

以下の方々が訂正を送ってくれました.  Karl Berry, Jim Blandy, Bard
Bloom, Stephane Boucher, David Boyes, Alan Carroll, Richard Davis,
Lawrence R. Dodd, Peter Doornbosch, David A. Duff, Chris Eich, Beverly
Erlebacher, David Eckelkamp, Ralf Fassel, Eirik Fuller, Stephen
Gildea, Bob Glickstein, Eric Hanchrow, George Hartzell, Nathan Hess,
Masayuki Ida, Dan Jacobson, Jak Kirman, Bob Knighten, Frederick
M. Korz, Joe Lammens, Glenn M. Lewis, K. Richard Magill, Brian Marick,
Roland McGrath, Skip Montanaro, John Gardiner Myers, Thomas
A. Peterson, Francesco Potorti, Friedrich Pukelsheim, Arnold
D. Robbins, Raul Rockwell, Per Starback, Shinichirou Sugou, Kimmo
Suominen, Edward Tharp, Bill Trost, Rickard Westman, Jean White,
Matthew Wilding, Carl Witty, Dale Worley, Rusty Wright, David D. Zuhn.


File: elisp-ja, Node: Lisp Data Types, Next: Numbers, Prev: Introduction, Up: Top

Lispのデータ型
**************

Lisp"オブジェクト"（object）とは, Lispプログラムが使用し操作するデータ
のことです.  "型"（type）や"データ型"（data type）とは, ここでは, 可能
なオブジェクトの集合を意味します.

各オブジェクトは, 少なくとも, 1つの型に属します.  同じ型のオブジェクト
は, 構造に類似性があり, 普通, 同じ文脈で使われます.  型は互いに重複し
ていてもよく, オブジェクトは複数の型に属することができます.  そのため, 
オブジェクトが特定の型に属するかどうかは判断できますが, オブジェクトの
型を『1つ』に限定することはできません.

Emacsには少数の基本オブジェクト型を組み込んであります.  これらの型は他
のすべてのオブジェクト型を構成するもとであり, "基本型"（primitive
types）と呼びます.  各オブジェクトはたった1つの基本型に属します.  基本
型には, "整数"（integer）, "浮動小数点数"（float）, "コンス"（cons）,
"シンボル"（symbol）, "文字列"（string）, "ベクトル"（vector）,
"subr", "バイトコード関数"（byte-code function）, ならびに, 編集に関連
する"バッファ"（buffer）などの特別な型があります.  （*Note Editing
Types::. ）

各基本型には, その型に属するオブジェクトであるかどうかを検査する対応す
るLisp関数があります.

Lispオブジェクトは"型を自己記述"（self-typing）するという点で, Lispは
他の多くの言語とは異なります.  つまり, オブジェクトの基本型は, オブジェ
クト自体に暗に含まれています.  たとえば, オブジェクトがベクトルであれ
ば, それを数と扱うことはありません.  Lispには, ベクトルは数ではないと
わかっているのです.

多くの言語では, プログラマは各変数のデータ型を宣言する必要があります. 
型はコンパイラが知っているのであって, データの中には入っていません. 
このような型宣言はEmacs Lispには存在しません.  Lisp変数はどんな型の値
でも保持でき, 変数に入れた値と型を記録しています.

本章では, GNU Emacs Lispの各標準型の表示表現と入力構文を説明します. 
これらの型の使用方法の詳細は, あとの章に譲ります.

* Menu:

* Printed Representation::      How Lisp objects are represented as text.
* Comments::                    Comments and their formatting conventions.
* Programming Types::           Types found in all Lisp systems.
* Editing Types::               Types specific to Emacs.
* Type Predicates::             Tests related to types.
* Equality Predicates::         Tests of equality between any two objects.



File: elisp-ja, Node: Printed Representation, Next: Comments, Prev: Lisp Data Types, Up: Lisp Data Types

表示表現と入力構文
==================

オブジェクトの"表示表現"（printed representation）とは, Lispプリンタ
（関数`prin1'）がそのオブジェクトを出力表示するときの書式です.  オブジェ
クトの"入力構文"（read syntax）とは, Lispリーダ（関数`read'）がそのオ
ブジェクトを入力として受理する書式です.  *Note Read and Print::.

ほとんどのオブジェクトには1つ以上の可能な入力構文があります.  ある種の
型のオブジェクトには入力構文はありませんが, そのような型のオブジェクト
をLispプログラムに直接入力する意味がないからです.  このような場合を除
くと, オブジェクトの表示表現はそのオブジェクトの入力構文でもあります.

他の言語では, 式はテキストであって, これ以外の形はありません.  Lispで
は, 式はとにかくLispオブジェクトであって, オブジェクトの入力構文である
テキストは副次的なものです.  この違いを強調する必要はありませんが, こ
のことを心に留めておかないと混乱することがあります.

各型には表示表現があります.  入力構文のない型もあります.  たとえば, バッ
ファ型には入力構文はありません.  このような型のオブジェクトは"ハッシュ
記法"（hash notation）で表示します.  つまり, 文字列`#<'のあとに説明用
の文字列（典型的には型名にオブジェクトの名前を続けたもの）を続け, 対応
する`>'で閉じます.  ハッシュ記法を読み取ることはできませんから, Lispリー
ダが`#<'に出会うとエラー`invalid-read-syntax'を通知します.

     (current-buffer)
          => #<buffer objects.texi>

読者が対話的に式を評価するとき, Lispインタープリタは, まず, 式のテキス
ト表現を読み取ってLispオブジェクトを生成し, そのオブジェクトを評価しま
す（*Note Evaluation::）.  しかしながら, 評価と読み取りは別々の動作で
す.  読み取りでは, 読み取ったテキストが表すLispオブジェクトを返します. 
このオブジェクトを, のちに評価する場合もありますが, 評価しない場合もあ
ります.  オブジェクトを読み取る基本関数`read'については, *Note Input
Functions::.



File: elisp-ja, Node: Comments, Next: Programming Types, Prev: Printed Representation, Up: Lisp Data Types

コメント
========

"コメント"（comment）は, プログラム内に書かれたテキストであり, プログ
ラムを読む人間のためだけにあり, プログラムの意味にはまったく影響しませ
ん.  Lispでは, 文字列や文字定数の外にあるセミコロン（`;'）でコメントを
始めます.  コメントは行末までです.  Lispリーダは, コメントを破棄します. 
コメントは, Lispシステム内部でプログラムを表すLispオブジェクトの一部に
はなりません.

`#@COUNT'という書き方は, 後続のCOUNT個の文字を飛び越します.  これは, 
プログラムで生成したバイナリデータを含むコメントに便利です.  Emacs
Lispのバイトコンパイラは, 出力ファイルにこのようなコメントを使います
（*Note Byte Compilation::）.  しかしながら, ソースファイル向きではあ
りません.

コメントの体裁に関する慣習については, *Note Comment Tips::.



File: elisp-ja, Node: Programming Types, Next: Editing Types, Prev: Comments, Up: Lisp Data Types

プログラミング向けの型
======================

Emacs Lispには, 大きく2種類の型があります.  Lispのプログラミングに関わ
るものと, 編集に関わるものです.  前者は, さまざまな形でLispの多くの実
装に見られます.  後者は, Emacs Lispに固有です.

* Menu:

* Integer Type::        Numbers without fractional parts.
* Floating Point Type:: Numbers with fractional parts and with a large range.
* Character Type::      The representation of letters, numbers and
                        control characters.
* Symbol Type::         A multi-use object that refers to a function,
                        variable, or property list, and has a unique identity.
* Sequence Type::       Both lists and arrays are classified as sequences.
* Cons Cell Type::      Cons cells, and lists (which are made from cons cells).
* Array Type::          Arrays include strings and vectors.
* String Type::         An (efficient) array of characters.
* Vector Type::         One-dimensional arrays.
* Char-Table Type::     One-dimensional sparse arrays indexed by characters.
* Bool-Vector Type::    One-dimensional arrays of `t' or `nil'.
* Function Type::       A piece of executable code you can call from elsewhere.
* Macro Type::          A method of expanding an expression into another
                          expression, more fundamental but less pretty.
* Primitive Function Type::     A function written in C, callable from Lisp.
* Byte-Code Type::      A function written in Lisp, then compiled.
* Autoload Type::       A type used for automatically loading seldom-used
                        functions.



File: elisp-ja, Node: Integer Type, Next: Floating Point Type, Prev: Programming Types, Up: Programming Types

整数型
------

Emacs Lispにおける整数の値の範囲は, ほとんどの計算機では, 
-134217728から134217727（28ビット長. つまり
-2**27
から2**27 - 1）です.  （計算機によっては, より広い範囲になる. ）Emacs
Lispの算術演算関数は, 桁溢れ（オーバフロー）を検査しないことを覚えてお
いてください.  したがって, ほとんどの計算機では, `(1+ 134217727)'は-
134217728となります.

整数の入力構文は, （10を基数とした）数字の並びであり, 先頭に符号があっ
てもよく, また, 最後にピリオドがあってもかまいません.  Lispインタープ
リタが生成する表示表現では, 先頭の`+'や最後の`.'はありません.

     -1               ; 整数 -1
     1                ; 整数 1
     1.               ; これも整数 1
     +1               ; これも整数 1
     268435457        ; 28ビット長整数では, これも整数 1

より詳しくは, *Note Numbers::.



File: elisp-ja, Node: Floating Point Type, Next: Character Type, Prev: Integer Type, Up: Programming Types

浮動小数点数
------------

Emacsは浮動小数点数を扱えます（ただし, コンパイル時のオプションで使用
不可にできる）.  浮動小数点数の範囲は, 計算機に依存します.

浮動小数点数の表示表現には, 小数点（に続けて1桁以上の小数部分）または
指数, あるいは, その両方が必要です.  たとえば, `1500.0', `15e2',
`15.0e2', `1.5e3', `.15e4'は, 同じ1500という値の浮動小数点数を書く5つ
の方法です.  どれも, まったく等価です.

詳しくは, *Note Numbers::.



File: elisp-ja, Node: Character Type, Next: Symbol Type, Prev: Floating Point Type, Up: Programming Types

文字型
------

Emacs Lispにおける"文字"（character）は, 
整数以外の何物でもありません. 
いいかえれば, 文字はその文字コードで表現されます. 
たとえば, 文字`A'は整数 65と表現されます. 

プログラムで個々の文字を独立に使うことはあまりありません.  文字を並べ
た*文字列*（strings）として扱うことが断然多いのです.  *Note String
Type::.

文字列内, バッファ内, ファイル内の文字は, 現時点では, 0から524287まで
の範囲, 19ビット長に制限されます.  しかし, この範囲の値すべてが正しい
文字コードではありません.  0から127までのコードはASCIIコードです.  そ
れ以外は, 非ASCIIです（*Note Non-ASCII Characters::）.  キーボード入力
を表す文字は, コントロール, メタ, シフトなどの修飾キーを符号化するため
に, 範囲がより広くなります.

文字は, 実際には整数ですから, 文字の表示表現は10進数です.  また, 文字
の入力構文として10進数も可能ですが, Lispプログラムでこのように文字を書
くのは最悪です.  Emacs Lispに用意してある文字向けの特別な入力構文を*つ
ねに*使うべきです.  これらの構文は疑問符で始まります.

英数字向けの普通の入力構文は, 疑問符に続けて1つの英数字を書きます.  し
たがって, 文字`A'は`?A', 文字`B'は`?B', 文字`a'は`?a'と書きます.

たとえば, つぎのとおりです.

     ?Q => 81     ?q => 113

同じ入力構文を句読点文字にも使えますが, `\'を追加して, Lispコードを編
集するEmacsコマンドが混乱しないようにすることがよいでしょう.  たとえば, 
空白文字は`?\ 'と書きます.  文字`\'は, クォートするために2つめの`\'を
使う*必要があり* `?\\'です.

コントロールg, バックスペース, タブ, 改行, 垂直タブ, ページ送り, 復帰, 
エスケープは, それぞれ, `?\a', `?\b', `?\t', `?\n', `?\v', `?\f',
`?\r', `?\e'と書きます.  つまり, つぎのとおりです.

     ?\a => 7                 ; C-g
     ?\b => 8                 ; バックスペース,  BS, C-h
     ?\t => 9                 ; タブ,  TAB, C-i
     ?\n => 10                ; 改行, C-j
     ?\v => 11                ; 垂直タブ, C-k
     ?\f => 12                ; ページ送り文字, C-l
     ?\r => 13                ; 復帰, RET, C-m
     ?\e => 27                ; エスケープ文字, ESC, C-[
     ?\\ => 92                ; バックスラッシュ文字, \

バックスラッシュで始まる系列は"エスケープシーケンス"（escape sequences）
とも呼びます.  バックスラッシュが, エスケープ文字の役割を果たすからで
す.  この使い方は, 文字ESCとは関係ありません.

コントロール文字は別の入力構文でも表現できます.  疑問符に続けてバック
スラッシュ, カレット（`^'）, そして, 対応するコントロールでない文字を
大文字か小文字で書きます.  たとえば, `?\^I'も`?\^i'も, 値が9である文字
`C-i'の正しい入力構文です.

カレットのかわりに, `C-'を使ってもかまいません.  ですから, `?\C-i'は,
`?\^I'や`?\^i'と等価です.

     ?\^I => 9     ?\C-I => 9

文字列やバッファ内ではASCIIのコントロール文字だけが許されますが, キー
ボード入力においては`C-'で任意の文字をコントロール文字にできます.  こ
れらの非ASCIIコントロール文字の文字コードは, 対応する非コントロール文
字の文字コードと2**26 のビットを含みます.  普通の端末では, 非ASCIIコン
トロール文字を生成する手立てはありませんが, Xウィンドウシステムや他の
ウィンドウシステムでは, 簡単に生成できます.

歴史的な理由で, EmacsはDEL文字を`?'に対応したコントロール文字として扱
います.

     ?\^? => 127     ?\C-? => 127

その結果, 今のところ, Xウィンドウシステムのもとでは意味のある文字
`Control-?'を`\C-'では表現できません.

ファイルや文字列に現れるコントロール文字を表現するには, `^'構文を勧め
ます.  キーボード入力のコントロール文字には, `C-'構文が好ましいです. 
どちらを使ってもプログラムの意味には影響しませんが, それを読む人には理
解の手助けになるかもしれません.

"メタ文字"（meta character）は, META修飾キーを使って打った文字です. 
そのような文字を表す整数は, （ほとんどの計算機では負の数になる）2**27 
のビットがセットされています.  上位のビットをメタや他の修飾子に用いる
ことで, 基本となる文字コードの範囲をできるだけ大きくします.

文字列では, メタ文字を表すASCII文字には2**7 のビットを付加します.  つ
まり, 文字列に収められるメタ文字のコードは128から255の範囲であり, 任意
のASCII文字のメタ変種を使えます.  （Emacs 18やそれ以前では, この方式を
文字列の外にある文字にも使っていた. ）

メタ文字の入力構文には`\M-'を使います.  たとえば, `?\M-A'は`M-A'です.
`\M-'と一緒に8進文字コードも使えますし（下記参照）, `\C-'や文字向けの
他の構文も使えます.  したがって, `M-A'は`?\M-A'と書いたり`?\M-\101'と
書けます.  同様に, `C-M-b'は`?\M-\C-b', `?\C-\M-b', `?\M-\002'と書けま
す.

図形文字の大文字小文字は, その文字コードで示されます.  たとえば, ASCII 
では`a'と`A'の文字を区別します.  しかし, ASCIIではコントロール文字の大
文字小文字を表現できません.  Emacsでは, コントロール文字を打つときに使っ
たシフトキーを表すために2**25 のビットを付加します.  このような区別はX
端末や他の特別な端末を使っている場合に限り可能です.  普通の端末ではこ
のような区別を計算機に送れません.

Xウィンドウシステムでは, 文字に設定可能な修飾ビットが他に3つあります.
"ハイパー"（hyper）, "スーパー"（super）, "アルト"（alt）です.  これら
の修飾ビットの構文は, `\H-', `\s-', `\A-'です.  （これらのプレフィック
スでは, 大文字小文字を区別する. ）したがって, `?\H-\M-\A-x'は
`Alt-Hyper-Meta-x'を表します.  数値的には, アルトは2**22, スーパーは
2**23, ハイパーは2**24のビット値です.

文字向けのもっとも汎用の入力構文では, 文字コードを8進数や16進数で表現
します.  8進数を使うには, 順に, 疑問符, バックスラッシュ, （3桁までの）
8進数字文字コードを書きます.  たとえば, `?\101'は文字`A'を表し,
`?\001'は文字`C-a'を表し, `?\002'は文字`C-b'を表します.  この構文で任
意のASCII文字を表現できますが, ASCIIでの表現よりも8進数値で表現するこ
とが重要な場合に限るべきです.

     ?\012 => 10         ?\n => 10         ?\C-j => 10
     ?\101 => 65         ?A => 65

16進数を使うには, 順に, 疑問符, バックスラッシュ, `x', 16進数字文字コー
ドを書きます.  16進数の桁数はいくつでもよいので, 任意の文字コードを表
現できます.  したがって, `?\x41'は文字`A'を表し, `?\x1'は文字`C-a'を表
し, `?\x8e0'はグレーブアクセント付きの文字`a'を表します.

特別なエスケープの意味を持たないどんな文字のまえにもバックスラッシュを
付けることができ, しかも, 無害です.  したがって, `?\+'は`?+'に等価です. 
ほとんどの文字のまえにバックスラッシュを付ける理由はありません.  しか
しながら, Lispコードを編集するEmacsコマンドが混乱しないように,
`()\|;'`"#.,'のいずれかの文字のまえにはバックスラッシュを付けるべきで
す.  空白, タブ, 改行, ページ送りのような白文字のまえにもバックスラッ
シュを付けるべきです.  しかしながら, タブなどの実際の白文字のかわりに,
`\t'などの読みやすいエスケープシーケンスを使ったほうが明確です.



File: elisp-ja, Node: Symbol Type, Next: Sequence Type, Prev: Character Type, Up: Programming Types

シンボル型
----------

GNU Emacs Lispにおける"シンボル"（symbol）は, 名前を持ったオブジェクト
です.  シンボル名は, シンボルの表示表現としての役割があります.  普通の
使い方では, 名前は一意です.  つまり, 2つのシンボルが同じ名前を持つこと
はありません.

シンボルは, 変数としての役割, 関数名としての役割, あるいは, 属性リスト
を保持する役割を果たします.  また, 他のすべてのLispオブジェクトと区別
するためだけの役割を果たすこともあり, データ構造の内部にそのようなシン
ボルが存在することを正確に認識できます.  ある場面においては, 普通, こ
れらのうちの1つの使い方をします.  しかし, ある1つのシンボルに対してす
べての使い方をしてもかまいません.

シンボル名には, どんな文字でも含められます.  ほとんどのシンボル名は, 
英文字, 数字, `-+=*/'の句読点文字で書かれます.  そのような名前では, 特
別な書き方は必要ありません.  名前が数に見えなければ, 名前を構成する文
字はなんでもよいのです.  （名前が数に見えるときには, 名前の先頭に`\'を
書いてシンボルであると強制する. ）`_~!@$%^&:<>{}'の文字はあまり使われ
ませんが, これらにも特別な書き方は必要ありません.  これら以外の文字は, 
バックスラッシュでエスケープすれば, シンボル名に含められます.  文字列
におけるバックスラッシュの用法とは対照的に, シンボル名におけるバックス
ラッシュは, 直後の1文字をクォートするだけです.  たとえば, 文字列では
`\t'はタブ文字を表しますが, シンボル名では英文字`t'をクォートするだけ
です.  名前にタブ文字を含むシンボルを書くには, 実際に（バックスラッシュ
の直後に）タブを使う必要があります.  しかし, そのようなことをするのは
皆無でしょう.

     Common Lispに関した注意：` ' Common Lispでは, 小文字を明示的にエ
     スケープしない限り, 小文字をつねに大文字に『変換』する.  Emacs
     Lispでは, 大文字と小文字を区別する.

シンボル名の例をいくつかあげましょう.  5番目の例の`+'は, 数として読ま
れるのを防ぐためにエスケープしてあることに注意してください.  6番目の例
では, これは必要ありません.  なぜなら, 名前の残りの部分が数としては不
正だからです.

     foo                 ; `foo'という名前のシンボル
     FOO                 ; `FOO'という名前のシンボル, `foo'とは別
     char-to-string      ; `char-to-string'という名前のシンボル
     1+                  ; `1+'という名前のシンボル
                         ;   （整数の`+1'ではない）
     \+1                 ; `+1'という名前のシンボル
                         ;   （読みにくい名前）
     \(*\ 1\ 2\)         ; `(* 1 2)'という名前のシンボル（悪い名前）
     +-*/_~!@$%^&=:<>{}  ; `+-*/_~!@$%^&=:<>{}'という名前のシンボル
                         ;   これらの文字をエスケープする必要はない



File: elisp-ja, Node: Sequence Type, Next: Cons Cell Type, Prev: Symbol Type, Up: Programming Types

シーケンス型
------------

"シーケンス"（sequence）とは, 要素の順序集合を表現するLispオブジェクト
です.  Emacs Lispには2種類のシーケンス, つまり, リストと配列があります. 
したがって, リスト型や配列型のオブジェクトは, シーケンス型でもあると考
えられます.

配列はさらに, 文字列, ベクトル, 文字テーブル, ブールベクトルに細分され
ます.  ベクトルは任意の型の要素を保持できますが, 文字列の要素は文字で
ある必要があり, ブールベクトルの要素は`t'か`nil'のいずれかである必要が
あります.  バッファ内の文字のように, 文字列内の文字はテキスト属性を持
てます（*Note Text Properties::）.  ベクトルとブールベクトル (1)
(*Note Sequence Type-Footnotes::) では, それらの要素が文字であったとし
ても, テキスト属性を扱えません.  文字テーブルは, ベクトルに似ています
が, 正しい文字コードで添字付けします.

リスト, 文字列, および, その他の配列型は別のものですが, それらには重要
な類似性があります.  たとえば, それらすべてに長さLがあり, それらのすべ
ての要素は0からL-1で添字付けできます.  シーケンス関数と呼ばれるいくつ
かの関数は, 任意のシーケンス型を扱います.  たとえば, シーケンスから指
定した添字の要素を取り出すには, 関数`elt'を使います.  *Note Sequences
Arrays Vectors::.

一般には, 同一のシーケンスを二度読み取ることは不可能です.  というのは, 
読むたびにつねに新たにシーケンスを作成するからです.  シーケンスの入力
構文を二度読むと, 同じ内容の2つのシーケンスを得ることになります.  1つ
例外があります.  空リスト`()'は, つねに同じオブジェクト`nil'を表します.


File: elisp-ja  Node: Sequence Type-Footnotes, Up: Sequence Type

(1) 【訳注】ベクトルのみの誤り？



File: elisp-ja, Node: Cons Cell Type, Next: Array Type, Prev: Sequence Type, Up: Programming Types

コンスセルとリスト型
--------------------

"コンスセル"（cons cell）とは, CARスロットおよびCDRスロットと呼ばれる2
つのポインタから成るオブジェクトです.  各スロットは, 任意のLispオブジェ
クトを"指す"ことができます.  また, 現在CARスロットが指しているオブジェ
クトがなんであれ, 『コンスセルのCARは』といったいい方をします.  CDRに
ついても同様です.

"リスト"（list）はコンスセルが連なったものであり, 各コンスセルのCDRス
ロットは, 後続のコンスセルを指すか空リストを指します.  リストに作用す
る関数については, *Note Lists::.  ほとんどのコンスセルは, リストの一部
分として使われるので, "リスト構造"（list structure）という用語は, コン
スセルから成る任意の構造のことを意味します.

CARやCDRという名称は, Lispの歴史に由来します. 
最初のLispはIBM 704で動作していました. 
この計算機では, ワードを2つの部分, 『番地』（address）部分, 
『減数』（decrement）部分と呼ばれるものに分けていました. 
CARはレジスタの番地部分の内容（Contents of Address Register）を
取り出す命令であり, 
CDRはレジスタの減数部分の内容（Contents of Decrement Register）を
取り出す命令でした. 
一方, 『コンスセル』という名称は, 
これらを作成する関数`cons'からきています. 
この関数名は, その目的, セルを作る（construction of cells）からきています. 

コンスセルはLispの核心なので, 『コンスセルではないオブジェクト』に対す
る名称もあります.  これらのオブジェクトを"アトム"（atoms）と呼びます.

リストの入力構文と表示表現は同一です.  開き括弧で始まり, 任意個の要素, 
閉じ括弧で終えます.

読み取り時には, 括弧の内側の各オブジェクトが, リストの各要素になります. 
つまり, これらの要素からなるコンスセルを作ります.  コンスセルのCARスロッ
トで要素を指します.  同じコンスセルのCDRスロットで, リスト上のつぎの要
素を保持している, リストのつぎのコンスセルを指します.  最後のコンスセ
ルのCDRスロットは`nil'を指します.

リストは, コンスセルを1対の箱で表して図示できます.  （Lispリーダがこの
ような図表示を読むことはない.  人間や計算機が理解できるテキスト表記と
違い, 箱を用いた図表示は人間だけが理解できる. ）つぎの図は, 3つの要素
から成るリスト`(rose violet buttercup)'を表します.

         -- ---      -- ---      -- ---
        |   |   |--> |   |   |--> |   |   |--> nil
         -- ---      -- ---      -- ---
          |            |            |
          |            |            |
           --> rose     --> violet   --> buttercup

この図で, 各箱は, 任意のLispオブジェクトを指すことができるスロットを表
します.  箱の対でコンスセルを表します.  各矢印は, アトムや他のコンスセ
ルであるLispオブジェクトを指すポインタです.

この例では, 最初のコンスセルのCARを表す最初の箱は, `rose'（シンボル）
を指しています.  あるいは, `rose'（シンボル）を『含んでいる』ともいい
ます.  最初のコンスセルのCDRを表す2番目の箱は, つぎの1対の箱, 2番目の
コンスセルを指しています.  2番目のコンスセルのCARは`violet'であり, こ
のコンスセルのCDRは3番目のコンスセルです.  3番目の（最後の）コンスセル
のCDRは, `nil'です.

同じリスト`(rose violet buttercup)'を別の方法で図表示するとつぎのよう
になります.

      ---------------       ----------------       -------------------
     | car   | cdr   |     | car    | cdr   |     | car       | cdr   |
     | rose  |   o-------->| violet |   o-------->| buttercup |  nil  |
     |       |       |     |        |       |     |           |       |
      ---------------       ----------------       -------------------

内部に要素を持たないリストは, "空リスト"（empty list）です.  これはシ
ンボル`nil'と同一です.  いいかえれば, `nil'はシンボルでもありリストで
もあります.

Lispの構文で書き表したリストの例を示します.

     (A 2 "A")            ; 3要素のリスト
     ()                   ; 要素を持たないリスト（空リスト）
     nil                  ; 要素を持たないリスト（空リスト）
     ("A ()")             ; 文字列`"A ()"'だけの1要素のリスト
     (A ())               ; `A'と空リストから成る2要素のリスト
     (A nil)              ; 上と同じ
     ((A B C))            ; 1要素のリスト
                          ;   （その要素は3要素のリスト）

リスト`(A ())'や, これと同じ`(A nil)'を箱と矢印で書くとつぎのようにな
ります.

         -- ---      -- ---
        |   |   |--> |   |   |--> nil
         -- ---      -- ---
          |            |
          |            |
           --> A        --> nil

* Menu:

* Dotted Pair Notation::        An alternative syntax for lists.
* Association List Type::       A specially constructed list.



File: elisp-ja, Node: Dotted Pair Notation, Next: Association List Type, Prev: Cons Cell Type, Up: Cons Cell Type

ドット対記法
............

"ドット対記法"（dotted pair notation）とは, CARとCDRを明示したコンスセ
ルを表すもう1つの構文です.  この構文では, `(A . B)'で, CARがオブジェク
トAでありCDRがオブジェクトBであるコンスセルを表します.  したがって, ドッ
ト対記法は, リストの構文よりさらに汎用性があります.  ドット対記法では, 
リスト`(1 2 3)'は, `(1 .  (2 . (3 . nil)))'と書けます.  `nil'で終るリ
ストならば, どちらの記法でも書き表せますが, リスト記法のほうがわかりや
すくて便利です.  リストを表示するときには, コンスセルのCDRがリスト以外
の場合に限ってドット対記法を使います.

ドット対記法を箱で表現してみます.  つぎの例は`(rose . violet)'を表した
ものです.

         -- ---
        |   |   |--> violet
         -- ---
          |
          |
           --> rose

最後のCDRが`nil'以外であるようなコンスセルの連鎖を表現するために, リス
ト記法にドット対記法を組み合わせることもできます.  リストの最後の要素
のあとにドットを書き, 続けて, 最後のコンスセルのCDRを書きます.  たとえ
ば, `(rose violet . buttercup)'は, `(rose . (violet . buttercup))'に等
価です.  このオブジェクトはつぎのようになります.

         -- ---      -- ---
        |   |   |--> |   |   |--> buttercup
         -- ---      -- ---
          |            |
          |            |
           --> rose     --> violet

`(rose . violet . buttercup)'という構文は不正です.  これが意味すること
はなにもありません.  たとえあったとしても, CDRを`violet'用にすでに使っ
ているコンスセルのCDRに`buttercup'を置けということになります.

リスト`(rose violet)'は, `(rose . (violet))'に等価であり, つぎのように
図示できます.

         -- ---      -- ---
        |   |   |--> |   |   |--> nil
         -- ---      -- ---
          |            |
          |            |
           --> rose     --> violet

同様に, 3要素のリスト`(rose violet buttercup)'は, `(rose . (violet
. (buttercup)))'に等価です.
つぎのように図示できます.

         -- ---      -- ---      -- ---
        |   |   |--> |   |   |--> |   |   |--> nil
         -- ---      -- ---      -- ---
          |            |            |
          |            |            |
           --> rose     --> violet   --> buttercup



File: elisp-ja, Node: Association List Type, Next: Array Type, Prev: Dotted Pair Notation, Up: Cons Cell Type

連想リスト型
............

"連想リスト"（association list）, すなわち, "alist"は, 各要素がコンス
セルであるように特別に構成したリストのことです.  各要素では, CARを"キー
"（key）と考え, CDRを"連想値"（associated value）と考えます.  （場合に
よっては, 連想値を, CDRのCARに保持することもある. ）連想リストはスタッ
クとして使われることがままあります.  というのは, リストの先頭に対応関
係を追加／削除するのが簡単だからです.

たとえば,

     (setq alist-of-colors
           '((rose . red) (lily . white)  (buttercup . yellow)))

は, 変数`alist-of-colors'に, 3要素の連想リストを設定します.  最初の要
素では, `rose'がキーであり, `red'が値です.

連想リストとそれらを操作する関数について詳しい説明は, *Note
Association Lists::.



File: elisp-ja, Node: Array Type, Next: String Type, Prev: Cons Cell Type, Up: Programming Types

配列型
------

"配列"（array）は, 任意のLispオブジェクトを指すための任意個のスロット
から成り, メモリの連続した場所に取ります.  配列のどの要素を参照しても, 
ほぼ同じ時間かかります.  一方, リストの要素を参照するときには, リスト
内の要素の位置に比例した時間が必要です.  （リストの末尾の要素を参照す
るには, リストの先頭の要素を参照するより時間がかかる. ）

Emacsには, 4つの配列型, つまり, 文字列, ベクトル, ブールベクトル, 文字
テーブルがあります.

文字列は文字の配列であり, ベクトルは任意のオブジェクトの配列です.  ブー
ルベクトルは, `t'や`nil'だけを保持できます.  これらの種類の配列は, 最
大の整数値までなら, 任意の長さにできます.  文字テーブルは, 正しい文字
コードで添字付けする疎な配列であり, 任意のオブジェクトを保持できます.

配列の最初の要素は0で添字付けする, 
2番目の要素は1で添字付けする, というようになります. 
これを"ゼロ原点"（zero-origin）の添字付けと呼びます. 
たとえば, 4つの要素からなる配列の添字は, 0, 1, 2, そして, 3です. 
最大の添字は, 配列の長さより1だけ小さくなります. 
いったん配列を作成すると, その長さは固定されます. 

Emacs Lispのすべての配列は1次元です.  （多くの他のプログラム言語では多
次元配列を扱えるが, それは本質的ではない.  配列の配列を作れば同じ効果
を得られる. ）配列のそれぞれの型に応じて, 専用の入力構文があります. 
詳しくは, 以下を参照してください.

配列型はシーケンス型に含まれ, 配列型は, 文字型, ベクトル型, ブールベク
トル型, 文字テーブル型を含みます.



File: elisp-ja, Node: String Type, Next: Vector Type, Prev: Array Type, Up: Programming Types

文字列型
--------

"文字列"（string）とは文字の配列です.  テキストエディタということから
予想されるように, Emacsではさまざまな目的に文字列を使います.  たとえば,
Lispシンボルの名前として, ユーザーへのメッセージとして, バッファから取
り出したテキストを表現するためなどです.  Lispの文字列は定数です.  つま
り, 文字列を評価すると同じ文字列になります.

文字列を操作する関数については, *Note Strings and Characters::.

* Menu:

* Syntax for Strings::
* Non-ASCII in Strings::
* Nonprinting Characters::
* Text Props and Strings::



File: elisp-ja, Node: Syntax for Strings, Next: Non-ASCII in Strings, Prev: String Type, Up: String Type

文字列の構文
............

文字列の入力構文は, `"like this"'のように, ダブルクォートで始めて, 任
意個の文字を書き, ダブルクォートで終えます.  文字列の中にダブルクォー
トを含めるには, バックスラッシュを直前に置きます.  つまり, `"\""'は, 
ダブルクォート1個だけから成る文字列です.  同様に, バックスラッシュを含
めるには, `"this \\ is a single embedded backslash"'のように, バックス
ラッシュを直前に置きます.

文字列の入力構文において, 改行文字は特別ではありません. 
ダブルクォートのあいだに改行を書けば, 
改行は文字列の文字になります. 
一方, エスケープした改行, つまり, `\'を直前に書くと, 
文字列の一部にはなりません. 
すなわち, Lispリーダは, 文字列を読む際にエスケープした改行を無視します. 
エスケープした空白`\ 'も, 同様に無視します. 

     "It is useful to include newlines
     in documentation strings,
     but the newline is \
     ignored if escaped."
          => "It is useful to include newlines 
     in documentation strings, 
     but the newline is ignored if escaped."



File: elisp-ja, Node: Non-ASCII in Strings, Next: Nonprinting Characters, Prev: Syntax for Strings, Up: String Type

文字列内の非ASCII文字
.....................

非ASCIIである国際化文字を文字列に含めるには, その文字をそのまま書きま
す.  Emacsの文字列（および, バッファ）では, 非ASCIIの表現方法が2つあり
ます.  ユニバイトとマルチバイトです.  マルチバイトバッファやマルチバイ
ト文字列, あるいは, マルチバイトとして訪問しているファイルなどのマルチ
バイトのソースから文字列定数を読み取るときには, 文字をマルチバイト文字
として読み取り, マルチバイト文字列にします.  ユニバイトのソースから文
字列定数を読み取るときには, 文字をユニバイト文字として読み取り, 文字列
はユニバイトになります.

マルチバイトの非ASCII文字は, 
必要な桁数の16進エスケープ`\xNNNNNNN'を用いて
書くこともできます. 
（マルチバイトの非ASCII文字のコードは, 256より大きい. ）
16進数字として正しくない文字で16進エスケープを終端します. 
16進数字の文字があとに続く場合には, `\ '（バックスラッシュと空白）と
書いて16進エスケープを終端します. 
たとえば, `\x8e0\ 'は, グレーブアクセント付きの`a'を表します. 
文字列定数内の`\ 'は, バックスラッシュ＋改行と同じです. 
文字列内の文字には含まれませんが, 先行する16進エスケープを終えます. 

マルチバイトの16進エスケープを使うと, 文字列はマルチバイトになります. 
ユニバイトの非ASCIIを文字コードで表現することもできますが, 文字コード
は128（8進0200）から255（8進0377）の範囲である必要があります.  こうす
ると, 文字列はユニバイトになります.
  
2種類のテキストの表現方法について詳しくは, *Note Text
Representations::.



File: elisp-ja, Node: Nonprinting Characters, Next: Text Props and Strings, Prev: Non-ASCII in Strings, Up: String Type

文字列内の非印字文字
....................

文字定数と同じバックスラッシュのエスケープシーケンスを文字列定数でも使
えます（ただし, 文字定数を開始する疑問符は書かない）.  たとえば, コン
マと空白で区切った非印字文字のタブと`C-a'を含む文字列を書くには, `"\t,
\C-a"'のようにします.  文字の入力構文については, *Note Character
Type::.

しかしながら, バックスラッシュのエスケープシーケンスすべてが, 文字列に
おいて正しいとは限りません.  文字列に含めることが可能なコントロール文
字は, ASCIIコントロール文字に限ります.  文字列では, ASCIIコントロール
文字の大文字小文字を区別しません.

正確にいえば, 文字列はメタ文字を保持できません.  しかし, 文字列をキー
列として使う場合には, 文字列内のASCII文字のメタ変種を表現するための特
別な慣習があります.  文字列定数内でメタ文字を表すために`\M-'の構文を使
うと, 文字列内のその文字に2**7 のビットを設定します.  `define-key'や
`lookup-key'に文字列を使うと, このコードは, 等価なメタ文字に変換されま
す.  *Note Character Type::.

文字列では, ハイパー, スーパー, アルトの修飾子を保持できません.



File: elisp-ja, Node: Text Props and Strings, Next: Vector Type, Prev: Nonprinting Characters, Up: String Type

文字列内のテキスト属性
......................

文字列は, 文字そのものに加えて, 文字の属性も保持できます.  このため, 
特別なことをしなくても, 文字列とバッファのあいだでテキストをコピーする
プログラムは, テキスト属性をコピーできます.  テキスト属性の意味につい
ては, *Note Text Properties::.  テキスト属性付きの文字列には, 特別な入
力構文があります.

     #("CHARACTERS" PROPERTY-DATA...)

ここで, PROPERTY-DATAは0個以上のつぎのような3つ組みです.

     BEG END PLIST

3つ組みの要素, BEGとENDは整数であり, 文字列内の添字の範囲を表します.
PLISTはその範囲の属性リストです.  たとえば,

     #("foo bar" 0 3 (face bold) 3 4 nil 4 7 (face italic))

は, 最初の3文字が`face'属性として`bold'を持ち, 最後の3文字が`face'属性
として`italic'を持つ, `foo bar'という文字列を表します.  （4番目の文字
にはテキスト属性はなく, その属性リストは`nil'.  デフォルトでは, 範囲に
含まれない文字には属性はないので, 属性リストが`nil'であるような範囲を
言及する必要はない. ）



File: elisp-ja, Node: Vector Type, Next: Char-Table Type, Prev: String Type, Up: Programming Types

ベクトル型
----------

"ベクトル"（vector）は, 任意の型の要素から成る1次元配列です.  ベクトル
の任意の要素を参照しても, それに必要な時間は一定です.  （リストでは, 
ある要素を参照するために必要な時間は, リストの先頭からの距離に比例する. 
）

ベクトルの表示表現は, 開き角括弧, 要素, 閉じ角括弧です.  これは, 入力
構文でもあります.  数や文字列と同様に, ベクトルは評価時には定数です.

     [1 "two" (three)]      ; 3要素のベクトル
          => [1 "two" (three)]

ベクトルに作用する関数については, *Note Vectors::.



File: elisp-ja, Node: Char-Table Type, Next: Bool-Vector Type, Prev: Vector Type, Up: Programming Types

文字テーブル型
--------------

"文字テーブル"（char-table）は, 任意の型の要素から成る1次元配列であり, 
文字コードで添字付けします.  文字テーブルには, 文字コードに情報を与え
るための多くの操作を簡単にする付加的な機能があります.  たとえば, 文字
テーブルは, 情報を継承するための親, デフォルト値, 特定目的向けの少数の
追加スロットを持てます.  文字テーブルでは, 文字集合全体に対して1つの値
を指定することもできます.

文字テーブルの表示表現はベクトルに似ていますが, 先頭に`#^'が余分に付き
ます.

文字テーブルを操作する特別の関数については, *Note Char-Tables::.  文字
テーブルはつぎのように使います.

   * 大文字小文字テーブル（*Note Case Tables::）.

   * 文字カテゴリテーブル（*Note Categories::）.

   * 表示テーブル（*Note Display Tables::）.

   * 構文テーブル（*Note Syntax Tables::）.



File: elisp-ja, Node: Bool-Vector Type, Next: Function Type, Prev: Char-Table Type, Up: Programming Types

ブールベクトル型
----------------

"ブールベクトル"（bool-vector）は, `t'か`nil'だけの要素から成る1次元配
列です.

ブールベクトルの表示表現は文字列に似ていますが, `#&'と長さで始まります. 
これに続く文字列定数が, ブールベクトルの実際の内容をビットマップで表し
ます.  つまり, 文字列の『各文字』は8ビット長のデータであり, ブールベク
トルのつぎの8個の要素を表します（1は`t'を表し, 0は`nil'を表す）.  文字
の最下位ビットが, ブールベクトルの小さい添字に対応します.  長さが8の倍
数でない場合には, 表示表現には余計な要素が含まれますが, 余計な部分に意
味はありません.

     (make-bool-vector 3 t)
          => #&3"\007"
     (make-bool-vector 3 nil)
          => #&3"\0"
     ;; 最初の3ビットだけを使っているので, 以下はすべて同じ
     (equal #&3"\377" #&3"\007")
          => t



File: elisp-ja, Node: Function Type, Next: Macro Type, Prev: Bool-Vector Type, Up: Programming Types

関数型
------

他のプログラム言語の関数が実行可能であるように, "Lisp関数"（Lisp
function）は実行可能なコードです.  しかしながら, Lispにおいては, 関数
は基本Lispオブジェクトであり, そのテキスト表現は副次的なものです.  こ
れらのLispオブジェクトはラムダ式です.  つまり, 先頭要素がシンボル
`lambda'であるリストです（*Note Lambda Expressions::）.

ほとんどのプログラム言語では, 名前のない関数を書くことは不可能です.
Lispでは, 本質的には, 関数に名前はありません.  ラムダ式のことを"無名関
数"（anonymous function）とも呼びます（*Note Anonymous Functions::）.
Lispにおける名前付き関数は, 実際には, 関数セルに正しい関数を収めたシン
ボルです（*Note Defining Functions::）.

多くの場合, LispプログラムのLisp式中に関数名を書くと関数が呼ばれます. 
しかし, 実行時に関数オブジェクトを構成したり取得して, 基本関数
`funcall'や`apply'で, それを呼び出すことができます.  *Note Calling
Functions::.



File: elisp-ja, Node: Macro Type, Next: Primitive Function Type, Prev: Function Type, Up: Programming Types

マクロ型
--------

"Lispマクロ"（Lisp macro）は, Lisp言語を拡張するユーザー定義の構造です. 
関数に似たオブジェクトで表現しますが, 引数渡しの意味は異なります.
Lispマクロは, リストの最初の要素がシンボル`macro'であり, リストのCDRが
`lambda'シンボルを含むLisp関数オブジェクトであるフォームです.

Lispマクロオブジェクトは, 通常, 組み込み関数`defmacro'で定義しますが,
Emacsにとっては, `macro'で始まるリストはマクロです.  マクロの書き方の
説明は, *Note Macros::.

*警告*：` 'Lispマクロとキーボードマクロ（*Note Keyboard Macros::）は, 
まったく別のものです.  単に『マクロ』といった場合には, Lispマクロを意
味するのであって, キーボードマクロのことではありません.



File: elisp-ja, Node: Primitive Function Type, Next: Byte-Code Type, Prev: Macro Type, Up: Programming Types

基本関数型
----------

"基本関数型"（primitive function）は, Lispから呼び出し可能な関数ですが,
C言語で書いてあります.  基本関数のことを"subr"とか"組み込み関数"
（built-in functions）とも呼びます.  （『subr』は『subroutine』からき
ている. ）ほとんどの基本関数は, 呼び出すときにすべての引数を評価します. 
引数すべてを評価しない基本関数を"スペシャルフォーム"（special form）と
呼びます（*Note Special Forms::）.

関数を呼び出す側からすれば, 関数が基本関数かどうかは関係ありません. 
しかし, Lispで書いた関数で基本関数を再定義しようとすると, 問題がありま
す.  というのは, 基本関数はCのコードから直接呼ばれるからです.  再定義
した関数をLispから呼び出す場合には新しい定義を使いますが, Cのコードは
組み込みの定義を使い続けるでしょう.  したがって, *基本関数を再定義しな
いでください*.

"関数"（function）という用語で, LispやCで書かれたEmacsのすべての関数を
指します.  Lispで書いた関数に関しては, *Note Function Type::.

基本関数には入力構文はなく, サブルーティン名を含むハッシュ記法で表示し
ます.

     (symbol-function 'car)          ; シンボルの関数セルを参照する
          => #<subr car>
     (subrp (symbol-function 'car))  ; 基本関数か？
          => t                       ; そのとおり



File: elisp-ja, Node: Byte-Code Type, Next: Autoload Type, Prev: Primitive Function Type, Up: Programming Types

バイトコード関数型
------------------

バイトコンパイラは, "バイトコード関数オブジェクト" （byte-code
function objects）を作り出します.  内部的には, バイトコード関数オブジェ
クトはベクトルによく似ています.  しかしながら, 評価過程においては, 関
数呼び出しのように見えるときには, このデータ型を特別に扱います.  バイ
トコンパイラについては, *Note Byte Compilation::.

バイトコード関数オブジェクトの表示表現と入力構文は, ベクトルに似ていま
すが, 開き角括弧`['のまえに`#'が付きます.



File: elisp-ja, Node: Autoload Type, Next: Editing Types, Prev: Byte-Code Type, Up: Programming Types

自動ロード型
------------

"自動ロードオブジェクト"（autoload object）は, 先頭要素がシンボル
`autoload'であるリストです.  実際の定義のかわりにシンボルの関数定義と
して使われ, 必要なときにロードすべき実際の定義を収めたLispコードファイ
ルを示します.  自動ロードオブジェクトには, ファイル名に加えて, 実際の
関数定義に関する他の情報も入っています.

ファイルをロードし終えると, シンボルには, 自動ロードオブジェクトではな
い新たな関数定義が入ります.  この新たな定義を始めからあったかのように
呼び出します.  ユーザーの視点からは, ロードしたファイル内の関数定義を
使って, 予想どおりに関数呼び出しが行われます.

自動ロードオブジェクトは, 普通, 関数`autoload'で作ります.  この関数は, 
シンボルの関数セルにオブジェクトを格納します.  より詳しくは, *Note
Autoload::.



File: elisp-ja, Node: Editing Types, Next: Type Predicates, Prev: Programming Types, Up: Lisp Data Types

編集向けの型
============

前節の型は一般のプログラム向けに使うもので, そのほとんどは, ほんどの
Lisp方言に共通しています.  Emacs Lispには, 編集に関連した目的向けにい
くつかのデータ型があります.

* Menu:

* Buffer Type::         The basic object of editing.
* Marker Type::         A position in a buffer.
* Window Type::         Buffers are displayed in windows.
* Frame Type::		Windows subdivide frames.
* Window Configuration Type::   Recording the way a frame is subdivided.
* Frame Configuration Type::    Recording the status of all frames.
* Process Type::        A process running on the underlying OS.
* Stream Type::         Receive or send characters.
* Keymap Type::         What function a keystroke invokes.
* Overlay Type::        How an overlay is represented.



File: elisp-ja, Node: Buffer Type, Next: Marker Type, Prev: Editing Types, Up: Editing Types

バッファ型
----------

"バッファ"（buffer）は, 編集可能なテキストを保持するオブジェクトです
（*Note Buffers::）.  ほとんどのバッファは, ディスクファイル（*Note
Files::）の内容を保持して編集できるようにしますが, 他の目的に使われる
ものもあります.  ほとんどのバッファは, ユーザーが見るためのものであり, 
ある期間, ウィンドウ（*Note Windows::）に表示されます.  しかし, バッファ
がいずれかのウィンドウに必ずしも表示される必要はありません.

バッファの内容は文字列によく似ていますが, Emacs Lispにおいては, バッファ
は文字列のようには使われず, 適用可能な操作も異なります.  たとえば, 既
存のバッファにテキストを効率よく挿入できますが, 文字列にテキストを『挿
入』するには, 部分文字列を連結する必要があり, まったく新しい文字列オブ
ジェクトになります.

各バッファには, "ポイント"（point）と呼ばれる特別な箇所があります
（*Note Positions::）.  どんなときにも, 1つのバッファが"カレントバッファ
"（current buffer）です.  ほとんどの編集コマンドは, カレントバッファの
ポイント付近の内容に作用します.  多くのEmacsの標準関数は, カレントバッ
ファ内にある文字を操作したり検査します.  本書には, これらの関数の説明
にあてた章が1つあります（*Note Text::）.

各バッファに関連付けられたデータ構造には, つぎのものがあります.

   * ローカル構文テーブル（*Note Syntax Tables::）

   * ローカルキーマップ（*Note Keymaps::）.  および

   * バッファにローカルな変数束縛リスト（*Note Buffer-Local
     Variables::）.

   * オーバレイ（*Note Overlays::）.

   * バッファ内のテキストのテキスト属性（*Note Text Properties::）.

ローカルキーマップと変数リストには, それぞれ, グローバルな束縛や値に優
先するものが入っています.  これらは, プログラムを変更せずに, 各バッファ
ごとに, プログラムのふるまいをカスタマイズするために使われます.

バッファは"間接"（indirect）でもよく, その場合, 別のバッファとテキスト
を共有しつつ異なった表示を行えます.  *Note Indirect Buffers::.

バッファには入力構文はありません.  バッファ名を含んだハッシュ記法で表
示します.

     (current-buffer)
          => #<buffer objects.texi>



File: elisp-ja, Node: Marker Type, Next: Window Type, Prev: Buffer Type, Up: Editing Types

マーカ型
--------

"マーカ"（marker）は, 特定のバッファ内の位置を表します.  したがって, 
マーカには2つの構成要素, つまり, バッファを示すものと位置を示すものが
あります.  バッファ内のテキストを変更すると, マーカがバッファ内の同じ2
つの文字のあいだをつねに指すことを保証するように, 位置の値を更新します.

マーカには入力構文はありません.  バッファ内の文字位置とバッファ名を含
んだハッシュ記法で表示します.

     (point-marker)
          => #<marker at 10779 in objects.texi>

マーカの検査, 作成, コピー, 移動の方法については, *Note Markers::.



File: elisp-ja, Node: Window Type, Next: Frame Type, Prev: Marker Type, Up: Editing Types

ウィンドウ型
------------

"ウィンドウ"（window）は, Emacsがバッファを表示するために使用する端末
画面の部分のことです.  各ウィンドウには, 対応付けられたバッファが1つあ
り, そのバッファの内容をウィンドウに表示しています.  一方, あるバッファ
が, 1つのウィンドウや複数のウィンドウに表示されることもあり, どのウィ
ンドウにも表示されないこともあります.

同時に複数のウィンドウが存在できますが, どんなときにも1つのウィンドウ
だけが"選択されたウィンドウ" （selected window）です.  これは, Emacsが
コマンドを受け付け可能なときにカーソルを（通常）表示するウィンドウです. 
選択されたウィンドウは, 通常, カレントバッファを表示しますが, これは必
須ではありません.

画面上のウィンドウはフレームにまとめられています.  各ウィンドウは, たっ
た1つのフレームに属します.  *Note Frame Type::.

ウィンドウには入力構文はありません.  ウィンドウ番号と表示中のバッファ
名を含んだハッシュ記法で表示します.  ウィンドウ番号は, ウィンドウを一
意に識別するためにあります.  これは, ウィンドウが表示しているバッファ
は頻繁に変わるからです.

     (selected-window)
          => #<window 1 on objects.texi>

ウィンドウを操作する関数の説明は, *Note Windows::.



File: elisp-ja, Node: Frame Type, Next: Window Configuration Type, Prev: Window Type, Up: Editing Types

フレーム型
----------

"フレーム"（frame）は, 画面上の矩形領域であって, 1つ以上のEmacsウィン
ドウを含みます.  フレームには最初は1つのウィンドウ（とミニバッファウィ
ンドウ）が含まれますが, これを左右や上下に小さなウィンドウに分割できま
す.

フレームには入力構文はありません.  フレームのタイトルとメモリ内のアド
レス（フレームを一意に識別するのに有用）を含んだハッシュ記法で表示しま
す.

     (selected-frame)
          => #<frame emacs@psilocin.gnu.org 0xdac80>

フレームを操作する関数の説明は, *Note Frames::.



File: elisp-ja, Node: Window Configuration Type, Next: Frame Configuration Type, Prev: Frame Type, Up: Editing Types

ウィンドウ構成型
----------------

"ウィンドウ構成"（window configuration）は, フレーム内のウィンドウの位
置／サイズ／内容に関する情報を記録し, 同じ配置のウィンドウをあとで再度
作成できるようにします.

ウィンドウ構成には入力構文はありません.  表示表現は,
`#<window-configuration>'のようになります.  ウィンドウ構成に関連した関
数の説明は, *Note Window Configurations::.



File: elisp-ja, Node: Frame Configuration Type, Next: Process Type, Prev: Window Configuration Type, Up: Editing Types

フレーム構成型
--------------

"フレーム構成"（frame configuration）は, すべてのフレームのウィンドウ
の位置／サイズ／内容に関する情報の記録です.  これは, 実際には, リスト
のCARが`frame-configuration'であり, リストのCDRが連想リストであるリス
トです.  連想リストの各要素で, そのCARに現れるフレーム1個を記述します.

フレーム構成に関連した関数の説明は, *Note Frame Configurations::.



File: elisp-ja, Node: Process Type, Next: Stream Type, Prev: Frame Configuration Type, Up: Editing Types

プロセス型
----------

単語"プロセス"（process）は, 通常, 実行中のプログラムを意味します.
Emacs自身, この種のプロセスとして実行されています.  しかし, Emacs Lisp
では, プロセスとは, Emacsプロセスが作成したサブプロセスを表すLispオブ
ジェクトのことです.  Emacsのサブプロセスで実行される, シェル, GDB,
ftp, コンパイラなどのプログラムは, Emacsの能力を拡張します.

Emacsサブプロセスは, Emacsからテキスト入力を受け取り, さらに処理できる
ようにEmacsにテキスト出力を返します.  Emacsはサブプロセスにシグナルを
送ることもできます.

プロセスオブジェクトに入力構文はありません.  プロセス名を含んだハッシュ
記法で表示します.

     (process-list)
          => (#<process shell>)

プロセスを作成したり削除したり, プロセスに関する情報を返したり, プロセ
スへ入力やシグナルを送ったり, プロセスから出力を受け取る関数に関する情
報は, *Note Processes::.



File: elisp-ja, Node: Stream Type, Next: Keymap Type, Prev: Process Type, Up: Editing Types

ストリーム型
------------

"ストリーム"（stream）は, 文字を出し入れする対象, つまり, 入力用に文字
を供給したり, 出力として文字を受け取ったりといったことに使えるオブジェ
クトです.  多くの異なる型をこのように使えます.  マーカ, バッファ, 文字
列, 関数です.  ほとんどの場合, 入力ストリーム（文字の供給源）は, キー
ボード, バッファ, ファイルから文字を取得します.  出力ストリーム（文字
の消費先）は, `*Help*'バッファなどのバッファやエコー領域に文字を送りま
す.

オブジェクト`nil'は, 他の意味に加えて, ストリームとしても使えます.  変
数`standard-input'や`standard-output'の値になります.  また, オブジェク
ト`t'も, ミニバッファ（*Note Minibuffers::）を使う入力ストリームやエコー
領域への出力（*Note The Echo Area::）を意味します.

ストリームには表示形式も入力構文もなく, その基本型で表示します.

構文解析関数や表示関数を含むストリームに関連した関数の説明は, *Note
Read and Print::.



File: elisp-ja, Node: Keymap Type, Next: Overlay Type, Prev: Stream Type, Up: Editing Types

キーマップ型
------------

"キーマップ"（keymap）は, ユーザーが打ったキーをコマンドに対応付けます. 
この対応付けは, ユーザーのコマンド入力をどのように実行するかを制御しま
す.  キーマップは, 実際には, リストであり, そのCARはシンボル`keymap'で
す.

キーマップの作成, プレフィックスキーの扱い方, グローバルやローカルなキー
マップ, キーバインディングの変更に関する情報は, *Note Keymaps::.



File: elisp-ja, Node: Overlay Type, Next: Type Predicates, Prev: Keymap Type, Up: Editing Types

オーバレイ型
------------

"オーバレイ"（overlay）は, バッファのある部分に作用する属性を指定しま
す.  各オーバレイは, バッファの指定した範囲に作用し, 属性リスト（属性
名と値の要素を交互に繰り返すリスト）を含んでいます.  オーバレイ属性は, 
バッファの一部を一時的に異なった方式で表示するために使われます.  オー
バレイ属性に入力構文はなく, バッファ名と位置範囲を含んだハッシュ記法で
表示します.

オーバレイの作成と使用法については, *Note Overlays::.



File: elisp-ja, Node: Type Predicates, Next: Equality Predicates, Prev: Editing Types, Up: Lisp Data Types

型述語
======

Emacs Lispインタープリタ自身は, 関数を呼び出すときに渡す実引数の型検査
を行いません.  そうできないのは, 他のプログラム言語が行うようには,
Lispの関数の引数にはデータ型の宣言がないからです.  したがって, 各実引
数がその関数で扱える型に属するかどうかを検査するのは, 各関数の責任です.

すべての組み込み関数は, 必要なときには実引数の型検査を行い, 引数が誤っ
た型であれば, エラー`wrong-type-argument'を通知します.  たとえば, `+'
に扱えない引数を渡すと, つぎのようになります.

     (+ 2 'a)
          error--> Wrong type argument: number-or-marker-p, a

読者のプログラムで, 異なる型を異なるように扱いたい場合には, 明示的に型
検査を行う必要があります.  オブジェクトの型を検査するもっとも一般的な
方法は, "型述語"（type predicate）関数を呼び出すことです.  Emacsには, 
各型ごとに型述語があり, 型を組み合わせたものに対する述語もあります.

型述語関数は1つの引数を取ります.  引数が適切な型に属していれば`t'を返
し, さもなければ`nil'を返します.  述語関数に関するLisp一般の慣習に従っ
て, ほとんどの型述語の名前は`p'で終ります.

以下は, リストの検査に述語`listp'を使い, シンボルの検査に述語`symbolp'
を使う例です.

     (defun add-on (x)
       (cond ((symbolp x)
              ;; Xがシンボルならば, それをLISTに加える
              (setq list (cons x list)))
             ((listp x)
              ;; Xがリストならば, その要素をLISTに追加する
              (setq list (append x list)))
             (t
              ;; シンボルとリストだけを扱う
              (error "Invalid argument %s in add-on" x))))

定義済みの型述語を, アルファベット順に, 参照先を併記してあげておきます.

`atom'
     *Note atom: List-related Predicates.

`arrayp'
     *Note arrayp: Array Functions.

`bool-vector-p'
     *Note bool-vector-p: Bool-Vectors.

`bufferp'
     *Note bufferp: Buffer Basics.

`byte-code-function-p'
     *Note byte-code-function-p: Byte-Code Type.

`case-table-p'
     *Note case-table-p: Case Tables.

`char-or-string-p'
     *Note char-or-string-p: Predicates for Strings.

`char-table-p'
     *Note char-table-p: Char-Tables.

`commandp'
     *Note commandp: Interactive Call.

`consp'
     *Note consp: List-related Predicates.

`display-table-p'
     *Note display-table-p: Display Tables.

`floatp'
     *Note floatp: Predicates on Numbers.

`frame-configuration-p'
     *Note frame-configuration-p: Frame Configurations.

`frame-live-p'
     *Note frame-live-p: Deleting Frames.

`framep'
     *Note framep: Frames.

`functionp'
     *Note functionp: Functions.

`integer-or-marker-p'
     *Note integer-or-marker-p: Predicates on Markers.

`integerp'
     *Note integerp: Predicates on Numbers.

`keymapp'
     *Note keymapp: Creating Keymaps.

`listp'
     *Note listp: List-related Predicates.

`markerp'
     *Note markerp: Predicates on Markers.

`wholenump'
     *Note wholenump: Predicates on Numbers.

`nlistp'
     *Note nlistp: List-related Predicates.

`numberp'
     *Note numberp: Predicates on Numbers.

`number-or-marker-p'
     *Note number-or-marker-p: Predicates on Markers.

`overlayp'
     *Note overlayp: Overlays.

`processp'
     *Note processp: Processes.

`sequencep'
     *Note sequencep: Sequence Functions.

`stringp'
     *Note stringp: Predicates for Strings.

`subrp'
     *Note subrp: Function Cells.

`symbolp'
     *Note symbolp: Symbols.

`syntax-table-p'
     *Note syntax-table-p: Syntax Tables.

`user-variable-p'
     *Note user-variable-p: Defining Variables.

`vectorp'
     *Note vectorp: Vectors.

`window-configuration-p'
     *Note window-configuration-p: Window Configurations.

`window-live-p'
     *Note window-live-p: Deleting Windows.

`windowp'
     *Note windowp: Basic Windows.

オブジェクトの型を調べるもっとも一般的な方法は, 関数`type-of'を呼び出
すことです.  各オブジェクトはたった1つの基本型に属することを思い出して
ください.  `type-of'はどの1つかを教えてくれます（*Note Lisp Data
Types::）.  しかし, `type-of'は, 基本型以外についてはなにも知りません. 
多くの場合, `type-of'より型述語を使うほうが便利でしょう.

 -- Function: type-of OBJECT
     この関数は, OBJECTの基本型を示すシンボルを返す.  その値は,
     `symbol', `integer', `float', `string', `cons', `vector',
     `char-table', `bool-vector', `subr', `compiled-function',
     `marker', `overlay', `window', `buffer', `frame', `process',
     `window-configuration'のシンボルのうちの1つ.

          (type-of 1)
               => integer
          (type-of 'nil)
               => symbol
          (type-of '())    ; `()'は`nil'
               => symbol
          (type-of '(x))
               => cons



