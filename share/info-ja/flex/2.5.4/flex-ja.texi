\input texinfo @c -*-texinfo-*-
@c           %**start of header
@c __ @<remove_this>setfilename       flex.info
@setfilename       flex-ja.info
@settitle          Flex
@synindex          fn cp
@synindex          vr cp
@synindex          tp cp
@synindex          pg cp
@setchapternewpage odd
@c           %**end of header
@c @finalout

@c SMALLBOOK NOTE: If using smallbook format, set smallbook also; 
@c this turns on TeX commands that reduce whitespace between sections.
@c Else clear smallbook.  --bob
@smallbook
@set smallbook
@c clear smallbook

@c GPL note.  at the request of RMS and vern paxson (who wrote Flex), i
@c have "ignore'd" the GPL.  it does not belong in most manuals.
@c --melissa, 3 march 1993

@c this files must have the nodes lines updated before making the info
@c version.  delete the copying node, then rerun the updates, then make
@c the info files.  --melissa, 4 march 1993


@c +--------------------------------------------------------------------+
@c | *********************** NOTES ************************************ |
@c | The following are notes on this file's configuration.              |
@c +--------------------------------------------------------------------+

@c Specify the edition of the manual, the date of the last update, and
@c the version of Flex to which this manual applies.
@c This information is printed in three places:
@c      1.First ifinfo section  2.title page  3.top node
@c To find the locations, search for %VERSIONDATA

@set EDITION 1.03
@set UPDATE-MONTH February 1993
@c @set VERSION 2.3.7

@c Include Flex 2.5 information, for Flex manual as published by ASCII
@set INCLUDEFLEX25INFO

@c @ifset INCLUDEFLEX25INFO
@set VERSION 2.5.4
@c @end ifset

@c =====================================================================
@c NOTES: There are a few places where the formatting/breaking doesn't 
@c look so good with my (older) version of TeX and Texinfo 2.9. I marked 
@c these with a "@c !!! ....". Can you just verify that they look OK in 
@c the printed version. Thanks!   --nick
@c Checked with TeX 2.991, texinfo.tex 2.100:  Good enough. --bob

@c Could have used syncodeindex instead of syncode to merge indices, but
@c the indices format OK this way. --bob

@c Tried `@@table @@kbd' instead `of @@table @@samp' for tables listing
@c options  since the @@kbd does not insert single quote marks in the
@c printed manual.  This looks better than the output produced with
@c @@samp.  In Info, the entries are enclosed with single quote marks,
@c but that looks OK in Info.  --bob

@c ISPELL CHECK: done, 26 Jan 1993 --bob
@c =====================================================================

@c +--------------------------------------------------------------------+
@c | The following appears in the info file and tells everyone what     |
@c | file is, and a little about the copying policy.                    |
@c +--------------------------------------------------------------------+

@ifinfo
This file documents Version @value{VERSION} of the Flex lexical scanner 
generator.

@c %VERSIONDATA
@c  edition, date, version
This is Edition @value{EDITION}, @value{UPDATE-MONTH}, @*
of the @cite{Flex Version @value{VERSION} Manual}.

Copyright (C) 1992, 1993 Free Software Foundation, Inc.

Permission is granted to make and distribute verbatim copies of this
manual provided the copyright notice and this permission notice are
preserved on all copies.

@ignore
Permission is granted to process this file through TeX and print the
results, provided the printed document carries copying permission notice
identical to this one except for the removal of this paragraph (this
paragraph not being relevant to the printed manual).

@end ignore

@c ummmm, problem; these sections aren't in the Flex manual.  --mew
@ignore
   Permission is granted to copy and distribute modified versions of this
   manual under the conditions for verbatim copying, provided also that the
   sections entitled ``GNU General Public License'' and ``TERMS AND
   CONDITIONS'' are included exactly as in the original, and provided that
   the entire resulting derived work is distributed under the terms of a
   permission notice identical to this one.

   Permission is granted to copy and distribute translations of this manual
   into another language, under the above conditions for modified versions,
   except that the sections entitled ``GNU General Public License'',
   ``TERMS AND CONDITIONS'' and this permission notice may be included in
   translations approved by the Free Software Foundation instead of in the
   original English.
@end ignore
@c i took this copyright from the Texinfo manual. --mew 23may93
Permission is granted to copy and distribute modified versions of this
manual under the conditions for verbatim copying, provided that the entire
resulting derived work is distributed under the terms of a permission
notice identical to this one.

Permission is granted to copy and distribute translations of this manual
into another language, under the above conditions for modified versions,
except that this permission notice may be stated in a translation approved
by the Free Software Foundation.
@end ifinfo

@c __ {{All the translated (original) text are commented out by '@c __ '.     }}
@c __ {{All the translated (original) TeX codes are commented out by '%% __ '.}}

@c +--------------------------------------------------------------------+
@c | The following is the title page definition.                        |
@c +--------------------------------------------------------------------+

@c %VERSIONDATA
@c  edition, date, version

@iftex
@shorttitlepage Flex
@end iftex

@titlepage
@title       Flex
@c __ @subtitle    The Lexical Scanner Generator
@c __ @subtitle    Edition @value{EDITION}, for Version @value{VERSION}
@c __ @subtitle    @value{UPDATE-MONTH}
@subtitle    字句スキャナ生成プログラム
@subtitle    Flex @value{VERSION}、@value{EDITION}版
@subtitle    1993年2月
@c __ @author      by G. T. Nicol
@author      G. T. Nicol 著
@page

@c +--------------------------------------------------------------------+
@c | The following is the general copyright notice.                     |
@c +--------------------------------------------------------------------+

@vskip 0pt plus 1filll
Flex Copyright @copyright{} by The Regents of the University of
California Berkeley.  
@*
All rights reserved.  

Flex is copyrighted by The Regents of the University of California
Berkeley and is not covered by the GNU General Public License.  It is
distributed by the Free Software Foundation under the terms of the
original copyright.  Please read the file @file{COPYING} in the Flex
distribution for details on the Flex copyright.

@sp 4

This manual@* 
Copyright @copyright{} 1992, 1993 Free Software Foundation

@sp 2
Published by the Free Software Foundation @*
59 Temple Place -- Suite 330@*
Boston, MA 02111-1307 USA @*
Printed copies are available for $20 each. @*
ISBN 1-882114-21-3

Permission is granted to make and distribute verbatim copies of this
manual provided the copyright notice and this permission notice are
preserved on all copies.

Permission is granted to copy and distribute modified versions of this
manual under the conditions for verbatim copying, provided that the entire
resulting derived work is distributed under the terms of a permission
notice identical to this one.

Permission is granted to copy and distribute translations of this manual
into another language, under the above conditions for modified versions,
except that this permission notice may be stated in a translation approved
by the Free Software Foundation.

@ignore
Permission is granted to process this file through TeX and print the
results, provided the printed document carries copying permission notice
identical to this one except for the removal of this paragraph (this
paragraph not being relevant to the printed manual).
@end ignore

@c ummmm, problem; these sections aren't in the Flex manual.  --mew
@ignore
@c i took this copyright from the Texinfo manual. --mew 23may93
Permission is granted to copy and distribute modified versions of this
manual under the conditions for verbatim copying, provided also that the
sections entitled ``GNU General Public License'' and ``TERMS AND
CONDITIONS'' are included exactly as in the original, and provided that
the entire resulting derived work is distributed under the terms of a
permission notice identical to this one.

Permission is granted to copy and distribute translations of this manual
into another language, under the above conditions for modified versions,
except that the sections entitled ``GNU General Public License'',
``TERMS AND CONDITIONS'' and this permission notice may be included in
translations approved by the Free Software Foundation instead of in the
original English.
@end ignore

@sp 2
Cover art by Etienne Suvasa.
@end titlepage
@page

@c +--------------------------------------------------------------------+
@c |                                                                    |
@c | This is where the file really begins. All the main themes should be|
@c | in here.                                                           |
@c |                                                                    |
@c +-----------------+-----------------+-----------------+--------------+ 
@c |       Name      |       Next      |     Previous    |       Up     |
@c +-----------------+-----------------+-----------------+--------------+ 
@ifnottex
@c @node             Top, Introduction, (dir), (dir)
@node Top, Introduction, (dir), (dir)
@top Flex

@c __ Flex is lexical scanner generator that takes a high-level description
@c __ language for input, and produces a scanner in C as output.  It works
@c __ faster, and produces faster scanners than the standard Unix utility, and
@c __ is largely POSIX and Lex compatible.
Flexは、
入力として高級記述言語を受け取り、
出力としてC言語で記述されたスキャナを生成する、
字句スキャナ生成プログラムです。
Flex自身が、
標準のUnixユーティリティと比較してより高速に動作しますし、
生成されるスキャナもより高速です。
また、
POSIX、Lexとの互換性も十分備えています。

@c %VERSIONDATA
@c edition, date, version
@c __ This is Edition 1.03, February 1993, of the Flex 2.3.7 Manual.
@c __ This is Edition @value{EDITION}, @value{UPDATE-MONTH},
@c __ of the @cite{Flex Version @value{VERSION} Manual}.
これは、
1993年2月発行、エディション1.03のFlex 2.3.7マニュアルです。
@c @ifset INCLUDEFLEX25INFO
Flex 2.5の新機能に関する情報も追加してあります。
Flex 2.5の新機能に関する節の名前には、
「（Flex 2.5の補足情報）」と書かれています。
@c @end ifset

@c __ ========================================================================
@c __ @menu
@c __ * Introduction::                The need for Flex and what it does.  
@c __ * Invoking Flex::               How to invoke Flex; command line options.
@c __ * Flex Descriptions::           The Flex description language
@c __ * Interfacing to Flex::         Connecting Flex scanners and C.  
@c __ * Other Flex Features::         Additional or uncommon Flex features.  
@c __ * Optimization::                How to optimize your Flex scanner.  
@c __ * More Examples::               Additional examples of using Flex.  
@c __ * Flex and Lex::                Differences; and their performance and
@c __                                 conformance with the POSIX standard.
@c __ * Useful Code::                 Code you can use in your scanners.  
@c __ * Summary::                     Summary of switches, variable etc.  
@c __ * Index::                       Index.  
@c __ 
@c __  --- The Detailed Node Listing ---
@c __ 
@c __ Introduction to Flex
@c __ 
@c __ * Problem Solving::             Flex as a problem solver
@c __ * General Programming::         Flex as a general programming tool
@c __ 
@c __ Invoking Flex
@c __ 
@c __ * Command Line Switches::       The command line options for Flex.
@c __ 
@c __ The Flex Description Language
@c __ 
@c __ * Comments::                    Explains the style of Flex comments.  
@c __ * Optional C Code::             Explains the optional C code section at the
@c __                                 top of a Flex definition.  
@c __ * Definitions::                 Tells you how to write definitions in Flex.  
@c __ * %%::                          Tells you what these delimiters mean.  
@c __ * Rules::                       Explains about the rule section if Flex 
@c __                                 files.  
@c __ * Pattern Matching::            Explains the parts used in pattern matching.  
@c __ * Regular Expressions::         Matching patterns.
@c __ * Start States::                How to activate a pattern matching rule
@c __                                 based upon some condition.  
@c __ 
@c __ The Pattern Section
@c __ 
@c __ * Characters::                  Characters in Flex.  Special characters.  
@c __ * Strings::                     What strings are in Flex, and special 
@c __                                 strings.  
@c __ * Character Classes::           Explains what character classes are and how to
@c __ use them.  
@c __ 
@c __ Start States
@c __ 
@c __ * Start States Explained::      Declaring start states, and how they affect
@c __                                 the scanner.  
@c __ * Activating States::           How to activate start states.  
@c __ * Start State Notes::           Notes on illegal declarations and on the 
@c __                                 power of exclusive start states.  
@c __ * Start State Example::         Example of using start states.
@c __ 
@c __ Interfacing to Flex
@c __ 
@c __ * Flex and C::                  The interface between C and Flex.
@c __ * An Example of Flex and C::    String substitution in a filter.  
@c __ * Flex and Bison::              How Flex and Bison fit together.  
@c __ * Another Example of Flex and Bison::  Another example of Flex and Bison.
@c __ 
@c __ Flex and Bison
@c __ 
@c __ * Interfacing Flex and Bison::  The general method.  
@c __ * YYSTYPE and yylval::          Passing more than just integers.  
@c __ 
@c __ Another Example of Flex and Bison
@c __ 
@c __ * The Database Language::       The definition of the database language.  
@c __ * The Implementation::          The files that parse the language.  
@c __ * Notes on the Implementation::  Some (brief) notes on why it was done the
@c __                                 way it was.  
@c __ 
@c __ Other Features of Flex
@c __ 
@c __ * Case Insensitive Scanners::   About scanners that ignore case.  
@c __ * Interactive Scanners::        Scanners for taking input from a user.  
@c __ * Table Compression and Scanner Speed::  Table compression and scanner speed
@c __ * Translation Tables::          Another way of grouping characters.  
@c __ * Multiple Input Buffers::      How to accept multiple input streams.  
@c __ * End-Of-File Rules::           Special rules for handling EOF.  
@c __ 
@c __ Case Insensitive Scanners
@c __ 
@c __ * The -i Switch::               How to ignore case in input.
@c __ 
@c __ Multiple Input Buffers
@c __ 
@c __ * Buffer Manipulation::         Buffer manipulation functions
@c __ * Example of Multiple Buffers::  An example of using multiple buffers
@c __ 
@c __ Optimizing the Scanner
@c __ 
@c __ * Optimizing for Speed::        The flags and topics relating to creating
@c __                                 fast scanners.  
@c __ * Optimizing for Size::         How to create smaller scanners.  
@c __ 
@c __ Optimizing for Speed
@c __ 
@c __ * Removing Backtracking::       By removing backtracking, you can have 
@c __                                 considerable impact on performance.
@c __ 
@c __ More Examples of Using Flex
@c __ 
@c __ * Example-Counting Words::      A wc like utility.  
@c __ * Example-Pascal Lexical Scanner::  An example of scanning a real language.  
@c __ * Example-Jargon Converter::    Convert Jargon file to Texinfo format.  
@c __ 
@c __ Flex and Lex
@c __ 
@c __ * Flex::                        
@c __ * Lex::                         
@c __ 
@c __ Flex 
@c __ 
@c __ * Flex and POSIX::              
@c __ 
@c __ Snippets of Useful Code
@c __ 
@c __ * Handling Comments::           
@c __ * Handling Strings::            
@c __ * Handling Numbers::            
@c __ * Multiple Scanners::           
@c __ * Miscellaneous::               
@c __ 
@c __ Summary 
@c __ 
@c __ * Switches Summary::            A summary of Flex command line switches 
@c __ * Summary or Flex Variables and Functions::  Summary of Flex variables 
@c __                                 and functions
@c __ * Summary of Flex Characters::  Flex accepts a character as itself, 
@c __                                 unless it is an operator, a special
@c __                                 character, or an escape sequence.  
@c __ * Summary of Flex Rules::       Rules in Flex have two parts.
@c __ @end menu
============================================================================
@menu
* Introduction::                Flexの必要性とその機能
* Invoking Flex::               Flexの起動方法、コマンドライン・オプション
* Flex Descriptions::           Flex記述言語
* Interfacing to Flex::         FlexスキャナとC言語の結合
* Other Flex Features::         追加的なFlex機能、一般的ではないFlex機能
* Optimization::                Flexスキャナの最適化方法
* More Examples::               Flexを使うための実例
* Flex and Lex::                FlexとLexの相違点、性能、POSIX標準への準拠度
* Useful Code::                 ユーザ・スキャナの中で使うことのできるコード
* Summary::                     オプション、変数などの要約
* Index::                       インデックス

 --- The Detailed Node Listing ---

Flex入門

* Problem Solving::             問題解決手段としてのFlex
* General Programming::         一般的なプログラミング・ツールとしてのFlex

Flexの起動

* Command Line Switches::       Flexのコマンドライン・オプション
@c @ifset INCLUDEFLEX25INFO
* Command Line Switches (Flex 2.5)::  同上（Flex 2.5の補足情報）
@c @end ifset

Flex記述言語

* Comments::                    Flexのコメント・スタイルの説明
* Optional C Code::             Flex定義の先頭のCコード・セクションの説明
* Definitions::                 Flexにおける定義の書き方
* %%::                          区切り文字%%の意味
* Rules::                       Flexファイルのルール・セクション
* Pattern Matching::            パターン・マッチングに使われる部分
* Regular Expressions::         パターンのマッチング
* Start States::                ある条件にもとづいてパターン・マッチング・
                                ルールを活性化させる方法
@c @ifset INCLUDEFLEX25INFO
* %option (Flex 2.5)::          %option指示子の説明
@c @end ifset

パターン・セクション

* Characters::                  Flexにおける文字、特殊文字
* Strings::                     Flexにおける文字列、特殊文字列
* Character Classes::           文字クラスの説明、その使い方
@c @ifset INCLUDEFLEX25INFO
* Character Class Expressions (Flex 2.5)::  同上（Flex 2.5の補足情報）
@c @end ifset

スタート状態

* Start States Explained::      スタート状態の宣言、スキャナに対する効果
* Activating States::           スタート状態の活性化方法
* Start State Notes::           不当な宣言、排他的スタート状態のパワーに
                                関する注
@c @ifset INCLUDEFLEX25INFO
* Start State Notes (Flex 2.5)::  同上 （Flex 2.5の補足情報）
@c @end ifset
* Start State Example::         スタート状態の使用例

Flexとのインターフェイス

* Flex and C::                  CとFlexのインターフェイス
@c @ifset INCLUDEFLEX25INFO
* Flex and C (Flex 2.5)::       同上（Flex 2.5の補足情報）
@c @end ifset
* An Example of Flex and C::    フィルタにおける文字列代替
* Flex and Bison::              FlexとBisonの協同
* Another Example of Flex and Bison::  FlexとBisonのもう１つの実例
@c @ifset INCLUDEFLEX25INFO
* Flex and C++ (Flex 2.5)::     C++とFlexのインターフェイス
                                （Flex 2.5の補足情報）
@c @end ifset

FlexとBison

* Interfacing Flex and Bison::  一般的な方法
* YYSTYPE and yylval::          単なる整数以上の情報の渡し方

FlexとBisonのもう１つの実例

* The Database Language::       データベース言語の定義
* The Implementation::          言語を解析するファイル
* Notes on the Implementation:: この実装を選択した理由に関する（簡単な）注

Flexの他の特徴

* Case Insensitive Scanners::   大文字・小文字を区別するスキャナ
* Interactive Scanners::        ユーザから入力を受け取るスキャナ
* Table Compression and Scanner Speed::  テーブル圧縮とスキャナのスピード
* Translation Tables::          文字をグループ化する別の方法
* Multiple Input Buffers::      複数の入力ストリームを受け付ける方法
* End-Of-File Rules::           EOFを処理するための特殊なルール

大文字・小文字を区別しないスキャナ

* The -i Switch::               入力において大文字・小文字を無視する方法

複数の入力バッファ

* Buffer Manipulation::         バッファ操作関数
@c @ifset INCLUDEFLEX25INFO
* Buffer Manipulation (Flex 2.5)::  同上（Flex 2.5の補足情報）
@c @end ifset
* Example of Multiple Buffers::  複数バッファを使う実例

スキャナの最適化

* Optimizing for Speed::        ファスト・スキャナを作るためのフラグ、
                                関連するトピック
* Optimizing for Size::         サイズの小さいスキャナの作り方

スピードの最適化

* Removing Backtracking::       バックトラッキングの除去による性能の
                                飛躍的向上

Flexを使うその他の実例

* Example-Counting Words::      wc風のユーティリティ
* Example-Pascal Lexical Scanner::  本物の言語をスキャンする実例
* Example-Jargon Converter::    専門用語ファイルのTexinfo形式への変換

FlexとLex

* Flex::                        Flex
* Lex::                         Lex

Flex 

* Flex and POSIX::              FlexとPOSIX
@c @ifset INCLUDEFLEX25INFO
* Flex and POSIX (Flex 2.5)::   FlexとPOSIX（Flex 2.5の補足情報）
@c @end ifset

役に立つコードの抜粋

* Handling Comments::           コメントの処理
* Handling Strings::            文字列の処理
* Handling Numbers::            数値の処理
* Multiple Scanners::           複数のスキャナ
* Miscellaneous::               その他

要約

* Switches Summary::            Flexコマンドライン・オプションの要約
@c @ifset INCLUDEFLEX25INFO
* Switches Summary (Flex 2.5)::  同上（Flex 2.5の補足情報）
@c @end ifset
* Summary or Flex Variables and Functions::  Flex変数、Flex関数の要約
@c @ifset INCLUDEFLEX25INFO
* Summary or Flex Variables and Functions (Flex 2.5)::
                                             同上（Flex 2.5の補足情報）
@c @end ifset
* Summary of Flex Characters::  演算子、特殊文字、エスケープ・シーケンス
                                以外の文字をその文字自身として受け付ける
* Summary of Flex Rules::       Flexルールの２つの構成要素
@end menu

========================================================================
@end ifnottex

@ignore

@@c +--------------------------------------------------------------------+
@@c |                                                                    |
@@c | This is the node for displaying copying information.               |
@@c |                                                                    |
@@c +-----------------+-----------------+-----------------+--------------+ 
@@c |       Name      |       Next      |     Previous    |       Up     |
@@c +-----------------+-----------------+-----------------+--------------+ 
@@node    Copying, Introduction, Top, Top
@@unnumbered GNU GENERAL PUBLIC LICENSE
@@center Version 1, February 1989

@@display
Copyright @@copyright{} 1989 Free Software Foundation, Inc.
675 Mass Ave, Cambridge, MA 02139, USA

Everyone is permitted to copy and distribute verbatim copies
of this license document, but changing it is not allowed.  
@@end display

@@unnumberedsec Preamble

The license agreements of most software companies try to keep users at
the mercy of those companies.  By contrast, our General Public License
is intended to guarantee your freedom to share and change free
software---to make sure the software is free for all its users.  The
General Public License applies to the Free Software Foundation's
software and to any other program whose authors commit to using it.  You
can use it for your programs, too.

When we speak of free software, we are referring to freedom, not
price.  Specifically, the General Public License is designed to make
sure that you have the freedom to give away or sell copies of free
software, that you receive source code or can get it if you want it,
that you can change the software or use pieces of it in new free
programs; and that you know you can do these things.

To protect your rights, we need to make restrictions that forbid
anyone to deny you these rights or to ask you to surrender the rights.
These restrictions translate to certain responsibilities for you if you
distribute copies of the software, or if you modify it.

For example, if you distribute copies of a such a program, whether
gratis or for a fee, you must give the recipients all the rights that
you have.  You must make sure that they, too, receive or can get the
source code.  And you must tell them their rights.  

We protect your rights with two steps: (1) copyright the software, and
(2) offer you this license which gives you legal permission to copy,
distribute and/or modify the software.  

Also, for each author's protection and ours, we want to make certain
that everyone understands that there is no warranty for this free
software.  If the software is modified by someone else and passed on, we
want its recipients to know that what they have is not the original, so
that any problems introduced by others will not reflect on the original
authors' reputations.  

The precise terms and conditions for copying, distribution and
modification follow.

@@c following enables GPL version 1 to fit into pages better
@@tex
\global\chapheadingskip = 30pt plus 8pt minus 4pt
\global\subsecheadingskip = 17pt plus 8pt minus 4pt
\global\secheadingskip = 21pt plus 8pt minus 4pt

\newskip\originalbaselineskip
\originalbaselineskip=\baselineskip
\global\baselineskip 11.5pt
@@end tex

@@iftex
@@unnumberedsec TERMS AND CONDITIONS
@@end iftex
@@ifinfo
@@center TERMS AND CONDITIONS
@@end ifinfo

@@enumerate
@@item
This License Agreement applies to any program or other work which
contains a notice placed by the copyright holder saying it may be
distributed under the terms of this General Public License.  The
``Program'', below, refers to any such program or work, and a ``work
based on the Program'' means either the Program or any work containing
the Program or a portion of it, either verbatim or with modifications.
Each licensee is addressed as ``you''.

@@item
You may copy and distribute verbatim copies of the Program's source code
as you receive it, in any medium, provided that you conspicuously and
appropriately publish on each copy an appropriate copyright notice and
disclaimer of warranty; keep intact all the notices that refer to this
General Public License and to the absence of any warranty; and give any
other recipients of the Program a copy of this General Public License
along with the Program.  You may charge a fee for the physical act of
transferring a copy.

@@item
You may modify your copy or copies of the Program or any portion of it,
and copy and distribute such modifications under the terms of Paragraph
1 above, provided that you also do the following:

@@itemize @@bullet{}
@@item
cause the modified files to carry prominent notices stating that you
changed the files and the date of any change; and

@@item
cause the whole of any work that you distribute or publish, that in
whole or in part contains the Program or any part thereof, either with
or without modifications, to be licensed at no charge to all third
parties under the terms of this General Public License (except that you
may choose to grant warranty protection to some or all third parties, at
your option).

@@item
If the modified program normally reads commands interactively when run,
you must cause it, when started running for such interactive use in the
simplest and most usual way, to print or display an announcement
including an appropriate copyright notice and a notice that there is no
warranty (or else, saying that you provide a warranty) and that users
may redistribute the program under these conditions, and telling the
user how to view a copy of this General Public License.

@@item
You may charge a fee for the physical act of transferring a copy, and
you may at your option offer warranty protection in exchange for a fee.
@@end itemize

Mere aggregation of another independent work with the Program (or its
derivative) on a volume of a storage or distribution medium does not
bring the other work under the scope of these terms.

@@item
You may copy and distribute the Program (or a portion or derivative of
it, under Paragraph 2) in object code or executable form under the terms
of Paragraphs 1 and 2 above provided that you also do one of the
following:

@@itemize @bullet{}
@@item
accompany it with the complete corresponding machine-readable source
code, which must be distributed under the terms of Paragraphs 1 and 2
above; or,

@@item
accompany it with a written offer, valid for at least three years, to
give any third party free (except for a nominal charge for the cost of
distribution) a complete machine-readable copy of the corresponding
source code, to be distributed under the terms of Paragraphs 1 and 2
above; or,

@@item
accompany it with the information you received as to where the
corresponding source code may be obtained.  (This alternative is allowed
only for non-commercial distribution and only if you received the
program in object code or executable form alone.)
@@end itemize

Source code for a work means the preferred form of the work for making
modifications to it.  For an executable file, complete source code means
all the source code for all modules it contains; but, as a special
exception, it need not include source code for modules which are
standard libraries that accompany the operating system on which the
executable file runs, or for standard header files or definitions files
that accompany that operating system.

@@item
You may not copy, modify, sub-license, distribute or transfer the
Program except as expressly provided under this General Public License.
Any attempt otherwise to copy, modify, sub-license, distribute or
transfer the Program is void, and will automatically terminate your
rights to use the Program under this License.  However, parties who have
received copies, or rights to use copies, from you under this General
Public License will not have their licenses terminated so long as such
parties remain in full compliance.

@@item
By copying, distributing or modifying the Program (or any work based on
the Program) you indicate your acceptance of this license to do so, and
all its terms and conditions.

@@item
Each time you redistribute the Program (or any work based on the
Program), the recipient automatically receives a license from the
original licensor to copy, distribute or modify the Program subject to
these terms and conditions.  You may not impose any further restrictions
on the recipients' exercise of the rights granted herein.

@@item
The Free Software Foundation may publish revised and/or new versions of
the General Public License from time to time.  Such new versions will be
similar in spirit to the present version, but may differ in detail to
address new problems or concerns.

Each version is given a distinguishing version number.  If the Program
specifies a version number of the license which applies to it and ``any
later version'', you have the option of following the terms and
conditions either of that version or of any later version published by
the Free Software Foundation.  If the Program does not specify a version
number of the license, you may choose any version ever published by the
Free Software Foundation.

@@item
If you wish to incorporate parts of the Program into other free programs
whose distribution conditions are different, write to the author to ask
for permission.  For software which is copyrighted by the Free Software
Foundation, write to the Free Software Foundation; we sometimes make
exceptions for this.  Our decision will be guided by the two goals of
preserving the free status of all derivatives of our free software and
of promoting the sharing and reuse of software generally.

@@iftex
@@heading NO WARRANTY
@@end iftex
@@ifinfo
@@center NO WARRANTY
@@end ifinfo

@@item
BECAUSE THE PROGRAM IS LICENSED FREE OF CHARGE, THERE IS NO WARRANTY FOR
THE PROGRAM, TO THE EXTENT PERMITTED BY APPLICABLE LAW.  EXCEPT WHEN
OTHERWISE STATED IN WRITING THE COPYRIGHT HOLDERS AND/OR OTHER PARTIES
PROVIDE THE PROGRAM ``AS IS'' WITHOUT WARRANTY OF ANY KIND, EITHER
EXPRESSED OR IMPLIED, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.  THE
ENTIRE RISK AS TO THE QUALITY AND PERFORMANCE OF THE PROGRAM IS WITH
YOU.  SHOULD THE PROGRAM PROVE DEFECTIVE, YOU ASSUME THE COST OF ALL
NECESSARY SERVICING, REPAIR OR CORRECTION.

@@item
IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING
WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MAY MODIFY AND/OR
REDISTRIBUTE THE PROGRAM AS PERMITTED ABOVE, BE LIABLE TO YOU FOR
DAMAGES, INCLUDING ANY GENERAL, SPECIAL, INCIDENTAL OR CONSEQUENTIAL
DAMAGES ARISING OUT OF THE USE OR INABILITY TO USE THE PROGRAM
(INCLUDING BUT NOT LIMITED TO LOSS OF DATA OR DATA BEING RENDERED
INACCURATE OR LOSSES SUSTAINED BY YOU OR THIRD PARTIES OR A FAILURE OF
THE PROGRAM TO OPERATE WITH ANY OTHER PROGRAMS), EVEN IF SUCH HOLDER OR
OTHER PARTY HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGES.
@@end enumerate

@@iftex
@@heading END OF TERMS AND CONDITIONS
@@end iftex
@@ifinfo
@@center END OF TERMS AND CONDITIONS
@@end ifinfo

@@tex
\baselineskip=\originalbaselineskip
@@end tex

@@unnumberedsec Appendix: How to Apply These Terms to Your New Programs

If you develop a new program, and you want it to be of the greatest
possible use to humanity, the best way to achieve this is to make it
free software which everyone can redistribute and change under these
terms.

To do so, attach the following notices to the program.  It is safest
to attach them to the start of each source file to most effectively
convey the exclusion of warranty; and each file should have at least the
``copyright'' line and a pointer to where the full notice is found.

@@smallexample
@@var{one line to give the program's name and a brief
idea of what it does.  } 
Copyright (C) 19@@var{yy} @@var{name of author}

This program is free software; you can redistribute
it and/or modify it under the terms of the GNU
General Public License as published by the Free
Software Foundation; either version 1, or (at your
option) any later version.

This program is distributed in the hope that it will
be useful, but WITHOUT ANY WARRANTY; without even
the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE.  See the GNU General
Public License for more details.

You should have received a copy of the GNU General
Public License along with this program; if not,
write to the Free Software Foundation, Inc., 
675 Mass Ave, Cambridge, MA 02139, USA.
@@end smallexample

@@noindent
Also add information on how to contact you by electronic and paper mail.  

If the program is interactive, make it output a short notice like this
when it starts in an interactive mode:

@@smallexample
Gnomovision version 69, Copyright (C) 19@@var{yy} 
@@var{name of author} Gnomovision comes with ABSOLUTELY NO 
WARRANTY; for details type `show w'.  
This is free software, and you are welcome to redistribute
it under certain conditions; type `show c' for details.  
@@end smallexample

The hypothetical commands `show w' and `show c' should show the
appropriate parts of the General Public License.  Of course, the
commands you use may be called something other than `show w' and `show
c'; they could even be mouse-clicks or menu items---whatever suits your
program.

You should also get your employer (if you work as a programmer) or your
school, if any, to sign a ``copyright disclaimer'' for the program, if
necessary.  Here a sample; alter the names:

@@*
@@smallexample
Yoyodyne, Inc., hereby disclaims all copyright interest in 
the program `Gnomovision' (a program to direct compilers to 
make passes at assemblers) written by James Hacker.

@@var{signature of Ty Coon}, 1 April 1989
Ty Coon, President of Vice
@@end smallexample

@@noindent
That's all there is to it!

@end ignore

@c Experiment with smaller amounts of whitespace between chapters
@c and sections in smallbook format.
@ifset smallbook
@tex
\global\chapheadingskip = 15pt plus 4pt minus 2pt 
\global\secheadingskip = 12pt plus 3pt minus 2pt
\global\subsecheadingskip = 9pt plus 2pt minus 2pt
@end tex
@end ifset
@c +--------------------------------------------------------------------+
@c |                                                                    |
@c | The following should only appear in the TeX manual, and not in the |
@c | info file.  This is just a simple overview and a thanks notice.    | 
@c |                                                                    |
@c +--------------------------------------------------------------------+

@iftex
@c __ @cindex      Thanks
@c __ @cindex      Prelude
@cindex      謝辞
@cindex      序
@c __ @unnumbered  Prelude
@unnumbered  序
@comment     ####### 

@c __ This manual covers all of the important aspects of the Flex lexical
@c __ scanner generator, including writing pattern matching rules, optimizing
@c __ scanners and how Flex fits into the POSIX world.  Examples are presented
@c __ throughout the book, and there is a special section containing useful
@c __ code.
このマニュアルではFlexの字句スキャナ生成機能が持つ重要な点を網羅して説明しています。
これには、
パターン・マッチング・ルールの記述方法、
スキャナの最適化方法、
および、
どのようにFlexがPOSIXに適合しているか、
という点が含まれています。
本書中いたるところに実例を示してありますし、
有用なコードを集めた特別なセクションもあります。

@c __ This manual is primarily a reference manual rather than a tutorial.
@c __ While an effort has been made to keep the material and explanations at a
@c __ fairly simple level, at times it does become quite technical.
@c __ Inexperienced users should be able to read the first few sections with
@c __ no trouble, but the sections with examples in them rely upon the reader
@c __ having at least a working knowledge of the C language, and to have had
@c __ some experience in programming.  In particular, the section on
@c __ connecting Flex and Bison assumes some knowledge of @code{yacc} or
@c __ Bison, and BNF (if you do not know what BNF is, you will probably
@c __ need to learn).
このマニュアルは、
チュートリアルというよりはむしろリファレンス・マニュアルになっています。
題材や説明はなるべくシンプルになるよう努めましたが、
かなり専門的になってしまったころもあります。
Flexの使用経験が浅いユーザでも、
最初の２、３章は問題なく読むことができるはずです。
しかし、
実例を含む章を理解するには、
少なくとも実用的なC言語の知識と、
ある程度のプログラミング経験が必要になります。
特に、
FlexとBisonを組み合わせて使う方法を説明した章は、
前提として@code{yacc}/BisonとBNF
（BNFが何であるかを知らない読者は、
それを勉強する必要がでてくるでしょう）
に関する知識を必要とします。

@c __ Readers without experience are encouraged to become familiar with some
@c __ of the more common problems in lexical analysis, compiler design, and
@c __ programming in general before reading the later sections of this manual.
@c __ Good books for this are:
字句解析、コンパイラ・デザイン、プログラミング全般について経験のない読者には、
このマニュアルの後半部分を読む前に、
各領域における一般的な問題について知識を得ておくようお勧めします。
この目的に役立つ良書をいくつか挙げておきます。

@quotation
@itemize
@c __ @item @cite{Compiler Design in C} --- by Allen I. Hollub
@c __ @item @cite{Compiler Design and Construction} --- by Arthur B. Pyster
@c __ @item @cite{Compilers: Principles, Techniques and Tools} --- @*
@item @cite{Compiler Design in C} --- Allen I. Hollub 著
@item @cite{Compiler Design and Construction} --- Arthur B. Pyster 著
@item @cite{Compilers: Principles, Techniques and Tools} --- @*
@tex 
\hskip 1em
@end tex
@c __ by Alfred V. Aho, Ravi Sethi and Jeffrey D. Ullman.  
Alfred V. Aho、Ravi Sethi、Jeffrey D. Ullman 共著
@end itemize 
@end quotation

@c __ I would like to thank the following people who in various ways made
@c __ writing this manual easier:
ここで、
このマニュアルを書く作業を様々な方法でより容易にしてくれた以下の人々に感謝したいと思います。

@quotation
@itemize
@item 
@b{Robert J. Chassell (bob@@gnu.ai.mit.edu)}

@c __ For providing a lot of pointers in the @emph{right} direction, useful
@c __ comments, and for his work on the Texinfo package, which was used
@c __ to format this manual.
@emph{正しい}方向へ導いてくれる多くの助言と役に立つコメントを提供してくれたこと、
また、
このマニュアルを整形するのに使われたTexinfoパッケージに関する作業を行ってくれたことに対して感謝します。

@item 
@b{Vern Paxson (vern@@ee.lbl.gov)}

@c __ For writing Flex, for going out of his way to proofread the manual
@c __ thoroughly, for his helpful comments both of a technical and general
@c __ nature, and for the excellent @code{flexdoc.1}, which inspired many
@c __ parts of this manual---particularly the sections on performance.
Flexを作成してくれたこと、
自らの作業を中断してこのマニュアルを徹底的に校正してくれたこと、
技術的な面と一般的な面の両方において役に立つコメントを提供してくれたこと、
このマニュアルの多くの部分 − 特に性能に関する部分 − に影響を与えた優れたドキュメント@code{flexdoc.1}を書いてくれたことに対して感謝します。

@item 
@b{Brendan Kehoe (brendan@@cygnus.com)}

@c __ For his extensive notes and comments on the early drafts, and his help
@c __ with the reference card.
初期の草稿に対して広範な注とコメントを提供してくれたこと、
リファレンス・カードの作成を手伝ってくれたことに対して感謝します。
@end itemize
@end quotation

@c __ I would also like to explain why I spent many unpaid hours writing this
@c __ manual.  The main reason is this: While I am not as strongly oriented
@c __ politically as the Free Software Foundation, I @emph{do} feel that free
@c __ software is a very important asset to the world, and that the overall
@c __ aim of the FSF is something we should all strive for.
さらにここで、
全くの無報酬であるにもかかわらず、
なぜ私がこのマニュアルを書くために多くの時間を割いたのか、
その理由について説明しておきたいと思います。
主な理由はこういうことです。
私自身にはFree Software Foundation（FSF）ほど強い政治的指向性はありませんが、
それでもフリー・ソフトウェアはこの世界にとって非常に重要な資産であり、
FSFが一貫して目的としているものは、
私たちすべてがその実現のために努力するべきものであると感じるのです。

@c __ When programming, I use many free tools.  I do not use them because they
@c __ are free (no cost), but because they are better than comparable
@c __ products.  For example, @code{gcc} is arguably one of the best ANSI C
@c __ compilers available, @code{emacs}, @code{TeX}, @code{groff} and
@c __ @code{ghostscript} are all extremely useful text processing tools,
@c __ @code{X11}, @code{f2c} and @code{p2c} are noteworthy in their own
@c __ category, and Flex is far superior to the standard Lex found on most
@c __ machines.
プログラミングをしている時、
私はフリーのツールを多く使います。
私がこうしたツールを使うのは、
それがフリー（無料）であるからではなく、
他の同等の製品と比較して優れているからです。
例えば、
@code{gcc}は入手可能なANSI Cコンパイラの中で最も良いものの１つであると主張できます。
@code{emacs}、@code{TeX}、@code{groff}、@code{ghostscript}はいずれもきわめて役に立つテキスト処理ツールです。
@code{X11}、@code{f2c}、@code{p2c}はそれぞれの分野において注目に値するものです。
そしてFlexはほとんどのマシン上にある標準のLexより格段に優れています。

@c __ This is proof that free software can be both useful and well supported,
@c __ and because I have had access to the source for these programs, I
@c __ have been able to study them and learn from them.
このことは、
フリー・ソフトウェアが役に立ち、
かつ、
十分にサポートされていることを証明しています。
こうしたプログラムのソース・コードにアクセスできたおかげで、
私はそれらを研究し、
そこから学ことができました。

@c __ This manual is my way of repaying the debt of gratitude I owe the FSF
@c __ and to all the authors of free software for their efforts.  If you use a
@c __ GNU tool, or some other free program, why don't you try to help too?
@c __ There are currently three free operating system under development
@c __ (Linux, 386BSD, and the GNU Hurd), which need all the help they can get,
@c __ especially in the non-programming areas.
このマニュアルは、
FSFとすべてのフリー・ソフトウェアの作者の努力に対して恩返しをするための、
私流の方法なのです。
もし読者がGNUのツールやその他のフリーのプログラムを使っているのであれば、
ご自分でも何か貢献することを試みてはいかがでしょうか？
現在、
フリーのオペレーティング・システムが３つ（Linux、386BSD、GNU Hurd）開発中です。
そこでは、
あらゆる援助、
特にプログラミングとは関係ない領域での援助が必要とされています。

@c __ Finally, I would like to say that while I have made an effort to make
@c __ sure the information in this manual is correct, there are bound to be
@c __ some mistakes, or inconsistencies.  These mistakes, and anything else in
@c __ this manual, can only be attributed to me, and do not reflect the
@c __ opinions or abilities of anyone else.  Please note that I am aware that
@c __ many of the examples are not the most efficient in their use of C
@c __ constructs, but I felt clarity outweighed performance in this manual.
最後に、
このマニュアル中の情報に誤りがないようにするための努力は払いましたが、
なんらかの誤りや矛盾がまだ含まれているであろうということを一言断っておきたいと思います。
このマニュアル中の誤りやその他の不都合な点の責任はすべて私にあり、
私以外の何人の見解もしくは能力の限界を表すものではありません。
また、
このマニュアル中の実例の多くはC言語の使い方として最も効率的なものではないことを私は認識していますが、
このマニュアル中では性能よりも明瞭さの方がはるかに重要であると考えました。

@noindent
@c __ Thanks again to all free software authors.  
最後にもう一度、
すべてのフリー・ソフトウェアの作者に対して感謝いたします。

@quotation
@c __ G. T. Nicol, 11 January 1993
G.T. Nicol、1993 年 1 月 11 日
@end quotation

@c +--------------------------------------------------------------------+
@c |                                                                    |
@c |  A few notes on the example programs                               |
@c |                                                                    |
@c +--------------------------------------------------------------------+

@c __ @cindex      About the example programs
@c __ @cindex      Programs, example
@cindex      プログラムの実例について
@cindex      プログラム、実例
@c __ @unnumbered  About the Example Programs
@unnumbered  プログラムの実例について
@comment     ###########################

@c __ The standard electronic distribution of this manual includes not only
@c __ the manual itself, but also a sub-directory containing the example
@c __ programs shown, or mentioned, and other various examples. These examples
@c __ are provided so that you can concentrate on studying, and modifying the
@c __ examples, rather than the error prone process of typing them in.
@c __ Assuming you have GCC and Bison installed on your computer, you should
@c __ have few problems compiling the examples. If you do not have an ANSI C
@c __ compiler, you may have some trouble.
@c @ifset INCLUDEFLEX25INFO
このマニュアルの標準的な電子ディストリビューションには、
このマニュアルだけではなく、
マニュアルの中で示されたり言及されたりしたプログラムの実例とその他の様々な実例が、
あるサブディレクトリ配下に収められています。@footnote{訳注：このマニュアルの日本語訳のディストリビューションには、
マニュアルの中で使われているサンプル・プログラムは含まれていません。
また、
Flex 2.5のディストリビューションに含まれているサンプル・プログラムは、
このマニュアルで使われているものとは異なるものです。}
@c @end ifset
@c @ifclear INCLUDEFLEX25INFO
@c このマニュアルの標準的な電子ディストリビューションには、
@c このマニュアルだけではなく、
@c マニュアルの中で示されたり言及されたりしたプログラムの実例とその他の様々な実例が、
@c あるサブディレクトリ配下に収められています。@footnote{訳注：このマニュアルの日本語訳のディストリビューションには、
@c マニュアルの中で使われているサンプル・プログラムは含まれていません。}
@c @end ifclear
こうした実例は、
読者が、
すべてのコードを入力するという誤りの起りやすい作業に煩わされることなく、
実例の研究や修正に集中できるようにするために提供されています。
コンピュータ上にGCCとBisonがインストールされていれば、
ほとんど問題なくこれらの実例をコンパイルできるはずです。
しかし、
ANSI Cコンパイラがない場合には、
問題に直面するかもしれません。
nogood
@*
@noindent
@c __ To build the examples, change to the @file{examples} sub-directory and
@c __ simply type: 
実例のプログラムをビルドするには、
@file{examples}という名のサブディレクトリに移動して以下を実行するだけです。

@example
make
@end example

@noindent
@c __ which will compile all the examples. Alternatively, you can type 
これですべての実例がコンパイルされます。
あるいは、
以下のように実行することもできます。

@example
make @var{example name}
@end example

@noindent
@c __ or compile them by hand.
また、
実例を手作業でコンパイルすることもできます。

@*
@c __ If you do not have the full distribution, you can get it via the
@c __ Internet, (at @code{prep.ai.mit.edu}) or you may order it from the Free
@c __ Software Foundation.
ディストリビューション全体を持っていない読者は、
インターネット（@code{prep.ai.mit.edu}）から入手することができますし、
Free Software Foundationに直接注文することもできます。

@end iftex


@c +--------------------------------------------------------------------+
@c |                                                                    |
@c | This node introduces the reader to the basic need for Lex/Flex and |
@c | and explains what it is and what it does.                          |
@c |                                                                    |
@c | When I read Forsythe's old lex manual, I was surprised at how      |
@c | similar this is to his introduction.... GTN                        |
@c |                                                                    |
@c +-----------------+-----------------+-----------------+--------------+ 
@c |       Name      |       Next      |     Previous    |       Up     |
@c +-----------------+-----------------+-----------------+--------------+ 
@c @node    Introduction, Invoking Flex, Top, Top
@node Introduction, Invoking Flex, Top, Top
@c __ @chapter Introduction to Flex
@chapter Flex入門
@c __ @cindex  Introduction to Flex
@c __ @cindex  Flex, introduction to
@c __ @cindex  Lexical scanners
@cindex  Flex入門
@cindex  Flex、入門
@cindex  字句スキャナ

@quotation
@c __ @i{This chapter introduces the concept of lexical scanning, and points
@c __ out the need for tools like Flex.  In later parts it introduces Flex and
@c __ gives some examples of situations where Flex could be used.}
@i{この章では字句スキャン処理の概念を紹介し、
Flexのようなツールの必要性を指摘します。
この章の後半部分でFlexを紹介し、
Flexを使うことのできる状況の実例をいくつか紹介します。}
@end quotation

@c __ In the Unix and C world, files are generally dealt with as a stream of
@c __ individual bytes, and any larger grouping is supplied by the programmer.
@c __ This abstraction is very powerful, since any file can be represented by
@c __ it.  However, there is a disadvantage in that a programmer almost always
@c __ has to impose a structure upon the raw file, or in other words, break
@c __ the file into more meaningful components.  For example, one part of a
@c __ compiler takes a stream of characters from a file and groups them into
@c __ units that the syntax checker understands, like numbers, keywords, and
@c __ strings.  This is because the language parser of the compiler does not
@c __ work with a stream of characters; it works with a stream of symbols from
@c __ the language.
UnixおよびCの世界では、
ファイルは通常個々のバイトが連続したものとして扱われます。
個々のバイトを集めてどのようにグループ化するかという点は、
プログラマが決めることです。
このような抽象化は非常に強力です。
というのは、
どのようなファイルであってもこの抽象化方法によって表現することができるからです。
しかしこの方法には短所もあり、
プログラマはほとんど常に生のファイルに対して構造をあてはめなければなりません。
言葉を変えると、
ファイルをより意味のある部分に分割しなければならないということです。
例えば、
コンパイラのある部分はファイルから連続した文字を受け取り、
構文チェッカが理解することのできる構成要素、
例えば、
数値、キーワード、文字列などにグループ化します。
このようなことを行う理由は、
コンパイラの言語パーサが処理を行うのは、
連続した文字に対してではなく、
その言語のシンボルが連続したものに対してだからです。

@c __ Database applications, and applications that deal with binary files,
@c __ often have a fixed format for their data and the format is used for
@c __ extracting meaning from the input.  The opposite is usually true for
@c __ programs that read in text.  These programs must often break the input
@c __ into words or symbols, and there is usually no set structure to the way
@c __ these words or symbols are laid out.  So, in order to break the input
@c __ into meaningful symbols, programs that deal with text often include a
@c __ stage called the @dfn{lexical analysis} stage or @dfn{lexical scanning}
@c __ stage which takes care of breaking up the input.  The functions for
@c __ doing this are referred to as lexical analyzers or lexical scanners, or
@c __ ``scanners'' for short.
データベース・アプリケーションや、
バイナリ・ファイルを扱うアプリケーションは、
扱うデータに対してある固定されたフォーマットというものを持っていることが多く、
そのフォーマットを使って入力データから意味を導き出します。
テキストを入力するプログラムは通常これとは反対で、
入力を単語やシンボルに分割しなければならないことが多いのですが、
通常これらの単語やシンボルがどのように配置されているかを示す決まった構造というものは存在しません。
したがって、
テキスト処理を行うプログラムは、
入力された情報を意味のあるシンボルに分割するために、
@dfn{字句解析}もしくは@dfn{字句スキャン}と呼ばれる処理を行う部分を持っていることが多く、
そこで入力情報の分割が行われます。
このようなことを行う関数群のことを字句アナライザもしくは字句スキャナ、
あるいは短く「スキャナ」と呼びます。

@c __ Generally, writing scanners is neither difficult nor interesting for a
@c __ programmer, but it can be time consuming.  Also, most popular
@c __ programming languages offer very poor support for writing scanners as
@c __ they have no built-in way of breaking a character stream into words,
@c __ tokens or symbols.  Usually, there are library routines for doing the
@c __ job, but they are often inflexible, difficult to use, or require so much
@c __ code to interface to them that the basic problem is obscured by the
@c __ implementation details.
一般的に、
スキャナを作成するのは、
プログラマにとって難しいことでも面白いことでもないのですが、
時間のかかる作業になることはあります。
普及しているプログラミング言語のほとんどは、
スキャナの作成を支援する機能が不十分です。
というのは、
連続した文字を単語、トークン、シンボルに分割する組み込みの機能を持っていないからです。
通常はこのような仕事を行うライブラリ・ルーチンが存在しますが、
柔軟でなかったり、
使いにくいものであったり、
あるいは、
ルーチンとのやりとりにあまりに多くのコードが必要になったりすることが多いために、
実装上の細かな点によって根本的な問題が不明瞭にされてしまいます。

@c __ A good example is writing a scanner in C to handle all the possible
@c __ numeric types allowed in the C language (floating point, integers,
@c __ hexadecimal, octal).  It is not very difficult, but the resulting code
@c __ is usually far from beautiful, and maintenance or expansion is often not
@c __ easy.
１つの良い例が、
C言語で許されているすべての数値型
（浮動小数、10進整数、16進整数、8進整数）
を処理するスキャナをC言語で記述する場合です。
これは非常に難しいということはありませんが、
出来上がったコードは通常美しいとはとても言えないものでしょうし、
その保守や拡張は容易でないことが多いのです。

@c __ As most programmers will be very quick to assure you, maintaining
@c __ someone else's code is usually not very enjoyable, and maintaining
@c __ poorly written code is far from pleasant.  So, with scanners being
@c __ boring to write and difficult to maintain, you can see that there was a
@c __ good reason to think of a way to make scanner-writing easier.
ほとんどのプログラマが即座に断言するように、
他人の書いたコードを保守するのは通常あまり楽しい作業ではありません。
さらに、
美しくないコードを保守するのは、
楽しいというにはほど遠いものです。
このように、
スキャナを書くことが退屈で、
その保守が難しいとなると、
スキャナの作成をより容易にしてくれる方法を考えようとするに足る理由のあったことが読者にもお分かりいただけるでしょう。

@ifinfo
@c __ Flex is the answer to the problem.  
Flexは、
このような問題への答なのです。
@end ifinfo 

@ifnottex
========================================================================
@c __ @menu
@c __ * Problem Solving::             Flex as a problem solver
@c __ * General Programming::         Flex as a general programming tool
@c __ @end menu
@menu
* Problem Solving::           問題解決手段としてのFlex
* General Programming::       一般的なプログラミング・ツールとしてのFlex
@end menu
========================================================================
@end ifnottex

@c +--------------------------------------------------------------------+
@c |                                                                    |
@c | This node introduces the reader to Flex, and describes its overall |
@c | functionality.                                                     |
@c |                                                                    |
@c +----------------+----------------+----------------+-----------------+ 
@c |       Name     |      Next      |     Previous   |       Up        |
@c +----------------+----------------+----------------+-----------------+ 
@c @node Problem Solving, General Programming, Introduction, Introduction
@node Problem Solving, General Programming, Introduction, Introduction
@c __ @section    Flex as a Problem Solver
@section    問題解決手段としてのFlex
@comment    ########################

@iftex
@c __ This is where Flex comes in.  
ここでFlexが登場することになります。
@end iftex 
@c __ Flex provides a programmer with a method of cleanly describing the
@c __ lexical analysis stage and generating efficient lexical scanners from
@c __ the description.  The programmer supplies Flex with a description of the
@c __ scanner needed and Flex uses the description to produce a scanner in C.
@c __ The description language is a high-level language, and is much more
@c __ suitable for describing scanners than C.  It allows the programmer to
@c __ specify how to group characters, and also what actions to take after a
@c __ grouping is completed.
Flexはプログラマに対して、
字句解析処理部分をきれいに記述し、
その記述にしたがった効率的な字句スキャナを生成する方法を提供します。
プログラマはFlexに対して、
必要なスキャナに関する記述情報を提供します。
Flexはその記述情報を使って、
C言語で書かれたスキャナを生成します。
記述に使われる言語は上級言語であり、
スキャナの記述に関してはC言語よりもはるかに適しています。
その上級言語を使うことで、
プログラマは、
文字をどのようにグループ化し、
グループ化が完了した時にどのようなアクションを発生させるかを指定することができます。

@c __ @strong{Please note:} @i{For most of this manual, the discussion covers
@c __ both Flex and Lex, which is the standard scanner-generating utility
@c __ found on most Unix systems (though it is inferior).  Where there are
@c __ differences, Flex is given preference.  Lex is covered briefly in
@c __ @ref{Lex, , Standard Lex}.  }
@strong{注：}@i{このマニュアルのほとんどの部分はFlex、Lexの両方を対象にしています。
Lexは
（Flexには劣りますが）
ほとんどのUnixシステム上にある標準のスキャナ生成ユーティリティです。
両者の間に違いがある場合には、
Flexを優先させています。
Lexについては@ref{Lex, , 標準Lex}で簡単に説明してあります。}

@c __ Again, a good example is a compiler.  As discussed before, the syntax
@c __ checker of a compiler needs to receive as input a stream of tokens that
@c __ represent parts of its grammar, not characters.  Flex is perfect for
@c __ this.  A scanner generated by Flex can sit between the syntax checker
@c __ and the file, waiting for the syntax checker to ask for the next
@c __ meaningful token.  Flex reads the file, groups characters according to
@c __ the description given by the programmer, and then returns a token
@c __ representing that match.  This continues until the scanner or the parser
@c __ finishes.
ここでも１つの良い例がコンパイラです。
前に議論したように、
コンパイラの構文チェッカは、
文字が連続したものではなく、
言語文法の構成要素を表すトークンが連続したものを、
入力として受け取る必要があります。
Flexはこのような場合に最適です。
Flexによって生成されたスキャナが構文チェッカとファイルの仲介役となり、
構文チェッカが次の意味のあるトークンを要求するのを待ちます。
Flexはファイルを読み、
プログラマが与える記述にしたがって文字をグループ化して、
マッチしたトークンを返却します。
この処理は、
スキャナもしくはパーサが終了するまで続きます。

@c __ For a C compiler, the Flex description to do this may take between 100
@c __ and 300 lines of code, most of which would be auxiliary C code for
@c __ symbol table management, identifier searching, type mapping and
@c __ returning additional information, such as the value of a number.  These
@c __ are not part of the description @i{per se}, but are usually required by
@c __ the compiler.
Cのコンパイラを作成する場合、
このようなことを行うために必要となるFlexの記述情報は、
コードの行数にして100行から300行くらいになるかもしれません。
この記述情報のほとんどは、
シンボル・テーブルの管理、識別子の検索、型のマッピング、ある数の値等の追加情報の返却を行うための補助的なCコードになるでしょう。
こうしたコード@i{自体}は記述情報の一部ではありませんが、
通常、
コンパイラによって必要とされるものです。

@c __ Conceptually, Flex is like a factory that takes in raw materials
@c __ (characters) and produces the finished product (tokens), ready for the
@c __ consumers (parsers, etc.).
概念的にはFlexは、
原材料（文字）を取り込み、
消費者（パーサ等）がすぐに使うことができる完成品（トークン）を製造する工場のようなものです。

@c +--------------------------------------------------------------------+
@c |                                                                    |
@c | This node introduces the reader into the many ways that Flex can   |
@c | be used.                                                           |
@c |                                                                    |
@c +----------------+----------------+----------------+-----------------+ 
@c |       Name     |      Next      |     Previous   |       Up        |
@c +----------------+----------------+----------------+-----------------+ 
@c @node General Programming,  , Problem Solving, Introduction
@node General Programming,  , Problem Solving, Introduction
@c __ @section        Flex as a General Programming Tool
@section        一般的なプログラミング・ツールとしてのFlex
@comment        ##################################

@c __ Flex is not limited to use only in compilers.  Think of all the programs
@c __ on your computer that need to read files and deal with groups of
@c __ characters in some way, and in particular, transformation filters and
@c __ language tools.  Almost all of these programs can be written using Flex,
@c __ or Flex combined with other tools.
Flexはコンパイラにしか使えないということはありません。
読者のコンピュータ上にある、
ファイルを読み込んだり、
なんらかの形で文字のグループを処理する必要のあるすべてのプログラム、
特に、
変換フィルタや言語ツールのことを考えてみてください。
こうしたプログラムのほとんどすべてを、
Flex単体、
もしくはFlexと他のツールの組み合わせによって作成することができます。

@c __ A good example is character counting.  Say you wanted to make a program
@c __ that would count all the lines in your file, count the occurrence of
@c __ every character, and count the number of times the word @samp{foo}
@c __ appears in it.  You could do it using the standard tools (@code{grep},
@c __ @code{sed}, @code{awk}, @code{perl}, et. al.), you could do it yourself
@c __ in C, or you could do it in Flex.  Another example is a mail reading
@c __ program, where you need to scan for certain keywords.  Again, you can do
@c __ it with the standard tools, or you can do it in Flex and C.
１つの良い例が文字数のカウントです。
例えば、
ファイルの中の全行数、
個々の文字の出現回数、
@samp{foo}という単語の出現回数を調べるプログラムを作成したいとしましょう。
標準的なツール
（@code{grep}、@code{sed}、@code{awk}、@code{perl}等）
で作成することも、
C言語のプログラムを書いて作成することもできますが、
Flexで作成することも可能です。
他の例として、
特定のキーワードを探す必要のある、
メール・リーダがあります。
この場合でも、
標準ツールで実現することも、
FlexとC言語で実現することもできます。

@c __ Flex can save programmers significant amounts of time in developing
@c __ scanners and processing the characters that make up a file.  In most
@c __ cases the Flex input will be easier to understand, at least as portable,
@c __ and easier to maintain than code in a traditional programming language.
@c __ Not only that, but because scanners in Flex can usually be developed in
@c __ a much shorter time than the corresponding scanner in a traditional
@c __ programming language, it is ideal for prototyping and for one-shot
@c __ programs or filters.
Flexを使うことで、
プログラマは、
スキャナの開発やファイルを構成する文字の処理にかかる時間を大幅に減らすことができます。
ほとんどの場合、
Flexに対する入力情報は、
既存のプログラミング言語で記述されたコードと比較して、
より理解しやすく、
少なくとも同程度の移植性があり、
保守もより簡単です。
それだけでなく、
Flexでスキャナを開発するのにかかる時間は、
既存のプログラミング言語で同等のスキャナを開発する場合と比べきわめて短くてすむので、
Flexは、
プロトタイピングや、
一度しか使わないプログラムやフィルタの開発に最適です。

@c +--------------------------------------------------------------------+
@c |                                                                    |
@c | This node really just serves as a kind of introduction/menu for    |
@c | the rest of the chapter/section.                                   |
@c |                                                                    |
@c +-----------------+-----------------+-----------------+--------------+ 
@c |       Name      |       Next      |     Previous    |       Up     |
@c +-----------------+-----------------+-----------------+--------------+ 
@c @node    Invoking Flex, Flex Descriptions, Introduction, Top
@node Invoking Flex, Flex Descriptions, Introduction, Top
@c __ @chapter Invoking Flex
@chapter Flexの起動
@c __ @cindex  Invoking Flex
@c __ @cindex  Using Flex
@c __ @cindex  Flex, usage
@c __ @cindex  Flex, invoking
@cindex  Flexの起動
@cindex  Flexの使用
@cindex  Flex、使用法
@cindex  Flex、起動

@quotation
@c __ @i{This chapter will explain the basic way to invoke Flex, and give a
@c __ brief explanation of the command line options available with Flex.}
@i{この章ではFlexを起動する基本的な方法を説明し、
Flexで使用可能なコマンドライン・オプションを簡単に説明します。}
@end quotation

@c __ Flex takes a file containing a description as input and converts it into
@c __ a C file that contains a scanner.  The command line for invoking Flex
@c __ is:
Flexは記述情報を含むファイルを入力として受け取り、
スキャナ機能を持つCのファイルに変換します。
Flexを起動するためのコマンド行は以下のようになります。

@example
flex [-bcdfinpstvFILT8] [-C[efmF]] [-S@var{skeleton}] [@var{file} @dots{}]
@end example

@noindent
@c __ It is generally called by simply typing @samp{flex} followed by the name
@c __ of the file to process, as in:
一般的には、
単に@samp{flex}に続けて処理すべきファイル名を入力することで実行されます。

@example 
flex myfile.l
@end example

@noindent
@c __ @findex @code{.l}@r{, lex files}
@findex @code{.l}@r{、lexファイル}
@c __ The @samp{.l} ending on a description file is a customary way of
@c __ saying that @file{myfile} is a Flex or Lex description file.  Another
@c __ common naming convention is to use the @samp{.lex} ending, as in:
記述情報ファイル名の末尾の@samp{.l}は、
@file{myfile}がFlexもしくはLexの記述ファイルであることを示唆する慣例的な方法です。
名前付けの慣例としてもう一つよく見られるのが、
末尾に@samp{.lex}を使うことです。
例えば、
以下のようになります。

@example 
flex myfile.lex
@end example

@noindent
@findex @code{lex.yy.c}
@c __ Flex reads in the description file (@code{myfile.l}) and produces a C
@c __ language file called @file{lex.yy.c} containing a scanner that will
@c __ recognize the patterns described.  If there are any errors in the
@c __ description, Flex will write a corresponding error message to
@c __ @code{stderr}.
Flexは記述情報ファイル（@code{myfile.l}）を読み込み、
そこに記述されたパターンを認識するスキャナ機能を持つ@file{lex.yy.c}という名前のC言語ファイルを生成します。
記述情報の中になんらかのエラーがあれば、
Flexは対応するエラー・メッセージを@code{stderr}に出力します。

@ifnottex
========================================================================
@c __ @menu
@c __ * Command Line Switches::       The command line options for Flex.
@c __ @end menu
@menu
* Command Line Switches::       Flexのコマンドライン・オプション
@c @ifset INCLUDEFLEX25INFO
* Command Line Switches (Flex 2.5)::  同上（Flex 2.5の補足情報）
@c @end ifset
@end menu
========================================================================
@end ifnottex

@c +--------------------------------------------------------------------+
@c |                                                                    |
@c | Summary of switches                                                |
@c |                                                                    |
@c +-----------------+-----------------+-----------------+--------------+ 
@c |       Name      |       Next      |     Previous    |       Up     |
@c +-----------------+-----------------+-----------------+--------------+ 
@c @node    Command Line Switches,  , Invoking Flex, Invoking Flex
@node Command Line Switches, Command Line Switches (Flex 2.5), Invoking Flex, Invoking Flex
@c __ @section Command Line Switches
@section コマンドライン・オプション
@comment #####################
@c __ @cindex  Command line options
@cindex  コマンドライン・オプション

@noindent
@c __ The command line options for Flex have following meanings:
Flexのコマンドライン・オプションは以下のような意味を持ちます。

@table @kbd
@item -b
@c __ The @samp{-b} option generates a file called @file{lex.backtrack}, which
@c __ is used when optimizing a scanner description.  
@c __ @xref{Optimizing for Speed}, for more details.
@samp{-b}オプションを指定すると@file{lex.backtrack}というファイルが生成されます。
このファイルはスキャナの記述情報を最適化する際に使用されます。
詳細については、@xref{Optimizing for Speed}。

@item -c
@c __ This option is only included for POSIX compliance, and does nothing.
@c __ In POSIX, @samp{-c} indicates that C language actions are used. 
このオプションはPOSIXとの互換性のために提供されているだけで、
実際には何もしません。
POSIXでは、
@samp{-c}オプションはC言語によるアクションが使用されることを意味します。

@item -d
@c __ Specifying this option enables debugging.  This generates a scanner
@c __ which writes scanner state information to @code{stderr} while it is
@c __ running.
このオプションを指定するとデバッグが可能になります。
これにより生成されるスキャナは、
実行中にスキャナの状態情報を@code{stderr}に出力します。

@item -f
@c __ This tells Flex to generate a @emph{fast} or @emph{full} scanner.
@c __ @xref{Table Compression and Scanner Speed}, for more information.  
@c __ Note that @samp{-f} (lower case) has different effects than @samp{-F}
@c __ (upper case).
Flexに対して@emph{ファスト}・スキャナ（@emph{fast} scanner）と@emph{フル}・スキャナ（@emph{full} scanner）のどちらを生成するかを指示します。
詳細については、
@xref{Table Compression and Scanner Speed}。
@samp{-f}（小文字）オプションと@samp{-F}（大文字）オプションとは異なる効果を持つ点に注意してください。

@item -i
@c __ This instructs Flex to generate a case-insensitive scanner.
@c __ @xref{Case Insensitive Scanners}, for more details.
Flexに対して大文字、小文字を区別しないスキャナを生成するよう指示します。
詳細については、
@xref{Case Insensitive Scanners}。

@item -n
@c __ This option has no meaning for Flex and is only included for POSIX
@c __ compliance. In POSIX, this flag is used to supress the output of the
@c __ @samp{-v} option. The default for POSIX is to suppress such output
@c __ unless table sizes were specified, and as table sizes have no meaning
@c __ for Flex, this flag is redundant.
このオプションはFlexにとっては何の意味も持たず、
POSIXとの互換性のためにのみ提供されています。
POSIXでは、
このフラグは@samp{-v}オプションによる出力を抑制するために使用されます。
POSIXでのデフォルトは、
テーブル・サイズが指定されない限りこのような出力を抑制するというものです。
Flexではテーブル・サイズは意味を持たないので、
このフラグは冗長です。

@item -p
@c __ The @samp{-p} option causes Flex to write a performance report to
@c __ @code{stderr}.  @xref{Optimizing for Speed}, for a discussion on
@c __ improving scanner performance.
@samp{-p}オプションが指定されると、
Flexは性能レポートを@code{stderr}に出力します。
スキャナの性能を向上させる方法に関する議論については、
@xref{Optimizing for Speed}。

@item -s
@c __ The default action of a Flex scanner when it fails to match 
@c __ anything is to write the unmatched input to @code{stdout}.  This option 
@c __ suppresses this action and instead aborts the scanner on unmatched
@c __ input. 
Flexスキャナがマッチするものを見つけることができなかった場合のデフォルトのアクションは、
そのマッチされなかった入力情報を@code{stdout}に出力することです。
@samp{-s}オプションはこのようなアクションを抑制し、
その代わりに入力情報がマッチしなかった時点でスキャナを異常終了させます。

@item -t
@c __ Flex will write the generated scanner to @code{stdout} instead of
@c __ @file{lex.yy.c} if this option is specified .
このオプションが指定された場合、
Flexは生成されたスキャナをファイル@file{lex.yy.c}にではなく@code{stdout}に出力します。

@item -v
@c __ This tells Flex to operate in @emph{verbose} mode.
Flexに対して@emph{冗長}モードで動作するよう指示します。

@item -F
@c __ This tells Flex to generate a @emph{fast} scanner.  
@c __ @xref{Optimization, , Optimizing the Scanner}, for more details.  Note
@c __ that @samp{-F} (upper case) has different effects than @samp{-f} (lower
@c __ case).  @xref{Table Compression and Scanner Speed}, for more information
@c __ about the difference between @samp{-f} and @samp{-F}.
Flexに対して@emph{ファスト}・スキャナ（@emph{fast} scanner）を生成するよう指示します。
詳細については、
@xref{Optimization, , スキャナの最適化}。
@samp{-F}（大文字）は@samp{-f}（小文字）とは異なる効果を持つ点に注意してください。
@samp{-f}と@samp{-F}の相違点に関する情報については、
@xref{Table Compression and Scanner Speed}。

@item -I
@c __ This option tells Flex to generate an @emph{interactive} scanner.
@c __ @xref{Interactive Scanners}, for more details.
このオプションはFlexに対して@emph{対話型}スキャナを生成するよう指示します。
詳細については、
@xref{Interactive Scanners}。

@item -L
@c __ By default, Flex generates @code{#line} directives in the generated
@c __ scanner to aid debugging.  This option turns @code{#line} directive
@c __ generation off.
デフォルトでは、
デバッグを支援するために、
Flexは生成されたスキャナのコード中に@code{#line}指示子を書き込みます。
このオプションによって@code{#line}指示子の書き込みは行われなくなります。

@item -T
@c __ This makes Flex run in @dfn{trace} mode.  Flex will print many messages
@c __ to @code{stderr}.  These messages will be meaningless unless you
@c __ understand Flex very well.
Flexに対して@dfn{トレース}・モードで動作するよう指示します。
Flexは多くのメッセージを@code{stderr}に出力するようになります。
こうしたメッセージは、
Flexを非常によく理解しているユーザ以外には無意味でしょう。

@item -8
@c __ This option tells Flex to generate a scanner that can accept 8 bit
@c __ input.
このオプションは、
Flexに対して8ビット入力を受け付けるスキャナを生成するよう指示します。

@item -C[efmF]
@c __ These options control the way the scanning tables are compressed.
@c __ @xref{Optimization, , Optimizing the Scanner}, for more details.
これらのオプションは、
スキャン処理用のテーブルをどのように圧縮するかを制御します。
詳細については、
@xref{Optimization, , スキャナの最適化}。

@item -S@var{skeleton_file}
@c __ This tells Flex to use @var{skeleton_file} as the base for the scanner
@c __ it generates.  This is mostly used for debugging Flex itself.
Flexに対して、
生成するスキャナのベースとして@var{skeleton_file}により指定されるスケルトン・ファイルを使用するよう指示します。
主に、
Flex自体をデバッグするために使用されます。
@end table

@c Include Flex 2.5 information, for Flex manual as published by ASCII
@c @ifset INCLUDEFLEX25INFO
@node Command Line Switches (Flex 2.5),  , Command Line Switches, Invoking Flex
@section コマンドライン・オプション（Flex 2.5の補足情報）
@include switch_addendum-ja.texi
@c @end ifset

@c +--------------------------------------------------------------------+
@c |                                                                    |
@c | This node takes care of explaining the Flex definition language    |
@c |                                                                    |
@c +-----------------+-----------------+-----------------+--------------+ 
@c |       Name      |       Next      |     Previous    |       Up     |
@c +-----------------+-----------------+-----------------+--------------+ 
@c @node    Flex Descriptions, Interfacing to Flex, Invoking Flex, Top
@node Flex Descriptions, Interfacing to Flex, Invoking Flex, Top
@c __ @chapter The Flex Description Language
@chapter Flex記述言語
@comment ############################
@c __ @cindex  Flex descriptions
@c __ @cindex  Descriptions, Flex
@c __ @cindex  Descriptions, Scanner
@cindex  Flex記述
@cindex  記述、Flex
@cindex  記述、スキャナ

@quotation
@c __ @i{This chapter explains the parts that make up a scanner definition,
@c __ and gives examples of their usage. In order to use Flex effectively, it
@c __ is essential to fully understand each part of a definition, so new users
@c __ are recommended to take their time reading this chapter.}
@i{この章では、
スキャナ定義の構成要素を説明し、
その使用例を示します。
Flexを効率的に使用するためには、
定義の個々の要素を完全に理解することが非常に重要です。
したがって、
初めてFlexを使うユーザには、
時間をかけてこの章を読むことをお勧めします。}
@end quotation

@c __ Most parts of a Flex scanner definition are optional, but the overall
@c __ definition format is:
Flexスキャナ定義のほとんどの要素は、
必須要素ではありません。
全体的な定義フォーマットは以下のようになります。

@example
@group
@c __ @var{Definitions and Initial C code}
@var{定義、初期Cコード}
%%
@c __ @var{Rules} 
@var{ルール} 
%%
@c __ @var{Other C code}
@var{他のCコード}
@end group
@end example

@noindent
@c __ and each of these is explained in detail below.  
各々について、
以下において詳細に説明します。

@ifnottex
========================================================================
@c __ @menu
@c __ * Comments::                    Explains the style of Flex comments.  
@c __ * Optional C Code::             Explains the optional C code section at the
@c __                                 top of a Flex definition.  
@c __ * Definitions::                 Tells you how to write definitions in Flex.  
@c __ * %%::                          Tells you what these delimiters mean.  
@c __ * Rules::                       Explains about the rule section if Flex 
@c __                                 files.  
@c __ * Pattern Matching::            Explains the parts used in pattern matching.  
@c __ * Regular Expressions::         Matching patterns.
@c __ * Start States::                How to activate a pattern matching rule
@c __                                 based upon some condition.  
@c __ @end menu
@menu
* Comments::                    Flexのコメント・スタイルの説明
* Optional C Code::             Flex定義の先頭のCコード・セクションの説明
* Definitions::                 Flexにおける定義の書き方
* %%::                          区切り文字%%の意味
* Rules::                       Flexファイルのルール・セクション
* Pattern Matching::            パターン・マッチングに使われる部分
* Regular Expressions::         パターンのマッチング
* Start States::                ある条件にもとづいてパターン・マッチング・
                                ルールを活性化させる方法
@c @ifset INCLUDEFLEX25INFO
* %option (Flex 2.5)::          %option指示子の説明
@c @end ifset
@end menu
========================================================================
@end ifnottex

@c +--------------------------------------------------------------------+
@c |                                                                    |
@c | This node explains what comments are and the form they take        |
@c |                                                                    |
@c +-----------------+-----------------+-----------------+--------------+ 
@c |       Name      |       Next      |     Previous    |       Up     |
@c +-----------------+-----------------+-----------------+--------------+ 
@c @node    Comments, Optional C Code, Flex Descriptions, Flex Descriptions
@node Comments, Optional C Code, Flex Descriptions, Flex Descriptions
@c __ @section  Comments
@section  コメント
@comment     ########
@c __ @cindex      Comments in definition files
@c __ @cindex      Definitions, comments
@cindex      定義ファイル中のコメント
@cindex      定義、コメント

@c __ Comments may appear anywhere C code is allowed, and follow the C
@c __ convention for comments.  They do not affect the description.  The
@c __ C-style comments are:
Cのコードが記述できるところには、
どこにでもコメントを記述することができます。
コメントの書式は、
Cのコメントの規則に従います。
コメントは、
記述情報に影響を与えることはありません。
Cスタイルのコメントは以下のようになります。

@example
@group
/*
@dots{}
*/
@end group
@end example

@noindent
@c __ In addition, Flex allows comments to begin with a @samp{#}. Such
@c __ comments are not copied to @file{lex.yy.c}, and their use is @emph{not}
@c __ recommended.
これに加えて、
Flexでは@samp{#}で始まるコメントも許されます。
このようなコメントは@file{lex.yy.c}にはコピーされませんので、
この形式のコメントを使うことは@emph{お勧めできません}。

@c __ @strong{Please note:} @i{Some versions of Lex generate code for
@c __ languages other than C (such as Pascal).  In these cases the comment
@c __ characters will be probably be different; Flex only generates C code.  }
@strong{注：}@i{C以外の言語
（例えばPascal）
のコードを生成するLexも存在します。
このようなLexではコメントの書式はおそらく異なるでしょう。
Flexの場合はCのコードしか生成しません。}

@c +--------------------------------------------------------------------+
@c |                                                                    |
@c | This node explains the optional C code area at the top of a file   |
@c |                                                                    |
@c +-----------------+-----------------+-----------------+--------------+ 
@c |       Name      |       Next      |     Previous    |       Up     |
@c +-----------------+-----------------+-----------------+--------------+ 
@c @node    Optional C Code, Definitions, Comments, Flex Descriptions
@node Optional C Code, Definitions, Comments, Flex Descriptions
@c __ @section          Optional C Code
@section          オプションのCコード
@comment          ###############
@c __ @cindex           Adding C code to the definitions
@c __ @cindex           C code, adding
@c __ @cindex           Interfacing to C
@cindex           定義へのCコードの追加
@cindex           Cコード、追加
@cindex           Cとのインターフェイス

@c __ A programmer may include C code in the scanner directly in two different
@c __ ways.  The first is to include code in the @dfn{``Definitions and
@c __ Initial C code''} section (the area preceding the first @samp{%%} pair),
@c __ and the second is to include code in the @dfn{``Other C code''} section
@c __ (The area following the second @samp{%%} pair).  In both cases, the code
@c __ must be legal because it will be copied verbatim into @file{lex.yy.c}.
プログラマは、
２つの異なる方法を用いて、
スキャナの中に直接Cのコードを含めることができます。
第１の方法は、
@dfn{「定義、初期Cコード」}セクション
（最初の@samp{%%}より前の部分）
にコードを含めることです。
第２の方法は、
@dfn{「他のCコード」}セクション
（２番目の@samp{%%}より後ろの部分）
にコードを含めることです。
どちらの場合も、
コードはそのまま@file{lex.yy.c}にコピーされますので、
正当なコードでなければなりません。

@c __ The C code in the first section takes the form:
第１のセクション中のCコードは以下の形式になります。

@example
@group

%@{ 
   @var{C code}
   @dots{}
%@}
@end group
@end example

@noindent
@c __ where the @samp{%@{@dots{}%@}} pair are used to show the start and end
@c __ of the block of C code.  Code of this form, and definitions may be
@c __ freely interspersed in the @dfn{``Definitions and Initial C code''}
@c __ section. Definitions are explained in the next section.
ここで@samp{%@{@dots{}%@}}というペアが、
Cコード・ブロックの先頭と末尾を示すために使われています。
この形式のコードと定義は、@dfn{「定義、初期Cコード」}セクションのどこにでも自由に記述することができます。
定義については次の節で説明します。

@c __ The @samp{%@{@dots{}%@}} pair are not needed if the C code does not
@c __ begin on the first column, but it is usually better to include them for
@c __ clarity.  Another point is that certain things like @code{#ifdef}'s must
@c __ start in the leftmost column, and are usually needed at the top of a
@c __ scanner, so unless they are surrounded by the @samp{%@{@dots{}%@}} pair,
@c __ Flex will think they are part of a definition.  This is another reason
@c __ for always using them.
Cのコードが最初のカラムから始まるのでなければ、
@samp{%@{@dots{}%@}}というペアは必要ありません。
しかし普通は、
分かりやすくするために記述しておいた方が良いでしょう。
もう１つのポイントは、
@code{#ifdef}等のように最左端のカラムから始まらなければならず、
かつ、
通常はスキャナ記述情報の先頭に置かれる必要のあるものが存在するという点です。
こうした場合、
@samp{%@{@dots{}%@}}に囲まれていないと、
Flexはそれを定義の一部であると見なすでしょう。
これが、
常に@samp{%@{@dots{}%@}}を使うもう１つの理由です。

@c __ The code in the final section (@dfn{``Other C code''}) is copied
@c __ verbatim, and requires no special declarations.
最後の
（@dfn{「他のCコード」}）
セクション内のコードは、
そのままコピーされます。
ここには特別な宣言は必要ありません。

@c +--------------------------------------------------------------------+
@c |                                                                    |
@c | This explains the definitions in Flex                              |
@c |                                                                    |
@c +-----------------+-----------------+-----------------+--------------+ 
@c |       Name      |       Next      |     Previous    |       Up     |
@c +-----------------+-----------------+-----------------+--------------+ 
@c @node    Definitions, %%, Optional C Code, Flex Descriptions
@node Definitions, %%, Optional C Code, Flex Descriptions
@c __ @section    Definitions
@section    定義
@comment    ###########
@c __ @cindex     Definitions
@cindex     定義

@c __ The definitions section allows the programmer to define a group of
@c __ characters as having a unique identifier that may be substituted for the
@c __ group.  Definitions have the form:
定義セクションにおいて、
プログラマは、
ある文字のグループに一意な識別子を与え、
その識別子がその文字グループに置き換えられるようにすることができます。
定義は以下のような形式になります。

@example 
@var{definition_name}    @var{definition}
@end example

@noindent
@c __ Note that @var{definition_name} must begin in the @emph{first} column of
@c __ the description or the definition will be copied verbatim into
@c __ @file{lex.yy.c}. Here are a few common definitions:
@var{definition_name}は@emph{最初}のカラムから始まらなければならず、
そうしないとその定義は@file{lex.yy.c}にそのままコピーされてしまうということに注意してください。
以下に一般的な定義をいくつか挙げます。

@example
@group
DIGIT     [0-9]
LETTER    [a-z]
IDENT     [a-z_][a-z0-9_]*
ALPHANUM  @{LETTER@}|@{DIGIT@}
@end group
@end example

@noindent
@c __ @cindex Definitions using rules
@cindex ルールを使用した定義
@c __ The @var{definition name} must be a unique identifier for that group,
@c __ and the @var{definition} can be anything that is legal in the rules
@c __ section (below).  Definitions must be surrounded by @samp{@{ @}} when
@c __ they are used in the rules section, or in a definition (as shown in the
@c __ definition for @code{ALPHANUM} in the above example).
@var{definition name}は、
そのグループの一意な識別子でなければなりません。
また、
@var{definition}はルール・セクション（後述）において正当なものであれば何でも構いません。
ルール・セクションや
（上の例の@code{ALPHANUM}の定義において示されるように）
別の定義中において使われる場合には、
定義は@samp{@{ @}}によって囲まれていなければなりません。

@c __ One very important difference between Flex and Lex is that Flex
@c __ literally surrounds definitions with parentheses when they are expanded,
@c __ whereas Lex does not.  This means that @samp{^}, @samp{<<EOF>>},
@c __ @samp{$} and @samp{/} cannot appear in definitions because they cannot
@c __ appear inside parentheses.  This is explained in more detail in
@c __ @ref{Characters}, 
@c __ and @ref{Flex and Lex}.
@c @ifset INCLUDEFLEX25INFO
FlexとLexの非常に重要な相違点に、
定義を展開する時、
Flexは字義どおりに丸括弧( )で囲むのに対して、
Lexは囲まないという点があります。@footnote{訳注：Flex 2.5では、
@samp{-l}オプションを指定して生成されたスキャナは、
Lexの場合と同じように、
定義を展開する時に丸括弧( )で囲みません。}
@c @end ifset
@c @ifclear INCLUDEFLEX25INFO
@c FlexとLexの非常に重要な相違点に、
@c 定義を展開する時、
@c Flexは字義どおりに丸括弧( )で囲むのに対して、
@c Lexは囲まないという点があります。
@c @end ifclear
これは、
@samp{^}、@samp{<<EOF>>}、@samp{$}、@samp{/}を定義中に入れることができないことを意味しています。
というのは、
前述の文字は丸括弧( )で囲まれた部分に入れることができないからです。
詳細は、
@ref{Characters}および@ref{Flex and Lex}において説明します。

@need 1000
@c __ For example:
例えば、

@example
@group
FUNCTION ^[a-zA-Z_][a-zA-Z0-9_]*"("
%%
@{FUNCTION@}  printf("got a function\n");
@end group
@end example

@noindent
@c __ looks as though it will match C function declarations if one uses a
@c __ programming style like the following:
は、
以下のようなプログラミング・スタイルを使っている場合の、
Cの関数宣言にマッチするように見えます。

@example
int
foo()
@{
   @dots{}
@}
@end example

@noindent
@c __ but in fact it does not work because @code{@{FUNCTION@}} is expanded
@c __ into:
しかし実際にはうまくいきません。
というのは、
@code{@{FUNCTION@}}が展開されると、

@example
(^[a-zA-Z_][a-zA-Z0-9_]*)
@end example

@noindent
@c __ which is illegal.  For more information on these kinds of problems,
@c __ refer to @ref{Flex and POSIX}.
のようになりますが、
これは不正だからです。
このような種類の問題に関する説明については、
@ref{Flex and POSIX}を参照してください。

@c +--------------------------------------------------------------------+
@c |                                                                    |
@c | The explains what the %% mean                                      |
@c |                                                                    |
@c +-----------------+-----------------+-----------------+--------------+ 
@c |       Name      |       Next      |     Previous    |       Up     |
@c +-----------------+-----------------+-----------------+--------------+ 
@c @node    %%, Rules, Definitions, Flex Descriptions
@node    %%, Rules, Definitions, Flex Descriptions
@section    %%
@comment    ##
@c __ @cindex     Code blocks
@cindex     コード・ブロック

@c __ The two percentage signs mark the start and end of the rules section of
@c __ a scanner description.  Every Flex description must have at least the
@c __ opening pair.
２つのパーセント記号が、
スキャナ記述情報のルール・セクションの先頭と末尾を示します。
すべてのFlex記述情報は、
少なくともルール・セクションの先頭を示す@samp{%%}を含んでいなければなりません。

@c +--------------------------------------------------------------------+
@c |                                                                    |
@c | This explains the components of rules, and what they are           |
@c |                                                                    |
@c +-----------------+-----------------+-----------------+--------------+ 
@c |       Name      |       Next      |     Previous    |       Up     |
@c +-----------------+-----------------+-----------------+--------------+ 
@c @node    Rules, Pattern Matching, %%, Flex Descriptions
@node    Rules, Pattern Matching, %%, Flex Descriptions
@c __ @section    Rules
@section    ルール
@comment    #####
@c __ @cindex     Rule definitions
@c __ @cindex     Flex, pattern matching rules
@c __ @cindex     Rules
@cindex     ルール定義
@cindex     Flex、パターン・マッチング・ルール
@cindex     ルール

@c __ Rules are the heart of Flex.  By writing rules, the programmer tells
@c __ Flex what the scanner should do.
ルールはFlexの心臓部です。
ルールを書くことによって、
プログラマは、
スキャナが何を実行するべきであるかをFlexに通知します。

@c __ Usually, rules have two parts:
通常、
ルールは２つの部分から構成されます。

@example 
@var{pattern}       @var{actions}
@end example

@noindent
@c __ where the @var{pattern} section defines what to recognize, and the
@c __ @var{actions} section tells the scanner what to do when it recognizes
@c __ something.  The pattern part is delimited by whitespace, which means
@c __ that if you want to match spaces, you must enclose them in quotes. 
このうち@var{pattern}が何を認識するべきかを定義し、
@var{actions}がその何かを認識した時に何を実行するべきであるかをスキャナに知らせます。
@var{pattern}の部分は空白によって区切られます。
これは、
空白をマッチさせたい場合には、
それを引用符で囲む必要があるということを意味しています。

@c __ If a scanner finds more than one match, it uses the following two rules to
@c __ decide which to accept. 
スキャナは、
マッチするものを２つ以上見つけた場合、
以下の２つのルールを使ってどれを受け入れるかを決めます。

@enumerate
@item 
@c __ Accept the longest match, including trailing context.  
後続コンテキスト（trailing context）も含めて最も長いものを受け入れる。
@item 
@c __ If the matches are all the same length, accept the one which came first
@c __ in the scanner definition.
マッチするものがすべて同じ長さの場合、
スキャナ定義中に最初に記述されたものを受け入れる。
@end enumerate

@c __ The @var{actions} part can be empty (no code), a single line containing
@c __ one or more C statements, one or more lines of code surrounded by the
@c __ @code{@{@dots{}@}} or @code{%@{@dots{}%@}} pair, or a single vertical
@c __ bar (@samp{|}).  Here are some examples:
@var{actions}は、
空（コードなし）にするか、
もしくは、
１つ以上のCの文を含む単一のコード行、
@code{@{@dots{}@}}または@code{%@{@dots{}%@}}で囲まれた１行以上のコード、
単一の垂直棒（@samp{|}）のいずれかを記述することができます。
以下にいくつか例を挙げます。

@example
@group
hi         |
bonjour    |
hello      printf("hello!\n");
goodbye    @{  printf("goodbye!\n"); @}
konnichiwa @{                   
               @var{line 1}      
               @dots{}             
               @var{line n}      
           @} 
sayonara   printf("lex will not "); printf("print this\n");
@end group
@end example

@noindent
@c __ where any single line may contain multiple statements. The @samp{|}
@c __ tells Flex that the actions part of the next rule should be invoked when
@c __ a match occurs on the current rule.
どの行も複数の文を含むことができます。
@samp{|}は、
そのルールにマッチするものが見つかった場合、
次に現れるルールのアクション部に記述されているアクションが実行されるべきであることをFlexに通知します。

@c __ @strong{Please note:} @i{Most versions of Lex only allow a single
@c __ statement outside the @{ @} pair (for example, the @code{sayonara} rule
@c __ will not work).  Also, in versions where Lex is targeted at a language
@c __ other than C, the @{ @} pair may need to be replaced with different
@c __ symbols, like @code{begin@dots{}end} in the case of Pascal.  }
@strong{注：}@i{ほとんどのバージョンのLexは、
@samp{@{}と@samp{@}}のペアの外部では単一の文しか許しません
（例えば上の@code{sayonara}ルールは許されません）。
また、
C以外の言語をターゲットにしているLexでは、
@samp{@{}と@samp{@}}のペアは、
例えばPascalの場合の@code{begin@dots{}end}のように、
異なるシンボルに置き換える必要があるかもしれません。}

@c __ @cindex Scanner's default actions
@cindex スキャナのデフォルト・アクション
@c __ Note that the default for unmatched input is to write it on
@c __ @code{stdout} and the default action for matched patterns is to discard
@c __ them.  This means that the simplest Flex definition is:
ルールにマッチしなかった入力に対するデフォルトのアクションは、
それを@code{stdout}に出力することであり、
一方、
マッチしたパターンに対するデフォルトのアクションは、
それを破棄することであるという点に注意してください。
これは、
最も単純なFlexの定義が

@example
%%
@end example

@noindent
@c __ which will write the input to @code{stdout} unchanged.  Another simple
@c __ example is:
であることを意味しています。
これは、
入力を変更せずそのまま@code{stdout}へ出力するものです。
別の単純な例として以下のようなものがあります。

@example
%%
foobar
@end example

@noindent
@c __ which deletes all occurrences of @samp{foobar} from the input, and
@c __ copies the rest of the input to @code{stdout}.
この場合、
入力の中から@samp{foobar}という文字の並びをすべて取り除き、
取り除いた結果を@code{stdout}に出力します。

@c +--------------------------------------------------------------------+
@c |                                                                    |
@c | This explains the expressions used for matching patterns.          |
@c |                                                                    |
@c +-----------------+-----------------+-----------------+--------------+ 
@c |       Name      |       Next      |     Previous    |       Up     |
@c +-----------------+-----------------+-----------------+--------------+ 
@c @node    Pattern Matching, Regular Expressions, Rules, Flex Descriptions
@node    Pattern Matching, Regular Expressions, Rules, Flex Descriptions
@c __ @section    The Pattern Section
@section    パターン・セクション
@comment    ###################
@c __ @cindex     Patterns, matching
@c __ @cindex     Matching patterns
@c __ @cindex     Flex rules
@c __ @cindex     Data types in Flex
@c __ @cindex     Flex data types
@cindex     パターン、マッチング
@cindex     パターンのマッチング
@cindex     Flexルール
@cindex     Flexにおけるデータ型
@cindex     Flexデータ型

@c __ The pattern section performs the actual matching by using a construct
@c __ called a @dfn{regular expression}.  Regular expressions are made up of
@c __ strings, characters, sets of characters (or @dfn{classes}) and
@c __ operators.  The parts that make up regular expressions are explained in
@c __ the following sections, and regular expressions themselves are discussed
@c __ in @ref{Regular Expressions}.
パターン・セクションは、
@dfn{正規表現}と呼ばれる仕組みを使って実際のマッチング処理を実行します。
正規表現は、
文字列、文字、文字集合（@dfn{クラス}）、および演算子から構成されています。
正規表現を構成する要素については次節以降で説明します。
また正規表現自体については、
@ref{Regular Expressions}において議論します。

@ifnottex
========================================================================
@c __ @menu
@c __ * Characters::                  Characters in Flex.  Special characters.  
@c __ * Strings::                     What strings are in Flex, and special 
@c __                                 strings.  
@c __ * Character Classes::           Explains what character classes are and how to
@c __ use them.  
@c __ @end menu
@menu
* Characters::                  Flexにおける文字、特殊文字
* Strings::                     Flexにおける文字列、特殊文字列
* Character Classes::           文字クラスの説明、その使い方
@c @ifset INCLUDEFLEX25INFO
* Character Class Expressions (Flex 2.5)::  同上（Flex 2.5の補足情報）
@c @end ifset
@end menu
========================================================================
@end ifnottex

@c +--------------------------------------------------------------------+
@c |                                                                    |
@c | This tells us about characters, special characters etc.            |
@c |                                                                    |
@c +-----------------+-----------------+-----------------+--------------+ 
@c |       Name      |       Next      |     Previous    |       Up     |
@c +-----------------+-----------------+-----------------+--------------+ 
@c @node    Characters, Strings, Pattern Matching, Pattern Matching
@node    Characters, Strings, Pattern Matching, Pattern Matching
@c __ @subsection Characters
@subsection 文字
@c __ @cindex Characters in Flex
@c __ @cindex Flex characters
@cindex Flexにおける文字
@cindex Flex文字

@c __ Some characters have special meaning to Flex and cannot @emph{safely }be
@c __ used alone to represent themselves.  Here is a table of the special
@c __ characters in Flex and their associated meaning.
いくつかの文字はFlexにとって特別の意味があり、
その文字を単独で使ったのでは、
その文字自体を表すことができません。
以下に、
Flexにおける特殊文字とその意味を表にして示します。

@sp 1
@quotation
@need 1750
@table @code
@c __ @item @b{Character}
@item @b{文字}
@c __ @b{Flex interpretation of the character}
@b{Flexによる解釈}

@item .
@c __ A period stands for any character @emph{except} a newline (@samp{\n}).
ピリオドは改行（@samp{\n}）@emph{以外}の任意の文字を表します。

@item \
@c __ The backslash is an escape character.  The escape sequences are the same
@c __ as those found in ANSI C.
バックスラッシュはエスケープ文字です。
エスケープ・シーケンスはANSI Cのものと同一です。

@item [ ]
@c __ Brackets group characters into @dfn{character classes}. 
@c __ @xref{Character Classes, , Grouping Characters in Flex}, for more details.
角括弧[ ]は複数の文字を@dfn{文字クラス}にグループ化します。
詳細については、
@xref{Character Classes, , Flexにおける文字のグループ化}。

@item ^
@c __ Within a character class, a circumflex denotes negation.
@c __ @xref{Character Classes, , Grouping Characters in Flex}, for more details.  
@c __ Outside a character class, it denotes the start of a line, and may only
@c __ appear at the beginning of a rule.  For example:
文字クラスの内部では^は否定を意味します。
詳細については、
@xref{Character Classes, , Flexにおける文字のグループ化}。
文字クラスの外部では、
^は行の先頭を意味し、
ルールの先頭にのみ置くことができます。
例を以下に示します。

@quotation
@table @code
@item [^AB]
@c __ A negative class.  
否定クラスです。

@item ^foo
@c __ Matches @samp{foo} only when it occurs at the start of a line.
行の先頭にある@samp{foo}という文字の並びにのみマッチします。

@item foo^
@c __ In this case, @samp{^} will be seen as a normal character.  For times
@c __ like this, it is usually better prepend a @samp{\} to the special
@c __ character to be certain you @emph{do} get what you want.  Such sequences
@c __ are called @dfn{escape sequences}, and are explained at the end of this
@c __ section.
この場合、
@samp{^}は普通の文字であるとみなされます。
このような時には、
希望どおりの結果が@emph{確実}に得られるようにするために、
特別な意味を持つ文字の前にバックスラッシュ@samp{\}を置くのが良いでしょう。
このような文字の並びを@dfn{エスケープ・シーケンス}と呼びます。
エスケープ・シーケンスについてはこの節の最後で説明します。
@end table
@end quotation

@item -
@c __ A hyphen denotes a range of characters inside a character class.
@c __ Outside character classes, it represents itself.
@c __ @xref{Character Classes, , Grouping Characters in Flex}, for more details.
ハイフンは文字クラスの内部において文字の範囲を表します。
文字クラスの外部では、
ハイフンはそれ自身を表します。
詳細については、
@xref{Character Classes, , Flexにおける文字のグループ化}。

@item @{ @}
@c __ Curly braces reference a definition, enclose multiple lines of actions,
@c __ or define a range of repetitions.  As an example, if you have a
@c __ definition @code{FOO}, and you want to reference it in a rule, use
@c __ @code{@{FOO@}}.
大括弧@{ @}は、
定義の参照、複数行のアクションの囲み、またはある範囲にわたる繰り返しの定義を行います。
例を挙げると、
定義@code{FOO}があって、
それをルールの中で参照したい場合に@code{@{FOO@}}を使います。

@c __ To define a range of repetitions for a given match, use @samp{
@c __ @{ @var{repetition list} @}} like this: 
与えられたパターンのある範囲にわたる繰り返しを定義するには、
以下のような@samp{@{ @var{repetition list} @}}を使います。

@example
@group
%%
@c __ f@{2,5@}  /* match `f' 2 to 5 times    */
@c __ f@{2,@}   /* match `f' 2 or more times */
@c __ f@{2@}    /* match `f' 2 times         */
f@{2,5@}  /* fの２回以上５回以下の繰り返し */
        /* にマッチ                      */
f@{2,@}   /* fの２回以上の繰り返しにマッチ */
f@{2@}    /* fの２回の繰り返しにマッチ     */
@end group
@end example

@noindent
@c __ There are some differences between Flex and Lex in the way they
@c __ interpret this usage.  Refer to @ref{Flex and POSIX}, for more details.
この用法の解釈において、 
FlexとLexの間にはいくつかの相違点があります。
詳細については、
@ref{Flex and POSIX}を参照してください。

@item ( )
@c __ Parentheses enable you to override precedence.  Note also that
@c __ definitions are implicitly surrounded by parentheses when they 
@c __ are expanded. This leads to an incompatibility with Lex, which is
@c __ described in @ref{Flex and POSIX}, and in @ref{Definitions}.
丸括弧( )を使って優先順位を変更することができます。
@c @ifset INCLUDEFLEX25INFO
また、
定義が展開される時には、
その定義は暗黙のうちに丸括弧( )で囲まれることに注意してください。@footnote{訳注：Flex 2.5では、
@samp{-l}オプションを指定して生成されたスキャナは、
Lexの場合と同じように、
定義を展開する時に丸括弧( )で囲みません。}
@c @end ifset
@c @ifclear INCLUDEFLEX25INFO
@c また、
@c 定義が展開される時には、
@c その定義は暗黙のうちに丸括弧( )で囲まれることに注意してください。
@c @end ifclear
このため、
Lexとは非互換なところがでてきます。
この点については、
@ref{Flex and POSIX}と@ref{Definitions}で説明しています。

@item "" 
@c __ Double quotation marks indicate strings, but only the characters that
@c __ are inside the quotes are matched. Thus,
二重引用符記号は文字列を表します。
引用符の内側の文字列だけがマッチの対象になります。
したがって、

@example
%%
"string"
@end example

@noindent
@c __ matches @code{string} not @code{"string"}.  
は@code{"string"}にではなく、
@code{string}にマッチします。

@item /
@c __ The forward slash establishes a trailing context.  This is a situation
@c __ in which you want to recognize a pattern, but only if it is followed by
@c __ a certain sequence of characters.  This means @samp{/} acts as a kind of
@c __ @dfn{lookahead} operator.  For example:
スラッシュは後続コンテキスト（trailing context）を設定します。
これは、
あるパターンの後ろに特定の文字の並びが続く場合のみ、
そのパターンを認識したいという状況です。
つまり、
スラッシュ@samp{/}は「@dfn{ルック・アヘッド}（その先を見る）」演算子として機能するということです。
例を挙げると、

@quotation
@table @code
@item abcDEF
@c __ This will recognize @samp{abcDEF}.  
@samp{abcDEF} を認識します。

@item abc/DEF
@c __ This will recognize @samp{abc} only if it is followed by @samp{DEF}.
@c __ @samp{DEF} is left unmatched, as though the characters had not yet been
@c __ read.
@samp{abc}の後ろに@samp{DEF}が続く場合に限り、
@samp{abc}を認識します。
@samp{DEF}の部分は、
あたかもまだ読まれてはいないかのように扱われ、
マッチの対象になりません。
@end table
@end quotation

@c __ @strong{Please note:} @i{Only one @samp{/} is allowed per rule.  This
@c __ means the following}
@strong{注：}@i{１つのルールの中では@samp{/}は１つだけ許されます。
つまり、}

@example
abc/def/hijkl
@end example

@noindent
@c __ @i{ is illegal.  }
@i{は不正です。}

@item < >
@c __ Angle brackets reference start states.  They are also used in the EOF
@c __ symbol(@samp{<<EOF>>}).  @xref{Start States}, and 
@c __ @ref{End-Of-File Rules}, to get a full explanation of this.
かぎ括弧< >はスタート状態を参照します。
また、
EOFシンボル（@samp{<<EOF>>}）にも使われます。
完全な説明については、
@ref{Start States}と@ref{End-Of-File Rules}を参照してください。

@item ? + *
@c __ The @samp{?},@samp{+}, and @samp{*} characters establish how many times
@c __ a @emph{regular expression} may appear.  The @samp{?} means 0 or 1 time
@c __ (``optional''), the @samp{+} means 1 or more times, and the @samp{*}
@c __ means 0 or more times.  For example:
@samp{?}、@samp{+}、@samp{*}は、
ある@emph{正規表現}が現れることのできる回数を設定します。
@samp{?}は０回もしくは１回
（その正規表現が現れることは必須ではないということ）
を意味します。
@samp{+}は１回以上を意味します。
@samp{*}は０回以上を意味します。
例えば、

@quotation
@table @code
@item a?
@c __ Matches 0 or 1 @code{a}'s.  
０個もしくは１個の@code{a}にマッチします。

@item a+
@c __ Matches 1 or more @code{a}'s.  
１個以上の@code{a}にマッチします。

@item a*
@c __ Matches 0 or more @code{a}'s.  
０個以上の@code{a}にマッチします。

@item (ABC)+
@c __ Matches the sequence @samp{ABC} one or more times.  
@samp{ABC}という文字の並びが１回以上続くものにマッチします。

@item [abQrS]?
@c __ Matches 0 or 1 members of this character class (which is made up of the
@c __ five letters, @samp{abQrS}).  
@c __ Refer to @ref{Character Classes, , Grouping Characters in Flex}, for more
@c __ details on what character classes are.
０個もしくは１個の、
（５つの文字@samp{abQrS}から構成される）
この文字クラスのメンバにマッチします。
文字クラスに関する詳細については、
@ref{Character Classes, , Flexにおける文字のグループ化}を参照してください。

@item @{NUM@}*
@c __ Match 0 or more @code{NUM}.  Here, @code{NUM} is a definition.  Refer to
@c __ @ref{Definitions}, for more details on what they are.
０個以上の@code{NUM}にマッチします。
ここでの@code{NUM}は定義です。
定義に関する詳細については、
@ref{Definitions}を参照してください。
@end table
@end quotation

@item |
@c __ This represents an ``or'' operator, and a special action.  For
@c __ example:
OR演算子、
および、
特別なアクションを表します。
例えば、

@example
   apples|oranges
@end example

@noindent
@c __ will match on either @code{apples} or @code{oranges}, and
は@code{apples}もしくは@code{oranges}のいずれかにマッチし、

@example
apples         |
oranges        printf("fruit!\n"); 
@end example

@noindent
@c __ executes the same @emph{action} for both apples and oranges.
は、
@code{apples}と@code{oranges}の両方に対して同一の@emph{アクション}を実行します。

@item $
@c __ The dollar sign signifies end-of-line.  For example:
ドル記号は行末を意味します。
例えば、

@example
   end$
@end example

@noindent
@c __ will match on @samp{end}, only if it is followed by the end of the line,
@c __ which is exactly the same as
はその直後が行末である場合にのみ@samp{end}という文字の並びにマッチします。
これは、
後ろに続くのが行末のマーカである場合のみ@samp{end}にマッチする

@example
   end/\n
@end example

@noindent
@c __ which matches @code{end} only if the @emph{lookahead} is the end-of-line
@c __ marker.
とまったく同じです。

@end table
@end quotation

@noindent
@c __ When you wish to represent one of these characters literally, you must
@c __ write it within quotes or represent it as an escape sequence (explained
@c __ in the table).
こうした文字のいずれかをその文字自身として表したい場合には、
引用符で囲むか、
（後に示す表で説明する）
エスケープ・シーケンスとして表さなければなりません。

@c __ There are three kinds of escape sequences in Flex.  One uses octal
@c __ numbers following @samp{\}, one uses hexadecimal numbers following
@c __ @samp{\x}, and one uses  @samp{\@var{letter}} to represent either
@c __ the letter, or some special non-printable character.  Those familiar
@c __ with C will recognize these as the ANSI C escape sequences.  Numeric
@c __ escape sequences should be avoided as they are not 100% portable, and
@c __ make maintenance more difficult.
Flexには３種類のエスケープ・シーケンスがあります。
バックスラッシュ@samp{\}に続けて8進数を使うもの、
@samp{\x}に続けて16進数を使うもの、
@samp{\@var{letter}}という表記法によってある１文字、
または、
特別な表示不可の文字を表すものの３つです。
Cをよく知っている人であれば、
この３つがANSI Cのエスケープ・シーケンスであることに気がつくことでしょう。
数値によるエスケープ・シーケンスは、
100パーセント移植性があるわけではなく、
保守を困難にするので、
避けるべきです。

@c __ Here is a summary of the use of characters.  In the table @samp{c}
@c __ represents a single character, @samp{NNN} represents an octal constant,
@c __ and @samp{HH} represents a hexadecimal constant.
以下に、
文字の使用に関する要約を示します。
この表中では、
@samp{c}が単一の文字を、
@samp{NNN}が8進定数を、
@samp{HH}が16進定数を表します。
@*

@ifinfo
@example
@c __                     CHARACTERS IN FLEX
@c __ ============+========================================+============
@c __  CHARACTER  |                  MEANING               | EXAMPLE
@c __ ============+========================================+============
@c __    c        | The letter unless it is an operator    | a
@c __    .        | Any character except a newline (\n)    | .  
@c __   "c"       | c                                      | "^", "$"
@c __    \b       | Back space      (BS)                   | [\b]
@c __    \t       | Tab             (HT)                   | [\t]
@c __    \n       | New line        (NL)                   | [\n]
@c __    \v       | Vertical tab    (VT)                   | [\v] 
@c __    \f       | Form feed       (FF)                   | [\f]
@c __    \r       | Carriage return (CR)                   | [\r]
@c __    \\       | A single backslash                     | \\, \\b
@c __    \"       | A single quote                         | \"
@c __    \0       | The NUL character                      | \0
@c __    \c       | c, for c not one of the above chars.   | \w
@c __    \xHH     | Character with value HH in hexadecimal.| \x1B 
@c __    \NNN     | Character with value NNN in octal.     | \033
                    Flexにおける文字
============+========================================+============
  文字      |                  意味                  | 例
============+========================================+============
   c        | cが演算子でない場合は、文字c自体       | a
   .        | 改行（\n）以外の任意の文字             | .  
  "c"       | c                                      | "^", "$"
   \b       | バックスペース       （BS）            | [\b]
   \t       | 水平タブ             （HT）            | [\t]
   \n       | 改行                 （NL）            | [\n]
   \v       | 垂直タブ             （VT）            | [\v] 
   \f       | 頁送り               （FF）            | [\f]
   \r       | キャリッジ・リターン （CR）            | [\r]
   \\       | 単一バックスラッシュ                   | \\, \\b
   \"       | 単一引用符                             | \"
   \0       | NUL文字                                | \0
   \c       | cが上記以外の文字の場合、文字c自体     | \w
   \xHH     | 16進数HHを値として持つ文字             | \x1B 
   \NNN     | 8進数NNNを値として持つ文字             | \033
@end example
@end ifinfo

@c +--------------------------------------------------------------+
@c | TeX sure does lead to some weird looking code at times....   |
@c | I'll be buggered if I'll understand this at first glance six |
@c | months from now...                                           |
@c +--------------------------------------------------------------+

@c Bob>>  This raw TeX could use some documentation.... :-)
@c nick>> Hopefully, no-one will read this... :-)

@iftex
@tex
%% __ \font\ett=cmtt9
%% __ \font\erm=cmr9
%% __ \erm
%% __ \vbox{
%% __ \center{\bf Characters in Flex}
%% __ \hfil
%% __ \vbox{
%% __ \offinterlineskip
%% __ \def\tablerule{\noalign{\hrule}}
%% __ \halign {\strut#& \vrule#\tabskip=1em plus2em &
%% __    \hfil#& \vrule#& #\hfil& \vrule#&
%% __    \hfil#& \vrule#\tabskip=0pt\cr\tablerule
%% __ &&\omit\hidewidth  \ \ Character\ \  \hidewidth
%% __ &&\omit\hidewidth  \ \ Meaning\ \   \hidewidth
%% __ &&\omit\hidewidth  \ \ Example\ \    \hidewidth&\cr\tablerule
%% __ && {\ett c}                       && {\ett c}, unless it is an operator.
%% __ && {\ett a }                      & \cr\tablerule
%% __ 
%% __ && {\ett "c"}                     && {\ett c}                            
%% __ && {\ett "|"}                     & \cr\tablerule
%% __ 
%% __ && {\ett .}                       && Any character except a newline     
%% __ && {\ett Un.x}                     & \cr\tablerule
%% __ 
%% __ && {\ett $\backslash$b}           && Back space     (BS)  
%% __ && {\ett $\backslash$b}           & \cr\tablerule
%% __ 
%% __ && {\ett $\backslash$t}           && Tab            (HT)  
%% __ && {\ett $\backslash$t}           & \cr\tablerule
%% __ 
%% __ && {\ett $\backslash$n}           && New line       (NL) 
%% __ && {\ett $\backslash$n}           & \cr\tablerule
%% __ 
%% __ && {\ett $\backslash$v}           && Vertical table (VT) 
%% __ && {\ett $\backslash$v}           & \cr\tablerule
%% __ 
%% __ && {\ett $\backslash$f}           && Form feed      (FF) 
%% __ && {\ett $\backslash$f}           & \cr\tablerule
%% __ 
%% __ && {\ett $\backslash$r}           && Carriage return(CR) 
%% __ && {\ett $\backslash$r}           & \cr\tablerule
%% __ 
%% __ && {\ett $\backslash$"}           && A single quote.
%% __ && {\ett $\backslash$"}           & \cr\tablerule
%% __ 
%% __ && {\ett $\backslash\backslash$}  && A single backslash            
%% __ && {\ett $\backslash\backslash$}  & \cr\tablerule
%% __ 
%% __ && {\ett $\backslash$0}           && The NUL character            
%% __ && {\ett $\backslash$0}           & \cr\tablerule
%% __ 
%% __ && {\ett $\backslash$c}           && c, for any c other than those above
%% __ && {\ett $\backslash$*}           & \cr\tablerule
%% __ 
%% __ && {\ett $\backslash$xHH}         && Character with value HH in Hexadecimal 
%% __ && {\ett $\backslash$x1B}         & \cr\tablerule
%% __ 
%% __ && {\ett $\backslash$NNN}         && Character with value NNN in Octal      
%% __ && {\ett $\backslash$033}         & \cr\tablerule}}
%% __ \hfil}
\font\ett=cmtt9
\font\erm=cmr9
\erm
\vbox{
\center{\bf Flexにおける文字}
\hfil
\vbox{
\offinterlineskip
\def\tablerule{\noalign{\hrule}}
\halign {\strut#& \vrule#\tabskip=1em plus2em &
   \hfil#& \vrule#& #\hfil& \vrule#&
   \hfil#& \vrule#\tabskip=0pt\cr\tablerule
&&\omit\hidewidth  \ \ 文字\ \  \hidewidth
&&\omit\hidewidth  \ \ 意味\ \   \hidewidth
&&\omit\hidewidth  \ \ 例\ \    \hidewidth&\cr\tablerule
&& {\ett c}                       && {\ett c}が演算子でない場合は、文字{\ett c}自体
&& {\ett a }                      & \cr\tablerule

&& {\ett "c"}                     && {\ett c}                            
&& {\ett "|"}                     & \cr\tablerule

&& {\ett .}                       && 改行以外の任意の文字     
&& {\ett Un.x}                     & \cr\tablerule

&& {\ett $\backslash$b}           && バックスペース       （BS）  
&& {\ett $\backslash$b}           & \cr\tablerule

&& {\ett $\backslash$t}           && 水平タブ             （HT）  
&& {\ett $\backslash$t}           & \cr\tablerule

&& {\ett $\backslash$n}           && 改行                 （NL） 
&& {\ett $\backslash$n}           & \cr\tablerule

&& {\ett $\backslash$v}           && 垂直タブ             （VT） 
&& {\ett $\backslash$v}           & \cr\tablerule

&& {\ett $\backslash$f}           && 頁送り               （FF） 
&& {\ett $\backslash$f}           & \cr\tablerule

&& {\ett $\backslash$r}           && キャリッジ・リターン （CR） 
&& {\ett $\backslash$r}           & \cr\tablerule

&& {\ett $\backslash$"}           && 単一引用符
&& {\ett $\backslash$"}           & \cr\tablerule

&& {\ett $\backslash\backslash$}  && 単一バックスラッシュ            
&& {\ett $\backslash\backslash$}  & \cr\tablerule

&& {\ett $\backslash$0}           && NUL文字            
&& {\ett $\backslash$0}           & \cr\tablerule

&& {\ett $\backslash$c}           && cが上記以外の文字の場合、文字c自体
&& {\ett $\backslash$*}           & \cr\tablerule

&& {\ett $\backslash$xHH}         && 16進数HHを値として持つ文字 
&& {\ett $\backslash$x1B}         & \cr\tablerule

&& {\ett $\backslash$NNN}         && 8進数NNNを値として持つ文字      
&& {\ett $\backslash$033}         & \cr\tablerule}}
\hfil}
@end tex
@end iftex

@*
@c __ @emph{@strong{Please note:} Some versions of Lex do not recognize or
@c __ match @samp{\0} correctly because it represents NUL, the C string
@c __ terminator.  Matching NUL does not present a problem for Flex, though it
@c __ does affect performance somewhat.  }
@emph{@strong{注：}いくつかのバージョンのLexでは、
@samp{\0}を正しく認識、
またはマッチしません。
これは、
@samp{\0}がNUL、
つまりC文字列の終端文字だからです。
Flexでは、
NULをマッチの対象にしても問題はありませんが、
性能には若干影響します。}
@c __ @cindex Escape sequences
@cindex エスケープ・シーケンス

@c __ In addition, the operators @samp{^} and @samp{<<EOF>>} may only appear
@c __ at the beginning of a rule.  These and @samp{$} and @samp{/} cannot
@c __ appear inside of parentheses.  This in turn affects the legality of
@c __ certain definitions because definitions are literally enclosed in
@c __ parentheses when they are expanded.  Refer to @ref{Definitions}, and
@c __ @ref{Flex and POSIX}, for a detailed explanation.
さらに付け加えると、
@samp{^}演算子と@samp{<<EOF>>}はルールの先頭にのみ置くことができます。
また、
これらと@samp{$}、@samp{/}は丸括弧( )の内部に置くことはできません。
このことはまた、
定義の正当性にも影響を及ぼします。
@c @ifset INCLUDEFLEX25INFO
というのは、
展開される時に定義は字義どおりに丸括弧( )で囲まれるからです。@footnote{訳注：Flex 2.5では、
@samp{-l}オプションを指定して生成されたスキャナは、
Lexの場合と同じように、
定義を展開する時に丸括弧( )で囲みません。}
@c @end ifset
@c @ifclear INCLUDEFLEX25INFO
@c というのは、
@c 展開される時に定義は字義どおりに丸括弧( )で囲まれるからです。
@c @end ifclear
詳細については、
@ref{Definitions}と@ref{Flex and POSIX}を参照してください。

@c +--------------------------------------------------------------------+
@c |                                                                    |
@c | This tells us what  strings are in Flex                            |
@c |                                                                    |
@c +-----------------+-----------------+-----------------+--------------+ 
@c |       Name      |       Next      |     Previous    |       Up     |
@c +-----------------+-----------------+-----------------+--------------+ 
@c @node    Strings, Character Classes, Characters, Pattern Matching
@node    Strings, Character Classes, Characters, Pattern Matching
@c __ @subsection Strings in Flex
@subsection Flexにおける文字列
@c __ @cindex Strings in Flex
@c __ @cindex Flex strings
@cindex Flexにおける文字列
@cindex Flex文字列

@c __ A @dfn{string} is a group of characters, often (but not always)
@c __ surrounded by quotes.  Strings may not contain newlines or non-printable
@c __ characters unless escape sequences are used.
@dfn{文字列}とは、
（常に、というわけではありませんが）
多くの場合、
引用符によって囲まれる文字のグループです。
エスケープ・シーケンスが使われない限り、
文字列には改行や表示不可の文字を含めることはできません。

@c __ Matches on a string occur on the @emph{literal} string, including the
@c __ case of the string, unless the @samp{-i} option is used 
@c __ (@xref{Case Insensitive Scanners}, for more details.)
@c __ For a quoted string, the quotes are @emph{not} part of the recognized string.
@samp{-i} オプション
（詳細については、@xref{Case Insensitive Scanners}）
を使わない限り、
大文字・小文字の区別も含めた@emph{字義どおり}の文字列に対してマッチが行われます。
引用符付きの文字列については、
引用符は認識される文字列には@emph{含まれません}。

@need 1000
@c __ For example:
例えば、

@example
@group
string
StrING
"STRING"
\"string\"
@end group
@end example

@noindent
@c __ are all legal strings, the last of which matches the quotes as well.
@c __ Strings in Flex do not @emph{require} the quotes.  So if you are
@c __ matching a group of keywords, either
はすべて正当な文字列であり、
最後のものは引用符も含めてマッチされます。
Flexにおいては文字列には引用符は@emph{必須}ではありません。
したがって、
キーワードのグループにマッチさせる場合、

@example
@group
begin
end
pointer
 @dots{}
@end group
@end example

@noindent
@c __ or
と

@example
@group
"begin"
"end"
"pointer"
 @dots{}
@end group
@end example

@noindent
@c __ are legal.  
のいずれも正当です。

@c +--------------------------------------------------------------------+
@c |                                                                    |
@c | This tells us about character classes.  |
@c |                                                                    |
@c +-----------------+-----------------+-----------------+--------------+ 
@c |       Name      |       Next      |     Previous    |       Up     |
@c +-----------------+-----------------+-----------------+--------------+ 
@c @node    Character Classes,  , Strings, Pattern Matching
@node    Character Classes, Character Class Expressions (Flex 2.5), Strings, Pattern Matching
@c __ @subsection Grouping Characters in Flex
@subsection Flexにおける文字のグループ化
@c __ @cindex Grouping characters
@c __ @cindex Character grouping
@c __ @cindex Character classes
@c __ @cindex Flex character classes
@cindex 文字のグループ化
@cindex 文字クラス
@cindex Flex文字クラス

@c __ Characters in Flex may be grouped together into a @dfn{character class}.
@c __ A character class is created by surrounding a group of characters with
@c __ brackets.  Any character is legal (using escape sequences for
@c __ non-printable characters.), and ranges may be specified with a @samp{-}.
@c __ When a character class is used in a rule, Flex will match any member of
@c __ the class, and acts much as though a single character was used.  For
@c __ example:
Flexでは、
文字をグループ化して@dfn{文字クラス}にすることができます。
文字クラスは、
文字のグループを角括弧[ ]で囲むことにより作成されます。
どのような文字でも正当です
（表示不可の文字についてはエスケープ・シーケンスを使います）。
また、
文字の範囲をハイフン@samp{-}を使って指定することができます。
文字クラスがルールの中で使われている場合には、
Flexはそのクラスの任意のメンバとマッチさせ、
あたかも単一文字が使われているかのように振る舞います。
例えば、

@example
@group
[a-z]
[A-Z]*
@end group
@end example

@noindent 
@c __ The first example will match on any single character from @samp{a} to
@c __ @samp{z}, and the second will match zero or more characters from
@c __ @samp{A} to @samp{Z}.
において、
最初の例は@samp{a}から@samp{z}までの任意の単一文字にマッチします。
第２の例は@samp{A}から@samp{Z}までの任意の文字が０個以上並んだものにマッチします。

@c __ You can also write a regular expression for a @emph{negated} character
@c __ class, which matches everything @emph{except} the members of the
@c __ character class (including @samp{\n}).  Do this by putting a @samp{^} at
@c __ the beginning of the class to be negated.  (Note that the @samp{^}
@c __ outside of classes has a different meaning.)  Here are some examples of
@c __ legal classes.
@emph{否定}文字クラスを表す正規表現を書くこともできます。
否定文字クラスは、
（@samp{\n}も含めて）
文字クラスのメンバ@emph{以外}であれば何にでもマッチします。
これを行うには、
否定すべきクラスの先頭に@samp{^}を置きます。
（クラスの外部では@samp{^}は異なる意味を持つことに注意してください。）
以下に、
正当なクラスの例をいくつか挙げます。

@itemize
@table @code
@item [abc]
@c __ Match @samp{a}, @samp{b}, or @samp{c}.  
@samp{a}、@samp{b}、@samp{c}のいずれかにマッチします。

@item [abc\n]
@c __ Match @samp{a}, @samp{b}, @samp{c}, or @samp{\n}.  
@samp{a}、@samp{b}、@samp{c}、@samp{\n}のいずれかにマッチします。

@item [a-z]
@c __ Match any character between the ASCII values
@c __ for @samp{a} and @samp{z}; that is, any lower-case letter.
ASCII値が@samp{a}から@samp{z}までの範囲にある任意の文字、
すなわち、
任意の英小文字にマッチします。

@item [^a-z]
@c __ Match any character @emph{except} those
@c __ between @samp{a} and @samp{z}.
@samp{a}から@samp{z}までの範囲にある文字@emph{以外}の任意の文字にマッチします。

@item [ABcd]
@c __ Match @samp{A}, @samp{B}, @samp{c}, or @samp{d}.  
@samp{A}、@samp{B}、@samp{c}、@samp{d}のいずれかにマッチします。
@end table
@end itemize

@c __ @strong{Please note:} @i{Flex, and some versions of Lex, cannot deal
@c __ with negative ranges in classes.  So}
@strong{注：}@i{Flex、
およびいくつかのバージョンのLexは、
クラス内における逆方向の範囲を扱うことができません。
したがって、}

@example
@group
%%
[z-a9-0]
@end group
@end example
@noindent
@c __ @i{will result in an error message.  Avoid ranges in reverse order.}
@i{はエラー・メッセージを出力します。
逆方向の範囲は指定しないでください。}

@c Include Flex 2.5 information, for Flex manual as published by ASCII
@c @ifset INCLUDEFLEX25INFO
@node Character Class Expressions (Flex 2.5),  , Character Classes, Pattern Matching
@subsection Flexにおける文字のグループ化（Flex 2.5の補足情報）
@include charclassexpr_addendum-ja.texi
@c @end ifset

@c +--------------------------------------------------------------------+
@c |                                                                    |
@c |    This node explains how regular expressions are used in Flex.    |
@c |                                                                    |
@c +-----------------+-----------------+-----------------+--------------+ 
@c |       Name      |       Next      |     Previous    |       Up     |
@c +-----------------+-----------------+-----------------+--------------+ 
@c @node Regular Expressions, Start States, Pattern Matching, Flex Descriptions
@node Regular Expressions, Start States, Pattern Matching, Flex Descriptions
@c __ @section Regular Expressions
@section 正規表現

@c __ By combining the characters, strings, classes, definitions, and
@c __ operators of Flex, we build a construct known as a @dfn{regular
@c __ expression}.  Like mathematical expressions (where the basic units are
@c __ numbers and operators), the basic building blocks are simple
@c __ (characters, operators, strings, classes and definitions) but they can
@c __ be combined to make more complicated expressions.  For example, @samp{c}
@c __ is a single character regular expression that matches @samp{c},
@c __ @samp{cc} is a regular expression containing a concatenation of two
@c __ regular expressions, so it matches @samp{cc}, and @samp{c*} is a regular
@c __ expression made up of a single character regular expression @samp{c},
@c __ followed by an operator @samp{*}.  This will match zero or more
@c __ @code{c}'s.  The real power of regular expressions lies in the ways they
@c __ can be combined, rather than the basic elements.
Flexの文字、文字列、クラス、定義、および演算子を組み合わせることで、
@dfn{正規表現}として知られているものが作られます。
（基本単位が数と演算子である）
数学表現と同じように、
基本的な要素は単純なもの
（文字、演算子、文字列、クラス、および定義）
ですが、
要素を組み合わせることでより複雑な表現式を作ることができます。
例えば、
@samp{c}は単一文字の正規表現で、
@samp{c}にマッチします。
@samp{cc}は２つの正規表現をつないだものを含む正規表現で、
@samp{cc}にマッチします。
@samp{c*}は、
単一文字の正規表現@samp{c}と、
それに続く演算子@samp{*}から構成される正規表現で、
０個以上の@code{c}にマッチします。
正規表現の真のパワーは、
個々の要素よりもむしろ、
組み合わせ可能な方法の中にあります。

@c __ The following table shows all the regular expressions available in Flex.
@c __ In the table @samp{c} stands for any single character (including an
@c __ escape sequence), @samp{r} for any regular expression and @samp{s} for a
@c __ string.  The table is organized into groups, with those at the top
@c __ having the highest precedence.
次の表は、
Flexで利用可能な正規表現をすべて示したものです。
表中において、
@samp{c}は
（エスケープ・シーケンスを含む）
任意の単一文字を、
@samp{r}は任意の正規表現を、
@samp{s}は文字列を表します。
表はグループ別に編成してあり、
優先度の最も高いものが一番上にあります。
@*  

@ifinfo
@example 
@c __                       REGULAR EXPRESSIONS
@c __ =============+=============================================+================
@c __ EXPRESSION   |           MATCHES                           |   EXAMPLES        
@c __ =============+=============================================+================
@c __    c         | any character except the special characters |  A, \n, a
@c __    .         | any character except a newline              |    abc.*
@c __    [s]       | any character in the string s               |    [abc]
@c __    [^s]      | any character not in the string s           |    [^abc]
@c __    r*        | zero or more r's                            |  (a|b)* or [abc]*
@c __    r+        | one or more r's                             |    (a|b)+
@c __    r?        | zero or one r's                             |  (a|[b-q])?
@c __    r@{x,y@}    | x to y r's (abc@{1,3@} = ab and 1-3 c's       |   foo@{1,5@}
@c __    "s"       | the literal string s                        |    "***"
@c __    \c        | c (unless \c has an ANSI C meaning)         |    \"  \*
@c __    (r)       | r - The parentheses are for grouping        |    (Aa|b)      
@c __              |                                             |
@c __    r1r2      | r1 then r2                                  | Aa or (A|a)[0-9]
@c __              |                                             |
@c __    r1|r2     | r1 or r2                                    |     A|B
@c __              |                                             |
@c __    r1/r2     | r1 when followed by r2                      |    abc/123
@c __    ^         | beginning of the line                       |    ^abc
@c __    $         | end of line                                 |    abc$
@c __              |                                             |
@c __    <start>r  | state state: r is active when `start' is    |  <command>"*/"
@c __    <<EOF>>   | End of file.  (Refer to End-Of-File rules)  |    <<EOF>>
                      Flexにおける正規表現
=============+=============================================+================
正規表現     |           マッチの対象                      |   例        
=============+=============================================+================
   c         | 特殊文字を除く任意の文字                    |  A、\n、a
   .         | 改行を除く任意の文字                        |    abc.*
   [s]       | クラスs中にある任意の文字                   |    [abc]
   [^s]      | クラスs中にない任意の文字                   |    [^abc]
   r*        | ０個以上のr                                 |  (a|b)*、[abc]*
   r+        | １個以上のr                                 |    (a|b)+
   r?        | ０個または１個のr                           |  (a|[b-q])?
   r@{x,y@}    | x個以上y個以下のr                           |   foo@{1,5@}
             | （abc@{1,3@}は、abと１個以上３個以下のc）     |
   "s"       | 字義どおりの文字列s                         |    "***"
   \c        | （\cがANSI Cにおいて特別な意味を持たない    |    \"  \*
             |   場合）c                                   |
   (r)       | r - 丸括弧()はグループ化のためのもの        |    (Aa|b)      
             |                                             |
   r1r2      | r1の後ろにr2が続くもの                      | Aa、(A|a)[0-9]
             |                                             |
   r1|r2     | r1またはr2                                  |     A|B
             |                                             |
   r1/r2     | r2が後ろに続くという条件を満足するr1        |    abc/123
   ^         | 行頭                                        |    ^abc
   $         | 行末                                        |    abc$
             |                                             |
   <start>r  | スタート状態（start状態の時、rがアクティブ）|  <command>"*/"
   <<EOF>>   | ファイルの終端（End-Of-Fileルールを参照）   |    <<EOF>>
@end example
@end ifinfo

@c TODO
@c ### you should give examples of text they might match, too

@iftex
@tex
%% __ \font\ett=cmtt9
%% __ \font\erm=cmr9
%% __ \font\eit=cmmi9
%% __ \erm
%% __ \vbox{
%% __ \center {\bf Regular expressions in Flex}
%% __ \hfil
%% __ \vbox{
%% __ \offinterlineskip
%% __ \def\tablerule{\noalign{\hrule height.5pt}}
%% __ 
%% __ \def\thickrule{\noalign{\hrule height1.25pt}}
%% __ 
%% __ \halign {\strut#& \vrule#\tabskip=1em plus2em &
%% __    \hfil#& \vrule#& \hfil#\hfil& \vrule#&
%% __    \hfil#& \vrule#\tabskip=0pt\cr\tablerule
%% __ &&\omit\hidewidth  Expression   \hidewidth
%% __ &&\omit\hidewidth  Matches      \hidewidth
%% __ &&\omit\hidewidth  Examples      \hidewidth&\cr\tablerule
%% __ 
%% __ && {\ett c}      && any character except the special characters &&
%% __ {\ett A {\eit or} $\backslash$n}        & \cr\tablerule
%% __ 
%% __ && {\ett .}      && any character except a newline ($\backslash$n)   &&
%% __ {\ett efg.*}     & \cr\tablerule
%% __ 
%% __ && {\ett [s]}    && any character in the class {\ett s}                &&
%% __ {\ett [efg] }  &  \cr\tablerule
%% __ 
%% __ && {\ett [$\hat$s]}    && any character {\eit not} in the class {\ett s}  &&
%% __ {\ett [$\hat$mnqs] }  &  \cr\tablerule
%% __ 
%% __ && {\ett r*} && zero or more {\ett r}'s                            &&
%% __ {\ett (a|[e-f])* } & \cr\tablerule
%% __ 
%% __ && {\ett r+} && one or more {\ett r}'s                             && 
%% __ {\ett (a|[e-f])+ } & \cr\tablerule
%% __ 
%% __ && {\ett r?} && zero or one r's                                    &&
%% __ {\ett (a|[e-f])? } & \cr\tablerule
%% __ 
%% __ && {\ett r$\{$x,y$\}$}&& {\ett x} to {\ett y} {\ett r}'s (abc$\{$1,3$\}$ = ab and 1-3 c's)    &&
%% __ {\ett abc$\lbrace$1,5$\rbrace$} & \cr\tablerule
%% __ 
%% __ && {\ett "s"}    && the literal string {\ett s}                        && 
%% __ {\ett "****"}    & \cr\tablerule
%% __ 
%% __ && {\ett $\backslash$c} && {\ett c} (unless {\ett $\backslash$c} has an
%% __ ANSI C meaning)        &&
%% __ {\ett $\backslash$" {\eit or} $\backslash$*} & \cr\tablerule
%% __ 
%% __ && {\ett (r)}     && {\ett r} - the parentheses are for grouping       && 
%% __ {\ett (Ab|Bb)}   & \cr\thickrule
%% __ 
%% __ && {\ett r1r2}    && {\ett r1} followed by {\ett r2}           && 
%% __ {\ett Aa}         & \cr\thickrule
%% __ 
%% __ && {\ett r1|r2}   && {\ett r1} or {\ett r2}                             &&
%% __ {\ett A|B}        & \cr\thickrule
%% __ 
%% __ && {\ett r1/r2}   && {\ett r1} when followed by {\ett r2}               && 
%% __ {\ett abc/123}    & \cr\tablerule
%% __ 
%% __ 
%% __ && {\ett \hat}   && beginning of line                                 && 
%% __ {\ett \hat abc}  &  \cr\tablerule
%% __ 
%% __ && {\ett \$}     && end of line                                       && 
%% __ {\ett abc\$}     & \cr\thickrule
%% __ 
%% __ && {\ett <{\eit start}>r} && start state: {\ett r} is active when {\eit start} is && 
%% __ {\ett <comment>"*/"}     & \cr\tablerule
%% __ 
%% __ && {\ett <<EOF>>}  && end of file (Refer to End-Of-File rules) && 
%% __ {\ett <<EOF>>}    & \cr\tablerule}}
%% __ \hfil}
\font\ett=cmtt9
\font\erm=cmr9
\font\eit=cmmi9
\erm
\vbox{
\center {\bf Flexにおける正規表現}
\hfil
\vbox{
\offinterlineskip
\def\tablerule{\noalign{\hrule height.5pt}}

\def\thickrule{\noalign{\hrule height1.25pt}}

\halign {\strut#& \vrule#\tabskip=1em plus2em &
   \hfil#& \vrule#& \hfil#\hfil& \vrule#&
   \hfil#& \vrule#\tabskip=0pt\cr\tablerule
&&\omit\hidewidth  正規表現   \hidewidth
&&\omit\hidewidth  マッチの対象      \hidewidth
&&\omit\hidewidth  例      \hidewidth&\cr\tablerule

&& {\ett c}      && 特殊文字を除く任意の文字 &&
{\ett A {\eit または} $\backslash$n}        & \cr\tablerule

&& {\ett .}      && 改行（$\backslash$n）を除く任意の文字  &&
{\ett efg.*}     & \cr\tablerule

&& {\ett [s]}    && クラス{\ett s}中にある任意の文字               &&
{\ett [efg] }  &  \cr\tablerule

&& {\ett [$\hat$s]}    && クラス{\ett s}中に{\eit ない}任意の文字   &&
{\ett [$\hat$mnqs] }  &  \cr\tablerule

&& {\ett r*} && ０個以上の{\ett r}                            &&
{\ett (a|[e-f])* } & \cr\tablerule

&& {\ett r+} && １個以上の{\ett r}                             && 
{\ett (a|[e-f])+ } & \cr\tablerule

&& {\ett r?} && ０個または１個の{\ett r}                              &&
{\ett (a|[e-f])? } & \cr\tablerule

&& {\ett r$\{$x,y$\}$}&& {\ett x}個以上{\ett y}個以下の{\ett r}（abc$\{$1,3$\}$は、abと１個以上３個以下のc）    &&
{\ett abc$\lbrace$1,5$\rbrace$} & \cr\tablerule

&& {\ett "s"}    && 字義どおりの文字列{\ett s}                        && 
{\ett "****"}    & \cr\tablerule

&& {\ett $\backslash$c} && （{\ett $\backslash$c}がANSI Cにおいて特別な意味を持たない場合）{\ett c}        &&
{\ett $\backslash$" {\eit または} $\backslash$*} & \cr\tablerule

&& {\ett (r)}     && {\ett r} − 丸括弧( )はグループ化のためのもの       && 
{\ett (Ab|Bb)}   & \cr\thickrule

&& {\ett r1r2}    && {\ett r1}の後ろに{\ett r2}が続くもの          && 
{\ett Aa}         & \cr\thickrule

&& {\ett r1|r2}   && {\ett r1}または{\ett r2}                             &&
{\ett A|B}        & \cr\thickrule

&& {\ett r1/r2}   && {\ett r2}が後ろに続くという条件を満足する{\ett r1}               && 
{\ett abc/123}    & \cr\tablerule


&& {\ett \hat}   && 行頭                                 && 
{\ett \hat abc}  &  \cr\tablerule

&& {\ett \$}     && 行末                                       && 
{\ett abc\$}     & \cr\thickrule

&& {\ett <{\eit start}>r} && スタート状態（{\eit start}状態の時、{\ett r}がアクティブ） && 
{\ett <comment>"*/"}     & \cr\tablerule

&& {\ett <<EOF>>}  && ファイルの終端（End-Of-Fileルールを参照） && 
{\ett <<EOF>>}    & \cr\tablerule}}
\hfil}
@end tex
@end iftex
@*

@c __ Note that while regular expressions are commonly used in Unix wherever a
@c __ pattern search is needed, they are not exactly the same from one
@c __ application to another, though they are very similar.  For example,
@c __ Flex, @code{egrep}, and @code{Emacs} all use regular expressions as
@c __ templates for pattern searches, but the regular expressions each
@c __ understands are slightly different.  In particular, definitions are used
@c __ in Flex, but not in @code{egrep} or @code{Emacs}, and @code{egrep} and
@c __ @code{Emacs} both provide the @samp{\<} and @samp{\>} sequences for
@c __ matching the beginning and end of words, but Flex does not.  In
@c __ addition, @code{Emacs} provides many other special @samp{\@var{letter}}
@c __ sequences for matching the beginning of buffers, doing ``fuzzy''
@c __ matches, and other such things.
Unixにおいてパターン検索が必要な場合には正規表現がよく使われますが、
アプリケーションが異なると、
正規表現もよく似てはいるもののまったく同一ではないという点に注意してください。
例えば、
Flex、@code{egrep}、@code{Emacs}はいずれもパターン検索のテンプレートとして正規表現を使いますが、
それぞれが理解する正規表現は少しずつ異なります。
特に、
Flexでは定義が使われますが、
@code{egrep}や@code{Emacs}では使われませんし、
@code{egrep}や@code{Emacs}は単語の先頭と末尾にマッチさせるための@samp{\<}と@samp{\>}とを提供していますが、
Flexは提供していません。
さらに、
@code{Emacs}はバッファの先頭に対するマッチングや「ファジー」なマッチング等を行うための、
特別な@samp{\@var{letter}}シーケンスをほかにも数多く提供しています。

@c +--------------------------------------------------------------------+
@c |                                                                    |
@c | This node takes care of explaining start states in detail. This can|
@c | be one of the more confusing parts or Lex/Flex.                    | 
@c |                                                                    |
@c +-----------------+-----------------+-----------------+--------------+ 
@c |       Name      |       Next      |     Previous    |       Up     |
@c +-----------------+-----------------+-----------------+--------------+ 
@c @node Start States,  , Regular Expressions, Flex Descriptions
@node Start States, %option (Flex 2.5), Regular Expressions, Flex Descriptions
@c __ @section Start States
@section スタート状態
@comment ################
@c __ @cindex  Context sensitive scanning
@c __ @cindex  Conditional scanning
@c __ @cindex  Changing scanner behavior on the fly 
@c __ @cindex  Setting state behavior
@c __ @cindex  Declaring start states
@c __ @cindex  Start states
@cindex  コンテキスト依存スキャン処理
@cindex  条件スキャン処理
@cindex  スキャナの振る舞いの動的な変更
@cindex  状態の振る舞いの設定
@cindex  スタート状態の宣言
@cindex  スタート状態

@c __ There are times when it is useful to activate a pattern matching rule
@c __ based upon some condition.  For example, in some computer languages, the
@c __ parse state is used to help disambiguate overlapping scanning rules.
@c __ Another example is when you want to have a rules active only after some
@c __ other input has been encountered. For dealing with such situations Flex
@c __ provides a simple system called @dfn{start conditions} or @dfn{start
@c __ states}.
なんらかの条件に基づいて、
パターン・マッチング処理のルールを活性化することが便利な時があります。
例えば、
いくつかのコンピュータ言語では、
重複しているスキャン・ルールの曖昧さを取り除くのを支援するために、
パース状態を使います。
別の例としては、
ある特定の入力が見つかったあとでだけ、
あるルールを活性化したいという場合があります。
このような状況に対処するために、
Flexは@dfn{スタート条件}または@dfn{スタート状態}と呼ばれる単純なシステムを提供しています。

@ifnottex
========================================================================
@c __ @menu
@c __ * Start States Explained::      Declaring start states, and how they affect
@c __                                 the scanner.  
@c __ * Activating States::           How to activate start states.  
@c __ * Start State Notes::           Notes on illegal declarations and on the 
@c __                                 power of exclusive start states.  
@c __ * Start State Example::         Example of using start states.
@c __ @end menu
@menu
* Start States Explained::      スタート状態の宣言、スキャナに対する効果
* Activating States::           スタート状態の活性化方法
* Start State Notes::           不当な宣言、排他的スタート状態のパワーに
                                関する注
@c @ifset INCLUDEFLEX25INFO
* Start State Notes (Flex 2.5)::  同上 （Flex 2.5の補足情報）
@c @end ifset
* Start State Example::         スタート状態の使用例
@end menu
========================================================================
@end ifnottex

@c +--------------------------------------------------------------------+
@c |                                                                    |
@c | This node takes care of explaining what start states are and       |
@c | how they are declared.                                             |
@c |                                                                    |
@c +-----------------+-----------------+-----------------+--------------+ 
@c |       Name      |       Next      |     Previous    |       Up     |
@c +-----------------+-----------------+-----------------+--------------+ 
@c @node Start States Explained, Activating States, Start States, Start States
@node Start States Explained, Activating States, Start States, Start States
@c __ @subsection Start States Explained
@subsection スタート状態の説明
@comment    ######################
@c __ @cindex     Using start states
@cindex     スタート状態の使用

@c __ Start states are like boolean variables which tell Flex when a rule is
@c __ active. Start states are declared in the definitions section, using
@c __ either @code{%x} (for an exclusive start state) or @code{%s} (for an
@c __ inclusive start state): 
スタート状態は、
あるルールがアクティブになるのはいつであるかをFlexに通知するブール値のようなものです。
スタート状態は、
定義セクションにおいて
（排他的スタート状態の場合）@code{%x} 、
または（包含的スタート状態の場合）@code{%s}を使って宣言されます。

@c __ @vindex @code{%x}@r{, in detail}
@c __ @vindex @code{%s}@r{, in detail}
@vindex @code{%x}@r{、詳細}
@vindex @code{%s}@r{、詳細}
@example
%x @var{start_state_name}
%s @var{start_state_name}
@end example

@noindent
@c __ Note that @var{start_state_name} must be a unique name. This means that
@c __ no other start states, and no definitions may have the same name. Start
@c __ states are referenced in the rules section by surrounding the state
@c __ name, or a comma separated list of names, with angle brackets. Start
@c __ state references must be the first part of a rule, and there can be but
@c __ one set of angle brackets per rule. This means that:
@var{start_state_name}は一意な名前でなければならない点に注意してください。
つまり、
他のスタート状態や定義が同じ名前を持ってはならないということです。
スタート状態は、
１つの状態の名前、
または、
カンマで区切られた複数の状態の名前をかぎ括弧< >で囲むことによって、
ルール・セクションで参照されます。
スタート状態の参照はルールの先頭になければならず、
１つのルール中には１対のかぎ括弧< >のみ許されます。
このことは、

@example
@group
%x state1
%s state2
%x state3 state4
%%
<state1>"foo"
<state2,state3,state4>"bar"
@end group
@end example

@noindent
@c __ are legal, whereas
が正当であり、

@example
@group
integer [-+]?[0-9]*
%x integer
%s state1,state2,state3
%%
<integer>"foo"
"bar"<state1>
<state1>"bar"<state2,state3>
@end group
@end example

@noindent
@c __ are all illegal. For @code{integer}, a definition of the same name
@c __ exists, and for the others, the start state reference is in the wrong
@c __ place, or there are multiple references.
はすべて不当であることを意味しています。
@code{integer}については同じ名前を持つ定義が存在し、
それ以外のものについてはスタート状態の参照の位置が正しくないか、
複数の参照が存在するからです。

@c __ So far, we have glossed over the fact that Flex supports two different
@c __ kinds of start states: @dfn{inclusive} (@code{%s}), and @dfn{exclusive}
@c __ (@code{%x}). The difference between these is: when an exclusive start
@c __ state is activated, @emph{only} the rules belonging to that state become
@c __ active, but for inclusive states, the rules belonging to the state, and
@c __ rules without start state references are active. As an example of the
@c __ differences:
これまでのところでは、
Flexが異なる２種類のスタート状態をサポートしている事実から目をそらしてきました。
２つのスタート状態とは、
@dfn{包含的スタート状態}（@code{%s}）と@dfn{排他的スタート状態}（@code{%x}）のことです。
これら２つの相違点は、
排他的スタート状態が活性化された場合は、
その状態に属するルール@emph{だけ}が活性化されるのに対して、
包含的スタート状態の場合は、
その状態に属するルールとスタート状態への参照を持たないルールの両方が活性化されるという点にあります。
この違いを示す例を挙げると、
以下のようになります。

@example
@group
%s state1
%%
<state1>"one" printf("two");
"three"       printf("four");
@end group
@end example

@noindent
@c __ This will translate @samp{one} into @samp{two} if @code{state1} is
@c __ active, and translate @samp{three} into @samp{four} @emph{whether or not
@c __ it is active}. By the default rule, all other text is written to
@c __ @code{stdout}. On the other hand:
この場合、
@code{state1}状態が活性化されている場合は@samp{one}を@samp{two}に置き換え、
@emph{@code{state1}状態が活性化されているか否かにかかわらず}@samp{three}を@samp{four}に置き換えます。
デフォルトのルールにより、
その他のテキストは@code{stdout}に出力されます。
これに対して、

@example
@group
%x state1
%%
<state1>"one" printf("two");
"three"       printf("four");
@end group
@end example

@noindent
@c __ will translate @samp{one} into @samp{two} when @code{state1} is active,
@c __ and @samp{three} into @samp{four} @emph{only when @code{state1} is
@c __ inactive}. By the default rule, all other text is written to
@c __ @code{stdout}.
は、
@code{state1}状態が活性化されている時は@samp{one}を@samp{two}に置き換え、
@emph{@code{state1}状態が活性化されていない時のみ}@samp{three}を@samp{four}に置き換えます。
デフォルトのルールにより、
その他のテキストは@code{stdout}に出力されます。

@c __ This implies that when exclusive start states are used, @emph{each}
@c __ exclusive start state must have rules to match all possible input,
@c __ unless unmatched text may be written to @code{stdout}. Inclusive start
@c __ states need to have just a single catch-all which has no start state
@c __ reference.
このことは、
排他的スタート状態が使われる場合には、
マッチしないテキストが@code{stdout}に出力されてはならないのであれば、
すべての可能な入力にマッチするルールを、
@emph{個々}の排他的スタート状態が持たなければならないことを意味しています。
包含的スタート状態の場合は、
あらゆる状態において有効な、
スタート状態への参照を持たないルールを１つ持つ必要があります。

@c __ @strong{Please note:}@i{Lex does not support exclusive start states,
@c __ even though they are part of POSIX.}
@strong{注：} @i{排他的スタート状態はPOSIXの一部であるにもかかわらず、
Lexではサポートしていません。}

@c +--------------------------------------------------------------------+
@c |                                                                    |
@c | This node explains how to activate start states using the BEGIN    |
@c | statement, and gives a simple example.                             |
@c |                                                                    |
@c +-----------------+-----------------+-----------------+--------------+ 
@c |       Name      |       Next      |     Previous    |       Up     |
@c +-----------------+-----------------+-----------------+--------------+ 
@c @node Activating States, Start State Notes, Start States Explained, Start States
@node Activating States, Start State Notes, Start States Explained, Start States
@c __ @subsection Activating States
@subsection 状態の活性化
@comment    ##################

@c __ @findex @code{BEGIN}@r{, activating start states}
@findex @code{BEGIN}@r{、スタート状態の活性化}
@c __ @cindex Start states, activating
@cindex スタート状態、活性化
@c __ Having start state names by themselves is not very useful; we also have
@c __ to control when they're active.  This is done by using @code{BEGIN}
@c __ inside the actions or additional C code areas of the description.  The
@c __ way to use it is:
スタート状態の名前を並べただけではあまり役に立ちません。
つまり、
スタート状態がいつ活性化されるのかということも制御しなければなりません。
活性化は、
アクションの中、
または、
記述情報内の追加的なCコードを記述する領域の中において、
@code{BEGIN}を使うことで実現されます。
使い方は以下のとおりです。

@example
BEGIN(@var{start_state_name});
@end example

@noindent
@c __ and as an example:
例を挙げると、
以下のようになります。

@example
@group
%x COMMENT
%%
"@{"            BEGIN(COMMENT);
<COMMENT>"$R"  
<COMMENT>"$I"  
<COMMENT>"$M"  
    @dots{}  
<COMMENT>"@}"   BEGIN(INITIAL);
@end group
@end example

@noindent
@c __ which changes to the state @code{COMMENT} when it encounters the opening
@c __ part of a Pascal comment, and then recognizes compiler options.
@c __ @code{BEGIN} may also be used immediately following the first @samp{%%}
@c __ pair (before the first rule), in which case @code{yylex()} will always
@c __ start in the specified state.
この場合、
Pascalのコメントの先頭部分を見つけると@code{COMMENT}状態に移行し、
コンパイラ・オプションを認識するようになります。
@code{BEGIN}は最初の@samp{%%}の直後（最初のルールの前）において使うこともでき、
この場合は@code{yylex()}は常に指定された状態で開始されます。

@c __ Note that in the example above, there is a state @code{INITIAL} which
@c __ has not yet been defined.  This state is always available, and
@c __ represents the initial state of the scanner @emph{when there were no
@c __ states active}.  This means that @code{BEGIN(INITIAL)} effectively
@c __ resets the scanner (without losing the current scan position of course).
上の例においては、
定義されていない@code{INITIAL}という状態があることに注意してください。
この状態は常に利用可能で、
@emph{活性化された状態が１つも存在しない時}のスキャナの初期状態を表します。
つまり、
@code{BEGIN(INITIAL)}によって、
スキャナの状態が効果的に
（もちろん、
その時点においてスキャンしている箇所を維持したまま）
リセットされることを意味しています。

@c +--------------------------------------------------------------------+
@c |                                                                    |
@c | This node provides a few notes on illegal start state declarations |
@c | and on how you can set up sub scanners using exclusive start states|
@c |                                                                    |
@c +-----------------+-----------------+-----------------+--------------+ 
@c |       Name      |       Next      |     Previous    |       Up     |
@c +-----------------+-----------------+-----------------+--------------+ 
@c @node Start State Notes, Start State Example, Activating States, Start States
@node Start State Notes, Start State Notes (Flex 2.5), Activating States, Start States
@c __ @subsection Start State Notes
@subsection スタート状態に関する注
@comment    #################

@c __ Here are a some notes on the use of start states.
以下に、
スタート状態の使用に関する注をいくつか示します。

@itemize @bullet
@item 
@c __ @b{Special characters}
@b{特殊文字}

@c __ Only one start state, or comma-separated list of state states, may be
@c __ used per rule, and they must come at the beginning of the rule.  The
@c __ following are legal:
１つのルールにおいては、
単一のスタート状態、
または、
カンマで区切られたスタート状態のリストのみを使用することができます。
また、
こうしたスタート状態の指定はルールの先頭になければなりません。
次に示すものは正当です。

@example
@group
%x state1
%s state2
%%
<state1> "something"
<state2> "another thing"
<state, state2> "something else"
@end group
@end example

@noindent
@c __ but the following are not.  
しかし、
次に示すものは不当です。

@example
@group
%x state1
%s state2
%%
wrong<state1>
<state1><state2>"wrong"
<state2>"wrong"<state1>
@end group
@end example

@c __ @cindex Exclusive start states
@c __ @cindex Start states, exclusive
@cindex 排他的スタート状態
@cindex スタート状態、排他的
@item 
@c __ @b{Exclusive start states}
@b{排他的スタート状態}

@c __ Exclusive start states are powerful because they ``turn off'' all other
@c __ states, which means that you can effectively define a scanner within a
@c __ scanner.  This makes it theoretically possible, for example, to define a
@c __ scanner that would scan both C and Pascal dependent upon a start state.
@c __ Imagine the effect of some code like the following:
排他的スタート状態は、
他のすべての状態を「無効」にするので、
強力です。
これは、
スキャナの内部においてもう１つのスキャナを効果的に定義することができることを意味しています。
これにより例えば、
スタート状態次第で、
CとPascalの両方をスキャンするスキャナを定義することが、
理論的には可能になります。
以下のようなコードが持つ効果を想像してみてください。

@example
%x PASCAL
%x C
%%
<PASCAL>begin     return(OPEN_BLOCK);
<PASCAL>end       return(CLOSE_BLOCK);
<C>@{              return(OPEN_BLOCK);
<C>@}              return(CLOSE_BLOCK);
@end example

@item 
@c __ @b{Start state names}
@b{スタート状態の名前}

@c __ As stated earlier, start states do not have a name-space of their own.
@c __ The reason for this is that they are defined as integers in much the
@c __ same way as @code{#define}.  This means that as integers, it is possible
@c __ to create a kind of ``stack'' of start states.  For example:
前述のとおり、
スタート状態はそれ自身の名前空間を持っていません。
その理由は、
スタート状態が@code{#define}とほとんど同じ方法で整数値として定義されているからです。
このことは、
整数値と同様、
スタート状態の「スタック」のようなものを作成することが可能であることを意味しています。
例えば、

@example
@group
%@{
    int last_state[MAX_STATES]
    int state_count = 0;
%@}
%x FOO BAR baz
%%
FOO        @{
              last_state[state_count] = FOO;
              state_count++; 
              BEGIN(baz);
           @}
@end group
@group
BAR        @{
              last_state[state_count] = BAR;
              state_count++; 
              BEGIN(baz);
           @}
@end group
@group
<baz>@var{rule 1}
     @dots{}  
<baz>@var{rule n}
<baz>END   @{
              statecount--;
              BEGIN(last_state[statecount]);
           @} 
@end group
@end example

@noindent
@c __ which allows @code{FOO} and @code{BAR} to both activate state
@c __ @code{baz}, and for the rule @code{<baz>END} to switch to the previous
@c __ state.  These ``state stacks'' may become a feature of Flex in the
@c __ future.
は@code{FOO}と@code{BAR}の両方によって@code{baz}状態を活性化させ、
@code{<baz>END}というルールによって１つ前の状態に戻します。
@c Include Flex 2.5 information, for Flex manual as published by ASCII
@c @ifset INCLUDEFLEX25INFO
こうした「状態スタック」は将来、
Flexの特徴的な機能になるかもしれません。@footnote{訳注：Flex 2.5は、
スタート状態スタックをサポートしています。
次節（@ref{Start State Notes (Flex 2.5)}）を参照してください。}
@c @end ifset
@c @ifclear INCLUDEFLEX25INFO
@c こうした「状態スタック」は将来、
@c Flexの特徴的な機能になるかもしれません。
@c @end ifclear
@end itemize

@c Include Flex 2.5 information, for Flex manual as published by ASCII
@c @ifset INCLUDEFLEX25INFO
@node Start State Notes (Flex 2.5), Start State Example, Start State Notes, Start States
@subsection スタート状態に関する注（Flex 2.5の補足情報）
@include startstate_addendum-ja.texi
@c @end ifset

@c +--------------------------------------------------------------------+
@c |                                                                    |
@c |  Another example of using start states.                            |
@c |                                                                    |
@c +-----------------+-----------------+-----------------+--------------+ 
@c |       Name      |       Next      |     Previous    |       Up     |
@c +-----------------+-----------------+-----------------+--------------+ 
@c @node    Start State Example,  , Start State Notes, Start States
@node    Start State Example,  , Start State Notes (Flex 2.5), Start States
@c __ @subsection Example of Using Start States
@subsection スタート状態の使用例
@comment    ##############################
@c __ @cindex     Start states, using
@c __ @cindex     Examples, start states
@cindex     スタート状態、使用
@cindex     例、スタート状態

@c __ In programming, the best way to learn how to do something is to try
@c __ doing it.  With that in mind, here is an example of how start states can
@c __ be used.
プログラミングにおいて、
何かをする方法を学ぶのに最良の方法は、
実際にそれをやってみることです。
そのことに留意し、
スタート状態をどのように使うことができるかを示す実例を以下に挙げます。

@c +--------------------------------------------------------------------+
@c |                                                                    |
@c | We may be able to accomplish the same thing using lookahead, but I |
@c | think performance would be worse anyway.                           |
@c |                                                                    |
@c +--------------------------------------------------------------------+

@c __ @cindex Scanning dates
@c __ @cindex Dates, scanning
@cindex 日付のスキャン処理
@cindex 日付、スキャン処理
@example
@group
@c __ /*
@c __  * dates.lex: An example of using start states to
@c __  *            distinguish between different date formats.  
@c __  */
/*
 * dates.lex: 日付の異なる形式を識別するために
 *            スタート状態を使用する例
 */

%@{
#include <ctype.h>

char month[20],dow[20],day[20],year[20];

%@}

@end group
@group
@c __ skip of|the|[ \t,]* /* We ignore this text.      */
skip of|the|[ \t,]* /* この文字の並びを無視する */

@c __ mon  (mon(day)?)    /* We set this up so we can  */
@c __ tue  (tue(sday)?)   /* match both long and short */
@c __ wed  (wed(nesday)?) /* forms of a weekday name.  */
mon  (mon(day)?)    /* 曜日の名前の長い形式と短い形式の */
tue  (tue(sday)?)   /* どちらにもマッチするよう設定する */
wed  (wed(nesday)?)
thu  (thu(rsday)?)
fri  (fri(day)?)
sat  (sat(urday)?)
sun  (sun(day)?)

@end group
@group
@c __  /* The following represents all the possible weekdays. */ 
 /* 以下はすべての可能な曜日を表す */

day_of_the_week (@{mon@}|@{tue@}|@{wed@}|@{thu@}|@{fri@}|@{sat@}|@{sun@})

@c __ jan  (jan(uary)?)   /* Do the same thing for all */
@c __ feb  (feb(ruary)?)  /* the months of a year.     */
jan  (jan(uary)?)   /* すべての月について同様のことを行う */
feb  (feb(ruary)?)
mar  (mar(ch)?)
apr  (apr(il)?)
may  (may)
jun  (jun(e)?)
jul  (jul(y)?)
aug  (aug(ust)?)
sep  (sep(tember)?)
oct  (oct(ober)?)
nov  (nov(ember)?)
dec  (dec(ember)?)

@end group
@group
@c __  /* The following represents all possible month names. */
 /* 以下はすべての可能な月の名前を表す */

first_half  (@{jan@}|@{feb@}|@{mar@}|@{apr@}|@{may@}|@{jun@})
second_half (@{jul@}|@{aug@}|@{sep@}|@{oct@}|@{nov@}|@{dec@})
month       @{first_half@}|@{second_half@}

@end group
@group
@c __  /* 
@c __   * The numeric formats for days, months, and years.  
@c __   * Note that they overlap, so we need the start states and
@c __   * some knowledge of date formats to parse them properly.  
@c __   */
 /*
  * 日、月、年の数値形式
  * これらは重複しているため、正しくパースするには、
  * スタート状態と日付の形式に関するある程度の知識
  * が必要であることに注意
  */

nday         [1-9]|[1-2][0-9]|3[0-1] 
nmonth       [1-9]|1[0-2]
nyear        [0-9]@{1,4@}

@end group
@group
@c __  /* Extensions for years and days. */
 /* 年と日のための拡張子 */

year_ext    (ad|AD|bc|BC)?
day_ext     (st|nd|rd|th)?

@end group
@group
@c __  /*
@c __   * We use non-exclusive start states so that we can handle
@c __   * all extraneous text with the rule at the bottom of this
@c __   * program. If we did not do this, we would have to add
@c __   * rules to each start state block. This is often a viable
@c __   * option with large scanners, because adding rules does
@c __   * not affect the speed of the scanner. In this case,
@c __   * simplicity came first.
@c __   */
  /*
   * このプログラムの最後にあるルールを使ってすべての無関係な
   * テキストを処理するために、非排他的なスタート状態を使う。
   * こうしないと、個々のスタート状態のブロックにルールを追加
   * しなければならなくなる。規模の大きいスキャナにおいては、
   * これは実行可能な選択肢であることが多い。なぜなら、ルール
   * の追加はスキャナのスピードに影響を与えないからである。
   * ここでは、簡潔さを優先させることにする
   */

%s LONG SHORT
@c __ %s DAY MONTH   /* Additional states for LONG dates. */
%s DAY MONTH   /* 長い形式の日付のために追加した状態 */
%s YEAR_FIRST YEAR_LAST YFMONTH YLMONTH

@end group
@group
%%

@c __  /*
@c __   * The day of the week is assumed to always come first, 
@c __   * and to act as a qualifier for the date following it.  
@c __   * Thus, it can be shared between date formats.  
@c __   */ 
 /*
  * 曜日は常に最初に置かれ、後ろに続く日付の修飾子として
  * 機能するものと仮定される。よって、曜日は複数の日付形式
  * の間で共用可能である
  */

<LONG>@{day_of_the_week@} strcpy(dow,yytext); 

@end group
@group
@c __  /*
@c __   * Handle dates of the form: month-day-year 
@c __   * The parse state goes: LONG->[match month]->DAY->LONG
@c __   */
 /*
  * 月-日-年という形式の日付を処理する
  * パース状態は
  * LONG->[月にマッチ]->DAY->LONG
  * のように遷移する
  */

<LONG>@{month@}         strcpy(month,yytext); BEGIN(DAY);
<DAY>@{nday@}@{day_ext@}  strcpy(day,yytext);   BEGIN(LONG);  

@end group
@group
@c __  /* 
@c __   * Handle dates of the form: day-month-year 
@c __   * The parse state goes: LONG->[match day]->MONTH->LONG
@c __   */
 /*
  * 日-月-年という形式の日付を処理する
  * パース状態は
  * LONG->[日にマッチ]->MONTH->LONG
  * のように遷移する
  */

<LONG>@{nday@}@{day_ext@} strcpy(day,yytext);   BEGIN(MONTH);
<MONTH>@{month@}        strcpy(month,yytext); BEGIN(LONG);

@end group
@group
@c __  /* 
@c __   * The year part of a date is expected to come last, so if
@c __   * we encounter a year, we can display the parsed dates.  
@c __   * Of course, illegal dates will produce garbage.  
@c __   */  
 /*
  * 日付の年の部分は最後に置かれるものと考えられる。したがって、
  * 年を見つけたらパースされた日付を表示することができる。もち
  * ろん、日付として不当なものであればゴミが出力されることになる
  */

<LONG>@{nyear@}@{year_ext@} @{
                          printf("Long:\n");
                          printf("  DOW   : %s \n",dow);
                          printf("  Day   : %s \n",day);
                          printf("  Month : %s \n",month);
                          printf("  Year  : %s \n",yytext);
                          strcpy(dow,"");
                          strcpy(day,"");
                          strcpy(month,"");
                        @}

@end group
@group
@c __  /* 
@c __   * Handle dates of the form: day-month-year 
@c __   * If we match a numeric day from SHORT then we assume
@c __   * the year will be the last part of the date.  
@c __   * The parse state goes:
@c __   *   SHORT->[match day]->YEAR_LAST->YLMONTH->SHORT
@c __   */
 /*
  * 日-月-年という形式の日付を処理する
  * SHORT状態で数値形式の日を見つけた場合は、年が日付の最後の部分
  * になると仮定する
  * パース状態は
  * SHORT->[日にマッチ]->YEAR_LAST->YLMONTH->SHORT
  * のように遷移する
  */

<SHORT>@{nday@}        strcpy(day,yytext);  BEGIN(YEAR_LAST);
<YEAR_LAST>@{nmonth@}  strcpy(month,yytext);BEGIN(YLMONTH);
<YLMONTH>@{nyear@}     strcpy(year,yytext); BEGIN(SHORT);

@end group
@group
@c __  /* 
@c __   * Handle dates of the form: year-month-day 
@c __   * If we match a numeric year from SHORT then we assume 
@c __   * the day will be the last part of the date.  
@c __   * The parse state goes:
@c __   *   SHORT->[match year]->YEAR_FIRST->YFMONTH->SHORT
@c __   */
 /*
  * 年-月-日という形式の日付を処理する
  * SHORT状態で数値形式の年を見つけた場合は、日が日付の最後の部分
  * になると仮定する
  * パース状態は
  * SHORT->[年にマッチ]->YEAR_FIRST->YFMONTH->SHORT 
  * のように遷移する
  */

<SHORT>@{nyear@}        strcpy(year,yytext); BEGIN(YEAR_FIRST);
<YEAR_FIRST>@{nmonth@}  strcpy(month,yytext);BEGIN(YFMONTH);
<YFMONTH>@{nday@}       strcpy(day,yytext);  BEGIN(SHORT);

@end group
@group
@c __  /*
@c __   * For numeric dates, the year could come first, or last,
@c __   * so we use the newline to indicate when we should display
@c __   * what we have parsed.  
@c __   */
 /*
  * 数値形式の日付では、年は最初になることも最後になることも可能。
  * したがって、パースしたものをいつ表示すべきかを示すのに改行を使う
  */

<SHORT>\n               @{
                          printf("Short:\n");
                          printf("  Day   : %s \n",day);
                          printf("  Month : %s \n",month);
                          printf("  Year  : %s \n",year);
                          strcpy(year,""); 
                          strcpy(day,"");
                          strcpy(month,"");
                        @}

@end group
@group
@c __  /* 
@c __   * The following toggles between short (numeric)
@c __   * format, and long (alphanumeric) format 
@c __   */
 /*
  * 以下により、短い（数字）形式と長い（英数字）形式とを切り換える
  */

long\n     BEGIN(LONG);
short\n    BEGIN(SHORT);

@end group
@group
@c __  /* 
@c __   * The following rules catch, and discard any extraneous
@c __   * text (matched text is not ECHO'ed by default, but 
@c __   * unmatched text is. The period catches anything but 
@c __   * newlines which the \n catches.
@c __   */
 /*
  * 以下のルールは、無関係なテキストを見つけて破棄する
  * （マッチされたテキストはデフォルトではECHOされないが、
  *   マッチされなかったテキストはECHOされる。ピリオドは
  *   改行以外のすべての文字を見つける。改行は\nによって
  *   見つけられる）
  */

@{skip@}*
\n
.  
@end group
@end example

@noindent
@c __ This example scans, and break into units, various forms of dates.  For
@c __ example it can correctly scan the following, and distinguish each part
@c __ of the dates.  
この実例は、
様々な形式の日付をスキャンし、
構成単位に分割します。
例えば、
以下のものを正しくスキャンし、
日付の個々の部分を識別します。

@example
@group
short
1989:12:23
1989:11:12
@end group
23:12:1989
11:12:1989
1989/12/23
1989/11/12
23/12/1989
11/12/1989
1989-12-23
1989-11-12
23-12-1989
@group
11-12-1989
long
Friday the 5th of January, 1989
Friday, 5th of January, 1989
@end group
Friday, January 5th, 1989
Fri, January 5th, 1989
Fri, Jan 5th, 1989
Fri, Jan 5, 1989
@group
FriJan 5, 1989
FriJan5, 1989
FriJan51989
Jan51989
@end group
@end example

@noindent
@c __ The first part of the file simply defines the months, and the numeric
@c __ formats used for different parts of a date.  In the example, we use
@c __ start states to force the scan to proceed in a certain manner.  For
@c __ example, if we see @samp{1989} at the beginning of a line, we know that
@c __ it must be a year, rather than a day-month combination, so we know that
@c __ the next part of the date should be a month, and force the scan to go
@c __ accordingly.  This allows us to cleanly break dates up into the various
@c __ pieces, because we are effectively creating a very simple, state-driven
@c __ parser (you can see this clearly if you draw a flow chart of what is
@c __ happening in this scanner).
ファイルの最初の部分では、
月、および、日付の異なる部分に使われる数字形式を単に定義しています。
この実例では、
ある特定の方法でスキャン処理が進行するよう強制するために、
スタート状態を使います。
例えば、
行の先頭で@samp{1989}を見つければ、
それが日と月の組み合わせではなく年であり、
したがって、
日付の次の部分が月に違いないことが分り、
スキャン処理がそのとおりに進むよう強制します。
このことにより、
非常に単純な状態駆動のパーサを効果的に作成したことになり、
日付をその構成要素にうまく分割することができるようになります
（このスキャナの内部で起こっていることをフロー・チャートに描いてみれば、
このことが明瞭に見てとれるでしょう）。

@c __ As with other examples in this manual, you may either compile it
@c __ manually by typing:
このマニュアル中の他の実例と同様に、
この実例も

@example
@group
flex -i dates.lex
cc -o dates lex.yy.c -lfl
@end group
@end example

@noindent
@c __ or by simply typing @samp{make dates} in the @file{examples}
@c __ sub-directory.
を実行することによりコンパイルすることができます。
また、
@file{examples}サブディレクトリにおいて単に@samp{make dates}を実行することにより、
コンパイルすることもできます。

@c Include Flex 2.5 information, for Flex manual as published by ASCII
@c @ifset INCLUDEFLEX25INFO
@node %option (Flex 2.5),  , Start States, Flex Descriptions
@section %option（Flex 2.5の補足情報）
@include option_addendum-ja.texi
@c @end ifset

@c +--------------------------------------------------------------------+
@c |                                                                    |
@c | This explains how we connect things to the Flex output.            |
@c |                                                                    |
@c +-----------------+-----------------+-----------------+--------------+ 
@c |       Name      |       Next      |     Previous    |       Up     |
@c +-----------------+-----------------+-----------------+--------------+ 
@c @node    Interfacing to Flex, Other Flex Features, Flex Descriptions, Top
@node    Interfacing to Flex, Other Flex Features, Flex Descriptions, Top
@c __ @chapter Interfacing to Flex
@chapter Flexとのインターフェイス
@comment ###################

@quotation
@c __ @i{This chapter will tell you how to use Flex with C and Bison.  As each
@c __ of these entails quite a lot of detail, it has been broken up into two
@c __ parts, each of which contains a section on the general interface
@c __ concepts, and a section with an example.}
@c @ifset INCLUDEFLEX25INFO
@i{この章ではCおよびBisonと一緒にFlexを使う方法を説明します。}@footnote{訳注：この章の最後で、
C++の使い方についても説明します。}@i{C、Bisonのそれぞれが非常に多くの細目を含むため、
本章は２つの部分に分割されています。
その両方に、
全般的なインターフェイス概念に関する節と実例を示す節があります。}
@c @end ifset
@c @ifclear INCLUDEFLEX25INFO
@c @i{この章ではCおよびBisonと一緒にFlexを使う方法を説明します。
@c C、Bisonのそれぞれが非常に多くの細目を含むため、
@c 本章は２つの部分に分割されています。
@c その両方に、
@c 全般的なインターフェイス概念に関する節と実例を示す節があります。}
@c @end ifclear
@end quotation

@ifnottex
========================================================================
@c __ @menu
@c __ * Flex and C::                  The interface between C and Flex.
@c __ * An Example of Flex and C::    String substitution in a filter.  
@c __ * Flex and Bison::              How Flex and Bison fit together.  
@c __ * Another Example of Flex and Bison::  Another example of Flex and Bison.
@c __ @end menu
@menu
* Flex and C::                  CとFlexのインターフェイス
@c @ifset INCLUDEFLEX25INFO
* Flex and C (Flex 2.5)::       同上（Flex 2.5の補足情報）
@c @end ifset
* An Example of Flex and C::    フィルタにおける文字列代替
* Flex and Bison::              FlexとBisonの協同
* Another Example of Flex and Bison::  FlexとBisonのもう１つの実例
@c @ifset INCLUDEFLEX25INFO
* Flex and C++ (Flex 2.5)::     C++とFlexのインターフェイス
                                （Flex 2.5の補足情報）
@c @end ifset
@end menu
========================================================================
@end ifnottex

@c +--------------------------------------------------------------------+
@c |                                                                    |
@c | This node takes care of explaining the C interface for Flex        |
@c |                                                                    |
@c +-----------------+-----------------+-----------------+--------------+ 
@c |       Name      |       Next      |     Previous    |       Up     |
@c +-----------------+-----------------+-----------------+--------------+ 
@c @node    Flex and C, An Example of Flex and C, Interfacing to Flex, Interfacing to Flex
@node    Flex and C, Flex and C (Flex 2.5), Interfacing to Flex, Interfacing to Flex
@c __ @section Flex and C
@section FlexとC
@c __ @cindex  C interface to lex
@c __ @cindex  Flex functions and variables
@c __ @cindex  Interfacing C and Flex
@cindex  lexに対するCのインターフェイス
@cindex  Flex関数とFlex変数
@cindex  CとFlexのインターフェイス

@c __ The main C interface to Flex is through the following routines and
@c __ variables.  Be aware that Flex and Lex differ in some details in the
@c __ following section.  Some functions do not appear in Lex, or the
@c __ declarations are different.  Generally this does not present a great
@c __ problem as many of the functions which differ are not commonly used.
@c __ Refer to @ref{Flex and Lex}, 
@c __ and @ref{Flex and POSIX}, 
@c __ for details on the differences.
Flexに対するCの主要なインターフェイスは、
以下に挙げるルーチンと変数によるものです。
以下の節を読む際には、
いくつかの細かな部分でFlexとLexとの間に相違点があるということを意識しておいてください。
Lexが提供していない関数がいくつかありますし、
宣言の内容が違うものもあります。
こうした相違点は、
通常大きな問題にはなりません。
というのは、
相違のある関数は一般的にはあまり使われていないからです。
相違点に関する詳細については、
@ref{Flex and Lex}および@ref{Flex and POSIX}を参照してください。

@itemize
@table @code
@c __ @item @b{Function}
@item @b{関数}
@c __ @b{Explanation and examples}
@b{説明と実例}

@c __ @findex @code{yylex()}@r{, in detail}
@findex @code{yylex()}@r{、詳細}
@item yylex()
@c __ @code{yylex()} is the function that performs the actual scanning.  It
@c __ reads a file (default is @code{stdin}), matches patterns, and executes
@c __ any actions associated with the pattern.  By default it continues to
@c __ match until it encounters the end of the input, at which point it
@c __ returns zero.  (It is possible to return other values to the calling
@c __ programs using @code{return}---this is covered in @ref{Flex and Bison}.)
@c __ Thus, a simple way to provide an interface is to add code like the
@c __ following in one of the optional C code areas:
@code{yylex()}は実際のスキャン処理を行う関数です。
ファイル（デフォルトは@code{stdin}）を読み込み、
パターン・マッチングを行い、
パターンに関連付けされたアクションを実行します。
デフォルトでは、
入力の終端に達するまでマッチングを行い、
終端に達したところでゼロを返します。
（@code{return}を使って、
呼び出し側のプログラムにほかの値を返すことは可能です。
これは、
@ref{Flex and Bison}で説明しています。）
したがって、
インターフェイスを提供する簡単な方法の１つは、
オプションのCコード領域の１つに以下のようなコードを追加することです。

@example
@group
#include <stdio.h>

int main(argc,argv)
int argc;
char *argv;
@{
   yylex();
@}
@end group
@end example

@noindent
@c __ Though in this case, you can link to either the Flex library
@c __ (@samp{-lfl}) or the Lex library (@samp{-ll}), and get such a
@c __ @code{main()} from there. Note that in this case, the scanner simply
@c __ scans the file and takes any actions associated with the rules.
しかしこのような場合には、
Flexライブラリ（@samp{-lfl}）もしくはLexライブラリ（@samp{-ll}）のいずれかをリンクして、
そこからこれと同じような@code{main()}関数を取り込むことができます。
この場合は、
スキャナは単にファイルをスキャンして、
ルールに関連付けされたアクションを実行するだけであるという点に注意してください。

@c __ Another very common way to use @code{yylex()} is to have it return values
@c __ indicating what was matched. This is done by adding @code{return}
@c __ statements to the actions. When a @code{return} statement is encountered,
@c __ @code{yylex()} returns with the value specified. This is how Bison
@c __ parsers get information from Flex scanners.
@code{yylex()}の使い方としてもう１つよく見られるのが、
マッチされたものが何であるかを示す値を返させることです。
これは、
アクションに@code{return}文を追加することで行われます。
@code{return}文を見つけると、
@code{yylex()}は指定された値を返します。
これが、
BisonによるパーサがFlexによるスキャナから情報を獲得する方法です。

@c __ If your rules contain @code{return} statements to return a code indicating
@c __ what the matched text represents, the following interface can be used:
ルールの中に、
マッチされたテキストが何を表しているかを示すコードを返す@code{return}文があれば、
以下のようなインターフェイスを使うことができます。

@example
@group
#include <stdio.h>

int main(argc,argv)
int argc;
char *argv;
@{
   int return_code;
@end group
@group
   while((return_code = yylex()) != 0)@{
       switch(return_code)@{
       case KEYWORD1:
@c __           /* do something */
          /* 何かを行う */
          break;
@end group
@group
       case KEYWORD2:
@c __           /* do something else */
          /* 何か別のことを行う */
          break;
            @dots{}
       case KEYWORD@var{n}:
       @}
   @}
@}
@end group
@end example

@c __ @cindex Redefining @code{yylex()}
@c __ @cindex @code{yylex()}, redefining
@cindex @code{yylex()}の再定義
@cindex @code{yylex()}、再定義
@c __ @findex @code{YY_DECL}@r{, in detail}
@findex @code{YY_DECL}@r{、詳細}
@c __ The default definition for @code{yylex} is @samp{int yylex(void)}, but
@c __ this may be changed using the @code{YY_DECL} macro.  As an example, the
@c __ following code changes the name of @code{yylex()} to @code{gettok()},
@c __ changes the type to a character pointer, and tells it to accept the
@c __ parameter @code{buffer}:
@code{yylex}のデフォルトの定義は@samp{int yylex(void)}ですが、
これは@code{YY_DECL}マクロを使うことによって変更することができます。
例を示すと、
以下のコードは@code{yylex()}の名前を@code{gettok()}に、
型をcharに対するポインタ型に変更し、
パラメータ@code{buffer}を受け取るように指定します。

@example
@group
#undef   YY_DECL
#define  YY_DECL char *gettok(char *buffer)
@end group
@end example

@c __ @strong{Please note:} @i{If you use non-ANSI C you must declare it as:}
@strong{注：}@i{ANSI対応でないCを使っている場合は以下のように定義しなければなりません。}
@example 
@group
#define YY_DECL char *gettok(buffer) \
                      char *buffer;
@end group
@end example
@noindent
@c __ @i{or in other words, the redeclaration must be a legal function
@c __ declaration for the targeted C compiler.  Also note that these
@c __ redeclarations must appear in the optional C code area at the
@c __ @strong{top} of the file.  }
@i{言葉を変えると、
再宣言はターゲットとなるCコンパイラにとって正当な関数宣言でなければなりません。
さらに、
この再宣言は、
ファイルの@strong{先頭}にあるオプションのCコード領域になければならないという点に注意してください。}

@vindex @code{yyin}
@item yyin
@c __ @code{yyin} is the file from which @code{yylex()} reads characters.  The
@c __ default is @code{stdin}, but may be changed using @code{fopen()}.  The
@c __ default method for reading @code{yyin} is to read blocks of characters
@c __ at a time.  This may be overridden with the @code{YY_INPUT} macro, whihc
@c __ can be useful for creating a scanner for scanning from strings, rather
@c __ than a file.  The way to define @code{YY_INPUT} is:
@code{yyin}は、
@code{yylex()}が文字を読み込む元となるファイルです。
デフォルトは@code{stdin}ですが、
@code{fopen()}を使って変更することができます。
@code{yyin}を読み込むデフォルトの方法は、
複数文字から成るブロックを一度に読むというものです。
これは、
@code{YY_INPUT}マクロによって変更できます。
@code{YY_INPUT}マクロは、
ファイルではなく文字列をスキャンするためのスキャナを生成するのに便利です。
@code{YY_INPUT}を定義する方法は以下のとおりです。

@c __ @cindex Redefining @code{YY_INPUT}
@c __ @cindex @code{YY_INPUT}, redefining
@cindex @code{YY_INPUT}の再定義
@cindex @code{YY_INPUT}、再定義
@example
YY_INPUT(buffer,result,max_size)
@end example

@c __ Where @code{buffer} is the input buffer, @code{result} is a variable
@c __ to be set to the number of characters read, and @code{max_size} is
@c __ the size of @code{buffer}. Here is an example redefinition which changes
@c __ the input scheme to read one character at a time.  This is @emph{much}
@c __ slower, so it is not recommended.
ここで、
@code{buffer}は入力バッファ、
@code{result}は読み込まれた文字数がセットされる変数、
@code{max_size}は@code{buffer}のサイズです。
以下に、
一度に１文字ずつ読み込むという入力方法に変更する再定義の例を示します。
この方法を使うと@emph{かなり}遅くなるので、
お勧めはできません。

@example
@group
#undef   YY_INPUT
#define  YY_INPUT(buffer,result,max_size) \
         @{\
            buffer[0] = getchar();\
            if(buffer[0] == EOF)\
               result = YY_NULL;\
            else\
               result = 1;\
         @}
@end group
@end example

@c __ @strong{Please note:} @i{These redeclarations must appear in the
@c __ optional C code area at the @strong{top} of the file.  }
@strong{注：}@i{この再宣言は、
ファイルの@strong{先頭}にあるオプションのCコード領域になければなりません。}

@c __ @cindex Standard output
@cindex 標準出力
@vindex @code{yyout}
@item yyout
@c __ @code{yyout} is the file that the scanner writes @code{ECHO} output to.
@c __ The default is @code{stdout}, but this may also be changed by calling
@c __ @code{fopen()}.
@code{yyout}はスキャナが@code{ECHO}の出力を書き込むファイルです。
デフォルトは@code{stdout}ですが、
これも@code{fopen()}を呼び出すことで変更できます。

@c __ @cindex Text scanned
@c __ @cindex Accessing the text scanned
@cindex スキャンされたテキスト
@cindex スキャンされたテキストへのアクセス
@c __ @vindex @code{yytext}@r{, in detail}
@vindex @code{yytext}@r{、詳細}
@item yytext
@c __ @code{yytext} is a global variable that contains the string of
@c __ characters last matched; that is, the last recognized token.  Note that
@c __ the correct external definition of @code{yytext} is as a character
@c __ pointer, @emph{not} a character array as with Lex.  That is, you should
@c __ always declare it as:
@code{yytext}は最後にマッチされた文字列、
つまり最後に認識されたトークンを含む大域変数です。
@c @ifset INCLUDEFLEX25INFO
@code{yytext}の正しい外部定義は、
Lexの場合のcharの配列とは@emph{異なり}、
charに対するポインタ型である点に注意してください。@footnote{訳注：Flex 2.5では、
@samp{%pointer}と@samp{%array}により、
@code{yytext}の型を選択できるようになりました。
@samp{%pointer}を指定した場合は@code{char *yytext}、
@samp{%array}を指定した場合は@code{char yytext[YYLMAX]}となります。
デフォルトは@samp{%pointer}です。
@samp{%array}を指定した場合の配列のサイズは、
@code{YYLMAX}を再定義することによって変更可能です。}
@c @end ifset
@c @ifclear INCLUDEFLEX25INFO
@c @code{yytext}の正しい外部定義は、
@c Lexの場合のcharの配列とは@emph{異なり}、
@c charに対するポインタ型である点に注意してください。
@c @end ifclear
つまり、
@code{yytext}は

@c 日本語訳では、２つの例の順番を逆転させている。
@c __ @example
@c __ extern char *yytext;
@c __ @end example
@c __ 
@c __ @noindent
@c __ rather than
@c __ 
@c __ @example
@c __ extern char yytext[];
@c __ @end example

@example
extern char yytext[];
@end example

ではなく、常に

@example
extern char *yytext;
@end example

のように宣言されなければならないということです。
@noindent

@noindent
@c __ The reason for this is based on performance; if @code{yytext} were an
@c __ array, the code that manipulates it in the scanner would need to do a
@c __ lot of copying, whereas with the pointer version, this is not necessary.
このようになっている理由は性能です。
@code{yytext}が配列であると、
スキャナ中でそれを操作するコードは、
コピー処理をたくさん行う必要があります。
これに対して@code{yytext}がポインタである場合には、
このようなことは必要ありません。

@c __ Generally @code{yytext} should not changed.  In cases where the contents
@c __ of @code{yytext} need to be changed, a buffer should be used instead.
@c __ (In the file @code{yymore2.lex} in the @file{examples} sub-directory,
@c __ @code{yytext} is manipulated directly, and demonstrates the technique.
@c __ This practice is @emph{not} recommended though.)
通常は、
@code{yytext}は変更すべきではありません。
@code{yytext}の内容が変更される必要がある場合には、
代わりのバッファが使われるべきです。
（@file{examples}サブディレクトリの@code{yymore2.lex}ファイルでは、
@code{yytext}を直接操作する技法が実演されています。
ただし、
このようなやり方は@emph{お勧めできません}。）

@c __ @cindex Text length 
@c __ @cindex Accessing @code{yytext}'s length
@cindex テキスト長
@cindex @code{yytext}の長さへのアクセス
@vindex @code{yyleng}
@item yyleng
@c __ @code{yyleng} is a global variable containing the length of the last
@c __ recognized token.
@code{yyleng}は、
最後に認識されたトークンの長さを保持する大域変数です。

@c __ @findex @code{yywrap()}@r{, in detail}
@findex @code{yywrap()}@r{、詳細}
@c __ @cindex @code{yywrap()} and @code{EOF}
@cindex @code{yywrap()}と@code{EOF}
@item yywrap()
@c __ @code{yywrap} is a function that is called when the end of @code{yyin}
@c __ has been reached.  If it returns @code{TRUE} (non-zero) then the scanner
@c __ terminates, but if it returns @code{FALSE} (zero), it is assumed that
@c __ @code{yyin} has been set to point to the next input file, and scanning
@c __ continues.
@code{yywrap}は、
@code{yyin}の終端に達した時に呼び出される関数です。
この関数が@code{TRUE}（ゼロ以外）を返すとスキャナは終了し、
@code{FALSE}（ゼロ）を返すと、
@code{yyin}が次の入力ファイルを指すように設定されたものと仮定して、
スキャン処理が続行されます。

@c __ At present @code{yywrap()} is a macro that is defined to always return
@c __ 1, so if you redefine it, you must first @code{#undef} it.  In Lex,
@c __ @code{yywrap()} is a true function; Flex will define it as a function at
@c __ some time in the future.
現在のところ@code{yywrap()}は、
常に１を返すよう定義されているマクロです。
このため、
再定義するには、
まず最初に@code{#undef}で定義解除しなければなりません。
Lexでは、
@code{yywrap()}は関数です。
@c @ifset INCLUDEFLEX25INFO
Flexも将来のある時点で、
これを関数として定義することになるでしょう。@footnote{訳注：Flex 2.5では、
@samp{%option noyywrap}が指定されない限り、
@code{yywrap()}は関数です。
再定義をするのに、
@code{#undef}で定義解除する必要はありません。}
@c @end ifset
@c @ifclear INCLUDEFLEX25INFO
@c Flexも将来のある時点で、
@c これを関数として定義することになるでしょう。
@c @end ifclear

@c __ @findex @code{yymore()}@r{, in detail}
@findex @code{yymore()}@r{、詳細}
@c __ @cindex Appending text
@cindex テキストの末尾への追加
@item yymore()
@c __ @code{yymore()} is a function that tells Flex to append the next token
@c __ recognized to @code{yytext}, rather than overwriting it.  So if we feed
@c __ @samp{foobar} to the following example, it will write @samp{foofoobar}
@c __ to @code{stdout}.
@code{yymore()} は、
次に認識されるトークンで@code{yytext}の内容を更新するのではなく、
その時点の@code{yytext}の内容の後ろにそのトークンを追加するようFlexに通知する関数です。
したがって、
以下の例に対して@samp{foobar}という文字の並びを入力として与えると、
@code{stdout}に@samp{foofoobar}という文字の並びが書き込まれます。

@example
@group
%%
foo    ECHO; yymore(); 
bar    ECHO;
@end group
@end example

@c __ This is because @samp{foo} is recognized in the @code{foo} rule, and is
@c __ @code{ECHO}ed, then @samp{bar} is recognized, appended to @code{yytext},
@c __ and then @samp{foobar} is @code{ECHO}ed.
これは、
まず@code{foo}ルールによって@samp{foo}という文字の並びが認識されて@code{ECHO}され、
次に@samp{bar}という文字の並びが認識されて@code{yytext}の内容の後ろに追加された後に、
@samp{foobar}という文字の並びが@code{ECHO}されるからです。

@c __ As a slightly more realistic example, the following code uses
@c __ @code{yymore()} to handle multi-line strings.
もう少し現実的な例を取り上げましょう。
以下のコードは複数行の文字列を処理するのに@code{yymore()}を使っています。

@example
@group
@c __ /*
@c __  * yymore.lex: An example of using yymore()
@c __  *             to good effect.  
@c __  */
/*
 *  yymore.lex: yymore()を有効に使う例
 */

%@{
#include <memory.h>
@end group
@group
void yyerror(char *message)
@{
  printf("Error: %s\n",message);
@}

%@}

@end group
@group
%x STRING

%%
\"   BEGIN(STRING);

<STRING>[^\\\n"]* yymore();
<STRING><<EOF>> @{
              yyerror("EOF in string.");       
              BEGIN(INITIAL);
            @}
@end group
@group
<STRING>\n  @{
              yyerror("Unterminated string."); 
              BEGIN(INITIAL);
            @}
@c __ <STRING>\\\n yymore(); /* handle multi-line 
@c __                         * strings 
@c __                         */
<STRING>\\\n yymore(); /* 複数行にわたる
                        * 文字列を処理する
                        */
@end group
@group
<STRING>\"  @{
              yytext[yyleng-1] = '\0';
              printf("string = \"%s\"",yytext); 
              BEGIN(INITIAL);
            @}
%%
@end group
@end example

@noindent
@c __ Note that in this example, no escape sequences are transformed, so the
@c __ string will need additional processing.  
@c __ In @ref{Handling Strings, , Handling String Literals}, 
@c __ this example is expanded into a more useful form that handles escape
@c __ sequences.
この例では、
エスケープ・シーケンスの変換がまったく行われていないので、
文字列に対してさらに処理が必要である点に注意してください。
この例は、
@ref{Handling Strings, , 文字列リテラルの処理}において、
エスエープ・シーケンスを処理する、
より役に立つ形式に拡張されます。
@c __ @cindex Recursion
@cindex 再帰

@c __ @findex @code{yyless()}@r{, in detail}
@findex @code{yyless()}@r{、詳細}
@c __ @cindex Returning text 
@cindex テキストの返却
@item yyless(@var{n})
@c __ @code{yyless()} is almost the opposite of @code{yymore()}.  This
@c __ function returns everything except the first @var{n} characters.  The
@c __ returned characters will be used in matching the next token, and
@c __ @code{yyleng} and @code{yytext} will reflect the change.  If you call
@c __ @code{yyless()} with @var{n} = 0, then the entire input will be
@c __ returned, and the scanner will go into an infinite loop (unless you
@c __ changed the default behavior with @code{BEGIN} or something like that).
@c __ For example, if we feed the following code the string @samp{foobar}, it
@c __ will print @samp{foobarbar}.
@code{yyless()}は、
@code{yymore()}とほぼ反対のことを行うものです。
この関数は、
最初の@var{n}文字以外のすべてを戻します。
戻された文字の並びは、
次のトークンをマッチするのに使われ、
@code{yyleng}と@code{yytext}には、
この変化を反映した値が設定されます。
引数@var{n}にゼロを指定して@code{yyless()}を呼び出すと、
全入力データが戻され、
スキャナは
（@code{BEGIN}、
またはそれに類似のものでデフォルトの動作が変更されない限り）
無限ループに入ります。
例えば、
次のコードに@samp{foobar}という文字の並びを入力として与えると、
@samp{foobarbar}という文字の並びが出力されます。

@example
@group
%%
foobar      ECHO; yyless(3);
[a-z]+      ECHO;
@end group
@end example

@c __ This is because @samp{foobar} is recognized and @code{ECHO}'ed, then
@c __ @samp{bar} is ``put back''.  The next match is then @samp{bar} only
@c __ (matched with the rule @samp{[a-z]+}), which is then @code{ECHO}'ed.
これは、
@samp{foobar}が認識され@code{ECHO}された後に、
@samp{bar}が戻されるからです。
となると、
次にマッチするのは
（@samp{[a-z]+}というルールでマッチされる）
@samp{bar}だけで、
これが次に@code{ECHO}されることになります。

@c __ @findex @code{input()}@r{, in detail}
@findex @code{input()}@r{、詳細}
@c __ @cindex Accessing the input stream
@cindex 入力ストリームへのアクセス
@item input()
@c __ @code{input()} is a function that returns the next character from
@c __ @code{yyin}.  This is commonly used for processing certain cases that
@c __ cannot be handled cleanly using the standard Flex rule system.  For
@c __ example, comments in most languages can be processed using this.  This
@c __ is because:
@code{input()}は、
@code{yyin}から次の文字を取って返す関数です。
これは、
標準的なFlexルール・システムを使ったのではうまく扱えないケースを処理するのによく使われます。
例えば、
ほとんどの言語におけるコメントは、
これを使って処理することができます。
これを使う理由は、

@example
@group
%%
"/*".*"*/"
@end group
@end example

@noindent 
@c __ will fail if comments span a line because the period matches any
@c __ character @emph{except} a new line character, and
が、
ピリオドが改行@emph{以外}の任意の文字にマッチしてしまうために
複数行にわたるコメントをうまく処理できず、
また、

@example
@group
%%
"/*"[.\n]*"*/"
@end group
@end example

@noindent 
@c __ will either overflow the buffer, or eat all the file because the
@c __ character class matches @emph{any} character.  (Actually it is possible
@c __ to handle things like this in a very elegant manner using exclusive
@c __ start states (Refer to @ref{Useful Code, , Snippets of Useful Code}, 
@c __ for an example.)
@c __ However, this is not portable since Lex does not have the POSIX supported 
@c __ features needed.)  C comments can be handled portably like this:
は、
文字クラスが@emph{任意}の文字にマッチしてしまうために、
バッファをオーバーフローさせるか、
さもなくばファイルの内容をすべて読み込んでしまうからです。
（実際には、
排他的スタート状態を使うことで、
こうしたことを非常にエレガントな方法で処理することができます。
実例については、
@ref{Useful Code, , 役に立つコードの抜粋}を参照してください。
しかし、
POSIXによりサポートされているにもかかわらず、
ここで必要になるいくつかの機能をLexが提供していないために、
この方法には移植性がありません。）
Cのコメントは以下のようにして移植性のある方法で処理することができます。

@example
@group
%%
"/*" @{
        int a,b;
        
        a = input();
        while(a != EOF)@{
          b = input();
          if(a == '*' && b == '/')@{
            break;
@end group
@group
           @}else@{
            a = b;
           @}
         @}
        if(a == EOF)@{
          error_message("EOF in comment");
        @}
      @}
@end group
@end example

@c __ @strong{Please note:} @i{If the scanner is compiled using a C++ compiler
@c __ this function will be named @code{yyinput} because @code{input}
@c __ conflicts with the C++ stream of the same name.  Also, in Flex,
@c __ @code{input()} destroys @code{yytext}, whereas in Lex, @code{yytext}
@c __ remains unchanged.  This will be fixed in a future release.  } 
@strong{注：}@i{スキャナがC++コンパイラを使ってコンパイルされる場合は、
この関数@code{input}は@code{yyinput}という名前になります。
これは、
@code{input}という名前が同一名のC++ストリームと衝突するからです。
また、
Flexでは@code{input()}は@code{yytext}の内容を破壊しますが、
Lexでは@code{yytext}は変更されずそのまま残ります。
これは将来のリリースで修正される予定です。}

@c __ @findex @code{unput()}@r{, in detail}
@findex @code{unput()}@r{、詳細}
@c __ @cindex Adding text to the input stream
@cindex 入力ストリームへのテキストの追加
@item unput(c)
@c __ @code{unput()} is a function that places the character @code{c} into the
@c __ input stream in such a way that it will become the next character
@c __ scanned.  For example:
@code{unput()}は、
文字@code{c}が次にスキャンされる文字になるように、
文字@code{c}を入力ストリームに置く関数です。
例えば、

@example
@group
%%
foo  unput('b'); 
@end group
@end example

@noindent
@c __ replaces @samp{foo} with @samp{b}, because it matches on @samp{foo}, and
@c __ puts back @samp{b}, which will be the next scanned character.  By the
@c __ default rule, @samp{b} will be written to @code{stdout}.
は@samp{foo}を@samp{b}で置き換えます。
これは、
@samp{foo}にマッチして@samp{b}を戻し、
この@samp{b}が次にスキャンされる文字になるからです。
デフォルトのルールにより、
@samp{b}は@code{stdout}に書き込まれます。

@c __ One subtle point about the character becoming the next character scanned
@c __ is that if you wish to place a string into the input stream, it must be
@c __ done in reverse order.  Here is an example:
１つの文字が次にスキャンされる文字になるということには１つ微妙な点があって、
それは、
文字列を入力ストリームに置きたい場合には、
逆順に行わなければならないということです。
以下に例を示します。

@example
@group
foobar  @{
           char  *baz = "baz";
           int   i    = strlen(baz)-1;

           while(i >= 0)@{
              unput(baz[i]);
              i--;
           @}
        @}
@end group
@end example

@noindent
@c __ which will place @samp{baz} into the input stream when @samp{foobar} is
@c __ matched.  As an example of what @emph{not} to do:
これは、
@samp{foobar}がマッチされた時に、
入力ストリームに@samp{baz}を置きます。
以下は、
@emph{してはならない}ことを示す例です。

@example
@group
@c __ /*
@c __  * unput.l : An example of what *not*
@c __  *           to do with unput().  
@c __  */
/*
 * unput.l : unput()を使って行ってはならない
 *           処理の例
 */

%@{
#include <stdio.h>

void putback_yytext(void);
%@}

@end group
@group
%%
foobar   putback_yytext();
raboof   putback_yytext();
%%

@end group
@group
void putback_yytext(void)
@{
    int   i;
    int   l = strlen(yytext);
    char  buffer[YY_BUF_SIZE];

    strcpy(buffer,yytext);
    printf("Got: %s\n",yytext);
    for(i=0; i<l; i++)@{
       unput(buffer[i]);
    @}
@}
@end group
@end example

@noindent
@c __ If you give @samp{foobar} as input to this example, it will go into an
@c __ infinite loop, first matching @samp{foobar}, then @samp{raboof}.
この例に@samp{foobar}を入力として与えると、
まず@samp{foobar}にマッチし、
次に@samp{raboof}にマッチする無限ループに陥ります。

@c __ @strong{Please note:} @i{@code{unput()}, like @code{input()}, destroys
@c __ the contents of @code{yytext}.  This means that if you wish to return
@c __ characters from @code{yytext}, you must first copy the contents, as
@c __ shown in the above example.  }
@c @ifset INCLUDEFLEX25INFO
@strong{注：}@i{@code{input()}と同様に@code{unput()}も@code{yytext}の内容を破壊します。}@footnote{訳注：Flex 2.5では、
@samp{%array}が指定された場合は、
@code{unput()}は@code{yytext}の内容を破壊しません。}@i{つまり、
@code{yytext}から文字情報を返したい場合には、
上の例に示されるように、
まず@code{yytext}の内容をコピーしなければならないことを意味しています。}
@c @end ifset
@c @ifclear INCLUDEFLEX25INFO
@c @strong{注：}@i{@code{input()}と同様に@code{unput()}も@code{yytext}の内容を破壊します。
@c つまり、
@c @code{yytext}から文字情報を返したい場合には、
@c 上の例に示されるように、
@c まず@code{yytext}の内容をコピーしなければならないことを意味しています。}
@c @end ifclear

@c __ @findex @code{yyterminate()}@r{, in detail}
@c __ @findex @code{yylex()}@r{, and} @code{yyterminate()}  
@findex @code{yyterminate()}@r{、詳細}
@findex @code{yylex()}@r{と}@code{yyterminate()}  
@item yyterminate()
@c __ When it is called in an action, @code{yyterminate()} terminates the scanner
@c __ and then @code{yylex()} returns 0.  After this, calls to @code{yylex()}
@c __ will immediately return, unless @code{yyrestart()} has been called
@c __ (see below).
アクションの中で呼び出されると、
@code{yyterminate()}はスキャナの実行を終了させ、
その後に@code{yylex()}が0を返します。
この後は、
@code{yyrestart()}（下記参照）が呼び出されない限り、
@code{yylex()}を呼び出してもすぐに復帰してしまいます。

@c __ @findex @code{yyrestart()}@r{, in detail}
@findex @code{yyrestart()}@r{、詳細}
@c __ @cindex Scanner reentrancy, @code{yyrestart()}
@cindex スキャナの再入可能性、@code{yyrestart()}
@item yyrestart(@var{file})
@c __ @code{yyrestart()} is a function that tells Flex to restart the scanner. 
@c __ It takes a single argument: a file to scan on (usually @code{yyin}). 
@c __ This can be used to handle EOF's, and can also be used to allow Flex to
@c __ be interrupted, and then restarted. (This is necessary because Flex
@c __ scanners are @emph{not} reentrant).
@code{yyrestart()}は、
スキャナの実行を再開するようFlexに通知する関数です。
これは引数を１つだけ、
すなわち、
スキャンの対象となるファイル（通常は@code{yyin}）を取ります。
これは、
EOFを処理するために使うこともできますし、
また、
Flexに割り込みをかけ、
その後に再開始させることができるようにするために使うこともできます。
（Flexスキャナは@emph{再入可能ではない}ので、
このようなことが必要になります。）

@c __ @findex @code{YY_NEW_FILE}@r{, in detail}
@findex @code{YY_NEW_FILE}@r{、詳細}
@item   YY_NEW_FILE
@c __ This is a macro which tells Flex that @code{yyin} has been pointed to a
@c __ new file, and that processing should continue. For example:
@c @ifset INCLUDEFLEX25INFO
@code{yyin}が新しいファイルを指すよう変更され、
処理が継続されるべきであるということをFlexに通知するマクロです。@footnote{訳注：Flex 2.5では、
@code{yyin}を変更した後に@code{YY_NEW_FILE}を実行する必要はなくなりました。}
@c @end ifset
@c @ifclear INCLUDEFLEX25INFO
@c @code{yyin}が新しいファイルを指すよう変更され、
@c 処理が継続されるべきであるということをFlexに通知するマクロです。
@c @end ifclear
以下に例を示します。

@c __ Large groupings produce less bad formatting in following pages
@c __ than do smaller groupings which work better here.  --bob
@example
@group
@c __ /*
@c __  * cat.lex: A demonstration of YY_NEW_FILE.
@c __  */
/*
 * cat.lex: YY_NEW_FILEの実演
 */

%@{
#include <stdio.h>

@end group
@group
#define ERRORMESS "Unable to open %s\n"

char **names = NULL;
int  current = 1;
%@}

@end group
@group
%%
<<EOF>> @{
         current += 1;
         if(names[current] != NULL)@{
            yyin = fopen(names[current],"r");
            if(yyin == NULL)@{
              fprintf(stderr,ERRORMESS,
                       names[current]);
              yyterminate();
            @}
            YY_NEW_FILE;
         @} else @{
           yyterminate();
         @}
        @}
%%

@end group
@group
int main(int argc, char **argv)
@{
  if(argc < 2)@{
     fprintf(stderr,"Usage: cat files....\n");
     exit(1);
  @}
  names = argv;

@end group
@group
  yyin = fopen(names[current],"r");
  if(yyin == NULL)@{
    fprintf(stderr,ERRORMESS,names[current]);
    yyterminate();
  @}
  yylex();
@}
@end group
@end example 

@c __ @cindex Displaying scanned text, @code{ECHO}
@cindex スキャンされたテキストの表示、@code{ECHO}
@c __ @vindex @code{yytext}@r{, displaying}
@vindex @code{yytext}@r{、表示}
@item   ECHO
@c __ A macro that writes @code{yytext} to @code{yyout}.  
@code{yytext}の内容を@code{yyout}に書き込むマクロです。

@c __ @findex @code{REJECT}@r{, in detail}
@findex @code{REJECT}@r{、詳細}
@c __ @cindex Rejecting a pattern match
@cindex パターン・マッチの拒絶
@item   REJECT
@c __ @code{REJECT} is a macro that tells the scanner not to accept the
@c __ current match, and to select the next best match.  The scanner looks for
@c __ the longest match, and if two matches are the same length, it will
@c __ choose the one which was defined first in the description file.  This
@c __ means that the length of the recognized text could be the same length,
@c __ or shorter.  After using @code{REJECT}, @code{yytext} and @code{yyleng}
@c __ will have new values.  Two important things to know about @code{REJECT}
@c __ are that the actions following a @code{REJECT} are not executed because
@c __ it is a branch, and never returns, and that @code{REJECT} and fast
@c __ tables (@samp{-F}) cannot be used together.  Here is a simple example:
@code{REJECT}は、
その時点においてマッチしているものを受け入れず、
次に最もよくマッチするものを受け入れるようスキャナに通知するマクロです。
スキャナはマッチするものの中で最長のものを探し、
マッチするものが２つあってその長さが同じ場合は、
記述ファイルにおいて最初に定義されている方を選択します。
つまり、
認識されるテキストの長さは、
同一の長さになることもあり、
または短くなることもあるということを意味しています。
@code{REJECT}を使った後は、
@code{yytext}と@code{yyleng}は新しい値を取ります。
@code{REJECT}に関して知っておくべき重要な点が２つあります。
１つめは、
@code{REJECT}は分岐命令であり、
決して戻ってこないので、
@code{REJECT}の後ろに記述されたアクションは実行されないということです。
２つめは、
@code{REJECT}とファスト・テーブル（fast table／@samp{-F}）は一緒に使うことはできないということです。
以下に簡単な例を示します。

@c =================================================================
@c TODO: We really need a better example here, but I'll damned
@c       if I can think of a good one.  How do you use REJECT?
@c       The only case I could imagine is in context sensitive
@c       scans, which are probably better served using start states.  
@c =================================================================

@example
@group
@c __ /* 
@c __  * reject.lex: An example of REJECT and unput()
@c __  *             misuse.  
@c __  */
/*
 * reject.lex: REJECTとunput()を悪用する実例
 */

%%
UNIX   @{ 
            unput('U'); unput('N'); 
            unput('G'); unput('\0');
            REJECT;
       @} 
GNU    printf("GNU is Not Unix!\n"); 
%%
@end group
@end example

@noindent
@c __ This example shows a new twist on text substitution.  When a match on
@c __ @samp{UNIX} occurs, the characters for @samp{GNU} are @code{unput()},
@c __ which effectively overwrites the contents of the current scan buffer.
@c __ Next @code{REJECT} causes a branch to tell the scanner to try to match
@c __ something else.  As @samp{GNU} has been written to the buffer, this is
@c __ matched next, and its actions executed.  Here is an example of what
@c __ might happen:
この例は、
新式のテキスト代替の技法を示しています。
@samp{UNIX}にマッチするものが見つかると、
@code{unput()}によって@samp{GNU}という文字の並びが戻され、
その時点におけるスキャン・バッファの内容が上書きされます。
次に@code{REJECT}により分岐が行われ、
別のものにマッチするようスキャナに対して通知が行われます。
@samp{GNU}がバッファに書き込まれたので、
これが次にマッチされ、
そのアクションが実行されます。
以下に、
その結果こうなるであろうと思われる例を示します。

@example
@group
UNIX @var{return}
GNU is Not Unix!
@end group
@end example

@noindent
@c __ Actually there are very few uses for @code{REJECT} in Flex.  Another way
@c __ it @emph{can} be used is for patterns that overlap, or for changing
@c __ states.  For example:
実際のところは、
Flexにおいて@code{REJECT}の用途はほんの少ししかありません。
上記以外では、
重複するパターンや状態の変更に@emph{使うことができます}。
例を示すと、
以下のようになります。

@example
@group
nday         [1-9]|[1-2][0-9]|3[0-1]
nmonth       [1-9]|1[0-2]
nyear        [0-9]@{1,4@}

%x DAY MONTH YEAR

@end group
@group
%%

@{nday@}           BEGIN(DAY);   REJECT;
<DAY>@{nday@}
     @dots{}  
@{nmonth@}         BEGIN(MONTH); REJECT;
<MONTH>@{nday@}
     @dots{}
@{nyear@}          BEGIN(YEAR);  REJECT;
<YEAR>@{nday@}
     @dots{}
@end group
@end example

@noindent
@c __ In this case, the formats for dates overlap, and we use the first
@c __ recognized part to decide how to parse them.  This example is rather
@c __ forced though, because with a little thought, we can eliminate the
@c __ @code{REJECT}'s, and gain a more efficient scanner.  This is done in
@c __ @ref{Start State Example, , Example of Using Start States}.
この例では、
日付の形式は重複しており、
最初に認識された構成要素によって、
どのように日付をパースするかを決定します。
しかし、
この例は少々不自然な感じがします。
というのは、
少し考えれば、
@code{REJECT}を使わずに、
より効率的なスキャナにすることができるからです。
これは、
@ref{Start State Example, , スタート状態の使用例}に示しています。

@c __ @findex @code{BEGIN}@r{, in detail}
@findex @code{BEGIN}@r{、詳細}
@item   BEGIN
@c __ @code{BEGIN} is a macro for putting the scanner into a certain start
@c __ state.  The name following @code{BEGIN} is the name of the start state.
@c __ For example:
@code{BEGIN}は、
スキャナをある特定のスタート状態にするためのマクロです。
@code{BEGIN}に続く名前はスタート状態の名前です。
例えば、

@example
@group
%x FLOAT
%%
floats   BEGIN(FLOAT)
<FLOAT>@var{some_rule} @var{some_action}
       @dots{}
@end group
@end example

@noindent
@c __ will set the start state to @code{FLOAT} when the word @samp{float} is
@c __ matched (@pxref{Start States Explained}, for more details).
は、
@samp{floats}という単語がマッチした時に、
スタート状態を@code{FLOAT}に設定します
（詳細については、
@pxref{Start States Explained}）。

@c __ @findex @code{YY_USER_ACTION}@r{, in detail}
@findex @code{YY_USER_ACTION}@r{、詳細}
@c __ @cindex User-defined action
@cindex ユーザ定義のアクション
@item   YY_USER_ACTION
@c __ @code{YY_USER_ACTION} is a macro that defines an action that takes place
@c __ @emph{before} any of the actions in the rules section.  This is useful
@c __ for doing things like converting @code{yytext} from lower to uppercase,
@c __ as shown in the example below.
@code{YY_USER_ACTION}は、
ルール・セクション中のどのアクションよりも@emph{前}に実行されるアクションを定義するマクロです。
これは、
以下の例で示すように、
@code{yytext}の内容の小文字から大文字への変換等を行うのに役に立ちます。

@example
@group
@c __ /* 
@c __  * user_act.lex: An example of user actions
@c __  *               using YY_USER_ACTION
@c __  *
@c __  */
/*
 * user_act.lex: YY_USER_ACTIONを使う
 *               ユーザ・アクションの例
 */

%@{

#include <ctype.h>

void user_action(void);

@end group
@group
#define YY_USER_ACTION user_action();

%@}

%%

.*         ECHO;
\n         ECHO;

%%

@end group
@group
@c __  /* 
@c __   * This user action just converts everything
@c __   * to upper case.
@c __   */
/*
 * このユーザ・アクションはすべての文字を
 * 単に大文字に変換する
 */

void user_action(void)
@{
  int loop;
  
  for(loop=0; loop<yyleng; loop++)@{
    if(islower(yytext[loop]))@{
       yytext[loop] = toupper(yytext[loop]);
    @}
  @}
@}
@end group
@end example

@noindent
@c __ This simply converts all the input to uppercase, and then @code{ECHO}'s
@c __ it.  The default for @code{YY_USER_ACTION} is to do nothing.
これは、
すべての入力文字を単に大文字に変換して@code{ECHO}します。
@code{YY_USER_ACTION}のデフォルトの設定では、
何も実行されません。

@c __ @findex @code{YY_USER_INIT}@r{, in detail}
@findex @code{YY_USER_INIT}@r{、詳細}
@c __ @cindex User-defined initialization
@cindex ユーザ定義の初期化
@item   YY_USER_INIT
@c __ @code{YY_USER_INIT} is a macro that defines an action to take place
@c __ @emph{before} scanning starts.  This is basically the same as placing
@c __ such code before the @code{yylex()} statement in @code{main()}.  Here is
@c __ a simple example:
@code{YY_USER_INIT}は、
スキャン処理が開始される@emph{前}に実行されるアクションを定義するマクロです。
基本的には、
@code{main()}関数の中で、
@code{yylex()}を呼び出す文の前に同様のコードを記述するのと同じことです。
以下に簡単な例を示します。

@example
@group
@c __ /* 
@c __  * userinit.lex: An example of using 
@c __  *               YY_USER_INIT.  
@c __  *
@c __  */
/*
 * userinit.lex: YY_USER_INITを使う例
 */

%@{
#define YY_USER_INIT open_input_file()

extern FILE *yyin;

@end group
@group
void open_input_file(void)
@{
  char *file_name,buffer[1024];

  yyin      = NULL; 

@end group
@group
  while(yyin == NULL)@{
    printf("Input file: ");
    file_name = fgets(buffer,1024,stdin);
@end group
@group
    if(file_name)@{
      file_name[strlen(file_name)-1] = '\0';
      yyin = fopen(file_name,"r");
@end group
@group
      if(yyin == NULL)@{
        printf("Unable to open \"%s\"\n",
               file_name);
      @}
@end group
@group
    @} else @{
      printf("stdin\n");
      yyin = stdin;
      break;
    @}
  @}
@}

%@}
%%
@end group
@end example

@noindent 
@c __ This prompts the user for an input name until either a file is opened,
@c __ or EOF is found, in which case the input defaults to @code{stdin}.  This
@c __ is the same as:
これは、
ファイルがオープンされるかEOFが検出されるまで、
入力ファイル名を入力するようユーザに催促します。
EOFが検出された場合は、
入力元はデフォルトで@code{stdin}になります。
これは以下と同じことです。

@example
@group
@c __ /*
@c __  * This example does the same thing but does
@c __  * not use YY_USER_INIT.  
@c __  *
@c __  */
/*
 * この例は、前の例と同じことをYY_USER_INITを
 * 使わずに行う
 */
 
%@{
void open_input_file(void)
@{
  char *file_name,buffer[1024];

  yyin      = NULL; 

@end group
@group
  while(yyin == NULL)@{
    printf("Input file: ");
    file_name = fgets(buffer,1024,stdin);
    if(file_name)@{
      file_name[strlen(file_name)-1] = '\0';
      yyin = fopen(file_name,"r");
      if(yyin == NULL)@{
        printf("Unable to open \"%s\"\n",
               file_name);
      @}
@end group
@group
    @} else @{
      printf("stdin\n");
      yyin = stdin;
      break;
    @}
  @}
@}

%@}
%%
%%

@end group
@group
int main(int argc, char *argv[])
@{
   open_input_file();
   yylex();
@}
@end group
@end example

@c __ @findex @code{YY_BREAK}@r{, in detail}
@c __ @findex @code{break} @r{used with} @code{YYBREAK} 
@findex @code{YY_BREAK}@r{、詳細}
@findex @code{YYBREAK}@r{とともに使用される}@code{break} 
@item   YY_BREAK
@c __ @code{YY_BREAK} is a macro, and is not really an interface feature, but
@c __ rather one that may be used to change the generated code.
@code{YY_BREAK}はマクロです。
インターフェイス的な機能というよりも、
むしろ生成されるコードを変更するために使うことができるものです。

@c __ In the scanner, all the actions are part of one big @code{switch}
@c __ statement, and are separated using @code{YY_BREAK}, which defaults to
@c __ the C @code{break;} statement.  If the actions part of the rules contain
@c __ many @code{return} statements, then the compiler may generate a lot of
@c __ @samp{statement not reached} errors.  By redefining @code{YY_BREAK}, it
@c __ is possible to stop these warnings.  This @emph{must} be a legal C
@c __ statement, including the semi-colon.
スキャナ中において、
すべてのアクションは１つの大きな@code{switch}文の要素であり、
デフォルトでCの@code{break;}文に置き換えられる@code{YY_BREAK}によって区切られます。
ルールのアクション部が多くの@code{return}文を含んでいる場合、
コンパイラが@samp{statement not reached}というエラー・メッセージをたくさん出力するかもしれません。
@code{YY_BREAK}を再定義することによって、
この警告メッセージの出力を止めることが可能です。
再定義は、
セミ・コロンを含む正当なCの文でなければ@emph{なりません}。

@* 
@c __ @strong{Please note:} @i{If you redefine @code{YY_BREAK} to be empty
@c __ make sure your actions finish with either a @code{return;} or a
@c __ @code{break;} statement.  }
@strong{注：}@i{@code{YY_BREAK}を再定義して空にするのであれば、
アクションの最後は必ず@code{return;}か@code{break;}になるようにしてください。}
@end table
@end itemize

@c Include Flex 2.5 information, for Flex manual as published by ASCII
@c @ifset INCLUDEFLEX25INFO
@node Flex and C (Flex 2.5), An Example of Flex and C, Flex and C, Interfacing to Flex
@section FlexとC（Flex 2.5の補足情報）
@include funcvar_addendum-ja.texi
@c @end ifset

@c +--------------------------------------------------------------------+
@c |                                                                    |
@c | Introduction to the simple example of Flex and C                   |
@c |                                                                    |
@c +-----------------+-----------------+-----------------+--------------+ 
@c |       Name      |       Next      |     Previous    |       Up     |
@c +-----------------+-----------------+-----------------+--------------+ 
@c @node    An Example of Flex and C, Flex and Bison, Flex and C, Interfacing to Flex
@node    An Example of Flex and C, Flex and Bison, Flex and C (Flex 2.5), Interfacing to Flex
@c __ @section A Simple Example of Flex and C
@section FlexとCの簡単な実例
@comment ##############################

@c __ It is often necessary to replace the occurrences of one word with
@c __ another.  Say for example you want to make a utility that will replace
@c __ every occurrence of a name with the value of one of your environment
@c __ variables, and you also want to have the utility act as a filter, so you
@c __ can do things like:
ある単語が現れた時に、
それを別の単語に置き換える必要の生じることがよくあります。
例えば、
ある名前が現れるたびに、
それをある１つの環境変数の値で置き換えてくれるユーティリティを作りたいとしましょう。
そして、
以下のようなことができるように、
そのユーティリティがフィルタとして動作するようにさせたいとします。

@example
@group
nick% myname   < infile | more
nick% myname   < infile > outfile
@end group
@end example

@noindent
@c __ Here is a simple example of a Flex file which shows you how to do it.
以下に、
こうしたことを実現する方法を示すFlexファイルの簡単な例を挙げます。

@example
@group
@c __ /*
@c __  * myname.lex : A sample Flex program
@c __  *              that does token replacement.  
@c __  */
/*
 * myname.lex : トークンの置き換えを行うFlexプログラム
 *              のサンプル
 */

%%

%NAME     @{ printf("%s",getenv("LOGNAME")); @}
%HOST     @{ printf("%s",getenv("HOST"));    @}
%HOSTTYPE @{ printf("%s",getenv("HOSTTYPE"));@}
%HOME     @{ printf("%s",getenv("HOME"));    @}

%%
@end group
@end example

@c __ The source for this is in the @file{examples} sub-directory, and it is
@c __ called @file{myname.lex}.  You can build this by typing @samp{make
@c __ myname} after changing to the @file{examples} sub-directory, or by
@c __ typing:
このソース・ファイルは@file{examples}サブディレクトリにあり、
その名前は@file{myname.lex}です。
これをビルドするには、
@file{examples}サブディレクトリに移動して@samp{make myname}を実行するか、
以下を実行します。

@example
@group
flex myname.lex
cc lex.yy.c -o myname -lfl
@end group
@end example

@noindent
@c __ Here the @samp{-lfl} tells the linker to link with the Flex library,
@c __ which currently contains only a default @code{main()}.  In a future
@c __ version of Flex, some other functions will also be found there. If you
@c __ do not have the Flex library installed this should be @samp{-ll}.
ここで@samp{-lfl}は、
リンカに対してFlexライブラリをリンクするよう通知します。
現在のところ、
Flexライブラリにはデフォルトの@code{main()}関数だけが含まれています。
将来のバージョンのFlexでは、
他の関数も含まれるようになるでしょう。
Flexライブラリがインストールされていない場合は、
この部分は@samp{-ll}でなければなりません。

@c __ In either case, you should end up with an executable file called
@c __ @file{myname}.  This is a filter which will perform the following
@c __ transformations.
いずれの場合でも、
最終的には@file{myname}という名前の実行ファイルが生成されるはずです。
これは、
以下のような変換処理を実行するフィルタです。

@itemize
@table @code
@item %NAME 
@c __ This will be replaced with the name you logged in under.  
ユーザのログイン名に置き換えられます。

@item %HOST
@c __ This will be replaced with the name of your host computer.  
ユーザのホスト・コンピュータ名に置き換えられます。

@item %HOSTTYPE
@c __ This will be replaced with the machine type of your host.  
ユーザのホスト・コンピュータのマシン・タイプに置き換えられます。

@item %HOME
@c __ This will be replaced with the path which represents your home
@c __ directory.  
ユーザのホーム・ディレクトリを表すパスに置き換えられます。
@end table
@end itemize

@noindent
@c __ So, if you create a file called @file{myname.txt} that contains:
したがって、
以下のような内容を持つファイル@file{myname.txt}を作成して、

@example
@group
Hello, my name is %NAME.  Actually 
"%NAME" isn't my real name, it is the
alias I use when I'm on %HOST, which
is the %HOSTTYPE I use.  My HOME 
directory is %HOME.  
@end group
@end example

@noindent
@c __ and you type:
以下を実行すると、

@example
myname < myname.txt
@end example

@noindent
@c __ then something like the following text will be written to @code{stdout}.  
以下のテキストに似たものが@code{stdout}へ書き込まれます。

@example
@group
Hello, my name is foobar.  Actually 
"foobar" isn't my real name, it is the
alias I use when I'm on baz, which
is the cray I use.  My HOME 
directory is /home/foo/foobar.  
@end group
@end example

@c __ @cindex Default behavior, scanner
@cindex デフォルトの振る舞い、スキャナ
@c __ This program works because the default action is to copy @code{yyin} to
@c __ @code{yyout}, and the defaults for these are @code{stdin} and
@c __ @code{stdout} respectively.  Note also that the @samp{@{ @}} are not
@c __ necessary as the only action for each rule is a single line.  In this
@c __ case putting @samp{@{ @}} around actions is a matter of personal
@c __ preference.
このプログラムがうまく動作するのは、
@code{yyin}と@code{yyout}がデフォルトでは@code{stdin}、@code{stdout}にそれぞれ割り当てられ、
かつ、
デフォルトのアクションが@code{yyin}の内容を@code{yyout}にコピーするからです。
また、
個々のルールに対応する唯一のアクションが単一行で記述されているため、
@samp{@{ @}}は必要ではないことに注意してください。
このような場合には、
アクションを@samp{@{ @}}で囲むか否かは、
個人的な好みの問題になります。

@c __ Notice how it matched @emph{every} occurrence of the specified names,
@c __ even the one inside the quotes? In Flex, if you do not want to have it
@c __ match things inside quotes, you must explicitly tell it not to by
@c __ creating a rule for it.  For example:
これが、
引用符で囲まれた部分にあるものも含めて、
指定された名前が現れるところ@emph{すべて}にマッチしたことに気がつきましたか？
Flexにおいては、
引用符で囲まれた部分にあるものにマッチさせたくない場合には、
それに対応するルールを作成することにより、
そうしないよう明示的にFlexに通知しなければなりません。
以下に例を示します。

@example
@group
@c __ /*
@c __  * myname2.lex : A sample Flex program
@c __  *               that does token replacement.  
@c __  */
/*
 * myname2.lex : トークンの置き換えを行うFlexプログラムの例
 */

%@{
#include <stdio.h>
%@}

%x STRING
%%
\"                ECHO; BEGIN(STRING); 
<STRING>[^\"\n]*  ECHO;
<STRING>\"        ECHO; BEGIN(INITIAL);

@end group
@group
%NAME     @{ printf("%s",getenv("LOGNAME")); @}
%HOST     @{ printf("%s",getenv("HOST"));    @}
%HOSTTYPE @{ printf("%s",getenv("HOSTTYPE"));@}
%HOME     @{ printf("%s",getenv("HOME"));    @}
@end group
@end example

@noindent
@c __ This uses an exclusive start state to make sure that text inside a
@c __ string is not changed.  This is also in the @file{examples}
@c __ subdirectory, and is called @file{myname2.lex}.
この例では、
排他的スタート状態を使って、
文字列中のテキストが変更されることのないようにしています。
この例も@file{examples}サブディレクトリにあるもので、
その名前は@file{myname2.lex}です。

@c +--------------------------------------------------------------------+
@c |                                                                    |
@c |This node takes care of explaining the interface between Bison and  |
@c |Flex                                                                |
@c |                                                                    |
@c +-----------------+-----------------+-----------------+--------------+ 
@c |       Name      |       Next      |     Previous    |       Up     |
@c +-----------------+-----------------+-----------------+--------------+ 
@c @node    Flex and Bison, Another Example of Flex and Bison, An Example of Flex and C, Interfacing to Flex
@node    Flex and Bison, Another Example of Flex and Bison, An Example of Flex and C, Interfacing to Flex
@c __ @section Flex and Bison
@section FlexとBison
@comment ##############
@c __ @cindex  Interfacing Flex and Bison
@cindex  FlexとBisonのインターフェイス
@cindex  @r{Bison}
@cindex  @code{Yacc}

@c __ Bison is a program, which, like Flex, takes a description and
@c __ generates C code from it.  The difference is that Bison takes as
@c __ input a description of grammars for languages such as C or Pascal, and
@c __ produces a @dfn{parser} from that description.  By combining Flex and
@c __ Bison, you can deal with both the lexical and syntactical analysis
@c __ parts of languages.  (These are the most easily automated steps in
@c __ compiler design.)
Bisonは、
Flexと同様、
ある記述情報を受け取って、
それをもとにCのコードを生成するプログラムです。
両者の違いは、
BisonがCやPascalのような言語の文法に関する記述情報を入力として受け取り、
その記述情報から@dfn{パーサ}を生成する点にあります。
FlexとBisonを結合することにより、
言語の字句解析と構文解析の両方を処理することができるようになります。
（これは、
コンパイラ・デザインにおいて最も容易に自動化できる部分です。）

@c __ Bison needs a function called @code{yylex()} for the generated
@c __ parser to work.  This function is supplied by the user, and when called
@c __ it returns to Bison an integer representing a part of the language
@c __ being parsed.  The scanning routine in Flex is @code{yylex()}, and by
@c __ default it can return an integer.  This makes it very easy to use Flex
@c __ and Bison together.
生成されるパーサが機能するためには、
Bisonは@code{yylex()}という関数を必要とします。
この関数はユーザによって提供され、
呼び出された時に、
パースされている言語のある要素を表す整数値をBisonに返します。
Flexにおいてスキャン処理を行うルーチンは@code{yylex()}であり、
デフォルトでは整数値を返します。
これにより、
FlexとBisonを一緒に使うのは非常に簡単になります。

@c __ @strong{Warning:} @i{The following sections assume that the reader can
@c __ understand the basic parser declarations of Bison.  If you have no
@c __ experience with Bison, the parser definitions may be confusing, so
@c __ please read the @cite{Bison} manual before continuing.  If you are not
@c __ interested in Bison, this section may be skipped altogether.}
@strong{警告：} @i{以下の節では、
読者がBisonの基本的なパーサの宣言を理解しているものと仮定します。
Bisonを使った経験のない人には、
パーサの定義は混乱をもたらす可能性がありますので、
先に進む前に是非@cite{Bison}のマニュアルを読んでください。
Bisonに興味の無い人は、
この節全体を飛ばしても構いません。}

@ifnottex
========================================================================
@c __ @menu
@c __ * Interfacing Flex and Bison::  The general method.  
@c __ * YYSTYPE and yylval::          Passing more than just integers.  
@c __ @end menu
@menu
* Interfacing Flex and Bison::  一般的な方法
* YYSTYPE and yylval::          単なる整数以上の情報の渡し方
@end menu
========================================================================
@end ifnottex

@c +--------------------------------------------------------------------+
@c |                                                                    |
@c | The basic yylex() interface is explained here.                     |
@c |                                                                    |
@c +-----------------+-----------------+-----------------+--------------+ 
@c |       Name      |       Next      |     Previous    |       Up     |
@c +-----------------+-----------------+-----------------+--------------+ 
@c @node    Interfacing Flex and Bison, YYSTYPE and yylval, Flex and Bison, Flex and Bison
@node    Interfacing Flex and Bison, YYSTYPE and yylval, Flex and Bison, Flex and Bison
@c __ @subsection Interfacing Flex and Bison
@subsection FlexとBisonのインターフェイス
@comment    ##########################
@c __ @cindex     Returning data from Flex
@cindex     Flexからのデータの返却

@c __ The basic method for passing information between Flex and Bison is
@c __ through the function @file{yylex()}, which is the name of the scanning
@c __ function in the Flex generated scanner.  This function can return values
@c __ other than just 0 or 1 by using a @file{return} statement in the actions
@c __ part of the Flex input file.  This way, @code{yylex()} can return an
@c __ integer value that represents the token it last recognized.
FlexとBisonの間で情報を渡す基本的な方法は、
関数@file{yylex()}を使うことです。
これは、
Flexにより生成されるスキャナにおいて、
スキャン処理を実行する関数の名前です。
Flexの入力ファイルのアクション部分において@file{return}文を使うことによって、
単なる0や1以外の値を返すことができます。
この方法で、
@code{yylex()}は最後に認識されたトークンを表す整数値を返すことができます。

@c __ When Bison is used with the @samp{-d} switch, Bison generates a
@c __ file with a @file{.tab.h} extension containing a unique definition for
@c __ each of the legal tokens in its description.  This output was
@c __ specifically designed to be used by scanners.  By including the file
@c __ into the Flex generated scanner, it is possible to create a very clear
@c __ interface between the two programs.  For example, the following file is
@c __ a Bison file; let's call it @file{expr.y}.
Bisonを@samp{-d}オプション付きで使うと、
Bisonは@file{.tab.h}という拡張子を持つファイルを生成します。
このファイルには、
記述情報中にある正当なトークンの１つ１つに対する一意な定義情報が含まれます。
この出力情報は、
特にスキャナによって使用されることを想定して設計されています。
このファイルをFlexにより生成されたスキャナに含めることで、
２つのプログラムの間に非常に明確なインターフェイスを作ることができます。
例として、
以下にBisonのファイルを示します。
このファイルの名前を@file{expr.y}としましょう。

@example
@group
@c __ /*
@c __  * expr.y : A simple Bison expression parser
@c __  *          Based on the Bison manual example.  
@c __  */
/*
 * expr.y : Bisonマニュアル中の例に基づく
 *          Bisonによる簡単な表現式パーサ
 */

%@{
#include <stdio.h>
#include <math.h>

%@}

@end group
@group
%union @{
   float val;
@}

%token NUMBER
%token PLUS MINUS MULT DIV EXPON
%token EOL
%token LB RB

@end group
@group
%left  MINUS PLUS
%left  MULT DIV
%right EXPON

%type  <val> exp NUMBER

@end group
@group
%%
input   :
        | input line
        ;

@end group
@group
line    : EOL
        | exp EOL @{ printf("%g\n",$1);@}

@end group
@group
exp     : NUMBER                 @{ $$ = $1;        @}
        | exp PLUS  exp          @{ $$ = $1 + $3;   @}
        | exp MINUS exp          @{ $$ = $1 - $3;   @}
        | exp MULT  exp          @{ $$ = $1 * $3;   @}
        | exp DIV   exp          @{ $$ = $1 / $3;   @}
        | MINUS  exp %prec MINUS @{ $$ = -$2;       @}
        | exp EXPON exp          @{ $$ = pow($1,$3);@}
        | LB exp RB              @{ $$ = $2;        @}
        ;

%%

@end group
@group
void yyerror(char *s)
@{
  printf("%s\n",s);
@}

@end group
@group
int main()
@{
  yyparse();
@}
@end group
@end example

@noindent
@c __ This is a grammar definition for a very simple calculator.  
これは非常に簡単な計算機の文法定義です。

@c __ When Bison is called with the @samp{-y -d} options, it will create a
@c __ file named @file{y.tab.h}, which will contain the following definitions,
@c __ or something much like them.
@samp{-y -d}オプション付きで呼び出されると、
Bisonは@file{y.tab.h}というファイルを生成します。
このファイルには以下のような定義か、
それにきわめてよく似た定義が含まれます。

@example
@group
typedef union  @{
   float val;
@} YYSTYPE;
extern YYSTYPE yylval;
#define NUMBER  258
@end group
#define PLUS    259
#define MINUS   260
#define MULT    261
#define DIV     262
#define EXPON   263
#define EOL     264
@group
#define LB      265
#define RB      266
@end group
@end example

@noindent
@c __ This can be included into the scanner (using @code{#include}) so that
@c __ Flex will return the correct token values to Bison.  The code looks
@c __ like this:
Flexがトークンの値を正しくBisonに返すことができるように、
（@code{#include}を使って）
これをスキャナに含めることができます。
そのコードは以下のようなものになります。

@example
@group
@c __ /*
@c __  * expr.lex : Scanner for a simple
@c __  *            expression parser.  
@c __  */
/*
 * expr.lex : 簡単な表現式パーサのためのスキャナ
 */

%@{
#include "y.tab.h"
%@}

%%

@end group
@group
[0-9]+     @{ yylval.val = atof(yytext);
             return(NUMBER);
           @}
[0-9]+\.[0-9]+ @{ 
             sscanf(yytext,"%f",&yylval.val);
             return(NUMBER);
           @}
"+"        return(PLUS);
@end group
@group
"-"        return(MINUS);
"*"        return(MULT);
"/"        return(DIV);
"^"        return(EXPON);
"("        return(LB);
")"        return(RB);
\n         return(EOL);
.          @{ yyerror("Illegal character"); 
             return(EOL);
           @}
%%
@end group
@end example

@noindent
@c __ You can compile these files by typing:
上記のファイルは、
以下のようにしてコンパイルすることができます。

@example
@group
bison -d -y expr.y
flex -I  expr.lex
cc -o expr y.tab.c lex.yy.c alloca.c 
@end group
@end example

@noindent
@c __ or if your have the source for the examples, you should just type
@c __ @samp{make expr} in the @file{examples} sub-directory.  Either of these
@c __ will produce a simple calculator called @file{expr}, which will parse
@c __ expressions like:
また、
この例のソースが手元にあれば、
@file{examples}サブディレクトリにおいて@samp{make expr}を実行するだけでコンパイルできます。
どちらの方法でも、
@file{expr}という名前の簡単な計算機が生成されます。
これは以下のような表現式をパースして、
その結果を出力します。

@example
1 + 2 * (199*2)
@end example

@noindent
@c この部分は、@example の前で翻訳済み
@c __ and print the result.  

@c =====================================================================
@c >>>brendan: flexible?  Hahaha...  
@c >>>nick:    Well, I figure that you have to say something
@c >>>nick:    positive.  Like Knuth in TeXbook, we tell little white
@c >>>nick:    lies.  
@c  =====================================================================

@c __ As you can see, this kind of interface is very flexible and very easy to
@c __ maintain.  It is possible to add or remove features and change
@c __ definitions or code in either the Flex or Bison inputs without
@c __ changing the interface between the two (as long as the token definition
@c __ names stay the same).
これを見てお分かりのように、
この種のインターフェイスは非常に柔軟であり、
かつ、
保守も非常に容易です。
（トークンを定義する名前が変わらない限り）
BisonとFlexの間のインターフェイスを変更することなく、
Flex、
Bisonいずれの入力情報においても、
機能の追加や削除、
定義やコードの変更を行うことが可能です。

@c __ Note that this example has introduced another way of passing information
@c __ between Flex and Bison.  This example uses @code{yylval} to pass the
@c __ value of the numbers back to Bison.  This is explained in more
@c __ detail in the next section.  For now, just study the use of the
@c __ @code{return} statement.
この例では、
FlexとBisonの間で情報を渡すための別の方法を導入していることに注意してください。
この例では、
数字の値をBisonに返すのに@code{yylval}を使っています。
これについては次の節でより詳細に説明します。
ここではとりあえず、
@code{return}文の使い方を学んでおいてください。

@c __ @strong{Please note:} @i{This is a simple example.  For a more detailed
@c __ look at expression parsing, refer to the @cite{Bison} manual.
@c __ }
@strong{注：}@i{これは単純な例です。
表現式のパース処理についてより詳しく知りたい人は、
@cite{Bison}のマニュアルを参照してください。}

@c +--------------------------------------------------------------------+
@c |                                                                    |
@c | The more powerful YYSTYPE and yylval are explained here.           |
@c |                                                                    |
@c +-----------------+-----------------+-----------------+--------------+ 
@c |       Name      |       Next      |     Previous    |       Up     |
@c +-----------------+-----------------+-----------------+--------------+ 
@c @node YYSTYPE and yylval,  , Interfacing Flex and Bison, Flex and Bison
@node YYSTYPE and yylval,  , Interfacing Flex and Bison, Flex and Bison
@c __ @subsection YYSTYPE and yylval
@subsection YYSTYPEとyylval
@comment    ##################
@c __ @tindex @code{YYSTYPE}@r{, in relation to Bison}
@tindex @code{YYSTYPE}@r{、Bisonとの関連}
@c __ @vindex @code{yylval}@r{, description}
@vindex @code{yylval}@r{、説明}

@c __ It is often necessary to pass more than just an integer from Flex to
@c __ Bison.  For example, in a compiler, you need to know not only what
@c __ @emph{kind} of token was recognized, but sometimes the value of the
@c __ token as well.  String, character, and numeric constants are good
@c __ examples.  The problem is, how can you get Flex to send the information
@c __ back?
FlexからBisonに対して、
単なる整数値以上の情報を渡す必要の生じることがよくあります。
例えば、
コンパイラにおいては、
どのような@emph{種類}のトークンが認識されたかだけではなく、
そのトークンの値についても知る必要のある場合がときどきあります。
文字列、文字、および数値定数などが良い例です。
ここで問題なのは、
どのようにしてFlexにこうした情報を返させるかです。

@c __ The answer is that Bison has a @code{%union} statement which defines
@c __ a type called @code{YYSTYPE}.  @code{YYSTYPE} is a @code{union} of all
@c __ the legal data types used in the parser definition.  There is a variable
@c __ @code{yylval} of type @code{YYSTYPE} that Bison uses to hold the
@c __ data associated with the current parse state, and we can put values into
@c __ @code{yylval} from Flex, thereby allowing us to pass more than just the
@c __ token type back to Bison.
その答は、
Bisonが持っている@code{%union}文です。
これは、
@code{YYSTYPE}という型を定義するものです。
@code{YYSTYPE}は、
パーサ定義中において使われるすべての正当なデータ型の共用体（@code{union}）です。
Bisonがカレントなパース状態に関連づけたデータを保存するために使う、
@code{YYSTYPE}型の変数@code{yylval}というものがあり、
Flexから@code{yylval}に値を設定することができるので、
トークンの型だけでなく、
それ以上の情報をBisonに返すことができます。

@c __ When you declare a @code{%union} in Bison and then use the @samp{-d}
@c __ option, it will create a file with a @file{.tab.h} extension that
@c __ contains not only token definitions, but also declarations for
@c __ @code{YYSTYPE} and @code{yylval}.  So in order to access @code{yylval},
@c __ all you have to do is include the @file{.tab.h} file into your Flex
@c __ definition.  This should be included at the top of the definition in the
@c __ extra C code section (@pxref{Interfacing Flex and Bison}).
Bisonにおいて@code{%union}を宣言して@samp{-d}オプションを使うと、
Bisonは@file{.tab.h}という拡張子を持つファイルを作成して、
そこにトークンの定義情報だけでなく、
@code{YYSTYPE}と@code{yylval}の宣言も含めます。
したがって、
@code{yylval}にアクセスするためにしなければならないことは、
Flexの定義情報の中にこの@file{.tab.h}ファイルをインクルードすることだけです。
これは、
追加のCコード・セクションにおける定義の先頭でインクルードしなければなりません
（@pxref{Interfacing Flex and Bison}）。

@c __ @strong{Please note:} @i{Early versions of Bison do not
@c __ automatically generate the declarations for @code{YYSTYPE} and
@c __ @code{yylval}.  In that case you should either get a more recent version
@c __ of Bison, or you should declare @code{YYSTYPE} and @code{yylval} at
@c __ the top of you Flex definition file.  }
@strong{注：}@i{初期のバージョンのBisonは、
自動的に@code{YYSTYPE}と@code{yylval}の宣言を生成しません。
この場合には、
より新しいバージョンのBisonを入手するか、
もしくは、
Flexの定義ファイルの先頭において@code{YYSTYPE}と@code{yylval}を宣言する必要があります。}

@c +--------------------------------------------------------------------+
@c |                                                                    |
@c | A simple example of Flex and Bison working together.               |
@c |                                                                    |
@c +-----------------+-----------------+-----------------+--------------+ 
@c |       Name      |       Next      |     Previous    |       Up     |
@c +-----------------+-----------------+-----------------+--------------+ 
@c @node    Another Example of Flex and Bison,  , Flex and Bison, Interfacing to Flex
@node    Another Example of Flex and Bison, Flex and C++ (Flex 2.5), Flex and Bison, Interfacing to Flex
@c __ @section Another Example of Flex and Bison
@section FlexとBisonのもう１つの実例
@comment ##################################

@c __ Reading code is a good way to learn how to program, so here is another
@c __ example of interfacing Flex and Bison.  In the example below we are
@c __ going to build a very simple parser for a toy language that could be
@c __ expanded and used to manipulate a database.
コードを読むのは、
プログラミングの方法を学ぶ良い方法です。
そこで、
Flex、Bisonのインターフェイス例をもう１つ示すことにします。
下の例では、
拡張してデータベースを操作するために使うことができるような、
小規模な言語のための簡単なパーサを作ります。

@ifnottex
========================================================================
@c __ @menu
@c __ * The Database Language::       The definition of the database language.  
@c __ * The Implementation::          The files that parse the language.  
@c __ * Notes on the Implementation::  Some (brief) notes on why it was done the
@c __                                 way it was.  
@c __ @end menu
@menu
* The Database Language::       データベース言語の定義
* The Implementation::          言語を解析するファイル
* Notes on the Implementation::  この実装を選択した理由に関する（簡単な）注
@end menu
========================================================================
@end ifnottex

@c +--------------------------------------------------------------------+
@c |                                                                    |
@c | An explanation of the language we are going to build.              |
@c |                                                                    |
@c +-----------------+-----------------+-----------------+--------------+ 
@c |       Name      |       Next      |     Previous    |       Up     |
@c +-----------------+-----------------+-----------------+--------------+ 
@c @node    The Database Language, The Implementation, Another Example of Flex and Bison, Another Example of Flex and Bison
@node    The Database Language, The Implementation, Another Example of Flex and Bison, Another Example of Flex and Bison
@c __ @subsection The Interface Language
@subsection インターフェイス言語
@comment    #######################
@c __ @cindex     Parsing languages
@c __ @cindex     Example Bison grammar
@cindex     パース言語
@cindex     Bison文法の例

@c __ The language for interfacing with the database will be a very small
@c __ subset of the English language.  Informally, the grammar is:
データベースとのインターフェイス言語は、
英語の非常に小さなサブセットになります。
文法はおおよそ以下のようになります。

@example
@group
command_list     ::= sentence @{sentence @dots{}@}
sentence         ::= verb_phrase noun_phrase position_phrase 
                     adverb period
verb_phrase      ::= VERB | adverb VERB
noun_phrase      ::= declared_noun | qualified_noun | noun
declared_noun    ::= declarator NOUN
declarator       ::= THIS | THAT | THE | THOSE
qualified_noun   ::= qualifier NOUN
qualifier        ::= SOME | MANY | ALL @{ declarator @} NOUN
position_phrase  ::= position declarator NOUN  | @i{empty}      
position         ::= IN | ON | AT
adverb           ::= ADVERB | @i{empty}
@end group
@end example

@noindent
@c __ The resulting program will accept sentences such as:
結果として作成されるプログラムは、
以下のような文章を受け付けます。

@example
@group
FIND MEN
QUICKLY FIND MEN
FIND ALL MEN ON THE NETWORK
QUICKLY FIND ALL MEN ON THE NETWORK
FIND ALL MEN ON THE NETWORK QUICKLY
@end group
@end example

@c __ The example will also print a simple analysis of the sentence, so that
@c __ interface between Bison and Flex can be shown clearly.  A sample run
@c __ of using the program might go something like this:
この例では、
BisonとFlexの間のインターフェイスが明確に示されるよう、
文章の簡単な解析結果が表示されます。
このプログラムを試しに実行してみると、
その表示結果は大体以下のようになります。

@example
@group
% front
FIND MEN
I understand that sentence.  
VP = FIND
@end group
@group
NP = MEN
PP = 
AD =
@end group
@group
QUICKLY FIND ALL THE MEN ON THE NETWORK
I understand that sentence.  
VP = QUICKLY FIND
@end group
@group
NP = ALL THE MEN
PP = ON THE NETWORK
AD = 
^C
%
@end group
@end example 

@noindent
@c __ This is not particularly useful, as it does not @emph{do} anything
@c __ except print out the components of a sentence.  However, the hooks are
@c __ there, and the general technique is demonstrated.  Try expanding it to
@c __ take a more general type of sentence.  You can still break sentences
@c __ into mostly @code{VERB} and @code{NOUN} phrases, but you need to allow
@c __ for other types of sentence construction, such as possessive nouns, and
@c __ noun-noun phrases.  (Imagine how to parse something like @samp{FIND ALL
@c __ JONES'S CAT NAMES}.)  Refer to the @cite{Bison} manual for an
@c __ in-depth discussion of grammars and using them in Bison.
これは特別便利なものではありません。
というのは、
これは文章の構成要素を表示する以外に何も@emph{行わない}からです。
しかし、
そこには拡張のためのフックもありますし、
一般的な技法も示されています。
より一般的な形式の文章を受け付けるよう、
この例を拡張してみてください。
ほとんどの場合、
文章は動詞句（@code{VERB}）と名詞句（@code{NOUN}）に分割することができますが、
所有格名詞、
名詞の後ろに名詞が続く場合など、
文章を構成する他の要素も許容されるようにする必要があります。
（@samp{FIND ALL JONE'S CAT NAMES}のような文章をどうやってパースするかを想像してみてください。）
Bisonの文法やその使い方に関する詳しい説明については、
@cite{Bison}のマニュアルを参照してください。

@c +--------------------------------------------------------------------+
@c |                                                                    |
@c | Notes on how we implement the database language.                   |
@c |                                                                    |
@c +-----------------+-----------------+-----------------+--------------+ 
@c |       Name      |       Next      |     Previous    |       Up     |
@c +-----------------+-----------------+-----------------+--------------+ 
@c @node    The Implementation, Notes on the Implementation, The Database Language, Another Example of Flex and Bison
@node    The Implementation, Notes on the Implementation, The Database Language, Another Example of Flex and Bison
@c __ @subsection Implementation: Command Sentence Parser
@subsection 実装：コマンド文パーサ
@comment    #######################################

@c __ Above we described a simple language, now we move on to implementing it.
@c __ The following files accomplish this.
上の節で、
小規模な言語について説明しました。
次にそれを実装してみることにしましょう。
以下のファイルがこれを実現します。

@c __ @strong{Please note:} @emph{This is an example and should be looked upon
@c __ as such.  The grammar in particular is not a very good example of
@c __ parsing English.  }
@strong{注：}@emph{これはあくまでも１つの例として見てください。
特に文法の部分は、
英語のパース処理としてはあまり良い例ではありません。}

@pindex @code{front.y}
@c __ @i{This file is the Bison file.  Take note of the @code{%union}
@c __ part, and the way @code{$$} and @code{$}@i{n} are used to access
@c __ @code{yylval}.  }
@i{以下はBisonのファイルです。
@code{%union}の部分、
および、
@code{yylval}にアクセスするために@code{$$}と@code{$}@i{n}を使う方法に注目してください。}

@example
@group
@c __ /* C code supplied at the beginning of the file.  */
/* Cコードはファイルの先頭で提供する */

%@{

#include <stdio.h>                          
#include <string.h>

@c __ extern int  yylexlinenum;  /* these are in lex.yy.c   */
@c __ extern char *yytext;       /* current token           */
extern int  yylexlinenum;  /* lex.yy.cに存在する */
extern char *yytext;       /* カレント・トークン */

%@}

@end group
@group
@c __ /* Keywords and reserved words begin here.  */
/* キーワードと予約語がここから始まる */

@c __ %union@{                   /* This is the data union.  */
@c __     char   name[128];      /* Names.                   */
%union@{                    /* これはデータの共用体 */
    char   name[128];      /* 名前                 */
@}

@end group
@group
@c __ /*------------- the reserved words ------------------*/
/*------------- 予約語 ------------------*/

%token PERIOD
%token NEWLINE
%token POSITIONAL

@end group
@group
%token VERB
%token ADVERB

@end group
@group
%token PROPER_NOUN
%token NOUN

@end group
@group
%token DECLARATIVE
%token CONDITIONAL
@end group

@group
%type  <name> declarative
%type  <name> verb_phrase
%type  <name> noun_phrase
%type  <name> position_phrase
%type  <name> adverb

@end group
@group
%type  <name> POSITIONAL VERB ADVERB PROPER_NOUN 
%type  <name> NOUN DECLARATIVE CONDITIONAL

%%

@end group
@group
sentence_list : sentence
              | sentence_list NEWLINE sentence
              ;
@end group

@group
sentence : verb_phrase noun_phrase position_phrase 
           adverb period 
           @{
             printf("I understand that sentence.\n");
             printf("VP = %s \n",$1);
             printf("NP = %s \n",$2);
             printf("PP = %s \n",$3);
             printf("AD = %s \n",$4);
           @}
         | @{ yyerror("That's a strange sentence!");  @}
         ;

@end group
@group
position_phrase : POSITIONAL  declarative PROPER_NOUN 
                  @{
                    sprintf($$,"%s %s %s",$1,$2,$3);
                  @}   
@c __                 | /* empty */ @{ strcpy($$,""); @}
                | /* 空 */ @{ strcpy($$,""); @}
                ;
@end group

@group               
verb_phrase : VERB @{ strcpy($$,$1); strcat($$," "); @}
            | adverb VERB  
              @{
                sprintf($$,"%s %s",$1,$2);
              @}
            ;

@end group
@group
adverb : ADVERB      @{ strcpy($$,$1); @}
@c __        | /* empty */ @{ strcpy($$,""); @}
       | /* 空 */    @{ strcpy($$,""); @}
       ;

@end group
@group
noun_phrase : DECLARATIVE NOUN 
              @{
                sprintf($$,"%s %s",$1,$2);
              @}
@end group
@group
            | CONDITIONAL declarative NOUN 
              @{
                sprintf($$,"%s %s %s",$1,$2,$3);
              @}   
            | NOUN @{ strcpy($$,$1); strcat($$," "); @}
            ;

@end group
@group
declarative : DECLARATIVE @{ strcpy($$,$1); @}
@c __             | /* empty */ @{ strcpy($$,""); @}
            | /* 空 */    @{ strcpy($$,""); @}
            ;

@end group
@group
@c __ period : /* empty */
period : /* 空 */
       | PERIOD
       ;

%%

@end group
@group
@c __ /* Supplied main() and yyerror() functions.  */
/* main()およびyyerror()関数を提供する */

void main(int argc, char **argv)
@{
@c __   yyparse();       /* Parse the file.         */
  yyparse();       /* ファイルをパースする */
@}

@end group
@group
int yyerror(char *message)
@{
  extern FILE *yyout;

  fprintf(yyout,"\nError at line %5d.  (%s) \n",
                     yylexlinenum,message);
@}
@end group
@end example

@pindex @code{front.lex}
@c __ @i{This is the Flex file.  Note the way strings are passed.  This is not
@c __ the optimal way, but is the easiest to understand.  }
@i{以下はFlexのファイルです。
文字列が渡される方法に注意してください。
これは最適化された方法ではありませんが、
最も理解しやすい方法です。}

@example
@group
%@{
#include <stdio.h>
#include <string.h>
@c __ #include "y.tab.h"      /* This comes from Bison.     */
#include "y.tab.h"      /* これはBisonにより生成される */

@end group
@group
#define TRUE  1
#define FALSE 0

@end group
@group
#define copy_and_return(token_type) \
         @{ \
             strcpy(yylval.name,yytext);\
             return(token_type); \
         @}

@c __ int yylexlinenum = 0;  /* So we can count lines.      */
int yylexlinenum = 0;  /* 行数カウント用 */
%@}

@end group
@group
%%
@c __    /* Lexical scanning rules begin from here.  */
   /* 字句解析ルールがここから始まる */

MEN|WOMEN|STOCKS|TREES      copy_and_return(NOUN)
MISTAKES|GNUS|EMPLOYEES     copy_and_return(NOUN)
LOSERS|USERS|CARS|WINDOWS   copy_and_return(NOUN)

@end group
@group
DATABASE|NETWORK|FSF|GNU    copy_and_return(PROPER_NOUN)
COMPANY|HOUSE|OFFICE|LPF    copy_and_return(PROPER_NOUN)

@end group
@group
THE|THIS|THAT|THOSE         copy_and_return(DECLARATIVE)

ALL|FIRST|LAST              copy_and_return(CONDITIONAL)

@end group
@group
FIND|SEARCH|SORT|ERASE|KILL copy_and_return(VERB)
ADD|REMOVE|DELETE|PRINT     copy_and_return(VERB)

QUICKLY|SLOWLY|CAREFULLY    copy_and_return(ADVERB)

@end group
@group
IN|AT|ON|AROUND|INSIDE|ON   copy_and_return(POSITIONAL)

"."                         return(PERIOD);                             
"\n"                        yylexlinenum++; return(NEWLINE);            
.  
%%
@end group
@end example

@noindent
@c __ These files may be compiled by typing:
これらのファイルは、
以下を実行することでコンパイルできます。

@example
@group
% bison -d front.y
% flex -I front.lex
% cc -o front alloca.c front.tab.c lex.yy.c
@end group
@end example

@noindent
@c __ or, if you have the source for the examples, by typing @samp{make front}
@c __ in the @file{examples} sub-directory.
または、
この例のソースが手元にあれば、
@file{examples}サブディレクトリにおいて@samp{make front}を実行することでもコンパイルできます。

@c __ @strong{Please note:} @emph{@file{alloca.c} is needed by the Bison
@c __ parser, and is included in the examples sub-directory.  If you use
@c __ @code{yacc} instead of Bison, you do not need this.  }
@strong{注：}@emph{Bisonパーサは@file{alloca.c}というファイルを必要とします。
このファイルはexamplesサブディレクトリにあります。
Bisonの代わりに@code{yacc}を使うのであれば、
このファイルは必要ありません。}

@c +--------------------------------------------------------------------+
@c |                                                                    |
@c | Disclaimers (mostly) and notes on the database implementation      |
@c |                                                                    |
@c +-----------------+-----------------+-----------------+--------------+ 
@c |       Name      |       Next      |     Previous    |       Up     |
@c +-----------------+-----------------+-----------------+--------------+ 
@c @node    Notes on the Implementation,  , The Implementation, Another Example of Flex and Bison
@node    Notes on the Implementation,  , The Implementation, Another Example of Flex and Bison
@c __ @subsection Notes on the Implementation
@subsection 実装に関する注
@comment    ###########################

@c __ Here are a few notes on the implementation.  
以下に実装に関する注を示します。

@itemize @bullet{}
@tindex @code{YYSTYPE}
@c __ @item @code{YYSTYPE} @b{and} @code{yylval} @*
@item @code{YYSTYPE} @b{と} @code{yylval} @*
@c __ Take note of the way @code{yylval} is accessed from Flex.  Passing data
@c __ up a parse tree in a Bison grammar is covered in the @cite{Bison}
@c __ manual, and does not affect Flex at all.  Integer values, floating point
@c __ numbers, and any other kinds of data can be passed back in the same way.
@code{yylval}がFlexからアクセスされる方法に注目してください。
Bison文法においてパース・ツリーの上位にデータを渡す方法については、
@cite{Bison}のマニュアルに説明されていますが、
Flexに対しては何の影響も持ちません。
整数値、浮動小数点数値、および他の任意の型のデータも同様の方法で返すことができます。

@c __ @item @b{Returning token values} @*
@item @b{トークン値の返却} @*
@c __ Note that in the example, both token values and string values are passed
@c __ back to Bison so that both the @emph{type} of the token, and its
@c __ value can be accessed in Bison.
この例では、
トークンの@emph{型}と値の両方がBisonからアクセスできるように、
トークンの値と文字列の値の両方がBisonに返されていることに注意してください。

@c __ @item @b{Bison and Flex} @*
@item @b{BisonとFlex} @*
@c __ Note how well Bison and Flex fit together.  Apart from the code
@c __ dealing with data exchange there is no other interface code.  Bison
@c __ calls @code{yylex()} and the scanner provides the token definitions.
BisonとFlexがいかにうまく調和しているかに注目してください。
データを交換するためのコード以外に、
インターフェイスのためのコードは一切ありません。
Bisonは@code{yylex()}を呼び出し、
スキャナがトークン定義を提供しています。
@end itemize

@c Include Flex 2.5 information, for Flex manual as published by ASCII
@c @ifset INCLUDEFLEX25INFO
@node Flex and C++ (Flex 2.5),  , Another Example of Flex and Bison, Interfacing to Flex
@section FlexとC++（Flex 2.5の補足情報）
@include c++_addendum-ja.texi
@c @end ifset

@c +--------------------------------------------------------------------+
@c |                                                                    |
@c | This node explains other features present in Flex.                 |
@c |                                                                    |
@c +-----------------+-----------------+-----------------+--------------+ 
@c |       Name      |       Next      |     Previous    |       Up     |
@c +-----------------+-----------------+-----------------+--------------+ 
@c @node    Other Flex Features, Optimization, Interfacing to Flex, Top
@node    Other Flex Features, Optimization, Interfacing to Flex, Top
@c __ @chapter Other Features of Flex
@chapter Flexの他の特徴
@comment ######################
@c __ @cindex  Special Flex features
@cindex  特殊なFlex機能

@quotation
@c __ @i{This section covers features that either are not present in Lex or
@c __ features that are not commonly used.  Flex is almost 100% compatible
@c __ with Lex, but, since it was implemented after Lex, it provides superior
@c __ performance and special features that make creating versatile scanners
@c __ easier.}
@i{ここでは、
Lexが提供していない機能や一般にはあまり使われない機能を説明します。
Flexはほぼ100パーセントLex互換ですが、
Lexよりも後に実装されたため、
性能的により優れており、
また、
広範な用途に使えるスキャナをより簡単に作成することができるよう、
特別な機能を提供しています。}
@end quotation

@ifnottex
========================================================================
@c __ @menu
@c __ * Case Insensitive Scanners::   About scanners that ignore case.  
@c __ * Interactive Scanners::        Scanners for taking input from a user.  
@c __ * Table Compression and Scanner Speed::  Table compression and scanner speed
@c __ * Translation Tables::          Another way of grouping characters.  
@c __ * Multiple Input Buffers::      How to accept multiple input streams.  
@c __ * End-Of-File Rules::           Special rules for handling EOF.  
@c __ @end menu
@menu
* Case Insensitive Scanners::   大文字・小文字を区別するスキャナ
* Interactive Scanners::        ユーザから入力を受け取るスキャナ
* Table Compression and Scanner Speed::  テーブル圧縮とスキャナのスピード
* Translation Tables::          文字をグループ化する別の方法
* Multiple Input Buffers::      複数の入力ストリームを受け付ける方法
* End-Of-File Rules::           EOFを処理するための特殊なルール
@end menu
========================================================================
@end ifnottex

@c +--------------------------------------------------------------------+
@c |                                                                    |
@c | Explaining the -i command line switch                              |
@c |                                                                    |
@c +-----------------+-----------------+-----------------+--------------+ 
@c |       Name      |       Next      |     Previous    |       Up     |
@c +-----------------+-----------------+-----------------+--------------+ 
@c @node    Case Insensitive Scanners, Interactive Scanners, Other Flex Features, Other Flex Features
@node    Case Insensitive Scanners, Interactive Scanners, Other Flex Features, Other Flex Features
@c __ @section Case Insensitive Scanners
@section 大文字・小文字を区別しないスキャナ
@comment #########################
@c __ @cindex  Case, ignoring
@cindex  大文字・小文字の無視

@c __ Many languages ignore case in their identifiers (Pascal, @sc{basic},
@c __ @sc{fortran}, etc.).  There are ways for specifying case-insensitive
@c __ scanners in Lex, but they are generally ugly and difficult to
@c __ understand.  One may define a long list of definitions replacing each
@c __ letter, or create a rule that accepts all identifiers, converts their
@c __ case, and then returns the type of the token.  The following code
@c __ demonstrates these two methods.  With definitions, one could use:
多くの言語は、
その識別子において大文字・小文字を区別しません（Pascal、@sc{basic}、@sc{fortran}等）。
Lexにも、
大文字・小文字を区別しないスキャナを指定するための方法がありますが、
それらは概して美しくなく、
理解するのも困難です。
個々の文字を置き換えてくれる定義を、
長いリストにして作成することも可能ですし、
すべての識別子を受け付ける１つのルールを作成し、
そのルールにおいて大文字・小文字を変換してから、
トークンの種類を返すようにすることも可能です。
以下のコードは、
この２つの方法を示すものです。
定義を使うのであれば、以下のようになります。

@example
@group
A [aA]
B [bB]
 @dots{}  
Z [zZ]

@end group
@group
%%
@{B@}@{E@}@{G@}@{I@}@{N@}      return(BEGIN_SYM);
@{E@}@{N@}@{D@}            return(END_SYM);
@end group
@end example

@noindent
@c __ To perform a similar operation using subroutines, use:
これに似た操作をサブルーチンで実行するのであれば、
以下のようにします。

@example
@group
ALPHA      [a-zA-Z]
NUM        [0-9]
ALPHANUM   @{ALPHA@}|@{NUM@}

@end group
@group
%%
@{ALPHA@}@{ALPHANUM@}*     return(convert_and_lookup(yytext));
@end group
@end example

@noindent
@c __ though this is less efficient because of the need for a function call
@c __ (pattern complexity has little effect for Flex).
もっともこれは、
関数呼び出しの必要があるため、
効率が悪くなります
（Flexでは、
パターンの複雑さは大した影響をもたらしません）。

@noindent
@c __ There are other ways of doing this, but none of them are elegant.  
ほかにもこれと同じことを行う方法がありますが、
いずれもエレガントではありません。

@ifnottex
========================================================================
@c __ @menu
@c __ * The -i Switch::               How to ignore case in input.
@c __ @end menu
@menu
* The -i Switch::               入力において大文字・小文字を無視する方法
@end menu
========================================================================
@end ifnottex

@c +--------------------------------------------------------------------+
@c |                                                                    |
@c | Explaining the -i command line switch                              |
@c |                                                                    |
@c +-----------------+-----------------+-----------------+--------------+ 
@c |       Name      |       Next      |     Previous    |       Up     |
@c +-----------------+-----------------+-----------------+--------------+ 
@c @node The -i Switch,  , Case Insensitive Scanners, Case Insensitive Scanners
@node The -i Switch,  , Case Insensitive Scanners, Case Insensitive Scanners
@c __ @subsection The @samp{-i} Switch
@subsection @samp{-i}オプション
@comment    ####################

@c __ @vindex @kbd{-i}@r{, in detail}
@vindex @kbd{-i}@r{、詳細}
@c __ Flex has a very simple way of solving this problem.  By using the
@c __ @samp{-i} switch on the command line, you can tell Flex to generate a
@c __ scanner that ignores case in its input.  This means that in Flex you do
@c __ not have to use either of the techniques above.  For example:
Flexは、
この問題を簡単に解決するための方法を提供しています。
コマンドラインで@samp{-i}オプションを使うことによって、
入力情報の大文字・小文字を区別しないスキャナを生成するよう、
Flexに対して通知することができます。
つまり、
Flexでは上記のようなテクニックを使う必要がないということを意味しています。
例えば、

@example
@group
%%
begin        return(BEGIN_SYM);
end          return(END_SYM);
@end group
@end example

@noindent
@c __ will match on @samp{BEGIN}, @samp{begin}, @samp{BeGiN}, or any other mix
@c __ of case if you use the @samp{-i} switch.  This is much simpler than the
@c __ Lex way of doing things.
は、
@samp{-i}オプションを使うことによって、
@samp{BEGIN}、@samp{begin}、@samp{BeGiN}、およびこれ以外のすべての大文字・小文字の組み合わせにマッチします。
これは、
Lexにおいて同様のことを行うための方法よりも、
はるかに簡単です。

@c __ There is one caveat with the @samp{-i} option: the scanner ignores the
@c __ case but @emph{does not convert it}.  This means that if you want to
@c __ hash symbol names in Pascal, you will have to convert them to upper or
@c __ lower case, otherwise, @samp{FOO} and @samp{foo} will be treated
@c __ differently.  This can be taken care of in either the symbol storage
@c __ routine, or by using @code{YY_USER_ACTION}.  Refer to the explanation of
@c __ @code{YY_USER_ACTION} in @ref{Flex and C}, for an example of how to do
@c __ this.
@samp{-i}オプションには１つ注意すべき点があります。
それは、
スキャナが大文字・小文字を区別しないだけで、
その@emph{変換まではしてくれない}ということです。
つまり、
Pascalにおいてシンボル名をハッシュしたいような場合、
自分でシンボル名を大文字または小文字に変換しなければならないことを意味しています。
そうしないと、
@samp{FOO}と@samp{foo}は異なるものとして扱われます。
これは、
シンボルを保存するルーチンの中で対処することもできますし、
@code{YY_USER_ACTION}を使うことによって対処することもできます。
これを実現する方法の例については、
@ref{Flex and C}における@code{YY_USER_ACTION}の説明を参照してください。

@c +--------------------------------------------------------------------+
@c |                                                                    |
@c | What interactive scanners are used for, and how to make them.      |
@c |                                                                    |
@c +-----------------+-----------------+-----------------+--------------+ 
@c |       Name      |       Next      |     Previous    |       Up     |
@c +-----------------+-----------------+-----------------+--------------+ 
@c @node    Interactive Scanners, Table Compression and Scanner Speed, Case Insensitive Scanners, Other Flex Features
@node    Interactive Scanners, Table Compression and Scanner Speed, Case Insensitive Scanners, Other Flex Features
@c __ @section The @samp{-I} Switch: Interactive Scanners
@section @samp{-I}オプション：対話型スキャナ
@comment ####################################
@c __ @cindex  Scanning typed input
@c __ @cindex  Typed input
@cindex  型付けされた入力のスキャン処理
@cindex  型付けされた入力
@c __ @vindex @kbd{-I}@r{, in detail}
@vindex @kbd{-I}@r{、詳細}
@c __ @cindex  Interactive scanners
@c __ @cindex  Scanners, interactive
@cindex  対話型スキャナ
@cindex  スキャナ、対話型

@c __ One problem with Flex is its need to look ahead one character in the
@c __ input before deciding what rule to apply.  While this is not a problem
@c __ for non-interactive use, using Flex to receive characters from a user
@c __ can be problematic.
Flexの問題として、
どのルールを適用するかを決定する前に、
入力情報中の次の１文字を先読みする必要があるということがあります。
対話的ではない使い方をする場合には問題になりませんが、
Flexを使ってユーザから直接入力文字を受け取るような場合には、
問題になることがあります。

@c __ Two such occasions are dealing with a shell or a database front end.
@c __ The normal action is for the newline to signify the end of the input,
@c __ and it is desirable to accept the newline by itself as a kind of ``empty
@c __ statement.'' For normal Flex scanners, this is not possible.  The fact
@c __ that Flex always looks ahead means that the user must type another line
@c __ for the newline to be recognized (i.e., a single newline by itself will
@c __ not be recognized; other characters need to be typed).  This is hardly
@c __ desirable in a shell.
このような場合を２つ挙げると、
１つはシェルとやりとりする場合、
もう１つはデータベースのフロント・エンドとやりとりする場合です。
通常のアクションは、
改行が入力の終わりを表すというもので、
改行自身は一種の「中身のない文」として受け付けるのが望ましいのですが、
通常のFlexスキャナではこれは可能ではありません。
Flexが常に先読みをするという事実は、
改行が認識されるためにはユーザが次の行を入力しなければならないということを意味しています
（すなわち、
単一の改行は、
それだけでは認識されず、
他の文字が入力される必要があるということです）。
これはシェル上ではまったく望ましくありません。

@c __ Flex does have a way of getting around this.  If you use the @samp{-I}
@c __ switch on the command line, Flex will create a special
@c __ @emph{interactive} scanner that only looks ahead when needed.  This kind
@c __ of scanner is suitable for getting input directly from a user, but may
@c __ suffer a minor performance penalty.
Flexにはこれを回避する方法があります。
コマンドラインで@samp{-I}オプションを使うと、
Flexは、
必要な場合にしか先読みをしない特別な@emph{対話型}スキャナを生成します。
この種のスキャナは、
ユーザからの入力を直接受け取るのに適していますが、
若干の性能低下を引き起こすかもしれません。

@c __ @strong{Please note:} @i{The @samp{-I} option cannot be used with the
@c __ @samp{-f}, @samp{-F}, @samp{-Cf}, or @samp{-CF} flags.  This means that
@c __ in addition to the performance penalty from not being able to look
@c __ ahead, the parser cannot be optimized for speed.  }
@strong{注：}@i{@samp{-I}オプションは、
@samp{-f}、@samp{-F}、@samp{-Cf}、または@samp{-CF}フラグと一緒に使うことはできません。
つまり、
先読みができないことから来る性能低下に加えて、
パーサも性能向上のために最適化することができないということを意味しています。}

@c __ The penalty associated with the @samp{-I} option is generally minimal so
@c __ if you are unsure about where your input will come from, and you are
@c __ willing to give up the ability to optimize for speed, it is better to
@c __ put the @samp{-I} flag in the command line.
@samp{-I}オプションに関連するマイナス面は、
通常はきわめて小さいので、
入力情報がどこから来るのか確かではなく、
性能向上のための最適化を施す可能性を諦めても構わないのであれば、
コマンドラインにおいて@samp{-I}オプションを使う方が良いでしょう。

@c +--------------------------------------------------------------------+
@c |                                                                    |
@c | Notes on the compression options in Flex.                          |
@c |                                                                    |
@c +-----------------+-----------------+-----------------+--------------+ 
@c |       Name      |       Next      |     Previous    |       Up     |
@c +-----------------+-----------------+-----------------+--------------+ 
@c @node    Table Compression and Scanner Speed, Translation Tables, Interactive Scanners, Other Flex Features
@node    Table Compression and Scanner Speed, Translation Tables, Interactive Scanners, Other Flex Features
@c __ @section Table Compression and Scanner Speed
@section テーブルの圧縮とスキャナのスピード
@comment ###################################
@c __ @cindex  Compressing tables
@c __ @cindex  Scanning speed
@cindex  テーブルの圧縮
@cindex  スキャン処理のスピード

@c __ In the area of table compression, and speed, Flex far exceeds the
@c __ capabilities of Lex; it can generate much faster or much smaller tables
@c __ than Lex, depending upon which options are used.  This section explains
@c __ the options available, and their effect on speed.  Generally, the more a
@c __ table is compressed, the slower it becomes.  In Flex these options are
@c __ given on the command line.  The switches are:
テーブルの圧縮とスピードの領域では、
FlexはLexの能力をはるかに上回っています。
Flexは、
使われるオプションに応じて、
Lexよりもはるかに高速なテーブル、
あるいは、
はるかに小さいテーブルを生成することができます。
この節では、
利用可能なオプションと各オプションがスピードにもたらす影響について説明します。
一般的には、
テーブルが圧縮されるほど、
そのスピードは遅くなります。
Flexでは、
こうしたオプションをコマンドラインで指定します。
@c @ifset INCLUDEFLEX25INFO
オプションは以下のとおりです。@footnote{訳注：Flex 2.5では、
ここに列挙されているもの以外に、
@samp{-Ca}オプションをサポートしています。
これについては、
@ref{Command Line Switches (Flex 2.5)}を参照してください。}
@c @end ifset
@c @ifclear INCLUDEFLEX25INFO
@c オプションは以下のとおりです。
@c @end ifclear

@itemize
@table @kbd
@c __ @vindex  @samp{-f}@r{, in detail}
@vindex  @samp{-f}@r{、詳細}
@c __ @item -f @i{or} -Cf 
@item -f@i{または}-Cf 
@c __ This option specifies that Flex should generate @dfn{full} tables.  The
@c __ tables are not compressed at all and are large, but fast. Note that
@c __ @code{REJECT} cannot be part of an action if these options are
@c __ specified.
このオプションは、
Flexが@dfn{フル}・テーブル（@dfn{full} table）を生成すべきであることを指定します。
このテーブルはまったく圧縮されず、
サイズが大きくなりますが、
スピードは速くなります。
このオプションが指定された場合は、
アクションの部分に@code{REJECT}を使うことはできない点に注意してください。

@c __ @b{Please note:} @i{The @samp{-f} and @samp{-F} flags differ in the
@c __ tables that are generated by Flex. The @samp{-f} flag generates @strong{full}
@c __ tables, and the @samp{-F} flags generates @strong{fast} tables. Fast
@c __ tables are an alternate table form optimized for speed, whereas full
@c __ tables have no optimizations performed on them. The results are similar,
@c __ but table sizes can be very different.}
@b{注：}@i{@samp{-f}フラグと@samp{-F}フラグは、
Flexが生成するテーブルにおいて相違をもたらします。
@samp{-f}フラグは@strong{フル}・テーブル（@strong{full} table）を生成し、
@samp{-F}フラグは@strong{ファスト}・テーブル（@strong{fast} table）を生成します。
ファスト・テーブルとは、
スピードを最大限にするよう最適化されたテーブル形式であり、
一方、
フル・テーブルには最適化は一切施されません。
もたらされる結果はよく似ていますが、
テーブルのサイズは大きく異なるものになる可能性があります。}

@c __ @vindex  @samp{-F}@r{, in detail}
@vindex  @samp{-F}@r{、詳細}
@c __ @item -F @i{or} -CF
@item -F@i{または}-CF
@c __ This option tells Flex to generate tables using the @dfn{fast} table
@c __ representation.  Generally, these tables are about as fast as the
@c __ full tables described above, but may be much smaller or larger,
@c __ depending on the patterns used.  As a rule, if you have a file that has
@c __ a list of keywords, as well as a rule to catch all identifiers, then you
@c __ should use the @samp{-f} option.  For example,
このオプションは@dfn{ファスト}・テーブル（@dfn{fast} table）形式を用いてテーブルを生成するようFlexに通知します。
一般的には、
このテーブルのスピードは先に説明したフル・テーブル（full table）とほとんど同じですが、
使われるパターンに応じて、
そのサイズは小さくも大きくもなる可能性があります。
原則として、
すべての識別子をキャッチするルールのほかにキーワードの一覧も持つファイルに対しては、
@samp{-f}オプションを使うべきです。
例えば、

@c __ @findex @code{ECHO}@r{, sample}
@findex @code{ECHO}@r{、サンプル}
@example
@group
ALPHA     [a-zA-Z]
NUM       [0-9]
ALPHANUM  @{ALPHA@}|@{NUM@}
%%
begin                  return(BEGIN_SYM);
  @dots{}  @var{rules and actions} @dots{}  
end                    return(END_SYM);
@{ALPHA@}@{ALPHANUM@}* return(IDENTIFIER);
@end group
@end example 

@noindent
@c __ should be processed with the @samp{-f} flag, whereas
は@samp{-f}フラグを使って処理すべきであり、

@example
@group
@{ALPHA@}@{ALPHANUM@}* @{ECHO; 
                    return(lookup(yytext));@}
@end group
@end example

@noindent
@c __ should be processed using the @samp{-F} flag.  Note that @code{REJECT}
@c __ cannot be part of an action if these options are specified.
は@samp{-F}フラグを使って処理すべきです。
これらのオプションが指定されている場合は、
アクションの部分に@code{REJECT}を使うことができない点に注意してください。

@c __ @cindex Equivalence classes
@cindex 同等クラス
@c __ @vindex  @samp{-Ce}@r{, in detail}
@vindex  @samp{-Ce}@r{、詳細}
@item -Ce
@c __ This option can reduce the table sizes considerably, though performance
@c __ is affected slightly.  When @samp{-Ce} is used, Flex creates
@c __ @dfn{equivalence classes}.  An equivalence class is a group of
@c __ characters that are used in an identical manner.  For example, if digits
@c __ appear only inside the set @code{[0-9]} then the numbers 0 through 9
@c __ will be put into an equivalence class.
このオプションを使うと、
性能にはわずかしか影響を及ぼさずに、
テーブルのサイズをかなり小さくすることができます。
@samp{-Ce}が使われると、
Flexは@dfn{同等クラス}（@dfn{equivalence classes}）を作成します。
同等クラスとは、
同一の方法で使われる文字のグループです。
例えば、
使われる数字が集合@code{[0-9]}の範囲に限定されるのであれば、
0から9までの数は同等クラスの中に置かれることになります。

@c __ @vindex @kbd{-Cf}@r{, in detail}
@c __ @vindex @kbd{-CF}@r{, in detail}
@vindex @kbd{-Cf}@r{、詳細}
@vindex @kbd{-CF}@r{、詳細}
@item -Cfe,-CFe 
@c __ Fast tables with equivalence classes.  The scanners generated with this
@c __ option are also fast, but they can be much smaller than those generated
@c __ when @samp{-Cf} or @samp{-CF} were specified.  Unless size or speed are
@c __ paramount, this is a good combination.
同等クラスを持つファスト・テーブルです。
このオプションによって生成されたスキャナもまた高速であり、
かつ、
@samp{-Cf}あるいは@samp{-CF}を指定して生成されたスキャナと比較して、
サイズもはるかに小さくなる可能性があります。
サイズ、
またはスピードの一方が他方に比べてはるかに重要であるということがないのであれば、
これは良い組み合わせです。

@c __ @cindex Meta-equivalence classes
@cindex メタ同等クラス
@c __ @vindex @kbd{-Cm}@r{, in detail}
@vindex @kbd{-Cm}@r{、詳細}
@item -Cm
@c __ This tells Flex to use @dfn{meta-equivalence classes}.  These are sets of
@c __ characters or equivalence classes (if they are being used) that are
@c __ often used together.  Performance suffers more than if equivalence
@c __ classes are used, but this is often a very effective way to reduce table
@c __ size.
Flexに対して@dfn{メタ同等クラス}（@dfn{meta-equivalence classes}）を使うよう通知します。
これは、
一緒に使われることが多い文字の集合、
または
（同等クラスが使われている場合には）
同等クラスです。
同等クラスを使う場合よりも性能はさらに悪くなりますが、
これは多くの場合、
テーブル・サイズを小さくするのに非常に効果的な方法です。

@c __ @vindex @kbd{-Cem}@r{, in detail}
@vindex @kbd{-Cem}@r{、詳細}
@item -Cem 
@c __ Default table compression.  The scanners generated with this option in
@c __ effect are the smallest, and slowest that Flex can generate.
デフォルトのテーブル圧縮です。
このオプションで生成されるスキャナは、
Flexが生成するスキャナの中で事実上最も小さく、
かつ、
最も性能の劣るものになります。

@item -C 
@c __ The @samp{-C} option by itself just tells Flex to compress the tables,
@c __ without using equivalence or meta-equivalence classes.
@samp{-C}オプション単体では、
同等クラスやメタ同等クラスを使わずにテーブルを圧縮するよう、
Flexに対して通知します。
@end table
@end itemize

@c __ @strong{Please Note:} Only one @samp{-C@var{xx}} option should appear on
@c __ the command line because only the last switch encountered has any
@c __ effect.  So
@strong{注：}@samp{-C@var{xx}}オプションは、
コマンドライン上には１つだけ指定すべきです。
というのは、
このうち最後に見つかったオプションだけが実際の効果を持つからです。
したがって、

@example
flex -Cf -Cem foo.l
@end example

@noindent
@c __ will cause Flex to use the @samp{-Cem} option.  
は、
Flexに@samp{-Cem}オプションを使わせることになります。

@c __ The default behavior of Flex corresponds to using the @samp{-Cem}
@c __ switches on the command line.  This provides the maximum amount of
@c __ compression and, generally, the slowest scanners.  These smaller tables
@c __ are generated more quickly, and compile faster, so the default is very
@c __ useful during development.  After the scanner has been debugged, you can
@c __ produce a faster (and usually larger) scanner.
Flexのデフォルトの動作は、
コマンドライン上で@samp{-Cem}オプションを使った場合に相当します。
この動作では圧縮を最大限に行うことになり、
一般的には最も遅いスキャナが生成されることになります。
こうした小さなテーブルはより速く生成され、
コンパイルもより速く実行されるので、
デフォルトは、
開発段階では非常に便利です。
スキャナのデバッグが終了した後は、
より高速な
（そして通常はよりサイズの大きい）
スキャナを作成することができます。

@c +--------------------------------------------------------------------+
@c |                                                                    |
@c | Notes on translation tables.                                       |
@c |                                                                    |
@c | Vern recommended getting rid of this section.  I basically agree   |
@c | as these are really a poxy misfeature.  However, some people *may* |
@c | want to know about them, so I left it in.....                      |
@c |                                                                    |
@c +-----------------+-----------------+-----------------+--------------+ 
@c |       Name      |       Next      |     Previous    |       Up     |
@c +-----------------+-----------------+-----------------+--------------+ 
@c @node    Translation Tables, Multiple Input Buffers, Table Compression and Scanner Speed, Other Flex Features
@node    Translation Tables, Multiple Input Buffers, Table Compression and Scanner Speed, Other Flex Features
@c __ @section Translation Tables
@section 翻訳テーブル
@comment ##################
@c __ @cindex  Translation tables
@cindex  翻訳テーブル

@c __ Translation tables are used to map characters into groups.  They are
@c __ part of Lex, but not part of POSIX.  While Flex allows translation
@c __ tables, they are an unsupported feature.  Translation table are
@c __ unnecessary in Flex as the Flex equivalence classes, with the @samp{-i}
@c __ switch, can accomplish the same thing 
@c __ (@pxref{The -i Switch, , The @samp{-i} Switch}).  
@c __ The translation table functionality is really just an extra feature that is
@c __ there for compatibility's sake.  The use of translation tables is
@c __ @emph{not} recommended.  If you want to use translation tables, they
@c __ must be defined in the definition section at the top of the definition
@c __ file.
翻訳テーブルは、
文字をグループにマップするのに使われます。
このテーブルはLexの持つ機能の１つですが、
POSIXでは定義されていません。
Flexでも翻訳テーブルを使うことはできますが、
サポート対象外の機能です。
Flexにおいては翻訳テーブルは不要です。
というのは、
Flexには@samp{-i}オプションによる同等クラスというものがあり、
これが翻訳テーブルと同等の機能を実現しているからです
（@pxref{The -i Switch, , @samp{-i}オプション}）。
翻訳テーブルの機能は、
互換性のためだけに存在する余分な機能です。
翻訳テーブルを使うことは@emph{お勧めできません}。
翻訳テーブルを使いたいのであれば、
定義ファイルの先頭の定義セクションにおいて定義しなければなりません。

@noindent
@c __ The general form for such tables is:
翻訳テーブルの一般的な形式は以下のとおりです。

@example
@group
%t 
1 ABCDEFGHIJKLMNOPQRSTUVWXYZ
2 0123456789
%t
%%
@end group
@end example

@noindent
@c __ which means that if any character from @samp{A} to @samp{Z} is used in a
@c __ rule, then the pattern will match @emph{any} character from @samp{A} to
@c __ @code{Z}, so that @samp{A(BC)} and @samp{X(YZ)} are exactly the same.
これは、
@samp{A}から@samp{Z}までの任意の文字がルールの中で使われている場合、
そのパターンは@samp{A}から@samp{Z}までの@emph{どの}文字にもマッチするということを意味しています。
したがって、
@samp{A(BC)}と@samp{X(YZ)}はまったく同一であるということになります。

@c +--------------------------------------------------------------------+
@c |                                                                    |
@c | The following introduces the need and problems associated with     |
@c | multiple input buffers.                                            |
@c |                                                                    |
@c +-----------------+-----------------+-----------------+--------------+ 
@c |       Name      |       Next      |     Previous    |       Up     |
@c +-----------------+-----------------+-----------------+--------------+ 
@c @node    Multiple Input Buffers, End-Of-File Rules, Translation Tables, Other Flex Features
@node    Multiple Input Buffers, End-Of-File Rules, Translation Tables, Other Flex Features
@c __ @section Multiple Input Buffers
@section 複数の入力バッファ
@comment ######################
@c __ @cindex  Input buffers
@c __ @cindex  Changing the input 
@c __ @cindex  Manipulating buffers
@c __ @cindex  Buffers, using multiple
@cindex  入力バッファ
@cindex  入力の変更
@cindex  バッファの操作
@cindex  バッファ、複数

@c __ There are many situations where it is necessary for a scanner to be able
@c __ to handle input from more than one file.  For example, many Pascal
@c __ implementations allow files to be included at compile time, and in C,
@c __ the scanner or preprocessor must be able to deal with the
@c __ @code{#include} statement.  What this means is that the scanner must be
@c __ able to save the current scanning @dfn{context}, change to a new
@c __ context, and later return to exactly where it was before.
スキャナが、
複数のファイルからの入力を処理することができるということが必要になる状況は、
たくさんあります。
例えば、
多くのPascalの実装では、
コンパイル時に複数のファイルを取り込むことを許していますし、
Cでは、
スキャナもしくはプリプロセッサが@code{#include}文を処理できなければなりません。
このことが意味しているのは、
スキャナは、
カレントなスキャン処理の@dfn{コンテキスト}を保存してから新しいコンテキストに変更し、
その後で、
以前の状態と完全に一致する状態に復帰することができなければならないということです。

@c __ A Flex scanner uses a large input buffer which makes it necessary to
@c __ perform extra processing to maintain scanning contexts.  However, Flex
@c __ provides some special features which make it very easy to create, switch
@c __ among, and delete multiple input buffers.
Flexスキャナは、
スキャン処理のコンテキストを維持するために余分の処理が必要になるような、
大きな入力バッファを使っています。
しかしFlexは、
複数の入力バッファの作成、切り替え、削除が非常に簡単に行えるような特別な機能を提供しています。

@ifnottex
========================================================================
@c __ @menu
@c __ * Buffer Manipulation::         Buffer manipulation functions
@c __ * Example of Multiple Buffers::  An example of using multiple buffers
@c __ @end menu
@menu
* Buffer Manipulation::         バッファ操作関数
@c @ifset INCLUDEFLEX25INFO
* Buffer Manipulation (Flex 2.5)::  同上（Flex 2.5の補足情報）
@c @end ifset
* Example of Multiple Buffers::  複数バッファを使う実例
@end menu
========================================================================
@end ifnottex

@c +--------------------------------------------------------------------+
@c |                                                                    |
@c | The following section explains the multiple buffer handling        |
@c | functions of Flex                                                  |
@c |                                                                    |
@c +-----------------+-----------------+-----------------+--------------+ 
@c |       Name      |       Next      |     Previous    |       Up     |
@c +-----------------+-----------------+-----------------+--------------+ 
@c @node Buffer Manipulation, Example of Multiple Buffers, Multiple Input Buffers, Multiple Input Buffers
@node Buffer Manipulation, Buffer Manipulation (Flex 2.5), Multiple Input Buffers, Multiple Input Buffers
@c __ @subsection Buffer Manipulation Functions
@subsection バッファを操作する関数
@c          #############################

@c __ Flex provides the following functions and macros for dealing with
@c __ multiple input buffers:
Flexは、
複数の入力バッファを取り扱うために、
以下のような関数やマクロを提供しています。

@itemize
@table @code
@findex @code{yy_create_buffer()}
@item YY_BUFFER_STATE yy_create_buffer( FILE *file, int size)
@c __ Creates a buffer for @code{file} which is large enough to hold
@c __ @code{size} characters.  The function returns a handle which may later
@c __ be used to switch between buffers, or to delete the newly created
@c __ buffer.
@code{file}で指定されるファイルのために、
@code{size}で指定される数の文字を格納するのに十分な大きさのバッファを作成します。
この関数は、
後に複数のバッファ間の切り替え、
または新規に作成されたバッファの削除に使うことのできるハンドルを返します。

@tindex @code{YY_BUF_SIZE}
@item YY_BUF_SIZE 
@c __ A macro that defines a default buffer size.  If you do not know what
@c __ size you should pass to @code{yy_create_buffer()}, you can use this.
デフォルトのバッファ・サイズを定義するマクロです。
@code{yy_create_buffer()}に渡すべきサイズが分からない場合に、
これを使うことができます。

@c __ @findex @code{yy_switch_to_buffer()}@r{, in detail}
@findex @code{yy_switch_to_buffer()}@r{、詳細}
@item void yy_switch_to_buffer( YY_BUFFER_STATE new_buffer)
@c __ Switches between buffers.  The next token read will come from
@c __ @code{new_buffer}, and tokens will be read from @code{new_buffer} until
@c __ it reaches end-of-file (EOF), or until the next call to
@c __ @code{yy_switch_to_buffer()}.  When @code{new_buffer} reaches EOF, it is
@c __ possible to switch to a new buffer.
バッファを切り替えます。
次に読み込まれるトークンは、
@code{new_buffer}で指定されるバッファから取られます。
ファイルの終端（EOF）に達するか、
次に@code{yy_switch_to_buffer()}が呼び出されるまで、
@code{new_buffer}からトークンが読み込まれます。
@code{new_buffer}がEOFに達すると、
新しいバッファに切り替えることができます。

@findex @code{yy_delete_buffer()} 
@item void yy_delete_buffer( YY_BUFFER_STATE buffer )
@c __ Deletes @code{buffer}, and frees the memory allocated for it.
@code{buffer}で指定されるバッファを削除し、
それに割り当てられたメモリを解放します。

@findex @code{YY_CURRENT_BUFFER}
@item YY_CURRENT_BUFFER
@c __ A macro that returns the current buffer being used.
使用中のカレントなバッファを返すマクロです。

@end table
@end itemize

@noindent
@c __ These supply all the functions needed for dealing with multiple input
@c __ buffers.
上記が、
複数の入力バッファを取り扱うのに必要なすべての機能を提供しています。

@c Include Flex 2.5 information, for Flex manual as published by ASCII
@c @ifset INCLUDEFLEX25INFO
@node Buffer Manipulation (Flex 2.5), Example of Multiple Buffers, Buffer Manipulation, Multiple Input Buffers
@subsection バッファを操作する関数（Flex 2.5の補足情報）
@include bufferman_addendum-ja.texi
@c @end ifset

@ignore
@@ifinfo
========================================================================
@@menu
* Multiple Buffers Example ::  An example that looks for files to include.
@@end menu
========================================================================
@@end ifinfo
@end ignore

@c +--------------------------------------------------------------------+
@c |                                                                    |
@c | The following provides a simple example of using the multiple input|
@c | buffers allowed by Flex                                            |
@c |                                                                    |
@c +-----------------+-----------------+-----------------+--------------+ 
@c |       Name      |       Next      |     Previous    |       Up     |
@c +-----------------+-----------------+-----------------+--------------+ 
@c @node    Example of Multiple Buffers,  , Buffer Manipulation, Multiple Input Buffers
@node    Example of Multiple Buffers,  , Buffer Manipulation (Flex 2.5), Multiple Input Buffers
@c __ @subsection An Example of Using Multiple Buffers
@subsection 複数バッファを使う実例
@comment    ####################################
@c __ @cindex     Input buffers, using multiple
@c __ @cindex     Multiple buffers example
@cindex     入力バッファ、複数の使用
@cindex     複数バッファを使う実例

@c __ To help you understand the idea of using multiple buffers, here is part
@c __ of a C scanner that looks for files to include.  It accepts only the
@c __ quoted string version of the C @code{#include}.  For example
複数のバッファを使うというアイデアを理解するための手助けとして、
インクルードすべきファイルを探すCのスキャナの一部を以下に示します。
これはCの@code{#include}のうち、
引用符で囲まれた文字列のみを受け付けます。
例えば、

@example
@group
#include"file1.c"
#include "file2.c"
#include " file3.c"
@end group
@end example

@noindent
@c __ are legal input, though the file name in the final example will include
@c __ the space.  This example is also a good demonstration of using EOF
@c __ rules, and of start states.
は、
最後の例のファイル名が空白を含むことになりますが、
いずれも正当な入力です。
ここでの例はまた、
EOFルールとスタート状態の使用法を実演する良い例でもあります。

@smallexample
@group
@c __ /*
@c __  * eof_rules.lex : An example of using multiple buffers
@c __  *                 EOF rules, and start states.
@c __  */
/*
 * eof_rules.lex : 複数バッファ、EOFルール、スタート状態
 *                 の使い方の例
 */

%@{

#define MAX_NEST 10                   

@end group
@group
YY_BUFFER_STATE include_stack[MAX_NEST];
int             include_count = -1;

%@}

%x INCLUDE

@end group
@group
%%

^"#include"[ \t]*\"  BEGIN(INCLUDE);
<INCLUDE>\"          BEGIN(INITIAL); 
@c __ <INCLUDE>[^\"]+ @{      /* Get the include file name. */
<INCLUDE>[^\"]+ @{  /* インクルード・ファイルの名前を獲得する */
        if ( include_count >= MAX_NEST)@{
           fprintf( stderr, "Too many include files" );
           exit( 1 );
        @}

        include_stack[++include_count] = YY_CURRENT_BUFFER;

        yyin = fopen( yytext, "r" );
        if ( ! yyin )@{
           fprintf(stderr,"Unable to open \"%s\"\n",yytext);
           exit( 1 );
        @}

        yy_switch_to_buffer(
                   yy_create_buffer(yyin,YY_BUF_SIZE));

@end group
@group
        BEGIN(INITIAL);
      @}
<INCLUDE><<EOF>>  @{
        fprintf( stderr, "EOF in include" );
        yyterminate();
      @}
@end group
@group
<<EOF>> @{
        if ( include_count <= 0 )@{
          yyterminate();
@end group
@group
        @} else @{
          yy_delete_buffer(include_stack[include_count--] );
          yy_switch_to_buffer(include_stack[include_count] );
          BEGIN(INCLUDE);
        @}
      @}
[a-z]+             ECHO;
.|\n               ECHO;
@end group
@end smallexample

@noindent
@c __ Note how start states are used to create the file name scanner, and how
@c __ the buffer switch takes place.  Other important things to note are the
@c __ section dealing with @code{<<EOF>>}, and that when we return to the old
@c __ buffer, we use @code{BEGIN} to make sure that we are in the correct
@c __ state.  If we did not do this, then the state would be reset to
@c __ @code{INITIAL}, which would cause the trailing @samp{"} of the include
@c __ to be @code{ECHO}'ed.
スタート状態を使ってファイル名のスキャナを生成する方法や、
バッファの切り替えを発生させる方法に注目してください。
ほかに注目すべき重要な点は、
@code{<<EOF>>}を取り扱うセクション、
および、
古いバッファに復帰する際に@code{BEGIN}を使って確実に正しい状態に遷移するようにする点です。
これを怠ると、
状態は@code{INITIAL}にリセットされ、
@code{#include}の最後の@samp{"}が@code{ECHO}されてしまいます。

@c __ @strong{Please note:} @i{The @r{<<EOF>>} feature is discussed in the next
@c __ section.  @xref{Start States}, for more details on what they are and
@c __ what they do.}
@strong{注：}@i{@r{<<EOF>>}機能は次の節で説明します。
@r{<<EOF>>}が何であり、
何を行うものかという点に関する詳細な議論については、
@xref{Start States}。}

@c +--------------------------------------------------------------------+
@c |                                                                    |
@c | Notes on the special <<EOF>> in Flex.                              |
@c |                                                                    |
@c +-----------------+-----------------+-----------------+--------------+ 
@c |       Name      |       Next      |     Previous    |       Up     |
@c +-----------------+-----------------+-----------------+--------------+ 
@c @node    End-Of-File Rules,  , Multiple Input Buffers, Other Flex Features
@node    End-Of-File Rules,  , Multiple Input Buffers, Other Flex Features
@c __ @section End-Of-File Rules
@section ファイルの終端（End-Of-File）ルール
@comment #################
@c __ @cindex  End-Of-File, handling
@cindex  End-Of-File、取り扱い
@c __ @vindex @code{<<EOF>>}@r{, in detail}
@vindex @code{<<EOF>>}@r{、詳細}

@c __ When an end-of-file (EOF) is encountered, Flex calls @code{yywrap()} to
@c __ see if there are any more files ready for processing.  If
@c __ @code{yywrap()} returns a value other than 0, it indicates that there
@c __ are no more files, and, therefore, that this is the absolute end of the
@c __ input.  In some situations, it is necessary to do further processing at
@c __ this point (for example we might want to set up another file for input).
@c __ For these situations Flex provides the @code{<<EOF>>} operator.  By
@c __ using this, you may define what is to take place when EOF is
@c __ encountered.  @xref{Example of Multiple Buffers, , An Example of Using
@c __ Multiple Buffers}, for a good demonstration where EOF rules are used to
@c __ catch unclosed comments, and to catch the end of the file being
@c __ included.
ファイルの終端（EOF）が見つかると、
Flexは@code{yywrap()}を呼び出し、
ほかに処理できる状態のファイルが存在するか調べます。
@code{yywrap()}が0以外の値を返すと、
もうこれ以上ファイルはないということを意味し、
したがって、
これがまさに入力の最後であるということになります。
状況によっては、
この時点でさらに処理を行う必要のある場合があります
（例えば、
入力のために別のファイルをセットアップしたいということがあるかもしれません）。
このような場合のために、
Flexは@code{<<EOF>>}演算子を提供しています。
これを使うことで、
EOFが見つかった時に実行すべきことを定義することができます。
@xref{Example of Multiple Buffers, , 複数バッファを使う実例}。
EOFルールを使って、
終わりのないコメントやインクルードされているファイルの終端を見つける、
良い例が示されています。

@c __ There are some limitations on the usage of the @code{<<EOF>>} operator.
@c __ They are:
@code{<<EOF>>}演算子の使用にはいくつか制限があります。
制限事項を以下に示します。

@itemize @bullet

@item 
@c __ @b{They may not be used with patterns}
@b{パターンと一緒に使用することは不可}

@c __ EOF rules may only be used with start states.  If no start state is
@c __ specified (i.e., it is unqualified), then all states (including
@c __ exclusive start states), without an @code{<<EOF>>} will be affected.
@c __ This means that: 
EOFルールは、
スタート状態とのみ一緒に使うことができます。
スタート状態が指定されていない場合
（すなわち、
@code{<<EOF>>}ルールが状態により制限されない場合）、
@code{<<EOF>>}が使われていないすべての
（排他的スタート状態を含む）
状態が影響を受けます。
つまり、

@example
"foo"<<EOF>>
@end example

@noindent
@c __ is illegal, whereas the following are all correct.  
が不当である一方で、

@example
@group
@c __ <<EOF>>           /* All states without <<EOF>>. */
@c __ <indent><<EOF>>   /* EOF in indent state.        */
@c __ <comment><<EOF>>  /* EOF in a comment.           */
<<EOF>>           /* <<EOF>>が使われていないすべての */
                  /* 状態におけるEOF                 */
<indent><<EOF>>   /* indent状態におけるEOF           */
<comment><<EOF>>  /* コメント内のEOF                 */
@end group
@end example

はすべて正当であることを意味しています。

@item 
@c __ @b{Action ending}
@b{アクションの終端}

@c __ One thing to be careful of is that EOF rules are called at the end of
@c __ input, so their actions must either set up a new input stream (using
@c __ @code{yy_switch_to_buffer()} or @code{YY_NEW_FILE}), return (using a
@c __ @code{return} statement), or halt the scanner (using
@c __ @code{yyterminate()}, or @code{exit()}).
１つ注意しなければならない点は、
EOFルールは入力の最後で呼び出されるという点です。
したがって、
EOFルールのアクションは、
(1) （@code{yy_switch_to_buffer()}、
または@code{YY_NEW_FILE}を使って）新しい入力ストリームを確立する、
(2) （@code{return}文を使って）復帰する、
(3) （@code{yyterminate()}、
または@code{exit()}を使って）スキャナの実行を終了させる、
のいずれかを実行しなければなりません。

@c __ @xref{Example of Multiple Buffers, , An Example of Using Multiple Buffers},
@c __ for an example of using
@c __ @code{yy_terminate()} and @code{yy_switch_to_buffer()}, and 
@c __ @ref{Flex and C}, for an explanation of what @code{yyterminate()} does.
@xref{Example of Multiple Buffers, , 複数バッファを使う実例}。
@code{yy_terminate()}と@code{yy_switch_to_buffer()}を使う例が示されています。
また、
@code{yyterminate()}の説明については、
@ref{Flex and C}を参照してください。
@end itemize

@c +--------------------------------------------------------------------+
@c |                                                                    |
@c | Optimizing a scanner in detail                                     |
@c |                                                                    |
@c +-----------------+-----------------+-----------------+--------------+ 
@c |       name      |       next      |     previous    |       up     |
@c +-----------------+-----------------+-----------------+--------------+ 
@c @node    Optimization, More Examples, Other Flex Features, Top
@node    Optimization, More Examples, Other Flex Features, Top
@c __ @chapter Optimizing the Scanner
@chapter スキャナの最適化
@c __ @cindex  Speed and table size
@c __ @cindex  Optimization
@c __ @cindex  Scanner optimization
@cindex  スピードとテーブル・サイズ
@cindex  最適化
@cindex  スキャナの最適化

@c __ @i{During debugging, the performance of the scanner is usually not very
@c __ important, and the Flex defaults usually suffice.  However, after
@c __ debugging, you may want to optimize the scanner for either speed or
@c __ size.  This section points out a few common ways in which you can
@c __ optimize scanners.}
@i{デバッグをしている間は、
スキャナの性能は通常それほど重要ではなく、
Flexのデフォルトの設定で十分です。
しかしデバッグ終了後は、
スピード、
またはサイズの面でスキャナを最適化したくなることもあるでしょう。
ここでは、
スキャナを最適化するのによく使われる手法をいくつか紹介します。}

@ifnottex

========================================================================
@c __ @menu
@c __ * Optimizing for Speed::        The flags and topics relating to creating
@c __                                 fast scanners.  
@c __ * Optimizing for Size::         How to create smaller scanners.  
@c __ @end menu
@menu
* Optimizing for Speed::        ファスト・スキャナを作るためのフラグ、
                                関連するトピック
* Optimizing for Size::         サイズの小さいスキャナの作り方
@end menu
========================================================================
@end ifnottex

@c +--------------------------------------------------------------------+
@c |                                                                    |
@c | Optimizing for Speed                                               | 
@c |                                                                    |
@c +-----------------+-----------------+-----------------+--------------+ 
@c |       Name      |       Next      |     Previous    |       Up     |
@c +-----------------+-----------------+-----------------+--------------+ 
@c @node    Optimizing for Speed, Optimizing for Size, Optimization, Optimization
@node    Optimizing for Speed, Optimizing for Size, Optimization, Optimization
@c __ @section Optimizing for Speed
@section スピードの最適化
@comment ####################

@c __ Many programs spend a large amount of time in the lexical analysis
@c __ stage, so optimizing a scanner can often result in rather large
@c __ performance improvements.  While Flex scanners tend to be much faster
@c __ then Lex scanners, certain constructs or actions can have a great impact
@c __ on performance.  Things to be careful of are:
多くのプログラムは、
字句解析の処理に多くの時間を費やします。
したがって、
スキャナの最適化はかなり大きな性能改善に結びつくことが多いのです。
Flexによるスキャナは、
Lexによるスキャナと比較するとかなり高速になる傾向がありますが、
特定の構成もしくはアクションによって、
性能に大きな影響を与えることができます。
注意すべき点は以下のとおりです。

@enumerate
@c __ @item @b{Table Compression} @*
@item
@b{テーブルの圧縮} @*
@c __ Any kind of compression will result in slower scanners, always use the
@c __ @samp{-f} or @samp{-F} command line options if you are worried about
@c __ speed.  @xref{Table Compression and Scanner Speed}, for a detailed
@c __ discussion of table compression and speed options.
どのような圧縮も結果的にスキャナを遅くします。
したがって、
スピードのことが心配であるならば、
常にコマンドラインで@samp{-f}オプション、
または@samp{-F}オプションを使ってください。
テーブルの圧縮とスピードに関連するオプションに関する詳細な議論については、
@xref{Table Compression and Scanner Speed}。

@c __ @item @b{REJECT} @*
@item
@b{REJECT} @*
@c __ This has the greatest effect on speed, and if it is used it will slow
@c __ down @emph{all} matches.  This is because the scanner has to restore the
@c __ scanner to the state it was in before the match, so it needs to do more
@c __ internal maintenance than would otherwise be needed. Avoid this if speed
@c __ is important.
スピードに対して最も大きな影響を及ぼします。
これが使われると@emph{すべて}のマッチ処理が遅くなります。
というのは、
スキャナは、
マッチする前の状態に自身を復旧する必要があるからで、
このようなことが必要ない場合と比較して、
より多くの内部的な保守作業を行わなければならないからです。
スピードが重要な場合には、
使わないようにしてください。

@c __ @item @b{Backtracking} @*
@item
@b{バックトラッキング} @*
@c __ Backtracking is where the scanner has to ``back up'' to match some text.
@c __ This has a bad effect on the performance of a scanner, and should be
@c __ avoided if speed is of utmost importance.  Note that because compressed
@c __ tables always backtrack, it is a waste of time removing backtracking
@c __ from the rules unless the @samp{-f} or @samp{-F} options are used. 
@c __ @xref{Removing Backtracking}, for more details on removing backtracking
@c __ from your scanner.
スキャナがあるテキストにマッチするために「逆行」しなければならないことを、
バックトラッキングといいます。
これは、
スキャナの性能に悪い影響を及ぼしますので、
スピードが最も重要である場合には避けるべきです。
圧縮されたテーブルは常にバックトラッキングを発生させるので、
@samp{-f}オプション、
または@samp{-F}オプションを使わない場合は、
ルールからバックトラッキングを削除しようとするのは時間の無駄です。
スキャナからバックトラッキングを削除することに関する詳細な情報については、
@xref{Removing Backtracking}。

@c __ @item @b{Variable trailing context} @*
@item
@b{可変長後続コンテキスト（variable trailing context）} @*
@c __ Variable trailing context is where both the leading and trailing parts
@c __ of a rule do not have a fixed length.  This is almost as bad as
@c __ @code{REJECT} in terms of performance, and should be avoided wherever
@c __ possible.  Here is an example of this:
可変長後続コンテキストとは、
あるルールの先頭部分と後続部分の両方が固定長でないような場合を指します。
性能の観点からは@code{REJECT}と同じくらい悪影響を及ぼすもので、
可能な場合にはいつでも避けるべきです。
この例を示すと、
以下のようになります。

@example
@group
%%
linux|hurd/(OS|"Operating system")
@end group
@end example

@noindent
@c __ This should be split into something like:
これは、
以下のように分割すべきです。

@example
@group
linux/OS|"Operating system"
hurd/OS|"Operating system"
@end group
@end example

@noindent
@c __ which removes the problem.  
こうすることによって、
問題は解消されます。

@c __ @item @b{Beginning of line operator} @*
@item
@b{行の先頭を表す演算子} @*
@c __ The @samp{^} operator adversely effects performance.  Avoid it if speed
@c __ is of the utmost importance.
@samp{^}演算子は、
性能に不利な影響を及ぼします。
スピードが最も重要な場合には、
使わないでください。

@c __ @item @b{yymore()} @*
@item
@b{yymore()} @*
@c __ Using @code{yymore} can reduce performance.  Avoid it if speed is of the
@c __ utmost importance.
@code{yymore}を使うと性能を低下させます。
スピードが最も重要な場合には、
使わないでください。

@c __ @item @b{Text length} @*
@item
@b{テキスト長} @*
@c __ The speed of the scanner is also affected by the length of the text it
@c __ matches.  A scanner will run faster if it is always matching long
@c __ strings, because it does not have to set up the @code{yytext}
@c __ environment. Instead it spends most of its time in the inner matching
@c __ loop, which is fast.
スキャナの性能は、
マッチするテキストの長さによっても影響を受けます。
常に長い文字列にマッチするような場合には、
スキャナは高速に実行されます。
というのは、
@code{yytext}環境をセットアップする必要がないからです。
スキャナの実行時間のほとんどは、
内部の高速なマッチング・ループの中で費やされることになります。

@c __ @item @b{@code{NUL}'s} @*
@item
@b{@code{NUL}} @*
@c __ Flex is slow at matching tokens with @code{NUL}'s in them.  In this case
@c __ it is better to write rules that will match @emph{short} amounts of
@c __ text.
Flexは、
@code{NUL}を含むトークンをマッチするのに時間がかかります。
この場合には、
@emph{短い}テキストにマッチするようルールを記述するほうが良いでしょう。
@end enumerate

@ifnottex

========================================================================
@c __ @menu
@c __ * Removing Backtracking::       By removing backtracking, you can have 
@c __                                 considerable impact on performance.
@c __ @end menu
@menu
* Removing Backtracking::       バックトラッキングの除去による性能の
                                飛躍的向上
@end menu
========================================================================
@end ifnottex

@c +--------------------------------------------------------------------+
@c |                                                                    |
@c | An explanation of how to remove backtracking                       |
@c |                                                                    |
@c +-----------------+-----------------+-----------------+--------------+ 
@c |       Name      |       Next      |     Previous    |       Up     |
@c +-----------------+-----------------+-----------------+--------------+ 

@c @node    Removing Backtracking,  , Optimizing for Speed, Optimizing for Speed
@node    Removing Backtracking,  , Optimizing for Speed, Optimizing for Speed
@c __ @subsection  Removing Backtracking
@subsection  バックトラッキングの削除
@comment     #####################

@c __ Removing backtracking from a scanner can have a considerable impact on
@c __ its performance.  Unfortunately, removing backtracking can be quite
@c __ complicated.  For example:
スキャナからバックトラッキングを削除することは、
スキャナの性能にかなりの影響をもたらします。
残念ながら、
バックトラッキングの削除はかなり複雑な作業になる可能性があります。
例えば、

@example
@group
%%
hurd     return(GNU_OS);
hurdle   return(JUMP);
hurdled  return(JUMPED);
@end group
@end example 

@noindent
@c __ involves backtracking.  When the scanner matches @samp{hu}, and the next
@c __ character is not an @samp{r}, the scanner will have to backtrack to
@c __ match @samp{h} and @samp{u} using the default rule of @code{ECHO}ing
@c __ unmatched text. The same situation applies to @samp{d} and @samp{e}.
@c __ (This is because the scanner can no longer continue to try to match
@c __ anything. Then it invokes the default rule, and has to reset the
@c __ @code{yyext} environment, all of which takes time.)
では、
バックトラッキングが発生します。
スキャナが@samp{hu}をマッチし、
次の文字が@samp{r}ではない場合、
マッチされなかったテキストを@code{ECHO}するデフォルトのルールを使って@samp{h}と@samp{u}を処理するために、
スキャナはバックトラッキングを行わなければなりません。
同じことが@samp{d}と@samp{e}についても適用されます。
（これは、
何かにマッチするようスキャナが努力を継続するということが、
もはやできないからです。
この場合、
スキャナはデフォルトのルールを適用し、
@code{yyext}環境をリセットしなければなりませんが、
いずれも時間のかかる処理です。）

@c __ We can get information about what is causing backtracking by using the
@c __ @samp{-b} command line option.  This creates a file called
@c __ @file{lex.backtrack} with backtracking information in it.  For the
@c __ example above, this file would contain:
コマンドライン・オプション@samp{-b}を使うことで、
バックトラッキングを発生させている原因に関する情報を知ることができます。
これにより、
バックトラッキングに関する情報を含む@file{lex.backtrack}というファイルが生成されます。
上記の例の場合、
このファイルは以下のような情報を含みます。

@example
@group
State #6 is non-accepting -
 associated rule line numbers:
        2       3       4
 out-transitions: [ r ]
 jam-transitions: EOF [ \000-q  s-\177 ]

@end group
@group
State #7 is non-accepting -
 associated rule line numbers:
        2       3       4
 out-transitions: [ d ]
 jam-transitions: EOF [ \000-c  e-\177 ]

@end group
@group
State #9 is non-accepting -
 associated rule line numbers:
        3       4
 out-transitions: [ e ]
 jam-transitions: EOF [ \000-d  f-\177 ]

Compressed tables always backtrack.  
@end group
@end example

@noindent
@c __ The backtracking information is broken into sections, each of which
@c __ describes one state that is causing backtracking.  The first line of
@c __ each section tells us the state number, the second line tells us which
@c __ lines in the description are affected, and the third line tells us the
@c __ character at which backtracking occurs.  So in the first block we can
@c __ see that the backtracking starts at @samp{r}, and that lines 2, 3, and 4
@c __ are affected.  The last line is a reminder that compressed tables always
@c __ backtrack, so we should not spend time removing backtracking if we use
@c __ command line options that cause table compression.
バックトラッキング情報はセクションに分割され、
個々のセクションにおいて、
バックトラッキングを引き起こしている１つの状態のことが記述されています。
個々のセクションの最初の行から、
状態番号を知ることができます。
２行目からは、
記述ファイルの何行目が関連しているのかを知ることができます。
３行目からは、
バックトラッキングを発生させた文字を知ることができます。
よって、
最初のブロックからは、
文字@samp{r}でバックトラッキングが発生し、
それは記述ファイルの２，３，４行目に関連していることを見てとることができます。
最後の行は、
圧縮されたテーブルは常にバックトラッキングを発生させるので、
テーブル圧縮を引き起こすようなコマンドライン・オプションを使う場合には、
バックトラッキングを削除しようとして時間を費やすべきではないことを思い出させるためのものです。

@c __ To remove backtracking, we need to add rules to catch the states where
@c __ backtracking is involved.  Note that this @emph{does not} affect the
@c __ speed of a scanner.  Scanner speed is almost entirely independent of the
@c __ number of rules or their complexity.
バックトラッキングを削除するためには、
バックトラッキングが関与している状態をキャッチするルールを加える必要があります。
これは、
スキャナのスピードには@emph{影響を与えない}ということに注意してください。
スキャナのスピードは、
ルールの数や複雑さとはまったくといえるほど無関係です。

@c __ There are 2 ways we can add rules to remove backtracking.  The first way
@c __ is to add rules like this:
バックトラッキングを削除するためにルールを追加する方法は、
２種類あります。
第１の方法は、
以下のようなルールを追加することです。

@example
@group
%%
hurd     return(GNU_OS);
hurdle   return(JUMP);
hurdled  return(JUMPED);
hu       return(OTHER);
hur      return(OTHER);
hurdl    return(OTHER);
@end group
@end example 

@noindent
@c __ or to add a catch-all rule:
別の方法として、
すべてをキャッチするようなルールを追加することもできます。

@example
@group
%%
hurd     return(GNU_OS);
hurdle   return(JUMP);
hurdled  return(JUMPED);
[a-z]+   return(OTHER);
@end group
@end example 

@noindent
@c __ The second method should be used wherever it is applicable. If we use
@c __ the @samp{-b} option with either of these, we get only: 
この第２の方法を適用できる場合は、
常にこれを使うべきです。
上記のどちらかと@samp{-b}オプションを一緒に使うと、

@example
Compressed tables always backtrack.  
@end example

@noindent
@c __ which indicates that there are no backtracking states.  
というメッセージだけが出力されるようになります。
これは、
バックトラッキング状態が存在しないことを示唆しています。

@c __ One of the problems with this is that for complex scanners, the
@c __ backtracking problem tends to cascade, so the information in
@c __ @code{lex.backtrack} can be confusing.  However, the cause can usually
@c __ be isolated to only a few rules, so it @emph{is} worth the effort to
@c __ look at the backtrack data.
これに付随する問題の１つとして、
複雑なスキャナではバックトラッキング問題はカスケードする傾向があるので、
@code{lex.backtrack}内の情報が混乱をもたらすものになる可能性があります。
しかし、
バックトラッキングの原因は通常２、３個のルールにしぼることが可能なので、
バックトラック・データを調べようと努力するだけの@emph{値打ちはあります}。

@c +--------------------------------------------------------------------+
@c |                                                                    |
@c | Optimizing for size (why ??? )                                     |
@c |                                                                    |
@c +-----------------+-----------------+-----------------+--------------+ 
@c |       Name      |       Next      |     Previous    |       Up     |
@c +-----------------+-----------------+-----------------+--------------+ 
@c @node    Optimizing for Size,  , Optimizing for Speed, Optimization
@node    Optimizing for Size,  , Optimizing for Speed, Optimization
@c __ @section  Optimizing for Size 
@section  サイズの最適化
@comment  ###################

@c __ Flex is aimed toward creating very fast scanners rather than small ones,
@c __ but the tables produced are usually much smaller than those of Lex
@c __ anyway.
Flexは、
サイズの小さいスキャナよりも、
むしろ非常に高速なスキャナを作成することを目標としていますが、
いずれにしても、
作成されるテーブルのサイズはLexによるそれと比較しても、
通常はかなり小さいものになります。

@c __ By default, Flex creates the smallest possible scanners it can, which is
@c __ the same as using @samp{-Cem} on the command line.  If you use the
@c __ default, you do not need to worry about command line switches.
デフォルトでは、
Flexは可能な限りサイズの小さいスキャナを作成します。
これは、
コマンドラインで@samp{-Cem}を使うのと同等です。
デフォルトを使うのであれば、
コマンドライン・オプションを気にする必要はありません。

@c __ To reduce table size further, it is best to use rules that match larger
@c __ groups of text, and use a C subroutine to recognize the lexical value.
@c __ A good example of this is in a compiler, where you can give rules like:
さらにテーブルのサイズを小さくするには、
より大きなテキスト・グループにマッチするルールを使い、
字句の値を認識するためにCのサブルーチンを使うのが最も良い方法です。
この良い例がコンパイラで、
以下のようなルールを与えることができます。

@example
@group
%%
begin    return(BEGINSYM);
end      return(ENDSYM);
program  return(PROGSYM);
    @dots{} 
@end group
@end example

@noindent
@c __ Or, a table lookup can be used, as in:
あるいは、
以下のようにテーブル検索を使うことも可能です。

@example
@group
[a-zA-Z][a-zA-Z0-9]*  return(lookup(yytext));
@end group
@end example

@noindent
@c __ where a general rule is specified, and @code{lookup()} matches the text
@c __ against keywords, and then returns an integer representing what the
@c __ token is.  This produces smaller tables, but tends to be less efficient,
@c __ and for small, or uncomplicated sets of rules, the reduction in table
@c __ size may be offset by the fact that you have to store the symbol mapping
@c __ information elsewhere in the program, which could require more space
@c __ than the Flex tables.
ここでは、
一般的なルールが指定されていて、
@code{lookup()}がテキストをキーワードにマッチさせ、
そのトークンが何であるかを示す整数値を返します。
これにより、
サイズのより小さいテーブルが生成されますが、
性能は悪くなる傾向があります。
また、
数が少なく複雑ではないルール集合については、
テーブル・サイズを縮小することの効果は、
シンボル・マッピング用の情報をプログラム中の他の領域に格納しなければならないという事実によって、
相殺されるかもしれません。
というのは、
シンボル・マッピング用の情報は、
Flexテーブルと比較して、
より多くのスペースを必要とする可能性があるからです。

@c +--------------------------------------------------------------------+
@c |                                                                    |
@c | More examples of using Flex. (If we give them code, they can copy  |
@c | and maybe learn something when they change it.  ADD MORE PLEASE !! |
@c |                                                                    |
@c +-----------------+-----------------+-----------------+--------------+ 
@c |       name      |       next      |     previous    |       up     |
@c +-----------------+-----------------+-----------------+--------------+ 
@c @node    More Examples, Flex and Lex, Optimization, Top
@node    More Examples, Flex and Lex, Optimization, Top
@c __ @chapter More Examples of Using Flex
@chapter Flexを使うその他の実例

@quotation
@c __ @i{The following section will give you a few more examples of using
@c __ Flex.  Again, the implementations are not always optimal, but the
@c __ examples should show general Flex usage.}
@i{ここでは、
Flexの使用例をさらにいくつか紹介します。
ここでの例も、
必ずしも最適な実装ではありませんが、
一般的なFlexの使い方を示してくれるはずです。}
@end quotation

@ifnottex

========================================================================
@c __ @menu
@c __ * Example-Counting Words::      A wc like utility.  
@c __ * Example-Pascal Lexical Scanner::  An example of scanning a real language.  
@c __ * Example-Jargon Converter::    Convert Jargon file to Texinfo format.  
@c __ @end menu
@menu
* Example-Counting Words::      wc風のユーティリティ
* Example-Pascal Lexical Scanner::  本物の言語をスキャンする実例
* Example-Jargon Converter::    専門用語ファイルのTexinfo形式への変換
@end menu
========================================================================
@end ifnottex

@c +--------------------------------------------------------------------+
@c |                                                                    |
@c | A wc like utility                                                  |
@c |                                                                    |
@c +-----------------+-----------------+-----------------+--------------+ 
@c |       Name      |       Next      |     Previous    |       Up     |
@c +-----------------+-----------------+-----------------+--------------+ 
@c @node    Example-Counting Words, Example-Pascal Lexical Scanner, More Examples, More Examples
@node    Example-Counting Words, Example-Pascal Lexical Scanner, More Examples, More Examples
@c __ @section Counting Words, Characters, and Lines
@section 単語数、文字数、行数のカウント
@comment #####################################

@c __ The following definition is a simple example of how to use Flex for
@c __ counting words, characters and lines in a given file.  Note that the
@c __ actual Flex part is very small.  Most of the following code deals with
@c __ command-line parameters and maintaining the totals.
以下の定義は、
与えられたファイルの中の単語数、文字数、行数をカウントするのにFlexを使う方法を示す、
簡単な例です。
実際にFlexに関係のある部分は、
非常に少ないことに注意してください。
以下のコードのほとんどは、
コマンドライン・パラメータを処理したり、
カウントの合計を保持したりするものです。

@c __ @vindex @code{yyin}@r{, example of resetting}
@vindex @code{yyin}@r{、リセットの例}
@example
@group
@c __ /*
@c __  * wc.lex : A simple example of using FLEX
@c __  *          to create a wc-like utility.  
@c __  */   
/*
 * wc.lex : wcのようなユーティリティを、
 *          Flexを使って作成する簡単な例
 */
@end group

@group
%@{
int  numchars = 0;
int  numwords = 0;
int  numlines = 0;
int  totchars = 0;
int  totwords = 0;
int  totlines = 0;
%@}

@end group
@group
@c __ /*
@c __  * Rules start from here.
@c __  */
/*
 * ルールはここから始まる
 */

%%

[\n]        @{ numchars++;  numlines++;         @}
[^ \t\n]+   @{ numwords++;  numchars += yyleng; @}
.           @{ numchars++;                      @}

@end group
@group
%%

@c __ /*
@c __  * Additional C code starts from here.  This supplies
@c __  * all the argument processing etc.  
@c __  */
/*
 * 追加的なCコードがここから始まる。
 * ここで、すべての引数処理等を行うコードが提供される
 */

@end group
@group
void main(int argc, char **argv)
@{
  int  loop;
@c __   int  lflag = 0; /* 1 if we count # of lines      */
@c __   int  wflag = 0; /* 1 if we count # of words      */
@c __   int  cflag = 0; /* 1 if we count # of characters */
@c __   int  fflag = 0; /* 1 if we have a file name      */
  int  lflag = 0; /* 行数をカウントする場合は1         */
  int  wflag = 0; /* 単語数をカウントする場合は1       */
  int  cflag = 0; /* 文字数をカウントする場合は1       */
  int  fflag = 0; /* ファイル名が指定されている場合は1 */

@end group
@group
  for(loop=1; loop<argc; loop++)@{
     char *tmp = argv[loop];
     if(tmp[0] == '-')@{
     switch(tmp[1])@{
       case 'l':
          lflag = 1;
          break;
       case 'w':
          wflag = 1;
          break;
       case 'c':
          cflag = 1;
          break;
       default:
          fprintf(stderr,"unknown option -%c\n",tmp[1]);
     @}
@end group
@group
    @} else @{
      fflag = 1;
      numlines = numchars = numwords = 0;  
@end group
@group
      if((yyin = fopen(tmp,"rb")) != 0)@{
        (void) yylex();
        fclose(yyin);
        totwords += numwords;
        totchars += numchars;
        totlines += numlines;
        printf("file  : %25s :",tmp) ;
@end group
@group
        if(lflag)@{
          fprintf(stdout,"lines %5d ",numlines); 
        @}
@end group
@group
        if(cflag)@{
          fprintf(stdout,"characters %5d ",numchars); 
        @}
@end group
@group
        if(wflag)@{
          fprintf(stdout,"words %5d ",numwords); 
        @}
        fprintf(stdout,"\n");
@end group
@group
      @}else@{
        fprintf(stderr,"wc : file not found %s\n",tmp);
      @} 
    @}
  @}
@end group
@group
  if(!fflag)@{
    fprintf(stderr,"usage : wc [-l -w -c] file [file...]\n");
    fprintf(stderr,"-l = count lines\n");
    fprintf(stderr,"-c = count characters\n");
    fprintf(stderr,"-w = count words\n");
    exit(1);
  @}
@end group
@group
  for(loop=0;loop<79; loop++)@{
    fprintf(stdout,"-");
  @}
  fprintf(stdout,"\n");
  fprintf(stdout,"total : %25s  ","") ;
  if(lflag)@{
    fprintf(stdout,"lines %5d ",totlines); 
  @}
@end group
@group
  if(cflag)@{
    fprintf(stdout,"characters %5d ",totchars); 
  @}
@end group
@group
  if(wflag)@{
     fprintf(stdout,"words %5d ",totwords); 
  @}
  fprintf(stdout,"\n");
@}
@end group
@end example

@c +--------------------------------------------------------------------+
@c |                                                                    |
@c | A Pascal scanner.  (I think it works...  )                         |
@c |                                                                    |
@c +-----------------+-----------------+-----------------+--------------+ 
@c |       Name      |       Next      |     Previous    |       Up     |
@c +-----------------+-----------------+-----------------+--------------+ 
@c @node    Example-Pascal Lexical Scanner, Example-Jargon Converter, Example-Counting Words, More Examples
@node    Example-Pascal Lexical Scanner, Example-Jargon Converter, Example-Counting Words, More Examples
@c __ @section A Lexical Scanner for a Pascal Subset
@section Pascalのサブセット用の字句スキャナ
@comment ############################

@c __ The following is a demonstration of how you can build a lexical scanner
@c __ for a language like Pascal.  In this scanner definition, each of the
@c __ keywords has been listed as a rule.  This is generally the easiest way
@c __ to differentiate between keywords and identifiers (though it is common
@c __ to see all the keywords put into a table, and then use table searches).
@c __ Note also that there is a single rule for identifiers, in most
@c __ situations, this would call a sub-routine for symbol table management.
ここでは、
Pascalのような言語用の字句スキャナを作る方法を示します。
このスキャナ定義では、
個々のキーワードがルールとしてリストされています。
（一般的には、
すべてのキーワードをテーブルに格納してからテーブル検索を使う手法がよく見られますが、）
ここでの方法は、
キーワードと識別子とを区別するための方法としては、
一般的に最も簡単なものです。
また、
識別子用にただ１つのルールがあるという点に注意してください。
多くの場合、
このルールはシンボル・テーブルを管理するためのサブルーチンを呼び出します。

@c __ One other thing to note is that @samp{_FILE} and @samp{_BEGIN} have a
@c __ leading underscore.  This was done to show that some names that are
@c __ defined in either Flex, or C, cannot be used without additional work.
@c __ It is much more common for @emph{all} tokens to have something
@c __ prepended, or appended, and then the problem does not occur---@samp{TOK}
@c __ and @samp{SYM} are very common extensions.
もう１つ注意すべき点は、
@samp{_FILE}と@samp{_BEGIN}が先頭にアンダースコアを持つという点です。
Flex、
またはCで定義済みの名前は、
追加的な工夫なしでは使えないということを示すために、
このようにしてあります。
これよりももっと一般的に使われる手法は、
@emph{すべて}のトークンの先頭もしくは末尾に何らかの文字列を付加するというもので、
こうすることによって問題は発生しなくなります。
@samp{TOK}や@samp{SYM}が一般的によく使われる拡張子です。

@c __ @cindex Counting lines
@c __ @cindex Lines, counting 
@c __ @cindex Illegal names
@c __ @cindex Names, illegal
@c __ @cindex Scanning Pascal comments
@c __ @cindex Pascal comments, scanning
@cindex 行数のカウント
@cindex 行数、カウント
@cindex 不当な名前
@cindex 名前、不当
@cindex Pascalコメントのスキャン処理
@cindex Pascalコメント、スキャン処理
@example
@group
@c __ /*
@c __  * pascal.lex: An example PASCAL scanner.
@c __  *
@c __  */
/*
 * pascal.lex : PASCALスキャナの例
 */

%@{
#include <stdio.h>
#include "y.tab.h"

@end group
@group
int line_number = 0;

@end group
@group
void yyerror(char *message);

%@}

%x COMMENT1 COMMENT2

@end group
@group
white_space       [ \t]*
digit             [0-9]
alpha             [A-Za-z_]
alpha_num         (@{alpha@}|@{digit@})
hex_digit         [0-9A-F]
identifier        @{alpha@}@{alpha_num@}*
unsigned_integer  @{digit@}+
hex_integer       $@{hex_digit@}@{hex_digit@}*
exponent          e[+-]?@{digit@}+
i                 @{unsigned_integer@}
real              (@{i@}\.@{i@}?|@{i@}?\.@{i@})@{exponent@}?
string            \'([^'\n]|\'\')+\'
bad_string        \'([^'\n]|\'\')+

@end group
@group
%%
"@{"                  BEGIN(COMMENT1);
<COMMENT1>[^@}\n]+
<COMMENT1>\n            ++line_number;
<COMMENT1><<EOF>>    yyerror("EOF in comment");
<COMMENT1>"@}"        BEGIN(INITIAL);

@end group
@group
"(*"                 BEGIN(COMMENT2);
<COMMENT2>[^)*\n]+
<COMMENT2>\n            ++line_number;
<COMMENT2><<EOF>>    yyerror("EOF in comment");
<COMMENT2>"*)"       BEGIN(INITIAL);
<COMMENT2>[*)]

@end group
@group
@c __  /* Note that FILE and BEGIN are already 
@c __   * defined in FLEX or C so they cannot  
@c __   * be used.  This can be overcome in                               
@c __   * a cleaner way by defining all the
@c __   * tokens to start with TOK_ or some
@c __   * other prefix.  
@c __   */
/* FILEとBEGINは、FlexやCにおいては既に定義されているため
 * 使うことができない点に注意。これは、すべてのトークンの
 * 先頭にTOK_やその他の接頭辞を付加することによって、より
 * すっきりと克服することができる
 */
@end group

and                  return(AND);
array                return(ARRAY);
begin                return(_BEGIN);
case                 return(CASE);
const                return(CONST);
div                  return(DIV);
do                   return(DO);
downto               return(DOWNTO);
else                 return(ELSE);
end                  return(END);
file                 return(_FILE);
for                  return(FOR);
function             return(FUNCTION);
goto                 return(GOTO);
if                   return(IF);
in                   return(IN);
label                return(LABEL);
mod                  return(MOD);
nil                  return(NIL);
not                  return(NOT);
of                   return(OF);
packed               return(PACKED);
procedure            return(PROCEDURE);
program              return(PROGRAM);
record               return(RECORD);
repeat               return(REPEAT);
set                  return(SET);
then                 return(THEN);
to                   return(TO);
type                 return(TYPE);
until                return(UNTIL);
var                  return(VAR);
while                return(WHILE);
with                 return(WITH);

@group
"<="|"=<"            return(LEQ);
"=>"|">="            return(GEQ);
"<>"                 return(NEQ);
"="                  return(EQ);

".."                 return(DOUBLEDOT);

@end group
@group
@{unsigned_integer@}   return(UNSIGNED_INTEGER);
@{real@}               return(REAL);
@{hex_integer@}        return(HEX_INTEGER);
@{string@}             return@{STRING@};
@{bad_string@}         yyerror("Unterminated string");

@end group
@group
@{identifier@}         return(IDENTIFIER);

[*/+\-,^.;:()\[\]]   return(yytext[0]);

@c __ @{white_space@}        /* do nothing */
@{white_space@}        /* 何もしない */
\n                   line_number += 1;
.                    yyerror("Illegal input");

@end group
@group
%%
void yyerror(char *message)
@{
   fprintf(stderr,"Error: \"%s\" in line %d.  Token = %s\n",
           message,line_number,yytext);
   exit(1);
@}
@end group
@end example

@c +--------------------------------------------------------------------+
@c |                                                                    |
@c | A way to convert the ASCII Jargon to Texinfo format                |
@c |                                                                    |
@c +-----------------+-----------------+-----------------+--------------+ 
@c |       Name      |       Next      |     Previous    |       Up     |
@c +-----------------+-----------------+-----------------+--------------+ 
@c @node    Example-Jargon Converter,  , Example-Pascal Lexical Scanner, More Examples
@node    Example-Jargon Converter,  , Example-Pascal Lexical Scanner, More Examples
@c __ @section Jargon Converter
@section 専門用語の変換
@comment ################

@c __ The following is an example of how start states can be used to set up
@c __ miniature parsers inside the scanner generated by Flex.  This code will
@c __ take @b{The New Hackers Dictionary} (in its text form, which is
@c __ available from @file{prep.ai.mit.edu}, and many other Internet @sc{ftp}
@c __ sites), and transform it into a Texinfo formatted document, ready
@c __ for processing and printing.  This has been tested on
@c __ @file{jargon2910.ascii}.
ここでは、
スタート状態を使って、
Flexにより生成されるスキャナの内部に小規模のパーサを作る方法の例を示します。
このコードは@b{The New Hackers Dictionary}
（@file{prep.ai.mit.edu}、
およびその他の多くのインターネット@sc{ftp}サイトから入手可能なテキスト形式のもの）
を入力として受け取り、
すぐに製版および印刷できる状態のTexinfoフォーマットのドキュメントに変換するものです。
このコードは@file{jargon2910.ascii}を使ってテスト済みです。

@noindent
@c __ Typical usage would be:
典型的な使い方は以下のとおりです。

@example
@group
j2t < jargon > jargon.texi 
tex jargon.texi
lpr -d jargon.dvi
@end group
@end example

@noindent
@c __ This program @emph{does not} produce a file that can be converted into a
@c __ usable @code{info} file, though that capability could be added without
@c __ much difficulty.  While this example is quite long, it is not very
@c __ complicated, so don't be afraid to study it.
このプログラムは、
使用に耐える@code{info}ファイルに変換可能なファイルは@emph{作成しません}が、
こうした機能は大した困難もなく追加することが可能です。
この例は非常に長いものですが、
大して複雑でもないので、
尻込みしないで研究してみてください。

@c =================================================================
@c TODO: Should I give a blow by blow description of this?
@c       Currently I assume the reader can understand some of these
@c       rules....
@c =================================================================

@smallexample
@group
@c __ /*
@c __  * j2t.lex : An example of the use (possibly abuse!)
@c __  *           of start states.  
@c __  */
/*
 * j2t.lex : スタート状態を利用（ひょっとして悪用！）する例
 */

%@{
#define MAX_STATES 1024
#define TRUE  1
#define FALSE 0

@end group
@group
#define CHAPTER   "@@chapter"
#define SECTION   "@@section"
#define SSECTION  "@@subsection"
#define SSSECTION "@@subsubsection"

@end group
@group
int  states[MAX_STATES];
int  statep = 0;

int  need_closing = FALSE;

char buffer[YY_BUF_SIZE];

extern char *yytext;

@end group
@group
@c __ /*
@c __  * Set up the head of the *.texinfo file the program
@c __  * will produce.  This is a standard Texinfo header.  
@c __  */
/*
 * このプログラムが生成する*.texinfoファイルの先頭部分を作る。
 * これは標準的なTexinfoヘッダである
 */

void print_header(void)
@{
   printf("\\input texinfo @@c -*-texinfo-*-\n");
   printf("@@c           %c**start of header\n",'%');
@end group
@group
   printf("@@setfilename       jargon.info\n");
   printf("@@settitle          The New Hackers Dictionary\n");
   printf("@@synindex          fn cp\n");
   printf("@@synindex          vr cp\n");
   printf("@@c           %c**end of header\n",'%');
   printf("@@setchapternewpage odd\n");
@end group
@group
   printf("@@finalout\n");
   printf("@@c @@smallbook\n");
   printf("\n");
   printf("@@c ====================================================\n\n");
   printf("@@c This file was produced by j2t.  Any mistakes are *not*\n");
   printf("@@c the fault of the jargon file editors.\n");
   printf("@@c ====================================================\n\n");
   printf("@@titlepage\n");
   printf("@@title    The New Hackers Dictionary\n");
   printf("@@subtitle Version 2.9.10\n");
@end group
@group
   printf("@@subtitle Generated by j2t\n");
   printf("@@author Eric S. Raymond, Guy L. Steel, and Mark Crispin\n"); 
   printf("@@end titlepage\n");
   printf("@@page\n");
   printf("@@c ====================================================\n");
   printf("\n\n");
@end group
@group
   printf("@@unnumbered Preface\n");
   printf("@@c          *******\n");
@}

@end group
@group
@c __ /*
@c __  * Create the tail of the Texinfo file produced.  
@c __  */
/*
 * 生成されるTexinfoファイルの末尾の部分を作成する
 */

void print_trailer(void)
@{
   printf("\n");
   printf("@@c ====================================================\n");
@c __    printf("@@contents\n");   /* Print the table of contents. */
   printf("@@contents\n");   /* 目次を表示する */ 
   printf("@@bye\n\n");     
@}

@end group
@group
@c __ /*
@c __  * Write an underline under a section
@c __  * or chapter so we can find it later.  
@c __  */
/*
 * 後でそれを見つけることができるよう、節または章に下線を引く
 */

void write_underline(int len, int space, char ch)
@{
  int loop;

  printf("@@c ");

@end group
@group
  for(loop=3; loop<space; loop++)@{
    printf(" ");
  @}

  while(len--)@{
    printf("%c",ch);
  @}
  printf("\n\n");
@}

@end group
@group
@c __ /*
@c __  * Check for Texinfo special characters
@c __  * and escape them.
@c __  */
/*
 * Texinfoにおいて特殊な意味を持つ文字をチェックし、エスケープする
 */

char *check_and_convert(char *string)
@{
  int  buffpos = 0;
  int  len,loop;

@end group
@group
  len = strlen(string);  
  for(loop=0; loop<len; loop++)@{
    if(string[loop] == '@@' || 
       string[loop] == '@{' || 
       string[loop] == '@}')
    @{
      buffer[buffpos++] = '@@';
      buffer[buffpos++] = string[loop];
    @} else @{
      buffer[buffpos++] = string[loop];
    @}
  @}
  buffer[buffpos] = '\0';
  return(buffer);
@}

@end group
@group
@c __ /*
@c __  * Write out a chapter,section, or subsection
@c __  * header.
@c __  */
/*
 * 章、節、項のヘッダを書き出す
 */

void write_block_header(char *type)
@{
  int loop;
  int len;

@end group
@group
  (void)check_and_convert(yytext);
  len = strlen(buffer);
  for(loop=0; buffer[loop] != '\n';loop++)

@end group
@group         ;
  buffer[loop] = '\0';
  printf("%s %s\n",type,buffer);
  write_underline(strlen(buffer),strlen(type)+1,'*');
@}

%@}

@end group
@group
@c __ /*
@c __  * The Flex description starts here.
@c __  */
/*
 * Flexの記述情報がここから始まる
 */

%x HEADING EXAMPLE ENUM EXAMPLE2
%x BITEM BITEM_ITEM 
%s LITEM LITEM2 

%%

@c __ ^#[^#]*"#"  /* Skip the header & trailer. */
^#[^#]*"#"  /* ヘッダとフッタをスキップする */
@c __                      /* 
@c __                       * Chapters have asterisks under them 
@c __                       * and are terminated with a colon.
@c __                       */
                     /*
                      * 章は、その下にアスタリスクを持ち、コロンで終わる
                      */
^[^\n:]+\n[*]+\n      write_block_header(CHAPTER); 

@end group
@group
@c __ ^"= "[A-Z]" ="\n"="*  @{ /* We create a section for each category. */
^"= "[A-Z]" ="\n"="*  @{ /* 個々のカテゴリごとに節を作成する */
                        if(need_closing == TRUE)@{
                          printf("@@end table\n\n\n");
                        @}
                        need_closing = TRUE;
                        write_block_header(SECTION);
                        printf("\n\n@@table @@b\n");
                      @}

@end group
@group
"Examples:"[^\.]+     ECHO;

@c __ "*"[^*\n]+"*"         @{ /* @@emph@{@}(emphasized) text */
"*"[^*\n]+"*"         @{ /* @@emph@{@}（強調された）テキスト */
                        yytext[yyleng-1] = '\0';
                        (void)check_and_convert(&yytext[1]);
                        printf("@@i@{%s@}",buffer);
                      @}

@end group
@group
@c __ "@{@{"[^@}]+"@}@}"         @{ /* special emphasis */
"@{@{"[^@}]+"@}@}"         @{ /* 特別な強調 */
                        yytext[yyleng-2] = '\0';
                        (void)check_and_convert(&yytext[2]);
                        printf("@@strong@{%s@}",buffer);
                      @}

@end group
@group
@c __ "@{"[^@}]+"@}"           @{ /* special emphasis */
"@{"[^@}]+"@}"           @{ /* 特別な強調 */
                        yytext[yyleng-1] = '\0';
                        (void)check_and_convert(&yytext[1]);
                        printf("@@b@{%s@}",buffer);
                      @}

@end group
@group  
@c __  /* Escape some special Texinfo characters. */
 /* 特殊なTexinfo文字をエスケープする */
<INITIAL,LITEM,LITEM2,BITEM,ENUM,EXAMPLE,EXAMPLE2>"@@"  printf("@@@@");
<INITIAL,LITEM,LITEM2,BITEM,ENUM,EXAMPLE,EXAMPLE2>"@{"  printf("@@@{");
<INITIAL,LITEM,LITEM2,BITEM,ENUM,EXAMPLE,EXAMPLE2>"@}"  printf("@@@}");

@end group
@group
@c __  /*
@c __   * Reproduce @@example code.
@c __   */
 /*
  * @@exampleコードを再生成する
  */

":"\n+[^\n0-9*]+\n"     "[^ ]   @{
                        int loop;
                        int len;
                        int cnt;

@end group
@group
                        printf(":\n\n@@example \n");
                        strcpy(buffer,yytext);
                        len = strlen(buffer);
                        cnt = 0;
                        for(loop=len; loop > 0;loop--)@{
                          if(buffer[loop] == '\n')
                             cnt++;
                          if(cnt == 2)
                              break;
                        @}
@end group
@group
                        yyless(loop+1);
                        statep++;
                        states[statep] = EXAMPLE2;
                        BEGIN(EXAMPLE2);
                      @}
@end group
@group
<EXAMPLE,EXAMPLE2>^\n  @{
                      printf("@@end example\n\n");
                      statep--; 
                      BEGIN(states[statep]);
                    @}

@end group
@group
@c __  /*
@c __   * Reproduce @@enumerate lists.
@c __   */
 /*
  * @@enumerateリストを再生成する
  */

":"\n+[ \t]*[0-9]+"."   @{
                      int loop;
                      int len;

@end group
@group
                      printf(":\n\n@@enumerate \n");
                      strcpy(buffer,yytext);
                      len = strlen(buffer);
                      for(loop=len; loop > 0;loop--)@{
                        if(buffer[loop] == '\n')
                           break;
                      @}
@end group
@group
                      yyless(loop);
                      statep++;
                      states[statep] = ENUM;
                      BEGIN(ENUM);
                    @}

@end group
@group
<ENUM>"@@"           printf("@@@@");
<ENUM>":"\n+"     "[^0-9]    @{
                    printf(":\n\n@@example\n");
                    statep++;
                    states[statep] = EXAMPLE;
                    BEGIN(EXAMPLE); 
                  @}
@end group

@group
<ENUM>\n[ \t]+[0-9]+"." @{
                    printf("\n\n@@item ");
                   @}
<ENUM>^[^ ] | 
<ENUM>\n\n\n[ \t]+[^0-9] @{
                    printf("\n\n@@end enumerate\n\n");
                    statep--;
                    BEGIN(states[statep]);
                  @}

@end group
@group 
@c __  /* 
@c __   * Reproduce one kind of @@itemize list.
@c __   */
 /*
  * １種類の@@itemizeリストを再生成する
  */

":"\n+":"         @{
                    int loop;
                    int len;

                    printf(":\n\n@@itemize @@bullet \n");
                    yyless(2);
                    statep++;
                    states[statep] = LITEM2;
                    BEGIN(LITEM2);
                  @}
@end group
@group
<LITEM2>^":".+":" @{
                    (void)check_and_convert(&yytext[1]);
                    buffer[strlen(buffer)-1]='\0';
                    printf("@@item @@b@{%s:@}\n",buffer);
                  @}

@end group
@group 
<LITEM2>\n\n\n+[^:\n] @{
                    printf("\n\n@@end itemize\n\n");
                    ECHO;
                    statep--;
                    BEGIN(states[statep]);
                  @}

@end group
@group 
@c __  /*
@c __   * Create a list out of the revision history part.  
@c __   * We need the "Version" for this because it 
@c __   * clashes with other rules otherwise.  
@c __   */
 /*
  * リビジョン・ヒストリ部からリストを作成する。
  * ここで"Version"が必要なのは、そうしないと他のルール
  * と衝突するからである
  */

:[\n]+"Version"[^:\n*]+":" @{
                    int loop;
                    int len;

@end group
@group
                    printf(":\n\n@@itemize @@bullet \n");
                    strcpy(buffer,yytext);
                    len = strlen(buffer);
                    for(loop=len; loop > 0;loop--)@{
                      if(buffer[loop] == '\n')
                         break;
                    @}
@end group
@group
                    yyless(loop);
                    statep++;
                    states[statep] = LITEM;
                    BEGIN(LITEM);
                  @}
@end group
@group
<LITEM>^.+":"     @{
                    (void)check_and_convert(yytext);
                    buffer[strlen(buffer)-1]='\0';
                    printf("@@item @@b@{%s@}\n\n",buffer);
                  @}

@end group
@group 
<LITEM>^[^:\n]+\n\n[^:\n]+\n  @{
                    int loop;

                    strcpy(buffer,yytext);
                    for(loop=0; buffer[loop] != '\n'; loop++);
                    buffer[loop] = '\0';
                    printf("%s\n",buffer);
                    printf("@@end itemize\n\n");
                    printf("%s",&buffer[loop+1]);
                    statep--;
                    BEGIN(states[statep]);
                  @}

@end group
@group 
@c __  /*
@c __   * Reproduce @@itemize @@bullet lists.
@c __   */
 /*
  * @@itemize @@bulletリストを再生成する
  */

":"\n[ ]*"*"      @{
                    int loop;
                    int len;

@end group
@group
                    printf(":\n\n@@itemize @@bullet \n");
                    len = strlen(buffer);
                    for(loop=0; loop < len;loop++)@{
                      if(buffer[loop] == '\n')
                         break;
                    @}
@end group
@group
                    yyless((len-loop)+2);
                    statep++;
                    states[statep] = BITEM;
                    BEGIN(BITEM);
                  @}

@end group
@group
<BITEM>^" "*"*"   @{
                    printf("@@item");
                    statep++;
                    states[statep] = BITEM_ITEM;
                    BEGIN(BITEM_ITEM);
                  @}
@end group
@group
<BITEM>"@@"          printf("@@@@");
<BITEM>^\n        @{ 
                    printf("@@end itemize\n\n");
                    statep--;
                    BEGIN(states[statep]);
                  @} 
@end group
@group
<BITEM_ITEM>[^\:]* @{
                     printf(" @@b@{%s@}\n\n",check_and_convert(yytext));
                   @}
@end group
@group
<BITEM_ITEM>":"   @{ 
                    statep--; 
                    BEGIN(states[statep]);
                  @}

@end group
@group
@c __  /* 
@c __   * Recreate @@chapter, @@section etc.  
@c __   */
 /*
  * @@chapter、@@section等を再作成する
  */

^:[^:]*           @{ 
                    (void)check_and_convert(&yytext[1]); 
                    statep++;
                    states[statep] = HEADING;
                    BEGIN(HEADING); 
                  @}
@end group
@group
<HEADING>:[^\n]   @{
                    printf("@@item @@b@{%s@}\n",buffer); 
                    write_underline(strlen(buffer),6,'~');
                    statep--; 
                    BEGIN(states[statep]);
                  @}
@end group
@group
<HEADING>:\n"*"*  @{ 
                    if(need_closing == TRUE)@{
                      printf("@@end table\n\n\n");
                      need_closing = FALSE;
                    @}
                    printf("@@chapter %s\n",buffer); 
                    write_underline(strlen(buffer),9,'*');
                    statep--; 
                    BEGIN(states[statep]);
                  @}
@end group
@group
<HEADING>:\n"="*  @{ 
                    if(need_closing == TRUE)@{
                     printf("@@end table\n\n\n");
                      need_closing = FALSE;
                    @}
                    printf("@@section %s\n",buffer); 
                    write_underline(strlen(buffer),9,'=');
                    statep--; 
                    BEGIN(states[statep]);
                  @}
@end group
@group
<HEADING>"@@"        printf("@@@@");
<HEADING>:\n"-"*  @{ 
                    if(need_closing == TRUE)@{
                      printf("@@end table\n\n\n");
                      need_closing = FALSE;
                    @}
                    printf("@@subsection %s\n",buffer); 
                    write_underline(strlen(buffer),12,'-');
                    statep--; 
                    BEGIN(states[statep]);
                  @}

@end group
@group
@c __  /*
@c __   * Recreate @@example text.
@c __   */
 /*
  * @@exampleテキストを再作成する
  */

^"     "          @{
                    printf("@@example\n");
                    statep++;
                    states[statep] = EXAMPLE;
                    BEGIN(EXAMPLE); 
                  @}
<EXAMPLE>^"     "
.                 ECHO;

%%

@end group
@group
@c __  /*
@c __   * Initialize and go.  
@c __   */
 /*
  * 初期化して実行する
  */

int main(int argc, char *argv[])
@{
  states[0] = INITIAL;
  statep    = 0;
  print_header();
  yylex();
  print_trailer();
  return(0);
@}
@end group
@end smallexample

@*
@noindent
@c __ This file scans the ASCII jargon file for some commonly occurring
@c __ patterns that were caused by the translation of the original Texinfo
@c __ jargon file into a plain ASCII representation.  This is somewhat
@c __ complicated by the fact that in the process of translation, a lot of
@c __ mark-up information is lost, so it is difficult to tell exactly
@c __ @emph{what}, or @emph{which} of 2 or 3 alternatives produced the output.
@c __ However, some commonly occurring patterns are:
このプログラムは、
ASCIIの専門用語ファイルを読み込んで、
いくつかのよく見られるパターンを検索します。
このパターンは、
オリジナルのTexinfo形式の専門用語ファイルを単なるASCIIテキストに変換した際に作成されたものです。
この変換の過程で、
多くのマークアップ情報が失われているために、
ある出力結果の元になったオリジナルの情報が@emph{何}であったか、
あるいは、
そのオリジナルの候補が２つ３つあったとしても、
そのうちの@emph{どれ}がその出力結果をもたらしたかを正確に決定することが困難であるという事情のため、
この検索作業はいくらか複雑なものになります。
よく見られるパターンをいくつか挙げると、
以下のようになります。

@table @b
@c __ @item Chapters, sections, and subsections
@item 章、節、項
@c __ All these have the same leading pattern:
これらの先頭にはいずれも同じパターンが来ます。

@example
:@var{some text}:\n
@end example

@noindent
@c __ which is followed by an underline of asterisks (chapter), equal signs
@c __ (section) or a minus signs (sub-sections).
この後ろに、
（章の場合は）アスタリスクによる下線、
（節の場合は）等号による下線、
（項の場合は）マイナス記号による下線が続きます。

@c __ @item Emphasis
@item 強調
@c __ This is a little difficult, but in general, emphasis is shown by the
@c __ @code{*}@dots{}@code{*} (italic), @code{@{@{}@dots{}@code{@}@}}
@c __ (strong), or @code{@{}@dots{}@code{@}}(bold) pairs.  We just search for
@c __ these and output the commands.
これは少し難しいのですが、
一般的には強調は（イタリックの場合は）@code{*}@dots{}@code{*}、
（強調文字（strong）の場合は）@code{@{@{}@dots{}@code{@}@}}、
（太字（bold）の場合は）@code{@{}@dots{}@code{@}}の対によって示されます。
ここでは、
この３種類を検索して、
コマンドを出力します。

@c __ @item Examples and enumerated lists
@item 実例、および列挙されたリスト
@c __ These both start with a colon, followed by one or more newlines, at
@c __ least 5 spaces, and then either a number or some text.  For example:
ともにコロンで始まり、
その後ろに、
１つ以上の改行、
少なくとも５つの空白、
そして最後に数字もしくは何らかのテキストが続きます。
例えば、
列挙されたリストは以下のようになります。

@c __ @example
@c __ @group
@c __ @dots{}enumerated:
@c __ 
@c __       0.@var{some text}
@c __       1.@var{some more text}
@c __ 
@c __ @end group
@c __ @group
@c __ @dots{}example:
@c __ 
@c __       Some text goes here and will continue
@c __       for a while (indented).  
@c __ @end group
@c __ @end example

@example
@group
@dots{}enumerated:

      0.@var{some text}
      1.@var{some more text}

@end group
@end example

また、
実例は以下のようになります。@footnote{訳注：@var{some text}の部分に、インデントされたテキストが記されます。}

@example
@group
@dots{}example:

      @var{some text}
@end group
@end example

@c __ @item Itemized and bulleted lists
@item 項目化されマークを付けられたリスト
@c __ These are similar to examples and enumerated lists except they have
@c __ either a leading colon or asterisk on the item, and a trailing colon.
実例、および列挙されたリストによく似ていますが、
違いは、
項目の先頭にコロン、
またはアスタリスクがあり、
末尾にコロンがあるという点です。
@end table

@c __ The example uses such kinds of patterns as @emph{hints} as to what is
@c __ being parsed, and then uses (mostly exclusive) start states to set up a
@c __ sub-parser for that particular section.  If you have the ASCII version
@c __ of the jargon file, it is worth while verifying which parts of the
@c __ scanner match what in the file.  For example, it is probably not
@c __ immediately obvious that the rule that generates @code{@@item} in the
@c __ @code{HEADING} state is the one that processes all the jargon entries.
ここでの例は、
パースされているものが何であるかを示す@emph{ヒント}としてこのようなパターンを使い、
その特定のセクション用の部分的なパーサを
（ほとんどの場合、排他的）スタート状態を使って作ります。
ASCII版の専門用語ファイルを持っているのであれば、
スキャナのどの部分がそのファイル中の何にマッチするかを検証してみる値打ちがあります。
例えば、
@code{HEADING}状態において@code{@@item}を生成するルールが、
すべての専門用語のエントリを処理するルールでもあるということは、
おそらく一見しただけでは明らかではないでしょう。

@c +--------------------------------------------------------------------+
@c |                                                                    |
@c | Explain how Flex,Lex and POSIX fit together                        |
@c |                                                                    |
@c +-----------------+-----------------+-----------------+--------------+ 
@c |       Name      |       Next      |     Previous    |       Up     |
@c +-----------------+-----------------+-----------------+--------------+ 
@c @node Flex and Lex, Useful Code, More Examples, Top
@node Flex and Lex, Useful Code, More Examples, Top
@c __ @chapter Flex and Lex
@chapter FlexとLex
@c __ @cindex  Differences between Flex and Lex
@c __ @cindex  Flex and Lex, differences
@cindex  FlexとLexの相違点
@cindex  FlexとLex、相違点

@quotation
@c __ @i{The next few sections will give a very brief look at both Flex and
@c __ Lex, and offer a few general comments on their performance and
@c __ conformance with the POSIX standard for Lex-like utilities.}
@i{ここで非常に簡単にではありますが、
FlexとLexの両方を概観してみます。
Flex、Lexそれぞれの性能と、
Lexのようなユーティリティに関するPOSIX標準への準拠度についても、
いくつか一般的なコメントを示します。}
@end quotation

@ifnottex
========================================================================
@c __ @menu
@c __ * Flex::                        
@c __ * Lex::                         
@c __ @end menu
@menu
* Flex::                        Flex
* Lex::                         Lex
@end menu
========================================================================
@end ifnottex

@c +--------------------------------------------------------------------+
@c |                                                                    |
@c | A brief comparison of Flex and Lex...  in Flex's favor mostly      |
@c |                                                                    |
@c +-----------------+-----------------+-----------------+--------------+ 
@c |       Name      |       Next      |     Previous    |       Up     |
@c +-----------------+-----------------+-----------------+--------------+ 
@c @node    Flex, Lex, Flex and Lex, Flex and Lex
@node    Flex, Lex, Flex and Lex, Flex and Lex
@c __ @section Flex 
@section Flex 
@comment ####
   
@c __ Flex is a superior reimplementation of Lex, which, like Lex, takes a
@c __ description of patterns and actions as input, and converts those into a
@c __ C scanner capable of matching those patterns.  However, Flex takes less
@c __ time to produce tables, and the tables it produces are much more
@c __ efficient than the tables generated by Lex.  (For an explanation of
@c __ exactly what Flex produces, you should read the books mentioned at the
@c __ start of this manual.)
Flexは、
Lexのより優れた再実装であり、
Lexと同様、
パターンとアクションの記述情報を入力として受け取って、
そのパターンにマッチする能力を持つCのスキャナに変換するものです。
しかしながら、
Flexはより少ない時間でテーブルを生成しますし、
Flexにより生成されるテーブルは、
Lexにより生成されるテーブルと比較して、
はるかに効率的なものです。
（Flexが正確には何を生成するのかという説明については、
このマニュアルの冒頭で言及した書籍を参照してください。）

@c __ Flex is largely compatible with Lex and POSIX, and adds some special
@c __ features of its own.
Flexは、
LexおよびPOSIXと十分に互換性があり、
それ独自の特別な機能もいくつか追加しています。

@ifnottex
========================================================================
@c __ @menu
@c __ * Flex and POSIX::              
@c __ @end menu
@menu
* Flex and POSIX::              FlexとPOSIX
@c @ifset INCLUDEFLEX25INFO
* Flex and POSIX (Flex 2.5)::   FlexとPOSIX（Flex 2.5の補足情報）
@c @end ifset
@end menu
========================================================================
@end ifnottex

@c +--------------------------------------------------------------------+
@c |                                                                    |
@c | Flex & POSIX conformance.  |
@c |                                                                    |
@c +-----------------+-----------------+-----------------+--------------+ 
@c |       Name      |       Next      |     Previous    |       Up     |
@c +-----------------+-----------------+-----------------+--------------+ 
@c @node     Flex and POSIX,  , Flex, Flex
@node     Flex and POSIX, Flex and POSIX (Flex 2.5), Flex, Flex
@c __ @subsection Flex and POSIX
@subsection FlexとPOSIX
@comment    ##############
@cindex     POSIX

@c __ Flex is generally compatible with both Lex and POSIX, and is likely to
@c __ become more POSIX compliant in the future (with either Flex or POSIX
@c __ changing).  However, there are a few places where Flex, Lex and POSIX
@c __ differ.  They are:
Flexは、
大体のところLexおよびPOSIXの両方と互換性があります。
将来は
（Flex、POSIXのどちらかが変わることによって）、
さらにPOSIXとの互換性を高めていくでしょう。
しかし、
Flex、Lex、POSIXには、
異なる部分もいくつかあります。
それを以下に示します。

@table @b
@c __ @item Exclusive start states
@item 排他的スタート状態
@c __ Flex and POSIX support exclusive start states, but Lex does not.
FlexとPOSIXは排他的スタート状態をサポートしていますが、
Lexはサポートしていません。

@c __ @item Definitions
@item 定義
@c __ Lex and Flex differ in the way they expand definitions.  Flex (and the
@c __ POSIX draft), surround definitions with parentheses when they are
@c __ expanded, but Lex does not.  This means that the operators @samp{^},
@c __ @samp{$}, @samp{/}, @samp{<<EOF>>} and @samp{<@var{start state}>} cannot
@c __ be used in Flex definitions.
LexとFlexでは定義の展開の方法が違います。
@c @ifset INCLUDEFLEX25INFO
Flex（およびPOSIXのドラフト仕様）は、
定義を展開する時に丸括弧( )で囲みますが、
Lexは囲みません。@footnote{訳注：Flex 2.5では、
@samp{-l}オプションを指定して生成されたスキャナは、
Lexの場合と同じように、
定義を展開する時に丸括弧( )で囲みません。}
@c @end ifset
@c @ifclear INCLUDEFLEX25INFO
@c Flex（およびPOSIXのドラフト仕様）は、
@c 定義を展開する時に丸括弧( )で囲みますが、
@c Lexは囲みません。
@c @end ifclear
このことは、
Flex定義では演算子@samp{^}、@samp{$}、@samp{/}、@samp{<<EOF>>}、および@samp{<@var{start state}>}は使うことができないということを意味しています。

@c __ One of the main problems with this is that it can affect the precedence
@c __ of matches, and can lead to subtle differences in scanning between Flex
@c __ and Lex.  For an example of the problem, refer to 
@c __ @ref{Pattern Matching, , The Pattern Section}.
このことがもたらす主要な問題の１つに、
マッチの優先順位に影響を与え、
FlexとLexの間でスキャン処理に微妙な差異が出てくるということがあります。
この問題の例については、
@ref{Pattern Matching, , パターン・セクション}を参照してください。

@c __ @findex @code{input()} @r{differences in Lex and Flex}
@findex @code{input()}@r{、LexとFlexの相違点}
@item @code{input()}
@c __ In Flex and the POSIX draft, @code{input()} is not redefinable.  Rather
@c __ than redefining @code{input()} to control the input, Flex uses the
@c __ @code{YY_INPUT} extension (which is not currently supported by POSIX).
@c __ Note also that unlike Lex, @code{input()} in Flex changes the value of
@c __ @code{yytext}.
FlexおよびPOSIXのドラフト仕様では、
@code{input()}は再定義可能ではありません。
Flexで入力を制御するためには、
@code{input()}を再定義する代わりに、
@code{YY_INPUT}という拡張機能を使います
（これは現在のところPOSIXではサポートされていません）。
また、
Lexとは異なり、
Flexの@code{input()}は@code{yytext}の値を変更するという点に注意してください。

@c __ @findex @code{ECHO} @r{and} @code{output()}
@findex @code{ECHO}@r{と}@code{output()}
@findex @code{output()}
@item @code{output()}
@c __ Flex does not support the @code{output()} routine.  Output from
@c __ @code{ECHO} is done via @code{yyout}, which defaults to @code{stdout}.
@c __ It is possible to write an @code{output()} to use this, but the current
@c __ POSIX draft does not state exactly what @code{output()} is supposed to
@c __ do.
Flexは@code{output()}ルーチンをサポートしていません。
@code{ECHO}の出力は@code{yyout}経由で行われます。
この@code{yyout}のデフォルトは@code{stdout}です。
これを使うように@code{output()}を書くことも可能ですが、
現在のPOSIXのドラフト仕様は、
@code{output()}が正確には何をすべきなのかを示していません。

@c __ @cindex Ratfor scanners
@cindex Ratforスキャナ
@c __ @item Ratfor scanners
@item Ratforスキャナ
@c __ Neither Flex nor POSIX offer any support for the Lex ratfor scanner
@c __ option (@code{%r}).
Flex、POSIXのどちらも、
LexのRatfor@footnote{訳注：Rational Fortran}スキャナ・オプション（@code{%r}）をサポートしていません。

@vindex @code{yylineno} 
@item @code{yylineno}
@c __ This is an undocumented feature of Lex that does not appear in Flex or
@c __ POSIX.  Implementing line-counting in Flex is not difficult however.
@c __ @xref{Miscellaneous}, for an example of how to include line counting in
@c __ your definitions
@c @ifset INCLUDEFLEX25INFO
これは、
FlexやPOSIXには存在しない、
ドキュメント化されていないLexの機能です。@footnote{訳注：Flex 2.5では、
Flex起動時に@samp{-l}オプションを指定するか、
スキャナ定義ファイルの中に@samp{%option yylineno}を指定することによって、
変数@code{yylineno}を利用することができます。}
@c @end ifset
@c @ifclear INCLUDEFLEX25INFO
@c これは、
@c FlexやPOSIXには存在しない、
@c ドキュメント化されていないLexの機能です。
@c @end ifclear
しかし、
Flexで行数をカウントする機能を実装するのは難しくありません。
定義中に行数カウント機能を組み込む方法の例については、
@xref{Miscellaneous}を参照してください。

@c __ @findex @code{yywrap()}@r{ and POSIX}
@findex @code{yywrap()}@r{とPOSIX}
@item @code{yywrap()}
@c __ Currently @code{yywrap()} is a macro.  The POSIX draft states that this
@c __ should be a function, and in the future, it is likely to change.
現在のところ@code{yywrap()}はマクロです。
@c @ifset INCLUDEFLEX25INFO
POSIXのドラフト仕様では、
これは関数であるべきとされていますので、
おそらく将来は変更されることになるでしょう。@footnote{訳注：Flex 2.5では、
@samp{%option noyywrap}が指定されない限り、
@code{yywrap()}は関数です。}
@c @end ifset
@c @ifclear INCLUDEFLEX25INFO
@c POSIXのドラフト仕様では、
@c これは関数であるべきとされていますので、
@c おそらく将来は変更されることになるでしょう。
@c @end ifclear

@c __ @vindex @code{yyleng}@r{, and} @code{unput()}
@c __ @vindex @code{yytext}@r{, and} @code{unput()}
@vindex @code{yyleng}@r{、}@code{unput()}
@vindex @code{yytext}@r{、}@code{unput()}
@item @code{unput()}
@c __ Currently @code{unput()} destroys the values of @code{yytext} and
@c __ @code{yyleng} and these are not valid until the next token match.  In
@c __ Lex and POSIX, @code{yytext} and @code{yyleng} are unaffected by
@c __ @code{unput()}.
現在のところ@code{unput()}は@code{yytext}と@code{yyleng}の値を破壊しますが、
次のトークンがマッチされるまでは、
これは不当です。
@c @ifset INCLUDEFLEX25INFO
LexとPOSIXでは、
@code{yytext}と@code{yyleng}は@code{unput()}の影響を受けません。@footnote{訳注：Flex 2.5では、
@samp{%array}を指定すれば、
@code{unput()}は@code{yytext}の内容を破壊しません。}
@c @end ifset
@c @ifclear INCLUDEFLEX25INFO
@c LexとPOSIXでは、
@c @code{yytext}と@code{yyleng}は@code{unput()}の影響を受けません。
@c @end ifclear

@c __ @item Numeric ranges
@item 数値範囲
@c __ POSIX states that @samp{abc@{1,3@}} should be ``@i{match @code{ab}
@c __ followed by 1, 2 or 3 @code{c}'s}''.  The behavior of Flex agrees with
@c __ this, but Lex interprets it as ``@i{match 1, 2 or 3 @code{abc}'s}''.
POSIX によると、
@samp{abc@{1,3@}}は
「@i{@code{ab}の後ろに１個、２個、または３個の@code{c}が続くもの}」
にマッチすべきとなっています。
Flexはこのとおりに動きますが、
Lexはこれを
「@i{１個、２個、または３個の@code{abc}}」
と解釈します。

@c __ @vindex @code{yytext}@r{ incompatibilities}
@vindex @code{yytext}@r{非互換性}
@item @code{yytext}
@c __ The correct way to define @code{yytext} for Flex is @samp{extern char
@c __ *yytext}, but in Lex it is @samp{extern char yytext[]}.  The array
@c __ access method has a considerable impact on performance, so Flex will
@c __ continue to use @samp{extern char *yytext}.
@c @ifset INCLUDEFLEX25INFO
Flexにおいて@code{yytext}の正しい定義は@samp{extern char *yytext}ですが、
Lexでは@samp{extern char yytext[]}です。@footnote{訳注：Flex 2.5では、
@samp{%pointer}と@samp{%array}により、
@code{yytext}の型を選択できるようになりました。
デフォルトは@samp{%pointer}です。}
@c @end ifset
@c @ifclear INCLUDEFLEX25INFO
@c Flexにおいて@code{yytext}の正しい定義は@samp{extern char *yytext}ですが、
@c Lexでは@samp{extern char yytext[]}です。
@c @end ifclear
配列によるアクセス方法は、
性能にかなりの影響を及ぼすので、
Flexでは@samp{extern char *yytext}を使い続けるでしょう。

@c __ The latest POSIX draft supports both methods by introducing the
@c __ @samp{%array} and @samp{%pointer} constructs.  This has not been
@c __ incorporated into either Flex or Lex yet.
最新のPOSIXドラフト仕様は、
@samp{%array}と@samp{%pointer}を導入することによって、
両方の方法をサポートしています。
@c @ifset INCLUDEFLEX25INFO
これは、
FlexとLexのいずれにもまだ組み込まれていません。@footnote{訳注：Flex 2.5は、
@samp{%pointer}と@samp{%array}をサポートしています。}
@c @end ifset
@c @ifclear INCLUDEFLEX25INFO
@c これは、
@c FlexとLexのいずれにもまだ組み込まれていません。
@c @end ifclear

@c __ @item Table sizes
@item テーブル・サイズ
@c __ Lex has table size declarators (@code{%p}, @code{%a} etc), but Flex does
@c __ not require them.  For compatibility, they are recognized, but quietly
@c __ ignored.
Lexにはテーブル・サイズ宣言子（@code{%p}、@code{%a}等）がありますが、
Flexでは必要ありません。
互換性のために認識はされますが、
無視されるだけです。

@item @code{FLEX_SCANNER}
@c __ @code{FLEX_SCANNER} is @code{#define}d to allow code to be included
@c __ based upon whether the scanner was produced by Flex or Lex.
スキャナがFlexとLexのどちらにより生成されたかによって、
コードをインクルードしたりしなかったりすることができるように、
@code{FLEX_SCANNER}が@code{#define}によって定義されています。

@c __ @item Actions
@item アクション
@c __ Flex allows multiple statements to be placed on a single line without
@c __ the statements needing the @code{@{@dots{}@}} pair.  Lex on the other
@c __ hand, truncates such lines to a single statement.
Flexでは、
大括弧の対@code{@{@dots{}@}}を使うことなく、
単一行において複数の文を置くことができます。
これに対してLexは、
そのような行を単一文に切り詰めてしまいます。

@c __ @item Comments
@item コメント
@c __ Flex allows comments to begin with @samp{#}, whereas neither Lex nor
@c __ POSIX allow this.  Using these comments is not recommended however.
Flexではコメントを@samp{#}で始めることができますが、
LexとPOSIXではできません。
ただし、
この形式のコメントを使うことはお勧めできません。

@c __ @cindex @code{#line} directives and Lex
@cindex @code{#line}指示子とLex
@c __ @vindex @code{<<EOF>>}@r{ and Lex}
@vindex @code{<<EOF>>}@r{とLex}
@c __ @findex @code{yyterminate()}@r{ and Lex}
@c __ @findex @code{yyrestart()}@r{ and Lex}
@findex @code{yyterminate()}@r{とLex}
@findex @code{yyrestart()}@r{とLex}
@c __ @item @code{yyterminate()},@code{yyrestart()}, @code{<<EOF>>}, @code{YY_DECL} and @code{#line} directives
@item @code{yyterminate()}、@code{yyrestart()}、@code{<<EOF>>}、@code{YY_DECL}、@code{#line} 指示子
@c __ None of these are supported by Lex nor are they explicitly defined in POSIX.  
@c __ @xref{Switches Summary, , Summary of Flex Command Line Options}, 
@c __ for an explanation of @code{#line} directives.
これらはいずれもLexではサポートされていませんし、
POSIXにおいて明示的に定義されてもいません。
@code{#line}指示子の説明に関しては、
@xref{Switches Summary, , Flex コマンドライン・オプションの要約}。

@end table

@c Include Flex 2.5 information, for Flex manual as published by ASCII
@c @ifset INCLUDEFLEX25INFO
@node Flex and POSIX (Flex 2.5),  , Flex and POSIX, Flex
@subsection FlexとPOSIX（Flex 2.5の補足情報）
@include flexposix_addendum-ja.texi
@c @end ifset

@c +--------------------------------------------------------------------+
@c |                                                                    |
@c | A few (mostly derisive) comments on Lex. This could probably be    |
@c | erased with few problems....                                       |
@c |                                                                    |
@c +-----------------+-----------------+-----------------+--------------+ 
@c |       Name      |       Next      |     Previous    |       Up     |
@c +-----------------+-----------------+-----------------+--------------+ 
@c @node    Lex,  , Flex, Flex and Lex
@node    Lex,  , Flex, Flex and Lex
@c __ @section Standard Lex
@section 標準Lex
@comment ############
@cindex  Lex

@c +--------------------------------------------------------------------+
@c | I was amused to find this quote in the plan 9 documentation:       |
@c | "The asteroid that will kill this dinosaur is still in orbit"....  |
@c +--------------------------------------------------------------------+

@c __ Lex is a standard Unix utility for creating scanners, and has a long
@c __ history.  Lex is very similar to Flex, but is much slower at generating
@c __ scanners, and the scanners it produces are usually slower than those
@c __ produced by Flex. Lex is in sore need of being replaced, especially as
@c __ it lacks many POSIX features, which Flex has.  As more computer systems
@c __ become POSIX compliant, they must support many of the features found in
@c __ Flex, which will probably result in Flex being installed in place of Lex
@c __ (For example, the 4.4 BSD release will use Flex), though the sheer
@c __ number of systems on which it is installed will ensure its continuance
@c __ for some time.
Lexはスキャナを作成するための標準的なUnixユーティリティであり、
長い歴史を持っています。
LexはFlexと非常によく似ていますが、
スキャナを生成するのにより多くの時間がかかりますし、
Lexの生成するスキャナはFlexの生成するスキャナよりも通常は遅いものです。
Lexは、
特に多くのPOSIX機能を提供していないという理由から、
置き換える必要が大いにあります。
FlexはこうしたPOSIX機能を提供しています。
より多くのコンピュータ・システムがPOSIX互換になるにつれて、
Flexの提供する多くの機能をサポートしなければならなくなり、
このために、
おそらくはFlexがLexの代わりにインストールされるようになるでしょう
（例えば、
4.4 BSDリリースはFlexを使うことになります）。
しかし、
Lexがインストールされている少数のシステムがあるために、
しばらくの間はLexの存在は確実に維持されるでしょう。

@c __ The big difference between Flex and Lex is that Flex was written with
@c __ performance in mind.  Generally, if you have Flex, you should use it;
@c __ the difference in performance is too great to ignore.  However, if
@c __ portability is of prime importance, scanner definitions should be made
@c __ as close as possible to Lex, which is virtually guaranteed to be on
@c __ every Unix machine, whereas Flex may not be available (though it is
@c __ usually trivial to install).  Unfortunately, this eliminates the use of
@c __ some of the more useful Flex and POSIX extensions, such as exclusive
@c __ start states.
FlexとLexの大きな違いは、
Flexが性能を考慮して書かれたという点にあります。
一般的には、
Flexを持っているのであればそれを使うべきです。
両者の性能差は、
無視するにはあまりにも大きすぎます。
しかし、
移植性が最も重要なのであれば、
スキャナ定義は可能な限りLexのものに近づけるべきです。
というのは、
Lexは事実上すべてのUnixマシンに入っていることが保証されていますが、
Flexは入っていない可能性があるからです
（しかし、
Flexのインストールは通常は取るに足りない作業です）。
このような場合に残念なのは、
FlexとPOSIXが持っている排他的スタート状態のような、
より便利な拡張機能を使うことができなくなるということです。

@c __ Another way to get around this problem is to produce the scanner with
@c __ Flex, and then distribute the generated scanner.  This is often a viable
@c __ option because scanners, once written, seldom change.  If changes
@c __ @emph{are} needed, the chances are that other parts of the program will
@c __ also be changed in a substantial way, so installing Flex will be but a
@c __ small part of the effort to update the program.
この問題を回避するためのもう１つの方法は、
Flexでスキャナを作成して、
作成されたスキャナを配布することです。
スキャナというものは一度書かれるとほとんど変更されることがないので、
多くの場合この方法は実行可能です。
仮に変更が必要になったとしても、
プログラムの他の部分も相当変更しなければならない可能性があり、
よってプログラムを更新するための努力全体から見れば、
Flexをインストールすることなどはほんの些細なものでしょう。

@c +--------------------------------------------------------------------+
@c |                                                                    |
@c | Some useful code snippets.                                         |
@c |                                                                    |
@c +-----------------+-----------------+-----------------+--------------+ 
@c |       Name      |       Next      |     Previous    |       Up     |
@c +-----------------+-----------------+-----------------+--------------+ 
@c @node    Useful Code, Summary, Flex and Lex, Top
@node    Useful Code, Summary, Flex and Lex, Top
@c __ @chapter Snippets of Useful Code
@chapter 役に立つコードの抜粋

@quotation
@c __ @i{This section gives a list of small pieces of Flex definitions that
@c __ you may include in your own programs.  Many of these should be fairly
@c __ obvious after reading this manual, but they are included here to save
@c __ you reinventing the code.}
@i{ここでは、
読者がプログラムの中で使うことのできる、
ちょっとしたFlex定義を一覧にして示します。
多くは、
このマニュアルを読んだあとでは、
かなり自明のものになるはずです。
しかし、
読者がこうしたコードを最初から作らずに済むように、
ここに入れてあります。}
@end quotation

@ifnottex
@c __ Chose which one you want to visit.  
参照したい項目を選択してください。

========================================================================
@c __ @menu
@c __ * Handling Comments::           
@c __ * Handling Strings::            
@c __ * Handling Numbers::            
@c __ * Multiple Scanners::           
@c __ * Miscellaneous::               
@c __ @end menu
@menu
* Handling Comments::           コメントの処理
* Handling Strings::            文字列の処理
* Handling Numbers::            数値の処理
* Multiple Scanners::           複数のスキャナ
* Miscellaneous::               その他
@end menu
========================================================================
@end ifnottex

@c +--------------------------------------------------------------------+
@c |                                                                    |
@c | This section shows how to handle comments in Flex in 2 ways.       |
@c |                                                                    |
@c +-----------------+-----------------+-----------------+--------------+ 
@c |       Name      |       Next      |     Previous    |       Up     |
@c +-----------------+-----------------+-----------------+--------------+ 
@c @node    Handling Comments, Handling Strings, Useful Code, Useful Code
@node    Handling Comments, Handling Strings, Useful Code, Useful Code
@c __ @section Handling Comments
@section コメントの処理
@c       #################

@c __ As stated in @ref{Flex and C}, comments can be handled using
@c __ @code{input()}.  The code to do this is:
@ref{Flex and C}において述べたように、
コメントは@code{input()}を使って処理することができます。
これを行うためのコードは以下のようになります。

@c __ @cindex C comments, scanning
@c __ @cindex Scanning C comments
@cindex Cコメント、スキャン処理
@cindex Cコメントのスキャン処理
@c __ @findex @code{input()}@r{, sample}
@findex @code{input()}@r{、サンプル}
@example
@group
%%
"/*" @{
        int a,b;
        
        a = input();
        while(a != EOF)@{
          b = input();
@end group
@group
          if(a == '*' && b == '/')@{
            break;
           @}else@{
            a = b;
           @}
         @}
        if(a == EOF)@{
          error_message("EOF in comment");
        @}
      @}
@end group
@end example

@noindent
@c __ Which is legal in both Flex and Lex.  Comments can also be handled using
@c __ exclusive start states, which is prettier, and more efficient.  The code
@c __ to handle comments with start states is:
これは、
FlexとLexの両方で正当なコードです。
コメントは排他的スタート状態を使って処理することも可能で、
こちらの方がより美しく、
より効率的です。
スタート状態を使ってコメントを処理するコードは、
以下のようになります。

@c __ @vindex @code{%x} @r{sample with EOF}
@vindex @code{%x} @r{EOFを使用したサンプル}
@example
@group
%x COMMENT
%%
"/*"                  BEGIN(COMMENT);
<COMMENT>[^\n]
<COMMENT>\n   
<COMMENT><<EOF>>      yyerror("EOF in comment");
<COMMENT>"*/"         BEGIN(INITIAL);
@end group
@end example

@noindent
@c __ The reason why it is better to handle anything up to a newline and then
@c __ the newline separately is that otherwise we would create a rule which
@c __ might overflow the internal matching buffer.  This will not work in Lex
@c __ because it does not support exclusive start states.  Actually, this
@c __ example, while easy to understand, is inefficient because it wastes a
@c __ lot of time matching single characters.  It can be sped up considerably
@c __ by making it match longer amounts of text.  It can be rewritten as:
改行の１つ前までと改行とを別々に処理した方が良いのは、
そうしないと、
内部のマッチ処理用のバッファをオーバーフローさせてしまうようなルールを作ることになってしまうからです。
Lexは排他的スタート状態をサポートしていないので、
このコードはLexでは動きません。
この例は分かりやすいのですが、
実際には単一文字をマッチするのに多くの時間を無駄に消費するため、
非効率的です。
もっと長いテキストにマッチするように変更することで、
スピードをかなり向上させることができます。
例えば、
以下のように書き直すことができます。

@c __ @vindex @code{%x} @r{sample with longer matched text}
@vindex @code{%x} @r{より長いテキストにマッチするサンプル}
@example
@group
%x COMMENT
%%
"/*"                     BEGIN(COMMENT);
<COMMENT>[^*\n]*         
<COMMENT>[^*\n]*\n
@c __ <COMMENT>"*"+[^*/\n]*    /* scan for extra *'s */
<COMMENT>"*"+[^*/\n]*    /* 余分な*を探す */
<COMMENT>"*"+[^*/\n]*\n
<COMMENT><<EOF>>         yyerror("EOF in comment");
<COMMENT>"*"+"/"         BEGIN(INITIAL);
@end group
@end example

@noindent
@c __ This is almost exactly the same as the example found in
@c __ @code{flexdoc.1} distributed with Flex.  This is much faster because it
@c __ matches longer blocks of text, and does not need to match the newline in
@c __ a rule by itself.
これは、
Flexと一緒に配布されている@code{flexdoc.1}の中にある例とほとんど同一です。
より長いテキスト・ブロックにマッチするため、
はるかに高速ですし、
ルールの中で改行のみにマッチさせる必要もありません。

@c +--------------------------------------------------------------------+
@c |                                                                    |
@c | This section shows how to handle strings in Flex                   |
@c |                                                                    |
@c +-----------------+-----------------+-----------------+--------------+ 
@c |       Name      |       Next      |     Previous    |       Up     |
@c +-----------------+-----------------+-----------------+--------------+ 
@c @node    Handling Strings, Handling Numbers, Handling Comments, Useful Code
@node    Handling Strings, Handling Numbers, Handling Comments, Useful Code
@c __ @section Handling String Literals
@section 文字列リテラルの処理
@c       ########################

@c __ Strings are slightly different from comments in that we are not throwing
@c __ away the input.  The basic approach is the same though.  First, we can
@c __ handle strings with @code{input()}.  The code to do that is:
文字列は、
それが入力として与えられた時に破棄されないという点で、
コメントとは若干異なります。
しかし、
基本的なアプローチは同じです。
第１の方法としては、
@code{input()}を使って文字列を処理することができます。
コードは以下のようになります。

@c __ @cindex Handling escape sequences
@c __ @cindex Escape sequences, scanning
@cindex エスケープ・シーケンスの取り扱い
@cindex エスケープ・シーケンス、スキャン処理
@example
@group
@c __ /* 
@c __  * string1.lex: Handling strings by using input()
@c __  */
/*
 * string1.lex: input()を使って文字列を処理する
 */

%@{
#include <stdio.h>
#include <malloc.h>
#include <ctype.h>

@c __ #define ALLOC_SIZE 32 /* for (re)allocating the buffer */                   
#define ALLOC_SIZE 32 /* バッファの（再）割り当て用 */

#define isodigit(x) ((x) >= '0' && (x) <= '7') 
#define hextoint(x) (isdigit((x)) ? (x) - '0'\
                                   : ((x) - 'A') + 10)  

@end group
@group
void yyerror(char *message)
@{
  printf("\nError: %s\n",message);
@}

%@}

@end group
@group
%%

\" @{
   int  inch,count,max_size;
   char *buffer;
   int  temp;

@end group
@group
   buffer   = malloc(ALLOC_SIZE);
   max_size = ALLOC_SIZE;
   inch     = input();
   count    = 0;
@end group
@group
   while(inch != EOF && inch != '"' && inch != '\n')@{
      if(inch == '\\')@{
        inch = input();
        switch(inch)@{
        case '\n': inch = input(); break;
        case 'b' : inch = '\b';    break;
        case 't' : inch = '\t';    break;
        case 'n' : inch = '\n';    break;
        case 'v' : inch = '\v';    break;
        case 'f' : inch = '\f';    break;
@end group
@group
        case 'r' : inch = '\r';    break;
        case 'X' :  
        case 'x' : inch = input();
                   if(isxdigit(inch))@{
                     temp = hextoint(toupper(inch));
                     inch = input();
@end group
@group
                     if(isxdigit(inch))@{
                       temp = (temp << 4) + 
                             hextoint(toupper(inch));
                     @} else @{
                       unput(inch);
                     @}
                     inch = temp; 
                   @} else @{
                     unput(inch);
                     inch = 'x';
                   @}
           break;
@end group
@group
        default:
           if(isodigit(inch))@{
              temp = inch - '0';
              inch = input();
@end group
@group
              if(isodigit(inch))@{
                temp = (temp << 3) + (inch - '0');
              @} else @{
                unput(inch);
                goto done;
              @}
              inch = input();
@end group
@group
              if(isodigit(inch))@{
                temp = (temp << 3) + (inch - '0');
              @} else @{
                unput(inch);
              @}
           done:
              inch = temp; 
           @}
        @} 
     @}
@end group
@group
      buffer[count++] = inch;
      if(count >= max_size)@{
         buffer = realloc(buffer,max_size + ALLOC_SIZE);
         max_size += ALLOC_SIZE;
      @}           
      inch = input();
   @}
@end group
@group
   if(inch == EOF || inch == '\n')@{
     yyerror("Unterminated string.");
   @}
   buffer[count] = '\0';
   printf("String = \"%s\"\n",buffer);
   free(buffer);
 @}
.  
\n
%%
@end group
@end example

@noindent
@c __ This scanner handles multi-line strings and various escape sequences.  It uses
@c __ a dynamic buffer so that strings can be of any size.  The code to do the
@c __ same thing using start states is:
このスキャナは、
複数行にわたる文字列や、
様々なエスケープ・シーケンスを処理します。
また、
文字列がどのような長さでも構わないように、
動的バッファを使っています。
これと同じことをスタート状態を使って行うコードは、
以下のようになります。

@c __ @vindex @code{%x} @r{sample with  multi-line strings}
@vindex @code{%x} @r{複数行文字列を使用したサンプル}
@c __ @cindex Hexadecimal constants
@c __ @cindex Octal constants
@cindex 16進定数
@cindex 8進定数
@example
@group
@c __ /*
@c __  * string2.lex: An example of using scanning strings
@c __  *              by using start states.  
@c __  */
/*
 * string2.lex: スタート状態を使って文字列をスキャンする例
 */

%@{
#include <ctype.h>

@end group
@group
#define isodigit(x) ((x) >= '0' && (x) <= '7') 
#define hextoint(x) (isdigit((x)) ? (x) - '0' \
                                  : ((x) - 'A') + 10)  

@end group
@group
char *buffer      = NULL;
int  buffer_size  = 0;

@end group
@group
void yyerror(char *message)
@{
  printf("\nError: %s\n",message);
@}

%@}

%x STRING

hex (x|X)[0-9a-fA-F]@{1,2@}
oct [0-7]@{1,3@}

@end group
@group
%%

\"                @{ 
                    buffer      = malloc(1); 
                    buffer_size = 1; strcpy(buffer,"");
                    BEGIN(STRING);
                  @}
@end group
@group
<STRING>\n        @{
                     yyerror("Unterminated string");       
                     free(buffer);
                     BEGIN(INITIAL);
                  @}
@end group
@group
<STRING><<EOF>>   @{
                     yyerror("EOF in string");       
                     free(buffer);
                     BEGIN(INITIAL);
                  @}
@end group
@group
<STRING>[^\\\n"]  @{
                    buffer_size += yyleng;
                    buffer = realloc(buffer,buffer_size+1);
                    strcat(buffer,yytext);
                  @}
@end group
@group
@c __ <STRING>\\\n      /* Ignore escaped. */
<STRING>\\\n      /* エスケープされた改行を無視する */
<STRING>\\@{hex@} @{
                    int temp =0,loop = 0, foo;
                    for(loop=yyleng-2; loop>0; loop--)@{
                      temp <<= 4;
                      foo    = toupper(yytext[yyleng-loop]);
                      temp += hextoint(foo);
                    @} 
                    buffer = realloc(buffer,buffer_size+1);
                    buffer[buffer_size-1] = temp;
                    buffer[buffer_size]   = '\0';
                    buffer_size += 1;
                  @}
@end group
@group
<STRING>\\@{oct@} @{
                    int temp =0,loop = 0;
                    for(loop=yyleng-1; loop>0; loop--)@{
                      temp  <<= 3;
                      temp  += (yytext[yyleng-loop] - '0');
                    @} 
                    buffer = realloc(buffer,buffer_size+1);
                    buffer[buffer_size-1] = temp;
                    buffer[buffer_size]   = '\0';
                    buffer_size += 1;
                  @}
@end group
@group
<STRING>\\[^\n]   @{
                    buffer = realloc(buffer,buffer_size+1);
                    switch(yytext[yyleng-1])@{
                    case 'b' : buffer[buffer_size-1] = '\b';  
                               break;
                    case 't' : buffer[buffer_size-1] = '\t';
                               break;
@end group
@group
                    case 'n' : buffer[buffer_size-1] = '\n';
                               break;
                    case 'v' : buffer[buffer_size-1] = '\v';
                               break;
                    case 'f' : buffer[buffer_size-1] = '\f';
                               break;
@end group
@group
                    case 'r' : buffer[buffer_size-1] = '\r';
                               break;
                    default  : buffer[buffer_size-1] = 
                                    yytext[yyleng-1];
                    @}
                    buffer[buffer_size] = '\0';
                    buffer_size += 1;
                  @}
@end group
@group
<STRING>\"        @{
                    printf("string = \"%s\"",buffer); 
                    free(buffer);
                    BEGIN(INITIAL);
                  @}
%%
@end group
@end example

@noindent
@c __ This scanner is more modular than @code{string1.lex}, and
@c __ perhaps easier to understand.  Note that the error rules return back to
@c __ the @code{INITIAL} state.  If we did not do this, the scanner would
@c __ merge illegal and legal strings.  Again, we have used a dynamic buffer
@c __ rather than rely on the Flex buffer (@code{YY_BUF_SIZE}) being big
@c __ enough.  If you are sure that the internal buffers will be big enough,
@c __ it is possible to use only @code{yytext}.  The important point when
@c __ doing this is to make sure that the right-hand side of @code{yytext}
@c __ remains in its original position.  For more information, refer to the
@c __ @code{yymore} entry in @ref{Flex and C}.
このスキャナは、
@code{string1.lex}よりもモジュール化されていて、
おそらくはより分かりやすいでしょう。
エラーのルールは、
@code{INITIAL}状態に戻るようになっていることに注意してください。
こうしないと、
スキャナは不当な文字列と正当な文字列とを結合してしまいます。
ここでも、
Flexのバッファ（@code{YY_BUF_SIZE}）が十分に大きいということをあてにせず、
動的バッファを使いました。
内部バッファが十分に大きいという確信が持てるのであれば、
@code{yytext}だけを使うことも可能です。
この場合には、
@code{yytext}の右端が確実に最初の位置に留まるようにすることが重要です。
より詳しい情報については、
@ref{Flex and C}の@code{yymore}の項を参照してください。
@c __ @cindex Recursion
@cindex 再帰

@c +--------------------------------------------------------------------+
@c |                                                                    |
@c | This section shows how to handle numbers in Flex                   |
@c |                                                                    |
@c +-----------------+-----------------+-----------------+--------------+ 
@c |       Name      |       Next      |     Previous    |       Up     |
@c +-----------------+-----------------+-----------------+--------------+ 
@c @node    Handling Numbers, Multiple Scanners, Handling Strings, Useful Code
@node    Handling Numbers, Multiple Scanners, Handling Strings, Useful Code
@c __ @section Handling Numbers
@section 数字の処理
@c       ################

@c __ Here are some common definitions for various numeric formats found in C
@c __ and an example of their usage.  The mains things to take note of are the
@c __ use of @code{scanf()} to get the values of the numbers, and the default
@c __ rule of scanning a @code{long} value to protect against overflow.  Using
@c __ @code{sscanf()} is generally the best way to convert @code{yytext} to a
@c __ number.
ここでは、
Cに見られる様々な数値形式に対してよく使われる定義をいくつか示し、
さらにその使い方の実例を１つ示します。
注目すべき主要な点は、
数の値を獲得するために@code{scanf()}を使っている点と、
オーバーフローが発生しないよう@code{long}型の値をスキャンするデフォルトのルールです。
一般的には、
@code{yytext}を数に変換する最良の方法は、
@code{sscanf()}を使うことです。

@example
@group
@c __ /*
@c __  * numbers.lex : An example of the definitions and techniques
@c __  *               for scanning numbers
@c __  */
/*
 * numbers.lex : 数をスキャンするための定義およびテクニックの実例
 */

%@{
#include <stdio.h>

@end group
#define UNSIGNED_LONG_SYM   1
#define SIGNED_LONG_SYM     2
#define UNSIGNED_SYM        3
#define SIGNED_SYM          4
#define LONG_DOUBLE_SYM     5
#define FLOAT_SYM           6

@group
union _yylval @{
  long double    ylong_double;
  float          yfloat; 
  unsigned long  yunsigned_long;
@end group
@group
  unsigned       yunsigned;
  long           ysigned_long;
  int            ysigned;
@} yylval;

%@}

@end group
@group
digit          [0-9]
hex_digit      [0-9a-fA-F]
oct_digit      [0-7]

@end group
@group
exponent       [eE][+-]?@{digit@}+
i              @{digit@}+
float_constant (@{i@}\.@{i@}?|@{i@}?\.@{i@})@{exponent@}?
hex_constant   0[xX]@{hex_digit@}+
@end group
oct_constant   0@{oct_digit@}*
int_constant   @{digit@}+
long_ext       [lL]
unsigned_ext   [uU]
float_ext      [fF]
ulong_ext      [lL][uU]|[uU][lL]

@group
%%

@c __ @{hex_constant@}@{ulong_ext@} @{  /* skip the "0x" part */
@{hex_constant@}@{ulong_ext@} @{  /* 0xの部分をスキップする */
                             sscanf(&yytext[2],"%lx",
                                    &yylval.yunsigned_long); 
                             return(UNSIGNED_LONG_SYM);
                          @}
@end group
@group
@{hex_constant@}@{long_ext@}  @{  
                             sscanf(&yytext[2],"%lx",
                                    &yylval.ysigned_long); 
                             return(SIGNED_LONG_SYM);
                          @}
@end group
@group
@{hex_constant@}@{unsigned_ext@}  @{ 
                             sscanf(&yytext[2],"%x",
                                    &yylval.yunsigned); 
                             return(UNSIGNED_SYM);
                          @}
@end group
@group
@c __ @{hex_constant@}   @{ /* use %lx to avoid overflow */
@{hex_constant@}   @{ /* オーバーフローを回避するために%lxを使う */
                             sscanf(&yytext[2],"%lx",
                                    &yylval.ysigned_long); 
                             return(SIGNED_LONG_SYM);
                          @}
@end group
@group
@{oct_constant@}@{ulong_ext@} @{
                             sscanf(yytext,"%lo",
                                    &yylval.yunsigned_long); 
                             return(UNSIGNED_LONG_SYM);
                          @}
@end group
@group
@{oct_constant@}@{long_ext@}  @{
                             sscanf(yytext,"%lo",
                                    &yylval.ysigned_long); 
                             return(SIGNED_LONG_SYM);
                          @}
@end group
@group
@{oct_constant@}@{unsigned_ext@}  @{
                             sscanf(yytext,"%o",
                                    &yylval.yunsigned); 
                             return(UNSIGNED_SYM);
                          @}
@end group
@group
@c __ @{oct_constant@} @{ /* use %lo to avoid overflow */
@{oct_constant@} @{ /* オーバーフローを回避するために%loを使う */
                             sscanf(yytext,"%lo",
                                    &yylval.ysigned_long); 
                             return(SIGNED_LONG_SYM);
                          @}
@end group
@group
@{int_constant@}@{ulong_ext@} @{
                             sscanf(yytext,"%ld",
                                    &yylval.yunsigned_long); 
                             return(UNSIGNED_LONG_SYM);
                          @}
@end group
@group
@{int_constant@}@{long_ext@}  @{
                             sscanf(yytext,"%ld",
                                    &yylval.ysigned_long); 
                             return(SIGNED_LONG_SYM);
                          @}
@end group
@group
@{int_constant@}@{unsigned_ext@}  @{
                             sscanf(yytext,"%d", 
                                    &yylval.yunsigned); 
                             return(UNSIGNED_SYM);
                          @}
@end group
@group
@c __ @{int_constant@} @{ /* use %ld to avoid overflow */
@{int_constant@} @{ /* オーバーフローを回避するために%ldを使う */
                             sscanf(yytext,"%ld",
                                    &yylval.ysigned_long); 
                             return(SIGNED_LONG_SYM);
                          @}
@end group
@group
@{float_constant@}@{long_ext@}  @{
                             sscanf(yytext,"%lf",
                             &yylval.ylong_double); 
                             return(LONG_DOUBLE_SYM);
                          @}
@end group
@group
@{float_constant@}@{float_ext@}  @{
                             sscanf(yytext,"%f",
                                    &yylval.yfloat); 
                             return(FLOAT_SYM);
                          @}
@end group
@group
@c __ @{float_constant@} @{ /* use %lf to avoid overflow */
@{float_constant@} @{ /* オーバーフローを回避するために%lfを使う */
                             sscanf(yytext,"%lf",
                                    &yylval.ylong_double); 
                             return(LONG_DOUBLE_SYM);
                          @}
@end group
@group
%%

int main(void)
@{
  int code;

  while((code = yylex()))@{
    printf("yytext          : %s\n",yytext);
    switch(code)@{
@end group
@group
    case UNSIGNED_LONG_SYM:
       printf("Type of number  : UNSIGNED LONG\n");
       printf("Value of number : %lu\n",
              yylval.yunsigned_long);
       break;
@end group
@group
    case SIGNED_LONG_SYM:  
       printf("Type of number  : SIGNED LONG\n");
       printf("Value of number : %ld\n",
              yylval.ysigned_long);
       break;
@end group
@group
    case UNSIGNED_SYM:     
       printf("Type of number  : UNSIGNED\n");
       printf("Value of number : %u\n",
              yylval.yunsigned);
       break;
@end group
@group
    case SIGNED_SYM:       
       printf("Type of number  : SIGNED\n");
       printf("Value of number : %d\n",
              yylval.ysigned);
       break;
@end group
@group
    case LONG_DOUBLE_SYM:  
       printf("Type of number  : LONG DOUBLE\n");
       printf("Value of number : %lf\n",
              yylval.ylong_double);
       break;
@end group
@group
    case FLOAT_SYM:        
       printf("Type of number  : FLOAT\n");
       printf("Value of number : %f\n",
              yylval.yfloat);
       break;
@end group
@group
    default:
       printf("Type of number  : UNDEFINED\n");
       printf("Value of number : UNDEFINED\n");
       break;
    @}
  @}
  return(0);
@}
@end group
@end example

@noindent
@c __ Note also that for hexadecimal constants, we need to skip the leading
@c __ @samp{0x} when we convert them---this a feature of @code{sscanf()}.
16進定数については、
変換する前に先頭の@samp{0x}をスキップする必要がある点に注意してください。
これは@code{sscanf()}の仕様です。

@c +--------------------------------------------------------------------+
@c |                                                                    |
@c | This explains how to include multiple scanners in a program        |
@c |                                                                    |
@c +-----------------+-----------------+-----------------+--------------+ 
@c |       Name      |       Next      |     Previous    |       Up     |
@c +-----------------+-----------------+-----------------+--------------+ 
@c @node    Multiple Scanners, Miscellaneous, Handling Numbers, Useful Code
@node    Multiple Scanners, Miscellaneous, Handling Numbers, Useful Code
@c __ @section Multiple Scanners
@section 複数のスキャナ
@c       #################

@c __ It is sometimes necessary to have more than one scanner in a program,
@c __ but if we do this, the linker will complain about functions and
@c __ variables that appear more than once.  What we need to do is to rename
@c __ the scanner, and everything associated with it.  This is extremely easy
@c __ to do because all the scanner functions, macros and data start with
@c __ either @samp{yy} or @samp{YY}.  All we have to do is change the prefix.
@c __ We can to this easily using @code{sed}, but just for fun, here's a flex
@c __ scanner to do it.
時には、
１つのプログラムの中で複数のスキャナを持つ必要がある場合がありますが、
こうすると、
２回以上現れる関数や変数について、
リンカが文句を言ってきます。
これを回避するためには、
スキャナとそれに関連するすべてのものの名前を変更する必要があります。
すべてのスキャナ関数、マクロ、およびデータの名前は@samp{yy}もしくは@samp{YY}で始まりますので、
これはきわめて簡単です。
しなければならないことは、
名前の接頭辞を変更することだけです。
@c @ifset INCLUDEFLEX25INFO
これは@code{sed}を使って簡単に行うことができますが、
ここではおもしろ半分で、
これを行うflexスキャナを示しましょう。@footnote{訳注：Flex 2.5では、
Flex起動時に@samp{-P@var{prefix}}オプションを指定するか、
スキャナ定義ファイルの中に@samp{%option prefix="@var{prefix}"}を指定することによって、
接頭辞@samp{yy}を別の文字列に変更することができます。}
@c @end ifset
@c @ifclear INCLUDEFLEX25INFO
@c これは@code{sed}を使って簡単に行うことができますが、
@c ここではおもしろ半分で、
@c これを行うflexスキャナを示しましょう。
@c @end ifclear

@example
@group
@c __ /*
@c __  * replace.lex : A simple filter for renaming
@c __  *               parts of flex or bison generated
@c __  *               scanners or parsers.  
@c __  */
/*
 * replace.lex : flexにより生成されたスキャナや
 *               bisonにより生成されたパーサの
 *               一部の名前を変更する簡単なフィルタ
 */

%@{
#include <stdio.h>

char lower_replace[1024];
char upper_replace[1024];

%@}

@end group
@group
%%

"yy"   fprintf(yyout,"%s",lower_replace);
"YY"   fprintf(yyout,"%s",upper_replace);

@end group
@group
%%

int main(argc,argv)
int argc;
char **argv;
@{
   if(argc < 3)@{
     printf("Usage %s lower UPPER\n",argv[0]);
     exit(1);
   @}
   strcpy(lower_replace,argv[1]);
   strcpy(upper_replace,argv[2]);
   yylex();
   return(0);
@}
@end group
@end example

@noindent
@c __ So we can convert all the scanner functions with a command line like:
すべてのスキャナ関数の名前を変更するには、
コマンドライン上で以下のように実行するだけです。

@example
replace myscan_ MYSCAN_ < lex.yy.c > myscan.c
@end example

@noindent
@c __ which will allow us to include as many scanners as we want.  It is also
@c __ possible to accomplish much the same thing using exclusive start states,
@c __ and multiple buffers, though it is somewhat more complicated.
これにより、
好きなだけ多くのスキャナを含めることができるようになります。
ほとんど同じことを、
排他的スタート状態と複数のバッファを使って実現することも可能ですが、
その方法は多少複雑になります。

@c __ @strong{Please note:} @i{Some internal Flex routines will be moved into
@c __ the Flex library (@samp{-lfl}) in the future, and then this technique
@c __ will not work.  However, when the change occurs, Flex itself will
@c __ support a method of renaming the functions that need to be changed.  }
@c @ifset INCLUDEFLEX25INFO
@strong{注：}@i{いくつかのFlex内部ルーチンは、
将来Flexライブラリ（@samp{-lfl}）の中に移されるでしょう。
そうなると、
このテクニックは機能しなくなります。
しかし、
この変更が行われる時には、
変更する必要のある関数名を変更する方法を、
Flex自身がサポートするようになるでしょう。}@footnote{訳注：Flex 2.5では、
@samp{-P@var{prefix}}オプションや@samp{%option prefix="@var{prefix}"}を指定することにより、
関数名を変更することができます。}
@c @end ifset
@c @ifclear INCLUDEFLEX25INFO
@c @strong{注：}@i{いくつかのFlex内部ルーチンは、
@c 将来Flexライブラリ（@samp{-lfl}）の中に移されるでしょう。
@c そうなると、
@c このテクニックは機能しなくなります。
@c しかし、
@c この変更が行われる時には、
@c 変更する必要のある関数名を変更する方法を、
@c Flex自身がサポートするようになるでしょう。}
@c @end ifclear

@c +--------------------------------------------------------------------+
@c |                                                                    |
@c | Other useful code and notes on using Flex                          |
@c |                                                                    |
@c +-----------------+-----------------+-----------------+--------------+ 
@c |       Name      |       Next      |     Previous    |       Up     |
@c +-----------------+-----------------+-----------------+--------------+ 
@c @node    Miscellaneous,  , Multiple Scanners, Useful Code
@node    Miscellaneous,  , Multiple Scanners, Useful Code
@c __ @section Miscellaneous
@section その他
@c       #############

@itemize @bullet
@item
@c __ @b{Counting lines}
@b{行数のカウント}

@c __ If you want to count lines, just put a variable in the top optional C
@c __ code section, and then check for the newline.  Make sure you also check
@c __ for newlines in start states or the line count could go wrong.  For
@c __ example:
行数をカウントしたいのであれば、
ファイルの先頭のオプションのCコード・セクションに変数を定義して、
改行をチェックします。
スタート状態の中でも改行をチェックするのを忘れないようにしてください。
さもないと、
行数のカウントはうまくいきません。
例えば、
以下のようにします。

@example
@group
%@{
int linenumber = 0;
%@}
@end group
@group
%x COMMENT STRING
%%
"/*"              BEGIN(COMMENT);
<COMMENT>\n       line_number += 1;
<COMMENT>[^\n]*
<COMMENT>"*/"     BEGIN(INITIAL);
\"                BEGIN(STRING)
<STRING>\\\n      line_number += 1;
<STRING>[^\n\\\"]*
<STRING>\"        BEGIN(INITIAL);
\n                line_number += 1;
@end group
@end example

@c =================================================================
@c TODO: this example is too thin to be very illuminating
@c =================================================================

@item
@c __ @b{Scanners and sockets}
@b{スキャナとソケット}

@c __ You can attach scanners (and hence Bison parsers) to sockets by
@c __ redirecting @code{yyin} and @code{yyout}.  You do this with the
@c __ @code{fdopen()} call.  For example:
@code{yyin}と@code{yyout}をリダイレクトすることによって、
スキャナを
（したがってBisonによるパーサをも）
ソケットにアタッチすることができます。
これは、
@code{fdopen()}を呼び出すことによって行います。
例えば、
以下のようになります。

@c __ @vindex @code{yyin}@r{, and sockets}
@c __ @vindex @code{yyout}@r{, and sockets}
@vindex @code{yyin}@r{とソケット}
@vindex @code{yyout}@r{とソケット}
@example
@group
yyin  = fdopen(connection, "r");
yyout = fdopen(connection, "w");
@end group
@end example

@noindent
@c __ where @code{connection} is the file descriptor of the socket connection
@c __ established.
ここで@code{connection}は、
確立されたソケット・コネクションのファイル・ディスクリプタです。
@end itemize

@c +--------------------------------------------------------------------+
@c |                                                                    |
@c | Summary of almost everything.                                      |
@c |                                                                    |
@c +-----------------+-----------------+-----------------+--------------+ 
@c |       Name      |       Next      |     Previous    |       Up     |
@c +-----------------+-----------------+-----------------+--------------+ 
@c @node    Summary, Index, Useful Code, Top
@node    Summary, Index, Useful Code, Top
@c __ @chapter Summary 
@chapter 要約

@quotation
@c __ @i{The following section will summarize all the pertinent information
@c __ about using Flex.  You can use this as a quick reference.}
@i{ここでは、
Flexの使用に関連するすべての情報を要約します。
この情報は、
クイック・リファレンスとして使うことができます。}
@end quotation

@ifnottex
========================================================================
@c __ @menu
@c __ * Switches Summary::            A summary of Flex command line switches 
@c __ * Summary or Flex Variables and Functions::  Summary of Flex variables 
@c __                                 and functions
@c __ * Summary of Flex Characters::  Flex accepts a character as itself, 
@c __                                 unless it is an operator, a special
@c __                                 character, or an escape sequence.  
@c __ * Summary of Flex Rules::       Rules in Flex have two parts.
@c __ @end menu
@menu
* Switches Summary::            Flexコマンドライン・オプションの要約
@c @ifset INCLUDEFLEX25INFO
* Switches Summary (Flex 2.5)::  同上（Flex 2.5の補足情報）
@c @end ifset
* Summary or Flex Variables and Functions::  Flex変数、Flex関数の要約
@c @ifset INCLUDEFLEX25INFO
* Summary or Flex Variables and Functions (Flex 2.5)::  
                                             同上（Flex 2.5の補足情報）
@c @end ifset
* Summary of Flex Characters::  演算子、特殊文字、エスケープ・シーケンス
                                以外の文字をその文字自身として受け付ける
* Summary of Flex Rules::       Flexルールの２つの構成要素
@end menu
========================================================================
@end ifnottex

@c +--------------------------------------------------------------------+
@c |                                                                    |
@c | Summary of switches                                                |
@c |                                                                    |
@c +-----------------+-----------------+-----------------+--------------+ 
@c |       Name      |       Next      |     Previous    |       Up     |
@c +-----------------+-----------------+-----------------+--------------+ 
@c @node    Switches Summary, Summary or Flex Variables and Functions, Summary, Summary
@node    Switches Summary, Switches Summary (Flex 2.5), Summary, Summary
@c __ @section Summary of Flex Command Line Options
@section Flexコマンドライン・オプションの要約
@comment ####################################
@c __ @cindex  Flex command line options
@c __ @cindex  Command line options
@cindex  Flexコマンドライン・オプション
@cindex  コマンドライン・オプション

@noindent
@c __ Flex has the following command line options:
Flexには、
以下のコマンドライン・オプションがあります。

@itemize
@table @kbd
@vindex @kbd{-b}
@item -b
@c __ This option generates a file called @file{lex.backtrack} that contains
@c __ information about rules that create states where backtracking is
@c __ necessary.  @xref{Optimizing for Speed}, and 
@c __ @ref{Removing Backtracking},
@c __ for more details on why this information is important and how to use it.
このオプションは、
バックトラッキングを必要とする状態をもたらすルールに関する情報を含む、
@file{lex.backtrack}というファイルを生成します。
なぜこの情報が重要なのか、
また、
この情報をどのように使うかという点に関する詳細については、
@ref{Optimizing for Speed}と@ref{Removing Backtracking}を参照してください。

@vindex @kbd{-c}
@item -c
@c __ This option is only included for POSIX compliance, and does nothing.
@c __ This was once used for controlling table compression, but that function
@c __ has been moved to the @samp{-C} option.  Now if Flex encounters this
@c __ flag it assumes table compression is desired and produces a warning.  In
@c __ the future, this warning may disappear.
このオプションは、
POSIXとの互換性のためだけに提供されており、
実際には何もしません。
以前は、
テーブル圧縮を制御するために使われていましたが、
その機能は@samp{-C}オプションに移されました。
このフラグを見つけると、
Flexはユーザがテーブル圧縮を希望しているものと想定し、
警告メッセージを出力します。
@c @ifset INCLUDEFLEX25INFO
将来、
この警告メッセージは出力されないようになるかもしれません。@footnote{訳注：Flex 2.5では、
この警告メッセージは出力されません。}
@c @end ifset
@c @ifclear INCLUDEFLEX25INFO
@c 将来、
@c この警告メッセージは出力されないようになるかもしれません。
@c @end ifclear

@vindex @kbd{-d}
@item -d
@c __ This is used for debugging.  This generates a scanner that writes
@c __ scanner state information to @code{yyout} while it is running.  Whenever
@c __ a rule is matched it writes:
デバッグに使われます。
実行中に自身の状態情報を@code{yyout}に書き込むスキャナを生成します。
あるルールがマッチするたびに、
バックトラッキングに関する情報、検出されたバッファの終端、@code{NUL}に関する情報に加えて、
以下のような情報が書き込まれます。

@example
@c __ --accepting rule at line @i{line #} ("@i{matched text}")
--accepting rule at line @i{行番号} ("@i{マッチしたテキスト}")
@end example

@noindent
@c __ as well as writing information about backtracking, end of buffers and
@c __ @code{NUL}'s encountered.  This line number refers to the description
@c __ file used to generate the scanner, not the @file{lex.yy.c} file
@c __ generated (unless the @samp{-L} option was used).
@c __ 最初の文は、@example の前で既に訳されている
この中の行番号は
（@samp{-L}オプションが使われていない場合には）、
生成されたファイル@file{lex.yy.c}ではなく、
スキャナを生成するのに使われた記述ファイルの行番号を指します。

@vindex @kbd{-f}
@item -f
@c __ This generates a @emph{full} scanner.  No compression is done.  This is
@c __ the same as @samp{-Cf} (@xref{Table Compression and Scanner Speed}, 
@c __ for more information).
@emph{フル}・スキャナ（@emph{full} scanner）を生成します。
圧縮は一切行われません。
これは、
@samp{-Cf}と同等です
（詳細については、
@xref{Table Compression and Scanner Speed}）。

@vindex @kbd{-i}
@item -i
@c __ This tells Flex to make a case-insensitive scanner.  Case is ignored in
@c __ the matching of rules, though characters are not @emph{converted} so
@c __ @code{yytext} contains characters of mixed case.
大文字・小文字の区別を無視するスキャナを作成するよう、
Flexに通知します。
ルールのマッチ処理において大文字・小文字の区別は無視されますが、
個々の文字は大文字または小文字に@emph{変換}されないので、
@code{yytext}には大文字・小文字が混在した文字の並びが入ることになります。

@vindex @kbd{-n}
@item -n
@c __ This option has no meaning for Flex and is only included for POSIX
@c __ compliance.
このオプションは、
Flexに対してはまったく意味を持たず、
単にPOSIXとの互換性のためだけに提供されています。

@vindex @kbd{-p}
@item -p
@c __ This tells Flex to write a performance report to @code{stderr}.  The
@c __ report consists of comments regarding features of the scanner
@c __ description that will degrade performance.
性能に関する情報を@code{stderr}に書き込むよう、
Flexに通知します。
報告される情報は、
性能を低下させるようなスキャナ記述情報の機能に関するコメントによって構成されます。

@vindex @kbd{-s}
@item -s
@c __ The default action of a Flex scanner when it fails to match 
@c __ anything is to write
@c __ the unmatched input to @code{stdout}.  This option suppresses this
@c __ action and instead aborts the scanner on unmatched input.
マッチするものがなかった場合のFlexスキャナのデフォルトのアクションは、
マッチしなかった入力情報を@code{stdout}に書き込むことです。
@samp{-s}オプションはこのアクションを抑制し、
その代わりに、
入力がマッチしないとすぐにスキャナを異常終了させます。

@vindex @kbd{-t}
@c __ @cindex Redirecting scanner generation, @samp{-t}
@cindex スキャナの生成結果のリダイレクト、@samp{-t}
@item -t
@c __ Flex will write the generated scanner to @code{stdout} instead of the
@c __ file @file{lex.yy.c} if this option is specified .
このオプションが指定されると、
Flexは生成されたスキャナをファイル@file{lex.yy.c}にではなく、
@code{stdout}に書き込みます。

@vindex @kbd{-v}
@item -v
@c __ This tells Flex to operate in @emph{verbose} mode.  Flex will generate a
@c __ summary of statistics about the generated scanner to @code{stdout}.  The
@c __ first line of the summary has the Flex version number, the next line has
@c __ the date and time, and the next line shows which options are in effect.
@c __ The rest of the summary has little meaning unless you understand the
@c __ details of how Flex and other such programs work.
@emph{冗長}モードで動作するよう、
Flexに通知します。
Flexは、
生成されたスキャナに関する統計情報の要約を生成して、
@code{stdout}に出力します。
要約情報の第１行にはFlexのバージョン番号、
次の行には日付と時刻、
さらに次の行には実際に使われているオプションが示されます。
要約情報のこれ以外の部分は、
Flexやその他の同様のプログラムの動作の詳細を理解している人以外にはほとんど意味を持ちません。

@vindex @kbd{-F} 
@item -F
@c __ This tells Flex to generate a @emph{fast} scanner.  This is the same as
@c __ using @samp{-CF}.  
@c __ @xref{Optimization, , Optimizing the Scanner}, for more details.
@emph{ファスト}・スキャナ（@emph{fast} scanner）を生成するよう、
Flexに通知します。
これは、
@samp{-CF}と同等です。
詳細については、
@xref{Optimization, , スキャナの最適化}。

@vindex @kbd{-I}
@item -I
@c __ This option tells Flex to generate an @emph{interactive} scanner which
@c __ can be used in shells or programs that need to accept typed input.
@c __ @xref{Interactive Scanners}, for more details.
このオプションは、
シェル上や、
型を持つ入力情報を受け付ける必要のあるプログラム内で使うことのできる@emph{対話型}スキャナを生成するよう、
Flexに通知します。
詳細については、
@xref{Interactive Scanners}。

@c __ @strong{Please note:} @i{The @samp{-I} option cannot be used with the
@c __ @samp{-Cf}, @samp{-f}, @samp{-CF}, or @samp{-F} switches.  }
@strong{注：}@i{@samp{-I}オプションは、
@samp{-Cf}、@samp{-f}、@samp{-CF}、@samp{-F}の各オプションと一緒に使うことはできません。}

@c __ @cindex @code{#line} directives, controlling
@cindex @code{#line}指示子、制御
@vindex @kbd{-L}
@item -L
@c __ By default Flex generates @code{#line} directives in the generated
@c __ scanner so that errors can be tracked in the scanner definition.  This
@c __ option turns off @code{#line} directive generation.
デフォルトではFlexは、
エラーがスキャナ定義のどこで発生したのかを追跡できるように、
生成されたスキャナのコード中に@code{#line}指示子を生成します。
@samp{-L}オプションは、
この@code{#line}指示子を生成する機能を抑制します。

@vindex @kbd{-T}
@item -T
@c __ This makes Flex run in @dfn{trace} mode.  Flex will generate (to
@c __ @code{stderr}) messages about the input, the scanning tables,
@c __ equivalence classes, and meta-equivalence classes.  This information
@c __ will have little meaning unless you understand the inner workings of
@c __ Flex.
Flexを@dfn{トレース}・モードで実行させます。
Flexは、
入力情報、スキャン処理テーブル、同等クラス（equivalence class）、およびメタ同等クラス（meta-equivalence class）に関するメッセージを生成して、
（@code{stderr}に）書き込みます。
この情報は、
Flexの内部的な動作を理解していない人には、
ほとんど意味を持たないでしょう。

@vindex @kbd{-8}
@item -8
@c __ This option tells Flex to generate a scanner that can accept 8 bit
@c __ input.  The results of giving 8 bit input to a 7 bit scanner are
@c __ unpredictable.
このオプションは、
8ビットの入力情報を受け付けることのできるスキャナを生成するよう、
Flexに通知します。
7ビットの入力情報しか受け付けないスキャナに8ビットの入力情報を与えた場合の結果は、
予測不能です。

@vindex @kbd{-C[efmF]}
@item -C[efmF]
@c __ This tells Flex how to compress the scanning tables.
@c __ @xref{Optimization, , Optimizing the Scanner}, for more details.
スキャン処理テーブルをどのように圧縮するかを、
Flexに通知します。
詳細については、
@xref{Optimization, , スキャナの最適化}を参照してください。

@vindex @kbd{-S}
@item -S@var{skeleton_file}
@c __ This tells Flex to use @var{skeleton_file} as the base for the scanner
@c __ it generates.  This is seldom used, but on MS-DOS it can be used to set
@c __ the path to the standard scanner skeleton.
生成されるスキャナのベースとして、
@var{skeleton_file}で指定されるファイルを使うよう、
Flexに通知します。
これを使うことはほとんどありませんが、
MS-DOS上ではこれによって標準のスキャナ・スケルトンへのパスを設定することができます。

@end table
@end itemize

@c Include Flex 2.5 information, for Flex manual as published by ASCII
@c @ifset INCLUDEFLEX25INFO
@node Switches Summary (Flex 2.5), Summary or Flex Variables and Functions, Switches Summary, Summary
@section Flexコマンドライン・オプションの要約（Flex 2.5の補足情報）
@include switch_summary_addendum-ja.texi
@c @end ifset

@c +--------------------------------------------------------------------+
@c |                                                                    |
@c | Summary of variables and functions.                                |
@c |                                                                    |
@c +-----------------+-----------------+-----------------+--------------+ 
@c |       Name      |       Next      |     Previous    |       Up     |
@c +-----------------+-----------------+-----------------+--------------+ 
@c @node    Summary or Flex Variables and Functions, Summary of Flex Characters, Switches Summary, Summary
@node    Summary or Flex Variables and Functions, Summary or Flex Variables and Functions (Flex 2.5), Switches Summary (Flex 2.5), Summary
@c __ @section Summary of Flex Variables and Functions
@section Flex変数およびFlex関数の要約
@comment ####################################### 
@c __ @cindex  Interfacing Flex and C
@c __ @cindex  Functions and variables, summary
@cindex  FlexとCのインターフェイス
@cindex  関数と変数、要約

@c __ The main C interface to Flex is through the following routines and
@c __ variables.  @xref{Interfacing to Flex}, for full descriptions of each.
Flexに対する主要なCインターフェイスは、
以下のルーチンおよび変数を通じて実現されます。
個々のルーチン、変数に関する完全な説明については、
@xref{Interfacing to Flex}。

@itemize
@table @code 
@c __ @findex @code{yylex()}@r{, summary}
@findex @code{yylex()}@r{、要約}
@item  yylex()
@c __ This is the main interface.  This is the function that does the actual
@c __ scanning.
主要なインターフェイスです。
これが実際のスキャン処理を行う関数です。

@c __ @vindex @code{yyin}@r{, summary}
@vindex @code{yyin}@r{、要約}
@item   yyin
@c __ This is the file from which @code{yylex()} reads characters.  The
@c __ default for this is @code{stdin}.
@code{yylex()}が文字を読み込む元となるファイルです。
このデフォルトは@code{stdin}です。

@c __ @vindex @code{yyout}@r{, summary}
@vindex @code{yyout}@r{、要約}
@item   yyout
@c __ This is the output file for the scanner.  The default is @code{stdout}.
スキャナの出力ファイルです。
デフォルトは@code{stdout}です。

@c __ @vindex @code{yytext}@r{, summary}
@vindex @code{yytext}@r{、要約}
@item   yytext
@c __ This is a global variable that contains the string of characters last
@c __ matched.  That is, it contains the last recognized token.
最後にマッチした文字列を保持する大域変数です。
つまり、
最後に認識されたトークンを保持しています。

@c __ @vindex @code{yyleng}@r{, summary}
@vindex @code{yyleng}@r{、要約}
@item   yyleng
@c __ This is a global variable that contains the length of the last
@c __ recognized token.
最後に認識されたトークンの長さを保持する大域変数です。

@c __ @findex @code{yywrap()}@r{, summary}
@findex @code{yywrap()}@r{、要約}
@item   yywrap()
@c __ This function is called when the end of @code{yyin} has been reached.
@c __ If it returns @code{TRUE} (non-zero) then the scanner terminates, but if
@c __ it returns @code{FALSE} (zero), it is assumed that @code{yyin} has been
@c __ set to point to the next input file, and scanning continues.
この関数は、
@code{yyin}の終端に達した時に呼び出されます。
これが@code{TRUE}（ゼロ以外）を返すとスキャナは実行を終了しますが、
@code{FALSE}（ゼロ）を返すと、
@code{yyin}が次の入力ファイルを指すよう設定されたものと想定し、
スキャン処理は継続されます。

@c __ @findex @code{yymore()}@r{, summary}
@findex @code{yymore()}@r{、要約}
@item   yymore()
@c __ This is a function that tells Flex to append the next token recognized
@c __ to @code{yytext}, rather than overwriting it.
次に認識されるトークンで@code{yytext}の内容を上書きするのではなく、
そのトークンを@code{yytext}の末尾に付加するようFlexに通知する関数です。

@c __ @findex @code{yyless()}@r{, summary}
@findex @code{yyless()}@r{、要約}
@item   yyless(@var{n})
@c __ This is almost the opposite of @code{yymore()}.  This function returns 
@c __ everything except the first @var{n} characters.  The returned characters
@c __ will be used in matching the next token, and @code{yyleng} and
@c __ @code{yytext} will reflect the change.
@code{yymore()}とほぼ反対のことを行います。
この関数は、
最初の@var{n}文字を除くすべての文字を戻します。
戻された文字の並びは、
次のトークンをマッチするのに使われます。
@code{yyleng}と@code{yytext}の内容には、
この変更が反映されます。

@c __ @findex @code{input()}@r{, summary}
@findex @code{input()}@r{、要約}
@item   input()
@c __ This returns the next character from the input.  This is commonly used
@c __ in scanners that cannot be handled cleanly using the standard Flex, or
@c __ in particular, the Lex description language.
入力から次の１文字を返します。
これは、
標準のFlex記述言語や特にLex記述言語を使ったのではうまく処理できないようなスキャナにおいて、
よく使われます。

@c __ @findex @code{unput()}@r{, summary}
@findex @code{unput()}@r{、要約}
@item   unput(@var{c})
@c __ This function returns the character @var{c} to the input stream.  This
@c __ then becomes the next character scanned.
この関数は、
文字@var{c}を入力ストリームに戻します。
この後、
この文字は次にスキャンされる文字になります。

@c __ @findex @code{yyterminate()}@r{, summary}
@findex @code{yyterminate()}@r{、要約}
@item   yyterminate()
@c __ This function, when used in an action, terminates the scanner
@c __ (@code{yylex()}), which then returns 0.  After this, calls to
@c __ @code{yylex()} will immediately return, unless @code{yyrestart()} has
@c __ been called.
この関数は、
アクションの中で使われると、
スキャナ（@code{yylex()}）の実行を終了させます。
終了したスキャナは0を返します。
この後@code{yyrestart()}が呼び出されない間は、
@code{yylex()}を呼び出してもすぐに復帰してしまいます。

@c __ @findex @code{yyrestart()}@r{, summary}
@findex @code{yyrestart()}@r{、要約}
@c __ @cindex Reentrancy and scanners
@cindex 再入可能性とスキャナ
@item yyrestart(@var{file})
@c __ This function tells Flex to restart the scanner. It takes a single
@c __ argument: a file to scan on (usually @code{yyin}). This can be used to
@c __ handle EOF's, and can also be used to give allow Flex to be interrupted,
@c __ and then restarted. (This is necessary because Flex scanners are
@c __ @emph{not} reentrant).
この関数は、
スキャナの実行を再開するようFlexに通知します。
これは、
スキャンすべきファイル（通常は@code{yyin}）を表す引数を１つ取ります。
EOFを処理するのに使うことができますし、
また、
Flexに割り込みをかけ、
その後で再開始することを可能にするために使うこともできます。
（Flexが@emph{再入可能ではない}ので、
このようなことが必要になります。）

@findex @code{ECHO}
@item   ECHO
@c __ This is a macro that copies @code{yytext} to @code{yyout}.
@code{yytext}の内容を@code{yyout}にコピーするマクロです。

@item   REJECT
@c __ This tells the scanner not to recognize the current token, and to select
@c __ the next best match.  The scanner looks for the longest match, and if
@c __ two matches are the same length, it will choose the one which was
@c __ defined first in the scanner description.
カレントなトークンを認識しないで、
次に最もよくマッチするものを選択するよう、
スキャナに通知します。
スキャナは、
マッチするもののうち最も長いものを探します。
マッチするものが２つあってその長さが同じ場合には、
スキャナ記述の中で最初に定義されているものを選択します。

@c __ @findex @code{BEGIN}@r{, summary}
@findex @code{BEGIN}@r{、要約}
@item   BEGIN(@var{state})
@c __ This is used to put the scanner into a certain start state.  The name
@c __ following @code{BEGIN} is the name of the start state, and it must have
@c __ been declared in the definitions section at the top of the scanner
@c __ description.
スキャナをある特定のスタート状態に置くために使われます。
@code{BEGIN}の後ろの名前は、
スタート状態の名前です。
これは、
スキャナ記述の先頭の定義セクションにおいて宣言されているものでなければなりません。

@c __ @findex @code{YY_USER_INIT}@r{, summary}
@findex @code{YY_USER_INIT}@r{、要約}
@item   YY_USER_INIT
@c __ This defines an action to be taken @emph{before} the scanner is
@c __ initialized.  Refer to @ref{Flex and C}, for more details.
スキャナが初期化される@emph{前}に実行されるべきアクションを定義します。
詳細については、
@ref{Flex and C}を参照してください。

@c __ @findex @code{YY_USER_ACTION}@r{, summary}
@findex @code{YY_USER_ACTION}@r{、要約}
@item   YY_USER_ACTION
@c __ This defines an action that takes place after matching but @emph{before}
@c __ any of the actions defined in the rules section.  This can be used to do
@c __ things like convert @code{yytext} from lower to uppercase.  The default
@c __ rule is to do nothing.  Refer to @ref{Flex and C}, for more details.
マッチが発生した後で、
ルール・セクションに定義されたアクションが実行される@emph{前}に、
実行されるべきアクションを定義します。
例えば、
@code{yytext}の内容を小文字から大文字へ変換する等を行うのに使うことができます。
デフォルトのルールでは何も実行されません。
詳細については、
@ref{Flex and C}を参照してください。

@c __ @findex @code{YY_BREAK}@r{, summary}
@findex @code{YY_BREAK}@r{、要約}
@item   YY_BREAK
@c __ This is not really an interface feature, but rather one that can be used
@c __ to alter the generated code.
実際にはインターフェイス機能ではなく、
むしろ生成されるコードを変更するために使うことができるものです。

@c __ In the scanner, all the actions are part of one big @code{switch}
@c __ statement, and are separated using @code{YY_BREAK}, which defaults to
@c __ the @samp{break;} statement.  If the actions part of most rules contain
@c __ a @samp{return;} statement, then the compiler will (or should) generate
@c __ a lot of @samp{statement not reached} errors.  By redefining
@c __ @code{YY_BREAK}, it is possible to stop these warnings.
スキャナの中では、
すべてのアクションは１つの大きな@code{switch}文の構成要素であり、
個々のアクションの区切りは、
デフォルトで@samp{break;}文に変換される@code{YY_BREAK}で与えられます。
もし、
ほとんどのルールのアクション部が@samp{return;}文を含んでいると、
コンパイラは@samp{statement not reached}というエラーをたくさん表示することになるでしょう
（表示するはずです）。
@code{YY_BREAK}を再定義することによって、
この警告メッセージを表示させないようにすることが可能です。

@c __ @strong{Please note:} @i{If you redefine @code{YY_BREAK}, make sure your
@c __ actions finish with @samp{return;} or @samp{break;}.  }
@strong{注：}@i{@code{YY_BREAK}を再定義する場合は、
アクションが必ず@samp{return;}か@samp{break;}で終わるようにしてください。}

@c __ @findex @code{YY_DECL}@r{, summary}
@findex @code{YY_DECL}@r{、要約}
@item   YY_DECL
@c __ This is a macro that defines the name of the scanning function.  The
@c __ default is @code{yylex}, but this may be redefined.  The redefinition
@c __ must be a legal function prototype.
スキャン処理を実行する関数の名前を定義するマクロです。
デフォルトは@code{yylex}ですが、
再定義することができます。
再定義した名前は、
関数のプロトタイプとして正当なものでなければなりません。

@c __ @findex @code{YY_INPUT}@r{, summary}
@findex @code{YY_INPUT}@r{、要約}
@item   YY_INPUT
@c __ This is a macro that defines the name of the input routine.  It can be
@c __ redefined if need arises.  For example, if you are scanning from a
@c __ string, or from some non-standard input device, this can be useful.
入力ルーチンの名前を定義するマクロです。
必要があれば、
この名前は再定義することができます。
例えば、
文字列や、
標準的ではない何らかの入力デバイスを入力として、
スキャン処理を行う場合に役に立ちます。

@c __ @findex @code{YY_NEW_FILE}@r{, summary}
@findex @code{YY_NEW_FILE}@r{、要約}
@item   YY_NEW_FILE
@c __ This is a macro that tells Flex that @code{yyin} has been pointed to a
@c __ new file, and that processing should continue.
@c @ifset INCLUDEFLEX25INFO
@code{yyin}が新しいファイルを指すよう設定されたこと、
および、
処理が継続されるべきであることをFlexに通知するマクロです。@footnote{訳注：Flex 2.5では、
@code{yyin}を変更した後に@code{YY_NEW_FILE}を実行する必要はなくなりました。}
@c @end ifset
@c @ifclear INCLUDEFLEX25INFO
@c @code{yyin}が新しいファイルを指すよう設定されたこと、
@c および、
@c 処理が継続されるべきであることをFlexに通知するマクロです。
@c @end ifclear

@item   YY_CURRENT_BUFFER
@c __ This is a macro which returns the current input buffer.  
カレントな入力バッファを返すマクロです。

@item   yy_create_buffer()
@c __ This is used to create a new input buffer.  By using this, and the
@c __ following two functions, it is possible to create and switch among
@c __ multiple buffers.
@c __ @ref{Buffer Manipulation, , Buffer Manipulation Functions}.
新しい入力バッファを作成するのに使われます。
この関数と、
この後の２つの関数を使うことにより、
複数のバッファを作成し、
バッファ間で切り替えることが可能になります。
@xref{Buffer Manipulation, , バッファを操作する関数}。

@item   yy_delete_buffer()
@c __ This is used to erase a previously created input buffer.  
以前に作成された入力バッファを削除するのに使われます。

@c __ @findex @code{yy_switch_to_buffer()}@r{, summary}
@findex @code{yy_switch_to_buffer()}@r{、要約}
@item   yy_switch_to_buffer()
@c __ This is used to switch between input buffers.  
複数の入力バッファの間で切り替えを行うのに使われます。

@tindex @code{YY_BUFFER_STATE}
@item   YY_BUFFER_STATE
@c __ This is the @emph{type} used for dealing with buffers.  It holds the
@c __ current context of the buffer.  A variable of this type is needed when
@c __ you switch between buffers.
バッファを処理するのに使われる@emph{型}です。
バッファのカレントなコンテキストを保持します。
複数のバッファ間で切り替えを行う時には、
この型の変数が必要になります。

@c __ @tindex @code{YYSTYPE}@r{, @code{%union} type in a Bison file}
@tindex @code{YYSTYPE}@r{、Bisonファイルにおける@code{%union}型}
@item   YYSTYPE
@c __ This is the type of the @code{%union} in a Bison file.  This is used
@c __ when you interface Flex and Bison.
Bisonファイル中の@code{%union}の型です。
これは、
FlexとBisonの間のインターフェイスで使われます。

@c __ @vindex @code{yylval}@r{, summary}
@vindex @code{yylval}@r{、要約}
@item   yylval
@c __ This is a variable in a Bison parser that holds the data associated
@c __ with the current Bison parse state.  Data can be passed between Flex
@c __ and Bison using this variable.
Bisonパーサのカレントなパース状態に関連するデータを保持する、
Bisonパーサ中の変数です。
この変数を使うことで、
データをFlexとBisonの間で渡すことができます。

@end table
@end itemize

@c Include Flex 2.5 information, for Flex manual as published by ASCII
@c @ifset INCLUDEFLEX25INFO
@node Summary or Flex Variables and Functions (Flex 2.5), Summary of Flex Characters, Summary or Flex Variables and Functions, Summary
@section Flex変数およびFlex関数の要約（Flex 2.5の補足情報）
@include funcvar_summary_addendum-ja.texi
@c @end ifset

@c +--------------------------------------------------------------------+
@c |                                                                    |
@c | Summary of characters.                                             |
@c |                                                                    |
@c +-----------------+-----------------+-----------------+--------------+ 
@c |       Name      |       Next      |     Previous    |       Up     |
@c +-----------------+-----------------+-----------------+--------------+ 
@c @node    Summary of Flex Characters, Summary of Flex Rules, Summary or Flex Variables and Functions, Summary
@node    Summary of Flex Characters, Summary of Flex Rules, Summary or Flex Variables and Functions (Flex 2.5), Summary
@c __ @section Summary of Flex Characters
@section Flex文字の要約
@comment ########################## 
@c __ @cindex  Flex characters, summary
@c __ @cindex  Characters in Flex, summary
@cindex  Flex文字、要約
@cindex  Flexにおける文字、要約

@c __ One of the basic building blocks in Flex is characters.  Basically, Flex
@c __ accepts a character as itself, unless it is an operator, a special
@c __ character, or an escape sequence.  The escape sequences are the same as
@c __ those found in ANSI C.  The Flex operators and special characters are:
Flexにおける基本的な構成要素の１つに、
文字があります。
基本的にFlexは、
演算子、特殊文字、エスケープ・シーケンスを除いて、
文字をそのまま受け付けます。
エスケープ・シーケンスは、
ANSI Cに見られるものと同一です。
Flexの演算子と特殊文字は以下のとおりです。

@*
@table @code
@c __ @item @b{Character}
@item @b{文字}
@c __ @b{Flex interpretation of the character}
@b{Flexの解釈}

@item \
@c __ The backslash is an escape character, as with ANSI C escape sequences.
バックスラッシュは、
ANSI Cのエスケープ・シーケンスで使われるのと同様の、
エスケープ文字です。

@item [ ]
@c __ Brackets are used to group a set of characters into a @dfn{character class}.  
@c __ @xref{Character Classes, , Grouping Characters in Flex}, for more details.
角括弧[ ]は、
文字の集合を@dfn{文字クラス}にグループ化するのに使われます。
詳細については、
@xref{Character Classes, , Flexにおける文字のグループ化}。

@item ^
@c __ In a character class, a circumflex denotes negation.  
@c __ @xref{Character Classes, , Grouping Characters in Flex}, for more details.  
@c __ Outside of a character class it denotes the
@c __ start of the line, and can only appear at the beginning of a rule
@c __ (unless it has been escaped).
文字クラスの中では、
@samp{^}は否定を意味します。
詳細については、
@xref{Character Classes, , Flexにおける文字のグループ化}。
一方、
文字クラスの外部では、
行の先頭を意味し、
（エスケープされていない場合は）
ルールの先頭にのみ置くことができます。

@item -
@c __ The hyphen is used to establish a range of characters within character
@c __ classes. Outside character classes, it represents itself.
@c __ @xref{Character Classes, , Grouping Characters in Flex}, for more details.
ハイフンは、
文字クラスの中で文字の範囲を設定するのに使われます。
文字クラスの外部では、
ハイフン自身を表します。
詳細については、
@xref{Character Classes, , Flexにおける文字のグループ化}。

@item @{ @}
@c __ Curly brackets reference a definition, enclose multiple lines of
@c __ actions, or define a range of repetitions for patterns.
大括弧@{ @}は、
定義の参照、複数行にわたるアクションの先頭と末尾の指定、
またはパターンの繰り返し回数の範囲の定義を行います。

@item ( )
@c __ Parentheses override precedence.  Note also that definitions are
@c __ implicitly surrounded by parentheses when they are expanded.
丸括弧( )は、
優先順位の変更に使われます。
また、
定義は展開される時に、
暗黙のうちに丸括弧で囲まれることに注意してください。

@item "" 
@c __ Double quotation marks delimit strings. Only characters inside the
@c __ quotes are matched.
二重引用符は、
文字列の範囲を示します。
引用符で囲まれた範囲の中にある文字だけがマッチされます。

@item /
@c __ The forward slash establishes trailing context.  This is where you want
@c __ to recognize a pattern, only if it is followed by another specific
@c __ pattern.  This means the @samp{/} acts as a kind of @dfn{lookahead}
@c __ operator.
スラッシュは、
後続コンテキスト（trailing context）を設定します。
これは、
あるパターンを認識するのを、
その後ろに別のパターンが続く場合に限定したい、
という場合です。
これは、
スラッシュ@samp{/}が一種の「@dfn{ルック・アヘッド}（その先を見る）」演算子として機能することを意味します。

@item < >
@c __ Angle brackets reference a start state, or group of start states, and
@c __ are used in the @code{EOF} symbol(@samp{<<EOF>>}).  
@c __ @xref{Start States},
@c __ and @ref{End-Of-File Rules}, to get a full explanation of this.
かぎ括弧< >は、
スタート状態の参照、またはスタート状態のグループの参照を行い、
さらに@code{EOF}シンボル（@samp{<<EOF>>}）で使われます。
これに関する完全な説明については、
@ref{Start States}と@ref{End-Of-File Rules}を参照してください。

@item ? + *
@c __ The @samp{?}, @samp{+}, and @samp{*} characters are used to establish
@c __ how many times a @emph{regular expression} can appear.  The @samp{?}
@c __ means zero or one time (``optional''), the @samp{+} means one or more times,
@c __ and the @samp{*} means zero or more times.
@samp{?}、@samp{+}、@samp{*}の各文字は、
ある@emph{正規表現}が何回出現することができるかを指定するのに使われます。
@samp{?}は、
ゼロ回もしくは１回（つまり、オプションであるということ）を、
@samp{+}は１回以上を、
@samp{*}はゼロ回以上をそれぞれ意味します。

@item |
@c __ This represents an ``or'' operator, and a special action which tells
@c __ Flex to use execute the actions of the following rule when a match on
@c __ the current rule occurs.
OR演算子を表します。
また、
カレントなルールに対するマッチが発生した場合、
次に記述されているルールのアクションを実行するようFlexに通知する、
特別なアクションを表します。

@item $
@c __ The dollar sign signifies end-of-line.
ドル記号は行末を意味します。
@end table

@noindent
@c __ When you wish to represent one of these characters literally, it must be
@c __ within quotes (@code{"*"}) or be represented as an escape sequence.
@c __ @xref{Characters}, for more details.
ここに挙げた文字を、
その文字自身として表したい場合には、
その文字を引用符で囲む（例えば@code{"*"}）か、
または、
エスケープ・シーケンスとして表す必要があります。
詳細については、
@xref{Characters}。

@c +--------------------------------------------------------------------+
@c |                                                                    |
@c | Summary of variables and functions.                                |
@c |                                                                    |
@c +-----------------+-----------------+-----------------+--------------+ 
@c |       Name      |       Next      |     Previous    |       Up     |
@c +-----------------+-----------------+-----------------+--------------+ 
@c @node    Summary of Flex Rules,  , Summary of Flex Characters, Summary
@node    Summary of Flex Rules,  , Summary of Flex Characters, Summary
@c __ @section Summary of Flex Rules
@section Flexルールの要約
@comment ##################### 
@c __ @cindex  Flex rules, summary
@c __ @cindex  Flex regular expressions
@c __ @cindex  Regular expressions in Flex 
@cindex  Flexルール、要約
@cindex  Flex正規表現
@cindex  Flexにおける正規表現

@c __ Rules in Flex have two parts: pattern matching expressions and an
@c __ actions section. They are laid out:
Flexにおけるルールには２つの部分があります。
パターン・マッチング用の表現式とアクション部です。
この２つは、
以下のように配置されます。

@example
@var{pattern} @var{actions}
@end example

@c __ The patterns that Flex matches are built out of regular expressions.  A
@c __ regular expression in turn is built out of characters, strings,
@c __ definitions, start states, and operators.  The following table shows the
@c __ various legal regular expressions.  In the table @samp{c} stands for any
@c __ single character (including an escape sequence), @samp{r} for any
@c __ regular expression and @samp{s} for a string.  The table is organized
@c __ into groups, with those at the top having the highest precedence.
Flexがマッチするパターンは、
正規表現を使って作られます。
そしてその正規表現は、
文字、文字列、定義、スタート状態、および演算子から作られます。
下の表は、
種々の正当な正規表現を示します。
表中において、
@samp{c}は（エスケープ・シーケンスを含む）任意の単一文字を、
@samp{r}は任意の正規表現を、
@samp{s}は文字列を、
それぞれ表します。
表はグループ別に編成されていて、
優先度の最も高いものが一番上にあります。
@* 

@c =================================================================
@c TODO: Is this badly redundant? I think most people will either 
@c       read this first, or read all the preceding stuff first.  In
@c       the later case, a refresher may be needed...  
@c =================================================================

@ifinfo
@example 
@c __                       REGULAR EXPRESSIONS
@c __ =============+=============================================+================
@c __ EXPRESSION   |           MATCHES                           |   EXAMPLES        
@c __ =============+=============================================+================
@c __    c         | any character except the special characters |  A, \n, a
@c __    .         | any character except a newline              |    efg.*
@c __    [s]       | any character in the string s               |    [efg]
@c __    [^s]      | any character not in the string s           |    [^moqs]
@c __    r*        | zero or more r's                            |  (a|b)* or [abc]*
@c __    r+        | one or more r's                             |    (a|b)+
@c __    r?        | zero or one r's                             |  (a|[b-q])?
@c __    r@{x,y@}    | x to y r's (abc@{1,3@} = ab and 1-3 c's       |   foo@{1,5@}
@c __    "s"       | the literal string s                        |    "***"
@c __    \c        | c (unless \c has an ANSI C meaning)         |    \"  \*
@c __    (r)       | r - The parentheses are for grouping        |    (Aa|b)      
@c __              |                                             |
@c __    r1r2      | r1 then r2                                  | Aa or (A|a)[0-9]
@c __              |                                             |
@c __    r1|r2     | r1 or r2                                    |     A|B
@c __              |                                             |
@c __    r1/r2     | r1 when followed by r2                      |    abc/123
@c __    ^         | beginning of the line                       |    ^foo
@c __    $         | end of line                                 |    foo$
@c __              |                                             |
@c __    <start>r  | state state: r is active when `start' is    |  <command>"*/"
@c __    <<EOF>>   | End of file.  (Refer to End-Of-File rules)  |    <<EOF>>
                      Flexにおける正規表現
=============+=============================================+================
正規表現     |           マッチの対象                      |   例        
=============+=============================================+================
   c         | 特殊文字を除く任意の文字                    |  A、\n、a
   .         | 改行を除く任意の文字                        |    efg.*
   [s]       | クラスs中にある任意の文字                   |    [efg]
   [^s]      | クラスs中にない任意の文字                   |    [^moqs]
   r*        | ０個以上のr                                 |  (a|b)*、[abc]*
   r+        | １個以上のr                                 |    (a|b)+
   r?        | ０個または１個のr                           |  (a|[b-q])?
   r@{x,y@}    | x個以上y個以下のr                           |   foo@{1,5@}
             | （abc@{1,3@}は、abと１個以上３個以下のc）     |
   "s"       | 字義どおりの文字列s                         |    "***"
   \c        | （\cがANSI Cにおいて特別な意味を持たない    |    \"  \*
             |   場合）c                                   |
   (r)       | r − 丸括弧( )はグループ化のためのもの      |    (Aa|b)      
             |                                             |
   r1r2      | r1の後ろにr2が続くもの                      | Aa、(A|a)[0-9]
             |                                             |
   r1|r2     | r1またはr2                                  |     A|B
             |                                             |
   r1/r2     | r2が後ろに続くという条件を満足するr1        |    abc/123
   ^         | 行頭                                        |    ^foo
   $         | 行末                                        |    foo$
             |                                             |
   <start>r  | スタート状態（start状態の時、rがアクティブ）|  <command>"*/"
   <<EOF>>   | ファイルの終端（End-Of-Fileルールを参照）   |    <<EOF>>
@end example
@end ifinfo

@c TODO
@c ### you should give examples of text they might match, too

@iftex
@tex
%% __ \font\ett=cmtt9
%% __ \font\erm=cmr9
%% __ \font\eit=cmmi9
%% __ \erm
%% __ \vbox{
%% __ \center {\bf Regular expressions in Flex}
%% __ \hfil
%% __ \vbox{
%% __ \offinterlineskip
%% __ \def\tablerule{\noalign{\hrule height.5pt}}
%% __ 
%% __ \def\thickrule{\noalign{\hrule height1.25pt}}
%% __ 
%% __ \halign {\strut#& \vrule#\tabskip=1em plus2em &
%% __    \hfil#& \vrule#& \hfil#\hfil& \vrule#&
%% __    \hfil#& \vrule#\tabskip=0pt\cr\tablerule
%% __ &&\omit\hidewidth  Expression   \hidewidth
%% __ &&\omit\hidewidth  Matches      \hidewidth
%% __ &&\omit\hidewidth  Examples      \hidewidth&\cr\tablerule
%% __ 
%% __ && {\ett c}      && any character except the special characters &&
%% __ {\ett A {\eit or} $\backslash$n}        & \cr\tablerule
%% __ 
%% __ && {\ett .}      && any character except a newline ($\backslash$n)   &&
%% __ {\ett efg.*}     & \cr\tablerule
%% __ 
%% __ && {\ett [s]}    && any character in the class {\ett s}                &&
%% __ {\ett [efg] {\eit or}}  &  \cr\tablerule
%% __ 
%% __ && {\ett [$\hat$s]}    && any character {\eit not} in the class {\ett s}  &&
%% __ {\ett [$\hat$moqs] }  &  \cr\tablerule
%% __ 
%% __ && {\ett r*} && zero or more {\ett r}'s                            &&
%% __ {\ett (a|[e-f])* } & \cr\tablerule
%% __ 
%% __ && {\ett r+} && one or more {\ett r}'s                             && 
%% __ {\ett (a|[e-f])+ } & \cr\tablerule
%% __ 
%% __ && {\ett r?} && zero or one r's                                    &&
%% __ {\ett (a|[e-f])? } & \cr\tablerule
%% __ 
%% __ && {\ett r$\{$x,y$\}$}&& {\ett x} to {\ett y} {\ett r}'s (abc$\{$1,3$\}$ = ab and 1-3 c's)    &&
%% __ {\ett foo$\lbrace$1,5$\rbrace$} & \cr\tablerule
%% __ 
%% __ && {\ett "s"}    && the literal string {\ett s}                        && 
%% __ {\ett "****"}    & \cr\tablerule
%% __ 
%% __ && {\ett $\backslash$c} && {\ett c} (unless {\ett $\backslash$c} has an
%% __ ANSI C meaning)        &&
%% __ {\ett $\backslash$" {\eit or} $\backslash$*} & \cr\tablerule
%% __ 
%% __ && {\ett (r)}     && {\ett r} - the parentheses are for grouping       && 
%% __ {\ett (Ab|Bb)}   & \cr\thickrule
%% __ 
%% __ && {\ett r1r2}    && {\ett r1} followed by {\ett r2}           && 
%% __ {\ett Aa}         & \cr\thickrule
%% __ 
%% __ && {\ett r1|r2}   && {\ett r1} or {\ett r2}                             &&
%% __ {\ett A|B}        & \cr\thickrule
%% __ 
%% __ && {\ett r1/r2}   && {\ett r1} when followed by {\ett r2}               && 
%% __ {\ett abc/123}    & \cr\tablerule
%% __ 
%% __ && {\ett \hat}   && beginning of line                                 && 
%% __ {\ett \hat foo}  &  \cr\tablerule
%% __ 
%% __ && {\ett \$}     && end of line                                       && 
%% __ {\ett foo\$}     & \cr\thickrule
%% __ 
%% __ && {\ett <{\eit start}>r} && start state: {\ett r} is active when {\eit start} is && 
%% __ {\ett <comment>"*/"}     & \cr\tablerule
%% __ 
%% __ && {\ett <<EOF>>}  && end of file (Refer to End-Of-File rules) && 
%% __ {\ett <<EOF>>}    & \cr\tablerule}}
%% __ \hfil}
\font\ett=cmtt9
\font\erm=cmr9
\font\eit=cmmi9
\erm
\vbox{
\center {\bf Flexにおける正規表現}
\hfil
\vbox{
\offinterlineskip
\def\tablerule{\noalign{\hrule height.5pt}}

\def\thickrule{\noalign{\hrule height1.25pt}}

\halign {\strut#& \vrule#\tabskip=1em plus2em &
   \hfil#& \vrule#& \hfil#\hfil& \vrule#&
   \hfil#& \vrule#\tabskip=0pt\cr\tablerule
&&\omit\hidewidth  正規表現   \hidewidth
&&\omit\hidewidth  マッチの対象      \hidewidth
&&\omit\hidewidth  例      \hidewidth&\cr\tablerule

&& {\ett c}      && 特殊文字を除く任意の文字 &&
{\ett A{\eit または}$\backslash$n}        & \cr\tablerule

&& {\ett .}      && 改行（$\backslash$n）を除く任意の文字  &&
{\ett efg.*}     & \cr\tablerule

&& {\ett [s]}    && クラス{\ett s}中にある任意の文字               &&
{\ett [efg] {\eit }}  &  \cr\tablerule

&& {\ett [$\hat$s]}    && クラス{\ett s}中に{\eit ない}任意の文字 &&
{\ett [$\hat$moqs] }  &  \cr\tablerule

&& {\ett r*} && ０個以上の{\ett r}                            &&
{\ett (a|[e-f])* } & \cr\tablerule

&& {\ett r+} && １個以上の{\ett r}                             && 
{\ett (a|[e-f])+ } & \cr\tablerule

&& {\ett r?} && ０個または１個の{\ett r}                                   &&
{\ett (a|[e-f])? } & \cr\tablerule

&& {\ett r$\{$x,y$\}$}&& {\ett x}個以上{\ett y}個以下の{\ett r}（abc$\{$1,3$\}$は、abと１個以上３個以下のc）    &&
{\ett foo$\lbrace$1,5$\rbrace$} & \cr\tablerule

&& {\ett "s"}    && 字義どおりの文字列{\ett s}                        && 
{\ett "****"}    & \cr\tablerule

&& {\ett $\backslash$c} && {\ett c}（{\ett $\backslash$c}がANSI Cにおいて特別な意味を持たない場合）        &&
{\ett $\backslash$"{\eit または}$\backslash$*} & \cr\tablerule

&& {\ett (r)}     && {\ett r} − 丸括弧( )はグループ化のためのもの       && 
{\ett (Ab|Bb)}   & \cr\thickrule

&& {\ett r1r2}    && {\ett r1}の後ろに{\ett r2}が続くもの          && 
{\ett Aa}         & \cr\thickrule

&& {\ett r1|r2}   && {\ett r1}または{\ett r2}                             &&
{\ett A|B}        & \cr\thickrule

&& {\ett r1/r2}   && {\ett r2}が後ろに続くという条件を満足する{\ett r1}              && 
{\ett abc/123}    & \cr\tablerule

&& {\ett \hat}   && 行頭                                 && 
{\ett \hat foo}  &  \cr\tablerule

&& {\ett \$}     && 行末                                       && 
{\ett foo\$}     & \cr\thickrule

&& {\ett <{\eit start}>r} && スタート状態：{\eit start}状態の時、{\ett r}がアクティブ && 
{\ett <comment>"*/"}     & \cr\tablerule

&& {\ett <<EOF>>}  && ファイルの終端（End-Of-Fileルールを参照） && 
{\ett <<EOF>>}    & \cr\tablerule}}
\hfil}
@end tex
@end iftex
@*

@noindent
@c __ Note that these are not exactly the same as the regular expression used
@c __ in @code{sed}, @code{grep}, @r{Emacs}, or other common programs that use
@c __ regular expressions.
これは、
@code{sed}、@code{grep}、@r{Emacs}や正規表現を使う他の一般的なプログラムにおいて使われる正規表現と完全に同一ではないことに注意してください。

@c __ The actions part of a rule is any legal C code. Multiple statements can
@c __ appear on a single line, or a block of statements can appear on multiple
@c __ lines if they are surrounded by the @code{@{@dots{}@}} pair.
ルールのアクション部は、
任意の正当なCコードです。
単一行に複数の文を書くことも可能ですし、
括弧の対@code{@{@dots{}@}}で囲むことで、
複数の文のブロックを複数行にわたって書くことも可能です。

@c +--------------------------------------------------------------------+
@c |                                                                    |
@c | Index.  That all folks!!                                           |
@c |                                                                    |
@c +-----------------+-----------------+-----------------+--------------+ 
@c |       Name      |       Next      |     Previous    |       Up     |
@c +-----------------+-----------------+-----------------+--------------+ 
@c @node Index,  , Summary, Top
@node Index,  , Summary, Top
@c __ @unnumbered Index
@unnumbered インデックス

@printindex cp

@shortcontents
@contents

@bye
