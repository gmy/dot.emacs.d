-*- coding: utf-8 -*-
   This file documents Version 2.5.4 of the Flex lexical scanner
generator.

   This is Edition 1.03, February 1993,
of the `Flex Version 2.5.4 Manual'.

   Copyright (C) 1992, 1993 Free Software Foundation, Inc.

   Permission is granted to make and distribute verbatim copies of this
manual provided the copyright notice and this permission notice are
preserved on all copies.

   Permission is granted to copy and distribute modified versions of
this manual under the conditions for verbatim copying, provided that
the entire resulting derived work is distributed under the terms of a
permission notice identical to this one.

   Permission is granted to copy and distribute translations of this
manual into another language, under the above conditions for modified
versions, except that this permission notice may be stated in a
translation approved by the Free Software Foundation.


File: flex-ja.info,  Node: Top,  Next: Introduction,  Prev: (dir),  Up: (dir)

Flex
****

Flexは、 入力として高級記述言語を受け取り、
出力としてC言語で記述されたスキャナを生成する、
字句スキャナ生成プログラムです。 Flex自身が、
標準のUnixユーティリティと比較してより高速に動作しますし、
生成されるスキャナもより高速です。 また、
POSIX、Lexとの互換性も十分備えています。

   これは、 1993年2月発行、エディション1.03のFlex 2.3.7マニュアルです。
Flex 2.5の新機能に関する情報も追加してあります。 Flex
2.5の新機能に関する節の名前には、 「（Flex
2.5の補足情報）」と書かれています。

============================================================================

* Menu:

* Introduction::                Flexの必要性とその機能
* Invoking Flex::               Flexの起動方法、コマンドライン・オプション
* Flex Descriptions::           Flex記述言語
* Interfacing to Flex::         FlexスキャナとC言語の結合
* Other Flex Features::         追加的なFlex機能、一般的ではないFlex機能
* Optimization::                Flexスキャナの最適化方法
* More Examples::               Flexを使うための実例
* Flex and Lex::                FlexとLexの相違点、性能、POSIX標準への準拠度
* Useful Code::                 ユーザ・スキャナの中で使うことのできるコード
* Summary::                     オプション、変数などの要約
* Index::                       インデックス

 --- The Detailed Node Listing ---

Flex入門

* Problem Solving::             問題解決手段としてのFlex
* General Programming::         一般的なプログラミング・ツールとしてのFlex

Flexの起動

* Command Line Switches::       Flexのコマンドライン・オプション
* Command Line Switches (Flex 2.5)::  同上（Flex 2.5の補足情報）

Flex記述言語

* Comments::                    Flexのコメント・スタイルの説明
* Optional C Code::             Flex定義の先頭のCコード・セクションの説明
* Definitions::                 Flexにおける定義の書き方
* %%::                          区切り文字%%の意味
* Rules::                       Flexファイルのルール・セクション
* Pattern Matching::            パターン・マッチングに使われる部分
* Regular Expressions::         パターンのマッチング
* Start States::                ある条件にもとづいてパターン・マッチング・
                                ルールを活性化させる方法
* %option (Flex 2.5)::          %option指示子の説明

パターン・セクション

* Characters::                  Flexにおける文字、特殊文字
* Strings::                     Flexにおける文字列、特殊文字列
* Character Classes::           文字クラスの説明、その使い方
* Character Class Expressions (Flex 2.5)::  同上（Flex 2.5の補足情報）

スタート状態

* Start States Explained::      スタート状態の宣言、スキャナに対する効果
* Activating States::           スタート状態の活性化方法
* Start State Notes::           不当な宣言、排他的スタート状態のパワーに
                                関する注
* Start State Notes (Flex 2.5)::  同上 （Flex 2.5の補足情報）
* Start State Example::         スタート状態の使用例

Flexとのインターフェイス

* Flex and C::                  CとFlexのインターフェイス
* Flex and C (Flex 2.5)::       同上（Flex 2.5の補足情報）
* An Example of Flex and C::    フィルタにおける文字列代替
* Flex and Bison::              FlexとBisonの協同
* Another Example of Flex and Bison::  FlexとBisonのもう１つの実例
* Flex and C++ (Flex 2.5)::     C++とFlexのインターフェイス
                                （Flex 2.5の補足情報）

FlexとBison

* Interfacing Flex and Bison::  一般的な方法
* YYSTYPE and yylval::          単なる整数以上の情報の渡し方

FlexとBisonのもう１つの実例

* The Database Language::       データベース言語の定義
* The Implementation::          言語を解析するファイル
* Notes on the Implementation:: この実装を選択した理由に関する（簡単な）注

Flexの他の特徴

* Case Insensitive Scanners::   大文字・小文字を区別するスキャナ
* Interactive Scanners::        ユーザから入力を受け取るスキャナ
* Table Compression and Scanner Speed::  テーブル圧縮とスキャナのスピード
* Translation Tables::          文字をグループ化する別の方法
* Multiple Input Buffers::      複数の入力ストリームを受け付ける方法
* End-Of-File Rules::           EOFを処理するための特殊なルール

大文字・小文字を区別しないスキャナ

* The -i Switch::               入力において大文字・小文字を無視する方法

複数の入力バッファ

* Buffer Manipulation::         バッファ操作関数
* Buffer Manipulation (Flex 2.5)::  同上（Flex 2.5の補足情報）
* Example of Multiple Buffers::  複数バッファを使う実例

スキャナの最適化

* Optimizing for Speed::        ファスト・スキャナを作るためのフラグ、
                                関連するトピック
* Optimizing for Size::         サイズの小さいスキャナの作り方

スピードの最適化

* Removing Backtracking::       バックトラッキングの除去による性能の
                                飛躍的向上

Flexを使うその他の実例

* Example-Counting Words::      wc風のユーティリティ
* Example-Pascal Lexical Scanner::  本物の言語をスキャンする実例
* Example-Jargon Converter::    専門用語ファイルのTexinfo形式への変換

FlexとLex

* Flex::                        Flex
* Lex::                         Lex

Flex

* Flex and POSIX::              FlexとPOSIX
* Flex and POSIX (Flex 2.5)::   FlexとPOSIX（Flex 2.5の補足情報）

役に立つコードの抜粋

* Handling Comments::           コメントの処理
* Handling Strings::            文字列の処理
* Handling Numbers::            数値の処理
* Multiple Scanners::           複数のスキャナ
* Miscellaneous::               その他

要約

* Switches Summary::            Flexコマンドライン・オプションの要約
* Switches Summary (Flex 2.5)::  同上（Flex 2.5の補足情報）
* Summary or Flex Variables and Functions::  Flex変数、Flex関数の要約
* Summary or Flex Variables and Functions (Flex 2.5)::
                                             同上（Flex 2.5の補足情報）
* Summary of Flex Characters::  演算子、特殊文字、エスケープ・シーケンス
                                以外の文字をその文字自身として受け付ける
* Summary of Flex Rules::       Flexルールの２つの構成要素

========================================================================


File: flex-ja.info,  Node: Introduction,  Next: Invoking Flex,  Prev: Top,  Up: Top

1 Flex入門
**********

     この章では字句スキャン処理の概念を紹介し、
     Flexのようなツールの必要性を指摘します。
     この章の後半部分でFlexを紹介し、
     Flexを使うことのできる状況の実例をいくつか紹介します。

   UnixおよびCの世界では、
ファイルは通常個々のバイトが連続したものとして扱われます。
個々のバイトを集めてどのようにグループ化するかという点は、
プログラマが決めることです。 このような抽象化は非常に強力です。
というのは、
どのようなファイルであってもこの抽象化方法によって表現することができるからです。
しかしこの方法には短所もあり、
プログラマはほとんど常に生のファイルに対して構造をあてはめなければなりません。
言葉を変えると、
ファイルをより意味のある部分に分割しなければならないということです。
例えば、 コンパイラのある部分はファイルから連続した文字を受け取り、
構文チェッカが理解することのできる構成要素、 例えば、
数値、キーワード、文字列などにグループ化します。
このようなことを行う理由は、 コンパイラの言語パーサが処理を行うのは、
連続した文字に対してではなく、
その言語のシンボルが連続したものに対してだからです。

   データベース・アプリケーションや、
バイナリ・ファイルを扱うアプリケーションは、
扱うデータに対してある固定されたフォーマットというものを持っていることが多く、
そのフォーマットを使って入力データから意味を導き出します。
テキストを入力するプログラムは通常これとは反対で、
入力を単語やシンボルに分割しなければならないことが多いのですが、
通常これらの単語やシンボルがどのように配置されているかを示す決まった構造というものは存在しません。
したがって、 テキスト処理を行うプログラムは、
入力された情報を意味のあるシンボルに分割するために、
"字句解析"もしくは"字句スキャン"と呼ばれる処理を行う部分を持っていることが多く、
そこで入力情報の分割が行われます。
このようなことを行う関数群のことを字句アナライザもしくは字句スキャナ、
あるいは短く「スキャナ」と呼びます。

   一般的に、 スキャナを作成するのは、
プログラマにとって難しいことでも面白いことでもないのですが、
時間のかかる作業になることはあります。
普及しているプログラミング言語のほとんどは、
スキャナの作成を支援する機能が不十分です。 というのは、
連続した文字を単語、トークン、シンボルに分割する組み込みの機能を持っていないからです。
通常はこのような仕事を行うライブラリ・ルーチンが存在しますが、
柔軟でなかったり、 使いにくいものであったり、 あるいは、
ルーチンとのやりとりにあまりに多くのコードが必要になったりすることが多いために、
実装上の細かな点によって根本的な問題が不明瞭にされてしまいます。

   １つの良い例が、 C言語で許されているすべての数値型
（浮動小数、10進整数、16進整数、8進整数）
を処理するスキャナをC言語で記述する場合です。
これは非常に難しいということはありませんが、
出来上がったコードは通常美しいとはとても言えないものでしょうし、
その保守や拡張は容易でないことが多いのです。

   ほとんどのプログラマが即座に断言するように、
他人の書いたコードを保守するのは通常あまり楽しい作業ではありません。
さらに、 美しくないコードを保守するのは、
楽しいというにはほど遠いものです。 このように、
スキャナを書くことが退屈で、 その保守が難しいとなると、
スキャナの作成をより容易にしてくれる方法を考えようとするに足る理由のあったことが読者にもお分かりいただけるでしょう。

   Flexは、 このような問題への答なのです。

========================================================================

* Menu:

* Problem Solving::           問題解決手段としてのFlex
* General Programming::       一般的なプログラミング・ツールとしてのFlex
========================================================================


File: flex-ja.info,  Node: Problem Solving,  Next: General Programming,  Prev: Introduction,  Up: Introduction

1.1 問題解決手段としてのFlex
============================

Flexはプログラマに対して、 字句解析処理部分をきれいに記述し、
その記述にしたがった効率的な字句スキャナを生成する方法を提供します。
プログラマはFlexに対して、 必要なスキャナに関する記述情報を提供します。
Flexはその記述情報を使って、 C言語で書かれたスキャナを生成します。
記述に使われる言語は上級言語であり、
スキャナの記述に関してはC言語よりもはるかに適しています。
その上級言語を使うことで、 プログラマは、 文字をどのようにグループ化し、
グループ化が完了した時にどのようなアクションを発生させるかを指定することができます。

*注：*このマニュアルのほとんどの部分はFlex、Lexの両方を対象にしています。
Lexは （Flexには劣りますが）
ほとんどのUnixシステム上にある標準のスキャナ生成ユーティリティです。
両者の間に違いがある場合には、 Flexを優先させています。
Lexについては*Note 標準Lex: Lex.で簡単に説明してあります。

   ここでも１つの良い例がコンパイラです。 前に議論したように、
コンパイラの構文チェッカは、 文字が連続したものではなく、
言語文法の構成要素を表すトークンが連続したものを、
入力として受け取る必要があります。 Flexはこのような場合に最適です。
Flexによって生成されたスキャナが構文チェッカとファイルの仲介役となり、
構文チェッカが次の意味のあるトークンを要求するのを待ちます。
Flexはファイルを読み、
プログラマが与える記述にしたがって文字をグループ化して、
マッチしたトークンを返却します。 この処理は、
スキャナもしくはパーサが終了するまで続きます。

   Cのコンパイラを作成する場合、
このようなことを行うために必要となるFlexの記述情報は、
コードの行数にして100行から300行くらいになるかもしれません。
この記述情報のほとんどは、
シンボル・テーブルの管理、識別子の検索、型のマッピング、ある数の値等の追加情報の返却を行うための補助的なCコードになるでしょう。
こうしたコード自体は記述情報の一部ではありませんが、 通常、
コンパイラによって必要とされるものです。

   概念的にはFlexは、 原材料（文字）を取り込み、
消費者（パーサ等）がすぐに使うことができる完成品（トークン）を製造する工場のようなものです。


File: flex-ja.info,  Node: General Programming,  Prev: Problem Solving,  Up: Introduction

1.2 一般的なプログラミング・ツールとしてのFlex
==============================================

Flexはコンパイラにしか使えないということはありません。
読者のコンピュータ上にある、 ファイルを読み込んだり、
なんらかの形で文字のグループを処理する必要のあるすべてのプログラム、
特に、 変換フィルタや言語ツールのことを考えてみてください。
こうしたプログラムのほとんどすべてを、 Flex単体、
もしくはFlexと他のツールの組み合わせによって作成することができます。

   １つの良い例が文字数のカウントです。 例えば、 ファイルの中の全行数、
個々の文字の出現回数、
`foo'という単語の出現回数を調べるプログラムを作成したいとしましょう。
標準的なツール （`grep'、`sed'、`awk'、`perl'等） で作成することも、
C言語のプログラムを書いて作成することもできますが、
Flexで作成することも可能です。 他の例として、
特定のキーワードを探す必要のある、 メール・リーダがあります。
この場合でも、 標準ツールで実現することも、
FlexとC言語で実現することもできます。

   Flexを使うことで、 プログラマは、
スキャナの開発やファイルを構成する文字の処理にかかる時間を大幅に減らすことができます。
ほとんどの場合、 Flexに対する入力情報は、
既存のプログラミング言語で記述されたコードと比較して、
より理解しやすく、 少なくとも同程度の移植性があり、 保守もより簡単です。
それだけでなく、 Flexでスキャナを開発するのにかかる時間は、
既存のプログラミング言語で同等のスキャナを開発する場合と比べきわめて短くてすむので、
Flexは、 プロトタイピングや、
一度しか使わないプログラムやフィルタの開発に最適です。


File: flex-ja.info,  Node: Invoking Flex,  Next: Flex Descriptions,  Prev: Introduction,  Up: Top

2 Flexの起動
************

     この章ではFlexを起動する基本的な方法を説明し、
     Flexで使用可能なコマンドライン・オプションを簡単に説明します。

   Flexは記述情報を含むファイルを入力として受け取り、
スキャナ機能を持つCのファイルに変換します。
Flexを起動するためのコマンド行は以下のようになります。

     flex [-bcdfinpstvFILT8] [-C[efmF]] [-SSKELETON] [FILE ...]

一般的には、
単に`flex'に続けて処理すべきファイル名を入力することで実行されます。

     flex myfile.l

記述情報ファイル名の末尾の`.l'は、
`myfile'がFlexもしくはLexの記述ファイルであることを示唆する慣例的な方法です。
名前付けの慣例としてもう一つよく見られるのが、
末尾に`.lex'を使うことです。 例えば、 以下のようになります。

     flex myfile.lex

Flexは記述情報ファイル（`myfile.l'）を読み込み、
そこに記述されたパターンを認識するスキャナ機能を持つ`lex.yy.c'という名前のC言語ファイルを生成します。
記述情報の中になんらかのエラーがあれば、
Flexは対応するエラー・メッセージを`stderr'に出力します。

========================================================================

* Menu:

* Command Line Switches::       Flexのコマンドライン・オプション
* Command Line Switches (Flex 2.5)::  同上（Flex 2.5の補足情報）
========================================================================


File: flex-ja.info,  Node: Command Line Switches,  Next: Command Line Switches (Flex 2.5),  Prev: Invoking Flex,  Up: Invoking Flex

2.1 コマンドライン・オプション
==============================

Flexのコマンドライン・オプションは以下のような意味を持ちます。

`-b'
     `-b'オプションを指定すると`lex.backtrack'というファイルが生成されます。
     このファイルはスキャナの記述情報を最適化する際に使用されます。
     詳細については、*Note Optimizing for Speed::。

`-c'
     このオプションはPOSIXとの互換性のために提供されているだけで、
     実際には何もしません。 POSIXでは、
     `-c'オプションはC言語によるアクションが使用されることを意味します。

`-d'
     このオプションを指定するとデバッグが可能になります。
     これにより生成されるスキャナは、
     実行中にスキャナの状態情報を`stderr'に出力します。

`-f'
     Flexに対して_ファスト_・スキャナ（_fast_
     scanner）と_フル_・スキャナ（_full_
     scanner）のどちらを生成するかを指示します。 詳細については、 *Note
     Table Compression and Scanner Speed::。
     `-f'（小文字）オプションと`-F'（大文字）オプションとは異なる効果を持つ点に注意してください。

`-i'
     Flexに対して大文字、小文字を区別しないスキャナを生成するよう指示します。
     詳細については、 *Note Case Insensitive Scanners::。

`-n'
     このオプションはFlexにとっては何の意味も持たず、
     POSIXとの互換性のためにのみ提供されています。 POSIXでは、
     このフラグは`-v'オプションによる出力を抑制するために使用されます。
     POSIXでのデフォルトは、
     テーブル・サイズが指定されない限りこのような出力を抑制するというものです。
     Flexではテーブル・サイズは意味を持たないので、
     このフラグは冗長です。

`-p'
     `-p'オプションが指定されると、
     Flexは性能レポートを`stderr'に出力します。
     スキャナの性能を向上させる方法に関する議論については、 *Note
     Optimizing for Speed::。

`-s'
     Flexスキャナがマッチするものを見つけることができなかった場合のデフォルトのアクションは、
     そのマッチされなかった入力情報を`stdout'に出力することです。
     `-s'オプションはこのようなアクションを抑制し、
     その代わりに入力情報がマッチしなかった時点でスキャナを異常終了させます。

`-t'
     このオプションが指定された場合、
     Flexは生成されたスキャナをファイル`lex.yy.c'にではなく`stdout'に出力します。

`-v'
     Flexに対して_冗長_モードで動作するよう指示します。

`-F'
     Flexに対して_ファスト_・スキャナ（_fast_
     scanner）を生成するよう指示します。 詳細については、 *Note
     スキャナの最適化: Optimization。
     `-F'（大文字）は`-f'（小文字）とは異なる効果を持つ点に注意してください。
     `-f'と`-F'の相違点に関する情報については、 *Note Table Compression
     and Scanner Speed::。

`-I'
     このオプションはFlexに対して_対話型_スキャナを生成するよう指示します。
     詳細については、 *Note Interactive Scanners::。

`-L'
     デフォルトでは、 デバッグを支援するために、
     Flexは生成されたスキャナのコード中に`#line'指示子を書き込みます。
     このオプションによって`#line'指示子の書き込みは行われなくなります。

`-T'
     Flexに対して"トレース"・モードで動作するよう指示します。
     Flexは多くのメッセージを`stderr'に出力するようになります。
     こうしたメッセージは、
     Flexを非常によく理解しているユーザ以外には無意味でしょう。

`-8'
     このオプションは、
     Flexに対して8ビット入力を受け付けるスキャナを生成するよう指示します。

`-C[efmF]'
     これらのオプションは、
     スキャン処理用のテーブルをどのように圧縮するかを制御します。
     詳細については、 *Note スキャナの最適化: Optimization。

`-SSKELETON_FILE'
     Flexに対して、
     生成するスキャナのベースとしてSKELETON_FILEにより指定されるスケルトン・ファイルを使用するよう指示します。
     主に、 Flex自体をデバッグするために使用されます。


File: flex-ja.info,  Node: Command Line Switches (Flex 2.5),  Prev: Command Line Switches,  Up: Invoking Flex

2.2 コマンドライン・オプション（Flex 2.5の補足情報）
====================================================

Flex 2.5では、 前節（*Note Command Line Switches::）で説明されていない、
以下のオプションもサポートされています。

`-h'
     Flexに対してコマンドライン・オプションの要約情報を出力するよう指示します。

`-l'
     AT&Tにより実装されたlexとの互換性を最大限に提供します。
     このオプションは、 性能面でかなりの悪影響を及ぼします。 また、
     このオプションを、
     `-f'、`-F'、`-Cf'、`-CF'、`-+'オプションと同時に指定することはできません。
     FlexとLexの（非）互換性の問題については、 *Note Flex and
     Lex::を参照してください。

`-w'
     このオプションが指定されると、 Flexは、
     警告メッセージを出力しません。

`-B'
     Flexに対してバッチ・スキャナを生成するよう指示します。 これは、
     対話型スキャナを生成するよう指示する`-I'オプションの否定です。

`-V'
     Flexに対してバージョン番号を出力するよう指示します。

`-7'
     Flexに対して7ビット・スキャナを生成するよう指示します。 これは、
     `-8'オプションの否定です。 内部的に生成されるテーブルのサイズは、
     `-8'オプションが指定された場合と比較して半分になりますが、
     生成されるスキャナは、
     8ビット文字を含む入力を処理することができなくなります。
     `-Cf'、`-CF'が指定されていない場合は、
     明示的に`-7'を指定しない限り、 8ビット・スキャナが生成されます。

`-+'
     Flexに対してC++スキャナ・クラスを生成するよう指示します。
     C++スキャナについては、 *Note Flex and C++ (Flex
     2.5)::を参照してください。

`-?'
     Flexに対してコマンドライン・オプションの要約情報を出力するよう指示します。
     （`-h'オプションと同じです）。

`-Ca'
     このオプションは、 スキャン処理用のテーブルを`long
     int'の配列として定義するようFlexに通知します
     （デフォルトでは`short int'型の配列となります）。
     RISCマシンによっては、 `long int'の方が高速に処理されるため、
     スキャナの性能向上が期待できますが、 その反面、
     テーブルのサイズは大きくなります。

`-Cr'
     このオプションを指定して生成されたスキャナは、
     入力に`read()'システム・コールを使います。 デフォルトでは、
     対話型スキャナの場合は`getc()'が、
     バッチ（非対話型）・スキャナの場合は`fread()'が使われます。

`-oFILE'
     このオプションが指定されると、
     Flexは生成されたスキャナをFILEにより指定されるファイルに出力します。
     デフォルトでは、 スキャナはファイル`lex.yy.c'に出力されます。

`-PPREFIX'
     Flexにより生成されるスキャナのソース・ファイルの中では、
     大域変数や大域関数の名前の先頭に接頭辞`yy'が付けられます。
     このオプションが指定されると、 `yy'の代わりに、
     PREFIXにより指定される文字列が接頭辞として使用されます。 また、
     `-o'オプションが指定されない場合のスキャナ・ファイル名`lex.yy.c'も、
     `lex.PREFIX.c'となります。

     以下に、 このオプションにより影響を受ける名前の一覧を示します。

          yy_create_buffer
          yy_delete_buffer
          yy_scan_buffer
          yy_scan_string
          yy_scan_bytes
          yy_flex_debug
          yy_init_buffer
          yy_flush_buffer
          yy_load_buffer_state
          yy_switch_to_buffer
          yyin
          yyleng
          yylex
          yylineno
          yyout
          yyrestart
          yytext
          yywrap

     `-+'オプションが指定されている場合は、
     影響を受けるのは`yywrap'と`yyFlexLexer'の２つだけです。

     このオプションにより、
     `yywrap()'の名前が変更されてしまう点に注意してください。
     プログラムをリンクするためには、
     `PREFIXwrap'という名前の関数を作成する必要があります。
     この関数を作成したくない場合には、 スキャナ定義ファイルの中で、
     `%option noyywrap'を指定して、
     リンク時に`-lfl'オプションを指定します。
     `%option'指示子については、 *Note %option (Flex
     2.5)::を参照してください。

`--help'
     Flexに対してコマンドライン・オプションの要約情報を出力するよう指示します。
     （`-h'オプションと同じです）。

`--version'
     Flexに対してバージョン番号を出力するよう指示します。
     （`-V'オプションと同じです）。


File: flex-ja.info,  Node: Flex Descriptions,  Next: Interfacing to Flex,  Prev: Invoking Flex,  Up: Top

3 Flex記述言語
**************

     この章では、 スキャナ定義の構成要素を説明し、
     その使用例を示します。 Flexを効率的に使用するためには、
     定義の個々の要素を完全に理解することが非常に重要です。 したがって、
     初めてFlexを使うユーザには、
     時間をかけてこの章を読むことをお勧めします。

   Flexスキャナ定義のほとんどの要素は、 必須要素ではありません。
全体的な定義フォーマットは以下のようになります。

     定義、初期コード
     %%
     ニーニ
     %%
     他のCコード

各々について、 以下において詳細に説明します。

========================================================================

* Menu:

* Comments::                    Flexのコメント・スタイルの説明
* Optional C Code::             Flex定義の先頭のCコード・セクションの説明
* Definitions::                 Flexにおける定義の書き方
* %%::                          区切り文字%%の意味
* Rules::                       Flexファイルのルール・セクション
* Pattern Matching::            パターン・マッチングに使われる部分
* Regular Expressions::         パターンのマッチング
* Start States::                ある条件にもとづいてパターン・マッチング・
                                ルールを活性化させる方法
* %option (Flex 2.5)::          %option指示子の説明
========================================================================


File: flex-ja.info,  Node: Comments,  Next: Optional C Code,  Prev: Flex Descriptions,  Up: Flex Descriptions

3.1 コメント
============

Cのコードが記述できるところには、
どこにでもコメントを記述することができます。 コメントの書式は、
Cのコメントの規則に従います。 コメントは、
記述情報に影響を与えることはありません。
Cスタイルのコメントは以下のようになります。

     /*
     ...
     */

これに加えて、 Flexでは`#'で始まるコメントも許されます。
このようなコメントは`lex.yy.c'にはコピーされませんので、
この形式のコメントを使うことは_お勧めできません_。

   *注：*C以外の言語 （例えばPascal）
のコードを生成するLexも存在します。
このようなLexではコメントの書式はおそらく異なるでしょう。
Flexの場合はCのコードしか生成しません。


File: flex-ja.info,  Node: Optional C Code,  Next: Definitions,  Prev: Comments,  Up: Flex Descriptions

3.2 オプションのCコード
=======================

プログラマは、 ２つの異なる方法を用いて、
スキャナの中に直接Cのコードを含めることができます。 第１の方法は、
"「定義、初期Cコード」"セクション （最初の`%%'より前の部分）
にコードを含めることです。 第２の方法は、 "「他のCコード」"セクション
（２番目の`%%'より後ろの部分） にコードを含めることです。
どちらの場合も、 コードはそのまま`lex.yy.c'にコピーされますので、
正当なコードでなければなりません。

   第１のセクション中のCコードは以下の形式になります。


     %{
        C CODE
        ...
     %}

ここで`%{...%}'というペアが、
Cコード・ブロックの先頭と末尾を示すために使われています。
この形式のコードと定義は、"「定義、初期Cコード」"セクションのどこにでも自由に記述することができます。
定義については次の節で説明します。

   Cのコードが最初のカラムから始まるのでなければ、
`%{...%}'というペアは必要ありません。 しかし普通は、
分かりやすくするために記述しておいた方が良いでしょう。
もう１つのポイントは、
`#ifdef'等のように最左端のカラムから始まらなければならず、 かつ、
通常はスキャナ記述情報の先頭に置かれる必要のあるものが存在するという点です。
こうした場合、 `%{...%}'に囲まれていないと、
Flexはそれを定義の一部であると見なすでしょう。 これが、
常に`%{...%}'を使うもう１つの理由です。

   最後の （"「他のCコード」"） セクション内のコードは、
そのままコピーされます。 ここには特別な宣言は必要ありません。


File: flex-ja.info,  Node: Definitions,  Next: %%,  Prev: Optional C Code,  Up: Flex Descriptions

3.3 定義
========

定義セクションにおいて、 プログラマは、
ある文字のグループに一意な識別子を与え、
その識別子がその文字グループに置き換えられるようにすることができます。
定義は以下のような形式になります。

     DEFINITION_NAME    DEFINITION

DEFINITION_NAMEは_最初_のカラムから始まらなければならず、
そうしないとその定義は`lex.yy.c'にそのままコピーされてしまうということに注意してください。
以下に一般的な定義をいくつか挙げます。

     DIGIT     [0-9]
     LETTER    [a-z]
     IDENT     [a-z_][a-z0-9_]*
     ALPHANUM  {LETTER}|{DIGIT}

DEFINITION NAMEは、 そのグループの一意な識別子でなければなりません。
また、
DEFINITIONはルール・セクション（後述）において正当なものであれば何でも構いません。
ルール・セクションや （上の例の`ALPHANUM'の定義において示されるように）
別の定義中において使われる場合には、 定義は`{
}'によって囲まれていなければなりません。

   FlexとLexの非常に重要な相違点に、 定義を展開する時、
Flexは字義どおりに丸括弧( )で囲むのに対して、
Lexは囲まないという点があります。(1) これは、
`^'、`<<EOF>>'、`$'、`/'を定義中に入れることができないことを意味しています。
というのは、 前述の文字は丸括弧(
)で囲まれた部分に入れることができないからです。 詳細は、 *Note
Characters::および*Note Flex and Lex::において説明します。

   例えば、

     FUNCTION ^[a-zA-Z_][a-zA-Z0-9_]*"("
     %%
     {FUNCTION}  printf("got a function\n");

は、 以下のようなプログラミング・スタイルを使っている場合の、
Cの関数宣言にマッチするように見えます。

     int
     foo()
     {
        ...
     }

しかし実際にはうまくいきません。 というのは、
`{FUNCTION}'が展開されると、

     (^[a-zA-Z_][a-zA-Z0-9_]*)

のようになりますが、 これは不正だからです。
このような種類の問題に関する説明については、 *Note Flex and
POSIX::を参照してください。

   ---------- Footnotes ----------

   (1) 訳注：Flex 2.5では、
`-l'オプションを指定して生成されたスキャナは、 Lexの場合と同じように、
定義を展開する時に丸括弧( )で囲みません。


File: flex-ja.info,  Node: %%,  Next: Rules,  Prev: Definitions,  Up: Flex Descriptions

3.4 %%
======

２つのパーセント記号が、
スキャナ記述情報のルール・セクションの先頭と末尾を示します。
すべてのFlex記述情報は、
少なくともルール・セクションの先頭を示す`%%'を含んでいなければなりません。


File: flex-ja.info,  Node: Rules,  Next: Pattern Matching,  Prev: %%,  Up: Flex Descriptions

3.5 ルール
==========

ルールはFlexの心臓部です。 ルールを書くことによって、 プログラマは、
スキャナが何を実行するべきであるかをFlexに通知します。

   通常、 ルールは２つの部分から構成されます。

     PATTERN       ACTIONS

このうちPATTERNが何を認識するべきかを定義し、
ACTIONSがその何かを認識した時に何を実行するべきであるかをスキャナに知らせます。
PATTERNの部分は空白によって区切られます。 これは、
空白をマッチさせたい場合には、
それを引用符で囲む必要があるということを意味しています。

   スキャナは、 マッチするものを２つ以上見つけた場合、
以下の２つのルールを使ってどれを受け入れるかを決めます。

  1. 後続コンテキスト（trailing
     context）も含めて最も長いものを受け入れる。

  2. マッチするものがすべて同じ長さの場合、
     スキャナ定義中に最初に記述されたものを受け入れる。

   ACTIONSは、 空（コードなし）にするか、 もしくは、
１つ以上のCの文を含む単一のコード行、
`{...}'または`%{...%}'で囲まれた１行以上のコード、
単一の垂直棒（`|'）のいずれかを記述することができます。
以下にいくつか例を挙げます。

     hi         |
     bonjour    |
     hello      printf("hello!\n");
     goodbye    {  printf("goodbye!\n"); }
     konnichiwa {
                    LINE 1
                    ...
                    LINE N
                }
     sayonara   printf("lex will not "); printf("print this\n");

どの行も複数の文を含むことができます。 `|'は、
そのルールにマッチするものが見つかった場合、
次に現れるルールのアクション部に記述されているアクションが実行されるべきであることをFlexに通知します。

   *注：*ほとんどのバージョンのLexは、
`{'と`}'のペアの外部では単一の文しか許しません
（例えば上の`sayonara'ルールは許されません）。 また、
C以外の言語をターゲットにしているLexでは、 `{'と`}'のペアは、
例えばPascalの場合の`begin...end'のように、
異なるシンボルに置き換える必要があるかもしれません。

   ルールにマッチしなかった入力に対するデフォルトのアクションは、
それを`stdout'に出力することであり、 一方、
マッチしたパターンに対するデフォルトのアクションは、
それを破棄することであるという点に注意してください。 これは、
最も単純なFlexの定義が

     %%

であることを意味しています。 これは、
入力を変更せずそのまま`stdout'へ出力するものです。
別の単純な例として以下のようなものがあります。

     %%
     foobar

この場合、 入力の中から`foobar'という文字の並びをすべて取り除き、
取り除いた結果を`stdout'に出力します。


File: flex-ja.info,  Node: Pattern Matching,  Next: Regular Expressions,  Prev: Rules,  Up: Flex Descriptions

3.6 パターン・セクション
========================

パターン・セクションは、
"正規表現"と呼ばれる仕組みを使って実際のマッチング処理を実行します。
正規表現は、
文字列、文字、文字集合（"クラス"）、および演算子から構成されています。
正規表現を構成する要素については次節以降で説明します。
また正規表現自体については、 *Note Regular
Expressions::において議論します。

========================================================================

* Menu:

* Characters::                  Flexにおける文字、特殊文字
* Strings::                     Flexにおける文字列、特殊文字列
* Character Classes::           文字クラスの説明、その使い方
* Character Class Expressions (Flex 2.5)::  同上（Flex 2.5の補足情報）
========================================================================


File: flex-ja.info,  Node: Characters,  Next: Strings,  Prev: Pattern Matching,  Up: Pattern Matching

3.6.1 文字
----------

いくつかの文字はFlexにとって特別の意味があり、
その文字を単独で使ったのでは、 その文字自体を表すことができません。
以下に、 Flexにおける特殊文字とその意味を表にして示します。


    `文字'
          Flexによる解釈

    `.'
          ピリオドは改行（`\n'）_以外_の任意の文字を表します。

    `\'
          バックスラッシュはエスケープ文字です。
          エスケープ・シーケンスはANSI Cのものと同一です。

    `[ ]'
          角括弧[ ]は複数の文字を"文字クラス"にグループ化します。
          詳細については、 *Note Flexにおける文字のグループ化:
          Character Classes。

    `^'
          文字クラスの内部では^は否定を意味します。 詳細については、
          *Note Flexにおける文字のグループ化: Character Classes。
          文字クラスの外部では、 ^は行の先頭を意味し、
          ルールの先頭にのみ置くことができます。 例を以下に示します。

              `[^AB]'
                    否定クラスです。

              `^foo'
                    行の先頭にある`foo'という文字の並びにのみマッチします。

              `foo^'
                    この場合、 `^'は普通の文字であるとみなされます。
                    このような時には、
                    希望どおりの結果が_確実_に得られるようにするために、
                    特別な意味を持つ文字の前にバックスラッシュ`\'を置くのが良いでしょう。
                    このような文字の並びを"エスケープ・シーケンス"と呼びます。
                    エスケープ・シーケンスについてはこの節の最後で説明します。

    `-'
          ハイフンは文字クラスの内部において文字の範囲を表します。
          文字クラスの外部では、 ハイフンはそれ自身を表します。
          詳細については、 *Note Flexにおける文字のグループ化:
          Character Classes。

    `{ }'
          大括弧{ }は、
          定義の参照、複数行のアクションの囲み、またはある範囲にわたる繰り返しの定義を行います。
          例を挙げると、 定義`FOO'があって、
          それをルールの中で参照したい場合に`{FOO}'を使います。

          与えられたパターンのある範囲にわたる繰り返しを定義するには、
          以下のような`{ REPETITION LIST }'を使います。

               %%
               f{2,5}  /* fの２回以上５回以下の繰り返し */
                       /* にマッチ                      */
               f{2,}   /* fの２回以上の繰り返しにマッチ */
               f{2}    /* fの２回の繰り返しにマッチ     */

          この用法の解釈において、
          FlexとLexの間にはいくつかの相違点があります。 詳細については、
          *Note Flex and POSIX::を参照してください。

    `( )'
          丸括弧( )を使って優先順位を変更することができます。 また、
          定義が展開される時には、 その定義は暗黙のうちに丸括弧(
          )で囲まれることに注意してください。(1) このため、
          Lexとは非互換なところがでてきます。 この点については、 *Note
          Flex and POSIX::と*Note Definitions::で説明しています。

    `""'
          二重引用符記号は文字列を表します。
          引用符の内側の文字列だけがマッチの対象になります。
          したがって、

               %%
               "string"

          は`"string"'にではなく、 `string'にマッチします。

    `/'
          スラッシュは後続コンテキスト（trailing context）を設定します。
          これは、 あるパターンの後ろに特定の文字の並びが続く場合のみ、
          そのパターンを認識したいという状況です。 つまり、
          スラッシュ`/'は「"ルック・アヘッド"（その先を見る）」演算子として機能するということです。
          例を挙げると、

              `abcDEF'
                    `abcDEF' を認識します。

              `abc/DEF'
                    `abc'の後ろに`DEF'が続く場合に限り、
                    `abc'を認識します。 `DEF'の部分は、
                    あたかもまだ読まれてはいないかのように扱われ、
                    マッチの対象になりません。

          *注：*１つのルールの中では`/'は１つだけ許されます。 つまり、

               abc/def/hijkl

          は不正です。

    `< >'
          かぎ括弧< >はスタート状態を参照します。 また、
          EOFシンボル（`<<EOF>>'）にも使われます。
          完全な説明については、 *Note Start States::と*Note
          End-Of-File Rules::を参照してください。

    `? + *'
          `?'、`+'、`*'は、
          ある_正規表現_が現れることのできる回数を設定します。
          `?'は０回もしくは１回
          （その正規表現が現れることは必須ではないということ）
          を意味します。 `+'は１回以上を意味します。
          `*'は０回以上を意味します。 例えば、

              `a?'
                    ０個もしくは１個の`a'にマッチします。

              `a+'
                    １個以上の`a'にマッチします。

              `a*'
                    ０個以上の`a'にマッチします。

              `(ABC)+'
                    `ABC'という文字の並びが１回以上続くものにマッチします。

              `[abQrS]?'
                    ０個もしくは１個の、
                    （５つの文字`abQrS'から構成される）
                    この文字クラスのメンバにマッチします。
                    文字クラスに関する詳細については、 *Note
                    Flexにおける文字のグループ化: Character
                    Classes.を参照してください。

              `{NUM}*'
                    ０個以上の`NUM'にマッチします。
                    ここでの`NUM'は定義です。
                    定義に関する詳細については、 *Note
                    Definitions::を参照してください。

    `|'
          OR演算子、 および、 特別なアクションを表します。 例えば、

                  apples|oranges

          は`apples'もしくは`oranges'のいずれかにマッチし、

               apples         |
               oranges        printf("fruit!\n");

          は、
          `apples'と`oranges'の両方に対して同一の_アクション_を実行します。

    `$'
          ドル記号は行末を意味します。 例えば、

                  end$

          はその直後が行末である場合にのみ`end'という文字の並びにマッチします。
          これは、
          後ろに続くのが行末のマーカである場合のみ`end'にマッチする

                  end/\n

          とまったく同じです。


こうした文字のいずれかをその文字自身として表したい場合には、
引用符で囲むか、 （後に示す表で説明する）
エスケープ・シーケンスとして表さなければなりません。

   Flexには３種類のエスケープ・シーケンスがあります。
バックスラッシュ`\'に続けて8進数を使うもの、
`\x'に続けて16進数を使うもの、 `\LETTER'という表記法によってある１文字、
または、 特別な表示不可の文字を表すものの３つです。
Cをよく知っている人であれば、 この３つがANSI
Cのエスケープ・シーケンスであることに気がつくことでしょう。
数値によるエスケープ・シーケンスは、
100パーセント移植性があるわけではなく、 保守を困難にするので、
避けるべきです。

   以下に、 文字の使用に関する要約を示します。 この表中では、
`c'が単一の文字を、 `NNN'が8進定数を、 `HH'が16進定数を表します。
                         Flexにおける文字
     ============+========================================+============
       文字      |                  意味                  | 例
     ============+========================================+============
        c        | cが演算子でない場合は、文字c自体       | a
        .        | 改行（\n）以外の任意の文字             | .
       "c"       | c                                      | "^", "$"
        \b       | バックスペース       （BS）            | [\b]
        \t       | 水平タブ             （HT）            | [\t]
        \n       | 改行                 （NL）            | [\n]
        \v       | 垂直タブ             （VT）            | [\v]
        \f       | 頁送り               （FF）            | [\f]
        \r       | キャリッジ・リターン （CR）            | [\r]
        \\       | 単一バックスラッシュ                   | \\, \\b
        \"       | 単一引用符                             | \"
        \0       | NUL文字                                | \0
        \c       | cが上記以外の文字の場合、文字c自体     | \w
        \xHH     | 16進数HHを値として持つ文字             | \x1B
        \NNN     | 8進数NNNを値として持つ文字             | \033

_*注：*いくつかのバージョンのLexでは、 `\0'を正しく認識、
またはマッチしません。 これは、 `\0'がNUL、
つまりC文字列の終端文字だからです。 Flexでは、
NULをマッチの対象にしても問題はありませんが、 性能には若干影響します。_ 

   さらに付け加えると、
`^'演算子と`<<EOF>>'はルールの先頭にのみ置くことができます。 また、
これらと`$'、`/'は丸括弧( )の内部に置くことはできません。
このことはまた、 定義の正当性にも影響を及ぼします。 というのは、
展開される時に定義は字義どおりに丸括弧( )で囲まれるからです。(2)
詳細については、 *Note Definitions::と*Note Flex and
POSIX::を参照してください。

   ---------- Footnotes ----------

   (1) 訳注：Flex 2.5では、
`-l'オプションを指定して生成されたスキャナは、 Lexの場合と同じように、
定義を展開する時に丸括弧( )で囲みません。

   (2) 訳注：Flex 2.5では、
`-l'オプションを指定して生成されたスキャナは、 Lexの場合と同じように、
定義を展開する時に丸括弧( )で囲みません。


File: flex-ja.info,  Node: Strings,  Next: Character Classes,  Prev: Characters,  Up: Pattern Matching

3.6.2 Flexにおける文字列
------------------------

"文字列"とは、 （常に、というわけではありませんが） 多くの場合、
引用符によって囲まれる文字のグループです。
エスケープ・シーケンスが使われない限り、
文字列には改行や表示不可の文字を含めることはできません。

   `-i' オプション （詳細については、*Note Case Insensitive Scanners::）
を使わない限り、
大文字・小文字の区別も含めた_字義どおり_の文字列に対してマッチが行われます。
引用符付きの文字列については、
引用符は認識される文字列には_含まれません_。

   例えば、

     string
     StrING
     "STRING"
     \"string\"

はすべて正当な文字列であり、 最後のものは引用符も含めてマッチされます。
Flexにおいては文字列には引用符は_必須_ではありません。 したがって、
キーワードのグループにマッチさせる場合、

     begin
     end
     pointer
      ...

と

     "begin"
     "end"
     "pointer"
      ...

のいずれも正当です。


File: flex-ja.info,  Node: Character Classes,  Next: Character Class Expressions (Flex 2.5),  Prev: Strings,  Up: Pattern Matching

3.6.3 Flexにおける文字のグループ化
----------------------------------

Flexでは、 文字をグループ化して"文字クラス"にすることができます。
文字クラスは、 文字のグループを角括弧[ ]で囲むことにより作成されます。
どのような文字でも正当です
（表示不可の文字についてはエスケープ・シーケンスを使います）。 また、
文字の範囲をハイフン`-'を使って指定することができます。
文字クラスがルールの中で使われている場合には、
Flexはそのクラスの任意のメンバとマッチさせ、
あたかも単一文字が使われているかのように振る舞います。 例えば、

     [a-z]
     [A-Z]*

において、 最初の例は`a'から`z'までの任意の単一文字にマッチします。
第２の例は`A'から`Z'までの任意の文字が０個以上並んだものにマッチします。

   _否定_文字クラスを表す正規表現を書くこともできます。
否定文字クラスは、 （`\n'も含めて）
文字クラスのメンバ_以外_であれば何にでもマッチします。 これを行うには、
否定すべきクラスの先頭に`^'を置きます。
（クラスの外部では`^'は異なる意味を持つことに注意してください。）
以下に、 正当なクラスの例をいくつか挙げます。

    `[abc]'
          `a'、`b'、`c'のいずれかにマッチします。

    `[abc\n]'
          `a'、`b'、`c'、`\n'のいずれかにマッチします。

    `[a-z]'
          ASCII値が`a'から`z'までの範囲にある任意の文字、 すなわち、
          任意の英小文字にマッチします。

    `[^a-z]'
          `a'から`z'までの範囲にある文字_以外_の任意の文字にマッチします。

    `[ABcd]'
          `A'、`B'、`c'、`d'のいずれかにマッチします。

   *注：*Flex、 およびいくつかのバージョンのLexは、
クラス内における逆方向の範囲を扱うことができません。 したがって、

     %%
     [z-a9-0]
はエラー・メッセージを出力します。
逆方向の範囲は指定しないでください。


File: flex-ja.info,  Node: Character Class Expressions (Flex 2.5),  Prev: Character Classes,  Up: Pattern Matching

3.6.4 Flexにおける文字のグループ化（Flex 2.5の補足情報）
--------------------------------------------------------

3.6.5 Flexにおける文字のグループ化（Flex 2.5の補足情報）
--------------------------------------------------------

Flex 2.5では、 文字クラスの中に"文字クラス式"を含めることができます。

   文字クラス式は、 形式的には、
ある文字集合を識別する名前を`[:'と`:]'で囲んだものです。 Flex 2.5では、
以下の文字クラス式が有効です。

     [:alnum:] [:alpha:] [:blank:]
     [:cntrl:] [:digit:] [:graph:]
     [:lower:] [:print:] [:punct:]
     [:space:] [:upper:] [:xdigit:]

   文字クラス式[:XXX:]は、 ANSI
Cの`isXXX()'関数がゼロ以外の値を返す文字の集合に対応します。
唯一の例外は[:blank:]で、 `isblank'は （POSIXでは定義されているものの）
ANSI Cでは定義されていないため、 Flexでは、 マクロ`IS_BLANK'を

     #define IS_BLANK(c) ((c) == ' ' || (c) == '\t')

のように定義して、 これが真となる文字の集合 （すなわち、
スペースとタブ） を文字クラス式[:blank:]に対応させています。

   文字クラス式を使えば、

     [a-zA-Z]
     [0-9]

を

     [[:alpha:]]
     [[:digit:]]

と書くことができます。

   また、 文字クラスの中に複数の文字クラス式を含めることができますので、

     [a-zA-Z0-9]

を、

     [[:alpha:][:digit:]]

と書くこともできます （もっとも、 この例の場合は、
[[:alnum:]]と書くほうが良いでしょう）。


File: flex-ja.info,  Node: Regular Expressions,  Next: Start States,  Prev: Pattern Matching,  Up: Flex Descriptions

3.7 正規表現
============

Flexの文字、文字列、クラス、定義、および演算子を組み合わせることで、
"正規表現"として知られているものが作られます。
（基本単位が数と演算子である） 数学表現と同じように、
基本的な要素は単純なもの （文字、演算子、文字列、クラス、および定義）
ですが、 要素を組み合わせることでより複雑な表現式を作ることができます。
例えば、 `c'は単一文字の正規表現で、 `c'にマッチします。
`cc'は２つの正規表現をつないだものを含む正規表現で、
`cc'にマッチします。 `c*'は、 単一文字の正規表現`c'と、
それに続く演算子`*'から構成される正規表現で、
０個以上の`c'にマッチします。 正規表現の真のパワーは、
個々の要素よりもむしろ、 組み合わせ可能な方法の中にあります。

   次の表は、 Flexで利用可能な正規表現をすべて示したものです。
表中において、 `c'は （エスケープ・シーケンスを含む） 任意の単一文字を、
`r'は任意の正規表現を、 `s'は文字列を表します。
表はグループ別に編成してあり、 優先度の最も高いものが一番上にあります。
                           Flexにおける正規表現
     =============+=============================================+================
     正規表現     |           マッチの対象                      |   例
     =============+=============================================+================
        c         | 特殊文字を除く任意の文字                    |  A、\n、a
        .         | 改行を除く任意の文字                        |    abc.*
        [s]       | クラスs中にある任意の文字                   |    [abc]
        [^s]      | クラスs中にない任意の文字                   |    [^abc]
        r*        | ０個以上のr                                 |  (a|b)*、[abc]*
        r+        | １個以上のr                                 |    (a|b)+
        r?        | ０個または１個のr                           |  (a|[b-q])?
        r{x,y}    | x個以上y個以下のr                           |   foo{1,5}
                  | （abc{1,3}は、abと１個以上３個以下のc）     |
        "s"       | 字義どおりの文字列s                         |    "***"
        \c        | （\cがANSI Cにおいて特別な意味を持たない    |    \"  \*
                  |   場合）c                                   |
        (r)       | r - 丸括弧()はグループ化のためのもの        |    (Aa|b)
                  |                                             |
        r1r2      | r1の後ろにr2が続くもの                      | Aa、(A|a)[0-9]
                  |                                             |
        r1|r2     | r1またはr2                                  |     A|B
                  |                                             |
        r1/r2     | r2が後ろに続くという条件を満足するr1        |    abc/123
        ^         | 行頭                                        |    ^abc
        $         | 行末                                        |    abc$
                  |                                             |
        <start>r  | スタート状態（start状態の時、rがアクティブ）|  <command>"*/"
        <<EOF>>   | ファイルの終端（End-Of-Fileルールを参照）   |    <<EOF>>

Unixにおいてパターン検索が必要な場合には正規表現がよく使われますが、
アプリケーションが異なると、
正規表現もよく似てはいるもののまったく同一ではないという点に注意してください。
例えば、
Flex、`egrep'、`Emacs'はいずれもパターン検索のテンプレートとして正規表現を使いますが、
それぞれが理解する正規表現は少しずつ異なります。 特に、
Flexでは定義が使われますが、 `egrep'や`Emacs'では使われませんし、
`egrep'や`Emacs'は単語の先頭と末尾にマッチさせるための`\<'と`\>'とを提供していますが、
Flexは提供していません。 さらに、
`Emacs'はバッファの先頭に対するマッチングや「ファジー」なマッチング等を行うための、
特別な`\LETTER'シーケンスをほかにも数多く提供しています。


File: flex-ja.info,  Node: Start States,  Next: %option (Flex 2.5),  Prev: Regular Expressions,  Up: Flex Descriptions

3.8 スタート状態
================

なんらかの条件に基づいて、
パターン・マッチング処理のルールを活性化することが便利な時があります。
例えば、 いくつかのコンピュータ言語では、
重複しているスキャン・ルールの曖昧さを取り除くのを支援するために、
パース状態を使います。 別の例としては、
ある特定の入力が見つかったあとでだけ、
あるルールを活性化したいという場合があります。
このような状況に対処するために、
Flexは"スタート条件"または"スタート状態"と呼ばれる単純なシステムを提供しています。

========================================================================

* Menu:

* Start States Explained::      スタート状態の宣言、スキャナに対する効果
* Activating States::           スタート状態の活性化方法
* Start State Notes::           不当な宣言、排他的スタート状態のパワーに
                                関する注
* Start State Notes (Flex 2.5)::  同上 （Flex 2.5の補足情報）
* Start State Example::         スタート状態の使用例
========================================================================


File: flex-ja.info,  Node: Start States Explained,  Next: Activating States,  Prev: Start States,  Up: Start States

3.8.1 スタート状態の説明
------------------------

スタート状態は、
あるルールがアクティブになるのはいつであるかをFlexに通知するブール値のようなものです。
スタート状態は、 定義セクションにおいて
（排他的スタート状態の場合）`%x' 、
または（包含的スタート状態の場合）`%s'を使って宣言されます。

     %x START_STATE_NAME
     %s START_STATE_NAME

START_STATE_NAMEは一意な名前でなければならない点に注意してください。
つまり、
他のスタート状態や定義が同じ名前を持ってはならないということです。
スタート状態は、 １つの状態の名前、 または、
カンマで区切られた複数の状態の名前をかぎ括弧< >で囲むことによって、
ルール・セクションで参照されます。
スタート状態の参照はルールの先頭になければならず、
１つのルール中には１対のかぎ括弧< >のみ許されます。 このことは、

     %x state1
     %s state2
     %x state3 state4
     %%
     <state1>"foo"
     <state2,state3,state4>"bar"

が正当であり、

     integer [-+]?[0-9]*
     %x integer
     %s state1,state2,state3
     %%
     <integer>"foo"
     "bar"<state1>
     <state1>"bar"<state2,state3>

はすべて不当であることを意味しています。
`integer'については同じ名前を持つ定義が存在し、
それ以外のものについてはスタート状態の参照の位置が正しくないか、
複数の参照が存在するからです。

   これまでのところでは、
Flexが異なる２種類のスタート状態をサポートしている事実から目をそらしてきました。
２つのスタート状態とは、
"包含的スタート状態"（`%s'）と"排他的スタート状態"（`%x'）のことです。
これら２つの相違点は、 排他的スタート状態が活性化された場合は、
その状態に属するルール_だけ_が活性化されるのに対して、
包含的スタート状態の場合は、
その状態に属するルールとスタート状態への参照を持たないルールの両方が活性化されるという点にあります。
この違いを示す例を挙げると、 以下のようになります。

     %s state1
     %%
     <state1>"one" printf("two");
     "three"       printf("four");

この場合、 `state1'状態が活性化されている場合は`one'を`two'に置き換え、
_`state1'状態が活性化されているか否かにかかわらず_`three'を`four'に置き換えます。
デフォルトのルールにより、 その他のテキストは`stdout'に出力されます。
これに対して、

     %x state1
     %%
     <state1>"one" printf("two");
     "three"       printf("four");

は、 `state1'状態が活性化されている時は`one'を`two'に置き換え、
_`state1'状態が活性化されていない時のみ_`three'を`four'に置き換えます。
デフォルトのルールにより、 その他のテキストは`stdout'に出力されます。

   このことは、 排他的スタート状態が使われる場合には、
マッチしないテキストが`stdout'に出力されてはならないのであれば、
すべての可能な入力にマッチするルールを、
_個々_の排他的スタート状態が持たなければならないことを意味しています。
包含的スタート状態の場合は、 あらゆる状態において有効な、
スタート状態への参照を持たないルールを１つ持つ必要があります。

   *注：* 排他的スタート状態はPOSIXの一部であるにもかかわらず、
Lexではサポートしていません。


File: flex-ja.info,  Node: Activating States,  Next: Start State Notes,  Prev: Start States Explained,  Up: Start States

3.8.2 状態の活性化
------------------

スタート状態の名前を並べただけではあまり役に立ちません。 つまり、
スタート状態がいつ活性化されるのかということも制御しなければなりません。
活性化は、 アクションの中、 または、
記述情報内の追加的なCコードを記述する領域の中において、
`BEGIN'を使うことで実現されます。 使い方は以下のとおりです。

     BEGIN(START_STATE_NAME);

例を挙げると、 以下のようになります。

     %x COMMENT
     %%
     "{"            BEGIN(COMMENT);
     <COMMENT>"$R"
     <COMMENT>"$I"
     <COMMENT>"$M"
         ...
     <COMMENT>"}"   BEGIN(INITIAL);

この場合、 Pascalのコメントの先頭部分を見つけると`COMMENT'状態に移行し、
コンパイラ・オプションを認識するようになります。
`BEGIN'は最初の`%%'の直後（最初のルールの前）において使うこともでき、
この場合は`yylex()'は常に指定された状態で開始されます。

   上の例においては、
定義されていない`INITIAL'という状態があることに注意してください。
この状態は常に利用可能で、
_活性化された状態が１つも存在しない時_のスキャナの初期状態を表します。
つまり、 `BEGIN(INITIAL)'によって、 スキャナの状態が効果的に
（もちろん、 その時点においてスキャンしている箇所を維持したまま）
リセットされることを意味しています。


File: flex-ja.info,  Node: Start State Notes,  Next: Start State Notes (Flex 2.5),  Prev: Activating States,  Up: Start States

3.8.3 スタート状態に関する注
----------------------------

以下に、 スタート状態の使用に関する注をいくつか示します。

   * 特殊文字

     １つのルールにおいては、 単一のスタート状態、 または、
     カンマで区切られたスタート状態のリストのみを使用することができます。
     また、
     こうしたスタート状態の指定はルールの先頭になければなりません。
     次に示すものは正当です。

          %x state1
          %s state2
          %%
          <state1> "something"
          <state2> "another thing"
          <state, state2> "something else"

     しかし、 次に示すものは不当です。

          %x state1
          %s state2
          %%
          wrong<state1>
          <state1><state2>"wrong"
          <state2>"wrong"<state1>

   * 排他的スタート状態

     排他的スタート状態は、 他のすべての状態を「無効」にするので、
     強力です。 これは、
     スキャナの内部においてもう１つのスキャナを効果的に定義することができることを意味しています。
     これにより例えば、 スタート状態次第で、
     CとPascalの両方をスキャンするスキャナを定義することが、
     理論的には可能になります。
     以下のようなコードが持つ効果を想像してみてください。

          %x PASCAL
          %x C
          %%
          <PASCAL>begin     return(OPEN_BLOCK);
          <PASCAL>end       return(CLOSE_BLOCK);
          <C>{              return(OPEN_BLOCK);
          <C>}              return(CLOSE_BLOCK);

   * スタート状態の名前

     前述のとおり、 スタート状態はそれ自身の名前空間を持っていません。
     その理由は、
     スタート状態が`#define'とほとんど同じ方法で整数値として定義されているからです。
     このことは、 整数値と同様、
     スタート状態の「スタック」のようなものを作成することが可能であることを意味しています。
     例えば、

          %{
              int last_state[MAX_STATES]
              int state_count = 0;
          %}
          %x FOO BAR baz
          %%
          FOO        {
                        last_state[state_count] = FOO;
                        state_count++;
                        BEGIN(baz);
                     }
          BAR        {
                        last_state[state_count] = BAR;
                        state_count++;
                        BEGIN(baz);
                     }
          <baz>RULE 1
               ...
          <baz>RULE N
          <baz>END   {
                        statecount--;
                        BEGIN(last_state[statecount]);
                     }

     は`FOO'と`BAR'の両方によって`baz'状態を活性化させ、
     `<baz>END'というルールによって１つ前の状態に戻します。
     こうした「状態スタック」は将来、
     Flexの特徴的な機能になるかもしれません。(1)

   ---------- Footnotes ----------

   (1) 訳注：Flex 2.5は、 スタート状態スタックをサポートしています。
次節（*Note Start State Notes (Flex 2.5)::）を参照してください。


File: flex-ja.info,  Node: Start State Notes (Flex 2.5),  Next: Start State Example,  Prev: Start State Notes,  Up: Start States

3.8.4 スタート状態に関する注（Flex 2.5の補足情報）
--------------------------------------------------

Flex 2.5では、 以下の新機能を利用することができます。

   * ワイルド・カード

     スタート状態`<*>'には特殊な意味があり、
     すべてのスタート状態にマッチします。

     例えば、

          %x state1
          %%
          <state1>"one" printf("two");
          <*>"three"    printf("four");

     は、

          %s state1
          %%
          <state1>"one" printf("two");
          "three"	      printf("four");

     と同じ意味になります。

   * カレントなスタート状態

     マクロ`YY_START'により、
     カレントなスタート状態を参照することができます。

     前節（*Note Start State
     Notes::）の「スタート状態の名前」に示した例では、
     カレントなスタート状態を配列`last_state'に格納する処理を、
     以下のように記述していますが、

          FOO        {
                        last_state[state_count] = FOO;
                        ...
                     }

     この代入は、

                        last_state[state_count] = YY_START;

     のように書き換えることができます。

     Lexとの互換性のために、 `YYSTATE'が、
     `YY_START'の別名として定義されています。

   * スタート状態のスコープ

     スタート状態のスコープを定義することができます。 これにより、
     同じスタート状態において複数のルールが存在する時に、
     その個々のルールにスタート状態を指定する必要がなくなります。

     スタート状態のスコープの形式は、 以下のとおりです。

          <START_STATES>{
          ...
          }

     ここで、 START_STATESは、 単一のスタート状態、 または、
     カンマで区切られたスタート状態のリストです。
     スタート状態のスコープの境界は、 `{'と`}'によって指定されます。
     スタート状態のスコープを入れ子にすることも可能です。

     *Note Activating States::に示した例を、
     スタート状態のスコープを使って書き直すと、 以下のようになります。

          %x COMMENT
          %%
          "{"            BEGIN(COMMENT);
          <COMMENT>{
              "$R"
              "$I"
              "$M"
              ...
              "}"        BEGIN(INITIAL);
          }

   * スタート状態スタック

     スキャナ定義ファイルで`%option stack'を指定すると、
     スタート状態スタックを利用できます。
     スタート状態スタックを操作するために、
     以下の関数が提供されています。

    `void yy_push_state(int NEW_STATE)'
          カレントなスタート状態をスタート状態スタックにプッシュし、
          NEW_STATE状態に遷移します。

    `void yy_pop_state()'
          スタート状態スタックからスタート状態をポップし、
          そのポップされたスタート状態に遷移します。

    `int yy_top_state()'
          スタート状態スタックの先頭にあるスタート状態を返します
          （スタート状態スタックの内容は変更されません）。

     前節（*Note Start State
     Notes::）の「スタート状態の名前」に示した例を、
     スタート状態スタックを使って書き直すと以下のようになります。

          %option stack
          %x FOO BAR baz
          %%
          FOO        {
                        yy_push_state(baz);
                     }
          BAR        {
                        yy_push_state(baz);
                     }
          <baz>RULE 1
               ...
          <baz>RULE N
          <baz>END   {
                        yy_pop_state();
                     }


File: flex-ja.info,  Node: Start State Example,  Prev: Start State Notes (Flex 2.5),  Up: Start States

3.8.5 スタート状態の使用例
--------------------------

プログラミングにおいて、 何かをする方法を学ぶのに最良の方法は、
実際にそれをやってみることです。 そのことに留意し、
スタート状態をどのように使うことができるかを示す実例を以下に挙げます。

     /*
      * dates.lex: 日付の異なる形式を識別するために
      *            スタート状態を使用する例
      */

     %{
     #include <ctype.h>

     char month[20],dow[20],day[20],year[20];

     %}
     skip of|the|[ \t,]* /* この文字の並びを無視する */

     mon  (mon(day)?)    /* 曜日の名前の長い形式と短い形式の */
     tue  (tue(sday)?)   /* どちらにもマッチするよう設定する */
     wed  (wed(nesday)?)
     thu  (thu(rsday)?)
     fri  (fri(day)?)
     sat  (sat(urday)?)
     sun  (sun(day)?)
      /* 以下はすべての可能な曜日を表す */

     day_of_the_week ({mon}|{tue}|{wed}|{thu}|{fri}|{sat}|{sun})

     jan  (jan(uary)?)   /* すべての月について同様のことを行う */
     feb  (feb(ruary)?)
     mar  (mar(ch)?)
     apr  (apr(il)?)
     may  (may)
     jun  (jun(e)?)
     jul  (jul(y)?)
     aug  (aug(ust)?)
     sep  (sep(tember)?)
     oct  (oct(ober)?)
     nov  (nov(ember)?)
     dec  (dec(ember)?)
      /* 以下はすべての可能な月の名前を表す */

     first_half  ({jan}|{feb}|{mar}|{apr}|{may}|{jun})
     second_half ({jul}|{aug}|{sep}|{oct}|{nov}|{dec})
     month       {first_half}|{second_half}
      /*
       * 日、月、年の数値形式
       * これらは重複しているため、正しくパースするには、
       * スタート状態と日付の形式に関するある程度の知識
       * が必要であることに注意
       */

     nday         [1-9]|[1-2][0-9]|3[0-1]
     nmonth       [1-9]|1[0-2]
     nyear        [0-9]{1,4}
      /* 年と日のための拡張子 */

     year_ext    (ad|AD|bc|BC)?
     day_ext     (st|nd|rd|th)?
       /*
        * このプログラムの最後にあるルールを使ってすべての無関係な
        * テキストを処理するために、非排他的なスタート状態を使う。
        * こうしないと、個々のスタート状態のブロックにルールを追加
        * しなければならなくなる。規模の大きいスキャナにおいては、
        * これは実行可能な選択肢であることが多い。なぜなら、ルール
        * の追加はスキャナのスピードに影響を与えないからである。
        * ここでは、簡潔さを優先させることにする
        */

     %s LONG SHORT
     %s DAY MONTH   /* 長い形式の日付のために追加した状態 */
     %s YEAR_FIRST YEAR_LAST YFMONTH YLMONTH
     %%

      /*
       * 曜日は常に最初に置かれ、後ろに続く日付の修飾子として
       * 機能するものと仮定される。よって、曜日は複数の日付形式
       * の間で共用可能である
       */

     <LONG>{day_of_the_week} strcpy(dow,yytext);
      /*
       * 月-日-年という形式の日付を処理する
       * パース状態は
       * LONG->[月にマッチ]->DAY->LONG
       * のように遷移する
       */

     <LONG>{month}         strcpy(month,yytext); BEGIN(DAY);
     <DAY>{nday}{day_ext}  strcpy(day,yytext);   BEGIN(LONG);
      /*
       * 日-月-年という形式の日付を処理する
       * パース状態は
       * LONG->[日にマッチ]->MONTH->LONG
       * のように遷移する
       */

     <LONG>{nday}{day_ext} strcpy(day,yytext);   BEGIN(MONTH);
     <MONTH>{month}        strcpy(month,yytext); BEGIN(LONG);
      /*
       * 日付の年の部分は最後に置かれるものと考えられる。したがって、
       * 年を見つけたらパースされた日付を表示することができる。もち
       * ろん、日付として不当なものであればゴミが出力されることになる
       */

     <LONG>{nyear}{year_ext} {
                               printf("Long:\n");
                               printf("  DOW   : %s \n",dow);
                               printf("  Day   : %s \n",day);
                               printf("  Month : %s \n",month);
                               printf("  Year  : %s \n",yytext);
                               strcpy(dow,"");
                               strcpy(day,"");
                               strcpy(month,"");
                             }
      /*
       * 日-月-年という形式の日付を処理する
       * SHORT状態で数値形式の日を見つけた場合は、年が日付の最後の部分
       * になると仮定する
       * パース状態は
       * SHORT->[日にマッチ]->YEAR_LAST->YLMONTH->SHORT
       * のように遷移する
       */

     <SHORT>{nday}        strcpy(day,yytext);  BEGIN(YEAR_LAST);
     <YEAR_LAST>{nmonth}  strcpy(month,yytext);BEGIN(YLMONTH);
     <YLMONTH>{nyear}     strcpy(year,yytext); BEGIN(SHORT);
      /*
       * 年-月-日という形式の日付を処理する
       * SHORT状態で数値形式の年を見つけた場合は、日が日付の最後の部分
       * になると仮定する
       * パース状態は
       * SHORT->[年にマッチ]->YEAR_FIRST->YFMONTH->SHORT
       * のように遷移する
       */

     <SHORT>{nyear}        strcpy(year,yytext); BEGIN(YEAR_FIRST);
     <YEAR_FIRST>{nmonth}  strcpy(month,yytext);BEGIN(YFMONTH);
     <YFMONTH>{nday}       strcpy(day,yytext);  BEGIN(SHORT);
      /*
       * 数値形式の日付では、年は最初になることも最後になることも可能。
       * したがって、パースしたものをいつ表示すべきかを示すのに改行を使う
       */

     <SHORT>\n               {
                               printf("Short:\n");
                               printf("  Day   : %s \n",day);
                               printf("  Month : %s \n",month);
                               printf("  Year  : %s \n",year);
                               strcpy(year,"");
                               strcpy(day,"");
                               strcpy(month,"");
                             }
      /*
       * 以下により、短い（数字）形式と長い（英数字）形式とを切り換える
       */

     long\n     BEGIN(LONG);
     short\n    BEGIN(SHORT);
      /*
       * 以下のルールは、無関係なテキストを見つけて破棄する
       * （マッチされたテキストはデフォルトではECHOされないが、
       *   マッチされなかったテキストはECHOされる。ピリオドは
       *   改行以外のすべての文字を見つける。改行は\nによって
       *   見つけられる）
       */

     {skip}*
     \n
     .

この実例は、 様々な形式の日付をスキャンし、 構成単位に分割します。
例えば、 以下のものを正しくスキャンし、 日付の個々の部分を識別します。

     short
     1989:12:23
     1989:11:12
     23:12:1989
     11:12:1989
     1989/12/23
     1989/11/12
     23/12/1989
     11/12/1989
     1989-12-23
     1989-11-12
     23-12-1989
     11-12-1989
     long
     Friday the 5th of January, 1989
     Friday, 5th of January, 1989
     Friday, January 5th, 1989
     Fri, January 5th, 1989
     Fri, Jan 5th, 1989
     Fri, Jan 5, 1989
     FriJan 5, 1989
     FriJan5, 1989
     FriJan51989
     Jan51989

ファイルの最初の部分では、
月、および、日付の異なる部分に使われる数字形式を単に定義しています。
この実例では、
ある特定の方法でスキャン処理が進行するよう強制するために、
スタート状態を使います。 例えば、 行の先頭で`1989'を見つければ、
それが日と月の組み合わせではなく年であり、 したがって、
日付の次の部分が月に違いないことが分り、
スキャン処理がそのとおりに進むよう強制します。 このことにより、
非常に単純な状態駆動のパーサを効果的に作成したことになり、
日付をその構成要素にうまく分割することができるようになります
（このスキャナの内部で起こっていることをフロー・チャートに描いてみれば、
このことが明瞭に見てとれるでしょう）。

   このマニュアル中の他の実例と同様に、 この実例も

     flex -i dates.lex
     cc -o dates lex.yy.c -lfl

を実行することによりコンパイルすることができます。 また、
`examples'サブディレクトリにおいて単に`make dates'を実行することにより、
コンパイルすることもできます。


File: flex-ja.info,  Node: %option (Flex 2.5),  Prev: Start States,  Up: Flex Descriptions

3.9 %option（Flex 2.5の補足情報）
=================================

Flex 2.5では、
スキャナ定義ファイルの中で様々なオプションを指定することができます。
オプションを指定するには、 スキャナ定義ファイルの先頭
（最初の`%%'よりも前の部分） に、 `%option'指示子を記述します。

   ほとんどの`%option'指示子は、 以下の形式で指定されます。

     %option OPTION_NAME

   オプションOPTION_NAMEの指定を無効にするためには、
オプション名の前に`no'を付けます。

     %option noOPTION_NAME

以下に、
コマンドライン・オプションと同等の効果を持つ`%option'指示子を示します。
各コマンドライン・オプションの意味については、 *Note Command Line
Switches::と*Note Command Line Switches (Flex 2.5)::を参照してください。

`%option 7bit'
     -7オプション

`%option 8bit'
     -8オプション

`%option align'
     -Caオプション

`%option backup'
     -bオプション

`%option batch'
     -Bオプション

`%option c++'
     -+オプション

`%option caseful'
     -iオプションの否定

`%option case-sensitive'
     -iオプションの否定

`%option case-insensitive'
     -iオプション

`%option caseless'
     -iオプション

`%option debug'
     -dオプション

`%option default'
     -sオプションの否定

`%option ecs'
     -Ceオプション

`%option fast'
     -Fオプション

`%option full'
     -fオプション

`%option interactive'
     -Iオプション

`%option lex-compat'
     -lオプション

`%option meta-ecs'
     -Cmオプション

`%option output="FILE"'
     -oFILEオプション

`%option perf-report'
     -pオプション

`%option prefix="PREFIX"'
     -PPREFIXオプション

`%option read'
     -Crオプション

`%option stdout'
     -tオプション

`%option verbose'
     -vオプション

`%option warn'
     -wオプションの否定

次に、
コマンドライン・オプションでは代替できない`%option'指示子を示します。

`%option array'
     `yytext'を`char'の配列として定義します。 これは、
     `%array'と同じです。

`%option always-interactive'
     入力を常に対話的に扱うスキャナを生成するよう指示します。
     これと`%option never-interactive'のどちらも指定されない場合、
     生成されたスキャナは、
     ファイルをオープンするたびに`isatty()'を呼び出して、
     入力を対話的に（１文字ずつ）読み込むべきか否かを決定します。

`%option main'
     生成されるスキャナに、
     以下のような`main()'関数を組み込むよう指示します。

          int main()
          	{
          	yylex();
          	return 0;
          	}

     これは、 暗黙のうちに`%option noyywrap'を指定します。

`%option never-interactive'
     入力を常に対話的に扱わないスキャナを生成するよう指示します。
     これと`%option always-interactive'のどちらも指定されない場合、
     生成されたスキャナは、
     ファイルをオープンするたびに`isatty()'を呼び出して、
     入力を対話的に（１文字ずつ）読み込むべきか否かを決定します。

`%option pointer'
     `yytext'を`char'に対するポインタとして定義します。 これは、
     `%pointer'と同じです。

`%option reject'
     スキャナ定義ファイルの中で`REJECT'が使われていることを、
     Flexに通知します。 Flexは通常、
     定義ファイルの中で`REJECT'が使われているか否かを自分で調査しますが、
     この`%option'指示子の指定は、 Flex自身による判定結果に優先します。

`%option stack'
     スタート状態スタック （*Note Start State Notes (Flex 2.5)::を参照）
     を使用するためには、
     この`%option'指示子を指定しなければなりません。

`%option stdinit'
     `yyin'を`stdin'で、 `yyout'を`stdout'で、 それぞれ初期化します。
     この`%option'指示子が指定されない場合、 あるいは、 `%option
     nostdinit'が指定された場合、 `yyin'と`yyout'は、 `(FILE
     *)0'（NULLポインタ）で初期化されます。

`%option unput'
     `%option *no*unput'が指定されると、 生成されるスキャナの中に、
     関数`unput()'が組み込まれません。(1)

`%option yy_pop_state'
     `%option *no*yy_pop_state'が指定されると、
     生成されるスキャナの中に、 関数`yy_pop_state()'が組み込まれません。
     ただし、 `%option stack'が指定されていない場合は、 `%option
     *no*yy_pop_state'の指定の有無にかかわらず、
     関数`yy_pop_state()'は組み込まれません。

`%option yy_push_state'
     `%option *no*yy_push_state'が指定されると、
     生成されるスキャナの中に、
     関数`yy_push_state()'が組み込まれません。 ただし、 `%option
     stack'が指定されていない場合は、 `%option
     *no*yy_push_state'の指定の有無にかかわらず、
     関数`yy_push_state()'は組み込まれません。

`%option yy_scan_buffer'
     `%option *no*yy_scan_buffer'が指定されると、
     生成されるスキャナの中に、
     関数`yy_scan_buffer()'が組み込まれません。

`%option yy_scan_bytes'
     `%option *no*yy_scan_bytes'が指定されると、
     生成されるスキャナの中に、
     関数`yy_scan_bytes()'が組み込まれません。

`%option yy_scan_string'
     `%option *no*yy_scan_string'が指定されると、
     生成されるスキャナの中に、
     関数`yy_scan_string()'が組み込まれません。

`%option yy_top_state'
     `%option *no*yy_top_state'が指定されると、
     生成されるスキャナの中に、 関数`yy_top_state()'が組み込まれません。
     ただし、 `%option stack'が指定されていない場合は、 `%option
     *no*yy_top_state'の指定の有無にかかわらず、
     関数`yy_top_state()'は組み込まれません。

`%option yyclass="CLASSNAME"'
     これは、 `-+'オプションが指定されている場合 （すなわち、
     C++スキャナを生成する場合） のみ有効です。 これにより、
     CLASSNAMEにより指定される名前のクラスが、
     `yyFlexLexer'のサブクラスとして定義されます。
     実際にスキャン処理を実行するコードは、
     クラスCLASSNAMEのメンバ関数`yylex()'（`CLASSNAME::yylex()'）に実装されます。
     詳細については、 *Note Flex and C++ (Flex
     2.5)::を参照してください。

`%option yylineno'
     入力の行数をカウントして大域変数`yylineno'に保持するスキャナを生成するよう指示します。

`%option yymore'
     スキャナ定義ファイルの中で`yymore()'が使われていることを、
     Flexに通知します。 Flexは通常、
     定義ファイルの中で`yymore()'が使われているか否かを自分で調査しますが、
     この`%option'指示子の指定は、 Flex自身による判定結果に優先します。

`%option yywrap'
     `%option *no*yywrap'が指定されると、 `yywrap()'はマクロとして、

          #define yywrap() 1

     のように定義されます。 この結果、 ファイルの終端を検出した時に、
     スキャナは、
     ほかにスキャンすべきファイルは存在しないと判断するようになります。

   ---------- Footnotes ----------

   (1) Flex 2.5.4に付属のドキュメント`flex.texi'には、
関数`input()'についても同様のことが記載されていますが、 実際に`%option
*no*input'を指定してみると、 生成されるスキャナの中に、
関数`input()'が組み込まれます。


File: flex-ja.info,  Node: Interfacing to Flex,  Next: Other Flex Features,  Prev: Flex Descriptions,  Up: Top

4 Flexとのインターフェイス
**************************

     この章ではCおよびBisonと一緒にFlexを使う方法を説明します。(1)C、Bisonのそれぞれが非常に多くの細目を含むため、
     本章は２つの部分に分割されています。 その両方に、
     全般的なインターフェイス概念に関する節と実例を示す節があります。

========================================================================

* Menu:

* Flex and C::                  CとFlexのインターフェイス
* Flex and C (Flex 2.5)::       同上（Flex 2.5の補足情報）
* An Example of Flex and C::    フィルタにおける文字列代替
* Flex and Bison::              FlexとBisonの協同
* Another Example of Flex and Bison::  FlexとBisonのもう１つの実例
* Flex and C++ (Flex 2.5)::     C++とFlexのインターフェイス
                                （Flex 2.5の補足情報）
========================================================================

   ---------- Footnotes ----------

   (1) 訳注：この章の最後で、 C++の使い方についても説明します。


File: flex-ja.info,  Node: Flex and C,  Next: Flex and C (Flex 2.5),  Prev: Interfacing to Flex,  Up: Interfacing to Flex

4.1 FlexとC
===========

Flexに対するCの主要なインターフェイスは、
以下に挙げるルーチンと変数によるものです。 以下の節を読む際には、
いくつかの細かな部分でFlexとLexとの間に相違点があるということを意識しておいてください。
Lexが提供していない関数がいくつかありますし、
宣言の内容が違うものもあります。 こうした相違点は、
通常大きな問題にはなりません。 というのは、
相違のある関数は一般的にはあまり使われていないからです。
相違点に関する詳細については、 *Note Flex and Lex::および*Note Flex and
POSIX::を参照してください。

    `関数'
          説明と実例

    `yylex()'
          `yylex()'は実際のスキャン処理を行う関数です。
          ファイル（デフォルトは`stdin'）を読み込み、
          パターン・マッチングを行い、
          パターンに関連付けされたアクションを実行します。
          デフォルトでは、 入力の終端に達するまでマッチングを行い、
          終端に達したところでゼロを返します。 （`return'を使って、
          呼び出し側のプログラムにほかの値を返すことは可能です。
          これは、 *Note Flex and Bison::で説明しています。）
          したがって、 インターフェイスを提供する簡単な方法の１つは、
          オプションのCコード領域の１つに以下のようなコードを追加することです。

               #include <stdio.h>

               int main(argc,argv)
               int argc;
               char *argv;
               {
                  yylex();
               }

          しかしこのような場合には、
          Flexライブラリ（`-lfl'）もしくはLexライブラリ（`-ll'）のいずれかをリンクして、
          そこからこれと同じような`main()'関数を取り込むことができます。
          この場合は、 スキャナは単にファイルをスキャンして、
          ルールに関連付けされたアクションを実行するだけであるという点に注意してください。

          `yylex()'の使い方としてもう１つよく見られるのが、
          マッチされたものが何であるかを示す値を返させることです。
          これは、 アクションに`return'文を追加することで行われます。
          `return'文を見つけると、 `yylex()'は指定された値を返します。
          これが、
          BisonによるパーサがFlexによるスキャナから情報を獲得する方法です。

          ルールの中に、
          マッチされたテキストが何を表しているかを示すコードを返す`return'文があれば、
          以下のようなインターフェイスを使うことができます。

               #include <stdio.h>

               int main(argc,argv)
               int argc;
               char *argv;
               {
                  int return_code;
                  while((return_code = yylex()) != 0){
                      switch(return_code){
                      case KEYWORD1:
                         /* 何かを行う */
                         break;
                      case KEYWORD2:
                         /* 何か別のことを行う */
                         break;
                           ...
                      case KEYWORDN:
                      }
                  }
               }

          `yylex'のデフォルトの定義は`int yylex(void)'ですが、
          これは`YY_DECL'マクロを使うことによって変更することができます。
          例を示すと、 以下のコードは`yylex()'の名前を`gettok()'に、
          型をcharに対するポインタ型に変更し、
          パラメータ`buffer'を受け取るように指定します。

               #undef   YY_DECL
               #define  YY_DECL char *gettok(char *buffer)

          *注：*ANSI対応でないCを使っている場合は以下のように定義しなければなりません。
               #define YY_DECL char *gettok(buffer) \
                                     char *buffer;
          言葉を変えると、
          再宣言はターゲットとなるCコンパイラにとって正当な関数宣言でなければなりません。
          さらに、 この再宣言は、
          ファイルの*先頭*にあるオプションのCコード領域になければならないという点に注意してください。

    `yyin'
          `yyin'は、 `yylex()'が文字を読み込む元となるファイルです。
          デフォルトは`stdin'ですが、
          `fopen()'を使って変更することができます。
          `yyin'を読み込むデフォルトの方法は、
          複数文字から成るブロックを一度に読むというものです。 これは、
          `YY_INPUT'マクロによって変更できます。 `YY_INPUT'マクロは、
          ファイルではなく文字列をスキャンするためのスキャナを生成するのに便利です。
          `YY_INPUT'を定義する方法は以下のとおりです。

               YY_INPUT(buffer,result,max_size)

          ここで、 `buffer'は入力バッファ、
          `result'は読み込まれた文字数がセットされる変数、
          `max_size'は`buffer'のサイズです。 以下に、
          一度に１文字ずつ読み込むという入力方法に変更する再定義の例を示します。
          この方法を使うと_かなり_遅くなるので、 お勧めはできません。

               #undef   YY_INPUT
               #define  YY_INPUT(buffer,result,max_size) \
                        {\
                           buffer[0] = getchar();\
                           if(buffer[0] == EOF)\
                              result = YY_NULL;\
                           else\
                              result = 1;\
                        }

          *注：*この再宣言は、
          ファイルの*先頭*にあるオプションのCコード領域になければなりません。

    `yyout'
          `yyout'はスキャナが`ECHO'の出力を書き込むファイルです。
          デフォルトは`stdout'ですが、
          これも`fopen()'を呼び出すことで変更できます。

    `yytext'
          `yytext'は最後にマッチされた文字列、
          つまり最後に認識されたトークンを含む大域変数です。
          `yytext'の正しい外部定義は、
          Lexの場合のcharの配列とは_異なり_、
          charに対するポインタ型である点に注意してください。(1) つまり、
          `yytext'は

               extern char yytext[];

          ではなく、常に

               extern char *yytext;

          のように宣言されなければならないということです。
          このようになっている理由は性能です。 `yytext'が配列であると、
          スキャナ中でそれを操作するコードは、
          コピー処理をたくさん行う必要があります。
          これに対して`yytext'がポインタである場合には、
          このようなことは必要ありません。

          通常は、 `yytext'は変更すべきではありません。
          `yytext'の内容が変更される必要がある場合には、
          代わりのバッファが使われるべきです。
          （`examples'サブディレクトリの`yymore2.lex'ファイルでは、
          `yytext'を直接操作する技法が実演されています。 ただし、
          このようなやり方は_お勧めできません_。）

    `yyleng'
          `yyleng'は、
          最後に認識されたトークンの長さを保持する大域変数です。

    `yywrap()'
          `yywrap'は、 `yyin'の終端に達した時に呼び出される関数です。
          この関数が`TRUE'（ゼロ以外）を返すとスキャナは終了し、
          `FALSE'（ゼロ）を返すと、
          `yyin'が次の入力ファイルを指すように設定されたものと仮定して、
          スキャン処理が続行されます。

          現在のところ`yywrap()'は、
          常に１を返すよう定義されているマクロです。 このため、
          再定義するには、
          まず最初に`#undef'で定義解除しなければなりません。 Lexでは、
          `yywrap()'は関数です。 Flexも将来のある時点で、
          これを関数として定義することになるでしょう。(2)

    `yymore()'
          `yymore()' は、
          次に認識されるトークンで`yytext'の内容を更新するのではなく、
          その時点の`yytext'の内容の後ろにそのトークンを追加するようFlexに通知する関数です。
          したがって、
          以下の例に対して`foobar'という文字の並びを入力として与えると、
          `stdout'に`foofoobar'という文字の並びが書き込まれます。

               %%
               foo    ECHO; yymore();
               bar    ECHO;

          これは、
          まず`foo'ルールによって`foo'という文字の並びが認識されて`ECHO'され、
          次に`bar'という文字の並びが認識されて`yytext'の内容の後ろに追加された後に、
          `foobar'という文字の並びが`ECHO'されるからです。

          もう少し現実的な例を取り上げましょう。
          以下のコードは複数行の文字列を処理するのに`yymore()'を使っています。

               /*
                *  yymore.lex: yymore()を有効に使う例
                */

               %{
               #include <memory.h>
               void yyerror(char *message)
               {
                 printf("Error: %s\n",message);
               }

               %}
               %x STRING

               %%
               \"   BEGIN(STRING);

               <STRING>[^\\\n"]* yymore();
               <STRING><<EOF>> {
                             yyerror("EOF in string.");
                             BEGIN(INITIAL);
                           }
               <STRING>\n  {
                             yyerror("Unterminated string.");
                             BEGIN(INITIAL);
                           }
               <STRING>\\\n yymore(); /* 複数行にわたる
                                       * 文字列を処理する
                                       */
               <STRING>\"  {
                             yytext[yyleng-1] = '\0';
                             printf("string = \"%s\"",yytext);
                             BEGIN(INITIAL);
                           }
               %%

          この例では、
          エスケープ・シーケンスの変換がまったく行われていないので、
          文字列に対してさらに処理が必要である点に注意してください。
          この例は、 *Note 文字列リテラルの処理: Handling
          Strings.において、 エスエープ・シーケンスを処理する、
          より役に立つ形式に拡張されます。 

    `yyless(N)'
          `yyless()'は、 `yymore()'とほぼ反対のことを行うものです。
          この関数は、 最初のN文字以外のすべてを戻します。
          戻された文字の並びは、 次のトークンをマッチするのに使われ、
          `yyleng'と`yytext'には、 この変化を反映した値が設定されます。
          引数Nにゼロを指定して`yyless()'を呼び出すと、
          全入力データが戻され、 スキャナは （`BEGIN'、
          またはそれに類似のものでデフォルトの動作が変更されない限り）
          無限ループに入ります。 例えば、
          次のコードに`foobar'という文字の並びを入力として与えると、
          `foobarbar'という文字の並びが出力されます。

               %%
               foobar      ECHO; yyless(3);
               [a-z]+      ECHO;

          これは、 `foobar'が認識され`ECHO'された後に、
          `bar'が戻されるからです。 となると、 次にマッチするのは
          （`[a-z]+'というルールでマッチされる） `bar'だけで、
          これが次に`ECHO'されることになります。

    `input()'
          `input()'は、 `yyin'から次の文字を取って返す関数です。
          これは、
          標準的なFlexルール・システムを使ったのではうまく扱えないケースを処理するのによく使われます。
          例えば、 ほとんどの言語におけるコメントは、
          これを使って処理することができます。 これを使う理由は、

               %%
               "/*".*"*/"

          が、 ピリオドが改行_以外_の任意の文字にマッチしてしまうために
          複数行にわたるコメントをうまく処理できず、 また、

               %%
               "/*"[.\n]*"*/"

          は、 文字クラスが_任意_の文字にマッチしてしまうために、
          バッファをオーバーフローさせるか、
          さもなくばファイルの内容をすべて読み込んでしまうからです。
          （実際には、 排他的スタート状態を使うことで、
          こうしたことを非常にエレガントな方法で処理することができます。
          実例については、 *Note 役に立つコードの抜粋: Useful
          Code.を参照してください。 しかし、
          POSIXによりサポートされているにもかかわらず、
          ここで必要になるいくつかの機能をLexが提供していないために、
          この方法には移植性がありません。）
          Cのコメントは以下のようにして移植性のある方法で処理することができます。

               %%
               "/*" {
                       int a,b;

                       a = input();
                       while(a != EOF){
                         b = input();
                         if(a == '*' && b == '/'){
                           break;
                          }else{
                           a = b;
                          }
                        }
                       if(a == EOF){
                         error_message("EOF in comment");
                       }
                     }

          *注：*スキャナがC++コンパイラを使ってコンパイルされる場合は、
          この関数`input'は`yyinput'という名前になります。 これは、
          `input'という名前が同一名のC++ストリームと衝突するからです。
          また、 Flexでは`input()'は`yytext'の内容を破壊しますが、
          Lexでは`yytext'は変更されずそのまま残ります。
          これは将来のリリースで修正される予定です。

    `unput(c)'
          `unput()'は、 文字`c'が次にスキャンされる文字になるように、
          文字`c'を入力ストリームに置く関数です。 例えば、

               %%
               foo  unput('b');

          は`foo'を`b'で置き換えます。 これは、
          `foo'にマッチして`b'を戻し、
          この`b'が次にスキャンされる文字になるからです。
          デフォルトのルールにより、 `b'は`stdout'に書き込まれます。

          １つの文字が次にスキャンされる文字になるということには１つ微妙な点があって、
          それは、 文字列を入力ストリームに置きたい場合には、
          逆順に行わなければならないということです。
          以下に例を示します。

               foobar  {
                          char  *baz = "baz";
                          int   i    = strlen(baz)-1;

                          while(i >= 0){
                             unput(baz[i]);
                             i--;
                          }
                       }

          これは、 `foobar'がマッチされた時に、
          入力ストリームに`baz'を置きます。 以下は、
          _してはならない_ことを示す例です。

               /*
                * unput.l : unput()を使って行ってはならない
                *           処理の例
                */

               %{
               #include <stdio.h>

               void putback_yytext(void);
               %}
               %%
               foobar   putback_yytext();
               raboof   putback_yytext();
               %%
               void putback_yytext(void)
               {
                   int   i;
                   int   l = strlen(yytext);
                   char  buffer[YY_BUF_SIZE];

                   strcpy(buffer,yytext);
                   printf("Got: %s\n",yytext);
                   for(i=0; i<l; i++){
                      unput(buffer[i]);
                   }
               }

          この例に`foobar'を入力として与えると、
          まず`foobar'にマッチし、
          次に`raboof'にマッチする無限ループに陥ります。

          *注：*`input()'と同様に`unput()'も`yytext'の内容を破壊します。(3)つまり、
          `yytext'から文字情報を返したい場合には、
          上の例に示されるように、
          まず`yytext'の内容をコピーしなければならないことを意味しています。

    `yyterminate()'
          アクションの中で呼び出されると、
          `yyterminate()'はスキャナの実行を終了させ、
          その後に`yylex()'が0を返します。 この後は、
          `yyrestart()'（下記参照）が呼び出されない限り、
          `yylex()'を呼び出してもすぐに復帰してしまいます。

    `yyrestart(FILE)'
          `yyrestart()'は、
          スキャナの実行を再開するようFlexに通知する関数です。
          これは引数を１つだけ、 すなわち、
          スキャンの対象となるファイル（通常は`yyin'）を取ります。
          これは、 EOFを処理するために使うこともできますし、 また、
          Flexに割り込みをかけ、
          その後に再開始させることができるようにするために使うこともできます。
          （Flexスキャナは_再入可能ではない_ので、
          このようなことが必要になります。）

    `YY_NEW_FILE'
          `yyin'が新しいファイルを指すよう変更され、
          処理が継続されるべきであるということをFlexに通知するマクロです。(4)
          以下に例を示します。

               /*
                * cat.lex: YY_NEW_FILEの実演
                */

               %{
               #include <stdio.h>
               #define ERRORMESS "Unable to open %s\n"

               char **names = NULL;
               int  current = 1;
               %}
               %%
               <<EOF>> {
                        current += 1;
                        if(names[current] != NULL){
                           yyin = fopen(names[current],"r");
                           if(yyin == NULL){
                             fprintf(stderr,ERRORMESS,
                                      names[current]);
                             yyterminate();
                           }
                           YY_NEW_FILE;
                        } else {
                          yyterminate();
                        }
                       }
               %%
               int main(int argc, char **argv)
               {
                 if(argc < 2){
                    fprintf(stderr,"Usage: cat files....\n");
                    exit(1);
                 }
                 names = argv;
                 yyin = fopen(names[current],"r");
                 if(yyin == NULL){
                   fprintf(stderr,ERRORMESS,names[current]);
                   yyterminate();
                 }
                 yylex();
               }

    `ECHO'
          `yytext'の内容を`yyout'に書き込むマクロです。

    `REJECT'
          `REJECT'は、 その時点においてマッチしているものを受け入れず、
          次に最もよくマッチするものを受け入れるようスキャナに通知するマクロです。
          スキャナはマッチするものの中で最長のものを探し、
          マッチするものが２つあってその長さが同じ場合は、
          記述ファイルにおいて最初に定義されている方を選択します。
          つまり、 認識されるテキストの長さは、
          同一の長さになることもあり、
          または短くなることもあるということを意味しています。
          `REJECT'を使った後は、
          `yytext'と`yyleng'は新しい値を取ります。
          `REJECT'に関して知っておくべき重要な点が２つあります。
          １つめは、 `REJECT'は分岐命令であり、 決して戻ってこないので、
          `REJECT'の後ろに記述されたアクションは実行されないということです。
          ２つめは、 `REJECT'とファスト・テーブル（fast
          table／`-F'）は一緒に使うことはできないということです。
          以下に簡単な例を示します。

               /*
                * reject.lex: REJECTとunput()を悪用する実例
                */

               %%
               UNIX   {
                           unput('U'); unput('N');
                           unput('G'); unput('\0');
                           REJECT;
                      }
               GNU    printf("GNU is Not Unix!\n");
               %%

          この例は、 新式のテキスト代替の技法を示しています。
          `UNIX'にマッチするものが見つかると、
          `unput()'によって`GNU'という文字の並びが戻され、
          その時点におけるスキャン・バッファの内容が上書きされます。
          次に`REJECT'により分岐が行われ、
          別のものにマッチするようスキャナに対して通知が行われます。
          `GNU'がバッファに書き込まれたので、 これが次にマッチされ、
          そのアクションが実行されます。 以下に、
          その結果こうなるであろうと思われる例を示します。

               UNIX RETURN
               GNU is Not Unix!

          実際のところは、
          Flexにおいて`REJECT'の用途はほんの少ししかありません。
          上記以外では、
          重複するパターンや状態の変更に_使うことができます_。
          例を示すと、 以下のようになります。

               nday         [1-9]|[1-2][0-9]|3[0-1]
               nmonth       [1-9]|1[0-2]
               nyear        [0-9]{1,4}

               %x DAY MONTH YEAR
               %%

               {nday}           BEGIN(DAY);   REJECT;
               <DAY>{nday}
                    ...
               {nmonth}         BEGIN(MONTH); REJECT;
               <MONTH>{nday}
                    ...
               {nyear}          BEGIN(YEAR);  REJECT;
               <YEAR>{nday}
                    ...

          この例では、 日付の形式は重複しており、
          最初に認識された構成要素によって、
          どのように日付をパースするかを決定します。 しかし、
          この例は少々不自然な感じがします。 というのは、 少し考えれば、
          `REJECT'を使わずに、
          より効率的なスキャナにすることができるからです。 これは、
          *Note スタート状態の使用例: Start State
          Example.に示しています。

    `BEGIN'
          `BEGIN'は、
          スキャナをある特定のスタート状態にするためのマクロです。
          `BEGIN'に続く名前はスタート状態の名前です。 例えば、

               %x FLOAT
               %%
               floats   BEGIN(FLOAT)
               <FLOAT>SOME_RULE SOME_ACTION
                      ...

          は、 `floats'という単語がマッチした時に、
          スタート状態を`FLOAT'に設定します （詳細については、 *note
          Start States Explained::）。

    `YY_USER_ACTION'
          `YY_USER_ACTION'は、
          ルール・セクション中のどのアクションよりも_前_に実行されるアクションを定義するマクロです。
          これは、 以下の例で示すように、
          `yytext'の内容の小文字から大文字への変換等を行うのに役に立ちます。

               /*
                * user_act.lex: YY_USER_ACTIONを使う
                *               ユーザ・アクションの例
                */

               %{

               #include <ctype.h>

               void user_action(void);
               #define YY_USER_ACTION user_action();

               %}

               %%

               .*         ECHO;
               \n         ECHO;

               %%
               /*
                * このユーザ・アクションはすべての文字を
                * 単に大文字に変換する
                */

               void user_action(void)
               {
                 int loop;

                 for(loop=0; loop<yyleng; loop++){
                   if(islower(yytext[loop])){
                      yytext[loop] = toupper(yytext[loop]);
                   }
                 }
               }

          これは、 すべての入力文字を単に大文字に変換して`ECHO'します。
          `YY_USER_ACTION'のデフォルトの設定では、 何も実行されません。

    `YY_USER_INIT'
          `YY_USER_INIT'は、
          スキャン処理が開始される_前_に実行されるアクションを定義するマクロです。
          基本的には、 `main()'関数の中で、
          `yylex()'を呼び出す文の前に同様のコードを記述するのと同じことです。
          以下に簡単な例を示します。

               /*
                * userinit.lex: YY_USER_INITを使う例
                */

               %{
               #define YY_USER_INIT open_input_file()

               extern FILE *yyin;
               void open_input_file(void)
               {
                 char *file_name,buffer[1024];

                 yyin      = NULL;
                 while(yyin == NULL){
                   printf("Input file: ");
                   file_name = fgets(buffer,1024,stdin);
                   if(file_name){
                     file_name[strlen(file_name)-1] = '\0';
                     yyin = fopen(file_name,"r");
                     if(yyin == NULL){
                       printf("Unable to open \"%s\"\n",
                              file_name);
                     }
                   } else {
                     printf("stdin\n");
                     yyin = stdin;
                     break;
                   }
                 }
               }

               %}
               %%

          これは、 ファイルがオープンされるかEOFが検出されるまで、
          入力ファイル名を入力するようユーザに催促します。
          EOFが検出された場合は、
          入力元はデフォルトで`stdin'になります。
          これは以下と同じことです。

               /*
                * この例は、前の例と同じことをYY_USER_INITを
                * 使わずに行う
                */

               %{
               void open_input_file(void)
               {
                 char *file_name,buffer[1024];

                 yyin      = NULL;
                 while(yyin == NULL){
                   printf("Input file: ");
                   file_name = fgets(buffer,1024,stdin);
                   if(file_name){
                     file_name[strlen(file_name)-1] = '\0';
                     yyin = fopen(file_name,"r");
                     if(yyin == NULL){
                       printf("Unable to open \"%s\"\n",
                              file_name);
                     }
                   } else {
                     printf("stdin\n");
                     yyin = stdin;
                     break;
                   }
                 }
               }

               %}
               %%
               %%
               int main(int argc, char *argv[])
               {
                  open_input_file();
                  yylex();
               }

    `YY_BREAK'
          `YY_BREAK'はマクロです。
          インターフェイス的な機能というよりも、
          むしろ生成されるコードを変更するために使うことができるものです。

          スキャナ中において、
          すべてのアクションは１つの大きな`switch'文の要素であり、
          デフォルトでCの`break;'文に置き換えられる`YY_BREAK'によって区切られます。
          ルールのアクション部が多くの`return'文を含んでいる場合、
          コンパイラが`statement not
          reached'というエラー・メッセージをたくさん出力するかもしれません。
          `YY_BREAK'を再定義することによって、
          この警告メッセージの出力を止めることが可能です。 再定義は、
          セミ・コロンを含む正当なCの文でなければ_なりません_。

          *注：*`YY_BREAK'を再定義して空にするのであれば、
          アクションの最後は必ず`return;'か`break;'になるようにしてください。

   ---------- Footnotes ----------

   (1) 訳注：Flex 2.5では、 `%pointer'と`%array'により、
`yytext'の型を選択できるようになりました。
`%pointer'を指定した場合は`char *yytext'、
`%array'を指定した場合は`char yytext[YYLMAX]'となります。
デフォルトは`%pointer'です。 `%array'を指定した場合の配列のサイズは、
`YYLMAX'を再定義することによって変更可能です。

   (2) 訳注：Flex 2.5では、 `%option noyywrap'が指定されない限り、
`yywrap()'は関数です。 再定義をするのに、
`#undef'で定義解除する必要はありません。

   (3) 訳注：Flex 2.5では、 `%array'が指定された場合は、
`unput()'は`yytext'の内容を破壊しません。

   (4) 訳注：Flex 2.5では、
`yyin'を変更した後に`YY_NEW_FILE'を実行する必要はなくなりました。


File: flex-ja.info,  Node: Flex and C (Flex 2.5),  Next: An Example of Flex and C,  Prev: Flex and C,  Up: Interfacing to Flex

4.2 FlexとC（Flex 2.5の補足情報）
=================================

Flex 2.5では、 前節（*Note Flex and C::）で説明されていない、
以下のマクロもサポートされています。

    `yy_set_interactive(IS_INTERACTIVE)'
          カレント・バッファを、 対話的なものと見なすか、
          非対話的なものと見なすかを制御します。
          引数IS_INTERACTIVEにゼロ以外の値を渡すと、
          カレント・バッファは対話的なものと見なされ、 ゼロを渡すと、
          非対話的なものと見なされます。
          `yy_set_interactive()'による指定は、 `%option
          always-interactive'や`%option
          never-interactive'による指定に優先します。 このマクロは、
          バッファからのスキャン処理が始まるよりも前に呼び出されなければなりません。

    `yy_set_bol(at_bol)'
          バッファは、 様々なコンテキスト情報を保持しています。 例えば、
          行頭を表す`^'を含むルールが適用されるのは、
          バッファ内のカレントな位置が実際に行の先頭である場合だけですが、
          カレントな位置が行の先頭にあるか否かという情報は、
          バッファのコンテキスト情報として保持されています。

          マクロ`yy_set_bol()'は、
          バッファ内のカレントな位置が行の先頭にあるか否かを表すコンテキスト情報を設定します。
          引数にゼロ以外の値を渡すと、
          バッファ内のカレントな位置は行の先頭である、
          というコンテキスト情報がセットされます。 したがって、
          次にトークンのマッチ処理が行われる時には、
          行頭を表す`^'を含むルールの適用が試みられます。 逆に、
          引数にゼロを渡すと、
          バッファ内のカレントな位置は行の先頭ではないことになり、
          次にトークンのマッチ処理が行われる時には、
          行頭を表す`^'を含むルールの適用が試みられなくなります。

    `YY_AT_BOL()'
          次にトークンのマッチ処理が行われる時に、
          行頭を表す`^'を含むルールの適用が試みられるようなコンテキスト情報がセットされている場合には、
          ゼロ以外の値を返します。 それ以外の場合は、 ゼロを返します。


File: flex-ja.info,  Node: An Example of Flex and C,  Next: Flex and Bison,  Prev: Flex and C (Flex 2.5),  Up: Interfacing to Flex

4.3 FlexとCの簡単な実例
=======================

ある単語が現れた時に、
それを別の単語に置き換える必要の生じることがよくあります。 例えば、
ある名前が現れるたびに、
それをある１つの環境変数の値で置き換えてくれるユーティリティを作りたいとしましょう。
そして、 以下のようなことができるように、
そのユーティリティがフィルタとして動作するようにさせたいとします。

     nick% myname   < infile | more
     nick% myname   < infile > outfile

以下に、
こうしたことを実現する方法を示すFlexファイルの簡単な例を挙げます。

     /*
      * myname.lex : トークンの置き換えを行うFlexプログラム
      *              のサンプル
      */

     %%

     %NAME     { printf("%s",getenv("LOGNAME")); }
     %HOST     { printf("%s",getenv("HOST"));    }
     %HOSTTYPE { printf("%s",getenv("HOSTTYPE"));}
     %HOME     { printf("%s",getenv("HOME"));    }

     %%

   このソース・ファイルは`examples'サブディレクトリにあり、
その名前は`myname.lex'です。 これをビルドするには、
`examples'サブディレクトリに移動して`make myname'を実行するか、
以下を実行します。

     flex myname.lex
     cc lex.yy.c -o myname -lfl

ここで`-lfl'は、
リンカに対してFlexライブラリをリンクするよう通知します。 現在のところ、
Flexライブラリにはデフォルトの`main()'関数だけが含まれています。
将来のバージョンのFlexでは、 他の関数も含まれるようになるでしょう。
Flexライブラリがインストールされていない場合は、
この部分は`-ll'でなければなりません。

   いずれの場合でも、
最終的には`myname'という名前の実行ファイルが生成されるはずです。
これは、 以下のような変換処理を実行するフィルタです。

    `%NAME'
          ユーザのログイン名に置き換えられます。

    `%HOST'
          ユーザのホスト・コンピュータ名に置き換えられます。

    `%HOSTTYPE'
          ユーザのホスト・コンピュータのマシン・タイプに置き換えられます。

    `%HOME'
          ユーザのホーム・ディレクトリを表すパスに置き換えられます。

したがって、 以下のような内容を持つファイル`myname.txt'を作成して、

     Hello, my name is %NAME.  Actually
     "%NAME" isn't my real name, it is the
     alias I use when I'm on %HOST, which
     is the %HOSTTYPE I use.  My HOME
     directory is %HOME.

以下を実行すると、

     myname < myname.txt

以下のテキストに似たものが`stdout'へ書き込まれます。

     Hello, my name is foobar.  Actually
     "foobar" isn't my real name, it is the
     alias I use when I'm on baz, which
     is the cray I use.  My HOME
     directory is /home/foo/foobar.

   このプログラムがうまく動作するのは、
`yyin'と`yyout'がデフォルトでは`stdin'、`stdout'にそれぞれ割り当てられ、
かつ、
デフォルトのアクションが`yyin'の内容を`yyout'にコピーするからです。
また、
個々のルールに対応する唯一のアクションが単一行で記述されているため、 `{
}'は必要ではないことに注意してください。 このような場合には、
アクションを`{ }'で囲むか否かは、 個人的な好みの問題になります。

   これが、 引用符で囲まれた部分にあるものも含めて、
指定された名前が現れるところ_すべて_にマッチしたことに気がつきましたか？
Flexにおいては、
引用符で囲まれた部分にあるものにマッチさせたくない場合には、
それに対応するルールを作成することにより、
そうしないよう明示的にFlexに通知しなければなりません。
以下に例を示します。

     /*
      * myname2.lex : トークンの置き換えを行うFlexプログラムの例
      */

     %{
     #include <stdio.h>
     %}

     %x STRING
     %%
     \"                ECHO; BEGIN(STRING);
     <STRING>[^\"\n]*  ECHO;
     <STRING>\"        ECHO; BEGIN(INITIAL);
     %NAME     { printf("%s",getenv("LOGNAME")); }
     %HOST     { printf("%s",getenv("HOST"));    }
     %HOSTTYPE { printf("%s",getenv("HOSTTYPE"));}
     %HOME     { printf("%s",getenv("HOME"));    }

この例では、 排他的スタート状態を使って、
文字列中のテキストが変更されることのないようにしています。
この例も`examples'サブディレクトリにあるもので、
その名前は`myname2.lex'です。


File: flex-ja.info,  Node: Flex and Bison,  Next: Another Example of Flex and Bison,  Prev: An Example of Flex and C,  Up: Interfacing to Flex

4.4 FlexとBison
===============

Bisonは、 Flexと同様、 ある記述情報を受け取って、
それをもとにCのコードを生成するプログラムです。 両者の違いは、
BisonがCやPascalのような言語の文法に関する記述情報を入力として受け取り、
その記述情報から"パーサ"を生成する点にあります。
FlexとBisonを結合することにより、
言語の字句解析と構文解析の両方を処理することができるようになります。
（これは、
コンパイラ・デザインにおいて最も容易に自動化できる部分です。）

   生成されるパーサが機能するためには、
Bisonは`yylex()'という関数を必要とします。
この関数はユーザによって提供され、 呼び出された時に、
パースされている言語のある要素を表す整数値をBisonに返します。
Flexにおいてスキャン処理を行うルーチンは`yylex()'であり、
デフォルトでは整数値を返します。 これにより、
FlexとBisonを一緒に使うのは非常に簡単になります。

   *警告：* 以下の節では、
読者がBisonの基本的なパーサの宣言を理解しているものと仮定します。
Bisonを使った経験のない人には、
パーサの定義は混乱をもたらす可能性がありますので、
先に進む前に是非`Bison'のマニュアルを読んでください。
Bisonに興味の無い人は、 この節全体を飛ばしても構いません。

========================================================================

* Menu:

* Interfacing Flex and Bison::  一般的な方法
* YYSTYPE and yylval::          単なる整数以上の情報の渡し方
========================================================================


File: flex-ja.info,  Node: Interfacing Flex and Bison,  Next: YYSTYPE and yylval,  Prev: Flex and Bison,  Up: Flex and Bison

4.4.1 FlexとBisonのインターフェイス
-----------------------------------

FlexとBisonの間で情報を渡す基本的な方法は、
関数`yylex()'を使うことです。 これは、
Flexにより生成されるスキャナにおいて、
スキャン処理を実行する関数の名前です。
Flexの入力ファイルのアクション部分において`return'文を使うことによって、
単なる0や1以外の値を返すことができます。 この方法で、
`yylex()'は最後に認識されたトークンを表す整数値を返すことができます。

   Bisonを`-d'オプション付きで使うと、
Bisonは`.tab.h'という拡張子を持つファイルを生成します。
このファイルには、
記述情報中にある正当なトークンの１つ１つに対する一意な定義情報が含まれます。
この出力情報は、
特にスキャナによって使用されることを想定して設計されています。
このファイルをFlexにより生成されたスキャナに含めることで、
２つのプログラムの間に非常に明確なインターフェイスを作ることができます。
例として、 以下にBisonのファイルを示します。
このファイルの名前を`expr.y'としましょう。

     /*
      * expr.y : Bisonマニュアル中の例に基づく
      *          Bisonによる簡単な表現式パーサ
      */

     %{
     #include <stdio.h>
     #include <math.h>

     %}
     %union {
        float val;
     }

     %token NUMBER
     %token PLUS MINUS MULT DIV EXPON
     %token EOL
     %token LB RB
     %left  MINUS PLUS
     %left  MULT DIV
     %right EXPON

     %type  <val> exp NUMBER
     %%
     input   :
             | input line
             ;
     line    : EOL
             | exp EOL { printf("%g\n",$1);}
     exp     : NUMBER                 { $$ = $1;        }
             | exp PLUS  exp          { $$ = $1 + $3;   }
             | exp MINUS exp          { $$ = $1 - $3;   }
             | exp MULT  exp          { $$ = $1 * $3;   }
             | exp DIV   exp          { $$ = $1 / $3;   }
             | MINUS  exp %prec MINUS { $$ = -$2;       }
             | exp EXPON exp          { $$ = pow($1,$3);}
             | LB exp RB              { $$ = $2;        }
             ;

     %%
     void yyerror(char *s)
     {
       printf("%s\n",s);
     }
     int main()
     {
       yyparse();
     }

これは非常に簡単な計算機の文法定義です。

   `-y -d'オプション付きで呼び出されると、
Bisonは`y.tab.h'というファイルを生成します。
このファイルには以下のような定義か、
それにきわめてよく似た定義が含まれます。

     typedef union  {
        float val;
     } YYSTYPE;
     extern YYSTYPE yylval;
     #define NUMBER  258
     #define PLUS    259
     #define MINUS   260
     #define MULT    261
     #define DIV     262
     #define EXPON   263
     #define EOL     264
     #define LB      265
     #define RB      266

Flexがトークンの値を正しくBisonに返すことができるように、
（`#include'を使って） これをスキャナに含めることができます。
そのコードは以下のようなものになります。

     /*
      * expr.lex : 簡単な表現式パーサのためのスキャナ
      */

     %{
     #include "y.tab.h"
     %}

     %%
     [0-9]+     { yylval.val = atof(yytext);
                  return(NUMBER);
                }
     [0-9]+\.[0-9]+ {
                  sscanf(yytext,"%f",&yylval.val);
                  return(NUMBER);
                }
     "+"        return(PLUS);
     "-"        return(MINUS);
     "*"        return(MULT);
     "/"        return(DIV);
     "^"        return(EXPON);
     "("        return(LB);
     ")"        return(RB);
     \n         return(EOL);
     .          { yyerror("Illegal character");
                  return(EOL);
                }
     %%

上記のファイルは、 以下のようにしてコンパイルすることができます。

     bison -d -y expr.y
     flex -I  expr.lex
     cc -o expr y.tab.c lex.yy.c alloca.c

また、 この例のソースが手元にあれば、
`examples'サブディレクトリにおいて`make
expr'を実行するだけでコンパイルできます。 どちらの方法でも、
`expr'という名前の簡単な計算機が生成されます。
これは以下のような表現式をパースして、 その結果を出力します。

     1 + 2 * (199*2)


   これを見てお分かりのように、
この種のインターフェイスは非常に柔軟であり、 かつ、
保守も非常に容易です。 （トークンを定義する名前が変わらない限り）
BisonとFlexの間のインターフェイスを変更することなく、 Flex、
Bisonいずれの入力情報においても、 機能の追加や削除、
定義やコードの変更を行うことが可能です。

   この例では、
FlexとBisonの間で情報を渡すための別の方法を導入していることに注意してください。
この例では、 数字の値をBisonに返すのに`yylval'を使っています。
これについては次の節でより詳細に説明します。 ここではとりあえず、
`return'文の使い方を学んでおいてください。

   *注：*これは単純な例です。
表現式のパース処理についてより詳しく知りたい人は、
`Bison'のマニュアルを参照してください。


File: flex-ja.info,  Node: YYSTYPE and yylval,  Prev: Interfacing Flex and Bison,  Up: Flex and Bison

4.4.2 YYSTYPEとyylval
---------------------

FlexからBisonに対して、
単なる整数値以上の情報を渡す必要の生じることがよくあります。 例えば、
コンパイラにおいては、
どのような_種類_のトークンが認識されたかだけではなく、
そのトークンの値についても知る必要のある場合がときどきあります。
文字列、文字、および数値定数などが良い例です。 ここで問題なのは、
どのようにしてFlexにこうした情報を返させるかです。

   その答は、 Bisonが持っている`%union'文です。 これは、
`YYSTYPE'という型を定義するものです。 `YYSTYPE'は、
パーサ定義中において使われるすべての正当なデータ型の共用体（`union'）です。
Bisonがカレントなパース状態に関連づけたデータを保存するために使う、
`YYSTYPE'型の変数`yylval'というものがあり、
Flexから`yylval'に値を設定することができるので、
トークンの型だけでなく、 それ以上の情報をBisonに返すことができます。

   Bisonにおいて`%union'を宣言して`-d'オプションを使うと、
Bisonは`.tab.h'という拡張子を持つファイルを作成して、
そこにトークンの定義情報だけでなく、
`YYSTYPE'と`yylval'の宣言も含めます。 したがって、
`yylval'にアクセスするためにしなければならないことは、
Flexの定義情報の中にこの`.tab.h'ファイルをインクルードすることだけです。
これは、
追加のCコード・セクションにおける定義の先頭でインクルードしなければなりません
（*note Interfacing Flex and Bison::）。

   *注：*初期のバージョンのBisonは、
自動的に`YYSTYPE'と`yylval'の宣言を生成しません。 この場合には、
より新しいバージョンのBisonを入手するか、 もしくは、
Flexの定義ファイルの先頭において`YYSTYPE'と`yylval'を宣言する必要があります。


File: flex-ja.info,  Node: Another Example of Flex and Bison,  Next: Flex and C++ (Flex 2.5),  Prev: Flex and Bison,  Up: Interfacing to Flex

4.5 FlexとBisonのもう１つの実例
===============================

コードを読むのは、 プログラミングの方法を学ぶ良い方法です。 そこで、
Flex、Bisonのインターフェイス例をもう１つ示すことにします。 下の例では、
拡張してデータベースを操作するために使うことができるような、
小規模な言語のための簡単なパーサを作ります。

========================================================================

* Menu:

* The Database Language::       データベース言語の定義
* The Implementation::          言語を解析するファイル
* Notes on the Implementation::  この実装を選択した理由に関する（簡単な）注
========================================================================


File: flex-ja.info,  Node: The Database Language,  Next: The Implementation,  Prev: Another Example of Flex and Bison,  Up: Another Example of Flex and Bison

4.5.1 インターフェイス言語
--------------------------

データベースとのインターフェイス言語は、
英語の非常に小さなサブセットになります。
文法はおおよそ以下のようになります。

     command_list     ::= sentence {sentence ...}
     sentence         ::= verb_phrase noun_phrase position_phrase
                          adverb period
     verb_phrase      ::= VERB | adverb VERB
     noun_phrase      ::= declared_noun | qualified_noun | noun
     declared_noun    ::= declarator NOUN
     declarator       ::= THIS | THAT | THE | THOSE
     qualified_noun   ::= qualifier NOUN
     qualifier        ::= SOME | MANY | ALL { declarator } NOUN
     position_phrase  ::= position declarator NOUN  | empty
     position         ::= IN | ON | AT
     adverb           ::= ADVERB | empty

結果として作成されるプログラムは、 以下のような文章を受け付けます。

     FIND MEN
     QUICKLY FIND MEN
     FIND ALL MEN ON THE NETWORK
     QUICKLY FIND ALL MEN ON THE NETWORK
     FIND ALL MEN ON THE NETWORK QUICKLY

   この例では、 BisonとFlexの間のインターフェイスが明確に示されるよう、
文章の簡単な解析結果が表示されます。
このプログラムを試しに実行してみると、
その表示結果は大体以下のようになります。

     % front
     FIND MEN
     I understand that sentence.
     VP = FIND
     NP = MEN
     PP =
     AD =
     QUICKLY FIND ALL THE MEN ON THE NETWORK
     I understand that sentence.
     VP = QUICKLY FIND
     NP = ALL THE MEN
     PP = ON THE NETWORK
     AD =
     ^C
     %

これは特別便利なものではありません。 というのは、
これは文章の構成要素を表示する以外に何も_行わない_からです。 しかし、
そこには拡張のためのフックもありますし、 一般的な技法も示されています。
より一般的な形式の文章を受け付けるよう、 この例を拡張してみてください。
ほとんどの場合、
文章は動詞句（`VERB'）と名詞句（`NOUN'）に分割することができますが、
所有格名詞、 名詞の後ろに名詞が続く場合など、
文章を構成する他の要素も許容されるようにする必要があります。 （`FIND
ALL JONE'S CAT
NAMES'のような文章をどうやってパースするかを想像してみてください。）
Bisonの文法やその使い方に関する詳しい説明については、
`Bison'のマニュアルを参照してください。


File: flex-ja.info,  Node: The Implementation,  Next: Notes on the Implementation,  Prev: The Database Language,  Up: Another Example of Flex and Bison

4.5.2 実装：コマンド文パーサ
----------------------------

上の節で、 小規模な言語について説明しました。
次にそれを実装してみることにしましょう。
以下のファイルがこれを実現します。

   *注：*_これはあくまでも１つの例として見てください。
特に文法の部分は、 英語のパース処理としてはあまり良い例ではありません。_

   以下はBisonのファイルです。 `%union'の部分、 および、
`yylval'にアクセスするために`$$'と`$'nを使う方法に注目してください。

     /* Cコードはファイルの先頭で提供する */

     %{

     #include <stdio.h>
     #include <string.h>

     extern int  yylexlinenum;  /* lex.yy.cに存在する */
     extern char *yytext;       /* カレント・トークン */

     %}
     /* キーワードと予約語がここから始まる */

     %union{                    /* これはデータの共用体 */
         char   name[128];      /* 名前                 */
     }
     /*------------- 予約語 ------------------*/

     %token PERIOD
     %token NEWLINE
     %token POSITIONAL
     %token VERB
     %token ADVERB
     %token PROPER_NOUN
     %token NOUN
     %token DECLARATIVE
     %token CONDITIONAL

     %type  <name> declarative
     %type  <name> verb_phrase
     %type  <name> noun_phrase
     %type  <name> position_phrase
     %type  <name> adverb
     %type  <name> POSITIONAL VERB ADVERB PROPER_NOUN
     %type  <name> NOUN DECLARATIVE CONDITIONAL

     %%
     sentence_list : sentence
                   | sentence_list NEWLINE sentence
                   ;

     sentence : verb_phrase noun_phrase position_phrase
                adverb period
                {
                  printf("I understand that sentence.\n");
                  printf("VP = %s \n",$1);
                  printf("NP = %s \n",$2);
                  printf("PP = %s \n",$3);
                  printf("AD = %s \n",$4);
                }
              | { yyerror("That's a strange sentence!");  }
              ;
     position_phrase : POSITIONAL  declarative PROPER_NOUN
                       {
                         sprintf($$,"%s %s %s",$1,$2,$3);
                       }
                     | /* 空 */ { strcpy($$,""); }
                     ;

     verb_phrase : VERB { strcpy($$,$1); strcat($$," "); }
                 | adverb VERB
                   {
                     sprintf($$,"%s %s",$1,$2);
                   }
                 ;
     adverb : ADVERB      { strcpy($$,$1); }
            | /* 空 */    { strcpy($$,""); }
            ;
     noun_phrase : DECLARATIVE NOUN
                   {
                     sprintf($$,"%s %s",$1,$2);
                   }
                 | CONDITIONAL declarative NOUN
                   {
                     sprintf($$,"%s %s %s",$1,$2,$3);
                   }
                 | NOUN { strcpy($$,$1); strcat($$," "); }
                 ;
     declarative : DECLARATIVE { strcpy($$,$1); }
                 | /* 空 */    { strcpy($$,""); }
                 ;
     period : /* 空 */
            | PERIOD
            ;

     %%
     /* main()およびyyerror()関数を提供する */

     void main(int argc, char **argv)
     {
       yyparse();       /* ファイルをパースする */
     }
     int yyerror(char *message)
     {
       extern FILE *yyout;

       fprintf(yyout,"\nError at line %5d.  (%s) \n",
                          yylexlinenum,message);
     }

   以下はFlexのファイルです。 文字列が渡される方法に注意してください。
これは最適化された方法ではありませんが、 最も理解しやすい方法です。

     %{
     #include <stdio.h>
     #include <string.h>
     #include "y.tab.h"      /* これはBisonにより生成される */
     #define TRUE  1
     #define FALSE 0
     #define copy_and_return(token_type) \
              { \
                  strcpy(yylval.name,yytext);\
                  return(token_type); \
              }

     int yylexlinenum = 0;  /* 行数カウント用 */
     %}
     %%
        /* 字句解析ルールがここから始まる */

     MEN|WOMEN|STOCKS|TREES      copy_and_return(NOUN)
     MISTAKES|GNUS|EMPLOYEES     copy_and_return(NOUN)
     LOSERS|USERS|CARS|WINDOWS   copy_and_return(NOUN)
     DATABASE|NETWORK|FSF|GNU    copy_and_return(PROPER_NOUN)
     COMPANY|HOUSE|OFFICE|LPF    copy_and_return(PROPER_NOUN)
     THE|THIS|THAT|THOSE         copy_and_return(DECLARATIVE)

     ALL|FIRST|LAST              copy_and_return(CONDITIONAL)
     FIND|SEARCH|SORT|ERASE|KILL copy_and_return(VERB)
     ADD|REMOVE|DELETE|PRINT     copy_and_return(VERB)

     QUICKLY|SLOWLY|CAREFULLY    copy_and_return(ADVERB)
     IN|AT|ON|AROUND|INSIDE|ON   copy_and_return(POSITIONAL)

     "."                         return(PERIOD);
     "\n"                        yylexlinenum++; return(NEWLINE);
     .
     %%

これらのファイルは、 以下を実行することでコンパイルできます。

     % bison -d front.y
     % flex -I front.lex
     % cc -o front alloca.c front.tab.c lex.yy.c

または、 この例のソースが手元にあれば、
`examples'サブディレクトリにおいて`make
front'を実行することでもコンパイルできます。

   *注：*_Bisonパーサは`alloca.c'というファイルを必要とします。
このファイルはexamplesサブディレクトリにあります。
Bisonの代わりに`yacc'を使うのであれば、 このファイルは必要ありません。_


File: flex-ja.info,  Node: Notes on the Implementation,  Prev: The Implementation,  Up: Another Example of Flex and Bison

4.5.3 実装に関する注
--------------------

以下に実装に関する注を示します。

   * `YYSTYPE' と `yylval'
     `yylval'がFlexからアクセスされる方法に注目してください。
     Bison文法においてパース・ツリーの上位にデータを渡す方法については、
     `Bison'のマニュアルに説明されていますが、
     Flexに対しては何の影響も持ちません。
     整数値、浮動小数点数値、および他の任意の型のデータも同様の方法で返すことができます。

   * トークン値の返却
     この例では、
     トークンの_型_と値の両方がBisonからアクセスできるように、
     トークンの値と文字列の値の両方がBisonに返されていることに注意してください。

   * BisonとFlex
     BisonとFlexがいかにうまく調和しているかに注目してください。
     データを交換するためのコード以外に、
     インターフェイスのためのコードは一切ありません。
     Bisonは`yylex()'を呼び出し、
     スキャナがトークン定義を提供しています。


File: flex-ja.info,  Node: Flex and C++ (Flex 2.5),  Prev: Another Example of Flex and Bison,  Up: Interfacing to Flex

4.6 FlexとC++（Flex 2.5の補足情報）
===================================

4.7 FlexとC++（Flex 2.5の補足情報）
===================================

Flex 2.5では、 Flexに対するC++インターフェイスが提供されています。

   FlexのC++インターフェイスを使うためには、
Flex実行時に`-+'オプションを指定するか、
スキャナ定義ファイルの中で`%option c++'を指定する必要があります。
これにより、
C++のスキャナ・クラスを実装する`lex.yy.cc'というファイルが生成されます。

   `lex.yy.cc'は、 Flexが提供する`FlexLexer.h'をインクルードします。
この`FlexLexer.h'の中に、
C++スキャナ・クラスの実装に利用される２つのC++クラス
（`FlexLexer'と`yyFlexLexer'） が定義されています。

`FlexLexer'は、
C++スキャナ・クラスが実装すべきインターフェイスを構成する抽象仮想関数を定義するクラスです。

   `FlexLexer'の持つメンバを以下に示します。

    `char* yytext'
          最後に認識された文字列（トークン）を保持します。

    `int yyleng'
          最後に認識された文字列（トークン）の長さを保持します。

    `int yylineno'
          `%option yylineno'が指定されている場合は、
          入力された行数を保持します。 それ以外の場合は、
          固定値1を持ちます。

    `int yy_flex_debug'
          この値がゼロ以外の場合、 C++スキャナはデバッグ出力を行います。

   次に、 `FlexLexer'の持つメンバ関数のうち、
抽象仮想関数ではないものを以下に示します。

    `const char* YYText()'
          メンバ`yytext'の値を返します。

    `int YYLeng()'
          メンバ`yyleng'の値を返します。

    `int yylex(istream* NEW_IN, ostream* NEW_OUT = 0)'
          NEW_INとNEW_OUTを引数に指定して、
          メンバ関数`switch_streams()'を呼び出した後、 メンバ関数`int
          yylex(void)'を呼び出します。

    `int lineno() const'
          メンバ`yylineno'の値を返します。

    `int debug() const'
          メンバ`yy_flex_debug'の値を返します。

    `void set_debug(int FLAG)'
          FLAGをメンバ`yy_flex_debug'に代入します。

   次に、 `FlexLexer'の持つ抽象仮想メンバ関数を列挙します。

     void yy_switch_to_buffer(struct yy_buffer_state* new_buffer)
     struct yy_buffer_state* yy_create_buffer(istream* s, int size)
     void yy_delete_buffer(struct yy_buffer_state* b)
     void yyrestart(istream* s)
     int yylex()
     void switch_streams(istream* new_in = 0, ostream* new_out = 0)

   最初の５つのメンバ関数は、
FlexのCインターフェイスにおける同名の関数と同等の機能を実現します。
Cインターフェイスでは、 `FILE*'となっていた引数の型が、
`istream*'となっている点に注意してください。
最後の`switch_streams()'は、 入出力ストリームの切り替えを行います。
これらの抽象仮想メンバ関数の定義は、
サブクラス`yyFlexLexer'において与えられ、
そのコードは`lex.yy.cc'の中に生成されます。

`yyFlexLexer'は、 `FlexLexer'のサブクラスです。 デフォルトの状態では、
`yyFlexLexer'のインスタンスを生成して、
`yylex()'メンバ関数を呼び出すことによって、
スキャナの処理が実行されます。 以下に例を示します。

     int main( int /* argc */, char** /* argv */ )
         {
         FlexLexer* lexer = new yyFlexLexer;
         while(lexer->yylex() != 0)
             ;
         return 0;
         }

   これは、 Cインターフェイスにおける、 以下のコードに対応します。

     int main( int /* argc */, char** /* argv */ )
         {
         yylex();
         return 0;
         }

   スキャナ定義ファイルの中に`%option yyclass="CLASSNAME"'を指定すると、
`lex.yy.cc'に`CLASSNAME::yylex()'が生成されます。
クラスCLASSNAMEを`yyFlexLexer'のサブクラスとして定義することによって、
CLASSNAMEのインスタンスを使ってスキャン処理を実行することができます。
クラスCLASSNAMEを定義する際、 以下に示す、
`yyFlexLexer'の持つ`protected'メンバ関数を再定義することによって、
スキャナの振る舞いを変更することができます。

    `int LexerInput(char* BUF, int MAX_SIZE)'
          これを再定義することによって、
          スキャナの入力処理を変更することができます。
          最大MAX_SIZEバイトの文字を入力してBUFの指す領域にセットし、
          実際に入力したバイト数を戻り値とします。
          入力を対話的に扱う場合と扱わない場合で、
          処理内容を変更する必要がある場合は、 `#ifdef
          YY_INTERACTIVE'を使います。

    `void LexerOutput(const char* BUF, int SIZE)'
          これを再定義することによって、
          スキャナの出力処理を変更することができます。
          BUFの指す領域にあるSIZEバイトの文字を出力します。

    `void LexerError(const char* MSG)'
          これを再定義することによって、
          エラー・メッセージの出力処理を変更することができます。
          エラー・メッセージは、 引数MSGで渡されます。

スキャン処理に関わるすべてのコンテキスト情報は、
`yyFlexLexer'のインスタンスの内部に閉じています。 このことは、
C++スキャナ・クラスを使うことによって、
再入可能なスキャナを生成することが可能であることを意味しています。

   複数のC++スキャナ・クラスを生成して、
１つの実行プログラムにリンクすることも可能です。 これを行うには、
Flex起動時に`-PPREFIX'オプションを指定するか、
スキャナ定義ファイルの中に`%option
prefix="PREFIX"'を指定することによって、
`yyFlexLexer'の名前を`PREFIXFlexLexer'に変更します。
`PREFIXFlexLexer'クラスを使うソース・ファイルの中では、
以下のようにして`FlexLexer.h'をインクルードすることによって、
`PREFIXFlexLexer' （実際には`yyFlexLexer'）
の定義を参照する必要があります。

     #undef yyFlexLexer
     #define yyFlexLexer PREFIXFlexLexer
     #include <FlexLexer.h>


File: flex-ja.info,  Node: Other Flex Features,  Next: Optimization,  Prev: Interfacing to Flex,  Up: Top

5 Flexの他の特徴
****************

     ここでは、
     Lexが提供していない機能や一般にはあまり使われない機能を説明します。
     Flexはほぼ100パーセントLex互換ですが、
     Lexよりも後に実装されたため、 性能的により優れており、 また、
     広範な用途に使えるスキャナをより簡単に作成することができるよう、
     特別な機能を提供しています。

========================================================================

* Menu:

* Case Insensitive Scanners::   大文字・小文字を区別するスキャナ
* Interactive Scanners::        ユーザから入力を受け取るスキャナ
* Table Compression and Scanner Speed::  テーブル圧縮とスキャナのスピード
* Translation Tables::          文字をグループ化する別の方法
* Multiple Input Buffers::      複数の入力ストリームを受け付ける方法
* End-Of-File Rules::           EOFを処理するための特殊なルール
========================================================================


File: flex-ja.info,  Node: Case Insensitive Scanners,  Next: Interactive Scanners,  Prev: Other Flex Features,  Up: Other Flex Features

5.1 大文字・小文字を区別しないスキャナ
======================================

多くの言語は、
その識別子において大文字・小文字を区別しません（Pascal、BASIC、FORTRAN等）。
Lexにも、
大文字・小文字を区別しないスキャナを指定するための方法がありますが、
それらは概して美しくなく、 理解するのも困難です。
個々の文字を置き換えてくれる定義を、
長いリストにして作成することも可能ですし、
すべての識別子を受け付ける１つのルールを作成し、
そのルールにおいて大文字・小文字を変換してから、
トークンの種類を返すようにすることも可能です。 以下のコードは、
この２つの方法を示すものです。
定義を使うのであれば、以下のようになります。

     A [aA]
     B [bB]
      ...
     Z [zZ]
     %%
     {B}{E}{G}{I}{N}      return(BEGIN_SYM);
     {E}{N}{D}            return(END_SYM);

これに似た操作をサブルーチンで実行するのであれば、 以下のようにします。

     ALPHA      [a-zA-Z]
     NUM        [0-9]
     ALPHANUM   {ALPHA}|{NUM}
     %%
     {ALPHA}{ALPHANUM}*     return(convert_and_lookup(yytext));

もっともこれは、 関数呼び出しの必要があるため、 効率が悪くなります
（Flexでは、 パターンの複雑さは大した影響をもたらしません）。

ほかにもこれと同じことを行う方法がありますが、
いずれもエレガントではありません。

========================================================================

* Menu:

* The -i Switch::               入力において大文字・小文字を無視する方法
========================================================================


File: flex-ja.info,  Node: The -i Switch,  Prev: Case Insensitive Scanners,  Up: Case Insensitive Scanners

5.1.1 `-i'オプション
--------------------

Flexは、 この問題を簡単に解決するための方法を提供しています。
コマンドラインで`-i'オプションを使うことによって、
入力情報の大文字・小文字を区別しないスキャナを生成するよう、
Flexに対して通知することができます。 つまり、
Flexでは上記のようなテクニックを使う必要がないということを意味しています。
例えば、

     %%
     begin        return(BEGIN_SYM);
     end          return(END_SYM);

は、 `-i'オプションを使うことによって、
`BEGIN'、`begin'、`BeGiN'、およびこれ以外のすべての大文字・小文字の組み合わせにマッチします。
これは、 Lexにおいて同様のことを行うための方法よりも、
はるかに簡単です。

   `-i'オプションには１つ注意すべき点があります。 それは、
スキャナが大文字・小文字を区別しないだけで、
その_変換まではしてくれない_ということです。 つまり、
Pascalにおいてシンボル名をハッシュしたいような場合、
自分でシンボル名を大文字または小文字に変換しなければならないことを意味しています。
そうしないと、 `FOO'と`foo'は異なるものとして扱われます。 これは、
シンボルを保存するルーチンの中で対処することもできますし、
`YY_USER_ACTION'を使うことによって対処することもできます。
これを実現する方法の例については、 *Note Flex and
C::における`YY_USER_ACTION'の説明を参照してください。


File: flex-ja.info,  Node: Interactive Scanners,  Next: Table Compression and Scanner Speed,  Prev: Case Insensitive Scanners,  Up: Other Flex Features

5.2 `-I'オプション：対話型スキャナ
==================================

Flexの問題として、 どのルールを適用するかを決定する前に、
入力情報中の次の１文字を先読みする必要があるということがあります。
対話的ではない使い方をする場合には問題になりませんが、
Flexを使ってユーザから直接入力文字を受け取るような場合には、
問題になることがあります。

   このような場合を２つ挙げると、 １つはシェルとやりとりする場合、
もう１つはデータベースのフロント・エンドとやりとりする場合です。
通常のアクションは、 改行が入力の終わりを表すというもので、
改行自身は一種の「中身のない文」として受け付けるのが望ましいのですが、
通常のFlexスキャナではこれは可能ではありません。
Flexが常に先読みをするという事実は、
改行が認識されるためにはユーザが次の行を入力しなければならないということを意味しています
（すなわち、 単一の改行は、 それだけでは認識されず、
他の文字が入力される必要があるということです）。
これはシェル上ではまったく望ましくありません。

   Flexにはこれを回避する方法があります。
コマンドラインで`-I'オプションを使うと、 Flexは、
必要な場合にしか先読みをしない特別な_対話型_スキャナを生成します。
この種のスキャナは、 ユーザからの入力を直接受け取るのに適していますが、
若干の性能低下を引き起こすかもしれません。

   *注：*`-I'オプションは、
`-f'、`-F'、`-Cf'、または`-CF'フラグと一緒に使うことはできません。
つまり、 先読みができないことから来る性能低下に加えて、
パーサも性能向上のために最適化することができないということを意味しています。

   `-I'オプションに関連するマイナス面は、 通常はきわめて小さいので、
入力情報がどこから来るのか確かではなく、
性能向上のための最適化を施す可能性を諦めても構わないのであれば、
コマンドラインにおいて`-I'オプションを使う方が良いでしょう。


File: flex-ja.info,  Node: Table Compression and Scanner Speed,  Next: Translation Tables,  Prev: Interactive Scanners,  Up: Other Flex Features

5.3 テーブルの圧縮とスキャナのスピード
======================================

テーブルの圧縮とスピードの領域では、
FlexはLexの能力をはるかに上回っています。 Flexは、
使われるオプションに応じて、 Lexよりもはるかに高速なテーブル、
あるいは、 はるかに小さいテーブルを生成することができます。 この節では、
利用可能なオプションと各オプションがスピードにもたらす影響について説明します。
一般的には、 テーブルが圧縮されるほど、 そのスピードは遅くなります。
Flexでは、 こうしたオプションをコマンドラインで指定します。
オプションは以下のとおりです。(1)

    `-fまたは-Cf'
          このオプションは、 Flexが"フル"・テーブル（"full"
          table）を生成すべきであることを指定します。
          このテーブルはまったく圧縮されず、 サイズが大きくなりますが、
          スピードは速くなります。 このオプションが指定された場合は、
          アクションの部分に`REJECT'を使うことはできない点に注意してください。

          注：`-f'フラグと`-F'フラグは、
          Flexが生成するテーブルにおいて相違をもたらします。
          `-f'フラグは*フル*・テーブル（*full* table）を生成し、
          `-F'フラグは*ファスト*・テーブル（*fast* table）を生成します。
          ファスト・テーブルとは、
          スピードを最大限にするよう最適化されたテーブル形式であり、
          一方、 フル・テーブルには最適化は一切施されません。
          もたらされる結果はよく似ていますが、
          テーブルのサイズは大きく異なるものになる可能性があります。

    `-Fまたは-CF'
          このオプションは"ファスト"・テーブル（"fast"
          table）形式を用いてテーブルを生成するようFlexに通知します。
          一般的には、
          このテーブルのスピードは先に説明したフル・テーブル（full
          table）とほとんど同じですが、 使われるパターンに応じて、
          そのサイズは小さくも大きくもなる可能性があります。
          原則として、
          すべての識別子をキャッチするルールのほかにキーワードの一覧も持つファイルに対しては、
          `-f'オプションを使うべきです。 例えば、

               ALPHA     [a-zA-Z]
               NUM       [0-9]
               ALPHANUM  {ALPHA}|{NUM}
               %%
               begin                  return(BEGIN_SYM);
                 ...  RULES AND ACTIONS ...
               end                    return(END_SYM);
               {ALPHA}{ALPHANUM}* return(IDENTIFIER);

          は`-f'フラグを使って処理すべきであり、

               {ALPHA}{ALPHANUM}* {ECHO;
                                   return(lookup(yytext));}

          は`-F'フラグを使って処理すべきです。
          これらのオプションが指定されている場合は、
          アクションの部分に`REJECT'を使うことができない点に注意してください。

    `-Ce'
          このオプションを使うと、 性能にはわずかしか影響を及ぼさずに、
          テーブルのサイズをかなり小さくすることができます。
          `-Ce'が使われると、 Flexは"同等クラス"（"equivalence
          classes"）を作成します。 同等クラスとは、
          同一の方法で使われる文字のグループです。 例えば、
          使われる数字が集合`[0-9]'の範囲に限定されるのであれば、
          0から9までの数は同等クラスの中に置かれることになります。

    `-Cfe,-CFe'
          同等クラスを持つファスト・テーブルです。
          このオプションによって生成されたスキャナもまた高速であり、
          かつ、
          `-Cf'あるいは`-CF'を指定して生成されたスキャナと比較して、
          サイズもはるかに小さくなる可能性があります。 サイズ、
          またはスピードの一方が他方に比べてはるかに重要であるということがないのであれば、
          これは良い組み合わせです。

    `-Cm'
          Flexに対して"メタ同等クラス"（"meta-equivalence
          classes"）を使うよう通知します。 これは、
          一緒に使われることが多い文字の集合、 または
          （同等クラスが使われている場合には） 同等クラスです。
          同等クラスを使う場合よりも性能はさらに悪くなりますが、
          これは多くの場合、
          テーブル・サイズを小さくするのに非常に効果的な方法です。

    `-Cem'
          デフォルトのテーブル圧縮です。
          このオプションで生成されるスキャナは、
          Flexが生成するスキャナの中で事実上最も小さく、 かつ、
          最も性能の劣るものになります。

    `-C'
          `-C'オプション単体では、
          同等クラスやメタ同等クラスを使わずにテーブルを圧縮するよう、
          Flexに対して通知します。

   *注：*`-CXX'オプションは、
コマンドライン上には１つだけ指定すべきです。 というのは、
このうち最後に見つかったオプションだけが実際の効果を持つからです。
したがって、

     flex -Cf -Cem foo.l

は、 Flexに`-Cem'オプションを使わせることになります。

   Flexのデフォルトの動作は、
コマンドライン上で`-Cem'オプションを使った場合に相当します。
この動作では圧縮を最大限に行うことになり、
一般的には最も遅いスキャナが生成されることになります。
こうした小さなテーブルはより速く生成され、
コンパイルもより速く実行されるので、 デフォルトは、
開発段階では非常に便利です。 スキャナのデバッグが終了した後は、
より高速な （そして通常はよりサイズの大きい）
スキャナを作成することができます。

   ---------- Footnotes ----------

   (1) 訳注：Flex 2.5では、 ここに列挙されているもの以外に、
`-Ca'オプションをサポートしています。 これについては、 *Note Command
Line Switches (Flex 2.5)::を参照してください。


File: flex-ja.info,  Node: Translation Tables,  Next: Multiple Input Buffers,  Prev: Table Compression and Scanner Speed,  Up: Other Flex Features

5.4 翻訳テーブル
================

翻訳テーブルは、 文字をグループにマップするのに使われます。
このテーブルはLexの持つ機能の１つですが、 POSIXでは定義されていません。
Flexでも翻訳テーブルを使うことはできますが、 サポート対象外の機能です。
Flexにおいては翻訳テーブルは不要です。 というのは、
Flexには`-i'オプションによる同等クラスというものがあり、
これが翻訳テーブルと同等の機能を実現しているからです （*note
`-i'オプション: The -i Switch.）。 翻訳テーブルの機能は、
互換性のためだけに存在する余分な機能です。
翻訳テーブルを使うことは_お勧めできません_。
翻訳テーブルを使いたいのであれば、
定義ファイルの先頭の定義セクションにおいて定義しなければなりません。

翻訳テーブルの一般的な形式は以下のとおりです。

     %t
     1 ABCDEFGHIJKLMNOPQRSTUVWXYZ
     2 0123456789
     %t
     %%

これは、 `A'から`Z'までの任意の文字がルールの中で使われている場合、
そのパターンは`A'から`Z'までの_どの_文字にもマッチするということを意味しています。
したがって、 `A(BC)'と`X(YZ)'はまったく同一であるということになります。


File: flex-ja.info,  Node: Multiple Input Buffers,  Next: End-Of-File Rules,  Prev: Translation Tables,  Up: Other Flex Features

5.5 複数の入力バッファ
======================

スキャナが、
複数のファイルからの入力を処理することができるということが必要になる状況は、
たくさんあります。 例えば、 多くのPascalの実装では、
コンパイル時に複数のファイルを取り込むことを許していますし、 Cでは、
スキャナもしくはプリプロセッサが`#include'文を処理できなければなりません。
このことが意味しているのは、 スキャナは、
カレントなスキャン処理の"コンテキスト"を保存してから新しいコンテキストに変更し、
その後で、
以前の状態と完全に一致する状態に復帰することができなければならないということです。

   Flexスキャナは、
スキャン処理のコンテキストを維持するために余分の処理が必要になるような、
大きな入力バッファを使っています。 しかしFlexは、
複数の入力バッファの作成、切り替え、削除が非常に簡単に行えるような特別な機能を提供しています。

========================================================================

* Menu:

* Buffer Manipulation::         バッファ操作関数
* Buffer Manipulation (Flex 2.5)::  同上（Flex 2.5の補足情報）
* Example of Multiple Buffers::  複数バッファを使う実例
========================================================================


File: flex-ja.info,  Node: Buffer Manipulation,  Next: Buffer Manipulation (Flex 2.5),  Prev: Multiple Input Buffers,  Up: Multiple Input Buffers

5.5.1 バッファを操作する関数
----------------------------

Flexは、 複数の入力バッファを取り扱うために、
以下のような関数やマクロを提供しています。

    `YY_BUFFER_STATE yy_create_buffer( FILE *file, int size)'
          `file'で指定されるファイルのために、
          `size'で指定される数の文字を格納するのに十分な大きさのバッファを作成します。
          この関数は、 後に複数のバッファ間の切り替え、
          または新規に作成されたバッファの削除に使うことのできるハンドルを返します。

    `YY_BUF_SIZE'
          デフォルトのバッファ・サイズを定義するマクロです。
          `yy_create_buffer()'に渡すべきサイズが分からない場合に、
          これを使うことができます。

    `void yy_switch_to_buffer( YY_BUFFER_STATE new_buffer)'
          バッファを切り替えます。 次に読み込まれるトークンは、
          `new_buffer'で指定されるバッファから取られます。
          ファイルの終端（EOF）に達するか、
          次に`yy_switch_to_buffer()'が呼び出されるまで、
          `new_buffer'からトークンが読み込まれます。
          `new_buffer'がEOFに達すると、
          新しいバッファに切り替えることができます。

    `void yy_delete_buffer( YY_BUFFER_STATE buffer )'
          `buffer'で指定されるバッファを削除し、
          それに割り当てられたメモリを解放します。

    `YY_CURRENT_BUFFER'
          使用中のカレントなバッファを返すマクロです。


上記が、
複数の入力バッファを取り扱うのに必要なすべての機能を提供しています。


File: flex-ja.info,  Node: Buffer Manipulation (Flex 2.5),  Next: Example of Multiple Buffers,  Prev: Buffer Manipulation,  Up: Multiple Input Buffers

5.5.2 バッファを操作する関数（Flex 2.5の補足情報）
--------------------------------------------------

5.5.3 バッファを操作する関数（Flex 2.5の補足情報）
--------------------------------------------------

Flex 2.5では、 以下のバッファ操作関数もサポートされています。

    `YY_BUFFER_STATE yy_new_buffer(FILE *file, int size)'
          `yy_create_buffer'の別名です。

    `void yy_flush_buffer(YY_BUFFER_STATE buffer)'
          引数で指定されたバッファの内容を破棄し、
          バッファの先頭２バイトに`YY_END_OF_BUFFER_CHAR'（`\0'）をセットします。

    `YY_FLUSH_BUFFER'
          引数にカレント・バッファを指定して`yy_flush_buffer()'を呼び出すよう定義されたマクロです。

   さらに、 Flex 2.5では、
メモリ上の文字列を操作するための入力バッファを作成する関数が提供されています。
いずれも、
新しく作成された入力バッファに対応する`YY_BUFFER_STATE'型のハンドルを戻り値とします。
入力バッファを使い終わったら、
このハンドルを引数に指定して`yy_delete_buffer()'を呼び出す必要があります。

    `YY_BUFFER_STATE yy_scan_string(const char *STR)'
          NULL文字で終端する文字列をスキャンするための入力バッファを作成します。
          実際には、 引数STRに指定された文字列の長さを調べて、
          次に説明する`yy_scan_bytes()'を呼び出し、
          その戻り値を返します。

    `YY_BUFFER_STATE yy_scan_bytes(const char *BYTES, int LEN)'
          BYTESから始まるLENバイトのメモリ領域をスキャンするためのバッファを作成します。
          実際には、 次に説明する`yy_scan_buffer()'を呼び出し、
          その戻り値を返します。

          `yy_scan_buffer()'の第１引数には、 BYTESではなく、
          この関数の内部で獲得された`LEN +
          2'バイトの領域へのポインタが渡される点に注意してください。
          `yy_scan_buffer()'が呼び出される前に、
          BYTESから始まるLENバイトのデータが、
          新たに獲得した領域にコピーされ、 さらに、
          末尾の2バイトに`YY_END_OF_BUFFER_CHAR'（`\0'）がセットされます。

    `YY_BUFFER_STATE yy_scan_buffer(char *BASE, yy_size_t SIZE)'
          BASEから始まるSIZEバイトのメモリ領域をスキャンするためのバッファを作成します。
          メモリ領域の末尾2バイトは、
          `YY_END_OF_BUFFER_CHAR'（`\0'）でなければなりません。
          この末尾2バイトは、 スキャン処理の対象になりません。

          引数で指定されたメモリ領域の末尾2バイトが`YY_END_OF_BUFFER_CHAR'でない場合は、
          `yy_scan_buffer()'はバッファを作成せず、
          NULLポインタを返します。


File: flex-ja.info,  Node: Example of Multiple Buffers,  Prev: Buffer Manipulation (Flex 2.5),  Up: Multiple Input Buffers

5.5.4 複数バッファを使う実例
----------------------------

複数のバッファを使うというアイデアを理解するための手助けとして、
インクルードすべきファイルを探すCのスキャナの一部を以下に示します。
これはCの`#include'のうち、 引用符で囲まれた文字列のみを受け付けます。
例えば、

     #include"file1.c"
     #include "file2.c"
     #include " file3.c"

は、 最後の例のファイル名が空白を含むことになりますが、
いずれも正当な入力です。 ここでの例はまた、
EOFルールとスタート状態の使用法を実演する良い例でもあります。

     /*
      * eof_rules.lex : 複数バッファ、EOFルール、スタート状態
      *                 の使い方の例
      */

     %{

     #define MAX_NEST 10
     YY_BUFFER_STATE include_stack[MAX_NEST];
     int             include_count = -1;

     %}

     %x INCLUDE
     %%

     ^"#include"[ \t]*\"  BEGIN(INCLUDE);
     <INCLUDE>\"          BEGIN(INITIAL);
     <INCLUDE>[^\"]+ {  /* インクルード・ファイルの名前を獲得する */
             if ( include_count >= MAX_NEST){
                fprintf( stderr, "Too many include files" );
                exit( 1 );
             }

             include_stack[++include_count] = YY_CURRENT_BUFFER;

             yyin = fopen( yytext, "r" );
             if ( ! yyin ){
                fprintf(stderr,"Unable to open \"%s\"\n",yytext);
                exit( 1 );
             }

             yy_switch_to_buffer(
                        yy_create_buffer(yyin,YY_BUF_SIZE));
             BEGIN(INITIAL);
           }
     <INCLUDE><<EOF>>  {
             fprintf( stderr, "EOF in include" );
             yyterminate();
           }
     <<EOF>> {
             if ( include_count <= 0 ){
               yyterminate();
             } else {
               yy_delete_buffer(include_stack[include_count--] );
               yy_switch_to_buffer(include_stack[include_count] );
               BEGIN(INCLUDE);
             }
           }
     [a-z]+             ECHO;
     .|\n               ECHO;

スタート状態を使ってファイル名のスキャナを生成する方法や、
バッファの切り替えを発生させる方法に注目してください。
ほかに注目すべき重要な点は、 `<<EOF>>'を取り扱うセクション、 および、
古いバッファに復帰する際に`BEGIN'を使って確実に正しい状態に遷移するようにする点です。
これを怠ると、 状態は`INITIAL'にリセットされ、
`#include'の最後の`"'が`ECHO'されてしまいます。

   *注：*<<EOF>>機能は次の節で説明します。 <<EOF>>が何であり、
何を行うものかという点に関する詳細な議論については、 *Note Start
States::。


File: flex-ja.info,  Node: End-Of-File Rules,  Prev: Multiple Input Buffers,  Up: Other Flex Features

5.6 ファイルの終端（End-Of-File）ルール
=======================================

ファイルの終端（EOF）が見つかると、 Flexは`yywrap()'を呼び出し、
ほかに処理できる状態のファイルが存在するか調べます。
`yywrap()'が0以外の値を返すと、
もうこれ以上ファイルはないということを意味し、 したがって、
これがまさに入力の最後であるということになります。 状況によっては、
この時点でさらに処理を行う必要のある場合があります （例えば、
入力のために別のファイルをセットアップしたいということがあるかもしれません）。
このような場合のために、 Flexは`<<EOF>>'演算子を提供しています。
これを使うことで、
EOFが見つかった時に実行すべきことを定義することができます。 *Note
複数バッファを使う実例: Example of Multiple Buffers。
EOFルールを使って、
終わりのないコメントやインクルードされているファイルの終端を見つける、
良い例が示されています。

   `<<EOF>>'演算子の使用にはいくつか制限があります。
制限事項を以下に示します。

   * パターンと一緒に使用することは不可

     EOFルールは、 スタート状態とのみ一緒に使うことができます。
     スタート状態が指定されていない場合 （すなわち、
     `<<EOF>>'ルールが状態により制限されない場合）、
     `<<EOF>>'が使われていないすべての （排他的スタート状態を含む）
     状態が影響を受けます。 つまり、

          "foo"<<EOF>>

     が不当である一方で、

          <<EOF>>           /* <<EOF>>が使われていないすべての */
                            /* 状態におけるEOF                 */
          <indent><<EOF>>   /* indent状態におけるEOF           */
          <comment><<EOF>>  /* コメント内のEOF                 */

     はすべて正当であることを意味しています。

   * アクションの終端

     １つ注意しなければならない点は、
     EOFルールは入力の最後で呼び出されるという点です。 したがって、
     EOFルールのアクションは、 (1) （`yy_switch_to_buffer()'、
     または`YY_NEW_FILE'を使って）新しい入力ストリームを確立する、 (2)
     （`return'文を使って）復帰する、 (3) （`yyterminate()'、
     または`exit()'を使って）スキャナの実行を終了させる、
     のいずれかを実行しなければなりません。

     *Note 複数バッファを使う実例: Example of Multiple Buffers。
     `yy_terminate()'と`yy_switch_to_buffer()'を使う例が示されています。
     また、 `yyterminate()'の説明については、 *Note Flex and
     C::を参照してください。


File: flex-ja.info,  Node: Optimization,  Next: More Examples,  Prev: Other Flex Features,  Up: Top

6 スキャナの最適化
******************

デバッグをしている間は、 スキャナの性能は通常それほど重要ではなく、
Flexのデフォルトの設定で十分です。 しかしデバッグ終了後は、 スピード、
またはサイズの面でスキャナを最適化したくなることもあるでしょう。
ここでは、
スキャナを最適化するのによく使われる手法をいくつか紹介します。

========================================================================

* Menu:

* Optimizing for Speed::        ファスト・スキャナを作るためのフラグ、
                                関連するトピック
* Optimizing for Size::         サイズの小さいスキャナの作り方
========================================================================


File: flex-ja.info,  Node: Optimizing for Speed,  Next: Optimizing for Size,  Prev: Optimization,  Up: Optimization

6.1 スピードの最適化
====================

多くのプログラムは、 字句解析の処理に多くの時間を費やします。
したがって、
スキャナの最適化はかなり大きな性能改善に結びつくことが多いのです。
Flexによるスキャナは、
Lexによるスキャナと比較するとかなり高速になる傾向がありますが、
特定の構成もしくはアクションによって、
性能に大きな影響を与えることができます。
注意すべき点は以下のとおりです。

  1. テーブルの圧縮
     どのような圧縮も結果的にスキャナを遅くします。 したがって、
     スピードのことが心配であるならば、
     常にコマンドラインで`-f'オプション、
     または`-F'オプションを使ってください。
     テーブルの圧縮とスピードに関連するオプションに関する詳細な議論については、
     *Note Table Compression and Scanner Speed::。

  2. REJECT
     スピードに対して最も大きな影響を及ぼします。
     これが使われると_すべて_のマッチ処理が遅くなります。 というのは、
     スキャナは、 マッチする前の状態に自身を復旧する必要があるからで、
     このようなことが必要ない場合と比較して、
     より多くの内部的な保守作業を行わなければならないからです。
     スピードが重要な場合には、 使わないようにしてください。

  3. バックトラッキング
     スキャナがあるテキストにマッチするために「逆行」しなければならないことを、
     バックトラッキングといいます。 これは、
     スキャナの性能に悪い影響を及ぼしますので、
     スピードが最も重要である場合には避けるべきです。
     圧縮されたテーブルは常にバックトラッキングを発生させるので、
     `-f'オプション、 または`-F'オプションを使わない場合は、
     ルールからバックトラッキングを削除しようとするのは時間の無駄です。
     スキャナからバックトラッキングを削除することに関する詳細な情報については、
     *Note Removing Backtracking::。

  4. 可変長後続コンテキスト（variable trailing context）
     可変長後続コンテキストとは、
     あるルールの先頭部分と後続部分の両方が固定長でないような場合を指します。
     性能の観点からは`REJECT'と同じくらい悪影響を及ぼすもので、
     可能な場合にはいつでも避けるべきです。 この例を示すと、
     以下のようになります。

          %%
          linux|hurd/(OS|"Operating system")

     これは、 以下のように分割すべきです。

          linux/OS|"Operating system"
          hurd/OS|"Operating system"

     こうすることによって、 問題は解消されます。

  5. 行の先頭を表す演算子
     `^'演算子は、 性能に不利な影響を及ぼします。
     スピードが最も重要な場合には、 使わないでください。

  6. yymore()
     `yymore'を使うと性能を低下させます。 スピードが最も重要な場合には、
     使わないでください。

  7. テキスト長
     スキャナの性能は、
     マッチするテキストの長さによっても影響を受けます。
     常に長い文字列にマッチするような場合には、
     スキャナは高速に実行されます。 というのは、
     `yytext'環境をセットアップする必要がないからです。
     スキャナの実行時間のほとんどは、
     内部の高速なマッチング・ループの中で費やされることになります。

  8. `NUL'
     Flexは、 `NUL'を含むトークンをマッチするのに時間がかかります。
     この場合には、
     _短い_テキストにマッチするようルールを記述するほうが良いでしょう。

========================================================================

* Menu:

* Removing Backtracking::       バックトラッキングの除去による性能の
                                飛躍的向上
========================================================================


File: flex-ja.info,  Node: Removing Backtracking,  Prev: Optimizing for Speed,  Up: Optimizing for Speed

6.1.1 バックトラッキングの削除
------------------------------

スキャナからバックトラッキングを削除することは、
スキャナの性能にかなりの影響をもたらします。 残念ながら、
バックトラッキングの削除はかなり複雑な作業になる可能性があります。
例えば、

     %%
     hurd     return(GNU_OS);
     hurdle   return(JUMP);
     hurdled  return(JUMPED);

では、 バックトラッキングが発生します。 スキャナが`hu'をマッチし、
次の文字が`r'ではない場合、
マッチされなかったテキストを`ECHO'するデフォルトのルールを使って`h'と`u'を処理するために、
スキャナはバックトラッキングを行わなければなりません。
同じことが`d'と`e'についても適用されます。 （これは、
何かにマッチするようスキャナが努力を継続するということが、
もはやできないからです。 この場合、
スキャナはデフォルトのルールを適用し、
`yyext'環境をリセットしなければなりませんが、
いずれも時間のかかる処理です。）

   コマンドライン・オプション`-b'を使うことで、
バックトラッキングを発生させている原因に関する情報を知ることができます。
これにより、
バックトラッキングに関する情報を含む`lex.backtrack'というファイルが生成されます。
上記の例の場合、 このファイルは以下のような情報を含みます。

     State #6 is non-accepting -
      associated rule line numbers:
             2       3       4
      out-transitions: [ r ]
      jam-transitions: EOF [ \000-q  s-\177 ]
     State #7 is non-accepting -
      associated rule line numbers:
             2       3       4
      out-transitions: [ d ]
      jam-transitions: EOF [ \000-c  e-\177 ]
     State #9 is non-accepting -
      associated rule line numbers:
             3       4
      out-transitions: [ e ]
      jam-transitions: EOF [ \000-d  f-\177 ]

     Compressed tables always backtrack.

バックトラッキング情報はセクションに分割され、
個々のセクションにおいて、
バックトラッキングを引き起こしている１つの状態のことが記述されています。
個々のセクションの最初の行から、 状態番号を知ることができます。
２行目からは、
記述ファイルの何行目が関連しているのかを知ることができます。
３行目からは、 バックトラッキングを発生させた文字を知ることができます。
よって、 最初のブロックからは、 文字`r'でバックトラッキングが発生し、
それは記述ファイルの２，３，４行目に関連していることを見てとることができます。
最後の行は、
圧縮されたテーブルは常にバックトラッキングを発生させるので、
テーブル圧縮を引き起こすようなコマンドライン・オプションを使う場合には、
バックトラッキングを削除しようとして時間を費やすべきではないことを思い出させるためのものです。

   バックトラッキングを削除するためには、
バックトラッキングが関与している状態をキャッチするルールを加える必要があります。
これは、
スキャナのスピードには_影響を与えない_ということに注意してください。
スキャナのスピードは、
ルールの数や複雑さとはまったくといえるほど無関係です。

   バックトラッキングを削除するためにルールを追加する方法は、
２種類あります。 第１の方法は、 以下のようなルールを追加することです。

     %%
     hurd     return(GNU_OS);
     hurdle   return(JUMP);
     hurdled  return(JUMPED);
     hu       return(OTHER);
     hur      return(OTHER);
     hurdl    return(OTHER);

別の方法として、
すべてをキャッチするようなルールを追加することもできます。

     %%
     hurd     return(GNU_OS);
     hurdle   return(JUMP);
     hurdled  return(JUMPED);
     [a-z]+   return(OTHER);

この第２の方法を適用できる場合は、 常にこれを使うべきです。
上記のどちらかと`-b'オプションを一緒に使うと、

     Compressed tables always backtrack.

というメッセージだけが出力されるようになります。 これは、
バックトラッキング状態が存在しないことを示唆しています。

   これに付随する問題の１つとして、
複雑なスキャナではバックトラッキング問題はカスケードする傾向があるので、
`lex.backtrack'内の情報が混乱をもたらすものになる可能性があります。
しかし、
バックトラッキングの原因は通常２、３個のルールにしぼることが可能なので、
バックトラック・データを調べようと努力するだけの_値打ちはあります_。


File: flex-ja.info,  Node: Optimizing for Size,  Prev: Optimizing for Speed,  Up: Optimization

6.2 サイズの最適化
==================

Flexは、 サイズの小さいスキャナよりも、
むしろ非常に高速なスキャナを作成することを目標としていますが、
いずれにしても、 作成されるテーブルのサイズはLexによるそれと比較しても、
通常はかなり小さいものになります。

   デフォルトでは、 Flexは可能な限りサイズの小さいスキャナを作成します。
これは、 コマンドラインで`-Cem'を使うのと同等です。
デフォルトを使うのであれば、
コマンドライン・オプションを気にする必要はありません。

   さらにテーブルのサイズを小さくするには、
より大きなテキスト・グループにマッチするルールを使い、
字句の値を認識するためにCのサブルーチンを使うのが最も良い方法です。
この良い例がコンパイラで、 以下のようなルールを与えることができます。

     %%
     begin    return(BEGINSYM);
     end      return(ENDSYM);
     program  return(PROGSYM);
         ...

あるいは、 以下のようにテーブル検索を使うことも可能です。

     [a-zA-Z][a-zA-Z0-9]*  return(lookup(yytext));

ここでは、 一般的なルールが指定されていて、
`lookup()'がテキストをキーワードにマッチさせ、
そのトークンが何であるかを示す整数値を返します。 これにより、
サイズのより小さいテーブルが生成されますが、
性能は悪くなる傾向があります。 また、
数が少なく複雑ではないルール集合については、
テーブル・サイズを縮小することの効果は、
シンボル・マッピング用の情報をプログラム中の他の領域に格納しなければならないという事実によって、
相殺されるかもしれません。 というのは、 シンボル・マッピング用の情報は、
Flexテーブルと比較して、
より多くのスペースを必要とする可能性があるからです。


File: flex-ja.info,  Node: More Examples,  Next: Flex and Lex,  Prev: Optimization,  Up: Top

7 Flexを使うその他の実例
************************

     ここでは、 Flexの使用例をさらにいくつか紹介します。 ここでの例も、
     必ずしも最適な実装ではありませんが、
     一般的なFlexの使い方を示してくれるはずです。

========================================================================

* Menu:

* Example-Counting Words::      wc風のユーティリティ
* Example-Pascal Lexical Scanner::  本物の言語をスキャンする実例
* Example-Jargon Converter::    専門用語ファイルのTexinfo形式への変換
========================================================================


File: flex-ja.info,  Node: Example-Counting Words,  Next: Example-Pascal Lexical Scanner,  Prev: More Examples,  Up: More Examples

7.1 単語数、文字数、行数のカウント
==================================

以下の定義は、
与えられたファイルの中の単語数、文字数、行数をカウントするのにFlexを使う方法を示す、
簡単な例です。 実際にFlexに関係のある部分は、
非常に少ないことに注意してください。 以下のコードのほとんどは、
コマンドライン・パラメータを処理したり、
カウントの合計を保持したりするものです。

     /*
      * wc.lex : wcのようなユーティリティを、
      *          Flexを使って作成する簡単な例
      */

     %{
     int  numchars = 0;
     int  numwords = 0;
     int  numlines = 0;
     int  totchars = 0;
     int  totwords = 0;
     int  totlines = 0;
     %}
     /*
      * ルールはここから始まる
      */

     %%

     [\n]        { numchars++;  numlines++;         }
     [^ \t\n]+   { numwords++;  numchars += yyleng; }
     .           { numchars++;                      }
     %%

     /*
      * 追加的なCコードがここから始まる。
      * ここで、すべての引数処理等を行うコードが提供される
      */
     void main(int argc, char **argv)
     {
       int  loop;
       int  lflag = 0; /* 行数をカウントする場合は1         */
       int  wflag = 0; /* 単語数をカウントする場合は1       */
       int  cflag = 0; /* 文字数をカウントする場合は1       */
       int  fflag = 0; /* ファイル名が指定されている場合は1 */
       for(loop=1; loop<argc; loop++){
          char *tmp = argv[loop];
          if(tmp[0] == '-'){
          switch(tmp[1]){
            case 'l':
               lflag = 1;
               break;
            case 'w':
               wflag = 1;
               break;
            case 'c':
               cflag = 1;
               break;
            default:
               fprintf(stderr,"unknown option -%c\n",tmp[1]);
          }
         } else {
           fflag = 1;
           numlines = numchars = numwords = 0;
           if((yyin = fopen(tmp,"rb")) != 0){
             (void) yylex();
             fclose(yyin);
             totwords += numwords;
             totchars += numchars;
             totlines += numlines;
             printf("file  : %25s :",tmp) ;
             if(lflag){
               fprintf(stdout,"lines %5d ",numlines);
             }
             if(cflag){
               fprintf(stdout,"characters %5d ",numchars);
             }
             if(wflag){
               fprintf(stdout,"words %5d ",numwords);
             }
             fprintf(stdout,"\n");
           }else{
             fprintf(stderr,"wc : file not found %s\n",tmp);
           }
         }
       }
       if(!fflag){
         fprintf(stderr,"usage : wc [-l -w -c] file [file...]\n");
         fprintf(stderr,"-l = count lines\n");
         fprintf(stderr,"-c = count characters\n");
         fprintf(stderr,"-w = count words\n");
         exit(1);
       }
       for(loop=0;loop<79; loop++){
         fprintf(stdout,"-");
       }
       fprintf(stdout,"\n");
       fprintf(stdout,"total : %25s  ","") ;
       if(lflag){
         fprintf(stdout,"lines %5d ",totlines);
       }
       if(cflag){
         fprintf(stdout,"characters %5d ",totchars);
       }
       if(wflag){
          fprintf(stdout,"words %5d ",totwords);
       }
       fprintf(stdout,"\n");
     }


File: flex-ja.info,  Node: Example-Pascal Lexical Scanner,  Next: Example-Jargon Converter,  Prev: Example-Counting Words,  Up: More Examples

7.2 Pascalのサブセット用の字句スキャナ
======================================

ここでは、 Pascalのような言語用の字句スキャナを作る方法を示します。
このスキャナ定義では、
個々のキーワードがルールとしてリストされています。 （一般的には、
すべてのキーワードをテーブルに格納してからテーブル検索を使う手法がよく見られますが、）
ここでの方法は、 キーワードと識別子とを区別するための方法としては、
一般的に最も簡単なものです。 また、
識別子用にただ１つのルールがあるという点に注意してください。
多くの場合、
このルールはシンボル・テーブルを管理するためのサブルーチンを呼び出します。

   もう１つ注意すべき点は、
`_FILE'と`_BEGIN'が先頭にアンダースコアを持つという点です。 Flex、
またはCで定義済みの名前は、
追加的な工夫なしでは使えないということを示すために、
このようにしてあります。 これよりももっと一般的に使われる手法は、
_すべて_のトークンの先頭もしくは末尾に何らかの文字列を付加するというもので、
こうすることによって問題は発生しなくなります。
`TOK'や`SYM'が一般的によく使われる拡張子です。

     /*
      * pascal.lex : PASCALスキャナの例
      */

     %{
     #include <stdio.h>
     #include "y.tab.h"
     int line_number = 0;
     void yyerror(char *message);

     %}

     %x COMMENT1 COMMENT2
     white_space       [ \t]*
     digit             [0-9]
     alpha             [A-Za-z_]
     alpha_num         ({alpha}|{digit})
     hex_digit         [0-9A-F]
     identifier        {alpha}{alpha_num}*
     unsigned_integer  {digit}+
     hex_integer       ${hex_digit}{hex_digit}*
     exponent          e[+-]?{digit}+
     i                 {unsigned_integer}
     real              ({i}\.{i}?|{i}?\.{i}){exponent}?
     string            \'([^'\n]|\'\')+\'
     bad_string        \'([^'\n]|\'\')+
     %%
     "{"                  BEGIN(COMMENT1);
     <COMMENT1>[^}\n]+
     <COMMENT1>\n            ++line_number;
     <COMMENT1><<EOF>>    yyerror("EOF in comment");
     <COMMENT1>"}"        BEGIN(INITIAL);
     "(*"                 BEGIN(COMMENT2);
     <COMMENT2>[^)*\n]+
     <COMMENT2>\n            ++line_number;
     <COMMENT2><<EOF>>    yyerror("EOF in comment");
     <COMMENT2>"*)"       BEGIN(INITIAL);
     <COMMENT2>[*)]
     /* FILEとBEGINは、FlexやCにおいては既に定義されているため
      * 使うことができない点に注意。これは、すべてのトークンの
      * 先頭にTOK_やその他の接頭辞を付加することによって、より
      * すっきりと克服することができる
      */

     and                  return(AND);
     array                return(ARRAY);
     begin                return(_BEGIN);
     case                 return(CASE);
     const                return(CONST);
     div                  return(DIV);
     do                   return(DO);
     downto               return(DOWNTO);
     else                 return(ELSE);
     end                  return(END);
     file                 return(_FILE);
     for                  return(FOR);
     function             return(FUNCTION);
     goto                 return(GOTO);
     if                   return(IF);
     in                   return(IN);
     label                return(LABEL);
     mod                  return(MOD);
     nil                  return(NIL);
     not                  return(NOT);
     of                   return(OF);
     packed               return(PACKED);
     procedure            return(PROCEDURE);
     program              return(PROGRAM);
     record               return(RECORD);
     repeat               return(REPEAT);
     set                  return(SET);
     then                 return(THEN);
     to                   return(TO);
     type                 return(TYPE);
     until                return(UNTIL);
     var                  return(VAR);
     while                return(WHILE);
     with                 return(WITH);

     "<="|"=<"            return(LEQ);
     "=>"|">="            return(GEQ);
     "<>"                 return(NEQ);
     "="                  return(EQ);

     ".."                 return(DOUBLEDOT);
     {unsigned_integer}   return(UNSIGNED_INTEGER);
     {real}               return(REAL);
     {hex_integer}        return(HEX_INTEGER);
     {string}             return{STRING};
     {bad_string}         yyerror("Unterminated string");
     {identifier}         return(IDENTIFIER);

     [*/+\-,^.;:()\[\]]   return(yytext[0]);

     {white_space}        /* 何もしない */
     \n                   line_number += 1;
     .                    yyerror("Illegal input");
     %%
     void yyerror(char *message)
     {
        fprintf(stderr,"Error: \"%s\" in line %d.  Token = %s\n",
                message,line_number,yytext);
        exit(1);
     }


File: flex-ja.info,  Node: Example-Jargon Converter,  Prev: Example-Pascal Lexical Scanner,  Up: More Examples

7.3 専門用語の変換
==================

ここでは、 スタート状態を使って、
Flexにより生成されるスキャナの内部に小規模のパーサを作る方法の例を示します。
このコードはThe New Hackers Dictionary （`prep.ai.mit.edu'、
およびその他の多くのインターネットFTPサイトから入手可能なテキスト形式のもの）
を入力として受け取り、
すぐに製版および印刷できる状態のTexinfoフォーマットのドキュメントに変換するものです。
このコードは`jargon2910.ascii'を使ってテスト済みです。

典型的な使い方は以下のとおりです。

     j2t < jargon > jargon.texi
     tex jargon.texi
     lpr -d jargon.dvi

このプログラムは、
使用に耐える`info'ファイルに変換可能なファイルは_作成しません_が、
こうした機能は大した困難もなく追加することが可能です。
この例は非常に長いものですが、 大して複雑でもないので、
尻込みしないで研究してみてください。

     /*
      * j2t.lex : スタート状態を利用（ひょっとして悪用！）する例
      */

     %{
     #define MAX_STATES 1024
     #define TRUE  1
     #define FALSE 0
     #define CHAPTER   "@chapter"
     #define SECTION   "@section"
     #define SSECTION  "@subsection"
     #define SSSECTION "@subsubsection"
     int  states[MAX_STATES];
     int  statep = 0;

     int  need_closing = FALSE;

     char buffer[YY_BUF_SIZE];

     extern char *yytext;
     /*
      * このプログラムが生成する*.texinfoファイルの先頭部分を作る。
      * これは標準的なTexinfoヘッダである
      */

     void print_header(void)
     {
        printf("\\input texinfo @c -*-texinfo-*-\n");
        printf("@c           %c**start of header\n",'%');
        printf("@setfilename       jargon.info\n");
        printf("@settitle          The New Hackers Dictionary\n");
        printf("@synindex          fn cp\n");
        printf("@synindex          vr cp\n");
        printf("@c           %c**end of header\n",'%');
        printf("@setchapternewpage odd\n");
        printf("@finalout\n");
        printf("@c @smallbook\n");
        printf("\n");
        printf("@c ====================================================\n\n");
        printf("@c This file was produced by j2t.  Any mistakes are *not*\n");
        printf("@c the fault of the jargon file editors.\n");
        printf("@c ====================================================\n\n");
        printf("@titlepage\n");
        printf("@title    The New Hackers Dictionary\n");
        printf("@subtitle Version 2.9.10\n");
        printf("@subtitle Generated by j2t\n");
        printf("@author Eric S. Raymond, Guy L. Steel, and Mark Crispin\n");
        printf("@end titlepage\n");
        printf("@page\n");
        printf("@c ====================================================\n");
        printf("\n\n");
        printf("@unnumbered Preface\n");
        printf("@c          *******\n");
     }
     /*
      * 生成されるTexinfoファイルの末尾の部分を作成する
      */

     void print_trailer(void)
     {
        printf("\n");
        printf("@c ====================================================\n");
        printf("@contents\n");   /* 目次を表示する */
        printf("@bye\n\n");
     }
     /*
      * 後でそれを見つけることができるよう、節または章に下線を引く
      */

     void write_underline(int len, int space, char ch)
     {
       int loop;

       printf("@c ");
       for(loop=3; loop<space; loop++){
         printf(" ");
       }

       while(len--){
         printf("%c",ch);
       }
       printf("\n\n");
     }
     /*
      * Texinfoにおいて特殊な意味を持つ文字をチェックし、エスケープする
      */

     char *check_and_convert(char *string)
     {
       int  buffpos = 0;
       int  len,loop;
       len = strlen(string);
       for(loop=0; loop<len; loop++){
         if(string[loop] == '@' ||
            string[loop] == '{' ||
            string[loop] == '}')
         {
           buffer[buffpos++] = '@';
           buffer[buffpos++] = string[loop];
         } else {
           buffer[buffpos++] = string[loop];
         }
       }
       buffer[buffpos] = '\0';
       return(buffer);
     }
     /*
      * 章、節、項のヘッダを書き出す
      */

     void write_block_header(char *type)
     {
       int loop;
       int len;
       (void)check_and_convert(yytext);
       len = strlen(buffer);
       for(loop=0; buffer[loop] != '\n';loop++)
       buffer[loop] = '\0';
       printf("%s %s\n",type,buffer);
       write_underline(strlen(buffer),strlen(type)+1,'*');
     }

     %}
     /*
      * Flexの記述情報がここから始まる
      */

     %x HEADING EXAMPLE ENUM EXAMPLE2
     %x BITEM BITEM_ITEM
     %s LITEM LITEM2

     %%

     ^#[^#]*"#"  /* ヘッダとフッタをスキップする */
                          /*
                           * 章は、その下にアスタリスクを持ち、コロンで終わる
                           */
     ^[^\n:]+\n[*]+\n      write_block_header(CHAPTER);
     ^"= "[A-Z]" ="\n"="*  { /* 個々のカテゴリごとに節を作成する */
                             if(need_closing == TRUE){
                               printf("@end table\n\n\n");
                             }
                             need_closing = TRUE;
                             write_block_header(SECTION);
                             printf("\n\n@table @b\n");
                           }
     "Examples:"[^\.]+     ECHO;

     "*"[^*\n]+"*"         { /* @emph{}（強調された）テキスト */
                             yytext[yyleng-1] = '\0';
                             (void)check_and_convert(&yytext[1]);
                             printf("@i{%s}",buffer);
                           }
     "{{"[^}]+"}}"         { /* 特別な強調 */
                             yytext[yyleng-2] = '\0';
                             (void)check_and_convert(&yytext[2]);
                             printf("@strong{%s}",buffer);
                           }
     "{"[^}]+"}"           { /* 特別な強調 */
                             yytext[yyleng-1] = '\0';
                             (void)check_and_convert(&yytext[1]);
                             printf("@b{%s}",buffer);
                           }
      /* 特殊なTexinfo文字をエスケープする */
     <INITIAL,LITEM,LITEM2,BITEM,ENUM,EXAMPLE,EXAMPLE2>"@"  printf("@@");
     <INITIAL,LITEM,LITEM2,BITEM,ENUM,EXAMPLE,EXAMPLE2>"{"  printf("@{");
     <INITIAL,LITEM,LITEM2,BITEM,ENUM,EXAMPLE,EXAMPLE2>"}"  printf("@}");
      /*
       * @exampleコードを再生成する
       */

     ":"\n+[^\n0-9*]+\n"     "[^ ]   {
                             int loop;
                             int len;
                             int cnt;
                             printf(":\n\n@example \n");
                             strcpy(buffer,yytext);
                             len = strlen(buffer);
                             cnt = 0;
                             for(loop=len; loop > 0;loop--){
                               if(buffer[loop] == '\n')
                                  cnt++;
                               if(cnt == 2)
                                   break;
                             }
                             yyless(loop+1);
                             statep++;
                             states[statep] = EXAMPLE2;
                             BEGIN(EXAMPLE2);
                           }
     <EXAMPLE,EXAMPLE2>^\n  {
                           printf("@end example\n\n");
                           statep--;
                           BEGIN(states[statep]);
                         }
      /*
       * @enumerateリストを再生成する
       */

     ":"\n+[ \t]*[0-9]+"."   {
                           int loop;
                           int len;
                           printf(":\n\n@enumerate \n");
                           strcpy(buffer,yytext);
                           len = strlen(buffer);
                           for(loop=len; loop > 0;loop--){
                             if(buffer[loop] == '\n')
                                break;
                           }
                           yyless(loop);
                           statep++;
                           states[statep] = ENUM;
                           BEGIN(ENUM);
                         }
     <ENUM>"@"           printf("@@");
     <ENUM>":"\n+"     "[^0-9]    {
                         printf(":\n\n@example\n");
                         statep++;
                         states[statep] = EXAMPLE;
                         BEGIN(EXAMPLE);
                       }

     <ENUM>\n[ \t]+[0-9]+"." {
                         printf("\n\n@item ");
                        }
     <ENUM>^[^ ] |
     <ENUM>\n\n\n[ \t]+[^0-9] {
                         printf("\n\n@end enumerate\n\n");
                         statep--;
                         BEGIN(states[statep]);
                       }
      /*
       * １種類の@itemizeリストを再生成する
       */

     ":"\n+":"         {
                         int loop;
                         int len;

                         printf(":\n\n@itemize @bullet \n");
                         yyless(2);
                         statep++;
                         states[statep] = LITEM2;
                         BEGIN(LITEM2);
                       }
     <LITEM2>^":".+":" {
                         (void)check_and_convert(&yytext[1]);
                         buffer[strlen(buffer)-1]='\0';
                         printf("@item @b{%s:}\n",buffer);
                       }
     <LITEM2>\n\n\n+[^:\n] {
                         printf("\n\n@end itemize\n\n");
                         ECHO;
                         statep--;
                         BEGIN(states[statep]);
                       }
      /*
       * リビジョン・ヒストリ部からリストを作成する。
       * ここで"Version"が必要なのは、そうしないと他のルール
       * と衝突するからである
       */

     :[\n]+"Version"[^:\n*]+":" {
                         int loop;
                         int len;
                         printf(":\n\n@itemize @bullet \n");
                         strcpy(buffer,yytext);
                         len = strlen(buffer);
                         for(loop=len; loop > 0;loop--){
                           if(buffer[loop] == '\n')
                              break;
                         }
                         yyless(loop);
                         statep++;
                         states[statep] = LITEM;
                         BEGIN(LITEM);
                       }
     <LITEM>^.+":"     {
                         (void)check_and_convert(yytext);
                         buffer[strlen(buffer)-1]='\0';
                         printf("@item @b{%s}\n\n",buffer);
                       }
     <LITEM>^[^:\n]+\n\n[^:\n]+\n  {
                         int loop;

                         strcpy(buffer,yytext);
                         for(loop=0; buffer[loop] != '\n'; loop++);
                         buffer[loop] = '\0';
                         printf("%s\n",buffer);
                         printf("@end itemize\n\n");
                         printf("%s",&buffer[loop+1]);
                         statep--;
                         BEGIN(states[statep]);
                       }
      /*
       * @itemize @bulletリストを再生成する
       */

     ":"\n[ ]*"*"      {
                         int loop;
                         int len;
                         printf(":\n\n@itemize @bullet \n");
                         len = strlen(buffer);
                         for(loop=0; loop < len;loop++){
                           if(buffer[loop] == '\n')
                              break;
                         }
                         yyless((len-loop)+2);
                         statep++;
                         states[statep] = BITEM;
                         BEGIN(BITEM);
                       }
     <BITEM>^" "*"*"   {
                         printf("@item");
                         statep++;
                         states[statep] = BITEM_ITEM;
                         BEGIN(BITEM_ITEM);
                       }
     <BITEM>"@"          printf("@@");
     <BITEM>^\n        {
                         printf("@end itemize\n\n");
                         statep--;
                         BEGIN(states[statep]);
                       }
     <BITEM_ITEM>[^\:]* {
                          printf(" @b{%s}\n\n",check_and_convert(yytext));
                        }
     <BITEM_ITEM>":"   {
                         statep--;
                         BEGIN(states[statep]);
                       }
      /*
       * @chapter、@section等を再作成する
       */

     ^:[^:]*           {
                         (void)check_and_convert(&yytext[1]);
                         statep++;
                         states[statep] = HEADING;
                         BEGIN(HEADING);
                       }
     <HEADING>:[^\n]   {
                         printf("@item @b{%s}\n",buffer);
                         write_underline(strlen(buffer),6,'~');
                         statep--;
                         BEGIN(states[statep]);
                       }
     <HEADING>:\n"*"*  {
                         if(need_closing == TRUE){
                           printf("@end table\n\n\n");
                           need_closing = FALSE;
                         }
                         printf("@chapter %s\n",buffer);
                         write_underline(strlen(buffer),9,'*');
                         statep--;
                         BEGIN(states[statep]);
                       }
     <HEADING>:\n"="*  {
                         if(need_closing == TRUE){
                          printf("@end table\n\n\n");
                           need_closing = FALSE;
                         }
                         printf("@section %s\n",buffer);
                         write_underline(strlen(buffer),9,'=');
                         statep--;
                         BEGIN(states[statep]);
                       }
     <HEADING>"@"        printf("@@");
     <HEADING>:\n"-"*  {
                         if(need_closing == TRUE){
                           printf("@end table\n\n\n");
                           need_closing = FALSE;
                         }
                         printf("@subsection %s\n",buffer);
                         write_underline(strlen(buffer),12,'-');
                         statep--;
                         BEGIN(states[statep]);
                       }
      /*
       * @exampleテキストを再作成する
       */

     ^"     "          {
                         printf("@example\n");
                         statep++;
                         states[statep] = EXAMPLE;
                         BEGIN(EXAMPLE);
                       }
     <EXAMPLE>^"     "
     .                 ECHO;

     %%
      /*
       * 初期化して実行する
       */

     int main(int argc, char *argv[])
     {
       states[0] = INITIAL;
       statep    = 0;
       print_header();
       yylex();
       print_trailer();
       return(0);
     }

このプログラムは、 ASCIIの専門用語ファイルを読み込んで、
いくつかのよく見られるパターンを検索します。 このパターンは、
オリジナルのTexinfo形式の専門用語ファイルを単なるASCIIテキストに変換した際に作成されたものです。
この変換の過程で、 多くのマークアップ情報が失われているために、
ある出力結果の元になったオリジナルの情報が_何_であったか、 あるいは、
そのオリジナルの候補が２つ３つあったとしても、
そのうちの_どれ_がその出力結果をもたらしたかを正確に決定することが困難であるという事情のため、
この検索作業はいくらか複雑なものになります。
よく見られるパターンをいくつか挙げると、 以下のようになります。

章、節、項
     これらの先頭にはいずれも同じパターンが来ます。

          :SOME TEXT:\n

     この後ろに、 （章の場合は）アスタリスクによる下線、
     （節の場合は）等号による下線、
     （項の場合は）マイナス記号による下線が続きます。

強調
     これは少し難しいのですが、
     一般的には強調は（イタリックの場合は）`*'...`*'、
     （強調文字（strong）の場合は）`{{'...`}}'、
     （太字（bold）の場合は）`{'...`}'の対によって示されます。
     ここでは、 この３種類を検索して、 コマンドを出力します。

実例、および列挙されたリスト
     ともにコロンで始まり、 その後ろに、 １つ以上の改行、
     少なくとも５つの空白、
     そして最後に数字もしくは何らかのテキストが続きます。 例えば、
     列挙されたリストは以下のようになります。

          ...enumerated:

                0.SOME TEXT
                1.SOME MORE TEXT

     また、 実例は以下のようになります。(1)

          ...example:

                SOME TEXT

項目化されマークを付けられたリスト
     実例、および列挙されたリストによく似ていますが、 違いは、
     項目の先頭にコロン、 またはアスタリスクがあり、
     末尾にコロンがあるという点です。

   ここでの例は、
パースされているものが何であるかを示す_ヒント_としてこのようなパターンを使い、
その特定のセクション用の部分的なパーサを
（ほとんどの場合、排他的）スタート状態を使って作ります。
ASCII版の専門用語ファイルを持っているのであれば、
スキャナのどの部分がそのファイル中の何にマッチするかを検証してみる値打ちがあります。
例えば、 `HEADING'状態において`@item'を生成するルールが、
すべての専門用語のエントリを処理するルールでもあるということは、
おそらく一見しただけでは明らかではないでしょう。

   ---------- Footnotes ----------

   (1) 訳注：SOME TEXTの部分に、インデントされたテキストが記されます。


File: flex-ja.info,  Node: Flex and Lex,  Next: Useful Code,  Prev: More Examples,  Up: Top

8 FlexとLex
***********

     ここで非常に簡単にではありますが、
     FlexとLexの両方を概観してみます。 Flex、Lexそれぞれの性能と、
     Lexのようなユーティリティに関するPOSIX標準への準拠度についても、
     いくつか一般的なコメントを示します。

========================================================================

* Menu:

* Flex::                        Flex
* Lex::                         Lex
========================================================================


File: flex-ja.info,  Node: Flex,  Next: Lex,  Prev: Flex and Lex,  Up: Flex and Lex

8.1 Flex
========

Flexは、 Lexのより優れた再実装であり、 Lexと同様、
パターンとアクションの記述情報を入力として受け取って、
そのパターンにマッチする能力を持つCのスキャナに変換するものです。
しかしながら、 Flexはより少ない時間でテーブルを生成しますし、
Flexにより生成されるテーブルは、 Lexにより生成されるテーブルと比較して、
はるかに効率的なものです。
（Flexが正確には何を生成するのかという説明については、
このマニュアルの冒頭で言及した書籍を参照してください。）

   Flexは、 LexおよびPOSIXと十分に互換性があり、
それ独自の特別な機能もいくつか追加しています。

========================================================================

* Menu:

* Flex and POSIX::              FlexとPOSIX
* Flex and POSIX (Flex 2.5)::   FlexとPOSIX（Flex 2.5の補足情報）
========================================================================


File: flex-ja.info,  Node: Flex and POSIX,  Next: Flex and POSIX (Flex 2.5),  Prev: Flex,  Up: Flex

8.1.1 FlexとPOSIX
-----------------

Flexは、 大体のところLexおよびPOSIXの両方と互換性があります。 将来は
（Flex、POSIXのどちらかが変わることによって）、
さらにPOSIXとの互換性を高めていくでしょう。 しかし、
Flex、Lex、POSIXには、 異なる部分もいくつかあります。
それを以下に示します。

排他的スタート状態
     FlexとPOSIXは排他的スタート状態をサポートしていますが、
     Lexはサポートしていません。

定義
     LexとFlexでは定義の展開の方法が違います。
     Flex（およびPOSIXのドラフト仕様）は、 定義を展開する時に丸括弧(
     )で囲みますが、 Lexは囲みません。(1) このことは、
     Flex定義では演算子`^'、`$'、`/'、`<<EOF>>'、および`<START
     STATE>'は使うことができないということを意味しています。

     このことがもたらす主要な問題の１つに、
     マッチの優先順位に影響を与え、
     FlexとLexの間でスキャン処理に微妙な差異が出てくるということがあります。
     この問題の例については、 *Note パターン・セクション: Pattern
     Matching.を参照してください。

`input()'
     FlexおよびPOSIXのドラフト仕様では、
     `input()'は再定義可能ではありません。
     Flexで入力を制御するためには、 `input()'を再定義する代わりに、
     `YY_INPUT'という拡張機能を使います
     （これは現在のところPOSIXではサポートされていません）。 また、
     Lexとは異なり、
     Flexの`input()'は`yytext'の値を変更するという点に注意してください。

`output()'
     Flexは`output()'ルーチンをサポートしていません。
     `ECHO'の出力は`yyout'経由で行われます。
     この`yyout'のデフォルトは`stdout'です。
     これを使うように`output()'を書くことも可能ですが、
     現在のPOSIXのドラフト仕様は、
     `output()'が正確には何をすべきなのかを示していません。

Ratforスキャナ
     Flex、POSIXのどちらも、
     LexのRatfor(2)スキャナ・オプション（`%r'）をサポートしていません。

`yylineno'
     これは、 FlexやPOSIXには存在しない、
     ドキュメント化されていないLexの機能です。(3) しかし、
     Flexで行数をカウントする機能を実装するのは難しくありません。
     定義中に行数カウント機能を組み込む方法の例については、 *Note
     Miscellaneous::を参照してください。

`yywrap()'
     現在のところ`yywrap()'はマクロです。 POSIXのドラフト仕様では、
     これは関数であるべきとされていますので、
     おそらく将来は変更されることになるでしょう。(4)

`unput()'
     現在のところ`unput()'は`yytext'と`yyleng'の値を破壊しますが、
     次のトークンがマッチされるまでは、 これは不当です。
     LexとPOSIXでは、
     `yytext'と`yyleng'は`unput()'の影響を受けません。(5)

数値範囲
     POSIX によると、 `abc{1,3}'は
     「`ab'の後ろに１個、２個、または３個の`c'が続くもの」
     にマッチすべきとなっています。 Flexはこのとおりに動きますが、
     Lexはこれを 「１個、２個、または３個の`abc'」 と解釈します。

`yytext'
     Flexにおいて`yytext'の正しい定義は`extern char *yytext'ですが、
     Lexでは`extern char yytext[]'です。(6) 配列によるアクセス方法は、
     性能にかなりの影響を及ぼすので、 Flexでは`extern char
     *yytext'を使い続けるでしょう。

     最新のPOSIXドラフト仕様は、
     `%array'と`%pointer'を導入することによって、
     両方の方法をサポートしています。 これは、
     FlexとLexのいずれにもまだ組み込まれていません。(7)

テーブル・サイズ
     Lexにはテーブル・サイズ宣言子（`%p'、`%a'等）がありますが、
     Flexでは必要ありません。 互換性のために認識はされますが、
     無視されるだけです。

`FLEX_SCANNER'
     スキャナがFlexとLexのどちらにより生成されたかによって、
     コードをインクルードしたりしなかったりすることができるように、
     `FLEX_SCANNER'が`#define'によって定義されています。

アクション
     Flexでは、 大括弧の対`{...}'を使うことなく、
     単一行において複数の文を置くことができます。 これに対してLexは、
     そのような行を単一文に切り詰めてしまいます。

コメント
     Flexではコメントを`#'で始めることができますが、
     LexとPOSIXではできません。 ただし、
     この形式のコメントを使うことはお勧めできません。

`yyterminate()'、`yyrestart()'、`<<EOF>>'、`YY_DECL'、`#line' 指示子
     これらはいずれもLexではサポートされていませんし、
     POSIXにおいて明示的に定義されてもいません。
     `#line'指示子の説明に関しては、 *Note Flex
     コマンドライン・オプションの要約: Switches Summary。


   ---------- Footnotes ----------

   (1) 訳注：Flex 2.5では、
`-l'オプションを指定して生成されたスキャナは、 Lexの場合と同じように、
定義を展開する時に丸括弧( )で囲みません。

   (2) 訳注：Rational Fortran

   (3) 訳注：Flex 2.5では、 Flex起動時に`-l'オプションを指定するか、
スキャナ定義ファイルの中に`%option yylineno'を指定することによって、
変数`yylineno'を利用することができます。

   (4) 訳注：Flex 2.5では、 `%option noyywrap'が指定されない限り、
`yywrap()'は関数です。

   (5) 訳注：Flex 2.5では、 `%array'を指定すれば、
`unput()'は`yytext'の内容を破壊しません。

   (6) 訳注：Flex 2.5では、 `%pointer'と`%array'により、
`yytext'の型を選択できるようになりました。 デフォルトは`%pointer'です。

   (7) 訳注：Flex 2.5は、 `%pointer'と`%array'をサポートしています。


File: flex-ja.info,  Node: Flex and POSIX (Flex 2.5),  Prev: Flex and POSIX,  Up: Flex

8.1.2 FlexとPOSIX（Flex 2.5の補足情報）
---------------------------------------

Flex 2.5でサポートされている新しい機能のうち、
POSIXの仕様（および、Lex）に存在しないものを以下に列挙します。

     C++スキャナ
     %option指示子
     スタート状態スコープ
     スタート状態スタック
     yy_scan_string()、yy_scan_bytes()、yy_scan_buffer()
     yy_set_interactive()
     yy_set_bol()
     YY_AT_BOL()
     <*>
     YY_START


File: flex-ja.info,  Node: Lex,  Prev: Flex,  Up: Flex and Lex

8.2 標準Lex
===========

Lexはスキャナを作成するための標準的なUnixユーティリティであり、
長い歴史を持っています。 LexはFlexと非常によく似ていますが、
スキャナを生成するのにより多くの時間がかかりますし、
Lexの生成するスキャナはFlexの生成するスキャナよりも通常は遅いものです。
Lexは、 特に多くのPOSIX機能を提供していないという理由から、
置き換える必要が大いにあります。
FlexはこうしたPOSIX機能を提供しています。
より多くのコンピュータ・システムがPOSIX互換になるにつれて、
Flexの提供する多くの機能をサポートしなければならなくなり、 このために、
おそらくはFlexがLexの代わりにインストールされるようになるでしょう
（例えば、 4.4 BSDリリースはFlexを使うことになります）。 しかし、
Lexがインストールされている少数のシステムがあるために、
しばらくの間はLexの存在は確実に維持されるでしょう。

   FlexとLexの大きな違いは、
Flexが性能を考慮して書かれたという点にあります。 一般的には、
Flexを持っているのであればそれを使うべきです。 両者の性能差は、
無視するにはあまりにも大きすぎます。 しかし、
移植性が最も重要なのであれば、
スキャナ定義は可能な限りLexのものに近づけるべきです。 というのは、
Lexは事実上すべてのUnixマシンに入っていることが保証されていますが、
Flexは入っていない可能性があるからです （しかし、
Flexのインストールは通常は取るに足りない作業です）。
このような場合に残念なのは、
FlexとPOSIXが持っている排他的スタート状態のような、
より便利な拡張機能を使うことができなくなるということです。

   この問題を回避するためのもう１つの方法は、 Flexでスキャナを作成して、
作成されたスキャナを配布することです。
スキャナというものは一度書かれるとほとんど変更されることがないので、
多くの場合この方法は実行可能です。 仮に変更が必要になったとしても、
プログラムの他の部分も相当変更しなければならない可能性があり、
よってプログラムを更新するための努力全体から見れば、
Flexをインストールすることなどはほんの些細なものでしょう。


File: flex-ja.info,  Node: Useful Code,  Next: Summary,  Prev: Flex and Lex,  Up: Top

9 役に立つコードの抜粋
**********************

     ここでは、 読者がプログラムの中で使うことのできる、
     ちょっとしたFlex定義を一覧にして示します。 多くは、
     このマニュアルを読んだあとでは、 かなり自明のものになるはずです。
     しかし、 読者がこうしたコードを最初から作らずに済むように、
     ここに入れてあります。

   参照したい項目を選択してください。

========================================================================

* Menu:

* Handling Comments::           コメントの処理
* Handling Strings::            文字列の処理
* Handling Numbers::            数値の処理
* Multiple Scanners::           複数のスキャナ
* Miscellaneous::               その他
========================================================================


File: flex-ja.info,  Node: Handling Comments,  Next: Handling Strings,  Prev: Useful Code,  Up: Useful Code

9.1 コメントの処理
==================

*Note Flex and C::において述べたように、
コメントは`input()'を使って処理することができます。
これを行うためのコードは以下のようになります。

     %%
     "/*" {
             int a,b;

             a = input();
             while(a != EOF){
               b = input();
               if(a == '*' && b == '/'){
                 break;
                }else{
                 a = b;
                }
              }
             if(a == EOF){
               error_message("EOF in comment");
             }
           }

これは、 FlexとLexの両方で正当なコードです。
コメントは排他的スタート状態を使って処理することも可能で、
こちらの方がより美しく、 より効率的です。
スタート状態を使ってコメントを処理するコードは、 以下のようになります。

     %x COMMENT
     %%
     "/*"                  BEGIN(COMMENT);
     <COMMENT>[^\n]
     <COMMENT>\n
     <COMMENT><<EOF>>      yyerror("EOF in comment");
     <COMMENT>"*/"         BEGIN(INITIAL);

改行の１つ前までと改行とを別々に処理した方が良いのは、 そうしないと、
内部のマッチ処理用のバッファをオーバーフローさせてしまうようなルールを作ることになってしまうからです。
Lexは排他的スタート状態をサポートしていないので、
このコードはLexでは動きません。 この例は分かりやすいのですが、
実際には単一文字をマッチするのに多くの時間を無駄に消費するため、
非効率的です。 もっと長いテキストにマッチするように変更することで、
スピードをかなり向上させることができます。 例えば、
以下のように書き直すことができます。

     %x COMMENT
     %%
     "/*"                     BEGIN(COMMENT);
     <COMMENT>[^*\n]*
     <COMMENT>[^*\n]*\n
     <COMMENT>"*"+[^*/\n]*    /* 余分な*を探す */
     <COMMENT>"*"+[^*/\n]*\n
     <COMMENT><<EOF>>         yyerror("EOF in comment");
     <COMMENT>"*"+"/"         BEGIN(INITIAL);

これは、
Flexと一緒に配布されている`flexdoc.1'の中にある例とほとんど同一です。
より長いテキスト・ブロックにマッチするため、 はるかに高速ですし、
ルールの中で改行のみにマッチさせる必要もありません。


File: flex-ja.info,  Node: Handling Strings,  Next: Handling Numbers,  Prev: Handling Comments,  Up: Useful Code

9.2 文字列リテラルの処理
========================

文字列は、 それが入力として与えられた時に破棄されないという点で、
コメントとは若干異なります。 しかし、 基本的なアプローチは同じです。
第１の方法としては、 `input()'を使って文字列を処理することができます。
コードは以下のようになります。

     /*
      * string1.lex: input()を使って文字列を処理する
      */

     %{
     #include <stdio.h>
     #include <malloc.h>
     #include <ctype.h>

     #define ALLOC_SIZE 32 /* バッファの（再）割り当て用 */

     #define isodigit(x) ((x) >= '0' && (x) <= '7')
     #define hextoint(x) (isdigit((x)) ? (x) - '0'\
                                        : ((x) - 'A') + 10)
     void yyerror(char *message)
     {
       printf("\nError: %s\n",message);
     }

     %}
     %%

     \" {
        int  inch,count,max_size;
        char *buffer;
        int  temp;
        buffer   = malloc(ALLOC_SIZE);
        max_size = ALLOC_SIZE;
        inch     = input();
        count    = 0;
        while(inch != EOF && inch != '"' && inch != '\n'){
           if(inch == '\\'){
             inch = input();
             switch(inch){
             case '\n': inch = input(); break;
             case 'b' : inch = '\b';    break;
             case 't' : inch = '\t';    break;
             case 'n' : inch = '\n';    break;
             case 'v' : inch = '\v';    break;
             case 'f' : inch = '\f';    break;
             case 'r' : inch = '\r';    break;
             case 'X' :
             case 'x' : inch = input();
                        if(isxdigit(inch)){
                          temp = hextoint(toupper(inch));
                          inch = input();
                          if(isxdigit(inch)){
                            temp = (temp << 4) +
                                  hextoint(toupper(inch));
                          } else {
                            unput(inch);
                          }
                          inch = temp;
                        } else {
                          unput(inch);
                          inch = 'x';
                        }
                break;
             default:
                if(isodigit(inch)){
                   temp = inch - '0';
                   inch = input();
                   if(isodigit(inch)){
                     temp = (temp << 3) + (inch - '0');
                   } else {
                     unput(inch);
                     goto done;
                   }
                   inch = input();
                   if(isodigit(inch)){
                     temp = (temp << 3) + (inch - '0');
                   } else {
                     unput(inch);
                   }
                done:
                   inch = temp;
                }
             }
          }
           buffer[count++] = inch;
           if(count >= max_size){
              buffer = realloc(buffer,max_size + ALLOC_SIZE);
              max_size += ALLOC_SIZE;
           }
           inch = input();
        }
        if(inch == EOF || inch == '\n'){
          yyerror("Unterminated string.");
        }
        buffer[count] = '\0';
        printf("String = \"%s\"\n",buffer);
        free(buffer);
      }
     .
     \n
     %%

このスキャナは、 複数行にわたる文字列や、
様々なエスケープ・シーケンスを処理します。 また、
文字列がどのような長さでも構わないように、 動的バッファを使っています。
これと同じことをスタート状態を使って行うコードは、
以下のようになります。

     /*
      * string2.lex: スタート状態を使って文字列をスキャンする例
      */

     %{
     #include <ctype.h>
     #define isodigit(x) ((x) >= '0' && (x) <= '7')
     #define hextoint(x) (isdigit((x)) ? (x) - '0' \
                                       : ((x) - 'A') + 10)
     char *buffer      = NULL;
     int  buffer_size  = 0;
     void yyerror(char *message)
     {
       printf("\nError: %s\n",message);
     }

     %}

     %x STRING

     hex (x|X)[0-9a-fA-F]{1,2}
     oct [0-7]{1,3}
     %%

     \"                {
                         buffer      = malloc(1);
                         buffer_size = 1; strcpy(buffer,"");
                         BEGIN(STRING);
                       }
     <STRING>\n        {
                          yyerror("Unterminated string");
                          free(buffer);
                          BEGIN(INITIAL);
                       }
     <STRING><<EOF>>   {
                          yyerror("EOF in string");
                          free(buffer);
                          BEGIN(INITIAL);
                       }
     <STRING>[^\\\n"]  {
                         buffer_size += yyleng;
                         buffer = realloc(buffer,buffer_size+1);
                         strcat(buffer,yytext);
                       }
     <STRING>\\\n      /* エスケープされた改行を無視する */
     <STRING>\\{hex} {
                         int temp =0,loop = 0, foo;
                         for(loop=yyleng-2; loop>0; loop--){
                           temp <<= 4;
                           foo    = toupper(yytext[yyleng-loop]);
                           temp += hextoint(foo);
                         }
                         buffer = realloc(buffer,buffer_size+1);
                         buffer[buffer_size-1] = temp;
                         buffer[buffer_size]   = '\0';
                         buffer_size += 1;
                       }
     <STRING>\\{oct} {
                         int temp =0,loop = 0;
                         for(loop=yyleng-1; loop>0; loop--){
                           temp  <<= 3;
                           temp  += (yytext[yyleng-loop] - '0');
                         }
                         buffer = realloc(buffer,buffer_size+1);
                         buffer[buffer_size-1] = temp;
                         buffer[buffer_size]   = '\0';
                         buffer_size += 1;
                       }
     <STRING>\\[^\n]   {
                         buffer = realloc(buffer,buffer_size+1);
                         switch(yytext[yyleng-1]){
                         case 'b' : buffer[buffer_size-1] = '\b';
                                    break;
                         case 't' : buffer[buffer_size-1] = '\t';
                                    break;
                         case 'n' : buffer[buffer_size-1] = '\n';
                                    break;
                         case 'v' : buffer[buffer_size-1] = '\v';
                                    break;
                         case 'f' : buffer[buffer_size-1] = '\f';
                                    break;
                         case 'r' : buffer[buffer_size-1] = '\r';
                                    break;
                         default  : buffer[buffer_size-1] =
                                         yytext[yyleng-1];
                         }
                         buffer[buffer_size] = '\0';
                         buffer_size += 1;
                       }
     <STRING>\"        {
                         printf("string = \"%s\"",buffer);
                         free(buffer);
                         BEGIN(INITIAL);
                       }
     %%

このスキャナは、 `string1.lex'よりもモジュール化されていて、
おそらくはより分かりやすいでしょう。 エラーのルールは、
`INITIAL'状態に戻るようになっていることに注意してください。
こうしないと、
スキャナは不当な文字列と正当な文字列とを結合してしまいます。 ここでも、
Flexのバッファ（`YY_BUF_SIZE'）が十分に大きいということをあてにせず、
動的バッファを使いました。
内部バッファが十分に大きいという確信が持てるのであれば、
`yytext'だけを使うことも可能です。 この場合には、
`yytext'の右端が確実に最初の位置に留まるようにすることが重要です。
より詳しい情報については、 *Note Flex and
C::の`yymore'の項を参照してください。 


File: flex-ja.info,  Node: Handling Numbers,  Next: Multiple Scanners,  Prev: Handling Strings,  Up: Useful Code

9.3 数字の処理
==============

ここでは、
Cに見られる様々な数値形式に対してよく使われる定義をいくつか示し、
さらにその使い方の実例を１つ示します。 注目すべき主要な点は、
数の値を獲得するために`scanf()'を使っている点と、
オーバーフローが発生しないよう`long'型の値をスキャンするデフォルトのルールです。
一般的には、 `yytext'を数に変換する最良の方法は、
`sscanf()'を使うことです。

     /*
      * numbers.lex : 数をスキャンするための定義およびテクニックの実例
      */

     %{
     #include <stdio.h>
     #define UNSIGNED_LONG_SYM   1
     #define SIGNED_LONG_SYM     2
     #define UNSIGNED_SYM        3
     #define SIGNED_SYM          4
     #define LONG_DOUBLE_SYM     5
     #define FLOAT_SYM           6

     union _yylval {
       long double    ylong_double;
       float          yfloat;
       unsigned long  yunsigned_long;
       unsigned       yunsigned;
       long           ysigned_long;
       int            ysigned;
     } yylval;

     %}
     digit          [0-9]
     hex_digit      [0-9a-fA-F]
     oct_digit      [0-7]
     exponent       [eE][+-]?{digit}+
     i              {digit}+
     float_constant ({i}\.{i}?|{i}?\.{i}){exponent}?
     hex_constant   0[xX]{hex_digit}+
     oct_constant   0{oct_digit}*
     int_constant   {digit}+
     long_ext       [lL]
     unsigned_ext   [uU]
     float_ext      [fF]
     ulong_ext      [lL][uU]|[uU][lL]

     %%

     {hex_constant}{ulong_ext} {  /* 0xの部分をスキップする */
                                  sscanf(&yytext[2],"%lx",
                                         &yylval.yunsigned_long);
                                  return(UNSIGNED_LONG_SYM);
                               }
     {hex_constant}{long_ext}  {
                                  sscanf(&yytext[2],"%lx",
                                         &yylval.ysigned_long);
                                  return(SIGNED_LONG_SYM);
                               }
     {hex_constant}{unsigned_ext}  {
                                  sscanf(&yytext[2],"%x",
                                         &yylval.yunsigned);
                                  return(UNSIGNED_SYM);
                               }
     {hex_constant}   { /* オーバーフローを回避するために%lxを使う */
                                  sscanf(&yytext[2],"%lx",
                                         &yylval.ysigned_long);
                                  return(SIGNED_LONG_SYM);
                               }
     {oct_constant}{ulong_ext} {
                                  sscanf(yytext,"%lo",
                                         &yylval.yunsigned_long);
                                  return(UNSIGNED_LONG_SYM);
                               }
     {oct_constant}{long_ext}  {
                                  sscanf(yytext,"%lo",
                                         &yylval.ysigned_long);
                                  return(SIGNED_LONG_SYM);
                               }
     {oct_constant}{unsigned_ext}  {
                                  sscanf(yytext,"%o",
                                         &yylval.yunsigned);
                                  return(UNSIGNED_SYM);
                               }
     {oct_constant} { /* オーバーフローを回避するために%loを使う */
                                  sscanf(yytext,"%lo",
                                         &yylval.ysigned_long);
                                  return(SIGNED_LONG_SYM);
                               }
     {int_constant}{ulong_ext} {
                                  sscanf(yytext,"%ld",
                                         &yylval.yunsigned_long);
                                  return(UNSIGNED_LONG_SYM);
                               }
     {int_constant}{long_ext}  {
                                  sscanf(yytext,"%ld",
                                         &yylval.ysigned_long);
                                  return(SIGNED_LONG_SYM);
                               }
     {int_constant}{unsigned_ext}  {
                                  sscanf(yytext,"%d",
                                         &yylval.yunsigned);
                                  return(UNSIGNED_SYM);
                               }
     {int_constant} { /* オーバーフローを回避するために%ldを使う */
                                  sscanf(yytext,"%ld",
                                         &yylval.ysigned_long);
                                  return(SIGNED_LONG_SYM);
                               }
     {float_constant}{long_ext}  {
                                  sscanf(yytext,"%lf",
                                  &yylval.ylong_double);
                                  return(LONG_DOUBLE_SYM);
                               }
     {float_constant}{float_ext}  {
                                  sscanf(yytext,"%f",
                                         &yylval.yfloat);
                                  return(FLOAT_SYM);
                               }
     {float_constant} { /* オーバーフローを回避するために%lfを使う */
                                  sscanf(yytext,"%lf",
                                         &yylval.ylong_double);
                                  return(LONG_DOUBLE_SYM);
                               }
     %%

     int main(void)
     {
       int code;

       while((code = yylex())){
         printf("yytext          : %s\n",yytext);
         switch(code){
         case UNSIGNED_LONG_SYM:
            printf("Type of number  : UNSIGNED LONG\n");
            printf("Value of number : %lu\n",
                   yylval.yunsigned_long);
            break;
         case SIGNED_LONG_SYM:
            printf("Type of number  : SIGNED LONG\n");
            printf("Value of number : %ld\n",
                   yylval.ysigned_long);
            break;
         case UNSIGNED_SYM:
            printf("Type of number  : UNSIGNED\n");
            printf("Value of number : %u\n",
                   yylval.yunsigned);
            break;
         case SIGNED_SYM:
            printf("Type of number  : SIGNED\n");
            printf("Value of number : %d\n",
                   yylval.ysigned);
            break;
         case LONG_DOUBLE_SYM:
            printf("Type of number  : LONG DOUBLE\n");
            printf("Value of number : %lf\n",
                   yylval.ylong_double);
            break;
         case FLOAT_SYM:
            printf("Type of number  : FLOAT\n");
            printf("Value of number : %f\n",
                   yylval.yfloat);
            break;
         default:
            printf("Type of number  : UNDEFINED\n");
            printf("Value of number : UNDEFINED\n");
            break;
         }
       }
       return(0);
     }

16進定数については、
変換する前に先頭の`0x'をスキップする必要がある点に注意してください。
これは`sscanf()'の仕様です。


File: flex-ja.info,  Node: Multiple Scanners,  Next: Miscellaneous,  Prev: Handling Numbers,  Up: Useful Code

9.4 複数のスキャナ
==================

時には、
１つのプログラムの中で複数のスキャナを持つ必要がある場合がありますが、
こうすると、 ２回以上現れる関数や変数について、
リンカが文句を言ってきます。 これを回避するためには、
スキャナとそれに関連するすべてのものの名前を変更する必要があります。
すべてのスキャナ関数、マクロ、およびデータの名前は`yy'もしくは`YY'で始まりますので、
これはきわめて簡単です。 しなければならないことは、
名前の接頭辞を変更することだけです。
これは`sed'を使って簡単に行うことができますが、 ここではおもしろ半分で、
これを行うflexスキャナを示しましょう。(1)

     /*
      * replace.lex : flexにより生成されたスキャナや
      *               bisonにより生成されたパーサの
      *               一部の名前を変更する簡単なフィルタ
      */

     %{
     #include <stdio.h>

     char lower_replace[1024];
     char upper_replace[1024];

     %}
     %%

     "yy"   fprintf(yyout,"%s",lower_replace);
     "YY"   fprintf(yyout,"%s",upper_replace);
     %%

     int main(argc,argv)
     int argc;
     char **argv;
     {
        if(argc < 3){
          printf("Usage %s lower UPPER\n",argv[0]);
          exit(1);
        }
        strcpy(lower_replace,argv[1]);
        strcpy(upper_replace,argv[2]);
        yylex();
        return(0);
     }

すべてのスキャナ関数の名前を変更するには、
コマンドライン上で以下のように実行するだけです。

     replace myscan_ MYSCAN_ < lex.yy.c > myscan.c

これにより、
好きなだけ多くのスキャナを含めることができるようになります。
ほとんど同じことを、
排他的スタート状態と複数のバッファを使って実現することも可能ですが、
その方法は多少複雑になります。

   *注：*いくつかのFlex内部ルーチンは、
将来Flexライブラリ（`-lfl'）の中に移されるでしょう。 そうなると、
このテクニックは機能しなくなります。 しかし、 この変更が行われる時には、
変更する必要のある関数名を変更する方法を、
Flex自身がサポートするようになるでしょう。(2)

   ---------- Footnotes ----------

   (1) 訳注：Flex 2.5では、
Flex起動時に`-PPREFIX'オプションを指定するか、
スキャナ定義ファイルの中に`%option
prefix="PREFIX"'を指定することによって、
接頭辞`yy'を別の文字列に変更することができます。

   (2) 訳注：Flex 2.5では、 `-PPREFIX'オプションや`%option
prefix="PREFIX"'を指定することにより、 関数名を変更することができます。


File: flex-ja.info,  Node: Miscellaneous,  Prev: Multiple Scanners,  Up: Useful Code

9.5 その他
==========

   * 行数のカウント

     行数をカウントしたいのであれば、
     ファイルの先頭のオプションのCコード・セクションに変数を定義して、
     改行をチェックします。
     スタート状態の中でも改行をチェックするのを忘れないようにしてください。
     さもないと、 行数のカウントはうまくいきません。 例えば、
     以下のようにします。

          %{
          int linenumber = 0;
          %}
          %x COMMENT STRING
          %%
          "/*"              BEGIN(COMMENT);
          <COMMENT>\n       line_number += 1;
          <COMMENT>[^\n]*
          <COMMENT>"*/"     BEGIN(INITIAL);
          \"                BEGIN(STRING)
          <STRING>\\\n      line_number += 1;
          <STRING>[^\n\\\"]*
          <STRING>\"        BEGIN(INITIAL);
          \n                line_number += 1;

   * スキャナとソケット

     `yyin'と`yyout'をリダイレクトすることによって、 スキャナを
     （したがってBisonによるパーサをも）
     ソケットにアタッチすることができます。 これは、
     `fdopen()'を呼び出すことによって行います。 例えば、
     以下のようになります。

          yyin  = fdopen(connection, "r");
          yyout = fdopen(connection, "w");

     ここで`connection'は、
     確立されたソケット・コネクションのファイル・ディスクリプタです。


File: flex-ja.info,  Node: Summary,  Next: Index,  Prev: Useful Code,  Up: Top

10 要約
*******

     ここでは、 Flexの使用に関連するすべての情報を要約します。
     この情報は、 クイック・リファレンスとして使うことができます。

========================================================================

* Menu:

* Switches Summary::            Flexコマンドライン・オプションの要約
* Switches Summary (Flex 2.5)::  同上（Flex 2.5の補足情報）
* Summary or Flex Variables and Functions::  Flex変数、Flex関数の要約
* Summary or Flex Variables and Functions (Flex 2.5)::
                                             同上（Flex 2.5の補足情報）
* Summary of Flex Characters::  演算子、特殊文字、エスケープ・シーケンス
                                以外の文字をその文字自身として受け付ける
* Summary of Flex Rules::       Flexルールの２つの構成要素
========================================================================


File: flex-ja.info,  Node: Switches Summary,  Next: Switches Summary (Flex 2.5),  Prev: Summary,  Up: Summary

10.1 Flexコマンドライン・オプションの要約
=========================================

Flexには、 以下のコマンドライン・オプションがあります。

    `-b'
          このオプションは、
          バックトラッキングを必要とする状態をもたらすルールに関する情報を含む、
          `lex.backtrack'というファイルを生成します。
          なぜこの情報が重要なのか、 また、
          この情報をどのように使うかという点に関する詳細については、
          *Note Optimizing for Speed::と*Note Removing
          Backtracking::を参照してください。

    `-c'
          このオプションは、 POSIXとの互換性のためだけに提供されており、
          実際には何もしません。 以前は、
          テーブル圧縮を制御するために使われていましたが、
          その機能は`-C'オプションに移されました。
          このフラグを見つけると、
          Flexはユーザがテーブル圧縮を希望しているものと想定し、
          警告メッセージを出力します。 将来、
          この警告メッセージは出力されないようになるかもしれません。(1)

    `-d'
          デバッグに使われます。
          実行中に自身の状態情報を`yyout'に書き込むスキャナを生成します。
          あるルールがマッチするたびに、
          バックトラッキングに関する情報、検出されたバッファの終端、`NUL'に関する情報に加えて、
          以下のような情報が書き込まれます。

               --accepting rule at line 行番号 ("マッチしたテキスト")

          この中の行番号は （`-L'オプションが使われていない場合には）、
          生成されたファイル`lex.yy.c'ではなく、
          スキャナを生成するのに使われた記述ファイルの行番号を指します。

    `-f'
          _フル_・スキャナ（_full_ scanner）を生成します。
          圧縮は一切行われません。 これは、 `-Cf'と同等です
          （詳細については、 *Note Table Compression and Scanner
          Speed::）。

    `-i'
          大文字・小文字の区別を無視するスキャナを作成するよう、
          Flexに通知します。
          ルールのマッチ処理において大文字・小文字の区別は無視されますが、
          個々の文字は大文字または小文字に_変換_されないので、
          `yytext'には大文字・小文字が混在した文字の並びが入ることになります。

    `-n'
          このオプションは、 Flexに対してはまったく意味を持たず、
          単にPOSIXとの互換性のためだけに提供されています。

    `-p'
          性能に関する情報を`stderr'に書き込むよう、 Flexに通知します。
          報告される情報は、
          性能を低下させるようなスキャナ記述情報の機能に関するコメントによって構成されます。

    `-s'
          マッチするものがなかった場合のFlexスキャナのデフォルトのアクションは、
          マッチしなかった入力情報を`stdout'に書き込むことです。
          `-s'オプションはこのアクションを抑制し、 その代わりに、
          入力がマッチしないとすぐにスキャナを異常終了させます。

    `-t'
          このオプションが指定されると、
          Flexは生成されたスキャナをファイル`lex.yy.c'にではなく、
          `stdout'に書き込みます。

    `-v'
          _冗長_モードで動作するよう、 Flexに通知します。 Flexは、
          生成されたスキャナに関する統計情報の要約を生成して、
          `stdout'に出力します。
          要約情報の第１行にはFlexのバージョン番号、
          次の行には日付と時刻、
          さらに次の行には実際に使われているオプションが示されます。
          要約情報のこれ以外の部分は、
          Flexやその他の同様のプログラムの動作の詳細を理解している人以外にはほとんど意味を持ちません。

    `-F'
          _ファスト_・スキャナ（_fast_ scanner）を生成するよう、
          Flexに通知します。 これは、 `-CF'と同等です。 詳細については、
          *Note スキャナの最適化: Optimization。

    `-I'
          このオプションは、 シェル上や、
          型を持つ入力情報を受け付ける必要のあるプログラム内で使うことのできる_対話型_スキャナを生成するよう、
          Flexに通知します。 詳細については、 *Note Interactive
          Scanners::。

          *注：*`-I'オプションは、
          `-Cf'、`-f'、`-CF'、`-F'の各オプションと一緒に使うことはできません。

    `-L'
          デフォルトではFlexは、
          エラーがスキャナ定義のどこで発生したのかを追跡できるように、
          生成されたスキャナのコード中に`#line'指示子を生成します。
          `-L'オプションは、
          この`#line'指示子を生成する機能を抑制します。

    `-T'
          Flexを"トレース"・モードで実行させます。 Flexは、
          入力情報、スキャン処理テーブル、同等クラス（equivalence
          class）、およびメタ同等クラス（meta-equivalence
          class）に関するメッセージを生成して、
          （`stderr'に）書き込みます。 この情報は、
          Flexの内部的な動作を理解していない人には、
          ほとんど意味を持たないでしょう。

    `-8'
          このオプションは、
          8ビットの入力情報を受け付けることのできるスキャナを生成するよう、
          Flexに通知します。
          7ビットの入力情報しか受け付けないスキャナに8ビットの入力情報を与えた場合の結果は、
          予測不能です。

    `-C[efmF]'
          スキャン処理テーブルをどのように圧縮するかを、
          Flexに通知します。 詳細については、 *Note スキャナの最適化:
          Optimizationを参照してください。

    `-SSKELETON_FILE'
          生成されるスキャナのベースとして、
          SKELETON_FILEで指定されるファイルを使うよう、
          Flexに通知します。 これを使うことはほとんどありませんが、
          MS-DOS上ではこれによって標準のスキャナ・スケルトンへのパスを設定することができます。


   ---------- Footnotes ----------

   (1) 訳注：Flex 2.5では、 この警告メッセージは出力されません。


File: flex-ja.info,  Node: Switches Summary (Flex 2.5),  Next: Summary or Flex Variables and Functions,  Prev: Switches Summary,  Up: Summary

10.2 Flexコマンドライン・オプションの要約（Flex 2.5の補足情報）
===============================================================

Flex 2.5では、 前節（*Note Switches Summary::）で説明されていない、
以下のオプションもサポートされています。

    `-h'
          Flexに対してコマンドライン・オプションの要約情報を出力するよう指示します。

    `-l'
          AT&Tにより実装されたlexとの互換性を最大限に提供します。
          このオプションは、 性能面でかなりの悪影響を及ぼします。 また、
          このオプションを、
          `-f'、`-F'、`-Cf'、`-CF'、`-+'オプションと同時に指定することはできません。

    `-w'
          このオプションが指定されると、 Flexは、
          警告メッセージを出力しません。

    `-B'
          Flexに対してバッチ・スキャナを生成するよう指示します。
          これは、
          対話型スキャナを生成するよう指示する`-I'オプションの否定です。

    `-V'
          Flexに対してバージョン番号を出力するよう指示します。

    `-7'
          Flexに対して7ビット・スキャナを生成するよう指示します。
          これは、 `-8'オプションの否定です。

    `-+'
          Flexに対してC++スキャナ・クラスを生成するよう指示します。

    `-?'
          Flexに対してコマンドライン・オプションの要約情報を出力するよう指示します。
          （`-h'オプションと同じです）。

    `-Ca'
          このオプションは、 スキャン処理用のテーブルを`long
          int'の配列として定義するようFlexに通知します
          （デフォルトでは`short int'型の配列となります）。

    `-Cr'
          このオプションを指定して生成されたスキャナは、
          入力に`read()'システム・コールを使います。 デフォルトでは、
          対話型スキャナの場合は`getc()'が、
          バッチ（非対話型）・スキャナの場合は`fread()'が使われます。

    `-oFILE'
          このオプションが指定されると、
          Flexは生成されたスキャナをFILEにより指定されるファイルに出力します。
          デフォルトでは、 スキャナはファイル`lex.yy.c'に出力されます。

    `-PPREFIX'
          Flexにより生成されるスキャナのソース・ファイルの中では、
          大域変数や大域関数の名前の先頭に接頭辞`yy'が付けられます。
          このオプションが指定されると、 `yy'の代わりに、
          PREFIXにより指定される文字列が接頭辞として使用されます。
          また、
          `-o'オプションが指定されない場合のスキャナ・ファイル名`lex.yy.c'も、
          `lex.PREFIX.c'となります。

    `--help'
          Flexに対してコマンドライン・オプションの要約情報を出力するよう指示します。
          （`-h'オプションと同じです）。

    `--version'
          Flexに対してバージョン番号を出力するよう指示します。
          （`-V'オプションと同じです）。


File: flex-ja.info,  Node: Summary or Flex Variables and Functions,  Next: Summary or Flex Variables and Functions (Flex 2.5),  Prev: Switches Summary (Flex 2.5),  Up: Summary

10.3 Flex変数およびFlex関数の要約
=================================

Flexに対する主要なCインターフェイスは、
以下のルーチンおよび変数を通じて実現されます。
個々のルーチン、変数に関する完全な説明については、 *Note Interfacing to
Flex::。

    `yylex()'
          主要なインターフェイスです。
          これが実際のスキャン処理を行う関数です。

    `yyin'
          `yylex()'が文字を読み込む元となるファイルです。
          このデフォルトは`stdin'です。

    `yyout'
          スキャナの出力ファイルです。 デフォルトは`stdout'です。

    `yytext'
          最後にマッチした文字列を保持する大域変数です。 つまり、
          最後に認識されたトークンを保持しています。

    `yyleng'
          最後に認識されたトークンの長さを保持する大域変数です。

    `yywrap()'
          この関数は、 `yyin'の終端に達した時に呼び出されます。
          これが`TRUE'（ゼロ以外）を返すとスキャナは実行を終了しますが、
          `FALSE'（ゼロ）を返すと、
          `yyin'が次の入力ファイルを指すよう設定されたものと想定し、
          スキャン処理は継続されます。

    `yymore()'
          次に認識されるトークンで`yytext'の内容を上書きするのではなく、
          そのトークンを`yytext'の末尾に付加するようFlexに通知する関数です。

    `yyless(N)'
          `yymore()'とほぼ反対のことを行います。 この関数は、
          最初のN文字を除くすべての文字を戻します。
          戻された文字の並びは、
          次のトークンをマッチするのに使われます。
          `yyleng'と`yytext'の内容には、 この変更が反映されます。

    `input()'
          入力から次の１文字を返します。 これは、
          標準のFlex記述言語や特にLex記述言語を使ったのではうまく処理できないようなスキャナにおいて、
          よく使われます。

    `unput(C)'
          この関数は、 文字Cを入力ストリームに戻します。 この後、
          この文字は次にスキャンされる文字になります。

    `yyterminate()'
          この関数は、 アクションの中で使われると、
          スキャナ（`yylex()'）の実行を終了させます。
          終了したスキャナは0を返します。
          この後`yyrestart()'が呼び出されない間は、
          `yylex()'を呼び出してもすぐに復帰してしまいます。

    `yyrestart(FILE)'
          この関数は、 スキャナの実行を再開するようFlexに通知します。
          これは、
          スキャンすべきファイル（通常は`yyin'）を表す引数を１つ取ります。
          EOFを処理するのに使うことができますし、 また、
          Flexに割り込みをかけ、
          その後で再開始することを可能にするために使うこともできます。
          （Flexが_再入可能ではない_ので、
          このようなことが必要になります。）

    `ECHO'
          `yytext'の内容を`yyout'にコピーするマクロです。

    `REJECT'
          カレントなトークンを認識しないで、
          次に最もよくマッチするものを選択するよう、
          スキャナに通知します。 スキャナは、
          マッチするもののうち最も長いものを探します。
          マッチするものが２つあってその長さが同じ場合には、
          スキャナ記述の中で最初に定義されているものを選択します。

    `BEGIN(STATE)'
          スキャナをある特定のスタート状態に置くために使われます。
          `BEGIN'の後ろの名前は、 スタート状態の名前です。 これは、
          スキャナ記述の先頭の定義セクションにおいて宣言されているものでなければなりません。

    `YY_USER_INIT'
          スキャナが初期化される_前_に実行されるべきアクションを定義します。
          詳細については、 *Note Flex and C::を参照してください。

    `YY_USER_ACTION'
          マッチが発生した後で、
          ルール・セクションに定義されたアクションが実行される_前_に、
          実行されるべきアクションを定義します。 例えば、
          `yytext'の内容を小文字から大文字へ変換する等を行うのに使うことができます。
          デフォルトのルールでは何も実行されません。 詳細については、
          *Note Flex and C::を参照してください。

    `YY_BREAK'
          実際にはインターフェイス機能ではなく、
          むしろ生成されるコードを変更するために使うことができるものです。

          スキャナの中では、
          すべてのアクションは１つの大きな`switch'文の構成要素であり、
          個々のアクションの区切りは、
          デフォルトで`break;'文に変換される`YY_BREAK'で与えられます。
          もし、
          ほとんどのルールのアクション部が`return;'文を含んでいると、
          コンパイラは`statement not
          reached'というエラーをたくさん表示することになるでしょう
          （表示するはずです）。 `YY_BREAK'を再定義することによって、
          この警告メッセージを表示させないようにすることが可能です。

          *注：*`YY_BREAK'を再定義する場合は、
          アクションが必ず`return;'か`break;'で終わるようにしてください。

    `YY_DECL'
          スキャン処理を実行する関数の名前を定義するマクロです。
          デフォルトは`yylex'ですが、 再定義することができます。
          再定義した名前は、
          関数のプロトタイプとして正当なものでなければなりません。

    `YY_INPUT'
          入力ルーチンの名前を定義するマクロです。 必要があれば、
          この名前は再定義することができます。 例えば、 文字列や、
          標準的ではない何らかの入力デバイスを入力として、
          スキャン処理を行う場合に役に立ちます。

    `YY_NEW_FILE'
          `yyin'が新しいファイルを指すよう設定されたこと、 および、
          処理が継続されるべきであることをFlexに通知するマクロです。(1)

    `YY_CURRENT_BUFFER'
          カレントな入力バッファを返すマクロです。

    `yy_create_buffer()'
          新しい入力バッファを作成するのに使われます。 この関数と、
          この後の２つの関数を使うことにより、 複数のバッファを作成し、
          バッファ間で切り替えることが可能になります。 *Note
          バッファを操作する関数: Buffer Manipulation。

    `yy_delete_buffer()'
          以前に作成された入力バッファを削除するのに使われます。

    `yy_switch_to_buffer()'
          複数の入力バッファの間で切り替えを行うのに使われます。

    `YY_BUFFER_STATE'
          バッファを処理するのに使われる_型_です。
          バッファのカレントなコンテキストを保持します。
          複数のバッファ間で切り替えを行う時には、
          この型の変数が必要になります。

    `YYSTYPE'
          Bisonファイル中の`%union'の型です。 これは、
          FlexとBisonの間のインターフェイスで使われます。

    `yylval'
          Bisonパーサのカレントなパース状態に関連するデータを保持する、
          Bisonパーサ中の変数です。 この変数を使うことで、
          データをFlexとBisonの間で渡すことができます。


   ---------- Footnotes ----------

   (1) 訳注：Flex 2.5では、
`yyin'を変更した後に`YY_NEW_FILE'を実行する必要はなくなりました。


File: flex-ja.info,  Node: Summary or Flex Variables and Functions (Flex 2.5),  Next: Summary of Flex Characters,  Prev: Summary or Flex Variables and Functions,  Up: Summary

10.4 Flex変数およびFlex関数の要約（Flex 2.5の補足情報）
=======================================================

Flex 2.5では、 前節（*Note Summary or Flex Variables and
Functions::）で説明されていない、
以下の関数やマクロもサポートされています。

    `yy_set_interactive()'
          カレント・バッファを、 対話的なものと見なすか、
          非対話的なものと見なすかを制御します。
          引数にゼロ以外の値を渡すと、
          カレント・バッファは対話的なものと見なされ、 ゼロを渡すと、
          非対話的なものと見なされます。

    `yy_set_bol()'
          バッファ内のカレントな位置が行の先頭にあるか否かを表すコンテキスト情報を設定します。
          引数にゼロ以外の値を渡すと、
          バッファ内のカレントな位置は行の先頭である、
          というコンテキスト情報がセットされます。 したがって、
          次にトークンのマッチ処理が行われる時には、
          行頭を表す`^'を含むルールの適用が試みられます。 逆に、
          引数にゼロを渡すと、
          バッファ内のカレントな位置は行の先頭ではないことになり、
          次にトークンのマッチ処理が行われる時には、
          行頭を表す`^'を含むルールの適用が試みられなくなります。

    `YY_AT_BOL()'
          次にトークンのマッチ処理が行われる時に、
          行頭を表す`^'を含むルールの適用が試みられるようなコンテキスト情報がセットされている場合には、
          ゼロ以外の値を返します。 それ以外の場合は、 ゼロを返します。

    `yy_new_buffer()'
          `yy_create_buffer'の別名です。

    `yy_flush_buffer()'
          引数で指定されたバッファの内容を破棄し、
          バッファの先頭２バイトに`YY_END_OF_BUFFER_CHAR'（`\0'）をセットします。

    `YY_FLUSH_BUFFER'
          引数にカレント・バッファを指定して`yy_flush_buffer()'を呼び出すよう定義されたマクロです。

    `yy_scan_string()'
          NULL文字で終端する文字列をスキャンするための入力バッファを作成します。
          実際には、 引数で渡された文字列のコピーがスキャンされます。

    `yy_scan_bytes()'
          引数で指定されたメモリ領域をスキャンするためのバッファを作成します。
          実際には、 メモリ領域上のデータのコピーがスキャンされます。

    `yy_scan_buffer()'
          引数で指定されたメモリ領域をスキャンするためのバッファを作成します。
          メモリ領域上のデータはコピーされません。

    `yy_push_state()'
          カレントなスタート状態をスタート状態スタックにプッシュし、
          引数で指定された状態に遷移します。

    `yy_pop_state()'
          スタート状態スタックからスタート状態をポップし、
          そのポップされたスタート状態に遷移します。

    `yy_top_state()'
          スタート状態スタックの先頭にあるスタート状態を返します
          （スタート状態スタックの内容は変更されません）。

    `yyFlexLexer::yylex()'
          C++スキャナにおいて実際にスキャン処理を行う関数です。

    `yyFlexLexer::LexerInput()'
          `yyFlexLexer'のサブクラスにおいて再定義することによって、
          C++スキャナの入力処理を変更することができます。

    `yyFlexLexer::LexerOutput()'
          `yyFlexLexer'のサブクラスにおいて再定義することによって、
          C++スキャナの出力処理を変更することができます。

    `yyFlexLexer::LexerError()'
          `yyFlexLexer'のサブクラスにおいて再定義することによって、
          C++スキャナのエラー・メッセージ出力処理を変更することができます。


File: flex-ja.info,  Node: Summary of Flex Characters,  Next: Summary of Flex Rules,  Prev: Summary or Flex Variables and Functions (Flex 2.5),  Up: Summary

10.5 Flex文字の要約
===================

Flexにおける基本的な構成要素の１つに、 文字があります。 基本的にFlexは、
演算子、特殊文字、エスケープ・シーケンスを除いて、
文字をそのまま受け付けます。 エスケープ・シーケンスは、 ANSI
Cに見られるものと同一です。 Flexの演算子と特殊文字は以下のとおりです。

`文字'
     Flexの解釈

`\'
     バックスラッシュは、 ANSI
     Cのエスケープ・シーケンスで使われるのと同様の、
     エスケープ文字です。

`[ ]'
     角括弧[ ]は、
     文字の集合を"文字クラス"にグループ化するのに使われます。
     詳細については、 *Note Flexにおける文字のグループ化: Character
     Classes。

`^'
     文字クラスの中では、 `^'は否定を意味します。 詳細については、
     *Note Flexにおける文字のグループ化: Character Classes。 一方、
     文字クラスの外部では、 行の先頭を意味し、
     （エスケープされていない場合は）
     ルールの先頭にのみ置くことができます。

`-'
     ハイフンは、 文字クラスの中で文字の範囲を設定するのに使われます。
     文字クラスの外部では、 ハイフン自身を表します。 詳細については、
     *Note Flexにおける文字のグループ化: Character Classes。

`{ }'
     大括弧{ }は、
     定義の参照、複数行にわたるアクションの先頭と末尾の指定、
     またはパターンの繰り返し回数の範囲の定義を行います。

`( )'
     丸括弧( )は、 優先順位の変更に使われます。 また、
     定義は展開される時に、
     暗黙のうちに丸括弧で囲まれることに注意してください。

`""'
     二重引用符は、 文字列の範囲を示します。
     引用符で囲まれた範囲の中にある文字だけがマッチされます。

`/'
     スラッシュは、 後続コンテキスト（trailing context）を設定します。
     これは、 あるパターンを認識するのを、
     その後ろに別のパターンが続く場合に限定したい、 という場合です。
     これは、
     スラッシュ`/'が一種の「"ルック・アヘッド"（その先を見る）」演算子として機能することを意味します。

`< >'
     かぎ括弧< >は、
     スタート状態の参照、またはスタート状態のグループの参照を行い、
     さらに`EOF'シンボル（`<<EOF>>'）で使われます。
     これに関する完全な説明については、 *Note Start States::と*Note
     End-Of-File Rules::を参照してください。

`? + *'
     `?'、`+'、`*'の各文字は、
     ある_正規表現_が何回出現することができるかを指定するのに使われます。
     `?'は、
     ゼロ回もしくは１回（つまり、オプションであるということ）を、
     `+'は１回以上を、 `*'はゼロ回以上をそれぞれ意味します。

`|'
     OR演算子を表します。 また、
     カレントなルールに対するマッチが発生した場合、
     次に記述されているルールのアクションを実行するようFlexに通知する、
     特別なアクションを表します。

`$'
     ドル記号は行末を意味します。

ここに挙げた文字を、 その文字自身として表したい場合には、
その文字を引用符で囲む（例えば`"*"'）か、 または、
エスケープ・シーケンスとして表す必要があります。 詳細については、 *Note
Characters::。


File: flex-ja.info,  Node: Summary of Flex Rules,  Prev: Summary of Flex Characters,  Up: Summary

10.6 Flexルールの要約
=====================

Flexにおけるルールには２つの部分があります。
パターン・マッチング用の表現式とアクション部です。 この２つは、
以下のように配置されます。

     PATTERN ACTIONS

   Flexがマッチするパターンは、 正規表現を使って作られます。
そしてその正規表現は、
文字、文字列、定義、スタート状態、および演算子から作られます。
下の表は、 種々の正当な正規表現を示します。 表中において、
`c'は（エスケープ・シーケンスを含む）任意の単一文字を、
`r'は任意の正規表現を、 `s'は文字列を、 それぞれ表します。
表はグループ別に編成されていて、
優先度の最も高いものが一番上にあります。
                           Flexにおける正規表現
     =============+=============================================+================
     正規表現     |           マッチの対象                      |   例
     =============+=============================================+================
        c         | 特殊文字を除く任意の文字                    |  A、\n、a
        .         | 改行を除く任意の文字                        |    efg.*
        [s]       | クラスs中にある任意の文字                   |    [efg]
        [^s]      | クラスs中にない任意の文字                   |    [^moqs]
        r*        | ０個以上のr                                 |  (a|b)*、[abc]*
        r+        | １個以上のr                                 |    (a|b)+
        r?        | ０個または１個のr                           |  (a|[b-q])?
        r{x,y}    | x個以上y個以下のr                           |   foo{1,5}
                  | （abc{1,3}は、abと１個以上３個以下のc）     |
        "s"       | 字義どおりの文字列s                         |    "***"
        \c        | （\cがANSI Cにおいて特別な意味を持たない    |    \"  \*
                  |   場合）c                                   |
        (r)       | r − 丸括弧( )はグループ化のためのもの      |    (Aa|b)
                  |                                             |
        r1r2      | r1の後ろにr2が続くもの                      | Aa、(A|a)[0-9]
                  |                                             |
        r1|r2     | r1またはr2                                  |     A|B
                  |                                             |
        r1/r2     | r2が後ろに続くという条件を満足するr1        |    abc/123
        ^         | 行頭                                        |    ^foo
        $         | 行末                                        |    foo$
                  |                                             |
        <start>r  | スタート状態（start状態の時、rがアクティブ）|  <command>"*/"
        <<EOF>>   | ファイルの終端（End-Of-Fileルールを参照）   |    <<EOF>>

これは、
`sed'、`grep'、Emacsや正規表現を使う他の一般的なプログラムにおいて使われる正規表現と完全に同一ではないことに注意してください。

   ルールのアクション部は、 任意の正当なCコードです。
単一行に複数の文を書くことも可能ですし、 括弧の対`{...}'で囲むことで、
複数の文のブロックを複数行にわたって書くことも可能です。


File: flex-ja.info,  Node: Index,  Prev: Summary,  Up: Top

インデックス
************

 [index ]
* Menu:

* #line指示子、制御:                     Switches Summary.    (line  97)
* #line指示子とLex:                      Flex and POSIX.      (line 105)
* %array:                                %option (Flex 2.5).  (line 103)
* %option:                               %option (Flex 2.5).  (line   6)
* %pointer:                              %option (Flex 2.5).  (line 133)
* %s、詳細:                              Start States Explained.
                                                              (line  12)
* %x EOFを使用したサンプル:              Handling Comments.   (line  33)
* %x より長いテキストにマッチするサンプル: Handling Comments. (line  50)
* %x 複数行文字列を使用したサンプル:     Handling Strings.    (line 114)
* %x、詳細:                              Start States Explained.
                                                              (line  12)
* -+:                                    Switches Summary (Flex 2.5).
                                                              (line  34)
* --help:                                Switches Summary (Flex 2.5).
                                                              (line  66)
* --version:                             Switches Summary (Flex 2.5).
                                                              (line  70)
* -7:                                    Switches Summary (Flex 2.5).
                                                              (line  30)
* -8:                                    Switches Summary.    (line 113)
* -?:                                    Switches Summary (Flex 2.5).
                                                              (line  37)
* -b:                                    Switches Summary.    (line   8)
* -B:                                    Switches Summary (Flex 2.5).
                                                              (line  22)
* -c:                                    Switches Summary.    (line  17)
* -C[efmF]:                              Switches Summary.    (line 120)
* -Ca:                                   Switches Summary (Flex 2.5).
                                                              (line  41)
* -Cem、詳細:                            Table Compression and Scanner Speed.
                                                              (line  88)
* -Ce、詳細:                             Table Compression and Scanner Speed.
                                                              (line  61)
* -CF、詳細:                             Table Compression and Scanner Speed.
                                                              (line  70)
* -Cf、詳細:                             Table Compression and Scanner Speed.
                                                              (line  70)
* -Cm、詳細:                             Table Compression and Scanner Speed.
                                                              (line  79)
* -Cr:                                   Switches Summary (Flex 2.5).
                                                              (line  46)
* -d:                                    Switches Summary.    (line  27)
* -f:                                    Switches Summary.    (line  40)
* -F:                                    Switches Summary.    (line  83)
* -f、詳細:                              Table Compression and Scanner Speed.
                                                              (line  15)
* -F、詳細:                              Table Compression and Scanner Speed.
                                                              (line  32)
* -h:                                    Switches Summary (Flex 2.5).
                                                              (line   9)
* -i:                                    Switches Summary.    (line  46)
* -I:                                    Switches Summary.    (line  88)
* -I、詳細:                              Interactive Scanners.
                                                              (line   6)
* -i、詳細:                              The -i Switch.       (line   6)
* -l:                                    Switches Summary (Flex 2.5).
                                                              (line  12)
* -L:                                    Switches Summary.    (line  97)
* -n:                                    Switches Summary.    (line  53)
* -o:                                    Switches Summary (Flex 2.5).
                                                              (line  52)
* -p:                                    Switches Summary.    (line  57)
* -P:                                    Switches Summary (Flex 2.5).
                                                              (line  57)
* -s:                                    Switches Summary.    (line  62)
* -S:                                    Switches Summary.    (line 125)
* -T:                                    Switches Summary.    (line 104)
* -t:                                    Switches Summary.    (line  68)
* -V:                                    Switches Summary (Flex 2.5).
                                                              (line  27)
* -v:                                    Switches Summary.    (line  73)
* -w:                                    Switches Summary (Flex 2.5).
                                                              (line  18)
* .l、lexファイル:                       Invoking Flex.       (line  20)
* 16進定数:                              Handling Strings.    (line 114)
* 7bit、%option:                         %option (Flex 2.5).  (line  25)
* 8bit、%option:                         %option (Flex 2.5).  (line  28)
* 8進定数:                               Handling Strings.    (line 114)
* <*>:                                   Start State Notes (Flex 2.5).
                                                              (line   8)
* <<EOF>>、詳細:                         End-Of-File Rules.   (line   6)
* <<EOF>>とLex:                          Flex and POSIX.      (line 105)
* align、%option:                        %option (Flex 2.5).  (line  31)
* always-interactive、%option:           %option (Flex 2.5).  (line 107)
* array、%option:                        %option (Flex 2.5).  (line 103)
* backup、%option:                       %option (Flex 2.5).  (line  34)
* batch、%option:                        %option (Flex 2.5).  (line  37)
* BEGIN、スタート状態の活性化:           Activating States.   (line   6)
* BEGIN、詳細:                           Flex and C.          (line 525)
* BEGIN、要約:                           Summary or Flex Variables and Functions.
                                                              (line  84)
* Bison:                                 Flex and Bison.      (line   6)
* Bison文法の例:                         The Database Language.
                                                              (line   6)
* c++、%option:                          %option (Flex 2.5).  (line  40)
* C++とFlexのインターフェイス:           Flex and C++ (Flex 2.5).
                                                              (line   9)
* case-insensitive、%option:             %option (Flex 2.5).  (line  49)
* case-sensitive、%option:               %option (Flex 2.5).  (line  46)
* caseful、%option:                      %option (Flex 2.5).  (line  43)
* caseless、%option:                     %option (Flex 2.5).  (line  52)
* CとFlexのインターフェイス:             Flex and C.          (line   6)
* CとFlexのインターフェイス（Flex2.5補足）: Flex and C (Flex 2.5).
                                                              (line   6)
* Cとのインターフェイス:                 Optional C Code.     (line   6)
* Cコード、追加:                         Optional C Code.     (line   6)
* Cコメント、スキャン処理:               Handling Comments.   (line  10)
* Cコメントのスキャン処理:               Handling Comments.   (line  10)
* debug()、FlexLexer:                    Flex and C++ (Flex 2.5).
                                                              (line  58)
* debug、%option:                        %option (Flex 2.5).  (line  55)
* default、%option:                      %option (Flex 2.5).  (line  58)
* ECHO:                                  Summary or Flex Variables and Functions.
                                                              (line  73)
* ECHO、サンプル:                        Table Compression and Scanner Speed.
                                                              (line  43)
* ECHOとoutput():                        Flex and POSIX.      (line  38)
* ecs、%option:                          %option (Flex 2.5).  (line  61)
* End-Of-File、取り扱い:                 End-Of-File Rules.   (line   6)
* fast、%option:                         %option (Flex 2.5).  (line  64)
* FlexLexer:                             Flex and C++ (Flex 2.5).
                                                              (line  22)
* Flex、パターン・マッチング・ルール:    Rules.               (line   6)
* Flex、起動:                            Invoking Flex.       (line   6)
* Flex、使用法:                          Invoking Flex.       (line   6)
* Flex、入門:                            Introduction.        (line   6)
* Flexからのデータの返却:                Interfacing Flex and Bison.
                                                              (line   6)
* FlexとBisonのインターフェイス:         Flex and Bison.      (line   6)
* FlexとCのインターフェイス:             Summary or Flex Variables and Functions.
                                                              (line   6)
* FlexとCのインターフェイス（Flex2.5補足）: Summary or Flex Variables and Functions (Flex 2.5).
                                                              (line   6)
* FlexとLex、相違点:                     Flex and Lex.        (line   6)
* FlexとLexの相違点:                     Flex and Lex.        (line   6)
* Flexにおけるデータ型:                  Pattern Matching.    (line   6)
* Flexにおける正規表現:                  Summary of Flex Rules.
                                                              (line   6)
* Flexにおける文字:                      Characters.          (line   6)
* Flexにおける文字、要約:                Summary of Flex Characters.
                                                              (line   6)
* Flexにおける文字列:                    Strings.             (line   6)
* Flexの起動:                            Invoking Flex.       (line   6)
* Flexの使用:                            Invoking Flex.       (line   6)
* Flexコマンドライン・オプション:        Switches Summary.    (line   6)
* Flexコマンドライン・オプション（Flex 2.5補足）: Switches Summary (Flex 2.5).
                                                              (line   6)
* Flexデータ型:                          Pattern Matching.    (line   6)
* Flexルール:                            Pattern Matching.    (line   6)
* Flexルール、要約:                      Summary of Flex Rules.
                                                              (line   6)
* Flex関数とFlex変数:                    Flex and C.          (line   6)
* Flex記述:                              Flex Descriptions.   (line   6)
* Flex正規表現:                          Summary of Flex Rules.
                                                              (line   6)
* Flex入門:                              Introduction.        (line   6)
* Flex文字:                              Characters.          (line   6)
* Flex文字、要約:                        Summary of Flex Characters.
                                                              (line   6)
* Flex文字クラス:                        Character Classes.   (line   6)
* Flex文字列:                            Strings.             (line   6)
* front.lex:                             The Implementation.  (line 116)
* front.y:                               The Implementation.  (line  13)
* full、%option:                         %option (Flex 2.5).  (line  67)
* input()、LexとFlexの相違点:            Flex and POSIX.      (line  29)
* input()、サンプル:                     Handling Comments.   (line  10)
* input()、詳細:                         Flex and C.          (line 261)
* input()、要約:                         Summary or Flex Variables and Functions.
                                                              (line  47)
* interactive、%option:                  %option (Flex 2.5).  (line  70)
* Lex:                                   Lex.                 (line   6)
* lex-compat、%option:                   %option (Flex 2.5).  (line  73)
* lex.yy.c:                              Invoking Flex.       (line  27)
* lex.yy.cc:                             Flex and C++ (Flex 2.5).
                                                              (line  11)
* LexerError()、yyFlexLexer:             Flex and C++ (Flex 2.5).
                                                              (line 125)
* LexerInput()、yyFlexLexer:             Flex and C++ (Flex 2.5).
                                                              (line 111)
* LexerOutput()、yyFlexLexer:            Flex and C++ (Flex 2.5).
                                                              (line 120)
* lexに対するCのインターフェイス:        Flex and C.          (line   6)
* lineno()、FlexLexer:                   Flex and C++ (Flex 2.5).
                                                              (line  55)
* main、%option:                         %option (Flex 2.5).  (line 114)
* meta-ecs、%option:                     %option (Flex 2.5).  (line  76)
* never-interactive、%option:            %option (Flex 2.5).  (line 126)
* output():                              Flex and POSIX.      (line  38)
* output、%option:                       %option (Flex 2.5).  (line  79)
* Pascalコメント、スキャン処理:          Example-Pascal Lexical Scanner.
                                                              (line  25)
* Pascalコメントのスキャン処理:          Example-Pascal Lexical Scanner.
                                                              (line  25)
* perf-report、%option:                  %option (Flex 2.5).  (line  82)
* pointer、%option:                      %option (Flex 2.5).  (line 133)
* POSIX:                                 Flex and POSIX.      (line   6)
* prefix、%option:                       %option (Flex 2.5).  (line  85)
* Ratforスキャナ:                        Flex and POSIX.      (line  46)
* read、%option:                         %option (Flex 2.5).  (line  88)
* reject、%option:                       %option (Flex 2.5).  (line 137)
* REJECT、詳細:                          Flex and C.          (line 449)
* set_debug()、FlexLexer:                Flex and C++ (Flex 2.5).
                                                              (line  61)
* stack、%option:                        %option (Flex 2.5).  (line 143)
* stdinit、%option:                      %option (Flex 2.5).  (line 148)
* stdout、%option:                       %option (Flex 2.5).  (line  91)
* switch_streams()、FlexLexer:           Flex and C++ (Flex 2.5).
                                                              (line  66)
* unput()、詳細:                         Flex and C.          (line 314)
* unput()、要約:                         Summary or Flex Variables and Functions.
                                                              (line  52)
* unput、%option:                        %option (Flex 2.5).  (line 154)
* verbose、%option:                      %option (Flex 2.5).  (line  94)
* warn、%option:                         %option (Flex 2.5).  (line  97)
* Yacc:                                  Flex and Bison.      (line   6)
* YY_AT_BOL()、詳細:                     Flex and C (Flex 2.5).
                                                              (line  39)
* YY_AT_BOL()、要約:                     Summary or Flex Variables and Functions (Flex 2.5).
                                                              (line  29)
* YY_BREAK、詳細:                        Flex and C.          (line 670)
* YY_BREAK、要約:                        Summary or Flex Variables and Functions.
                                                              (line 101)
* YY_BUF_SIZE:                           Buffer Manipulation. (line  15)
* YY_BUFFER_STATE:                       Summary or Flex Variables and Functions.
                                                              (line 150)
* yy_create_buffer():                    Buffer Manipulation. (line   9)
* yy_create_buffer()、FlexLexer:         Flex and C++ (Flex 2.5).
                                                              (line  66)
* YY_CURRENT_BUFFER:                     Buffer Manipulation. (line  33)
* YY_DECL、詳細:                         Flex and C.          (line  78)
* YY_DECL、要約:                         Summary or Flex Variables and Functions.
                                                              (line 119)
* yy_delete_buffer():                    Buffer Manipulation. (line  29)
* yy_delete_buffer()、FlexLexer:         Flex and C++ (Flex 2.5).
                                                              (line  66)
* yy_flex_debug、FlexLexer:              Flex and C++ (Flex 2.5).
                                                              (line  38)
* yy_flush_buffer()、詳細:               Buffer Manipulation (Flex 2.5).
                                                              (line  14)
* yy_flush_buffer()、要約:               Summary or Flex Variables and Functions (Flex 2.5).
                                                              (line  37)
* YY_FLUSH_BUFFER、詳細:                 Buffer Manipulation (Flex 2.5).
                                                              (line  18)
* YY_FLUSH_BUFFER、要約:                 Summary or Flex Variables and Functions (Flex 2.5).
                                                              (line  41)
* YY_INPUT、再定義:                      Flex and C.          (line 105)
* YY_INPUT、要約:                        Summary or Flex Variables and Functions.
                                                              (line 125)
* YY_INPUTの再定義:                      Flex and C.          (line 105)
* yy_new_buffer()、詳細:                 Buffer Manipulation (Flex 2.5).
                                                              (line  11)
* yy_new_buffer()、要約:                 Summary or Flex Variables and Functions (Flex 2.5).
                                                              (line  34)
* YY_NEW_FILE、詳細:                     Flex and C.          (line 399)
* YY_NEW_FILE、要約:                     Summary or Flex Variables and Functions.
                                                              (line 131)
* yy_pop_state()、詳細:                  Start State Notes (Flex 2.5).
                                                              (line  95)
* yy_pop_state()、要約:                  Summary or Flex Variables and Functions (Flex 2.5).
                                                              (line  60)
* yy_pop_state、%option:                 %option (Flex 2.5).  (line 158)
* yy_push_state()、詳細:                 Start State Notes (Flex 2.5).
                                                              (line  91)
* yy_push_state()、要約:                 Summary or Flex Variables and Functions (Flex 2.5).
                                                              (line  56)
* yy_push_state、%option:                %option (Flex 2.5).  (line 165)
* yy_scan_buffer()、詳細:                Buffer Manipulation (Flex 2.5).
                                                              (line  47)
* yy_scan_buffer()、要約:                Summary or Flex Variables and Functions (Flex 2.5).
                                                              (line  52)
* yy_scan_buffer、%option:               %option (Flex 2.5).  (line 173)
* yy_scan_bytes()、詳細:                 Buffer Manipulation (Flex 2.5).
                                                              (line  34)
* yy_scan_bytes()、要約:                 Summary or Flex Variables and Functions (Flex 2.5).
                                                              (line  48)
* yy_scan_bytes、%option:                %option (Flex 2.5).  (line 178)
* yy_scan_string()、詳細:                Buffer Manipulation (Flex 2.5).
                                                              (line  28)
* yy_scan_string()、要約:                Summary or Flex Variables and Functions (Flex 2.5).
                                                              (line  44)
* yy_scan_string、%option:               %option (Flex 2.5).  (line 183)
* yy_set_bol()、詳細:                    Flex and C (Flex 2.5).
                                                              (line  20)
* yy_set_bol()、要約:                    Summary or Flex Variables and Functions (Flex 2.5).
                                                              (line  17)
* yy_set_interactive()、詳細:            Flex and C (Flex 2.5).
                                                              (line   9)
* yy_set_interactive()、要約:            Summary or Flex Variables and Functions (Flex 2.5).
                                                              (line  10)
* YY_START:                              Start State Notes (Flex 2.5).
                                                              (line  29)
* yy_switch_to_buffer()、FlexLexer:      Flex and C++ (Flex 2.5).
                                                              (line  66)
* yy_switch_to_buffer()、詳細:           Buffer Manipulation. (line  20)
* yy_switch_to_buffer()、要約:           Summary or Flex Variables and Functions.
                                                              (line 147)
* yy_top_state()、詳細:                  Start State Notes (Flex 2.5).
                                                              (line  99)
* yy_top_state()、要約:                  Summary or Flex Variables and Functions (Flex 2.5).
                                                              (line  64)
* yy_top_state、%option:                 %option (Flex 2.5).  (line 188)
* YY_USER_ACTION、詳細:                  Flex and C.          (line 540)
* YY_USER_ACTION、要約:                  Summary or Flex Variables and Functions.
                                                              (line  93)
* YY_USER_INIT、詳細:                    Flex and C.          (line 585)
* YY_USER_INIT、要約:                    Summary or Flex Variables and Functions.
                                                              (line  89)
* YYBREAKとともに使用されるbreak:        Flex and C.          (line 670)
* yyclass、%option:                      %option (Flex 2.5).  (line 195)
* yyFlexLexer:                           Flex and C++ (Flex 2.5).
                                                              (line  82)
* yyFlexLexer::LexerError()、詳細:       Flex and C++ (Flex 2.5).
                                                              (line 125)
* yyFlexLexer::LexerError()、要約:       Summary or Flex Variables and Functions (Flex 2.5).
                                                              (line  79)
* yyFlexLexer::LexerInput()、詳細:       Flex and C++ (Flex 2.5).
                                                              (line 111)
* yyFlexLexer::LexerInput()、要約:       Summary or Flex Variables and Functions (Flex 2.5).
                                                              (line  71)
* yyFlexLexer::LexerOutput()、詳細:      Flex and C++ (Flex 2.5).
                                                              (line 120)
* yyFlexLexer::LexerOutput()、要約:      Summary or Flex Variables and Functions (Flex 2.5).
                                                              (line  75)
* yyFlexLexer::yylex()、詳細:            Flex and C++ (Flex 2.5).
                                                              (line  82)
* yyFlexLexer::yylex()、要約:            Summary or Flex Variables and Functions (Flex 2.5).
                                                              (line  68)
* yyin:                                  Flex and C.          (line  95)
* yyin、リセットの例:                    Example-Counting Words.
                                                              (line  13)
* yyin、要約:                            Summary or Flex Variables and Functions.
                                                              (line  15)
* yyinとソケット:                        Miscellaneous.       (line  38)
* yyleng:                                Flex and C.          (line 159)
* YYLeng()、FlexLexer:                   Flex and C++ (Flex 2.5).
                                                              (line  47)
* yyleng、FlexLexer:                     Flex and C++ (Flex 2.5).
                                                              (line  30)
* yyleng、unput():                       Flex and POSIX.      (line  62)
* yyleng、要約:                          Summary or Flex Variables and Functions.
                                                              (line  26)
* yyless()、詳細:                        Flex and C.          (line 240)
* yyless()、要約:                        Summary or Flex Variables and Functions.
                                                              (line  40)
* yylex()、FlexLexer:                    Flex and C++ (Flex 2.5).
                                                              (line  50)
* yylex()、再定義:                       Flex and C.          (line  78)
* yylex()、詳細:                         Flex and C.          (line  19)
* yylex()、要約:                         Summary or Flex Variables and Functions.
                                                              (line  11)
* yylex()とyyterminate():                Flex and C.          (line 381)
* yylex()の再定義:                       Flex and C.          (line  78)
* yylineno:                              Flex and POSIX.      (line  50)
* yylineno、%option:                     %option (Flex 2.5).  (line 205)
* yylineno、FlexLexer:                   Flex and C++ (Flex 2.5).
                                                              (line  33)
* yylval、説明:                          YYSTYPE and yylval.  (line   6)
* yylval、要約:                          Summary or Flex Variables and Functions.
                                                              (line 160)
* yymore()、詳細:                        Flex and C.          (line 177)
* yymore()、要約:                        Summary or Flex Variables and Functions.
                                                              (line  36)
* yymore、%option:                       %option (Flex 2.5).  (line 208)
* yyout:                                 Flex and C.          (line 126)
* yyout、要約:                           Summary or Flex Variables and Functions.
                                                              (line  19)
* yyoutとソケット:                       Miscellaneous.       (line  38)
* yyrestart()、FlexLexer:                Flex and C++ (Flex 2.5).
                                                              (line  66)
* yyrestart()、詳細:                     Flex and C.          (line 388)
* yyrestart()、要約:                     Summary or Flex Variables and Functions.
                                                              (line  63)
* yyrestart()とLex:                      Flex and POSIX.      (line 105)
* YYSTYPE:                               Notes on the Implementation.
                                                              (line   8)
* YYSTYPE、Bisonとの関連:                YYSTYPE and yylval.  (line   6)
* YYSTYPE、Bisonファイルにおける%union型: Summary or Flex Variables and Functions.
                                                              (line 156)
* yyterminate()、詳細:                   Flex and C.          (line 381)
* yyterminate()、要約:                   Summary or Flex Variables and Functions.
                                                              (line  56)
* yyterminate()とLex:                    Flex and POSIX.      (line 105)
* YYText()、FlexLexer:                   Flex and C++ (Flex 2.5).
                                                              (line  44)
* yytext、FlexLexer:                     Flex and C++ (Flex 2.5).
                                                              (line  27)
* yytext、unput():                       Flex and POSIX.      (line  62)
* yytext、詳細:                          Flex and C.          (line 131)
* yytext、表示:                          Flex and C.          (line 446)
* yytext、要約:                          Summary or Flex Variables and Functions.
                                                              (line  22)
* yytextの長さへのアクセス:              Flex and C.          (line 159)
* yytext非互換性:                        Flex and POSIX.      (line  74)
* yywrap()、詳細:                        Flex and C.          (line 163)
* yywrap()、要約:                        Summary or Flex Variables and Functions.
                                                              (line  29)
* yywrap()とEOF:                         Flex and C.          (line 163)
* yywrap()とPOSIX:                       Flex and POSIX.      (line  57)
* yywrap、%option:                       %option (Flex 2.5).  (line 214)
* エスケープ・シーケンス:                Characters.          (line 216)
* エスケープ・シーケンス、スキャン処理:  Handling Strings.    (line  11)
* エスケープ・シーケンスの取り扱い:      Handling Strings.    (line  11)
* コード・ブロック:                      %%.                  (line   6)
* コンテキスト依存スキャン処理:          Start States.        (line   6)
* コマンドライン・オプション <1>:        Command Line Switches.
                                                              (line   6)
* コマンドライン・オプション:            Switches Summary.    (line   6)
* コマンドライン・オプション（Flex 2.5補足）: Command Line Switches (Flex 2.5).
                                                              (line   6)
* スキャナ、対話型:                      Interactive Scanners.
                                                              (line   6)
* スキャナのデフォルト・アクション:      Rules.               (line  56)
* スキャナの再入可能性、yyrestart():     Flex and C.          (line 388)
* スキャナの最適化:                      Optimization.        (line   6)
* スキャナの振る舞いの動的な変更:        Start States.        (line   6)
* スキャナの生成結果のリダイレクト、-t:  Switches Summary.    (line  68)
* スキャンされたテキスト:                Flex and C.          (line 131)
* スキャンされたテキストの表示、ECHO:    Flex and C.          (line 446)
* スキャンされたテキストへのアクセス:    Flex and C.          (line 131)
* スキャン処理のスピード:                Table Compression and Scanner Speed.
                                                              (line   6)
* スタート状態:                          Start States.        (line   6)
* スタート状態、活性化:                  Activating States.   (line   6)
* スタート状態、使用:                    Start State Example. (line   6)
* スタート状態、排他的:                  Start State Notes.   (line  32)
* スタート状態の使用:                    Start States Explained.
                                                              (line   6)
* スタート状態の宣言:                    Start States.        (line   6)
* スタート状態スコープ:                  Start State Notes (Flex 2.5).
                                                              (line  53)
* スタート状態スタック:                  Start State Notes (Flex 2.5).
                                                              (line  84)
* スピードとテーブル・サイズ:            Optimization.        (line   6)
* メタ同等クラス:                        Table Compression and Scanner Speed.
                                                              (line  79)
* ユーザ定義のアクション:                Flex and C.          (line 540)
* ユーザ定義の初期化:                    Flex and C.          (line 585)
* テーブルの圧縮:                        Table Compression and Scanner Speed.
                                                              (line   6)
* テキストの返却:                        Flex and C.          (line 240)
* テキストの末尾への追加:                Flex and C.          (line 177)
* テキスト長:                            Flex and C.          (line 159)
* デフォルトの振る舞い、スキャナ:        An Example of Flex and C.
                                                              (line  84)
* ルール:                                Rules.               (line   6)
* ルールを使用した定義:                  Definitions.         (line  22)
* ルール定義:                            Rules.               (line   6)
* バッファ、複数:                        Multiple Input Buffers.
                                                              (line   6)
* バッファの操作:                        Multiple Input Buffers.
                                                              (line   6)
* パース言語:                            The Database Language.
                                                              (line   6)
* パターン、マッチング:                  Pattern Matching.    (line   6)
* パターン・マッチの拒絶:                Flex and C.          (line 449)
* パターンのマッチング:                  Pattern Matching.    (line   6)
* 関数と変数、要約:                      Summary or Flex Variables and Functions.
                                                              (line   6)
* 記述、Flex:                            Flex Descriptions.   (line   6)
* 記述、スキャナ:                        Flex Descriptions.   (line   6)
* 型付けされた入力:                      Interactive Scanners.
                                                              (line   6)
* 型付けされた入力のスキャン処理:        Interactive Scanners.
                                                              (line   6)
* 行数、カウント:                        Example-Pascal Lexical Scanner.
                                                              (line  25)
* 行数のカウント:                        Example-Pascal Lexical Scanner.
                                                              (line  25)
* 再帰 <1>:                              Flex and C.          (line 238)
* 再帰:                                  Handling Strings.    (line 221)
* 再入可能性とスキャナ:                  Summary or Flex Variables and Functions.
                                                              (line  63)
* 最適化:                                Optimization.        (line   6)
* 字句スキャナ:                          Introduction.        (line   6)
* 条件スキャン処理:                      Start States.        (line   6)
* 状態の振る舞いの設定:                  Start States.        (line   6)
* 大文字・小文字の無視:                  Case Insensitive Scanners.
                                                              (line   6)
* 対話型スキャナ:                        Interactive Scanners.
                                                              (line   6)
* 定義:                                  Definitions.         (line   6)
* 定義、コメント:                        Comments.            (line   6)
* 定義へのCコードの追加:                 Optional C Code.     (line   6)
* 定義ファイル中のコメント:              Comments.            (line   6)
* 同等クラス:                            Table Compression and Scanner Speed.
                                                              (line  61)
* 特殊なFlex機能:                        Other Flex Features. (line   6)
* 日付、スキャン処理:                    Start State Example. (line  10)
* 日付のスキャン処理:                    Start State Example. (line  10)
* 入力の変更:                            Multiple Input Buffers.
                                                              (line   6)
* 入力ストリームへのアクセス:            Flex and C.          (line 261)
* 入力ストリームへのテキストの追加:      Flex and C.          (line 314)
* 入力バッファ:                          Multiple Input Buffers.
                                                              (line   6)
* 入力バッファ、複数の使用:              Example of Multiple Buffers.
                                                              (line   6)
* 排他的スタート状態:                    Start State Notes.   (line  32)
* 標準出力:                              Flex and C.          (line 126)
* 不当な名前:                            Example-Pascal Lexical Scanner.
                                                              (line  25)
* 複数バッファを使う実例:                Example of Multiple Buffers.
                                                              (line   6)
* 文字のグループ化:                      Character Classes.   (line   6)
* 文字クラス:                            Character Classes.   (line   6)
* 文字クラス式:                          Character Class Expressions (Flex 2.5).
                                                              (line   9)
* 翻訳テーブル:                          Translation Tables.  (line   6)
* 名前、不当:                            Example-Pascal Lexical Scanner.
                                                              (line  25)
* 例、スタート状態:                      Start State Example. (line   6)



Tag Table:
Node: Top1000
Node: Introduction7031
Node: Problem Solving10521
Node: General Programming12601
Node: Invoking Flex14149
Node: Command Line Switches15501
Node: Command Line Switches (Flex 2.5)19180
Node: Flex Descriptions23264
Node: Comments24675
Node: Optional C Code25407
Node: Definitions26877
Ref: Definitions-Footnote-128752
Node: %%28894
Node: Rules29187
Node: Pattern Matching31610
Node: Characters32496
Ref: Characters-Footnote-141122
Ref: Characters-Footnote-241264
Node: Strings41406
Node: Character Classes42384
Node: Character Class Expressions (Flex 2.5)44148
Node: Regular Expressions45581
Node: Start States49345
Node: Start States Explained50468
Node: Activating States53395
Node: Start State Notes54689
Ref: Start State Notes-Footnote-157476
Node: Start State Notes (Flex 2.5)57611
Node: Start State Example61031
Node: %option (Flex 2.5)68513
Ref: %option (Flex 2.5)-Footnote-174797
Node: Interfacing to Flex75012
Ref: Interfacing to Flex-Footnote-176023
Node: Flex and C76088
Ref: Flex and C-Footnote-1101677
Ref: Flex and C-Footnote-2101996
Ref: Flex and C-Footnote-3102147
Ref: Flex and C-Footnote-4102247
Node: Flex and C (Flex 2.5)102342
Node: An Example of Flex and C104422
Node: Flex and Bison108337
Node: Interfacing Flex and Bison109836
Node: YYSTYPE and yylval114512
Node: Another Example of Flex and Bison116125
Node: The Database Language116927
Node: The Implementation119206
Node: Notes on the Implementation124472
Node: Flex and C++ (Flex 2.5)125460
Node: Other Flex Features130830
Node: Case Insensitive Scanners131834
Node: The -i Switch133401
Node: Interactive Scanners134733
Node: Table Compression and Scanner Speed136557
Ref: Table Compression and Scanner Speed-Footnote-1141664
Node: Translation Tables141842
Node: Multiple Input Buffers143001
Node: Buffer Manipulation144249
Node: Buffer Manipulation (Flex 2.5)145816
Node: Example of Multiple Buffers148385
Node: End-Of-File Rules150960
Node: Optimization153304
Node: Optimizing for Speed154065
Node: Removing Backtracking157454
Node: Optimizing for Size161399
Node: More Examples162993
Node: Example-Counting Words163650
Node: Example-Pascal Lexical Scanner166958
Node: Example-Jargon Converter171713
Ref: Example-Jargon Converter-Footnote-1188904
Node: Flex and Lex188976
Node: Flex189546
Node: Flex and POSIX190463
Ref: Flex and POSIX-Footnote-1194694
Ref: Flex and POSIX-Footnote-2194836
Ref: Flex and POSIX-Footnote-3194867
Ref: Flex and POSIX-Footnote-4195047
Ref: Flex and POSIX-Footnote-5195138
Ref: Flex and POSIX-Footnote-6195232
Ref: Flex and POSIX-Footnote-7195362
Node: Flex and POSIX (Flex 2.5)195432
Node: Lex195944
Node: Useful Code197829
Node: Handling Comments198661
Node: Handling Strings200757
Node: Handling Numbers208620
Node: Multiple Scanners215543
Ref: Multiple Scanners-Footnote-1217568
Ref: Multiple Scanners-Footnote-2217769
Node: Miscellaneous217901
Node: Summary219255
Node: Switches Summary220173
Ref: Switches Summary-Footnote-1225611
Node: Switches Summary (Flex 2.5)225677
Node: Summary or Flex Variables and Functions228413
Ref: Summary or Flex Variables and Functions-Footnote-1234931
Node: Summary or Flex Variables and Functions (Flex 2.5)235026
Node: Summary of Flex Characters238441
Node: Summary of Flex Rules241344
Node: Index244425

End Tag Table
