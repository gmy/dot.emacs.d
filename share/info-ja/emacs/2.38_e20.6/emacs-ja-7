Info file: emacs-ja,    -*-Text-*-
produced by `texinfo-format-buffer'
from file `emacs.texi'
using `texinfmt.el' version 2.38 of 3 July 1998.


Emacs 20.6版対応に改訂した`GNU Emacs Manual' 13版です.

INFO-DIR-SECTION Editors
START-INFO-DIR-ENTRY
* Emacs: (emacs).	The extensible self-documenting text editor.
END-INFO-DIR-ENTRY


Published by the Free Software Foundation 59 Temple Place, Suite 330
Boston, MA 02111-1307 USA

Copyright (C) 1985, 1986, 1987, 1993, 1994, 1995, 1996, 1997, 1998,
1999 Free Software Foundation, Inc.

Permission is granted to make and distribute verbatim copies of this
manual provided the copyright notice and this permission notice are
preserved on all copies.

Permission is granted to copy and distribute modified versions of this
manual under the conditions for verbatim copying, provided also that
the sections entitled "The GNU Manifesto", "Distribution" and "GNU
General Public License" are included exactly as in the original, and
provided that the entire resulting derived work is distributed under
the terms of a permission notice identical to this one.

Permission is granted to copy and distribute translations of this
manual into another language, under the above conditions for modified
versions, except that the sections entitled "The GNU Manifesto",
"Distribution" and "GNU General Public License" may be included in a
translation approved by the Free Software Foundation instead of in the
original English.





File: emacs-ja, Node: Fontsets, Next: Defining Fontsets, Prev: Specify Coding, Up: International

フォントセット
==============

Xウィンドウシステムのフォントは, 典型的には, 1つのアルファベットや文字
集合の形を定義しています.  したがって, Emacsが扱える文字の範囲全体を表
示するには, たくさんのフォントを集めたものが必要です.  Emacsでは, そう
いったフォントを集めたものを"フォントセット"（fontset）と呼びます.  フォ
ントセットは, ある文字コード範囲を扱うフォントのリストで定義されます.

各フォントセットには, フォントと同様に名前があります.  使用可能なXのフォ
ントは, Xサーバーが定義します.  しかし, フォントセットはEmacsの中で定
義されます.  いったんフォントセットを定義すれば, フォントを使える場面
ではどこでも, その名前を指定してEmacs内のフォントセットを使用できます. 
もちろん, Emacsのフォントセットでは, Xサーバーで使えるフォントだけを使
えます.  ある文字が画面で中抜きの箱で表示されたなら, その文字に使用し
たフォントセットには, その文字に対するフォントがないことを意味します.

Emacsは, "標準フォントセット"と"スタートアップフォントセット"の2つのフォ
ントセットを自動的に作ります.  標準フォントセットは, 非ASCII文字向けの
広い範囲のフォントをもっとも持ちそうなものです.  しかし, これは, Emacs
が使うデフォルトではありません.  （デフォルトでは, Emacsはボールドとイ
タリックの変種のフォントをみつけようとする. ）オプション`-fn'やXのリソー
ス`Font'（*Note Font X::）で使用する標準フォントセットを指定できます. 
たとえば, つぎのようにします.

     emacs -fn fontset-standard

フォントセットが, すべての文字コードに対するフォントを指定する必要はあ
りません.  フォントセットが, ある文字に対してフォントを指定していない, 
あるいは, システムに存在しないフォントを指定している場合には, その文字
を正しく表示できません.  そのかわりに, 中抜きの箱を表示します.

フォントセットの高さと幅は, ASCII文字で決定されます（つまり, そのフォ
ントセット内でASCII文字用に使われるフォント）.  フォントセットのあるフォ
ントが異なる高さや幅を持つ場合には, そのフォントを割り当てられた文字は, 
フォントセットの大きさに切り詰められます.  `highlight-wrong-size-font'
が`nil'以外ならば, これらのまちがった大きさの文字は箱で囲まれて表示さ
れます.



File: emacs-ja, Node: Defining Fontsets, Next: Single-Byte European Support, Prev: Fontsets, Up: International

フォントセットの定義方法
========================

Emacsは`standard-fontset-spec'の値に従って, 自動的に標準フォントセット
を作ります.  フォントセットの名前はつぎのとおりです.

     -*-fixed-medium-r-normal-*-16-*-*-*-*-*-fontset-standard

または, 省略して`fontset-standard'です.

標準フォントセットのボールド, イタリック, ボールドイタリックの変種も自
動的に作られます.  それらの名前は, `medium'のかわりに`bold', `r'のかわ
りに`i', あるいは, 両方ともそのようになります.

リソース`Font'やオプション`-fn'で, デフォルトのASCIIフォントを指定する
と, Emacsはそれから自動的にフォントセットを生成します.  これが, "スター
トアップフォントセット"で, その名前は`fontset-startup'です.  これは, 
フォント名のフィールド, FOUNDRY, FAMILY, ADD_STYLE, AVERAGE_WIDTHを`*'
で, CHARSET_REGISTRYを`fontset'で, CHARSET_ENCODINGを`startup'で置き換
えて得られた文字列をフォントセットの指定に使用します.

たとえば, Emacsをつぎのように起動します.

     emacs -fn "*courier-medium-r-normal--14-140-*-iso8859-1"

Emacsがつぎのフォントセットを生成して, Xウィンドウの初期フレームに使い
ます.

     -*-*-medium-r-normal-*-14-140-*-*-*-*-fontset-startup

Xのリソース`Emacs.Font'で, フォントセット名を実際のフォント名のように
指定できます.  しかし, `Emacs*Font'のようなワイルドカードを使ったリソー
スにフォントセット名を指定しないように注意してください.  ワイルドカー
ドを使った指定は, フォントセットを扱えないメニューのような, 他のさまざ
まな目的にも適用されます.

`Fontset-N'という名前のXのリソースを使って追加フォントセットを指定でき
ます.  ただし, Nは0から始まる整数です.  リソースの値はつぎのような形式
でなければなりません.

     FONTPATTERN, [CHARSETNAME:FONTNAME]...

FONTPATTERNは, 最後の2つのフィールドを除いて, 標準のXフォント名の形式
でなければなりません.  最後の2つのフィールドは, `fontset-ALIAS'の形式
を持つべきです.

フォントセットには2つの名前, 長い名前と短い名前があります.  長い名前は
FONTPATTERNです.  短い名前は`fontset-ALIAS'です.  どちらの名前でもフォ
ントセットを参照できます.

`CHARSET:FONT'という構成は, ある文字集合に対して（このフォントセットで
は）どのフォントを使用するかを指定します.  ここでCHARSETは, 文字集合の
名前で, FONTはその文字集合に使用するフォントです.  1つのフォントセット
の定義の中では, この構成を何度でも使用できます.

他の文字集合に対しては, EmacsはFONTPATTERNに基づいて選択します.  これ
には, 文字集合を記述する値で`fontset-ALIAS'を置き換えます.  ASCII文字
フォントに対しては, `fontset-ALIAS'を`ISO8859-1'で置き換えます

これに加えて, いくつか連続したフィールドがワイルドカードであるなら,
Emacsはそれらを1つのワイルドカードにまとめます.  これは, 自動的に拡大
縮小したフォントの使用を避けるためです.  大きめのフォントを縮小したフォ
ントは編集には使えません.  また, 小さめのフォントを拡大したフォントも
便利ではありません.  というのは, Emacsがそうするように, もともと小さな
フォントを使うほうがよいからです.

したがって, FONTPATTERNがつぎのようであると,

     -*-fixed-medium-r-normal-*-24-*-*-*-*-*-fontset-24

ASCII文字に対するフォント指定はつぎのようになります.

     -*-fixed-medium-r-normal-*-24-*-ISO8859-1

また, Chinese GB2312文字に対するフォント指定はつぎのようになります.

     -*-fixed-medium-r-normal-*-24-*-gb2312*-*

上のフォント指定に一致する中国語フォントがないかもしれません.  多くのX
の配布には, FAMILYフィールドが`song ti'か`fangsong ti'の中国語フォント
だけが含まれています.  そういった場合, `Fontset-N'をつぎのように指定し
ます.

     Emacs.Fontset-0: -*-fixed-medium-r-normal-*-24-*-*-*-*-*-fontset-24,\
             chinese-gb2312:-*-*-medium-r-normal-*-24-*-gb2312*-*

そうすると, Chinese GB2312の文字を除くフォント指定ではFAMILYフィールド
が`fixed'となり, Chinese GB2312の文字に対するフォント指定ではFAMILYフィー
ルドが`*'となります.

フォントセットのリソース値を処理してフォントセットを作る関数は,
`create-fontset-from-fontset-spec'です.  フォントセットを作るために, 
この関数を明示的に呼ぶこともできます.

Xにおけるフォントの命名法について詳しくは, *Note Font X::.



File: emacs-ja, Node: Single-Byte European Support, Next: Major Modes, Prev: Defining Fontsets, Up: International

1バイトヨーロッパ文字の使い方
=============================

ISO 8859 Latin-N文字集合は, さまざまなヨーロッパの言語で必要とされるア
クセント文字と句読点記号を扱うために, 160から250の範囲の文字コードを定
義しています.  マルチバイト文字を使用不可にしても, Emacsは, 一度にはこ
れらの文字コードの*1つ*を扱えます.  これらのコードの*どれ*を使うかを指
定するには, `M-x set-language-environment'を起動して, `Latin-N'のよう
な適切な言語環境を指定します.

ユニバイト操作についてより詳しくは, *Note Enabling Multibyte::を参照し
てください.  非ASCII文字を含んだ初期化ファイルをユニバイトで読むことを
保証したいときには特に注意してください.

端末や使っているフォントでこれらの文字を扱えるならば, Emacsはこれらの
文字を表示できます.  これは自動的に行われます.  あるいは, ウィンドウシ
ステムを使っている場合には, 現在の言語環境に従ってそれらに対応するマル
チバイト文字を表示することで, Emacsはフォントセットを介して1バイト文字
を表示できます.  これを行うには, 変数
`unibyte-display-via-language-environment'に`nil'以外の値を設定します.

もし, 端末でLatin-1文字集合を表示できなければ, Emacsは, これらの文字を
その文字が少なくとも何であるかを明確に理解できるようなASCII列として表
示できます.  これを行うには, ライブラリ`iso-ascii'をロードします.  他
のLatin-N文字集合に対しても似たようなライブラリを実装できますが, まだ
行っていません.

（文字128から159の）非ISO 8859文字は, 通常, 8進表示されます.  ライブラ
リ`disp-table'の関数`standard-display-8bit'を使えば, この表示を非標準
の「拡張」版のISO 8859文字集合に変更できます.

1バイト非ASCII文字を入力する異なる方法が3つあります.

   * キーボードが, 非ASCII文字を表現する128以上の文字コードを生成でき
     るならば, Emacsがそれらを理解できるようにつぎの式を実行する.

          (set-input-mode (car (current-input-mode))
                          (nth 1 (current-input-mode))
                          0)

   * 選択した言語環境の入力方式を使う.  *Note Input Methods::.  ユニバ
     イトのバッファで入力方式を使うと, 入力した非ASCII文字は, ユニバイ
     トに変換される.

   * Latin-1に対してだけだが, 非ASCIIのLatin-1の印字文字の入力の『合成
     文字』プレフィックスとして`C-x 8'を使える.  `C-x 8'は, （ミニバッ
     ファや他のバッファでの）挿入, 探索, キー列が許される他の文脈など
     で使える.

     ライブラリ`iso-transl'をロードすることで`C-x 8'は動作する.  ライ
     ブラリをロードしておくと, ALT修飾キーがあるならば, `C-x 8'と同じ
     目的で使用できる.  後続の文字を修飾するには, アクセント文字と一緒
     にALTを使う.  さらに, Latin-1の『専用アクセント文字』キーがあると,
     `iso-transl'をロード後は, それらのキーも後続の文字を合成するよう
     に定義される.


File: emacs-ja, Node: Major Modes, Next: Indentation, Prev: International, Up: Top

メジャーモード
**************

Emacsには, 多数の選択できる"メジャーモード"（major mode）があり, 各モー
ドは特定の種類のテキストを編集するためにEmacsをカスタマイズします.  メ
ジャーモードは相互に排他的で, 各バッファはいつでも1つのメジャーモード
だけを持ちます.  モード行は, 通常, 現行のメジャーモードの名前を括弧の
中に表示します（*Note Mode Line::）.

もっとも特殊化されていないメジャーモードは, "基本（fundamental）モード
"と呼ばれます.  このモードには, モード独自の再定義や変数設定がなく, 各
Emacsコマンドはもっとも一般的なふるまいをして, 各オプションはデフォル
トの状態になっています.  Lispや英文のように, Emacsが知っている特定の種
類のテキストを編集するには, Lispモードや, テキスト（text）モードのよう
な適切なメジャーモードに切り替えるべきです.

メジャーモードを選択することは, 編集対象の言語により明確に適応するよう
にキーの意味を多少変更することです.  よく変更されるキーはTAB, DEL,
`C-j'です.  プレフィックスキー`C-c'は, モード特有のコマンドを含みます. 
さらに, コメントを扱うコマンドは, モードを使ってコメントの区切り方を決
定します.  多くのメジャーモードでは, バッファ内に現れる文字の構文上の
属性を再定義しています.  *Note Syntax::.

メジャーモードは3つのグループに分けられます.  （いくつかの変種を有する）
Lispモード, Cモード, Fortranモード, その他のプログラム言語特有のモード
のグループがあります.  テキスト（text）モード, nroffモード, TeXとアウ
トライン（outline）モードなど英文を編集するためのものがあります.  残り
のメジャーモードは, ユーザーのファイルに使うためのものではありません.
Emacsが特別の目的のために作るバッファで使われます.  dired（*Note
Dired::）が作るバッファ向けのdiredモード（*Note Dired::）, `C-x m'で作
られるバッファ向けのメイル（mail）モード（*Note Sending Mail::）, 下位
のシェルプロセスとの通信用のバッファ向けのシェル（shell）モード（*Note
Interactive Shell::）などです.

ほとんどのプログラム言語用のメジャーモードでは, 段落の区切りは空行だけ
です.  これは, 段落コマンドを役立つようにするためです.  （*Note
Paragraphs::. ）また, これらのモードでは, 自動詰め込み（auto-fill）モー
ドにおいて, 新たに作った行を字下げするようにTABを定義します.  というの
は, プログラム中のほとんどの行は通常字下げされるからです.  （*Note
Indentation::. ）

* Menu:

* Choosing Modes::     How major modes are specified or chosen.



File: emacs-ja, Node: Choosing Modes, Next: Indentation, Prev: Major Modes, Up: Major Modes

メジャーモードの選択方式
========================

カレントバッファに対して明示的にメジャーモードを選択することもできます. 
しかし, たいていは, ファイル名やファイル内の特別のテキストに基づいて
Emacsはどのモードを使うかを決定します.

明示的に新しいメジャーモードを選択するには, `M-x'コマンドで行います. 
メジャーモードの名前に`-mode'を付け加えると, そのモードを選ぶコマンド
名になります.  したがって, Lispモードに入るには`M-x lisp-mode'を実行し
ます.

ファイルを訪問すると, Emacsは通常ファイル名に基づいて正しいメジャーモー
ドを選択します.  たとえば, `.c'で終る名前のファイルは, Cモードで編集さ
れます.  ファイル名とメジャーモードとの対応は, 変数`auto-mode-alist'で
制御します.  その値は, 要素がつぎのような形式のリストです.

     (REGEXP . MODE-FUNCTION)

または, つぎの形式です.

     (REGEXP MODE-FUNCTION FLAG)

たとえば, このリストに通常ある要素は, `("\\.c\\'". c-mode)'です.  これ
は, `.c'で終る名前のファイルにはCモードを選びます.  （Lispの構文では,
`\'を含めるには`\\'が必要.  また, `\'は, 正規表現の`.'の特別な意味を抑
制するために必要. ）リストの要素が`(REGEXP MODE-FUNCTION FLAG)'の形式
でFLAGが`nil'以外ならば, FUNCTIONを呼んだあとにREGEXPに一致する接尾辞
を捨てて, リストで他に一致するものをふたたび探します.

ファイルの空行でない最初の行の特別な種類のテキストによって, そのファイ
ルを編集するためにどのメジャーモードを使うかを指定できます.  モード名
は, その行に`-*-'で囲まれて現れます.  他のテキストがその行にあってもか
まいません.  たとえば,

     ;-*-Lisp-*-

は, EmacsにLispモードを使うように指示します.  このような明示的な指定は, 
ファイル名に基づいたメジャーモードに優先します.  この行がLispのコメン
トになるようにセミコロンを使っていることに注意してください.

モードを指定する別の書式は, つぎのとおりです.

     -*- mode: MODENAME;-*-

これは, 同様にローカル変数も指定できて, つぎのように書きます.

     -*- mode: MODENAME; VAR: VALUE; ... -*-

より詳しくは, *Note File Variables::.

ファイルの内容が`#!'で始まるときは, ファイルの1行目で指定したコマンド
インタープリタを実行することで, 実行可能なシェルコマンドとして働きます. 
ファイルの残りの部分は, インタープリタへの入力として使われます.

Emacsでそのようなファイルを訪問したとき, ファイルの名前がメジャーモー
ドを指定しないときには, Emacsはモードを選択するために1行目のインタープ
リタの名前を使います.  1行目が, `perl'や`tcl'のような認識されるインター
プリタプログラムの名前ならば, Emacsはインタープリタのプログラムにとっ
て適切なモードを使用します.  変数`interpreter-mode-alist'は, インター
プリタプログラム名とメジャーモードとの対応を指定します.

1行目が`#!'で始まるときには, インタープリタを実行するときにシステムが
混乱するため, 1行目では`-*-'の機能を使えません.  そのため, そのような
ファイルでは, Emacsは1行目に加えて2行目でも`-*-'を探します.

使用するメジャーモードを指定しないファイルを訪問したとき, あるいは,
`C-x b'で新たにバッファを作るときには, 変数`default-major-mode'が, 使
用するモードを指定します.  通常, その値は, 基本（fundamental）モードを
指定するシンボル`fundamental-mode'です.  `default-major-mode'が`nil'な
ら, メジャーモードはまえに選択していたバッファのモードと同じものとなり
ます.

バッファのメジャーモードを変更しても, Emacsが自動的に選択するメジャー
モードに戻れます.  それには, コマンド`M-x normal-mode'を使います.  こ
のコマンドは, メジャーモードを選択するために`find-file'が呼び出す関数
と同じ関数です.  この関数は, ファイル中にローカル変数リストがあればそ
れも処理します.

コマンド`C-x C-w'と`set-visited-file-name'は, 新しいファイル名がモード
を示すものであるなら, 新しいメジャーモードに変更します（*Note Saving::）. 
しかし, バッファの内容がメジャーモードを指定していて, かつ, ある『特別
な』メジャーモードがそのモードの変更を許さないなら, メジャーモードは変
更されません.  `change-major-mode-with-file-name'を`nil'に設定すると, 
このモード変更機能をオフにできます.


File: emacs-ja, Node: Indentation, Next: Text, Prev: Major Modes, Up: Top

字下げ
******

本章では, 字下げ（indentation）を付加／削除／調整するEmacsコマンドにつ
いて説明します.

`TAB'
     モードに固有の方法で, 現在行を『適切に』字下げする.
``C-j''
     RETに続けてTABを実行する（`newline-and-indent'）.
`M-^'
     2つの行を連結して1つにする（`delete-indentation'）.  `C-j'の効果
     を取り消す.
`C-M-o'
     ポイント位置で行を分割する.  つまり, 行内のポイント以降のテキスト
     は新たな行になり, かつ, ポイント位置まで字下げする（`split-line'）.
`M-m'
     現在行の空白でない最初の文字までポイントを（行末か行頭へ向かって）
     移動する（`back-to-indentation'）.
`C-M-\'
     複数の行を同じ桁に字下げする（`indent-region'）.
`C-x TAB'
     複数の行の塊を（右か左に）同じ量だけきっちり移動する
     （`indent-rigidly'）.
`M-i'
     ポイント位置からあらかじめ設定したつぎのタブストップ位置まで字下
     げする（`tab-to-tab-stop'）.
`M-x indent-relative'
     ポイント位置からまえの行の字下げ位置まで字下げする.

ほとんどのプログラム言語には, 字下げの慣習があります.  Lispコードでは, 
括弧の入れ子の深さに従って行を字下げします.  細部はかなり異なりますが, 
概念的にはCコードでも同様の考え方で字下げします.

どんな言語であっても, 行を字下げするにはTABコマンドを使います.  各メ
ジャーモードでは, 特定の言語に適した字下げを行うように, このコマンドを
定義します.  Lispモードでは, TABは括弧の深さに応じて行を整列します. 
行のどこでTABを打鍵しても, その行全体を整列します.  Cモードでは, TABは,
Cの構文上のさまざまな側面を考慮した巧みで洗練された字下げスタイルを実
現しています.

テキスト（text）モードでは, TABは`tab-to-tab-stop'コマンドを実行します. 
これは, つぎのタブストップ位置まで字下げを行います.  タブストップ位置
は`M-x edit-tab-stops'で設定できます.

* Menu:

* Indentation Commands::  Various commands and techniques for indentation.
* Tab Stops::             You can set arbitrary "tab stops" and then
                            indent to the next tab stop when you want to.
* Just Spaces::           You can request indentation using just spaces.



File: emacs-ja, Node: Indentation Commands, Next: Tab Stops, Prev: Indentation, Up: Indentation

字下げコマンドとその技巧
========================

行の字下げを飛び越えるには, `M-m'（`back-to-indentation'）を使います. 
行のどこで実行しても, その行の空白でない最初の文字位置にポイントを移動
します.

現在行のまえに字下げした行を挿入するには, `C-a C-o TAB'を使います.  現
在行のあとに字下げした行を挿入するには, `C-e C-j'を使います.

単にタブ文字を挿入するには, `C-q TAB'と打ちます.

`C-M-o'（`split-line'）は, ポイントから行末までのテキストを垂直に下ろ
します.  その結果, 現在行は2つの行に分割されます.  `C-M-o'は, まず, ポ
イントの直後に空白やタブがある限りポイントを進めます.  そして, ポイン
トの直後に, 改行とポイント位置の桁までに必要な字下げを挿入します.  ポ
イント自身は挿入した改行の直前に留まります.  この点では, `C-M-o'は
`C-o'に似ています.

2つの行を連結するには, コマンド`M-^'（`delete-indentation'）を使います. 
このコマンドは, 現在行の行頭の字下げと行区切り（改行文字）を削除して空
白1個に置き換えます.  ただし, この空白1個を省いてしまう（Lispコードに
は便利な）特別な場合があります.  2つの行を繋げた結果, 開き括弧や閉じ括
弧が連続する場合, あるいは, さらに改行が続く場合です.  現在行の字下げ
だけを削除するには, 行頭に移動してから`M-\'（`delete-horizontal-space'）
を使います.  このコマンドは, カーソル（ポイント）の周りの空白とタブを
すべて削除します.

詰め込み接頭辞がある場合, `M-^'は, 削除される改行の直後に現れる詰め込
み接頭辞を削除します.  *Note Fill Prefix::.

一度に複数の行の字下げを変更するコマンドもあります.  `C-M-\'
（`indent-region'）は, リージョン内で始まるすべての行に作用します.  こ
のコマンドは, 行頭でTABを打鍵したかのように『普通の』方法で各行を字下
げします.  数引数は字下げする桁位置を指定します.  つまり, 最初の空白で
ない文字がその桁位置にくるように行全体を右か左に水平移動します.  `C-x
TAB'（`indent-rigidly'）は, リージョン内のすべての行を, 引数で指定した
分だけ右に移動します（引数が負であれば左に移動）.  複数の行全部をきちっ
と揃えて（rigidly）横に移動することから, コマンドにはこのような名前が
付いています.

`M-x indent-relative'は, 先行する行（実際には空行でないいちばん近くの
行）に基づいてポイント位置を字下げします.  ポイント位置に空白を挿入し
てポイントを進めて, ポイントが先行する行の字下げ位置の真下にくるように
します.  字下げ位置とは連続した白文字の末尾か行末のことです.  ポイント
が先行する行のどの字下げ位置よりも右にある場合には, ポイントのまえの白
文字を削除してから, 先行する行の適用可能な最初の字下げ位置まで字下げし
ます.  適用可能な字下げ位置がない場合には, `indent-relative'は
`tab-to-tab-stop'を実行します（*Note Tab Stops::）.

字下げテキスト（indented text）モードでは, TABは`indent-relative'と定
義されます.  *Note Text::.

テキストの一部を字下げする別の方法については*Note Format
Indentation::.



File: emacs-ja, Node: Tab Stops, Next: Just Spaces, Prev: Indentation Commands, Up: Indentation

タブストップ
============

表を入力するには, テキスト（textモード）におけるTABの定義,
`tab-to-tab-stop'を利用できます.  このコマンドは, ポイントがつぎのタブ
ストップ位置に達するまでポイントのまえに字下げを挿入します.  テキスト
（text）モードでなくても, `M-i'でこのコマンドを実行できます.

`M-i'が使用するタブストップは任意に設定できます.  この設定は, 昇順に並
べた桁番号のリストとして`tab-stop-list'と呼ばれる変数に格納されます.

タブストップを設定する便利な方法は, `M-x edit-tab-stops'を使うことです. 
このコマンドは, タブストップの設定を記述したバッファを作成して選択しま
す.  このバッファを編集して今までとは異なるタブストップを指定し, `C-c
C-c'と打ってその新たな設定を有効にします.  `edit-tab-stops'は, 呼ばれ
たときのカレントバッファをあらかじめ記録しておくので, そのバッファに新
たなタブストップを設定します.  通常, 全バッファで同じタブストップを共
有しているので, 1つのバッファでタブストップを変更すると, すべてのバッ
ファに影響をします.  しかし, あるバッファで`tab-stop-list'をローカルに
しておくと, そのバッファで`edit-tab-stops'を実行するとローカルな設定を
編集します.

一般的に使われる8桁ごとに設定されたタブストップの場合, 設定用バッファ
の内容はつぎのようになります.

             :       :       :       :       :       :
     0         1         2         3         4
     0123456789012345678901234567890123456789012345678
     To install changes, type C-c C-c

1行目は, 各タブストップ位置をコロンで表します.  残りの行は, タブストッ
プ位置を読み取りやすくためや使い方です.

`tab-to-tab-stop'を制御するタブストップと, バッファ内でのタブ文字の表
示とは, 関係がないことに注意してください.  詳細については*Note Display
Vars::.



File: emacs-ja, Node: Just Spaces, Next: Text, Prev: Tab Stops, Up: Indentation

タブと空白
==========

Emacsでは, 通常, 行の字下げにはタブと空白の両方を使用します.  しかし, 
空白だけを用いて字下げを行うことも可能です.  そうするには, 変数
`indent-tabs-mode'に`nil'を設定します.  この変数はバッファごとの変数で
す.  変数を変更してもカレントバッファだけに影響しますが, デフォルト値
を変更することもできます.  *Note Locals::.

空白以外のテキストの桁を保存したまま, タブを空白（あるいはその逆）に変
換するコマンドもあります.  `M-x tabify'は, リージョン内の連続する空白
を探して, 字下げを変えることがなければ少なくとも連続する3個の空白をタ
ブに変換します.  `M-x untabify'は, リージョン内のすべてのタブを適切な
個数の空白に変換します.


File: emacs-ja, Node: Text, Next: Programs, Prev: Indentation, Up: Top

自然言語用のコマンド
********************

コンピュータの分野では, "テキスト"（text）という用語には2つの大きな意
味があります.  1つは, 文字の列から成るデータのことです.  この意味から
すれば, Emacsで編集するどんなファイルもテキストです.  もう1つの意味は
より限定されていて, 人間が読む自然言語の（テキスト整形処理後の場合もあ
るが）文字の列のことで, プログラムやプログラムに与えるコマンドと対比さ
れます.

自然言語には, エディタコマンドで支援したり利用したりできる構文的／様式
的な約束事があります.  たとえば, 単語, 文, 段落, 大文字といったもので
す.  本章では, これらを扱うEmacsコマンドについて述べます.  また, "詰め
込み"（filling）, つまり, 段落の各行がほぼ同じ長さになるように再配置し
直すコマンドについてもふれます.  単語, 文, 段落を横断してポイントを移
動したり, それらをキルするコマンドは, 自然言語テキストの編集を意図した
ものですが, プログラムの編集にも役立ちます.

Emacsには, 自然言語テキストの編集用のメジャーモードがいくつかあります. 
扱うテキストが純粋にテキストだけで単純なものであれば, テキスト（text）
モードを使いましょう.  これは, 自然言語テキストの構文上の約束事を扱え
るように, Emacsを少しだけカスタマイズしてあります.  アウトライン
（outline）モードには, アウトライン構造を持つテキストを操作する特別な
コマンドがあります.

テキスト整形コマンドを埋め込んだテキストに対しては, 特定のテキスト清書
系ごとに別のメジャーモードが用意してあります.  たとえば, TeX用にはTeX 
モードがあります.  nroff用にはnroffモードがあります.

テキスト清書系を使うかわりにエンリッチ（enriched）モードを使用すれば,
WYSIWYG（what you see is what you get, 『見たとおりを得る』）スタイル
で整形済みテキストを編集することもできます.  つまり, Emacsの画面上で整
形結果を見ながら編集できるわけです.

* Menu:

* Words::	        Moving over and killing words.
* Sentences::	        Moving over and killing sentences.
* Paragraphs::	        Moving over paragraphs.
* Pages::	        Moving over pages.
* Filling::	        Filling or justifying text.
* Case::	        Changing the case of text.
* Text Mode::	        The major modes for editing text files.
* Outline Mode::        Editing outlines.
* TeX Mode::	        Editing input to the formatter TeX.
* Nroff Mode::	        Editing input to the formatter nroff.
* Formatted Text::      Editing formatted text directly in WYSIWYG fashion.



File: emacs-ja, Node: Words, Next: Sentences, Prev: Text, Up: Text

単語
====

Emacsには, 単語を横断してポイントを移動したり, 単語を操作対象とするコ
マンドがあります.  慣例として, これらのコマンドのキーはメタ文字です.

`M-f'
     単語を横断してポイントを前向きに移動する（`forward-word'）.
`M-b'
     単語を横断してポイントを後向きに移動する（`backward-word'）.
`M-d'
     ポイント位置から単語の末尾までをキルする（`kill-word'）.
`M-DEL'
     ポイント位置から単語の先頭までを後向きにキルする
     （`backward-kill-word'）.
`M-@'
     つぎの単語の末尾にマークを設定する（`mark-word'）.
`M-t'
     隣接した2つの単語を入れ替える.  あるいは, 単語を複数の単語を飛び
     越して移す.  （`transpose-words'）.

これらのキーは, 文字単位の操作コマンド, `C-f', `C-b', `C-d', DEL,
`C-t'に対応していることに注目してください.  `M-@'も, `C-SPC'の別名であ
る`C-@'に対応しています.

コマンド`M-f'（`forward-word'）と`M-b'（`backward-word'）は, 単語を横
断してポイントを前向きに（末尾に向かって）あるいは後向きに（先頭に向かっ
て）移動します.  これらのメタ文字は, 文字単位でポイントを前後に移動す
るコントロール文字`C-f'や`C-b'に類似しています.  この類似性は, 数引数
を反復回数として扱うことにもおよびます.  負の引数を指定すると, `M-f'は
後向きに移動し, `M-b'は前向きに移動します.  前向き移動では単語の最後の
文字の直後に, 後向き移動では最初の文字の直前に, ポイントを移動しま
す. (1) (*Note Words-Footnotes::)

`M-d'（`kill-word'）はポイントの直後の単語をキルします.  正確にいえば, 
ポイント位置から`M-f'による移動位置までの全文字をキルします.  ポイント
が単語の途中にあれば, ポイントよりあとの部分だけをキルします.  また, 
ポイントとつぎの単語のあいだに句読点があれば, 単語と一緒にそれらもキル
します.  （つぎの単語だけをキルしてそのまえにある句読点を残したければ,
`M-f'でつぎの単語の末尾に移動してから, `M-DEL'でその単語を後向きにキル
する. ）`M-d'は, 引数を`M-f'と同様に解釈します.

`M-DEL'（`backward-kill-word'）は, 
ポイントの直前の単語をキルします. 
ポイント位置から`M-b'による移動位置までの全文字をキルします. 
ポイントが`FOO, BAR'の空白の直後にあるとすれば, 
`FOO, 'をキルします. 
（`FOO'だけをキルしてコンマと空白を残したければ, 
`M-DEL'のかわりに`M-b M-d'を使う. ）

`M-t'（`transpose-words'）は, 
ポイントの直前にある単語あるいはポイントを含む単語と, 
後続の単語とを入れ替えます. 
単語のあいだにある区切り文字は動きせん. 
たとえば, `FOO, BAR'を入れ替えると, 
`BAR FOO,'ではなく`BAR, FOO'となります. 
入れ替えや入れ替えコマンドの引数については, 
*Note Transpose::. 

ポイントとマークのあいだに適用される操作を後続のN個の単語に適用する方
法は, 2つあります.  ポイント位置にマークを設定してから, 単語を横断して
ポイントを移動します.  あるいは, コマンド`M-@'（`mark-word'）を使いま
す.  このコマンドは, ポイントを移動せずに, `M-f'による移動位置にマーク
を設定します.  `M-@'には, 何単語先にマークを設定するかを数引数で指定で
きます.  暫定マーク（transient-mark）モードでは, このコマンドはマーク
を活性にします.

単語操作コマンドが理解する構文は, すべて構文テーブルで制御されます. 
たとえば, 任意の文字を単語の区切り文字として宣言できます.  *Note
Syntax::.


File: emacs-ja  Node: Words-Footnotes, Up: Words

(1) 【訳注】なお, 移動方向に単語構成文字がない場合には, それらを飛び越
えてポイントを移動します.



File: emacs-ja, Node: Sentences, Next: Paragraphs, Prev: Words, Up: Text

文
==

Emacsの文／段落操作コマンドは, 単語操作コマンドと同じく, ほとんどメタ
キーです.

`M-a'
     文の先頭にポイントを後向きに移動する（`backward-sentence'）.
`M-e'
     文の末尾にポイントを前向きに移動する（`forward-sentence'）.
`M-k'
     ポイント位置から文末までを前向きにキルする（`kill-sentence'）.
`C-x DEL'
     ポイント位置から文頭までを後向きにキルする
     （`backward-kill-sentence'）.

コマンド`M-a'と`M-e' （`backward-sentence'と`forward-sentence'）は, そ
れぞれ, ポイントを含む文の先頭あるいは末尾にポイントを移動します.  こ
れらは, 行頭や行末にポイントを移動するコマンド`C-a'と`C-e'に類似するよ
うに選ばれました.  ただし, `M-a'や`M-e'を反復して使ったり数引数を指定
すると, ポイントは連続した文を横断して移動する点が違います.

（文頭に向かって）後向きに移動するときは, 文の先頭の文字の直前にポイン
トを置きます.  （文末に向かって）前向きに移動するときは, 文を終える句
読点の直後に置きます.  どちらのコマンドも, 文と文の境界にある白文字に
ポイントを移動することはありません.

`C-a'と`C-e'には調和したキルコマンド`C-k'があるように, `M-a'と`M-e'に
もコマンド`M-k'（`kill-sentence'）があります.  これはポイントから文末
までをキルします.  引数に-1を指定すると, 文頭までを後向きにキルします. 
これより大きな引数は反復回数になります.  また, ポイント位置から文頭ま
でを後向きにキルするコマンドとして`C-x DEL'（`backward-kill-sentence'）
もあります.  このコマンドは, 文の作成途中で考えが変わったときに便利で
す.

文操作コマンドでは, 文末に空白を2個打つという米国のタイピストの習慣を
踏襲しているものと仮定します.  つまり, `.', `?', `!'の直後が行末である
か空白が2個続けば, その箇所を文末とみなします.  ただし, `.', `?', `!'
の直後には, `)', `]', `'', `"'がいくつあってもかまいません.  また, 段
落の先頭と末尾も, それぞれ, 文の先頭と末尾になります.

変数`sentence-end'で, 文末の識別方法を制御します.  この値は, 文末の数
個の文字とそれらに続く白文字に一致する正規表現です.  通常の値はつぎの
とおりです. (1) (*Note Sentences-Footnotes::)

     "[.?!][]\"')]*\\($\\|\t\\|  \\)[ \t\n]*"

この例は, 正規表現の節で説明しました.  *Note Regexps::.

文のあいだには空白を1個だけとしたければ, `sentence-end'にはつぎの値を
設定します.

     "[.?!][]\"')]*\\($\\|\t\\| \\)[ \t\n]*"

同時に, 変数`sentence-end-double-space'には`nil'を設定して, 詰め込みコ
マンドにも, 文末には空白が1個だけあり, また, 文末には空白を1個だけ追加
することを指示します.  ただし, このように設定すると, 文末のピリオドと
省略のピリオドとを区別できなくなることに注意してください.


File: emacs-ja  Node: Sentences-Footnotes, Up: Sentences

(1) 【訳注】言語環境を`Japanese'にすると, 変数`sentence-end' は
     "[.?!][]\"')]*\\($\\|\t\\| \\)[ \t\n]*\\|[. ？！]"
となっている.  追加部分は, 日本語の文末に対応する文字集合.



File: emacs-ja, Node: Paragraphs, Next: Pages, Prev: Sentences, Up: Text

段落
====

段落を操作するEmacsコマンドもメタキーです.

`M-{'
     まえの段落の先頭にポイントを後向きに移動する
     （`backward-paragraph'）.
`M-}'
     つぎの段落の末尾にポイントを前向きに移動する（`forward-paragraph'）.
`M-h'
     ポイントを含む段落かつぎの段落の周りにポイントとマークを置く
     （`mark-paragraph'）.

`M-{'は, ポイントを含む段落の先頭か, まえの段落の先頭にポイントを移動
します.  一方, `M-}'は, ポイントを含む段落の末尾か, つぎの段落の末尾に
ポイントを移動します.  段落は, 空行やテキスト整形コマンドの行で区切ら
れますが, それらの行自体は段落には属しません.  基本（fundamental）モー
ドでは, 字下げした行も新たな段落の始まりとみなしますが, テキスト（text）
モードではそうしません.  （段落の直前に空行があれば, これらのコマンド
はそれらを段落の先頭として扱う. ）

プログラム用のメジャーモードでは, 段落は空行で始まり空行で終ります. 
こうしておけば, 本来段落を持たないプログラムでも段落操作コマンドが役立
ちます.

詰め込み接頭辞がある場合には, 接頭辞で始まらない行が段落の区切りとなり
ます.  *Note Filling::.

段落を対象に操作したいときには, コマンド`M-h'（`mark-paragraph'）を使っ
て段落を囲むようなリージョンを設定します.  したがって, たとえば, `M-h
C-w'とすると, ポイントを含むか直後の段落を削除します.  `M-h'コマンドは, 
ポイントを含む段落の先頭にポイントを置き, 末尾にマークを設定します. 
暫定マーク（transient-mark）モードでは, このマークを活性にします.  ポ
イントが段落のあいだ（空行や境界）にある場合は, ポイントの直後にある段
落の周りにポイントとマークを設定します.  段落の1行目のまえに空行があれ
ば, 直前の空行1行も`M-h'が設定するリージョンに含まれます.

正確な段落の境界は, 変数`paragraph-separate'と`paragraph-start'で定義
されます.  `paragraph-start'の値は, 段落を始めたり区切ったりする行に一
致する正規表現です.  `paragraph-separate'の値も別の正規表現ですが, ど
の段落にも属さない段落を分割する行（たとえば空行）だけに一致するもので
す.  新たな段落を始めてその段落に属す行は, `paragraph-start'だけに一致
して, `paragraph-separate'に一致してはいけません.  たとえば, 基本
（fundamental）モードでは, `paragraph-start'は`"[ \t\n\f]"'であり,
`paragraph-separate'は`"[ \t\f]*$"'です.

通常, ページ境界でも段落が区切られるのが望ましいです.  これらの変数の
デフォルト値は, ページの一般的な区切り文字も認識します.



File: emacs-ja, Node: Pages, Next: Filling, Prev: Paragraphs, Up: Text

ページ
======

ファイルを"ページ送り"文字（ASCIIコードのコントロールL, 8進コードの014）
で区切った"ページ"の集まりとして捉えることがよくあります.  ファイルを
印刷すると, この文字は改ページを行います.  そのため, ファイル内の各ペー
ジは別々の用紙に印刷されます.  ほとんどのEmacsコマンドは, ページを区切
る文字を他の文字と同様に扱いますから, `C-q C-l'でページ送り文字を挿入
したり, DELで削除できます.  つまり, ファイルをページに区切るのも区切ら
ないのも自由です.  しかし, ページはファイルを分割する意味ある単位なの
で, Emacsには, ページ間の移動やページを対象とするコマンドがあります.

`C-x ['
     まえのページ境界にポイントを移動する（`backward-page'）.
`C-x ]'
     つぎのページ境界にポイントを移動する（`forward-page'）.
`C-x C-p'
     このページ（か別のページ）の周りに, ポイントとマークを置く
     （`mark-page'）.
`C-x l'
     このページの行数を数える（`count-lines-page'）.

`C-x ['（`backward-page'）コマンドは, まえのページ区切り文字の直後にポ
イントを移動します.  ポイントがすでにページ区切りの直後にあれば, さら
にまえのページ区切り文字の直後に移動します.  数引数は反復回数として扱
われます.  `C-x ]'（`forward-page'）コマンドは, つぎのページ区切り文字
の直後にポイントを移動します.

`C-x C-p'コマンド（`mark-page'）は, ページの先頭にポイントを置き, 末尾
にマークを設定します.  末尾にあるページ区切り文字は含まれます（マーク
はページ区切り文字の直後にある）.  先頭にあるページ区切り文字は除外さ
れます（ポイントはページ区切り文字の直後にある）.  `C-x C-p C-w'は, ペー
ジ全体をキルして別の場所に移動するのに便利な方法です.  `C-x ['や`C-x
]'で別のページ区切り位置に移動してからキルしたページをヤンクすれば, す
べてのページが適切に区切られた状態が維持されます.  `C-x C-p'が末尾のペー
ジ区切り文字だけを含める理由は, これを保証するためです.

`C-x C-p'への数引数は, 現在のページを基準にしてポイントの移動先のペー
ジを指定します.  0は現在のページを意味します.  1はつぎのページ, -1はま
えのページを意味します.

`C-x l'コマンド（`count-lines-page'）は, ページをどこで2つに分割するか
を決めるのに便利です.  現在のページについて, 総行数, 現在行のまえにあ
る行数とうしろにある行数をつぎのようにエコー領域に表示します.

     Page has 96 lines (72+25)

この例で, 総行数が1だけ少ないことに注意してください.  ポイントが行頭に
ないとつねにこうなります.

変数`page-delimiter'はページの始まりを制御します.  この変数の値は, ペー
ジを区切る行の先頭に一致する正規表現です.  この変数の通常の値は`"^\f"'
で, 行頭のページ送り文字に一致します.



File: emacs-ja, Node: Filling, Next: Case, Prev: Pages, Up: Text

テキストの詰め込み
==================

テキストの"詰め込み"（filling）とは, 指定した幅に納まるようにテキスト
を行に分割することです.  Emacsには, 詰め込む方法が2つあります.  自動詰
め込み（auto-fill）モードでは, 自己挿入文字でテキストを挿入すると同時
に詰め込みを行います.  あるいは, 詰め込まずにテキストを編集していると
きには, 陽に詰め込みコマンドを使います.  整形済みテキストを編集してい
るときは, テキストの各部分ごとに詰め込みのスタイルを指定できます
（*Note Formatted Text::）.

* Menu:

* Auto Fill::	        Auto Fill mode breaks long lines automatically.
* Fill Commands::       Commands to refill paragraphs and center lines.
* Fill Prefix::	        Filling paragraphs that are indented
                          or in a comment, etc.
* Adaptive Fill::       How Emacs can determine the fill prefix automatically.



File: emacs-ja, Node: Auto Fill, Next: Fill Commands, Prev: Filling, Up: Filling

自動詰め込みモード（auto-fillモード）
-------------------------------------

"自動詰め込み"（auto-fill）モードはマイナモードで, 行が長くなりすぎる
と自動的に分割します.  SPCやRETを打鍵したときだけ, 行を分割します.

`M-x auto-fill-mode'
     自動詰め込み（auto-fill）モードをオンにしたりオフにする.
`SPC'
`RET'
     自動詰め込み（auto-fill）モードでは, 適切な場合には行を分割する.

`M-x auto-fill-mode'は, 自動詰め込み（auto-fill）モードがオフならばオ
ンにし, オンならばオフにします.  正の数引数を指定すると自動詰め込み
（auto-fill）モードをつねにオンにしますが, 負の引数を指定するとつねに
オフにします.  モード行の括弧の中に`Fill'と表示されていれば, このモー
ドはオンになっています.  自動詰め込み（auto-fill）モードは, 各バッファ
ごとにオン／オフできるマイナモードです.  *Note Minor Modes::.

自動詰め込み（auto-fill）モードでは, 行が決められた幅より長くなると, 
自動的に空白の位置で行を分割します.  行の分割と再配置は, SPCかRETを打
鍵したときだけ行われます.  行を分割せずに空白や改行を挿入するには,
`C-q SPC'や`C-q C-j'と打鍵します（改行はまさにコントロールJであること
を思い出してほしい）.  `C-o'も行を分割せずに改行を挿入します.

自動詰め込み（auto-fill）モードは, TABで新たな行を字下げするので, プロ
グラム言語用のモードと組み合わせてもうまく動作します.  コメントで終わ
る行が長くなりすぎた場合には, コメント内のテキストを2つのコメント行に
分割します.  始めの行の末尾とつぎの行の行頭に新たにコメントの区切り文
字列を挿入して, 2つの独立したコメント行にすることもできます.  この付加
機能は, 変数`comment-multi-line'で制御します（*Note Comments::）.

適応型詰め込み（後述）は, 明示した詰め込みコマンドのみならず, 自動詰め
込みに対しても有効に働きます.  これは, 段落の先頭行あるいは第2行目から, 
自動的に詰め込み接頭辞を切り出します.

自動詰め込み（auto-fill）モードは, 段落全体を詰め直すことはしません. 
行を分割できても, 併合はできません.  そのため, 段落の途中を編集すると, 
必ずしも段落を正しく詰め込めません.  段落をふたたび適切に詰め込まれた
状態にするもっとも簡単な方法は, 明示的に詰め込みコマンドを使用すること
です.  *Note Fill Commands::.

多くのユーザーは自動詰め込み（auto-fill）モードを好み, あらゆるテキス
トファイルの編集に使用しようとします.  初期化ファイルの節では, こうす
る方法を説明します.  *Note Init File::.



File: emacs-ja, Node: Fill Commands, Next: Fill Prefix, Prev: Auto Fill, Up: Filling

明示的な詰め込みコマンド
------------------------

`M-q'
     現在の段落を詰め込む（`fill-paragraph'）.
`C-x f'
     詰め込み桁を設定する（`set-fill-column'）.
`M-x fill-region'
     リージョン内の各段落を詰め込む（`fill-region'）.
`M-x fill-region-as-paragraph'
     リージョン全体を1つの段落とみなして詰め込む.
`M-s'
     行を中央に揃える.

段落を詰め直すには, コマンド`M-q'（`fill-paragraph'）を使います.  ポイ
ントを含む段落, あるいは, ポイントが段落のあいだにある場合には直後の段
落を操作します.  改行をすべて取り除いてから, 必要な箇所に新たに改行を
挿入することで段落を詰め直します.

いくつもの段落を詰め直すには, `M-x fill-region'を使います.  これは, リー
ジョンを段落に分けてから, 各段落を詰め込みます.

`M-q'と`fill-region'は, `M-h'と同じ基準で段落の境界を探します（*Note
Paragraphs::）.  段落の大きさを制御するには, `M-x
fill-region-as-paragraph'を使います.  これは, ポイントとマークのあいだ
にあるものすべてを詰め直します.  このコマンドはリージョン内の空行をす
べて削除して, 分かれていたテキストの塊を1つの塊にまとめ上げます.

`M-q'に数引数を指定すると, テキストの詰め込みだけでなく, テキストの"幅
揃え"（justify）も行います.  つまり, 余分に空白を挿入して, 行の右端が
詰め込み桁に一致するようにします.  余分な空白を取り除くには, 引数を指
定しないで`M-q'を使います.  （`fill-region'も同様. ）幅揃えを制御して
別の詰め込みスタイルを選択する別の方法は, テキスト属性`justification'
を使うことです.  これに関しては, *Note Format Justification::を参照し
てください.

コマンド`M-s'（`center-line'）は, 詰め込み桁までの範囲内で現在行を中央
に揃えます.  引数Nを指定すると, 現在行を含めN行をそれぞれ独立に中央に
揃えてから, 揃えた行のつぎにポイントを移動します.

詰め込むときの行の最大幅は, 変数`fill-column'に入っています.
`fill-column'の値を変更すると, カレントバッファにローカルな変数になり
ます.  それまではデフォルト値が有効です.  デフォルト値は始めは70です.
*Note Locals::.  `fill-column'を設定するもっとも簡単な方法は, コマンド
`C-x f'（`set-fill-column'）を使うことです.  このコマンドに数引数を指
定すると, その値を新たな詰め込み桁として使います.  `C-u'だけを引数に指
定すると, ポイントの現在の水平位置を`fill-column'に設定します.

Emacsコマンドは通常, ピリオドの直後に空白が2個あるか改行があれば文末と
して扱います.  ピリオドの直後に空白が1個だけでは, 文末ではなく省略とみ
なします.  ピリオドのこれら2つの用法の違いを保存するために, ピリオドの
直後に空白が1個だけの箇所では詰め込みコマンドは行を分割しません.

変数`sentence-end-double-space'が`nil'ならば, 詰め込みコマンドは, 文末
には空白が1個だけあると仮定し, かつ, 文末には空白を1個だけ残します. 
普通, この変数の値は`t'なので, 上述のように空白が2個ある場合だけを文末
として扱います.  *Note Sentences::.

`colon-double-space'が`nil'以外ならば, 詰め込みコマンドはコロンのうし
ろに空白を2個置きます.



File: emacs-ja, Node: Fill Prefix, Next: Adaptive Fill, Prev: Fill Commands, Up: Filling

詰め込み接頭辞
--------------

各行が（段落を字下げする数個の空白などの）特別の印で始まっている段落を
詰め込むには, "詰め込み接頭辞"（fill prefix）の機能を使えます.  詰め込
み接頭辞は文字列であり, Emacsはすべての行がその文字列で始まると仮定し
ますが, 詰め込み接頭辞自体は詰め込みの対象ではありません.  明示的に詰
め込み接頭辞を指定できますが, Emacsが詰め込み接頭辞を自動的に推測する
こともできます（*Note Adaptive Fill::）.

`C-x .'
     詰め込み接頭辞を設定する（`set-fill-prefix'）.
`M-q'
     現在の詰め込み接頭辞を使って, 段落を詰め込む（`fill-paragraph'）.
`M-x fill-individual-paragraphs'
     字下げ幅の変化を新たな段落の始まりとみなして, リージョン内を詰め
     込む.
`M-x fill-nonuniform-paragraphs'
     段落を分割する行だけを新たな段落の始まりとみなして, リージョン内
     を詰め込む.

詰め込み接頭辞を指定するには, 
目的の接頭辞で始まっている行に移動して接頭辞の直後にポイントを置いてから, 
コマンド`C-x .'（`set-fill-prefix'）を実行します. 
`C-x'のあとはピリオドです. 
詰め込み接頭辞の使用をやめるには, 空の接頭辞を設定します. 
つまり, 行頭にポイントを置いてから`C-x .'と打ちます. 

詰め込み接頭辞が設定されている場合, 詰め込みコマンドは処理に先だって各
行から詰め込み接頭辞を取り除き, 詰め込みを行ったあとに各行に挿入します. 
自動詰め込み（auto-fill）モードでも, 新たに行を作成するときに自動的に
詰め込み接頭辞を挿入します.  行頭で`C-o'コマンド（*Note Blank Lines::）
を使用すると, 新たに作成する行にも詰め込み接頭辞を挿入します.  逆に, 
コマンド`M-^'は, 削除する改行の直後に詰め込み接頭辞があると接頭辞も削
除します（*Note Indentation::）.

たとえば, `fill-column'が40で詰め込み接頭辞が`;; 'のときに, つぎのテキ
ストで`M-q'を実行します.

     ;; This is an
     ;; example of a paragraph
     ;; inside a Lisp-style comment.

結果はつぎのようになります.

     ;; This is an example of a paragraph
     ;; inside a Lisp-style comment.

`M-q'および段落コマンドは, 詰め込み接頭辞で始まらない行を段落の始まり
とみなします.  これにより, ぶら下がり字下げ（先頭行を除いてすべての行
が字下げ）された段落も正しく詰め込みます.  空行や接頭辞を取りさると字
下げした行になる行も, 段落の区切りや始まりとみなします.  これによって, 
各行にコメント区切りがある複数段落のコメントを書いているときにも, 望み
どおりの結果を得られます.

各段落に対して自動的に詰め込み接頭辞を設定するには, `M-x
fill-individual-paragraphs'を使います.  このコマンドは, 字下げ幅の変化
を新たな段落の始まりとみなして, リージョンを段落に分割したあと, 各段落
を詰め込みます.  つまり, 1つの『段落』内の行はどれも同じ字下げ幅です. 
字下げ幅が, 段落に対する詰め込み接頭辞として働きます.

`M-x fill-nonuniform-paragraphs'も同様なコマンドですが, リージョンを段
落に分割する方法が異なります.  このコマンドは, （変数
`paragraph-separate'で定義される）段落区切り行だけを新たな段落の始まり
とみなします.  つまり, 各段落の行はさまざまに字下げされているかもしれ
ないので, その中の最少の字下げを詰め込み接頭辞として使用するわけです. 
段落の最初の行の字下げが残りの行に比べて多くても少なくても, 正しい詰め
込み結果を得られます.

詰め込み接頭辞は変数`fill-prefix'に格納されます.  この値は文字列である
か, 詰め込み接頭辞が設定されていなければ`nil'です.  この変数を変更して
もカレントバッファだけに影響しますが, デフォルト値を変更することもでき
ます.  *Note Locals::.

テキスト属性`indentation'は, 段落に与える字下げ幅を調整する別の方法で
す.  *Note Format Indentation::.



File: emacs-ja, Node: Adaptive Fill, Next: Case, Prev: Fill Prefix, Up: Filling

適応型詰め込み
--------------

詰め込みコマンド自身が, 段落に対する適切な詰め込み接頭辞を推測できる状
況もあります.  段落のすべての行の先頭に白文字やある種の句読点文字が使
われている場合です.

段落が2行以上から成る場合, 段落の2行目から詰め込み接頭辞を切り出します
が, 1行目にもそれが現れるときに限ります.

段落が1行だけの場合には, その行から詰め込み接頭辞を切り出す*かもしれま
せん* (1) (*Note Adaptive Fill-Footnotes::).  こういった状況では, つぎ
のような3つの合理的な挙動が考えられるので, 接頭辞の決定は複雑です.


   * 最初の行の接頭辞を段落のすべての行に用いる.

   * 1行目の接頭辞に続くテキストの直下に並ぶように後続の行を白文字で字
     下げするが, 1行目から接頭辞をコピーしない.

   * 2行目以降には何も特別なことは行わない.

これら3つの整形スタイルは, いずれも一般的に使用されます.  そこで, 詰め
込みコマンドは, 現れた接頭辞とそのときのメジャーモードに基づいて, ユー
ザーが望むスタイルを決定しようとします.  判断基準はつぎのとおりです.

1行目でみつけた接頭辞が`adaptive-fill-first-line-regexp'に一致するか, 
（メジャーモードに依存する）コメント開始文字列のようであれば, みつけた
接頭辞を段落の詰め込みに用います.  ただし, その接頭辞が後続の行に対し
て段落の始まりにならない場合に限ります.

さもなければ, みつけた接頭辞を相当分の空白に変換して, それらの空白を段
落の2行目以降の詰め込み接頭辞として使います.  ただし, それらの空白が後
続の行に対して段落の始まりにならない場合に限ります.

テキスト（text）モード, および, 空行やページ区切りだけが段落を区切るモー
ドでは, 適応型詰め込みによって選ばれた接頭辞が段落の始まりになることは
けっしてありませんから, その接頭辞を段落の詰め込みに使用することができ
ます.

変数`adaptive-fill-regexp'で, 行頭のどんな文字列を詰め込み接頭辞として
使えるかを決定します.  この変数の正規表現に一致する行頭の文字列を接頭
辞とします.  変数`adaptive-fill-mode'に`nil'を設定すると, 詰め込み接頭
辞を自動的には切り出しません.

変数`adaptive-fill-function'に関数を設定すると, 詰め込み接頭辞を自動的
に切り出すためのより複雑な方法を指定できます.  この関数は行の左端の直
後にポイントを置いて呼び出されます.  その行から類推される適切な詰め込
み接頭辞を返さなくてはいけません.  その行に詰め込み接頭辞がなさそうで
あれば`nil'を返します.


File: emacs-ja  Node: Adaptive Fill-Footnotes, Up: Adaptive Fill

(1) 【訳注】段落に1行しかなければ, 詰め込み接頭辞を切り出す必要はない
と思うかもしれないが, たとえば, その行が詰め込み桁より長かったり, 新た
な入力によって複数行の段落になったときのことを考えてみてほしい.



File: emacs-ja, Node: Case, Next: Text Mode, Prev: Filling, Up: Text

大文字小文字変換コマンド
========================

Emacsには, 単語や任意の長さのテキストを大文字あるいは小文字に変換する
コマンドがあります.

`M-l'
     後続の単語を小文字に変換する（`downcase-word'）.
`M-u'
     後続の単語を大文字に変換する（`upcase-word'）.
`M-c'
     後続の単語の1文字目だけを大文字にする（`capitalize-word'）.
`C-x C-l'
     リージョン内のテキストを小文字に変換する（`downcase-region'）.
`C-x C-u'
     リージョン内のテキストを大文字に変換する（`upcase-region'）.

単語変換コマンドはたいへん便利です.  `M-l'（`downcase-word'）はポイン
トの直後の単語を小文字に変換し, 単語の末尾にポイントを移動します.  し
たがって, `M-l'を繰り返すと, 連続した単語を変換できます.  `M-u'
（`upcase-word'）は単語を大文字に変換し, `M-c'（`capitalize-word'）は
単語の1文字目を大文字して残りを小文字に変換します.  これらのコマンドに
引数を指定すると, 一度に数単語を変換できます.  これらのコマンドは, 大
文字だけの大量のテキストを大文字小文字が混在するように変換するときに, 
特に威力を発揮します.  というのは, 必要に応じて`M-l', `M-u', `M-c'を使
い分けて移動したり, `M-f'で変換せずに単語を飛び越えられるからです.

負の引数を指定すると, ポイントの直前にある数個の単語を変換しますが, ポ
イントは移動しません.  これは, 大文字小文字をまちがえて単語を入力した
直後には便利です.  大文字小文字変換コマンドを打ってからすぐに入力を再
開できます.

単語の途中で大文字小文字変換コマンドを実行すると, ポイントのうしろにあ
る部分だけを変換します.  これは`M-d'（`kill-word'）のふるまいと同じで
す.  また, 負の引数を指定すると, ポイントよりまえの部分を変換します.

他の大文字小文字変換コマンドは, `C-x C-u'（`upcase-region'）と`C-x
C-l'（`downcase-region'）です.  これらは, リージョン内のテキストを指定
どおりに変換します.  ポイントもマークも移動しません.

リージョンに対する大文字小文字変換コマンドである`upcase-region'と
`downcase-region'は, 通常, 使用禁止になっています.  つまり, これらのコ
マンドを使おうとすると, 最初に確認を求めてきます.  確認するときにコマ
ンドを使用可にしておけば, つぎからは確認を求めてきません.  *Note
Disabling::.



File: emacs-ja, Node: Text Mode, Next: Outline Mode, Prev: Case, Up: Text

テキストモード（textモード）
============================

自然言語テキストのファイルを編集するときには, 基本（fundamental）モー
ドではなくテキスト（text）モードを使ったほうが便利です.  テキスト
（text）モードに入るには`M-x text-mode'と打ちます.

テキスト（text）モードでは, 空行とページ区切りだけが段落の区切りです. 
その結果, 段落を字下げできて, 適応型詰め込みでは段落の詰め込みに使用す
る字下げを決定できます.  *Note Adaptive Fill::.

テキスト（text）モードでは, TABは`indent-relative'（*Note
Indentation::）を実行するように定義してあるので, 先行する行と同じよう
に字下げするのに便利です.  先行する行が字下げされてなければ,
`indent-relative'は`tab-to-tab-stop'を実行します.  これは, ユーザーが
設定したEmacsのタブストップを使います（*Note Tab Stops::）.

テキスト（text）モードでは, コメントに関する機能は, 陽に起動した場合を
除いてオフです.  ピリオドは単語の一部ではなく, 一方, アポストロフ, バッ
クスペース, 下線は単語の一部である, となるように構文テーブルを変更しま
す.

段落の最初の行を字下げするのであれば, テキスト（text）モードではなく段
落字下げ型テキスト（paragraph-indent-text）モードを使うべきです.  この
モードでは, 段落のあいだに空行を設ける必要はありません.  というのは, 
最初の行の字下げで, 段落の始まりがわかるからです.  ただし, すべての行
が字下げされている段落は扱えません.  このモードに入るには, `M-x
paragraph-indent-text-mode'を使います.

テキスト（text）モード, および, テキスト（text）モードに基づくすべての
モードでは, `M-TAB'をコマンド`ispell-complete-word'として定義します. 
このコマンドは, ポイントの直前の部分的な単語を綴り辞書を用いて補完しま
す.  *Note Spelling::.

テキスト（text）モードに入ると, フック`text-mode-hook'を実行します. 
テキスト（text）モードに関連する他のモードも, このフックに続けて各モー
ド専用のフックを実行します.  つまり, 段落字下げ型テキスト
（paragraph-indent-text）モード, nroffモード, TeXモード, アウトライン
（outline）モード, メイル（mail）モードがそうです.  `text-mode-hook'に
登録されたフック関数では, `major-mode'の値を調べれば実際にどのモードに
入ったかわかります.  *Note Hooks::.

Emacsには, 綺麗な印刷出力を得るためにテキスト清書系に渡すテキストを編
集するためのモードが他に2つあります.  nroff入力の編集については, *Note
Nroff Mode::.  TeX入力の変数については, *Note TeX Mode::.

別のモードは, アウトラインの編集に使います.  このモードは, さまざまな
レベルの詳しさでテキストを眺めることができます.  アウトラインの見出し
だけを見たり, 見出しとテキストを同時に見たりできます.  低いレベルの見
出しの一部を隠して, より高いレベルの構造を際だたせることもできます.
*Note Outline Mode::.



File: emacs-ja, Node: Outline Mode, Next: TeX Mode, Prev: Text Mode, Up: Text

アウトラインモード（outlineモード）
===================================

アウトライン（outline）モードはテキスト（text）モードにたいへんよく似
たメジャーモードですが, アウトライン構造を持つテキストの編集用です. 
アウトライン構造を把握できるようにテキストの一部を一時的に不可視にでき
ます.  カレントバッファのメジャーモードをアウトライン（outline）モード
に切り替えるには, `M-x outline-mode'と打ちます.

アウトライン（outline）モードで行を不可視にすると, その行は画面上に表
示されません.  画面上では, 不可視にした行が削除されたかのように見えま
すが, それに先行する可視な行の末尾に省略記号（ピリオドが3つ...）が表示
されます（何行不可視にしていても, 省略記号は1つだけ）.

`C-n'や`C-p'のような行を対象とした編集コマンドは, 不可視にした行のテキ
ストを, 先行する可視な行の一部であるかのように扱います.  改行も含めて
可視な行全体をキルすると, 後続の不可視な行も一緒にキルします.

アウトラインマイナ（outline-minor）モードは, メジャーモードであるアウ
トライン（outline）モードと同じコマンドを提供しますが, 他のメジャーモー
ドと一緒に使用できます.  カレントバッファでアウトラインマイナ
（outline-minor）モードをオンにするには, `M-x outline-minor-mode'と打
ちます.  `mode: outline-minor'といった形のファイルにローカルな変数で, 
テキストファイルにアウトラインマイナ（outline-minor）モードを指定する
こともできます（*Note File Variables::）.

メジャーモードであるアウトライン（outline）モードでは, プレフィックス
`C-c'に特別なキーバインディングを設定しています.  アウトラインマイナ
（outline-minor）モードでは, `C-c @'をプレフィックスとして同様のバイン
ディングがあります.  これは, 一緒に用いるメジャーモードの特別なコマン
ドとの衝突を減らすための措置です.  （変数`outline-minor-mode-prefix'で, 
実際に使用するプレフィックスを制御する. ）

アウトライン（outline）モードに入ると, フック`text-mode-hook'に続けて
フック`outline-mode-hook'を実行します（*Note Hooks::）.

* Menu:

* Format: Outline Format.	   What the text of an outline looks like.
* Motion: Outline Motion.	   Special commands for moving through
                                     outlines. 
* Visibility: Outline Visibility.  Commands to control what is visible.
* Views: Outline Views.            Outlines and multiple views.



File: emacs-ja, Node: Outline Format, Next: Outline Motion, Prev: Outline Mode, Up: Outline Mode

アウトラインの形式
------------------

アウトライン（outline）モードは, バッファの中には2種類の行, つまり, "
見出し行"（heading lines）, "本体行"（body lines）があると仮定します. 
見出し行は, アウトラインのトピックを表していて, 1つ以上の星印で始まり
ます.  星印の個数は, アウトライン構造における見出しの深さを表します. 
つまり, 星印1つの見出し行は主要なトピックを表します.  この行とつぎの星
印1個の行のあいだにある星印2個の見出し行は, この行の下位トピックです. 
星印がいくつであってもこのような関係が成り立ちます.  見出し行以外は本
体行です.  これらは直前の見出し行に属します.  以下に例を示します.

     * Food
     This is the body,
     which says something about the topic of food.

     ** Delicious Food
     This is the body of the second-level header.

     ** Distasteful Food
     This could have
     a body too, with
     several lines.

     *** Dormitory Food

     * Shelter
     Another first-level topic with its header line.

見出し行とそれに続く本体行をまとめて"項目"（entry）と呼びます.  また, 
見出し行と, それに続くさらに深いレベルの見出し行とそれらの本体行をまと
めて"部分木"（subtree）と呼びます.

変数`outline-regexp'に値を設定して, 見出し行を判定する基準をカスタマイ
ズできます.  この正規表現に行頭が一致する行を見出し行とみなします. 
（左端からではなく）行の途中で一致するものは, 無視します.  一致したテ
キストの長さによって, 見出しのレベルを決定します.  一致したテキストが
長いほどレベルが深くなります.  したがって, たとえば, 清書系に章や節を
分ける`@chapter', `@section', `@subsection'といったコマンドがある場合, 
これらの行を見出しとして扱えばよいのですが, それには`outline-regexp'に
`"@chap\\|@\\(sub\\)*section"'と設定します.  これには, ちょっとしたト
リックがあります.  2つの単語, `chapter'と`section'は同じ長さですが, 正
規表現では, `chap'だけに一致するように定義することで, 章見出しに一致す
るテキストの長さのほうを短くできます.  これによって, アウトライン
（outline）モードは, 章（chapter）の中に節（section）が含まれるとわか
るのです.  他のコマンドが`@chap'で始まらない限り, この設定は有効です.

変数`outline-level'を設定すると, 見出し行のレベル計算方法を変更できま
す.  `outline-level'の値は, 引数を取らない, 現在の見出しのレベルを返す
関数である必要があります.  Cモード, nroffモード, Emacs Lispモードといっ
たメジャーモードのいくつかでは, アウトラインマイナ（outline-minor）モー
ドが有効に働くように, この変数を設定します.



File: emacs-ja, Node: Outline Motion, Next: Outline Visibility, Prev: Outline Format, Up: Outline Mode

アウトライン上での移動コマンド
------------------------------

アウトライン（outline）モードには, 前後の見出し行に移動する特別なコマ
ンドがあります.

`C-c C-n'
     つぎの可視な見出し行にポイントを移動する
     （`outline-next-visible-heading'）.
`C-c C-p'
     まえの可視な見出し行にポイントを移動する
     （`outline-previous-visible-heading'）.
`C-c C-f'
     ポイント位置と同じレベルのつぎの可視な見出し行にポイントを移動す
     る（`outline-forward-same-level'）.
`C-c C-b'
     ポイント位置と同じレベルのまえの可視な見出し行にポイントを移動す
     る（`outline-backward-same-level'）.
`C-c C-u'
     より浅い（より多くの項目を含む）レベルで, 可視な見出し行にポイン
     トを移動する（`outline-up-heading'）.

`C-c C-n'（`outline-next-visible-heading'）は, つぎの見出し行にポイン
トを移動します.  `C-c C-p'（`outline-previous-visible-heading'）も同様
ですが, 逆向きにポイントを移動します.  どちらのコマンドも, 数引数を反
復回数として受け取ります.  コマンドの名前は, 不可視な見出し行を飛び越
えることを強調していますが, これは何も特別な機能ではありません.  行を
探すようなすべての編集コマンドは, 不可視な行を自動的に無視します.

もっと強力な移動コマンドは, 見出しのレベル構造を把握して移動を行うもの
です.  `C-c C-f'（`outline-forward-same-level'）と`C-c C-b'
（`outline-backward-same-level'）は, アウトライン構造中で同じレベルに
ある別の見出し行にポイントを移動します.  `C-c C-u'
（`outline-up-heading'）は, より浅いレベルの見出し行へ戻るようにポイン
トを移動します.



File: emacs-ja, Node: Outline Visibility, Next: Outline Views, Prev: Outline Motion, Up: Outline Mode

アウトラインの可視／不可視制御コマンド
--------------------------------------

アウトライン（outline）モードの特別なコマンドとして, 行を可視／不可視
にするものもあります.  これらのコマンドの名前は, すべて`hide'あるいは
`show'で始まります.  これらのほとんどは, 逆の機能のコマンドと対になっ
ています.  これらのコマンドはアンドゥ可能ではありませんが, 実行直後な
らば戻すことはできます.  行を可視／不可視にするのは, アンドゥ機構に単
純に記録するのではありません.

`C-c C-t'
     バッファ中の本体行をすべて不可視にする（`hide-body'）.
`C-c C-a'
     バッファ中のすべての行を可視にする（`show-all'）.
`C-c C-d'
     ポイント位置の見出し行を除いて, その下位レベルのすべてを不可視に
     する（`hide-subtree'）.
`C-c C-s'
     ポイント位置の見出し行, 本体, 下位の見出し／本体, すべてを可視に
     する（`show-subtree'）.
`C-c C-l'
     ポイント位置の見出し行の本体と下位の見出し行のすべての本体を不可
     視にする（`hide-leaves'）.
`C-c C-k'
     ポイント位置の見出し行の下位の見出し行をすべて可視にする
     （`show-branches'）.
`C-c C-i'
     ポイント位置の見出し行の直下（1レベル深い）の下位見出しを可視にす
     る（`show-children'）.
`C-c C-c'
     ポイント位置の見出し行の本体を不可視にする（`hide-entry'）.
`C-c C-e'
     ポイント位置の見出し行の本体を可視にする（`show-entry'）.
`C-c C-q'
     最上位のNレベルまでを除き, すべてを不可視にする（`hide-sublevels'）.
`C-c C-o'
     ポイント位置の見出し行や本体, および, そこから最上位レベルに至る
     までに通過する見出し行を除き, すべて不可視にする（`hide-other'）.

`C-c C-c'（`hide-entry'）と`C-c C-e'（`show-entry'）の2つのコマンドは, 
正反対の機能を持っています.  これらは, 見出し行にポイントがある場合 
(1) (*Note Outline Visibility-Footnotes::) に, その本体のみに作用しま
す.  下位見出しとその本体は影響を受けません.

もっと強力で機能が正反対のコマンドは, `C-c C-d'（`hide-subtree'）と
`C-c C-s'（`show-subtree'）です.  どちらも見出し行にポイントがあるとき 
(2) (*Note Outline Visibility-Footnotes::) に使い, 見出しの"部分木" 内
のすべての行つまり, 本体, 直接／間接に関わらずあらゆる下位の見出しとそ
の本体, に作用します.  つまり, 部分木には, その見出し行に続くつぎの同
レベルか上位レベルの見出し行の直前までが含まれます.

可視な部分木と, すべて不可視な部分木の中間的な状態には, 本体は不可視で
下位の見出し行はすべて可視といったものも存在します.  この状態を作り出
すコマンドは2つあり, 本体を不可視にするか, 下位見出しを可視にするかで
す.  これらは, `C-c C-l'（`hide-leaves'）と`C-c C-k'（`show-branches'）
です.

`C-c C-i'（`show-children'）は, `show-branches'より少し弱いコマンドで
す.  これは, 直下の, つまり1レベル深い見出し行だけを可視にします.  よ
り深いレベルの見出しは不可視ならば不可視のままです.

ファイル全体に効果がおよぶ2つのコマンドがあります.  `C-c C-t'
（`hide-entry'）は本体行をすべて不可視にするので, アウトライン構造だけ
を眺めることができます.  `C-c C-a'（`show-all'）は, すべての行を可視に
します.  `C-c C-a'は本体行以外にも作用しますが, これらのコマンドは正反
対の機能の対と考えることができます.

コマンド`C-c C-q'（`hide-sublevels'）は, 最上位レベルの見出し以外をす
べて不可視にします.  数引数Nを指定すると, 最上位からNレベルまでの見出
し行を除いたすべてを不可視にします.

コマンド`C-c C-o'（`hide-other'）は, ポイント位置の見出しあるいは本体, 
その親（アウトライン構造においてポイント位置から最上位レベルまで至る見
出し）を除いたすべてを不可視にします.

変数`selective-display-ellipses'に`nil'を設定すると, 可視な行の末尾に
現れる省略記号を消せます.  そうすると, 不可視な行の存在を示すものは何
もなくなります.

インクリメンタルサーチでアウトライン（outline）モードが不可視にしてい
るテキストを探しだすと, バッファのその部分は可視になります.  その箇所
で探索から抜けると, テキストは可視のまま (3) (*Note Outline
Visibility-Footnotes::)になります.


File: emacs-ja  Node: Outline Visibility-Footnotes, Up: Outline Visibility

(1) 【訳注】ポイントが本体行にあっても動作する.

(2) 【訳注】ポイントが本体行にあっても動作し, 結果も同じ.

(3) 【訳注】抜けると, また不可視にもどってしまう.




File: emacs-ja, Node: Outline Views, Next: TeX Mode, Prev: Outline Visibility, Up: Outline Mode

複数の視点からアウトラインを眺める
----------------------------------

1つのアウトライン構造を同時に2つの視点から別々のウィンドウに表示して眺
めることができます.  それには, `M-x make-indirect-buffer'を使って間接
バッファを作成する必要があります.  このコマンドの最初の引数は, 既存の
アウトライン用バッファの名前で, 2番目の引数は新たに作成する間接バッファ
の名前です.  *Note Indirect Buffers::.

間接バッファがあるならば, `C-x 4 b'や他のEmacsコマンドで普通にそのバッ
ファをウィンドウに表示できます.  テキストの一部を可視／不可視にするア
ウトライン（outline）モードのコマンドは, 各バッファで独立に働きます. 
その結果, 各バッファごとに独自の視点を持たせることが可能です.  同じア
ウトラインに対して3つ以上の視点が必要ならば, 間接バッファをさらに作成
してください.



File: emacs-ja, Node: TeX Mode, Next: Nroff Mode, Prev: Outline Mode, Up: Text

TeXモード
=========

TeXは, Donald Knuthが作成した強力な清書系です.  しかも, GNU Emacsと同
じくフリーです.  LaTeXは, TeXの入力形式を単純化したもので, TeXのマクロ
で実現されています.  これもTeXに付属しています.  SliTeXはスライドを作
成するためにLaTeXを特殊化したものです.

Emacsには, TeXの入力ファイルを編集するための特別なTeXモードがあります. 
このモードには, 区切りの対応を検査したり, ファイル全体やその一部に対し
てTeXを起動したりする機能があります.

TeXモードには3つの変種があります.  それぞれ, プレインTeX（plain-tex）
モード, LaTeX（latex）モード, SliTeX（slitex）モードです（これら3つは
メジャーモードですが, 差異はわずか）.  これらのモードは, 異なる3つの入
力形式を編集するように設計されています.  コマンド`M-x tex-mode'は, バッ
ファ内の内容を調べて, LaTeXの入力なのかSliTeXの入力なのか判断します. 
そのいずれかであれば, それに適したモードを選択します.  ファイルの中身
がLaTeXでもSliTeXでもなさそうであれば, プレインTeX（plain-tex）モード
を選択します.  ファイルの内容が判断するに十分でなければ, 変数
`tex-default-mode'で使用するモードを制御します.

`M-x tex-mode'が適切なモードを推測できなかった場合には, コマンド`M-x
plain-tex-mode', `M-x latex-mode', `M-x slitex-mode'で明示的にTeXの変
種を選択できます.

* Menu:

* Editing: TeX Editing.   Special commands for editing in TeX mode.
* LaTeX: LaTeX Editing.   Additional commands for LaTeX input files.
* Printing: TeX Print.    Commands for printing part of a file with TeX.



File: emacs-ja, Node: TeX Editing, Next: LaTeX Editing, Prev: TeX Mode, Up: TeX Mode

TeX編集コマンド
---------------

ここでは, TeXの入力ファイルのテキストを編集するためにTeXモードに用意し
てある特別なコマンドについて述べます.

`"'
     文脈に応じて`"', `"', `"'を挿入する（`tex-insert-quote'）.
`C-j'
     段落区切り（空行を2つ）を挿入し, まえの段落の中括弧やドル記号の対
     応を検査する（`tex-terminate-paragraph'）.
`M-x tex-validate-region'
     リージョン内の各段落に対して, 中括弧やドル記号の対応を検査する.
`C-c {'
     `{}'を挿入して, そのあいだにポイントを移動する
     （`tex-insert-braces'）.
`C-c }'
     対応が取れていないつぎの閉じ中括弧のあとに前向きにポイントを移動
     する（`up-list'）.

TeXでは, 文字`"'はまず使いません.  引用を始めるには`"'を, 終るには`"'
を使います.  こういったテキスト整形上の規則の下で編集作業を楽にするた
めに, TeXモードでは``'と`''を対で挿入する（`tex-insert-quote'）ように
キー`"'の意味を変えています.  より正確にいえば, このコマンドは白文字や
開き中括弧のあとでは`"'を, バックスラッシュのあとでは`"'を, これ以外の
文字のあとでは`"'を挿入します.

特別な文脈で`"'文字が必要であれば, `C-q'を使って挿入します.  また, `"'
に数引数を指定すると, その個数分の`"'を入力します.  ローカルマップから
バインディング（*Note Key Bindings::）を取り除けば, `"'を展開する機能
をオフにできます.

TeXモードでは, `$'にはTeXの数式モードの区切りの対応を確認するための特
別な構文コードが設定されています.  数式モード終了を意味する`$'を挿入す
ると, それに対応した数式モード開始の`$'を1秒間ほど表示します.  これは, 
閉じ中括弧を挿入すると, それに対応する開き中括弧を表示する機能と同じで
す.  しかし, `$'が数式モードを開始するものか終了するものかを知る方法が
ありません.  したがって, 数式モード開始の`$'を挿入しても, たとえ実際に
は無関係であっても, まえにある`$'が対応しているかのように表示されてし
まいます.

TeXは, 中括弧を必ず対応が取れている区切りとして使います.  ユーザーの中
には, 中括弧を別々に入力するよりも, つねに対応が取れている中括弧の入力
を好む人もいます.  `C-c {'（`tex-insert-braces'）と打てば中括弧の対を
挿入できます.  さらに, ポイントがそれらのあいだに置かれるので, 中括弧
の内側にテキストを挿入できます.  そのあとに, コマンド`C-c }'
（`up-list'）を使って, 閉じ中括弧のうしろに移動します.

中括弧の対応を調べるコマンドは2つあります.  `C-j'
（`tex-terminate-paragraph'）は, ポイントの直前の段落を検査してから, 
新たな段落を始める空行を2つ挿入します.  対応していない中括弧があれば, 
エコー領域にメッセージを表示します.  `M-x tex-validate-region'は, リー
ジョンの段落を1つ1つ検査します.  エラーはバッファ`*Occur*'に表示されま
す.  このバッファで`C-c C-c'や`Mouse-2'を使えば, 特定の非対応箇所へ移
動できます.

TeXモードでは, Emacsコマンドは中括弧だけでなく, 括弧（`()'）や角括弧
（`[]'）も数えています.  これは, TeXの構文を検査する目的からいえば, 厳
密には正しくありません.  しかし, 括弧や角括弧はテキスト内で対応する区
切りとしてよく使われますし, 各種の移動コマンドや対応関係を自動表示する
コマンドがそれらを扱えると便利です.



File: emacs-ja, Node: LaTeX Editing, Next: TeX Print, Prev: TeX Editing, Up: TeX Mode

LaTeX編集コマンド
-----------------

LaTeXモードと, その変種のSliTeX モードには, プレインTeX（plain-tex）で
は利用できない特別な機能がいくつかあります.

`C-c C-o'
     LaTeXのブロックを表す`\begin'と`\end'を挿入し, それらのあいだにポ
     イントを置く（`tex-latex-block'）.
`C-c C-e'
     まだ閉じていないもっとも内側のLaTeXのブロックを閉じる
     （`tex-close-latex-block'）.

LaTeXの入力では, `\begin'と`\end'がテキストのブロックをグループ化する
ために使われます.  `\begin'と対応する`\end'を（`\begin'のつぎの新しい
行に）挿入するには, `C-c C-o'（`tex-latex-block'）を使います.  それら
のあいだには空行が挿入されてポイントもそこに置かれます.  ブロックの種
類を入力するときには, 補完を使えます.  標準のリストに含まれないブロッ
ク名を使う場合には, 変数`latex-block-names'に設定します.  つぎの例は,
`theorem', `corollary', `proof'を追加するものです.

     (setq latex-block-names '("theorem" "corollary" "proof"))

LaTeXの入力では, `\begin'と`\end'は対応が取れている必要があります.
`C-c C-e'（`tex-close-latex-block'）を使うと, 対応が取れていない最後の
`\begin'に対応する`\end'を自動的に挿入できます.  また, 対応する
`\begin'と同じ字下げを`\end'にも施します.  ポイントが行頭にあったとき
には, `\end'のうしろで改行します.



File: emacs-ja, Node: TeX Print, Next: Nroff Mode, Prev: LaTeX Editing, Up: TeX Mode

TeX印刷コマンド
---------------

バッファ全体あるいは一部のテキストに対して, Emacsの下位プロセスとして
TeXを起動できます.  特定の章だけに対してこのようにTeXを実行するのは, 
ファイル全体の清書に時間を費すことなく, 変更部分の見え方を確認するよい
方法です.

`C-c C-r'
     バッファのヘッダとともに, カレントリージョンに対してTeXを起動する
     （`tex-region'）.
`C-c C-b'
     カレントバッファ全体に対してTeXを起動する（`tex-buffer'）.
`C-c TAB'
     現在のファイルに対してBibTeXを起動する（`tex-bibtex-file'）.
`C-c C-f'
     現在のファイルに対してTeXを起動する（`tex-file'）.
`C-c C-l'
     下位プロセスであるTeXの出力を表示したウィンドウをスクロールして, 
     出力行の最後が見えるようにする（`tex-recenter-output-buffer'）.
`C-c C-k'
     TeXのサブプロセスを終了させる（`tex-kill-job'）.
`C-c C-p'
     最後に実行した`C-c C-r', `C-c C-b', `C-c C-f'の出力を印刷する. 
     （`tex-print'）.
`C-c C-v'
     最後に実行した`C-c C-r', `C-c C-b', `C-c C-f'の出力をプレビューす
     る（`tex-view'）.
`C-c C-q'
     プリンタキューを表示する（`tex-show-print-queue'）.

`C-c C-b'（`tex-buffer'）を使えば, カレントバッファの内容を下位のTeXに
渡すことができます.  清書結果は一時ファイルに出力されます.  それを印刷
するには, `C-c C-p'（`tex-print'）と打ちます.  そのあとで, 印刷の進捗
状況を確認するには`C-c C-q'（`tex-show-print-queue'）を利用できます.
TeXの出力ファイルを表示する機能を持った端末があれば, `C-c C-v'
（`tex-view'）でプレビューできます.

TeXが実行時に使うディレクトリを指定するには, 変数`tex-directory'に設定
します.  デフォルトの値は`"."'です.  環境変数`TEXINPUTS'に相対的なディ
レクトリ名が入っていたり, TeXの`\input'コマンドに相対的なファイル名を
指定してある場合には, `tex-directory'は`"."'である*必要*があります. 
さもないと, 誤った結果になるでしょう.  そういった状況でなければ,
`"/tmp"'のような, 他のディレクトリを設定しても安全です.

下位のTeXを起動するために使うコマンドを指定したければ, 変数
`tex-run-command', `latex-run-command', `slitex-run-command',
`tex-dvi-print-command', `tex-dvi-view-command',
`tex-show-queue-command'にそれぞれ値を設定します.
`tex-dvi-view-command'にはデフォルト値がないので, 使用する端末にあわせ
た値を設定する*必要*があります.  これ以外の変数には, 使用するシステム
に適切と思われる（そうでないかもしれないが）デフォルト値が設定されてい
ます.

通常は, これらのコマンドに与えるファイル名はコマンド文字列の最後にきま
す.  たとえば, `latex FILENAME'です.  しかし, ときにはコマンドの途中に
ファイル名を埋め込む必要があります.  たとえば, パイプを介して出力を他
のコマンドに渡すようなコマンドの引数にファイル名を指定する場合です. 
ファイル名を置く箇所は, コマンド文字列中の`*'で指定できます.  たとえば, 
以下のように設定します.

     (setq tex-dvi-print-command "dvips -f * | lpr")

エラーメッセージを含めたTeXからの端末出力は, `*tex-shell*'と呼ばれるバッ
ファにすべて現れます.  TeXがエラーを報告した場合には, このバッファに切
り替えれば適切な入力を与えることができます（これはシェル（shell）モー
ドと同様に動作する. *Note Interactive Shell::）.  このバッファに切り替
えなくても`C-c C-l'と打てば, バッファの最後の行が表示されるようにスク
ロールできます.

TeXの出力が不要となったら, TeXプロセスを終了させるために`C-c C-k'
（`tex-kill-job'）と打ちます.  `C-c C-b'や`C-c C-r'を使っても, 動作中
のTeXプロセスを終了できます.

`C-c C-r'（`tex-region'）と打てば, 任意のリージョンを下位のTeXに渡せま
す.  しかし, これには少々巧妙な手口を必要とします.  というのは, たいて
いの場合, TeXの入力ファイルの先頭部分にはパラメータの設定やマクロ定義
があり, それらがないと残りの部分を正しく清書できないからです.  この問
題を解決するために, `C-c C-r'ではファイルの中で必須の整形コマンドを含
んでいる部分を指定できます.  リージョンのまえにその部分を加えてTeXへの
入力とします.  ファイル中の必須であると指定された部分を"ヘッダ"と呼び
ます.

プレインTeX（plain-tex）モードでヘッダの境界を示すには, ファイルに2つ
の特別な文字列を挿入します.  ヘッダの直前に`%**start of header'を, ヘッ
ダの直後に`%**end of header'を挿入します.  どちらの文字列も2行にまたがっ
てはいけませんが, 前後に別のテキストがあってもかまいません.  これらの
文字列を持つ行もヘッダに含まれます.  バッファの先頭から100行以内に
`%**start of header'が現れなければ, `C-c C-r'はヘッダがないと仮定しま
す.

LaTeXモードでは, `\documentstyle'で始まり`\begin{document}'で終わる部
分がヘッダです.  これらは, いかなる場合でもLaTeXが要求するコマンドなの
で, ヘッダを認識するために特別なことをする必要はありません.

コマンド`tex-buffer'と`tex-region'は, 一時的なディレクトリ上ですべての
作業を行うので, 相互参照のためにTeXが必要とする補助ファイルを使用でき
ません.  一般に, これらのコマンドは, 相互参照がすべて正しい必要がある
最終的な原稿の作成には適していません.

相互参照のための補助ファイルを必要とする場合には, カレントバッファのファ
イルを入力として, そのファイルを置いたディレクトリでTeXを実行する`C-c
C-f'（`tex-file'）を使います.  TeXを実行するまえに, 変更したすべてのバッ
ファを保存するか尋ねてきます.  一般には, 正しい相互参照を得るためには,
`tex-file'を2度実行する必要があります.

変数`tex-start-options-string'の値は, TeXの実行のオプションを指定しま
す.  デフォルト値は, TeXをバッチモードで実行します.  TeXを対話的に実行
するには, 変数に`""'を設定します.

巨大なTeX文書は, 複数のファイル, つまり, 1つのメインファイルとサブファ
イルとに分割されることがよくあります.  サブファイルに対してTeXを実行し
ても, うまくいくことはまずありません.  メインファイルに対してTeXを実行
する必要があります.  サブファイルを編集する場合でも`tex-file'を使える
ように, メインファイルの名前を変数`tex-main-file'に設定できます.  そう
すると`tex-file'はそのファイルに対してTeXを実行します.

`tex-main-file'のもっとも便利な使い方は, 各サブファイルのローカル変数
リストで指定することです.  *Note File Variables::.

LaTeX用ファイルであれば, カレントバッファのファイルに対する補助ファイ
ルを処理するためにBibTeXを使えます.  BibTeXは, 参考文献をデータベース
で調べて, 参考文献の節のための文献リストを準備します.  コマンド`C-c
TAB'（`tex-bibtex-file'）は, カレントバッファのファイルに対する`.bbl'
ファイルを生成するためのシェルコマンド（`tex-bibtex-command'）を実行し
ます.  通常は, まず`.aux'ファイルを作るために`C-c C-f'（`tex-file'）を
一度実行してから, つぎに`C-c TAB'（`tex-bibtex-file'）を実行し, 正しい
相互参照を得るために`C-c C-f'（`tex-file'）をさらに2回実行します.

どのTeXモードに入っても, フック`text-mode-hook'と`tex-mode-hook'を実行
します.  そのあとで, `plain-tex-mode-hook'か`latex-mode-hook'の適切な
フックを実行します.  SliTeXファイルに対しては, `slitex-mode-hook'を呼
びます.  TeX用のシェルの開始時には, フック`tex-shell-hook'を実行します.
*Note Hooks::.



File: emacs-ja, Node: Nroff Mode, Next: Formatted Text, Prev: TeX Mode, Up: Text

nroffモード
===========

nroffモードはテキスト（text）モードに似ていますが, テキスト中のnroffコ
マンドを扱えるように変更してあります.  このモードに入るには, `M-x
nroff-mode'を実行します.  テキスト（text）モードとは, 2, 3の点で異なる
だけです.  nroffコマンドを含んだ行は, すべて段落区切りとみなすので, 詰
め込みによってnroffコマンドが本文に混ざってしまうことはありません.  ペー
ジは`.bp'コマンドで分割されます.  コメントは`.\"'で始まります.  また, 
テキスト（text）モードにはない, つぎの3つの特別なコマンドがあります.

`M-n'
     nroffコマンドではないつぎの行の先頭にポイントを移動する
     （`forward-text-line'）.  引数は反復回数.
`M-p'
     `M-n'と同様だが, まえの行に移動する（`backward-text-line'）.
`M-?'
     リージョン中のテキスト（nroffコマンド以外）の行数をエコー領域に表
     示する（`count-text-lines'）.

nroffモードの他の機能としては, エレクトリックnroff（electric-nroff）モー
ドがあります.  これは`M-x electric-nroff-mode'でオン／オフできるマイナ
モードです（*Note Minor Modes::）.  このモードがオンのとき, グループを
始めるnroffコマンドを含む行を終えるためにRET (1) (*Note Nroff
Mode-Footnotes::)を打つたびに, そのグループを終える対応したnroffコマン
ドを自動的につぎの行に挿入します.  たとえば, 行頭で`. ( b RET'と打つと, 
ポイントのうしろに新たな行として対応するnroffコマンド`.)b'を挿入します.

nroffモードと一緒にアウトラインマイナ（outline-minor）モード（*Note
Outline Mode::）を使用すると, 見出し行は`.H'のあとに（見出しのレベルに
あたる）数字が続く形になります.

nroffモードに入ると, フック`text-mode-hook'に続いてフック
`nroff-mode-hook'が実行されます（*Note Hooks::）.


