Info file: emacs-ja,    -*-Text-*-
produced by `texinfo-format-buffer'
from file `emacs.texi'
using `texinfmt.el' version 2.38 of 3 July 1998.


Emacs 20.6版対応に改訂した`GNU Emacs Manual' 13版です.

INFO-DIR-SECTION Editors
START-INFO-DIR-ENTRY
* Emacs: (emacs).	The extensible self-documenting text editor.
END-INFO-DIR-ENTRY


Published by the Free Software Foundation 59 Temple Place, Suite 330
Boston, MA 02111-1307 USA

Copyright (C) 1985, 1986, 1987, 1993, 1994, 1995, 1996, 1997, 1998,
1999 Free Software Foundation, Inc.

Permission is granted to make and distribute verbatim copies of this
manual provided the copyright notice and this permission notice are
preserved on all copies.

Permission is granted to copy and distribute modified versions of this
manual under the conditions for verbatim copying, provided also that
the sections entitled "The GNU Manifesto", "Distribution" and "GNU
General Public License" are included exactly as in the original, and
provided that the entire resulting derived work is distributed under
the terms of a permission notice identical to this one.

Permission is granted to copy and distribute translations of this
manual into another language, under the above conditions for modified
versions, except that the sections entitled "The GNU Manifesto",
"Distribution" and "GNU General Public License" may be included in a
translation approved by the Free Software Foundation instead of in the
original English.





File: emacs-ja, Node: Two-Column, Next: Editing Binary Files, Prev: Narrowing, Up: Top

2段組み編集
===========

2段組み（two-column）モードは, 左右の段に分けたテキストを編集するのに
便利です.  このモードでは, 左右に並んだ2つのウィンドウを使用し, それぞ
れに別のバッファを表示します.

2段組み（two-column）モードに入るには, 3つの方法があります.

`F2 2' または `C-x 6 2'
     カレントバッファを左側に, カレントバッファの名前に基づいた名前の
     バッファを右側にして2段組み（two-column）モードに入る
     （`2C-two-columns'）.  右側のバッファがまだ存在しなければ空のバッ
     ファで始まり, カレントバッファの内容は変化しない.

     このコマンドはカレントバッファが空か, または1段目の内容だけを持っ
     ていて, これから2段目を作成しようとするときに使う.

`F2 s' または `C-x 6 s'
     2段組みテキストを含んでいるカレントバッファの内容を2つのバッファ
     に分割し, それらを左右に並べて表示する（`2C-split'）.  カレントバッ
     ファは左側のバッファになるが, 右側の段の内容は右側のバッファに移
     される.  分割位置はポイントのある文字位置で指定する.  現在行から
     バッファの末尾を分割する.

     このコマンドはバッファにすでに2段組みのテキストが入っていて, 一時
     的に左右の段を分けて編集したいときに用いる.

`F2 b BUFFER RET'
`C-x 6 b BUFFER RET'
     カレントバッファを左側のバッファ, BUFFERを右側のバッファとして2段
     組み（two-column）モードに入る（`2C-associate-buffer'）.

`F2 s'と`C-x 6 s'は, 各行を2つの段に分ける文字列である「段区切り文字列」
を探します.  段区切り文字列の文字数は, `F2 s'への数引数で指定できます. 
ポイントの直前のその文字数分の文字列が段区切り文字列になります.  デフォ
ルトでは幅は1ですから, ポイントの直前の文字が段区切り文字列になります.

各行の正しい位置に段区切り文字列があれば, `F2 s'は各行の段区切り文字列
のうしろの文字列を右側のバッファに移し, 段区切り文字列を削除します. 
段区切り文字列が正しい位置にない行は分割されずに左側のバッファに残り, 
対応する右側のバッファの内容は空行になります.  （これは, 『2段組み
（two-column）モードで両側の段にまたがった行』の書き方.  つまり, 左側
のバッファにそのような行を書き, 右側のバッファは空行にしておく）.

コマンド`C-x 6 RET'や`F2 RET' （`2C-newline'）は, 左右の2つのバッファ
の対応する位置に改行を挿入します.  バッファを分割して編集しているとき
に2段組みテキストに新しい行を追加するにはこれがもっとも簡単な方法です.

左右のバッファを望むように編集し終えたら, それらを`F2 1'または`C-x 6
1'（`2C-merge'）で再度併合します.  右側バッファの内容を左側バッファに
第2段目としてコピーします.  再度2段組み編集に戻るには, `F2 s'を使いま
す.

2つのバッファ間の関連を解消するには, `F2 d'または`C-x 6 d'
（`2C-dissociate'）を使います.  コマンドを入力したときにカレントバッファ
でない側のバッファが空であれば, そのバッファは削除します.



File: emacs-ja, Node: Editing Binary Files, Next: Saving Emacs Sessions, Prev: Two-Column, Up: Top

バイナリファイルの編集
======================

バイナリファイルを編集するための特別なメジャーモード, hexlモードがあり
ます.  このモードを使うには, ファイルを訪問する`C-x C-f'のかわりに`M-x
hexl-find-file'を使います.  このコマンドはファイルの内容を16進数表現に
変換し, 変換したものを編集するようにします.  ファイルを保存すると自動
的にバイナリに戻されます.

`M-x hexl-mode'を使えば, 既存のバッファを16進数表現に変換できます.  普
通にファイルを訪問してみたら, 実はバイナリファイルだとわかった場合に便
利です.

hexlモードでは通常のテキスト文字は上書きします.  これはファイル中のデー
タの配置をまちがって壊してしまう危険を減らすためです.  特別な挿入コマ
ンドがあります.  以下は, hexlモードで使えるコマンドの一覧です.

`C-M-d'
     10数進で入力したコードのバイトを挿入する.

`C-M-o'
     8数進で入力したコードのバイトを挿入する.

`C-M-x'
     16数進で入力したコードのバイトを挿入する.

`C-x ['
     1kバイト単位の『ページ』の先頭へ移動する.

`C-x ]'
     1kバイト単位の『ページ』の末尾へ移動する.

`M-g'
     16進数で指定したアドレス位置へ移動する.

`M-j'
     10進数で指定したアドレス位置へ移動する.

`C-c C-c'
     hexlモードを抜け, `hexl-mode'実行前のこのバッファのメジャーモード
     に戻る.



File: emacs-ja, Node: Saving Emacs Sessions, Next: Recursive Edit, Prev: Editing Binary Files, Up: Top

Emacsセッションの保存
=====================

デスクトップ（desktop）ライブラリを使うと, セッションからセッションへ
Emacsの状態を保存できます.  状態を保存するというのは, 以前のEmacsセッ
ションで使っていたのと同じバッファ群, メジャーモード, バッファ内の位置
の状態でEmacsが始まるという意味です.

デスクトップ機能を使うには, カスタマイズバッファ（*Note Easy
Customization::）を使って`desktop-enable'に`nil'以外の値を設定するか, 
個人の`.emacs'ファイルの末尾に以下のような行を追加します.

     (desktop-load-default)
     (desktop-read)

ユーザーが最初にEmacsセッションの状態を保存するときは, `M-x
desktop-save'で陽に状態を保存する必要があります.  一度これを行っておけ
ば, Emacsを終わるときに（現在のセッションだけでなく, それ以降のセッショ
ンでも）自動的に状態を保存します.  また, Emacsを終わらせることなく任意
の時点で状態を保存するには, `M-x desktop-save'を使います.

Emacsがまえのセッションの状態を引き継ぐためには, まえのセッションを開
始したときと同じカレントディレクトリでEmacsを起動する必要があります. 
これは, `desktop-read'が読み込むファイルをカレントディレクトリで探すか
らです.  つまり, 異なるディレクトリごとに別のセッションを保存できるこ
とを意味します.  Emacsを起動するディレクトリで, 保存したどのセッション
を使うか制御できます.

変数`desktop-files-not-to-save'は, 状態保存から除外するファイルを制御
します.  この変数の値は, 除外したいファイルに一致する正規表現です.  デ
フォルトでは, （ftpで取ってきた）リモートファイルを除外します.  これは
リモートファイルを再度取ってくるとセッションの開始が遅くなるからです. 
リモートファイルも状態保存に含めるには, `desktop-files-not-to-save'に
`"^$"'と設定します.  *Note Remote Files::.



File: emacs-ja, Node: Recursive Edit, Next: Emulation, Prev: Saving Emacs Sessions, Up: Top

再帰編集レベル
==============

"再帰編集"とは, あるEmacsコマンドの実行途中で任意のEmacsコマンドを使っ
て編集を行う状況をいいます.  たとえば, `query-replace'の途中で`C-r'を
打つと, 再帰編集に入りカレントバッファを自由に変更できます.  再帰編集
から抜けると, `query-replace'の続きに戻ります.

再帰編集から"脱出"するとは, 実行途中のコマンドに戻ってその続きを行うこ
とを意味します.  脱出のためのコマンドは`C-M-c'（`exit-recursive-edit'）
です.

再帰編集を"アボート"することもできます.  これは脱出と似ていますが, 実
行途中だったコマンドも一緒に中断します.  アボートするには, `C-]'
（`abort-recursive-edit'）を使います.  *Note Quitting::.

再帰編集中は, モード行のメジャー／マイナモード名を囲む丸括弧の外側に中
括弧`[...]'が表示されます.  各ウィンドウのモード行すべてにこのように表
示されます.  というのは, 特定のウィンドウやバッファではなくEmacs全体が
再帰編集に入っているからです.

再帰編集中にさらに再帰編集に入ることもできます.  たとえば,
`query-replace'の途中で`C-r'を打ってからデバッガを起動するコマンドを打っ
たとします.  すると, `C-r'による再帰編集の中でさらにデバッガのための再
帰編集に入ることになります.  モード行には, 現在の再帰編集レベルの数だ
け中括弧の対が表示されます.

内側の再帰編集を（たとえばデバッガのコマンド`c'で）脱出すると, 1つ上の
レベルでのコマンドが再開されます.  そのコマンドが終わったところで
`C-M-c'を使うとそのレベルの再帰編集を脱出する, というようにして再帰編
集を終わらせていくことができます.  脱出はつねにもっとも内側のレベルに
対して起こります.  また, アボートも1つのレベルの再帰編集から脱出し, 1
つまえの再帰編集のコマンドレベルに戻ります.  必要ならそこでつぎの再帰
編集レベルをアボートする, というように続けることができます.

あるいは, コマンド`M-x top-level'ですべてのレベルの再帰編集をアボート
し, ただちにトップレベルのコマンド入力に戻ることができます.

再帰編集の中で編集しているテキストはトップレベルで編集しているテキスト
と同じであるとは限りません.  再帰編集の目的によって変わってきます.  再
帰編集を起動するコマンドがまず別のバッファに切り替えるものなら, そのバッ
ファを再帰的に編集することになるでしょう.  いずれにせよ, 再帰編集の内
側でも（バッファを切り替えるキーが再定義されていない限り）通常どおりバッ
ファを切り替えることができます.  残りの編集作業をすべて再帰編集の内側
でやってしまい, 別のファイルを訪問したりもできます.  しかしそのような
ことをすると, ときどき（スタックオーバーフローなどの）痛い目に合う可能
性があります.  ですから, 再帰編集が不要になったら忘れずに脱出かアボー
トしてください.

一般に, GNU Emacsでは再帰編集レベルを最小限に抑えるように努めています. 
というのは, 再帰編集では特定の順, つまり, 最内側レベルからトップレベル
に向かう順で戻るように強いられるからです.  このため, 別の作業は別のバッ
ファでするようにして, ユーザーがそれらの間を自由に行き来できるようにし
ています.  たとえば, あるコマンドは新しいメジャーモードに切り替えます
が, もとのモードに戻るコマンドを用意しておきます.  このようにしたほう
が, やりかけの作業に戻る順番を自由に選べ, 柔軟性を提供できます.



File: emacs-ja, Node: Emulation, Next: Dissociated Press, Prev: Recursive Edit, Up: Top

エミュレーション
================

GNU Emacsは, 他のほとんどのエディタの（程度の差はありますが）エミュレー
ト（真似を）するようにプログラムできます.  標準の機能では, 以下のもの
をエミュレートできます.

EDT（DECのVMSエディタ）
     `M-x edt-emulation-on'でEDTエミュレーションに入る.  `M-x
     edt-emulation-off'で通常のEmacsのバインディングに戻る.

     EDTエミュレーションコマンドの大部分はキーパッドのキーであり, 大部
     分のEmacsのキーバインディングはそのまま使える.  EDTエミュレーショ
     ンのバインディング変更はグローバルキーマップに対して行われ, EDTエ
     ミュレーションの状態でバッファやメジャーモードを切り替えても問題
     ない.

vi （バークレー エディタ）
     viperは最新のviエミュレータである.  viperでは複数レベルのエミュレー
     ションを実装している.  レベル1がもっともviに近く, レベル5はviとい
     くらか違うところもあるが, そのかわりEmacsの機能も活かせるようになっ
     ている.  viperを起動するには, `M-x viper-mode'と打つ.  すると, 使
     い方のガイドを表示し, どのレベルのエミュレーションにするかを尋ね
     てくる.  *Note Viper: (viper)Top.

vi （もう1つのエミュレータ）
     `M-x vi-mode'はそれまでのメジャーモードにかわってviメジャーモード
     に入る.  viの『入力』モードに入るコマンドはすべて, それまでのメ
     ジャーモードに戻る動作になっている.  つまり, viの『入力』モードと
     して普通のEmacsが使えるのである.

     viエミュレーションはメジャーモードとして動くので, エミュレーショ
     ン中にバッファを切り替えることはできない.  バッファを切り替えたけ
     れば, まず通常のEmacsに戻る.

     viエミュレーションを多用するつもりなら, `vi-mode'コマンドにキーを
     バインドしたほうがよいだろう.

vi （また別のエミュレータ）
     `M-x vip-mode'は, `M-x vi-mode'よりもっとviに酷似しているといわれ
     る別のviエミュレータを起動する.  このエミュレータでは『入力』モー
     ドも通常のEmacsとは変わっていて, ESCでviコマンドモードに戻る.  vi
     コマンドモードのエミュレーションから通常のEmacsに戻るには`C-z'と
     打つ.

     このエミュレータはメジャーモードとして動くのではないので, エミュ
     レータを動かしたままさまざまな方法でバッファを切り替えることがで
     きる.  `vi-mode'のようにコマンド`vi-mode'で入力モードを終了するの
     ではないので, `vip-mode'にキーを割り当てる必要はない.

     より詳しくは*Note VIP: (vip)Top.



File: emacs-ja, Node: Dissociated Press, Next: Amusements, Prev: Emulation, Up: Top

まぜこぜ新聞（Dissociated Press）
=================================

`M-x dissociated-press'はテキストを, 単語単位, または, 文字単位で混ぜ
合わせるコマンドです.  普通の英語をバッファに入れた状態でこれを実行す
ると, きわめておもしろい結果が生成されます.  入力はカレントバッファか
ら取り, 出力は`*Dissociation*'というバッファに書き込みます（およそ2, 3
行生成するごとにバッファが再表示されるので, 生成内容を順次読めます）.

`M-x dissociated-press'は定期的にもっと出力を続けるかどうか聞いてきま
す.  `n'と答えると生成をやめます.  また, `C-g'を打てばいつでも止められ
ます.  出力はバッファ`*Dissociation*'に残っていますから, 必要ならどこ
へでもコピーできます.

`M-x dissociated-press'はバッファ中のある箇所からランダムに別の箇所に
ジャンプすることを繰り返していきます.  ただのゴミではなくおもしろい出
力が得られるように, ある一連の単語列からつぎの一連の単語列に移る際に, 
それらのあいだに一定の重複があるようにします.  つまり, たとえば
presidentと出力したところで別の場所にジャンプすることに決めたら, 最後
にあったentと同じ文字列のある単語, たとえばpentagonのところに飛んでそ
こから続けるので, 結果としてpregidentagon (1) (*Note Dissociated
Press-Footnotes::) というのが生成されるわけです.  元テキストが長いとた
いへんおもしろい結果を得られます.

`M-x dissociated-press'に正の数引数を渡すと文字単位で動作し, その数値
は重複する文字数を指定します.  また, 負の数引数を渡すと単語単位で動作
し, その数値（の絶対値）で重複する単語数を指定します.  引数を指定しな
いと「2」を指定したのと同じになります.  繰り返しますが, 出力はつねにバッ
ファ`*Dissociation*'に現れます.  もとのバッファは変更されません.

`M-x dissociated-press'は, 入力テキストから頻度表を作ってマルコフ連鎖
を適用したのに近い結果をもたらしますが, それ自体はきわめてオリジナルな
発明です.  というのは, マルコフ連鎖では単に乱数に基づいて文字や語を選
ぶだけなのに対し, このコマンドでは乱数に基づいて連続した文字や語をコピー
してくるからです.  このため, より高速な実行が可能ですし, 読んでおもし
ろい結果が得られます.

`M-x dissociated-press'の使いすぎは仕事に差し支え, 場合によっては重大
な障碍となりますから注意しましょう.  また, ユーザーに受け入れてもらう
ためにも, マニュアルにこのコマンドの出力を利用するのはやめたほうがよい
です.  でも, せいぜい楽しんで, よかったらバグの提案もよろしく. (2)
(*Note Dissociated Press-Footnotes::)


File: emacs-ja  Node: Dissociated Press-Footnotes, Up: Dissociated Press

(1) この合成語は, ベトナム戦争中にまさにそれにぴったりの意味で実際に使
われたことがある.

(2) 【訳注】 この段落自体, `M-x dissociated-press'で生成したような
ものなので, 原文を掲載しておく.  
 It is a mustatement that too much
use of Dissociated Press can be a developediment to your real work.
Sometimes to the point of outragedy.  And keep dissociwords out of
your documentation, if you want it to be well userenced and
properbose.  Have fun.  Your buggestions are welcome.



File: emacs-ja, Node: Amusements, Next: Customization, Prev: Dissociated Press, Up: Top

その他の娯楽
============

退屈なときは, `M-x hanoi'を試してください.  ひどく退屈なら, 数引数を指
定してください.  ものすごく, ひどく退屈なら, 「9」を指定するとよいでしょ
う.  まあやってみてください.

もう少し積極的に何かしたいなら, `M-x gomoku'を試してください.  これは
五目並べのプログラムです.

`M-x blackbox'と`M-x mpuz'は2種類のパズルです.  `blackbox'は箱の中の物
の位置を当てるゲームです.  `mpuz'は掛け算の覆面算で, 英字に対応してい
る数字を当てるゲームです.  英字を打ってからその英字に対応していると思
う数字を打ち込みます.

`M-x dunnet'はアドベンチャー風の探検ゲームで, 大きなパズルだと思えばよ
いでしょう.

いらいらするときは, 有名なElizaプログラムを試してみてください.  `M-x
doctor'と打つだけです.  1つの入力の終りにはRETを2回打ちます.

奇妙な感じがするときは, `M-x yow'と打ってみてください.


File: emacs-ja, Node: Customization, Next: Quitting, Prev: Amusements, Up: Top

カスタマイズ
************

本章では, Emacsの動作を（あまり大幅でなく）カスタマイズする方法につい
て説明します.  もっと大幅な変更を行いたい場合には`The Emacs Lisp
Reference Manual'を参照してください.

カスタマイズは, Emacsの1つのセッションの中だけで効果を持ちます.  Emacs
を終了するとカスタマイズの効果は失われますし, 同時にあるいはあとで別の
Emacsを立ち上げた場合にも何の影響も及ぼしません.  あるEmacsのセッショ
ンがセッションを超えて影響するためには, ファイルに書くしかありません. 
特に, カスタマイズを『恒久化』したい場合には, 個人の`.emacs'ファイルや
その他の関連するファイルに適切な内容を書き込んでおき, セッションごとに
カスタマイズが行われるようにします.  *Note Init File::.

* Menu:

* Minor Modes::		Each minor mode is one feature you can turn on
			  independently of any others.
* Variables::		Many Emacs commands examine Emacs variables
			  to decide what to do; by setting variables,
			  you can control their functioning.
* Keyboard Macros::	A keyboard macro records a sequence of
			  keystrokes to be replayed with a single
			  command. 
* Key Bindings::	The keymaps say what command each key runs.
			  By changing them, you can "redefine keys".
* Keyboard Translations::
                        If your keyboard passes an undesired code
			   for a key, you can tell Emacs to
			   substitute another code. 
* Syntax::		The syntax table controls how words and
			   expressions are parsed.
* Init File::		How to write common customizations in the
			  `.emacs' file. 



File: emacs-ja, Node: Minor Modes, Next: Variables, Prev: Customization, Up: Customization

マイナモード（minor mode）
==========================

マイナモードは, 個別にオン／オフ可能な機能です.  たとえば, マイナモー
ドである自動詰め込み（auto-fill）モードをオンにすると, SPCで自動的に
（単語の切れ目で）行分けします.  すべてのマイナモードは互いに独立です
し, どのメジャーモードとも独立です.  ほとんどのマイナモードは, それが
オンであることをモード行に表示します.  たとえば, モード行に`Fill'と表
示されていれば, 自動詰め込み（auto-fill）モードがオンであることを意味
します.

マイナモード名のうしろに`-mode'を付け加えると, そのモードをオン／オフ
するコマンド関数の名前になります.  したがって, 自動詰め込み（auto-fill）
モードをオン／オフするコマンドは`M-x auto-fill-mode'ということになりま
す.  これらのコマンドは通常`M-x'を使って起動しますが, どれかのキーにバ
インドすることもできます.  引数を指定しないと, これらのコマンドはモー
ドがオフのときはオンに, オンのときはオフに切り替えます.  これを"トグル
する"と呼びます.  これに対し, 正の引数を指定するとつねにモードをオンに
しますし, 明示的に0の引数を指定するか, または負の引数を指定するとつね
にモードをオフにします.

いくつかのマイナモードのオン／オフは, カレントバッファに対してのみ適用
され, 他のバッファには影響しません.  つまり, あるバッファであるモード
をオンにし, 別のバッファではそのモードをオフにできるわけです.  このよ
うな, バッファごとにオン／オフできるマイナモードとしては, 略語（abbrev）
モード, 自動詰め込み（auto-fill）モード, 自動保存（auto-save）モード, 
フォントロック（font-lock）モード, ISOアクセント（iso-sccents）モード, 
アウトライン（outline）マイナモード, 上書き（overwrite）モード, バイナ
リ上書き（binary-overwrite）モードがあります.

略語（abbrev）モードでは, 略語を打ち込むと自動的に展開されるような略語
を定義できます.  たとえば, `amd'を`abbrev mode'と展開させます.  詳しく
は, *Note Abbrevs::.

自動詰め込み（auto-fill）モードでは, いちいち改行で行分けしなくてもテ
キストを詰め込んで入力できます.  行が長くなりすぎないようにEmacsが適宜
改行を挿入します.  *Note Filling::.

自動保存（auto-save）モードはバッファの内容を定期的に保存することで, 
システムクラッシュが起きたとき紛失してしまう作業の量を少なくします.
*Note Auto Save::.

エンリッチ（enriched）モードは, 整形済みテキストの編集を可能にします.
*Note Formatted Text::.

フライスペル（flyspell）モードは, 綴りに誤りのある単語を自動的に強調表
示します.

フォントロック（font-lock）モードは, コメント, 文字列, 定義中の関数名
などのプログラム中の決まった単位を自動的に強調表示します.  これには, 
複数のフォントを表示できるウィンドウシステムが必要です.  *Note
Faces::.

水平スクロール（hscroll）モードは, ポイントが画面内に留まるように, 自
動的に水平スクロールを行います.  *Note Horizontal Scrolling::.

ISOアクセント（iso-accents）モードは, ``', `'', `"', `^', `/', `~'とこ
れらに続くつぎの文字を結合して, ISO Latin-1文字集合のアクセント付き文
字を作り出します.  *Note Single-Byte European Support::.

アウトラインマイナ（outline-minor）モードは, メジャーモードであるアウ
トライン（outline）モードと同じ機能を提供します.  しかし, マイナモード
なので任意のメジャーモードと一緒に使えます.  *Note Outline Mode::.

上書き（overwrite）モードでは, 入力された図形文字は既存の文字を右に押
しやるかわりにその文字を置き換えます.  たとえば, ポイントが`FOOBAR'の
`B'のまえにあるときに`G'を打つと`FOOGAR'となります.  通常のモードであ
れば`FOOGBAR'となります.  上書き（overwrite）モードでコマンド`C-q'を打
つと, そのつぎの文字が何であっても（数字であっても）その文字を挿入しま
す.  つまり, 上書き（overwrite）モードの中で文字を挿入するにはこの方法
を使います.

バイナリ上書き（binary-overwrite）モードは上書き（overwrite）モードの
変形で, バイナリファイル編集用です.  このモードでは, 改行やタブも他の
文字と同じに扱われるので, 他の文字をこれらの文字で上書きすることも, こ
れらの文字を他の文字で上書きすることもできます.

以下で説明するマイナモードは, すべてのバッファに一斉に適用されます. 
ただし, これらは変数の値に応じてオン／オフされますから, その変数をバッ
ファにローカルな変数にすれば, バッファごとに独立にオン／オフすることも
可能です.  *Note Locals::.

補完示唆（icomplete）モードは, ミニバッファで入力中に補完機能が働いて
いるとき, どのような補完候補があるかを表示します.  *Note Completion
Options::.

行番号（line-number）モードは, ポイントのある行の行番号を絶えずモード
行に表示します.  *Note Mode Line::.

ミニバッファリサイズ（resize-minibuffer）モードは, 打ち込んだテキスト
量に応じて自動的にミニバッファを広げます.  *Note Minibuffer Edit::.

スクロールバー（scroll-bar）モードは, 各ウィンドウにスクロールバーを付
けます（*Note Scroll Bars::）.  メニューバー（menu-bar）モードは, 各フ
レームにメニューバーを付けます（*Note Menu Bars::）.  どちらのモードも,
Xウィンドウシステムを使っているときはデフォルトでオンになっています.

暫定マーク（transient-mark）モードでは, バッファの内容を変更するとマー
クは『不活性』になるので, そのあとでリージョンを対象とするコマンドを使
うとエラーになります.  つまり, リージョンを対象とするコマンドを使うま
えに, 改めてマークを設定するか, 不活性になったマークを『再度活性』にし
ます.  暫定マーク（transient-mark）モードの利点は, （今のところXウィン
ドウシステムを使っているときのみ）Emacsがリージョンを強調表示すること
です.  *Note Setting Mark::.

ほとんどのマイナモードには, コマンド名と同じ名前の変数があり, その変数
でモードを直接制御しています.  つまり, その変数の値が`nil'以外ならモー
ドはオンであり, 各マイナモードコマンドは変数の値を設定する動作をします. 
たとえば, コマンド`outline-minor-mode'は, 変数`outline-minor-mode'の値
を設定する動作を行います.  つまり, この変数が, 直接, 上書き（overwrite）
モードをオン／オフしているのです.  あるマイナモードがこのように動作す
るかどうかは, `C-h v'を使ってその変数の説明文字列を参照してください.

これらのマイナモード変数は, Lispプログラムからモードをオン／オフするの
に有用です.  また, ファイルのローカル変数リストとして指定するのも便利
です.  ただし, ローカル変数リストで設定する場合には, よく考えてくださ
い.  というのは, ほとんどのマイナモードはユーザーの好みの問題であり, 
同じファイルを編集する別のユーザーは好みが違うかもしれません.



File: emacs-ja, Node: Variables, Next: Keyboard Macros, Prev: Minor Modes, Up: Customization

変数
====

"変数"は値を持つLispシンボル（記号）です.  そのシンボルの名前のことを, 
変数名とも呼びます.  変数名はファイルに入れられるどのような文字でも含
むことができますが, 習慣的には, 変数名は英単語をハイフンでつなげたもの
です.  変数には, その変数がどのような値を持ち, どのように使われるかを
記述した説明文字列を持たせることができます.

Lispではどの変数にどのような値でも格納できますが, Emacsの中ではほとん
どの変数はどのような値を持つかが決まっています.  たとえば, ある変数は
つねに文字列である, 別の変数は数値であるといった具合です.  また, 「こ
れこれの機能はこの変数が`nil'以外のときにオンになる」といういい方もし
ます.  その場合は, その変数に`nil'が格納されているときはその機能はオフ
ですが, それ以外の*どんな*値が格納されているときでもその機能はオンにな
ります.  ですが, ある機能をオンにするために使う値として何か選ばなけれ
ばなりませんから, `t'という値を使うのが習慣です.

Emacsは一般のLispプログラムと同様, 内部で情報を保持するために数多くの
変数を使いますが, ユーザーにとって特に興味深い変数というのは, もっぱら
カスタマイズ向けに用意された変数だといえます.  Emacsは（通常は）そのよ
うな変数の値を変更しません.  かわりに, ユーザーが値を設定すると, その
値に応じてさまざまなEmacsコマンドのふるまいを変更したり制御したりでき
るのです.  これらの変数のことを"ユーザーオプション"といいます.  ほとん
どのユーザーオプションはこのマニュアルに記載してありますし, 変数索引
（*Note Variable Index::）にも記載してあります.

ユーザーオプションであるような変数の例として`fill-column'があります. 
この変数は, 詰め込みコマンド（*Note Filling::）が使う右端の桁位置を
（左端から何文字右かを表す数値として）保持します.

* Menu:

* Examining::	        Examining or setting one variable's value.
* Easy Customization::
                        Convenient and easy customization of variables.
* Hooks::	        Hook variables let you specify programs for parts
		          of Emacs to run on particular occasions.
* Locals::	        Per-buffer values of variables.
* File Variables::      How files can specify variable values.



File: emacs-ja, Node: Examining, Next: Easy Customization, Prev: Variables, Up: Variables

変数の設定と参照
----------------

`C-h v VAR RET'
     変数VARの値と説明文字列を表示する（`describe-variable'）.
`M-x set-variable RET VAR RET VALUE RET'
     変数VARの値をVALUEに変更する.

特定の変数の値を見るには, `C-h v'（`describe-variables'）を使います. 
このコマンドは, ミニバッファで補完機能付きで変数名を読み取ります.  変
数の値と説明文字列の双方を表示します.  たとえば,

     C-h v fill-column RET

とすると, つぎのように表示されます.

     fill-column's value is 75

     Documentation:
     *Column beyond which automatic line-wrapping should happen.
     Automatically becomes buffer-local when set in any fashion.

説明文の先頭にある`*'は, この変数がユーザーオプションであることを示し
ます.  `C-h v'は, ユーザーオプションに限らず任意の変数を扱えます.

ユーザーオプションを設定するいちばん簡単な方法は`M-x set-variable'を使
うことです.  このコマンドは, まずミニバッファで（補完機能付きで）変数
名を読み取り, つぎにミニバッファで変数に設定するLisp式を読み取ります. 
たとえば,

     M-x set-variable RET fill-column RET 75 RET

とすると, `fill-column'に75を設定します.

`M-x set-variable'はユーザーオプションに対してだけ使えます.  これに対
し, `setq'を使えばどの変数にでも値が設定できます.  たとえば, `setq'を
使って`fill-column'に設定するにはつぎのようにします.

     (setq fill-column 75)

このような式を実行するには, `*scratch*'バッファにいき, 式を打ち込んで
から`C-j'を打ちます.  *Note Lisp Interaction::.

変数を設定することは, 特記していない限り, 他のカスタマイズ方法と同様に, 
現在のEmacsセッションだけに影響します.



File: emacs-ja, Node: Easy Customization, Next: Hooks, Prev: Examining, Up: Variables

簡便なカスタマイズ方法
----------------------

変更したいユーザーオプション変数をみつけて値を変更する便利な方法は,
`M-x customize'を使うことです.  このコマンドは"カスタマイズバッファ"を
作成し, そのバッファ内では論理的な順序に並べたEmacsのユーザーオプショ
ンを眺めてまわることができますし, さらに値を編集して設定できます.  ま
た, カスタマイズバッファを使えば設定を恒久的なものとして保存もできます. 
（まだこの機能で扱えないユーザーオプションもあるが, それらも扱えるよう
に現在作業中. ）

* Menu:

* Groups: Customization Groups.
                             How options are classified in a structure.
* Changing an Option::       How to edit a value and set an option.
* Face Customization::       How to edit the attributes of a face.
* Specific Customization::   Making a customization buffer for specific
                                options, faces, or groups.



File: emacs-ja, Node: Customization Groups, Next: Changing an Option, Prev: Easy Customization, Up: Easy Customization

カスタマイズグループ
....................

カスタマイズのために, ユーザーオプションを"グループ"にまとめてみつけや
すくしてあります.  グループはさらに大きなグループにまとめられていて, 
いちばん大きな（すべてのグループを含む）グループは`Emacs'という名前で
す.

`M-x customize'は, トップレベルの`Emacs'グループおよびその直下の（第2
レベルの）グループを表示したカスタマイズバッファを作成します.  その表
示はつぎのようになります.

     /- Emacs group: ---------------------------------------------------\
           [State]: visible group members are all at standard settings.
        Customization of the One True Editor.
        See also [Manual].

     Editing group: [Go to Group] 
     Basic text editing facilities.

     External group: [Go to Group] 
     Interfacing to external utilities.

     MORE SECOND-LEVEL GROUPS

     \- Emacs group end ------------------------------------------------/


この表示の先頭部分は, このバッファが`Emacs'グループの内容を表示してい
ることを記しています.  残りのグループが表示されるのは, それらが`Emacs'
グループに含まれているからです.  ただし, それらは字下げや「-」なしで表
示されていて, 表示にはそれらのグループの内容が含まれては*いない*ことを
示しています.  各グループの表示には1行の説明文字列が付随しています. 
また, `Emacs'グループについては`[State]'行が付随しています.

カスタマイズバッファ内のテキストのほとんどは変更できませんが, 一部分は
"編集可能フィールド"になっていて, 変更できます.  また, "アクティブフィー
ルド"という, その場所を"起動"するとなんらかの動作を行うような場所もあ
ります.  アクティブフィールドを起動するには, `Mouse-1'でそこをクリック
するか, またはそこにポイントを持っていってRETを打ちます.

たとえば, 第2レベルグループ中の`[Go to Group]'と記された部分はアクティ
ブフィールドです.  `[Go to Group]'のフィールドを起動すると, そのグルー
プとそのグループの内容を表示する新しいカスタマイズバッファが作られ, そ
のグループと中身が表示されます.  このフィールドは他のグループへのハイ
パーテキストリンクの一種です.

`Emacs'グループそのものはユーザーオプションを1つも含んでいませんが, 他
のグループにはあります.  さまざまなグループを眺めてみると, 興味を持っ
てカスタマイズしてみようと思うような機能に属するオプションやフェイスを
みつけることができるでしょう.

カスタマイズグループ群の構造を概観するには, `M-x customize-browse'を使
います.  このコマンドは, グループ名（とオプションやフェイス）とそれら
の構造だけを表示する特別なカスタマイズバッファを作ります.

このバッファ中では, グループの中身を見るには`[+]'のところを起動します. 
グループの中身が見えるようになると, このボタンは`[-]'に変わります.  こ
れを起動すると中身を（もとどおり）隠します.

各グループ, オプション, フェイスにはそれぞれ`[Group]', `[Option]',
`[Face]'と記されたアクティブフィールドがあります.  それらを起動すると, 
そのグループ／オプション／フェイスのみを表示した通常のカスタマイズバッ
ファが作成されます.  そのバッファで値を設定します.



File: emacs-ja, Node: Changing an Option, Next: Face Customization, Prev: Customization Groups, Up: Easy Customization

オプションの変更
................

カスタマイズバッファでユーザーオプションがどのように見えるか, 例をあげ
ましょう.

     Kill Ring Max: [Hide] 30
        [State]: this option is unchanged from its standard setting.
     Maximum length of kill ring before oldest elements are thrown away.

`[Hide]'に続くテキスト, つまり, `30'がオプションの現在の値を示していま
す.  `[Hide]'ではなく`[Show]'と表示されていれば, 値は隠されています. 
カスタマイズバッファでは, 複数行にわたるような値は最初は隠されていて,
`[Show]'を起動すると表示されます.

オプション名に続く行はオプションの"カスタマイズ状態"を示しています. 
上の例では, まだ変更していないと表示されています.  行頭の`[State]'のと
ころがアクティブフィールドで, ここを`Mouse-1'かRETで起動するとさまざま
な操作を示すメニューが表示されます.  これらの操作は変数をカスタマイズ
するうえでとても重要です.

`[State]'のつぎの行には, そのオプションの説明文字列の先頭部分が表示さ
れます.  1行に収まらない場合には, 行末に`[More]'と表示されます.  これ
を起動すると説明文字列全体が表示されます.

`Kill Ring Max'に新しい値を設定するには, ポイントを値の位置へ持っていっ
て直接文字列を変更します.  たとえば, `M-d'で現在の値を削除してから, 設
定する数値を打ち込めばよいのです.

文字列を変更し始めると, `[State]'行の表示が変わって, 値が編集されてい
ることを示すようになります.

     [State]: you have edited the value as text, but not set the option.

文字列を変更しただけでは, まだオプション変数の値は設定されません.  値
を"設定する"には, `[State]'のところを起動して, `Set for Current
Session'を選択します.

値を設定すると, オプションの状態表示も対応して変わります.

     [State]: you have set this option, but not saved it for future sessions.

正しくない値を設定してしまう心配はありません.  というのは, オプション
の設定時には, 値の正しさを検査して, 正しくない値は設定できないようになっ
ています.

ディレクトリ名, ファイル名, コマンド名である値やフィールドを編集すると
き, および, その他何であれ補完が定義されているものを編集するときは,
`M-TAB'（`widget-complete'）を打てば補完できます.

いくつかのオプションでは, 正しい値としては決まった少数のものだけを使え
ます.  そのようなオプションは, テキストとしては編集できません.  かわり
に`[Value Menu]'というアクティブフィールドが値のまえに現れます.  『オ
ンかオフ』だけの真偽値を持つオプションでは, アクティブフィールドは
`[Toggle]'と表示されていて, そこを起動するたびに値を反転できます.
`[Value Menu]'も`[Toggle]'もバッファを変更するだけです.  値が実際に設
定されるのは`Set for Current Session'を起動したときです.

いくつかのオプションは, 込み入った構造の値を持ちます.  たとえば,
`load-path'は値としてディレクトリのリストを持ちます.  これをカスタマイ
ズバッファに表示すると, つぎのようになります.

     Load Path:
     [INS] [DEL] [Current dir?]: /usr/local/share/emacs/20.3/site-lisp
     [INS] [DEL] [Current dir?]: /usr/local/share/emacs/site-lisp
     [INS] [DEL] [Current dir?]: /usr/local/share/emacs/20.3/leim
     [INS] [DEL] [Current dir?]: /usr/local/share/emacs/20.3/lisp
     [INS] [DEL] [Current dir?]: /build/emacs/e20/lisp
     [INS] [DEL] [Current dir?]: /build/emacs/e20/lisp/gnus
     [INS]
        [State]: this item has been changed outside the customization buffer.
     List of directories to search for files to load....

リスト中の各ディレクトリがそれぞれ別の行に表示され, 各行にはいくつかの
編集可能／アクティブフィールドがあります.

どのディレクトリ名も直接編集できます.  リストからディレクトリを削除す
るには, その行の`[DEL]'を起動します.  リストに新しいディレクトリを追加
するには, 挿入したい箇所の`[INS]'を起動します.

`[Current dir?]'を起動すると, パスに特定のディレクトリを含めるのか, ま
たは, `nil'を含めるのかを切り替えられます.  （探索パスにおける`nil'は, 
『カレントディレクトリを探せ』という意味. ）

2つの特別なコマンド, TABと`S-TAB'は, カスタマイズバッファ内での移動に
役立ちます.  TAB（`widget-forward'）はつぎのアクティブ／編集可能フィー
ルドへ移動します.  `S-TAB'（`widget-backward'）は, 1つまえのアクティブ／
編集可能フィールドへ移動します.

編集可能フィールドでRETを打つと, TABと同様につぎのフィールドへ進みます. 
なぜそうなっているかというと, 編集可能フィールドを編集し終えると最後に
RETを打つ人が多いからです.  編集可能フィールドに改行文字を入るには,
`C-o'か`C-q C-j'と打ちます.

オプションを設定すると, その値は現在のEmacsセッションだけに有効です. 
その値を"保存"すると, 将来のセッションでも有効になります.  保存を行う
と, 個人の`~/.emacs'ファイルにコードが追加されて, つぎにEmacsを起動し
たときにオプション変数の値を設定するようになります.  オプションを保存
するには, `[State]'を起動して`Save for Future Sessions'を選びます.

オプションを標準値に戻したければ, `[State]'を起動して`Reset to
Standard Settings'を選びます.  実際にはつぎの3種類のリセット操作があり
ます.

`Reset'
     なんらかの修正を行ったが, まだオプションを設定していなければ, こ
     の操作により, カスタマイズバッファ上のテキストをオプションの現在
     値と一致させられる.

`Reset to Saved'
     この操作では, オプションの値を最後に保存した値に戻し, カスタマイ
     ズバッファ上のテキストもその値に合わせる.

`Reset to Standard Settings'
     この操作では, オプションを標準値に設定し, カスタマイズバッファ上
     のテキストもその値に合わせる.  さらに, 以前にそのオプションについ
     て保存した値もすべてもとに戻されるので, 将来のEmacsセッションでも
     すべて標準値が使われるようになる.

グループの`[State]'はそのグループに属するもののどれかが編集された／設
定された／保存されたことを示します.  `Set for Current Session', `Save
for Future Sessions', および各種の`Reset'をグループ全体に対して適用で
きます.  これらの操作はグループおよびそのサブグループに属するすべての
オプションに対して適用されます.

カスタマイズバッファの先頭付近には, いくつかのアクティブフィールドを含
んだつぎのような行があります.

      [Set for Current Session] [Save for Future Sessions]
      [Reset] [Reset to Saved] [Reset to Standard]   [Bury Buffer]

`[Bury Buffer]'を起動すると, カスタマイズバッファを消します.  他のフィー
ルドは, そのバッファに含まれている項目それぞれについてそれぞれ, 設定, 
保存, リセットを（それらの操作が適用可能なら）実行します.



File: emacs-ja, Node: Face Customization, Next: Specific Customization, Prev: Changing an Option, Up: Easy Customization

フェイスのカスタマイズ
......................

いくつかのカスタマイズグループは, ユーザーオプションに加えてフェイスも
含みます.  グループの内容を表示したとき, オプションとフェイスの両方が
カスタマイズバッファに現れます.  フェイスの見え方は, たとえばつぎのよ
うになります.

     Custom Changed Face: (sample)
        [State]: this face is unchanged from its standard setting.
     Face used when the customize item has been changed.
     Attributes: [ ] Bold: [toggle] off
                 [X] Italic: [toggle] on
                 [ ] Underline: [toggle] off
                 [ ] Inverse-Video: [toggle] on
                 [ ] Foreground: black (sample)
                 [ ] Background: white (sample)
                 [ ] Stipple:  

フェイスの各属性はそれぞれが1行を占めます.  属性のまえの`[X]'というフィー
ルドは, その属性が"オンになっている"かどうかを表示しています.  `X'が表
示されていればオンになっています.  そのフィールドを起動することでオン／
オフを反転できます.  属性がオンになっている場合は, その属性の値をオプ
ションと同様にして変更できす.

白黒ディスプレイでは, 背景に設定可能な表示色は`black', `white',
`gray', `gray1', `gray3'のいずれかです.  Emacsは表示色のかわりにドット
パターンで灰色の階調を表します.

フェイスを設定／保存／リセットするのは, オプションと同様にしてできます
（*Note Changing an Option::）.

フェイスでは, ディスプレイの種別ごとに異なる見え方を指定できます.  た
とえば, あるフェイスをカラーディスプレイでは赤で表示し, 白黒ディスプレ
イではかわりにボールド体で表示するようにできます.  あるフェイスに複数
の見え方を指定するには, `[State]'メニューを表示させて`Show Display
Types'を選びます.

フェイスの属性を設定するもっと基本的な方法は, `M-x modify-face'を使う
ことです.  このコマンドは, まずフェイスの名前を聞いてきて, 続いて属性
を1つずつ順に聞いてきます.  表示色やパターンの属性では, その属性の現在
の値がデフォルトになっています.  これらを変更したくなければ, 単に, RET
を打てばよいのです.  属性を空にしたければ`none'と打ちます.



File: emacs-ja, Node: Specific Customization, Next: Hooks, Prev: Face Customization, Up: Easy Customization

特定項目のカスタマイズ
......................

グループ構造を1段ずつ降りていって目指すオプションを探すかわりに, カス
タマイズしたいオプション／フェイス／グループの名前を直接に指定すること
もできます.

`M-x customize-option RET OPTION RET'
     指定したオプションOPTIONだけを含むカスタマイズバッファを開く.
`M-x customize-face RET FACE RET'
     指定したフェイスFACEだけを含むカスタマイズバッファを開く.
`M-x customize-group RET GROUP RET'
     指定したグループGROUPだけを含むカスタマイズバッファを開く.
`M-x customize-apropos RET REGEXP RET'
     指定した正規表現REGEXPに一致するすべてのオプション／フェイス／グ
     ループを含むカスタマイズバッファを開く.
`M-x customize-changed-options RET VERSION RET'
     EmacsのバージョンVERSION以降に意味が変更されたすべてのオプション／
     フェイス／グループを含むカスタマイズバッファを開く.
`M-x customize-saved'
     カスタマイズバッファで保存したすべてのオプションとフェイスを含む
     カスタマイズバッファを開く.
`M-x customize-customized'
     カスタマイズしたが, まだ保存していないすべてのオプションとフェイ
     スを含むカスタマイズバッファを開く.

名前のわかっているオプション変数をカスタマイズバッファで変更したい場合
は, コマンド`M-x customize-option'で直接名前を指定します.  これにより, 
そのオプションだけを含むカスタマイズバッファが現れます.  編集／設定／
保存はこれまで説明したとおりに行いますが, 設定の対象になるのは指定した
オプションだけです.

同様にして, `M-x customize-face'ではフェイス名を指定して変更できます.

同様に, `M-x customize-group'ではグループ名を指定してカスタマイズバッ
ファを開くことができます.  そのカスタマイズバッファには, 指定したグルー
プに直接含まれているオプション, フェイス, 他の（下位の）グループが現れ
ます.  ただし, サブグループの内容は最初は隠されています.  それらを表示
したい場合は, 通常どおり`[Show]'を起動します.

`M-x customize-apropos'を使うと, カスタマイズするものをもっと細かく制
御できます.  このコマンドでは引数として正規表現を指定し, それに一致す
るすべてのオプション／フェイス／グループを含んだカスタマイズバッファが
現れます.  空の正規表現を指定すると, *すべての*オプション／フェイス／
グループを含むカスタマイズバッファができます（ただしすごく時間がかかる）.

Emacsの新版へ更新したときには, 新しいオプション, 意味やデフォルト値が
変更されたオプションをカスタマイズしたいはずです.  それには, `M-x
customize-changed-options'を使い, ミニバッファで以前の版のEmacsのバー
ジョン番号を指定します.  すると, 指定したバージョン以降に定義が変更さ
れたすべてのオプション（とグループ）を含んだカスタマイズバッファを作り
ます.

オプションを変更したあとでまちがったと気づいたときは, 変更したものを再
検討するために2つのコマンドが使えます.  保存してしまったオプションにつ
いては`customize-saved'を, 変更したけれどまだ保存していないオプション
については`M-x customize-customized'を使います.



File: emacs-ja, Node: Hooks, Next: Locals, Prev: Easy Customization, Up: Variables

フック
------

"フック"とはある特定の状況で既存のプログラムから呼び出される関数／関数
群を格納しておく変数をいいます.  Emacsには, カスタマイズ用のフックが数
多くあります.

Emacs中のほとんどのフックは"ノーマルフック"です.  これらの変数は, 引数
なしで呼び出される関数のリストを保持します.  ほとんどのフックがノーマ
ルフックなのは, それらを統一的に扱えるからです.  Emacsでは, `-hook'で
終わる名前の変数はすべてノーマルフックです.

ほとんどのメジャーモードは初期設定の最終段階でフックを実行します.  モー
ドが設定したローカル変数をフックで変更すればよいので, モードのふるまい
をユーザーがカスタマイズすることが容易になります.  しかし, フックはそ
れ以外の場面でも使われます.  たとえば, `suspend-hook'は, Emacsが休止す
る直前に実行されます（*Note Exiting::）.

ノーマルフックにフック関数を追加するお勧めのやり方は, `add-hook'を呼ぶ
ことです.  フック関数としては任意のLisp関数を使えます.  たとえば, テキ
スト（text）モードやテキスト（text）モードを基にしているモードにおいて, 
自動的に自動詰め込み（auto-fill）モードをオンにするにはつぎのようにし
ます

     (add-hook 'text-mode-hook 'turn-on-auto-fill)

つぎの例は, Cコードの字下げをカスタマイズするのにフックを使う方法を示
します.  （誰でも字下げには独自の好みがある）.  ここでは, フック関数は
名前のないラムダ式です.

     (setq my-c-style
       '((c-comment-only-line-offset . 4)
         (c-cleanup-list . (scope-operator
     		       empty-defun-braces
     		       defun-close-semi))
         (c-offsets-alist . ((arglist-close . c-lineup-arglist)
     			(substatement-open . 0)))))

     (add-hook 'c-mode-common-hook
       (function (lambda ()
         (c-add-style "my-style" my-c-style t))))

どの順番で実行されても大丈夫なようにフック関数を設計するのが最良です. 
実行順序に依存するのは, 『事故を呼び込む』ようなものです.  しかし, 順
番は予測できます.  もっとも最近に追加したフック関数ほど先に実行されま
す.



File: emacs-ja, Node: Locals, Next: File Variables, Prev: Hooks, Up: Variables

ローカル変数
------------

`M-x make-local-variable RET VAR RET'
     変数VARがカレントバッファでローカルに値を持つようにする.
`M-x kill-local-variable RET VAR RET'
     変数VARがカレントバッファではグローバル値を使うようにする.
`M-x make-variable-buffer-local RET VAR RET'
     変数VARを, 値を設定したときにその時点のカレントバッファでローカル
     に値を持つようにする.

ほとんどの変数はEmacsバッファに対して"ローカル"にできます.  つまり, そ
の変数のバッファ中での値は他のバッファでの値とは独立になります.  いく
つかの変数はつねにすべてのバッファにおいてローカルです.  それ以外の変
数はすべて, "グローバル"な値, つまりその変数をローカルにしていないすべ
てのバッファにおいて共有される値を持ちます.

`M-x make-local-variable'は変数名を受け取り, その変数をカレントバッファ
においてローカルにします.  それ以降, このバッファ内でその変数を変更し
ても他のバッファには影響しませんし, その変数のグローバルな値を変更して
もこのバッファ内での値には影響しません.

`M-x make-variable-buffer-local'は, 変数名を受け取り, 値が設定されると
その変数が自動的にローカルになるようにします.  もっと正確にいえば, こ
のように特別な印を変数に付けておくと, 通常の方法で変数に値を設定すると
きにはつねにまず`make-local-variable'が実行されるようになるのです.  こ
のような変数を"バッファごとの変数"と呼びます.

メジャーモード（*Note Major Modes::）では, 変数を設定するまえにつねに
ローカルにします.  このため, あるバッファでメジャーモードを変更しても
他のバッファには影響が及びません.  マイナモード（*Note Minor Modes::）
も同様で, 通常, マイナモードごとにオン／オフを制御する変数があり, その
変数が`nil'以外のときにそのマイナモードはオンになります.  ほとんどのマ
イナモードでは, その制御用変数はバッファごとの変数です.

Emacsには, つねにバッファごとの変数であるような変数が数多くあります.
`abbrev-mode', `auto-fill-function', `case-fold-search',
`comment-column', `ctl-arrow', `fill-column', `fill-prefix',
`indent-tabs-mode', `left-margin', `mode-line-format',
`overwrite-mode', `selective-display-ellipses', `selective-display',
`tab-width', `truncate-lines'がそのような変数です.  これ以外にもつねに
各バッファでローカルな変数はありますが, それらは内部作業用の変数です.

いくつかの変数はディスプレイに対してローカルになっているため, バッファ
に対してローカルにはできません（*Note Multiple Displays::）.  これらの
変数をバッファにローカルにしようとすると, エラーメッセージが表示されま
す.

`M-x kill-local-variable'は, 変数名を受け取り, その変数をカレントバッ
ファに対してローカルでなくします.  それ以降そのバッファでは, その変数
のグローバルな値が使われます.  メジャーモードを設定すると, "つねにロー
カル"と印が付いた少数の特別な変数を除いて, そのバッファにローカルなす
べての変数をローカルでなくします.

ある変数がカレントバッファでローカルか否かに係わらずその変数のグローバ
ルな値を設定したければ, `setq-default'を使います.  これは`setq'のよう
に使われますが, （たとえローカルな値があったとしても）つねにグローバル
な値のほうを設定します.  その変数がローカルな値を持っている場合, 新た
に設定したグローバルな値は別のバッファに切り替えるまでは参照できません. 
以下に例をあげます.

     (setq-default fill-column 75)

`setq-default'は, `make-variable-buffer-local'で印を付けた変数のグロー
バルな値を設定する唯一の方法です.

Lispプログラム中では, 変数のデフォルト値を参照するためには
`default-value'を使えます.  この関数はシンボルを引数とし, その変数のデ
フォルト値を返します.  引数は評価されるので, 普通は引数をクォートしま
す.  たとえば, `fill-column'のデフォルト値を取得するにはつぎのようにし
ます.

     (default-value 'fill-column)



File: emacs-ja, Node: File Variables, Next: Keyboard Macros, Prev: Locals, Up: Variables

ファイルにローカルな変数
------------------------

Emacsでファイルを編集する際に, そのファイルに対応したローカル変数とそ
の値を指定することができます.  Emacsはファイルを訪問すると, ローカル変
数指定の有無を検査し, あれば指定された変数を自動的にバッファにローカル
にして, その値をファイルで指定された値に設定します.

ローカル変数とその値を設定するには2つの方法があります.  1つはファイル
の先頭行に書くことで, もう1つはローカル変数リストを書くことです.  先頭
行に書く場合は, たとえばつぎのようにします.

     -*- mode: MODENAME; VAR: VALUE; ... -*-

変数とその値を「:」で区切った対を「;」で区切って並べ, いくつでも指定で
きます.  `mode: MODENAME;'はメジャーモードを指定するもので, 行の最初に
ある必要があります.  VALUEは評価されずに書かれているとおりのまま使われ
ます.  以下は, Lispモードで2つの変数に数値を設定する例です.

     ;; -*-mode: Lisp; fill-column: 75; comment-column: 50; -*-

この方法では, ファイルのコーディングシステムも指定できます.  つまり,
`coding'という名前の『変数』に値を指定すればよいのです.  『値』は,
Emacsが認識できるコーディングシステム名である必要があります.  *Note
Coding Systems::.

一方, "ローカル変数リスト"はファイルの末尾（最後のページ）に置きます. 
（最後のページにはローカル変数リストだけを置くというのを勧めます. ）ロー
カル変数リストは`Local Variables:'という内容を含む行で始まり, `End:'と
いう内容を含む行で終ります.  これらの行のあいだに, 1つの変数につき1行
ずつ, `VARIABLE: VALUE'という形で変数の名前と値を指定します.  VALUEは
評価されずにファイルに書かれたとおりにそのまま使われます.  ファイルに
ローカル変数リストと`-*-'の行が両方含まれていた場合には, Emacsはまず
`-*-'の行を*すべて*処理してから, 続いてローカル変数リストの内容を*すべ
て*処理します.

以下にローカル変数リストの例を示します：

     ;;; Local Variables: ***
     ;;; mode:lisp ***
     ;;; comment-column:0 ***
     ;;; comment-start: ";;; "  ***
     ;;; comment-end:"***" ***
     ;;; End: ***

上の例では, 各行は`;;;'で始まり`***'で終っています.  Emacsはこれらの接
頭辞と接尾辞をリストの最初の内容に基づいて認識します.  つまり, 特別な
文字列`Local Variables:'の前後の文字列を, それぞれ, 接頭辞, 接尾辞とみ
なし, それ以降の行についてはこの接頭辞と接尾辞を無視します.

接頭辞と接尾辞を使う主な理由は, ローカル変数リストをコメントの中に入れ
ることで, そのファイルを読み込む他のプログラムを困惑させないようにする
ことです.  上の例では, コメントが`;;;'で始まり`***'で終るような言語を
想定しています.  変数`comment-start'と`comment-end'のローカルな値で, 
このような変な構文に対処するようにEmacsをカスタマイズするのです.  必要
ないのであれば, 接頭辞（と接尾辞）は使わないでください.

ローカル変数リストにおいては, 2つの変数名が特別な意味を持ちます.  変数
`mode'に対する値は, 実際にはメジャーモードを設定します.  変数`eval'に
対する値は, 式として評価されますが, その結果は捨てられます.  `mode'と
`eval'は本当の変数ではなく, 他の状況でこれらの名前の変数に値を設定して
もなんら特別な意味を持ちません.  メジャーモードを設定するために`mode'
を指定する場合は, ローカル変数リストの先頭に書く必要があります.

仮想的な『変数』`mode'は, メジャーモードだけでなくマイナモードを設定す
るのにも使えます.  実は, この指定は2回以上使うことができて, 最初はメ
ジャーモードを設定し, それ以降は（それぞれ）マイナモードを設定します. 
しかし, マイナモードはユーザーの好みに応じて選ぶものですから, 普通はファ
イルでマイナモードを指定するべきではないでしょう.

たとえば, ローカル変数リストで自動詰め込み（auto-fill）モードをオンに
したいと思うかもしれませんが, それはまちがいです.  自動詰め込みにする
かどうかは, 個人の好みの問題であり, ファイルの中身によって決まるもので
はないからです.  ある種別のファイルでいつも自動詰め込みにしたければ, 
個人の`.emacs'ファイルで（状況に応じて）自動詰め込み（auto-fill）モー
ドをオンにするようなメジャーモードのフックを設定してください（*Note
Init File::）.  ローカル変数リストで他人に好みを押し付けてはいけません.

ローカル変数リストは, ファイルの末尾から3000文字以内にある必要があり, 
ファイルがページに分かれている場合には最後のページにある必要があります. 
これらが守られていないと, Emacsはローカル変数リストがあることを認識し
ません.  これらの規則の目的は, 最後ではないページに偶然`Local
Variables:'があってもEmacsが誤認しないようにすることと, 全体が1ページ
でローカル変数リストを持たない長いファイルを訪問するときでもファイル全
体を探さなくてもすむようにするためです.

バッファのローカル変数やメジャーモードを, ローカル変数リストがあるとき
にはそれによる指定も含めて, ファイル名とファイルの内容に基づいたものに
リセットしたければ, `normal-mode'コマンドを使ってください.  *Note
Choosing Modes::.

変数`enable-local-variables'は, ファイル中のローカル変数指定を処理する
か否かを制御します.  つまり, ローカル変数指定を無視するようにもできま
す.  デフォルトは`t'で, ファイル中のローカル変数指定を処理します.  値
を`nil'にすると, ファイル中のローカル変数指定を無視します.  これら以外
の値の場合は, ファイル中にローカル変数指定があると, その内容を表示して
処理するかどうか問い合わせます.

仮想的な『変数』`eval'といくつかの（実在する）変数に対する指定は, ある
種の危険性をもたらします.  他人のファイルを訪問したとき, そこに書かれ
ているローカル変数指定によってあなたが使っているEmacsのふるまいがどの
ようにでも変更できるからです.  このため, オプション`enable-local-eval'
により, 変数`eval', さらに, `-hook', `-hooks', `-function',
`-functions'という名前で終る変数, および, 他のいくつかの変数に対するロー
カル変数指定を処理するかどうか制御できるようになっています.
`enable-local-variables'と同じように指定できる値は3種類あって, `t',
`nil', これら以外です.  デフォルトは`maybe'で, これは`t'でも`nil'でも
ありませんから, Emacsはこれらのローカル変数指定があるときは確認を求め
てきます.



File: emacs-ja, Node: Keyboard Macros, Next: Key Bindings, Prev: Variables, Up: Customization

キーボードマクロ
================

"キーボードマクロ"は, ユーザーが一連のキー操作に基づいて定義したコマン
ドです.  たとえば, `C-n C-d'という打鍵を40回繰り返す必要があるとわかっ
たら, `C-n C-d'を実行するキーボードマクロを定義し, それを40回繰り返す
指定をして呼び出すと迅速に作業できます.

`C-x ('
     キーボードマクロの定義を開始する（`start-kbd-macro'）.
`C-x )'
     キーボードマクロの定義を終了する（`end-kbd-macro'）.
`C-x e'
     もっとも最近のキーボードマクロを実行する（`call-last-kbd-macro'）.
`C-u C-x ('
     もっとも最近のキーボードマクロを再実行したうえで, その定義にキー
     を追加する.
`C-x q'
     キーボードマクロの実行中にこの場所に到達したら, 実行の確認を求め
     る（`kbd-macro-query'）.
`M-x name-last-kbd-macro'
     もっとも最近に定義したキーボードマクロに（現在のEmacsセッションだ
     けで有効な）コマンド名を与える.
`M-x insert-kbd-macro'
     キーボードマクロの定義をLispコードとしてバッファに挿入する.
`C-x C-k'
     まえに定義したキーボードマクロを編集する（`edit-kbd-macro'）.
`M-x apply-macro-to-region-lines'
     リージョン内の各行に対して, 最後に定義したキーボードマクロを実行
     する.

キーボードマクロは, それがLispではなくEmacsのコマンド言語で記述されて
いるという点で, 通常のEmacsコマンドとは違っています.  このため, キーボー
ドマクロは初心者でも簡単に作れ, 間に合わせとして定義するのにも向いてい
ます.  しかし, Emacsのコマンド言語は, プログラム言語として知的で汎用的
な動作を記述できるほど強力ではありません.  そういう場合には, Lispを使っ
てください.

キーボードマクロは, 定義内容のコマンド列を実際に実行しながら定義できま
す.  いいかえれば, キーボードマクロを定義しているときに, その定義の第1
回目の実行が行われることになります.  ですから, コマンドがどのように動
作するかを目で見ながら確認でき, 頭の中だけで動作を考えるよりも楽に定義
できます.  コマンド列の最後まできてキーボードマクロを定義し終ると, 第1
回目の実行も終ったことになります.  そのあとは, マクロを呼び出すことで
何回でもそのコマンド列全体を実行できます.

* Menu:

* Basic Kbd Macro::     Defining and running keyboard macros.
* Save Kbd Macro::      Giving keyboard macros names; saving them in files.
* Kbd Macro Query::     Making keyboard macros do different things each time.



File: emacs-ja, Node: Basic Kbd Macro, Next: Save Kbd Macro, Prev: Keyboard Macros, Up: Keyboard Macros

基本的な使い方
--------------

キーボードマクロの定義を開始するには, `C-x ('コマンド
（`start-kbd-macro'）を打ってください.  それ以降打鍵するものは通常どお
り実行されますが, それと同時にキーボードマクロの定義として取り込まれま
す.  モード行にもそのことを表す`Def'という表示が現れます.  定義の終り
まできたら, `C-x )'（`end-kbd-macro'）を打ち込むとキーボードマクロの定
義が完了します（`C-x )'はマクロの内容には含まれません！）.  たとえば,

     C-x ( M-f foo C-x )

のように打鍵すると, 1単語分ポイントを前進させ文字列`foo'をバッファに挿
入する, キーボードマクロを定義できます.

定義し終えたキーボードマクロは, コマンド`C-x e'（`call-last-kbd-macro'）
で再実行できますし, 数引数として反復回数を指定することで多数回実行する
こともできます.  `C-x )'にも引数として反復回数を指定でき, その場合は定
義完了とともにただちに指定した回数だけキーボードマクロを実行しますが, 
定義しているとき（実行しているので）を1回目の実行として数えます.  です
から, `C-u 4 C-x )'と打つと, キーボードマクロをただちに3回実行します.
`C-x e'や`C-x )'に反復回数0を指定すると, キーボードマクロを無限回, つ
まり, エラーが発生するか, `C-g'（MS-DOSでは`C-BREAK'）が打鍵されるまで, 
繰り返し実行します.

テキスト上の規則的にとびとびの位置に対して操作を行いたい場合には, キー
ボードマクロを定義するときに, つぎに適用したい位置までポイントを移動す
るコマンドを含めておきます.  たとえば, 各行について変更を行いたければ, 
ポイントを行頭に置いてからキーボードマクロを定義し始め, 最後にポイント
をつぎの行の行頭に置いたところで定義を終えます.  キーボードマクロを繰
り返し実行すると, 次々と連続する行に対して操作を実行できます.

キーボードマクロの定義を完了してしまったあとでも, `C-u C-x ('を打ち込
めば, その定義の末尾に内容を追加できます.  このコマンドは, `C-x ('に続
いて現在のキーボードマクロの定義内容全体を打鍵したのと同じ効果を持ちま
す.  その結果, 定義されたとおりにマクロを再実行します.

キーボードマクロの中で, 通常のキーと同様にファンクションキーを使うこと
もできます.  マウスイベントを使うことさえできますが, その場合は注意し
てください.  キーボードマクロはマウスイベントを再現しますが, マウス位
置としては最初にキーボードマクロを定義したときの位置がそのまま使われま
す.  その結果は予想し難いものになります.  （現在のマウス位置を使っても, 
結果はさらに予想し難いものになる. ）

キーボードマクロの中で必ずうまくいくとは限らないことの1つに, `C-M-c'
（`exit-recursive-edit'）コマンドがあります.  このコマンドがマクロの中
で開始させた再帰編集を終らせる場合には, 期待どおりに動くでしょう.  し
かし, このコマンドがキーボードマクロを起動するまえに入っていた再帰編集
を終らせるとすると, その終了処理の過程でキーボードマクロの実行も終らせ
てしまいます.

定義済みのキーボードマクロを編集するには, `C-x C-k'（`edit-kbd-macro'）
と打ちます.  このコマンドに続けてマクロを起動する打鍵, つまり, `C-x e'
や`M-x NAME'などのキー列を入れます.  すると, キー列に対応するキーボー
ドマクロの内容が整形されて特別な編集用メジャーモードのバッファに入りま
す.  そのバッファ中で`C-h m'と打つと編集方法が表示されます.  編集し終
えたら`C-c C-c'と打ちます.

コマンド`M-x apply-macro-to-region-lines'は最後に定義されたキーボード
マクロを現在のリージョンの各行に対して実行します.  つまり, 各行につい
て, 行頭にポイントを置いてからキーボードマクロを実行します.



File: emacs-ja, Node: Save Kbd Macro, Next: Kbd Macro Query, Prev: Basic Kbd Macro, Up: Keyboard Macros

キーボードマクロの命名と保存
----------------------------

新たにつぎのキーボードマクロを定義したあとでも現在のキーボードマクロを
使いたいなら, `M-x name-last-kbd-macro'でキーボードマクロに名前を付け
ておく必要があります.  このコマンドは, ミニバッファで名前を読み取り, 
その名前でキーボードマクロを実行できるように定義します.  マクロ名は
Lispシンボルであり, このように定義されているので, `M-x'で呼び出したり
`global-set-key' （*Note Keymaps::）でキーに対応付けたりできる有効なコ
マンド名になります.  その名前にキーボードマクロ以外のものがすでに定義
されていると, エラーメッセージが表示され何の変更も起こりません.

キーボードマクロにコマンド名を付けると, その定義をファイルに保存できま
す.  そうすると, 別の編集セッションで使えるようになります.  まず, 定義
を保存したいファイルを訪問してから, つぎのコマンドを使ってください.

     M-x insert-kbd-macro RET MACRONAME RET

このコマンドは, 実行するとそのキーボードマクロと同じ動作を行うLispコー
ドをバッファに挿入します.  （`insert-kbd-macro'がLispコードの生成を代
行するので, Lispコードを理解する必要はない. ）そうしたら, このファイル
を保存します.  `load-file'（*Note Lisp Libraries::）でファイルをロード
できます.  保存するファイルとして`~/.emacs'（*Note Init File::）を使え
ば, Emacsを起動するとつねにそのマクロが定義されます.

`insert-kbd-macro'に数引数を指定すると, さらに（もしあれば）キーボード
マクロに割り当てたキーを記録するLispコードが追加されるので, ファイルを
ロードしたときに同じキーがマクロに割り当てられます.



File: emacs-ja, Node: Kbd Macro Query, Next: Key Bindings, Prev: Save Kbd Macro, Up: Keyboard Macros

変化のあるマクロの実行
----------------------

`C-x q'（`kbd-macro-query'）を使うと, `query-replace'と同様に変更する
かどうか尋ねてくるキーボードマクロを作れます.  キーボードマクロを定義
しているときに, 問い合わせが起きてほしい箇所で`C-x q'を打ちます.  マク
ロの定義中は`C-x q'は何の動作もしませんが, あとでマクロを実行させたと
きには`C-x q'の箇所で処理を続けるかどうか尋ねてくるようになります.

`C-x q'の問い合わせに対する有効な応答は, SPC（または`y'）, DEL（または
`n'）, RET（または`q'）, `C-l', `C-r'です.  これらの意味は
`query-replace'と同じですが, `query-replace'のすべての応答が意味を持つ
とは限りません.

SPCは続行, DELはこの回の反復の残りを飛ばしてただちにつぎの反復に進むと
いう意味になります.  RETではこの回の反復の残りも以後の反復もすべて取り
消します.  `C-l'は画面を再描画し, 再度どうするかを問い合わせてきます.

`C-r'で再帰編集レベルに入るので, そこでキーボードマクロにはない編集を
行えます.  `C-M-c'で再帰編集から抜けると, 再度どうするかを聞いてきます. 
ここでSPCを打つと, キーボードマクロの残りの部分が実行されます.  キーボー
ドマクロの残りの部分が望みどおりの動作をする状態にポイントやテキストを
保っておくのは, ユーザーの責任です.

`C-u C-x q', つまり, 数引数を指定した`C-x q'は, まったく違った動作をし
ます.  キーボードマクロの定義中でも実行中でも, キーボードから入力を受
け付ける再帰編集に入ります.  定義中の場合, 再帰編集の中で行った操作は
マクロの一部にはなりません.  実行中の場合, 再帰編集の中で各反復ごとに
個別の編集を行う機会が得られます.  *Note Recursive Edit::.



File: emacs-ja, Node: Key Bindings, Next: Keyboard Translations, Prev: Keyboard Macros, Up: Customization

キーバインディングのカスタマイズ
================================

本節では, コマンドをキーに対応付ける"キーバインディング"と, キーバイン
ディングを記録する"キーマップ"について説明します.  また, キーバインディ
ングをカスタマイズする方法についても説明します.

コマンドとは, 対話利用向けに定義されたLisp関数であることを思い出してく
ださい.  コマンドには, 他のLisp関数と同様, 通常, 英小文字とハイフンか
ら成る関数名前が付いています.

* Menu:

* Keymaps::             Generalities.  The global keymap.
* Prefix Keymaps::      Keymaps for prefix keys.
* Local Keymaps::       Major and minor modes have their own keymaps.
* Minibuffer Maps::     The minibuffer uses its own local keymaps.
* Rebinding::           How to redefine one key's meaning conveniently.
* Init Rebinding::      Rebinding keys with your init file, `.emacs'.
* Function Keys::       Rebinding terminal function keys.
* Named ASCII Chars::   Distinguishing TAB from `C-i', and so on.
* Non-ASCII Rebinding:: Rebinding non-ASCII characters such as Latin-1.
* Mouse Buttons::       Rebinding mouse buttons in Emacs.
* Disabling::           Disabling a command means confirmation is required
                          before it can be executed.  This is done to protect
                          beginners from surprises.



File: emacs-ja, Node: Keymaps, Next: Prefix Keymaps, Prev: Key Bindings, Up: Key Bindings

キーマップ
----------

キー列とコマンド関数との対応は"キーマップ"と呼ばれるデータ構造に保持さ
れています.  Emacsには数多くのキーマップがあり, それぞれが特定の場面で
使われます.

"キー列"（または単に"キー"）とは, ひとまとまりの意味を持つ"入力イベン
ト"の並びをいいます.  入力イベントは, 文字, ファンクションキー, マウス
ボタン, つまり, 端末から計算機に送ることができるすべての入力から成りま
す.  キー列の意味付けは, どのコマンドを実行するかを表す"バインディング
"によって決まります.  キーマップの役割は, これらのバインディングを保持
することです.

"グローバル"キーマップはもっとも重要なキーマップですが, それはグローバ
ルキーマップがつねに有効だからです.  グローバルキーマップは基本
（fundamental）モードのキーを定義します.  つまり, そこに含まれる定義の
大部分は, ほとんどまたはすべてのメジャーモードに共通のものです.  各メ
ジャー／マイナモードは, グローバルキーマップの定義の一部を置き換えるよ
うな独自のキーマップを持つことができます.

たとえば, `g'のような自己挿入文字を打つとその文字がバッファに挿入され
るのは, グローバルキーマップでこれらのキーが`self-insert-command'に対
応付けられているからです.  また, `C-a'のような標準の編集コマンドも, そ
の意味付けはグローバルキーマップに書かれています.  `M-x
global-set-key'のようなバインディングを変更するコマンド群は, グローバ
ルキーマップの適切な箇所に新しいバインディングを書き込みます.

メタ文字はやや違った動作になります.  Emacsでは, メタ文字はESCで始まる
文字列に変換されます.  ですから, `M-a'という入力はつねにEmacsの中では
`ESC a'に置き換えられて処理されます.  つまり, メタ文字は単一の入力イベ
ントですが, キーバインディングの観点では2つのイベントとして扱われます. 
こうなっている理由は歴史的なもので, 将来は変わる可能性もあります.

最近のほとんどのキーボードには, 文字キーの他にファンクションキーがあり
ます.  ファンクションキーは文字キーと同様に入力イベントを送出し, キー
マップはそれに対応するバインディングを保持することができます.

多くの端末では, ファンクションキーを打つとコンピュータには一連の文字列
が送られます.  具体的にどのファンクションキーがどんな文字列を送るかは
端末によってまちまちです.  （多くの場合, 文字列は`ESC ['で始まる. ）
Emacsが使用中の端末種別を正しく認識していれば, キー列（の先頭でだけで
なく）に現れるファンクションキーに対応した文字列を正しく判別できます. 
ですから, 多くの場合, ファンクションキーの打鍵も1つの入力イベントとし
て直接Emacsに送られているとみなして, 文字列としての表現形式は無視して
かまいません.

マウスボタンも入力イベントを発生させます.  これらのイベントには, 追加
データ, つまり, ボタンを押したり放したりしたときのウィンドウとその中で
の位置, 時刻が付属しています.  ただし, キーバインディングに関しては, 
どのボタンが使われたかだけが問題となります.  残りの情報は, コマンドが
これらの情報を参照する場合だけ意味を持ちます.  （通常, マウスから起動
できるコマンドは, これらの情報を参照する. ）

キーマップは1つのイベントに対する定義のみを保持します.  複数キーの列か
ら成る複数のイベントの解釈には, キーマップの連鎖が使われます.  最初の
キーマップが最初のイベントの定義を保持し, その定義がつぎのキーマップに
なっていて, 2番目のイベントの定義を保持し, というようになっています.

キー列にはファンクションキーと文字キーとが混ざっていてもかまいません. 
たとえば, `C-x SELECT'というのも許されます.  SELECTをプレフィックスキー
として定義しておけば, `SELECT C-n'というのも許されます.  マウスイベン
トとキーボードイベントを混ぜることさえ可能ですが, そうすると打ち込むの
が面倒ですからお勧めしません.

ユーザーはどんなキー列でも再定義して利用できますが, `C-c'に続けて1文字
というキー列だけを使うのが最善です.  このキー列は『ユーザー定義のため
に予約』されていて, 正しく設計されたEmacsの各種拡張とは衝突しないよう
になっているからです.  F5からF9までのファンクションキーもユーザー定義
のために予約してあります.  これ以外のキー列を再定義すると, 同じキーを
再定義する拡張やメジャーモードによってあなたの定義が上書きされてしまう
可能性があります.



File: emacs-ja, Node: Prefix Keymaps, Next: Local Keymaps, Prev: Keymaps, Up: Key Bindings

プレフィックスキーマップ
------------------------

`C-x'やESCのようなプレフィックスキーはそれぞれ専用のキーマップを持って
いて, そこにはそのプレフィックスキーに続くイベントの定義が保持されてい
ます.

プレフィックスキーの定義は, 通常, それに続くイベントの定義を検索するた
めのキーマップです.  あるいは, プレフィックスキーの定義がLispシンボル
であって, その関数の定義がキーマップというのもあります.  どちらでも効
果は同じですが, 後者では, プレフィックスキーにコマンド名を与えてその用
途を示すことができます.  このため, `C-x'にバインドされているのはシンボ
ル`Ctl-X-Prefix'であり, その関数定義は`C-x'コマンド群に対応するキーマッ
プです.  `C-c', `C-x', `C-h', ESCはグローバルマップでプレフィックスキー
として定義されていますから, これらはつねにプレフィックスキーとして使用
できます.

通常のプレフィックスキーに加えて, メニューバーを表す『仮想的なプレフィッ
クスキー』があります.  メニューバーのキーバインディングに関する特別な
点については*Note メニューバー: (elisp-ja)Menu Bar.を参照してください。
ポップアップメニューを表示させるマウスボタンイベントもまた, プレフィッ
クスキーです.  こちらの詳細については*Note メニューキーマップ:
(elisp-ja)Menu Keymaps.を参照してください。

決まった変数に格納されているプレフィックスキーマップもあります.

   * `ctl-x-map'は`C-x'に続くキーを探すためのマップを納めた変数名.
   * `help-map'は`C-h'に続くキーを探すためのマップを納めた変数名.
   * `esc-map'はESCに続くキーを探すためのマップを納めた変数名.  つまり, 
     すべてのメタ文字は実際にはこのマップで定義されている.
   * `ctl-x-4-map'は`C-x 4'に続くキーを探すためのマップを納めた変数名.
   * `mode-specific-map'は`C-c'に続くキーを探すためのマップを納めた変
     数名.



File: emacs-ja, Node: Local Keymaps, Next: Minibuffer Maps, Prev: Prefix Keymaps, Up: Key Bindings

ローカルキーマップ
------------------

これまではグローバルキーマップの諸側面について説明しました.  メジャー
モード固有のキーバインディングを"ローカルキーマップ"に定義することで, 
各メジャーモードはEmacsの動作を変更します.  たとえば, Cモードでは, TAB
をCのコードの現在行を字下げする機能に差し替えます.  バッファ内の一部の
テキストで, そのバッファのメジャーモードのかわりとなる固有のキーマップ
を指定することもできます.

マイナモードもローカルキーマップを持てます.  その場合, マイナモードが
生きているときには, そのキーマップがメジャーモードのローカルキーマップ
やグローバルキーマップに優先します.

Lispモードおよびその他のいくつかのメジャーモードのローカルキーマップは, 
そのモードを使っていないときでもつねに存在します.  これらのキーマップ
は, `lisp-mode-map'などの変数に格納されています.  さほど頻繁に使われな
いメジャーモードの場合は, そのモードがセッションの中で初めて起動された
ときにローカルキーマップが作られます.  これは, メモリを節約するためで
す.  このようなモードのキーマップを変更したい場合には, 当該メジャーモー
ドの"モードフック"を使う必要があります（以下を参照）.

すべてのマイナモードのキーマップは, あらかじめ作られています.  マイナ
モードのキーマップ作成をそのマイナモードが最初に起動されるまで遅延させ
る方法はありません.

ローカルキーマップでは, その中のあるキーの定義をプレフィックスキーマッ
プとすることで, そのキーをローカルなプレフィックスキーとして再定義でき
ます.  そのキーがグローバルにもプレフィックスキーであると定義されてい
るなら, ローカルキーマップとグローバルキーマップの内容は実質的に統合さ
れ, プレフィックスキーに続くイベントは両方のキーマップで検索されます. 
したがって, あるモードのローカルキーマップが`C-c'を別のキーマップとし
て定義し, そのキーマップでは`C-z'をコマンドとして定義すると, これらに
よって`C-c C-z'のローカルな意味が与えられます.  しかし, これは`C-c'で
始まる他のキー列には影響しません.  あるキー列が独自のローカルなバイン
ディングを持たなければ, グローバルなバインディングが意味を持つからです.

いいかえれば, Emacsが複数イベントから成るキー列を扱う方法は, 複数のキー
マップから1つずつ, キー列全体に一致するバインディングを探すのです.  ま
ず, マイナモードが生きていればそのキーマップを検索し, つぎにメジャーモー
ドのキーマップを検索し, 最後にグローバルキーマップを検索します.  これ
は厳密にはキーの検索動作とは違いますが, 通常の状況でどうなるか理解する
には十分です.

メジャーモードのローカルバインディングを変更するには, そのモードのロー
カルキーマップを変更する必要があります.  通常, そのためにはそのモード
が最初に使われるまで待つ必要があります.  というのは, ほどんどのメジャー
モードは使われるまでキーマップを作成しないからです.  ですから, 個人の
`~/.emacs'ファイルでメジャーモードのバインディングを変更したければ, そ
のモードのモードフックを使ってそのモードが最初に使われるまで（変更を）
遅らせる必要があります.

たとえば, texinfoモードを選択する`texinfo-mode'コマンドはフック
`texinfo-mode-hook'を実行します.  このフックを使って`C-c n'と`C-c p'に
対する（有益ではないですが）ローカルバインディングをtexinfoモードに追
加するには, つぎのようにします.

     (add-hook 'texinfo-mode-hook
               '(lambda ()
                  (define-key texinfo-mode-map
                              "\C-cp"
                              'backward-paragraph)
                  (define-key texinfo-mode-map
                              "\C-cn"
                              'forward-paragraph)
                  ))

*Note Hooks::.



File: emacs-ja, Node: Minibuffer Maps, Next: Rebinding, Prev: Local Keymaps, Up: Key Bindings

ミニバッファのキーマップ
------------------------

ミニバッファも一群の専用ローカルキーマップを持っています.  それらには
各種の補完や脱出コマンドが定義されています.

   * `minibuffer-local-map'は通常の入力に使われる（補完なし）.
   * `minibuffer-local-ns-map'も同様.  ただし, SPCは, RETと同様に, 脱
     出動作である.  これは主にMocklispとの互換性のために使われる.
   * `minibuffer-local-completion-map'は弱い補完に使われる.
   * `minibuffer-local-must-match-map'は強い補完と慎重な補完に使われる.



File: emacs-ja, Node: Rebinding, Next: Init Rebinding, Prev: Minibuffer Maps, Up: Key Bindings

キーバインディングの対話的な変更
--------------------------------

Emacsのキーを再定義するには, キーマップの対応する項目を変更すればよい
のです.  グローバルキーマップを変更すると, その変更は（同じキーに対し
て独自のローカルな定義をしているメジャーモードを除く）すべてのメジャー
モードに影響します.  あるいは, カレントバッファのローカルマップを変更
すると, 同じメジャーモードを使っているすべてバッファに影響が及びます.

`M-x global-set-key RET KEY CMD RET'
     CMDを実行するようにKEYをグローバルに定義する.
`M-x local-set-key RET KEY CMD RET'
     CMDを実行するようにKEYを（現在のメジャーモードで）ローカルに定義
     する.
`M-x global-unset-key RET KEY'
     KEYをグローバルマップで未定義にする.
`M-x local-unset-key RET KEY'
     KEYを（現在のメジャーモードで）ローカルに未定義にする.

たとえば, Emacsを休止してログインシェルでコマンドを実行するかわりに,
Emacsバッファ内のサブシェルでコマンドを実行したいとします.  通常, （X
ウィンドウシステムを使っていない場合）`C-z'は関数`suspend-emacs'にバイ
ンドされていますが, つぎのようにこのキーを`shell'にバインドすれば, こ
のキーでEmacs内の対話的サブシェルを起動するように変更できます.

     M-x global-set-key RET C-z shell RET

`global-set-key'はキー列に続けてコマンド名を読み取ります.  使いたいキー
を打鍵すると, どのキーをバインドしたいのかを確認するつぎのようなメッセー
ジが表示されます.

     Set key C-z to command: 

同じ手順で, ファンクションキーやマウスイベントを再定義できます.  バイ
ンドすべきキーを指定するときに, キーのかわりにファンクションキーを押し
たりマウスボタンをクリックしてください.

複数イベントから成るキーも単一イベントのキーと同様にして再定義できます.
Emacsは再定義すべきキー列が完成するまで（つまりプレフィックスキーでは
ないキーが出てくるまで）イベントを読み続けます.  たとえば, KEYとして
`C-f'を打てばそれで終りですから, ミニバッファはただちにCMDを読む状態に
なります.  一方, `C-x'を打つとさらにその先のキーを読みます.  そこで`4'
を打つと, さらにその先のキーが読まれる, というようになります.  たとえ
ば,

     M-x global-set-key RET C-x 4 $ spell-other-window RET

では, `C-x 4 $'を（実在しない）コマンド`spell-other-window'にバインド
します.

`C-c'に続けて英字という2文字のキー列は, ユーザーのカスタマイズ用に予約
されています.  Lispプログラムはこれらのキー列を定義しないことになって
いますから, これらのキー列のバインディングはどのメジャーモードでも使え, 
いかなる機能とも干渉しないはずです.

`global-unset-key'でキーのグローバルな定義を取り除けます.  そのキーは"
未定義"になります.  未定義のキーを打つと, Emacsはベルを鳴らします.  同
様に, `local-unset-key'は現在のメジャーモードでキーを未定義にしますか
ら, グローバルな定義（あるいはグローバルでの未定義状態）が現在のメジャー
モードでふたたび有効になります.

キーを再定義（または未定義に）して, あとでもとに戻したいと思った場合, 
キーを未定義にしてももとには戻りません.  キーの標準定義を設定し直す必
要があります.  キーの標準定義を調べるには, 基本（fundamental）モードの
バッファにいって`C-h c'を使います.  本書のキーの説明にもコマンド名を掲
載してあります.

まちがって, あるコマンドを実行することを防ぎたければ, キーを未定義にす
るのでなく, コマンドを使用禁止にするのがよいでしょう.  必要になったと
きに使用禁止コマンドを起動するのは造作もありません.



File: emacs-ja, Node: Init Rebinding, Next: Function Keys, Prev: Rebinding, Up: Key Bindings

初期化ファイルでのキーの変更
----------------------------

いつでもあるキーバインディングを設定しておきたければ, その指定を個人の
`.emacs'ファイルにLispのコードとして書いておきます.

これを行うもっとも簡単な方法は, ASCII文字とメタ修飾付きのASCII文字に対
してのみ使えます.  たとえば, `C-z'を`shell'にバインドするにはつぎのよ
うにします.

     (global-set-key "\C-z" 'shell)

この例では1つの文字`C-z'から成る文字列定数を指定しています.  コマンド
名`shell'のまえのクォート「'」は, `shell'を変数ではなく定数シンボルと
して扱う印です.  クォートがないと, Emacsは`shell'を変数としてその値を
ただちに評価しようとします.  すると, 望んでいることではなく, エラーに
なります.

つぎは, 2文字のキー列をバインドする例です.

     (global-set-key "\C-xl" 'make-symbolic-link)

キー列にファンクションキーやマウスボタンイベントが含まれていたり,
`C-='や`H-a'などの非ASCII文字が含まれているなら, 文字列よりもっと一般
的な指定方法であるベクタを使った指定を使う必要があります.

Emacs Lispでのベクタの書き方は, その要素を中括弧（`[...]'）で囲みます. 
要素は空白で区切ります.  要素がシンボルであれば, 単にその名前だけを書
けばよく, 区切り記号などは不要です.  要素が文字であれば, Lispの文字定
数として, つまり`?'に続けてその文字が文字列中に現れるのと同じ書き方で, 
書いてください.

ベクタを使って`C-='（ASCIIの範囲にないコントロール文字）, `H-a'（ハイ
パー文字. ASCIIにはハイパー文字は含まれない）, F7（ファンクションキー）,
`C-Mouse-1'（キーボード修飾付きのマウスボタン）をバインドする例を示し
ます.

     (global-set-key [?\C-=] 'make-symbolic-link)
     (global-set-key [?\H-a] 'make-symbolic-link)
     (global-set-key [f7] 'make-symbolic-link)
     (global-set-key [C-mouse-1] 'make-symbolic-link)

単純な（文字列ですむ）場合にベクタを使ってもかまいません.  先の2つの例
をベクタを使うように書き直すとつぎのようになります.

     (global-set-key [?\C-z] 'shell)

     (global-set-key [?\C-x ?l] 'make-symbolic-link)



