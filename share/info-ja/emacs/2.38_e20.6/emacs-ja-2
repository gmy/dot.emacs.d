Info file: emacs-ja,    -*-Text-*-
produced by `texinfo-format-buffer'
from file `emacs.texi'
using `texinfmt.el' version 2.38 of 3 July 1998.


Emacs 20.6版対応に改訂した`GNU Emacs Manual' 13版です.

INFO-DIR-SECTION Editors
START-INFO-DIR-ENTRY
* Emacs: (emacs).	The extensible self-documenting text editor.
END-INFO-DIR-ENTRY


Published by the Free Software Foundation 59 Temple Place, Suite 330
Boston, MA 02111-1307 USA

Copyright (C) 1985, 1986, 1987, 1993, 1994, 1995, 1996, 1997, 1998,
1999 Free Software Foundation, Inc.

Permission is granted to make and distribute verbatim copies of this
manual provided the copyright notice and this permission notice are
preserved on all copies.

Permission is granted to copy and distribute modified versions of this
manual under the conditions for verbatim copying, provided also that
the sections entitled "The GNU Manifesto", "Distribution" and "GNU
General Public License" are included exactly as in the original, and
provided that the entire resulting derived work is distributed under
the terms of a permission notice identical to this one.

Permission is granted to copy and distribute translations of this
manual into another language, under the above conditions for modified
versions, except that the sections entitled "The GNU Manifesto",
"Distribution" and "GNU General Public License" may be included in a
translation approved by the Free Software Foundation instead of in the
original English.





File: emacs-ja, Node: Mode Line, Next: Menu Bar, Prev: Echo Area, Up: Screen

モード行
========

テキストウィンドウの最後の行は"モード行"（mode line）で, そのウィンド
ウで何が進行しているか表示します.  テキストウィンドウが1つしかない場合, 
モード行はエコー領域のすぐ上に表示されます.  フレーム上では最後から2番
目の行になります.  端末に反転表示機能があれば, モード行は反転表示され
ます.  モード行の表示内容は, ダッシュで始まりダッシュで終ります.

通常, モード行はつぎのように表示されます.

     -CS:CH  BUF      (MAJOR MINOR)--LINE--POS------

これから, ウィンドウに表示中のバッファに関する情報を得られます.  バッ
ファの名前, どのメジャーモードやマイナモードを使っているか, バッファの
テキストが変更されたかどうか, バッファ全体のどのあたりを現在表示してい
るかです.

CHは, バッファのテキストが編集されている（つまりバッファが『変更』され
ている）場合には星印2個`**'になり, バッファが編集されていない場合には
`--'になります.  読み出し専用のバッファの場合には, バッファが編集され
ている場合には`%*'になり, バッファが編集されていない場合には`%%'となり
ます.

BUFは, ウィンドウに表示されている"バッファ"の名前です.  ほとんどの場合, 
編集中のファイル名と同じです.  *Note Buffers::.

（カーソルがある）選択されたウィンドウに表示されたバッファは, Emacsの
選択されたバッファでもあり, 編集はこのバッファで行われます.  コマンド
が『バッファ』に何かを行うといったとき, 現在選択されているバッファを指
しています.

LINEは, `L'のあとに現在ポイントがある行の番号が続いたものです.  これは, 
行番号（line-number）モードがオンである（通常はオン）場合に表示されま
す.  なお, 桁番号（column-number）モードをオンにすると, 現在の桁番号も
表示できます（多少時間がかかるので, このモードはデフォルトではオフ）.
*Note Optional Mode Line::.

POSは, ウィンドウの最上部より上や最下部より下にさらにテキストがあるか
どうかを示します.  バッファが小さくて, すべてがウィンドウに収まってい
る場合には, POSは`All'となります.  そうでない場合, バッファの先頭が表
示されていれば`Top', バッファの末尾が表示されていれば`Bot', あるいは,
`NN%'となります.  ここで, NNはウィンドウの最上部より上にあるバッファの
割合を百分率で示します.

MAJORは, そのバッファの"メジャーモード"（major mode）の名前です.  各バッ
ファはつねに必ず1つのメジャーモードになっています.  使用可能なメジャー
モードには, 基本（fundamental）モード（もっとも特殊化されていないモー
ド）, テキスト（text）モード, Lisp モード, Cモード, texinfoモード, そ
の他にも数多くあります.  各モードの相違や選択方法についての詳細は,
*Note Major Modes::.

メジャーモードには, メジャーモード名のあとに付加的な情報を表示するもの
もあります.  たとえば, rmailバッファでは, 現在のメッセージ番号とメッセー
ジ総数を表示します.  コンパイルバッファやシェルバッファでは, サブプロ
セスの状態を表示します.

MINORは, ウィンドウの選択されたバッファにおいて, その時点でオンになっ
ている"マイナモード" （minor mode）の一覧の一部を示します.  たとえば,
`Fill'は, 自動詰め込み（auto-fill）モードがオンであることを意味します.
`Abbrev'は, 略語（abbrev）モードがオンであることを意味します.  `Ovwrt'
は , 上書き（overwrite）モードがオンであることを意味します.  詳しくは,
*Note Minor Modes::.  `Narrow'は, 表示中のバッファが, そのテキストの一
部のみを編集するように制限されていることを示します.  これは, 実際には
マイナモードではありませんが, そのようなものです.  *Note Narrowing::.
`Def'は, キーボードマクロを定義中であることを示します.  *Note Keyboard
Macros::.

さらに, Emacsが, 現在, 再帰編集レベルにあるときには, モードを囲んでい
る括弧の周りに角括弧（`[...]'）が現れます.  再帰編集レベルの中で別の再
帰編集レベルに入っていると, 角括弧は2重になるというふうになります.  再
帰編集レベルは, 特定のバッファにだけ関係するものではなく, Emacs全体に
影響するので, 角括弧はすべてのウィンドウのモード行に表示される, あるい
は, まったく表示されないのどちらかです.  *Note Recursive Edit::.

ウィンドウを表示できない端末では, 一度には, 単一のEmacsフレームしか表
示できません（*Note Frames::）.  そのような端末では, モード行のCHのあ
とに, 選択しているフレームの名前が表示されます.  初期フレームの名前は,
`F1'です.

CSは, 編集中のファイルで使用しているコーディングシステムを表します. 
ダッシュ（`-'）はデフォルトの状態, つまり, ファイルの内容に応じて行末
変換は行うが, コード変換は行わないことを示します.  `='の場合, コード変
換をまったく行わないことを意味します.  単純ではないコード変換をさまざ
ま文字で示します.  たとえば, `1'は, ISO Latin-1を表します.  詳しくは,
*Note Coding Systems::.  入力方式を使っている場合には, CSの先頭に`I>'
の形式の文字列が付加されます.  ここで, Iは入力方式を表します.  （`>'の
かわりに, `+'や`@'を表示する入力方式もある. ）*Note Input Methods::.

（ウィンドウシステムではなくて）文字端末を使っている場合, CSは3文字に
なり, それぞれ, キーボード入力のコーディングシステム, 画面出力のコーディ
ングシステム, 編集中のファイルのコーディングシステムです.

マルチバイト文字が使用不可の場合, CSはまったく表示されません.  *Note
Enabling Multibyte::.

CSのあとのコロンは, 特定の場面では別の文字列に変わることがあります.
Emacsは, バッファ内の行区切りとして改行を使います.  ファイルによっては, 
行区切りとして別の慣習を用いるものもあります.  復帰改行（MS-DOSの慣習）, 
あるいは, 復帰のみ（Macintoshの慣習）です.  バッファのファイルが復帰改
行を使っている場合には, オペレーティングシステムに依存して, コロンはバッ
クスラッシュ（`\'）か`(DOS)'に変わります.  ファイルが復帰のみを使って
いる場合には, コロンはスラッシュ（`/'）か`(Mac)'に変わります.  システ
ムによっては, 行区切りとして改行を使っているファイルであっても, Emacs
はコロンのかわりに`(Unix)'を表示します.

各種行末形式のモード行への表示は, 各変数, `eol-mnemonic-unix',
`eol-mnemonic-dos', `eol-mnemonic-mac', `eol-mnemonic-undecided'にユー
ザーにとって適切な任意の文字列を設定することでカスタマイズできます. 
変数の設定方法については, *Note Variables::.

ポイント位置の桁番号, 現在時刻, 新着メイルの有無などのお手ごろ情報をモー
ド行へ追加する機能については, *Note Optional Mode Line::.



File: emacs-ja, Node: Menu Bar, Next: User Input, Prev: Mode Line, Up: Screen

メニューバー
============

各Emacsフレームには, 通常, 最上部に"メニューバー"（menu bar）があり, 
よく使われる操作を実行するのに使えます.  読者自身で簡単に確かめられま
すから, ここではそれらを列挙する必要はないでしょう.

ウィンドウシステムを使っているのであれば, マウスを使ってメニューバーか
らコマンドを選べます.  メニュー項目のあとにある右向き矢印は, その項目
にサブメニューがあることを示します.  項目の最後に`...'がある場合は, コ
マンドを実際に実行するまえに, コマンドがキーボードから引数を読み取るこ
とを意味します.

メニュー項目の完全なコマンド名や説明文を見るには, `C-h k'と打ってから, 
通常どおりにマウスでメニューバーを選択します（*Note Key Help::）.

マウスのない文字端末でも, `M-`'やF10（これらは`tmm-menubar'を起動する）
を打てば, メニューバーを利用できます.  このコマンドは, キーボードから
メニュー項目を選択するモードに入ります.  エコー領域には, 仮の選択項目
が表示されます.  左矢印キーや右矢印キーでメニューの中を移動して別の項
目を選べます.  選択を確定するにはRETキーを打ちます.

各メニュー項目には, その項目を指定する1個の文字や数字も割り当てられて
います.  通常, それらは項目名の単語の頭文字です.  これらの文字や数字は, 
項目名と`=>'で分離されています.  項目の文字や数字を打てばその項目を選
べます.

メニューバーにあるコマンドの中には, キーバインディングを持つものもあり
ます.  その場合, 項目自身のあとの括弧の中に等価なキーバインドを表示し
ます.



File: emacs-ja, Node: User Input, Next: Keys, Prev: Screen, Up: Top

ユーザー入力の種類
==================

GNU Emacsは, キーボード入力に対しては拡張ASCII文字集合を使います.  ま
た, ファンクションキーやマウスボタン操作のような文字以外の入力イベント
も受け付けます.

ASCIIは, 128の文字コードから成ります.  これらのコードの中には, `a'や
`='のような図形記号に割り当てられているものもあります.  それ以外は,
`Control-a'のようなコントロール文字です（通常, `C-a'と略記）.  `C-a'の
名前は, CTRLキーを押し下げたまま`a'を押すことからきています.

ASCIIコントロール文字の中には, 特別な名前が付いたものもあります.  多く
の端末では, コントロール文字を打つための特別なキーを備えています.  た
とえば, RET, TAB, DEL, ESCがそうです.  空白文字は, 以下では普通SPCと表
記します.  厳密にいえば, 表示した図形が空白である図形文字です.  `C-j' 
に対する別名である『linefeed』（ラインフィード） (1) (*Note User
Input-Footnotes::)というラベルが付いたキーを備えたキーボードもあります.


Emacsでは, 数千の印字文字（*Note International::）, 追加のコントロール
文字, 任意の文字と組み合わせ可能な修飾子を導入して, ASCII文字集合を拡
張しています.

ASCII端末では, 利用可能なコントロール文字は32個しかありません.  これら
は, 英字と`@[]\^_'のコントロール変種です.  さらに, コントロール文字で
は, シフトキーは意味を持ちません.  つまり, `C-a'と`C-A'は同じ文字であ
り, Emacsは区別できません.

しかし, Emacsの文字集合自体には, すべての印字文字にコントロール変種を
用意する余地があり, `C-a'と`C-A'を区別できます.  Xウィンドウシステムで
は, これらすべての文字を入力できます.  たとえば, `C--'（コントロールマ
イナス）と`C-5'は, Xウィンドウシステム上では意味を持つEmacsコマンドで
す.

Emacsの文字集合に対するもう1つの拡張は, 修飾ビットの追加です.  通常は1
ビットの修飾ビットだけを使い, このビットをメタ（Meta）と呼びます.  す
べての文字にはメタ変種があります.  たとえば, `Meta-a'（通常は`M-a'と略
記）や`M-A'（`M-a'とは異なる文字だが, Emacsでは通常, 同じ意味）,
`M-RET', `M-C-a'です.  伝統的な理由で, 通常, `M-C-a'よりむしろ`C-M-a'
と書きます.  論理的には, 2つの修飾キーCTRLとMETAの順序は関係ありません.

端末の中にはMETAキーを備えたものもあり, このキーを押し下げることでメタ
文字を打てます.  たとえば, `Meta-a'は, METAを押し下げたまま`a'を押して
入力します.  METAキーはSHIFTキーと同じように働きます.  しかし, このよ
うなキーのラベルがつねにMETAであるとは限りません.  というのは, この機
能は, 別の主目的を持つキーとするための特別なオプションであることがまま
あるからです.

METAキーがなくても, ESCで始まる2文字列を使ってメタ文字を入力できます. 
つまり, `M-a'を入力するには, `ESC a'と打ちます.  `C-M-a'を入力するには,
`ESC C-a'と打ちます.  この方法に慣れているのであれば, METAがある端末で
も, ESCを使ってかまいません.
  
Xウィンドウシステムには, 他にもいくつかの修飾キーがあり, すべての入力
文字に適用できます.  これらは, SUPER, HYPER, ALTと呼ばれます.  文字に
これらの修飾子が付いていることを示す意味で, `s-', `H-', `A-'と書きます. 
つまり, `s-H-C-x'は, `Super-Hyper-Control-x'を省略したものです.  すべ
てのX端末に, 実際にこれらの修飾子用のキーがあるわけではありません.  実
際, ALTとラベルされているにも関わらず, 実はMETAとして機能するキーを持
つ端末が多くあります.  Emacsの標準キーバインディングには, これらの修飾
子が付いた文字はありません.  しかし, Emacsをカスタマイズして, それらに
独自の意味を割り当てることができます.

キーボード入力には, ファンクションキーや矢印キーのような文字以外のキー
も含まれます.  マウスボタンも文字の範囲には入りません.  これらのイベン
トも, 修飾キーCTRL, META, SUPER, HYPER, ALTを使って, キーボード文字と
同じように修飾できます.

文字入力と非文字入力の両者を合わせて, "入力イベント"（input events）と
呼びます.  より詳しくは, *Note 入力イベント: (elisp-ja)Input Events.。
Lispのプログラミング抜きに, 文字イベントや非文字イベントの意味を再定義
したい場合には, *Note Customization::を参照してください.

ASCII端末では, ASCII文字だけしかコンピュータに送れません.  これらの端
末では, 文字の並びを使って各ファンクションキーを表現します.  ただし, 
キーボード入力ルーチンがこれらの特別な文字の並びを認識して, Emacsの他
の部分に渡すまえにファンクションキーイベントに変換してしまうので, これ
らの文字の並びがEmacsユーザーの目にふれることはありません.


File: emacs-ja  Node: User Input-Footnotes, Up: User Input

(1) 【訳注】同じ意味で, 改行（newline）も使う.



File: emacs-ja, Node: Keys, Next: Commands, Prev: User Input, Up: Top

キー
====

"キー列"（key sequence）（"キー"と略記）は, 一塊で『1つのコマンド』と
しての意味を持つ入力イベントの列です.  Emacsのコマンド列の中には, 1文
字のみ, つまり, 1イベントのみであるものもあります.  たとえば, `C-f'は
ポイントを1文字先へ進めます.  しかし, なかには, 起動に2つ以上のイベン
トを必要とするコマンドもあります.

あるイベント列が1つのコマンドを起動するのに十分である場合, それらを"完
結キー"（complete key）と呼びます.  完結キーの例としては, `C-a', `X',
RET, NEXT（ファンクションキーの1つ）, DOWN（矢印キー）, `C-x C-f',
`C-x 4 C-f'があります.  完結するほど十分に長くないイベント列を, "プレ
フィックスキー"（prefix key）と呼びます.  上の例では, `C-x'や`C-x 4'が, 
プレフィックスキーです.  すべてのキー入力列は, 完結キーかプレフィック
スキーのどちらかです.

Emacs標準のコマンド割り当てでは, ほとんどの1文字は完結キーです.  残り
の少数はプレフィックスキーです.  プレフィックスキーは, 後続の入力イベ
ントと結び付いて, それ自体が完結キーやプレフィックスキーとなる, さらに
長いキーの列を作ります.  たとえば, `C-x'はプレフィックスキーなので,
`C-x'に続く入力イベントと結び付いて2文字のキー列を作ります.  `C-x C-f'
や`C-x b'を含めて, これらのキー列のほとんどは完結キーになります.  `C-x
4'や`C-x r'のように, いくつかのキー列はそれ自体がプレフィックスキーと
なり, 3文字のキー列を作ります.  キー列の長さに制限はありませんが, 実用
上は4文字を超える長さのキー列を使うことはめったにありません.

これに対して, 完結キーには入力イベントを付け加えることができません. 
たとえば, 2文字の列`C-f C-k'はキーではありません.  というのは, `C-f'が
それ自体で完結キーだからです.  `C-f C-k'にコマンドとしての独立した意味
付けをすることは不可能です.  `C-f C-k'は, 2つのキー列であって, 1つのキー
列ではありません.

Emacsのプレフィックスキーは, `C-c', `C-h', `C-x', 
`C-x RET', `C-x @', `C-x a', `C-x n', 
`C-x r', `C-x v', `C-x 4', `C-x 5', 
`C-x 6', ESC, `M-g', `M-j'です. 
しかし, これらは固定されているわけではなく, 
Emacsのキー割り当ての標準設定となっているだけです. 
Emacsをカスタマイズすれば, 新しいプレフィックスキーを設定したり, 
これらを解除したりできます. 
*Note Key Bindings::. 

プレフィックスキーを設定したり解除したりすると, 可能なキー列の集合を変
えることになります.  たとえば, `C-f'をプレフィックスキーとして再定義す
ると, `C-f C-k'は自動的に（これをさらにプレフィックスとして定義しない
限り完結した）キーになります.  逆に, `C-x 4'をプレフィックスでなくする
と, `C-x 4 f' （または`C-x 4 ANYTHING'）は, もはやキーではなくなります.

プレフィックスキーのあとにヘルプ文字（`C-h'やF1）を打つと, そのプレフィッ
クスで始まるコマンド一覧を表示できます.  歴史的な背景から, `C-h'が機能
しないプレフィックス文字も存在します.  これらの文字では, `C-h'が別の意
味に割り当てられていて, 容易には変更できないのです.  しかし, F1はすべ
てのプレフィックスに対して使えるはずです.
  


File: emacs-ja, Node: Commands, Next: Text Characters, Prev: Keys, Up: Top

キーとコマンド
==============

本書は, 特定のキーの機能を詳しく説明したページばかりです.  しかし,
Emacsは直接キーに意味を与えてはいません.  そのかわりに, Emacsは名前を
付けた"コマンド"（commands）に意味を持たせ, キーとコマンドを"バインディ
ング"（binding, 結び付ける）することによって, キーに意味を与えています.

すべてのコマンドには, プログラマが選んだ名前が付いています.  その名前
は, たいていダッシュで区切った数語の英単語です.  たとえば, `next-line'
や`forward-word'がそうです.  コマンドは, Lispプログラムである"関数定義
" （function definition, defun）を持ちます.  これが, コマンドが行うべ
きことを行えるようにしています.  Emacs Lispでは, コマンドは実際には特
別な種類の関数です.  つまり, 引数の読み取り方や対話的な呼び出し方が規
定されたLisp関数です.  コマンドと関数に関してより詳しくは, *Note 関数
とは何か: (elisp-ja)What Is a Function.を参照してください. （本書での
定義は少々簡易化してある. ）

キーとコマンドのバインディングは, "キーマップ"（keymaps）という表に記
録されています.  *Note Keymaps::.

『`C-n'は垂直方向に1行下がる』という表現では, Emacsのカスタマイズ方法
を理解するうえでは非常に重要であっても, 普段の使い方では意味のない「区
別」をあえて無視しています.  下がるようにプログラムされているのは
`next-line'というコマンドです.  `C-n'がそのコマンドにバインドされてい
るので, そのような効果を発揮するのです.  `C-n'をコマンド`forward-word'
にバインドし直すと, `C-n'は, かわりに1単語ずつ先へ進むようになります. 
キーの再バインディングは, カスタマイズの一般的な方法です.

本書では, 今後, 話を単純にするために, 普段はこの違いを無視することにし
ます.  カスタマイズに必要な情報を示す場合, コマンドを実行するキーを記
したあとに, 実際にその動作を行うコマンドの名前を括弧に括って示します. 
たとえば, 『コマンド`C-n'（`next-line'）は, ポイントを下向きに移動する』
という表現では, 下向きに移動するコマンドは`next-line'であり, 標準では
キー`C-n'にバインドされていることを意味します.

これまでカスタマイズに関して述べてきましたので, "変数"についてふれてお
く時期でしょう.  コマンドの説明では, 『これを変更するには, 変数
`mumble-foo'を設定する』と記述することがあります.  変数とは, 値を記憶
しておくために使う名前のことです.  本書に記載された変数の大部分は, カ
スタマイズのために使われます.  いくつかのコマンドやEmacsの他の部分では, 
変数を調べて設定された値に従ってそのふるまいを変えていきます.  カスタ
マイズに興味が出てくるまでは, 変数に関する記述は無視してかまいません. 
カスタマイズしてみたいと思ったら, 変数に関する基礎を読んでください. 
そうすれば, 個々の変数に関する情報を理解できるでしょう.  *Note
Variables::.



File: emacs-ja, Node: Text Characters, Next: Entering Emacs, Prev: Commands, Up: Top

テキスト用の文字集合
====================

Emacsバッファ内のテキストは, 1バイト8ビットのバイトの列です.  各バイト
で, 1つのASCII文字を表現できます.  ASCIIコントロール文字（8進数000〜
037, 0177）とASCII印字文字（8進数040〜0176）の両方を使えます.  しかし, 
非ASCIIコントロール文字はバッファには現れません.  メタのようなキーボー
ド入力で用いられるその他の修飾フラグもバッファ内では許されません.

いくつかのASCIIコントロール文字は, テキスト中では特別な目的のために用
いられていて, 特別な名前が付いています.  たとえば, 改行文字（8進数012）
は, バッファ内の1行の終りに使われます.  また, タブ文字（8進数011）は, 
つぎのタブストップ位置（通常8桁ごと）までテキストを字下げするために使
われます.  *Note Text Display::.

非ASCII印字文字もバッファ内に存在できます.  マルチバイト文字を使用可に
してあれば, Emacsが扱える任意の非ASCII印字文字を使えます.  それらの文
字の文字コードは256（8進で0400）から始まり, 各文字は2バイト, あるいは
それ以上のバイト列として表現されます.  *Note International::.

マルチバイト文字を使用不可にしている場合, 非ASCII文字のうちの1種類のア
ルファベットだけを使えますが, それらはすべて1バイトに収まるものです. 
文字コードは0200から0377を使います.  *Note Single-Byte European
Support::.


File: emacs-ja, Node: Entering Emacs, Next: Exiting, Prev: Text Characters, Up: Top

Emacsの起動と終了
*****************

Emacsを起動する普通の方法は, シェルコマンドの`emacs'です.  Emacsは, 画
面をクリアし, 初期ヘルプメッセージとコピーライトを表示します.  オペレー
ティングシステムによっては, Emacsが起動するまでに先打ちした入力をすべ
て破棄してしまうことがあります.  Emacs側ではこれを防ぐことはできません. 
したがって, 編集コマンドを打ち始めるまえに, Emacsが画面をクリアするま
で待つように推奨します.

Xウィンドウシステム上のシェルウィンドウからEmacsを起動するのであれば,
`emacs&'のようにバックグラウンドで実行するようにしましょう.  こうすれ
ば, Emacsがシェルウィンドウを拘束することがないので, Emacsが専用のXの
ウィンドウで動作中でも, 別のシェルコマンドを実行できます.  キーボード
入力をEmacsのフレームに向ければ, ただちにEmacsコマンドを打ち始められま
す.

Emacsが動き始めると, `*scratch*'という名前のバッファを作ります.  ユー
ザーはこのバッファから始めます.  バッファ`*scratch*'は, Lisp対話
（lisp-interaction）モードですから, Lisp式を打ち込んでそれを評価できま
すし, あるいは, この機能を無視して単なる落書用として使ってもかまいませ
ん.  （個人の初期化ファイル中で変数`initial-major-mode'を設定すれば, 
このバッファに別のメジャーモードを指定できる.  *Note Init File::. ）

シェルのコマンド行でEmacsに引数を与えて, 訪問するファイル, ロードする
Lispファイル, 呼び出す関数を指定できます.  *Note Command Arguments::. 
ただし, これはお勧めしません.  この機能は, 主に, 他のエディタとの互換
性のためにあるのです.

他のエディタの多くは, 編集を行うたびに新たに起動するように設計されてい
ます.  1つのファイルを編集し終えると, エディタを終了します.  つぎに別
のファイルや同じファイルを編集したければ, 再度, エディタを起動する必要
があります.  これらのエディタでは, コマンド行の引数で編集するファイル
を指定する意味があります.

しかし, 別のファイルを編集するたびに新たにEmacsを起動するのはナンセン
スです.  1つには, 起動はじれったいほど遅いでしょう.  また, このように
すると, 1つの編集セッションで複数のファイルを扱えるEmacsの利点を活かせ
ません.  さらに, レジスタやアンドゥ履歴, マークリングといった, それま
でに蓄積した内容も失ってしまいます.

GNU Emacsの推奨される使い方は, ログイン後に1度だけEmacsを起動して, す
べての編集を同じEmacsセッションで行うことです.  別のファイルを編集する
には, 既存のEmacsでそのファイルを訪問します.  そうすると, ついには, 多
くのファイルをすぐに編集できる状態で保持することになります.  通常, ロ
グアウトするまで, Emacsを終了する必要はありません.  複数のファイルを訪
問することに関して詳しくは, *Note Files::.



File: emacs-ja, Node: Exiting, Next: Basic, Prev: Entering Emacs, Up: Top

Emacsの終了
===========

Emacsの抜け方には, "休止"（suspending）する, "終了"（killing）するの2
種類があるので, Emacsを抜けるコマンドも2つあります.

"休止"（suspending）は, 一時的にEmacsを止めて, 親プロセス（通常はシェ
ル）に制御を戻します.  こうすると, 同じバッファ, 同じキルリング, 同じ
アンドゥ履歴を保持したままの同じEmacsジョブをあとで再開できます.  これ
が通常の抜け方 (1) (*Note Exiting-Footnotes::)です.

"終了"（killing）は, Emacsジョブの破壊を意味します.  あとでまたEmacsを
起動できますが, 新たなEmacs環境です.  終了したあとでは, 同じ編集セッショ
ンを再開する方法はありません.

`C-z'
     Emacsを休止する, あるいは, フレームをアイコン化する
     （`iconify-or-deiconify-frame'）.
`C-x C-c'
     Emacsを終了する（`save-buffers-kill-emacs'）.

Emacsを休止するには, `C-z'（`suspend-emacs'）と打ちます.  すると,
Emacsを起動したシェルに戻ります.  ほとんどの一般的なシェルでは, シェル
コマンド`%emacs'でEmacsを再開できます.

プログラムを休止できないシステムでは, `C-z'は, 端末と直接やりとりする
下位シェルを起動します.  Emacsは, ユーザーがこのサブシェルから抜け出る
まで待ちます.  （普通, `C-d'や`exit'でサブシェルを終了するはずだが, 使っ
ているシェルに依存する. ）このようなシステムでは, Emacsを起動したシェ
ルに（たとえばログアウトのために）戻るには, Emacsを終了する以外に方法
はありません.

プログラムを休止できるシステムであっても, プログラムを休止できないシェ
ル上で実行しているEmacsは休止できません.  このような場合, 変数
`cannot-suspend'に`nil'以外の値を設定して, `C-z'に下位シェルの実行を強
制できます.  （適切なジョブ制御をできないEmacsの親シェルを『下位』と呼
ぶこともできるが, これは好みの問題. ）

EmacsがXサーバーと直接通信して専用のXのウィンドウを作っている場合には,
`C-z'は別の意味になります.  専用のXのウィンドウを持つアプリケーション
を休止しても, あまり意味がありませんし, 便利なわけでもありません.  そ
のかわり, `C-z'は, 選択されているEmacsフレーム（*Note Frames::）を一時
的に閉じるコマンド`iconify-or-deiconify-frame'を実行します.  シェルウィ
ンドウに戻るには, ウィンドウマネージャの機能を使います.

Emacsを終了するには, `C-x C-c' （`save-buffers-kill-emacs'）と打ちます. 
これを2文字のキーにしてあるのは, 少々打ちづらく (2) (*Note
Exiting-Footnotes::)するためです.  このコマンドは, まず, 変更したバッ
ファを保存するかどうか聞いてきます.  未保存のものがあるとそれらを永久
に失うことになるので, Emacsを終了するまえに`yes'での再確認を求めてきま
す.  Emacsを終了するとサブプロセスもただちに終了されられてしまうため, 
サブプロセスが走っている場合にも, それらに関して確認を求めてきます.


一度Emacsを終了してしまうと, Emacsセッションを再開する方法はありません. 
しかしながら, 終了時に訪問していたファイルなどの特定のセッション情報を
記録するようにEmacsに指示しておけば, つぎにEmacsを起動し直したときに, 
同じファイルを訪問するなどを試みるようになります.  *Note Saving Emacs
Sessions::.

オペレーティングシステムは, 通常, 実行中のプログラムを終了させたり休止
させたりする特定の特殊文字を監視しています.  Emacsを使っているときには, 
オペレーティングシステムのこの機能はオフになっています (3) (*Note
Exiting-Footnotes::) .  Emacsのキーとしての`C-z'や`C-x C-c'の意味は, 
いくつかのオペレーティングシステムでプログラムを休止させたり終了させた
りするために用いる文字, `C-z'と`C-c'にヒントを得たものですが, オペレー
ティングシステムとの関係はそれだけです.  これらのキーで好きなコマンド
を実行するようにカスタマイズできます（*Note Keymaps::）.



File: emacs-ja  Node: Exiting-Footnotes, Up: Exiting

(1) 【訳注】これは, 画面端末を使っている場合の話.

(2) 【訳注】簡単に終了してしまっては, 困るので.

(3) 【訳注】Emacsが専用のXのウィンドウを使っている場合は関係ない.


File: emacs-ja, Node: Basic, Next: Minibuffer, Prev: Exiting, Up: Top

基本編集コマンド
****************

テキストの入力, 修正, ファイルへの保存といった基本操作について説明しま
す.  これらに接するのが初めてという読者は, 手を動かしながら学ぶチュー
トリアルを実行したほうが, もっと簡単に習得できる思います.  チュートリ
アルを利用するには, Emacsを起動して`Control-h t'と打ちます. (1) (*Note
Basic-Footnotes::)

画面をクリアして再表示するには, `C-l'（`recenter'）と打ちます.

* Menu:


* Inserting Text::      Inserting text by simply typing it.
* Moving Point::        How to move the cursor to the place where you want to
			  change something.
* Erasing::	        Deleting and killing text.
* Undo::	        Undoing recent changes in the text.
* Files: Basic Files.   Visiting, creating, and saving files.
* Help: Basic Help.     Asking what a character does.
* Blank Lines::	        Commands to make or delete blank lines.
* Continuation Lines::  Lines too wide for the screen.
* Position Info::       What page, line, row, or column is point on?
* Arguments::	        Numeric arguments for repeating a command.
* Repeating::           A short-cut for repeating the previous command.


File: emacs-ja  Node: Basic-Footnotes, Up: Basic

(1) 【訳注】Emacsのインストールの仕方によっては, きちんと日本語のチュー
トリアルが表示される.  そうでなければ, `M-x
set-language-environment RET Japanese RET'（あるいは,
`C-x RET l Japanese RET'）と打ってから, 改めて
`Control-h t'と打つ.  日本語以外にもいくつかの言語のチュートリアル
がある.



File: emacs-ja, Node: Inserting Text, Next: Moving Point, Prev: Basic, Up: Basic

テキストを挿入する
==================

編集中のテキストに印字文字を挿入するには, 単にその文字を打ちます.  こ
うすると, 打鍵した文字がバッファのカーソル位置（すなわち"ポイント"位置.
*Note Point::）に挿入されます.  カーソルは右（前向き）に移動して, それ
にあわせてカーソル以降のすべてのテキストも右（前向き）に移動します. 
バッファ内のテキストが`FOOBAR'であって, カーソルが`B'に重なっていると
すると, `XX'と打つとカーソルは`B'に重なったままで, `FOOXXBAR'となりま
す.

挿入したばかりのテキストを"削除"（delete）するには, DELキーを使います.
DELキーは*カーソルのまえ*の文字を削除します（カーソルが重なっている文
字ではない.  その文字はカーソルのうしろにある）.  カーソルとカーソル以
降のすべてのテキストは左（後向き）に移動します.  つまり, 図形文字を1つ
打った直後にDELを打つと, 挿入を取り消したことになります.

行を終えて新たな行を打ち始めるには, RETを打ちます.  これにより, バッファ
に改行文字が挿入されます.  ポイントが行の途中にある場合, RETは行を分割
します.  カーソルが行頭にあるときにDELを打つと, 直前の改行文字が削除さ
れて直前の行と連結されます.

"自動詰め込み"（auto-fill）モードと呼ばれる特別なマイナモードをオンに
しておくと, 行が長くなりすぎたときにEmacsが自動的に行を分割します.  自
動詰め込み（auto-fill）モードの使い方は, *Note Filling::.

既存のテキストを右に押しやるのではなく, テキストを順次置き換える（上書
きする）のが好みならば, マイナモードの1つである上書き（overwrite）モー
ドをオンにします.  *Note Minor Modes::.

印字文字とSPCは直接挿入できますが, それ以外の文字は編集コマンドとして
機能して, それ自体を挿入しません.  コントロール文字や8進で0200を超える
文字コードの文字を挿入したい場合には, まず`Control-q'（`quoted-insert'）
と打って, それらの文字を"クォート"（quote） (1) (*Note Inserting
Text-Footnotes::) する必要があります.  （`Control-q'は, 通常, `C-q'と
略す. ）`C-q'の使い方には, つぎの2つがあります.

   * `C-q'に続く非図形文字（`C-g'でさえも）を挿入する.

   * `C-q'に続く8進数字列は, 8進数字列で指定されるコードの文字を挿入す
     る.  8進数字の桁数はいくつでもかまわず, 8進数字以外で数字列は終る. 
     終端の文字がRETであれば, 単に数字列を終らせるだけ.  それ以外の非
     数字は, 数字列を終らせるだけでなく, その文字自身も入力として扱わ
     れる.  （普通の上書き（overwrite）モードでは, 上書きのかわりに挿
     入を簡単に行う手段としているため, この8進数字列は使えない. ）

マルチバイト文字が使用可ならば, 8進コード0200から0377までは正しい文字
ではありません.  この範囲のコードを指定すると, `C-q'はISO Latin-N文字
集合の利用を意図しているとみなして, 指定したコードを対応するEmacs文字
コードに変換します.  *Note Enabling Multibyte::.  言語環境の選択
（*Note Language Environments::）を介して, ISO Latin文字集合を1つ選び
ます.

8進数のかわりに10進数や16進数を使うには, 変数`read-quoted-char-radix'
に10や16を設定します.  基数が10を超える場合には, `a'から始まるいくつか
の英字は文字コードの一部として数字の桁と同じように扱われます.

`C-q'に数引数を指定すると, クォートした文字を何個挿入するかを指定しま
す（*Note Arguments::）.

カスタマイズ情報：` ' ほとんどのモードでは, DELはコマンド
`delete-backward-char'を実行します.  RETはコマンド`newline'を実行しま
す.  自己挿入の図形文字はコマンド`self-insert'を実行します.
`self-insert'は, これを起動した文字が何であってもその文字を挿入します. 
いくつかのメジャーモードでは, DELを別のコマンドにバインドし直していま
す.


File: emacs-ja  Node: Inserting Text-Footnotes, Up: Inserting Text

(1) 【訳注】なんらの解釈もせずに, 単なる文字として扱う.



File: emacs-ja, Node: Moving Point, Next: Erasing, Prev: Inserting Text, Up: Basic

ポイント位置を移動する
======================

文字の挿入以外のことを行うには, ポイント（*Note Point::）の移動方法を
知っておく必要があります.  もっとも簡単な方法は, 矢印キーを使うか, 移
動先の箇所でマウスの左ボタンをクリックします.

カーソル移動のためのコントロール文字やメタ文字もあります.  一部は矢印
キーと同等です（これらは, 矢印キーを備えた端末が現れるまえからあった. 
矢印キーがない端末では便利）.  他のものは, こったことをします.

`C-a'
     行頭に移動する（`beginning-of-line'）.
`C-e'
     行末に移動する（`end-of-line'）.
`C-f'
     前向き（右）に1文字移動する（`forward-char'）.
`C-b'
     後向き（左）に1文字移動する（`backward-char'）.
`M-f'
     前向きに1語移動する（`forward-word'）.
`M-b'
     後向きに1語移動する（`backward-word'）.
`C-n'
     垂直に1行下へ移動する（`next-line'）.  このコマンドは行内での横方
     向の位置を保とうとする.  したがって, 行の途中で使うと, つぎの行の
     途中に移動する.  テキストの最終行である場合には, `C-n'は新たな行
     を作り, その行へ移動する.
`C-p'
     垂直に1行上へ移動する（`previous-line'）.
`M-r'
     ポイントをウィンドウの縦方向の中央位置で左端に移動する
     （`move-to-window-line'）.  テキストは画面上を移動しない.

     数引数は, 画面上の何行目にポイントを移動するかを指定する.  行数は, 
     ウィンドウ上端（0行目）から下向きに数える.  負の引数では, ウィン
     ドウの下端（-1行）から数える.
`M-<'
     バッファの先頭に移動する（`beginning-of-buffer'）.  数引数Nを指定
     すると, 先頭から全体のN/10の行にポイントを移動する.  数引数の詳細
     については, *Note Arguments::.
`M->'
     バッファの末尾に移動する（`end-of-buffer'）.
`M-x goto-char'
     数値Nを読み取り, バッファのN番目の文字にポイントを移動する.  バッ
     ファの先頭が位置1.
`M-x goto-line'
     数値Nを読み取り, N行目にポイントを移動する.  バッファの先頭が第1
     行.
`C-x C-n'
     現在ポイントがある桁を`C-n'や`C-p'の"半恒久的な目標桁"として設定
     する.  このあと, これらのコマンドは, 移動先の各行でこの桁位置に, 
     あるいは, 行の内容によっては可能な限りこの桁に近い位置にポイント
     を移動する.  この目標桁は取り消すまで有効.
`C-u C-x C-n'
     目標桁を取り消す.  これ以後, `C-n'や`C-p' は, 通常のように横方向
     の位置を保とうとする.

変数`track-eol'に`nil'以外を設定すると, 行末にポイントがある場合の
`C-n'や`C-p'は, 移動先の行でも行末にポイントを移動します.  通常,
`track-eol'は`nil'です.  `track-eol'のような変数の設定方法については,
*Note Variables::.

通常, バッファの最終行での`C-n'は, 新しい行を追加します.  変数
`next-line-add-newlines'が`nil'である場合, `C-n'は新規の行を追加せずに
（先頭行での`C-p'と同様に）エラーになります.



File: emacs-ja, Node: Erasing, Next: Undo, Prev: Moving Point, Up: Basic

テキストの消去
==============

`DEL'
     ポイントの直前の文字を削除する（`delete-backward-char'）.
`C-d'
     ポイントの直後の文字を削除する（`delete-char'）.
`C-k'
     行末までをキルする（`kill-line'）.
`M-d'
     つぎの語の末尾までを前向きにキルする（`kill-word'）.
`M-DEL'
     まえの語の先頭までを後向きにキルする（`backward-kill-word'）.

ポイントの直前（つまり, カーソルの直前）の文字を削除するDELキーについ
てはすでに知っていますね.  `Control-d'（`C-d'と略記）は, ポイントの直
後の文字（つまり, カーソルが重なっている文字）を削除します.  すると, 
残りのテキストは左に移動します.  行末で`C-d'を打つと, その行とつぎの行
が連結されます.

大量のテキストを消去するには, `C-k'を使います.  `C-k'は1行を一度にキル
します.  行頭や行の途中で`C-k'を打つと, 行末までのすべてのテキストをキ
ルします.  行末で`C-k'を打つと, その行とつぎの行を連結します.

より柔軟なテキストのキルについての詳細は, *Note Killing::.



File: emacs-ja, Node: Undo, Next: Basic Files, Prev: Erasing, Up: Basic

変更をアンドゥする（もとに戻す）
================================

バッファのテキストに対する変更は, ある時点まで遡って, すべてアンドゥ
（もとに戻すことが）できます.  各バッファでは個々の変更をそれぞれ記録
していて, アンドゥコマンドは, つねにカレントバッファに作用します.  通
常, 各編集コマンドはアンドゥ記録に別々の項目を作成しますが,
`query-replace'のようなコマンドは一度に多くの項目を作りますし, 自己挿
入文字のように非常に単純なコマンドは, もとに戻すのを単純にするために, 
まとめられます.

`C-x u'
     一塊の変更をもとに戻す.  普通, 1つのコマンドに相当する（`undo'）.
`C-_'
     同じ.
`C-u C-x u'
     リージョン内で, 一塊の変更をもとに戻す.

変更をもとに戻すには, コマンド, `C-x u'や`C-_'を使います.  始めにこの
コマンドを実行すると, 直前の変更をもとに戻します.  ポイントは, もとに
戻されたコマンドを実行するまえの位置に戻ります.

`C-_'や`C-x u'を連続して実行すると, アンドゥ情報の限界に達するまで, 次々
に以前の変更をもとに戻していきます.  記録されているすべての変更をもと
に戻してしまうと, アンドゥコマンドはその旨エラーメッセージを表示します.

アンドゥコマンド以外の他のコマンドを実行すると, アンドゥコマンドの連続
実行系列が断ち切られます.  これ以後, これよりまえのアンドゥコマンドの
実行自体が, もとに戻すことが可能な一般の変更として扱われます.  したがっ
て, もとに戻してしまった変更をやはりそのとおりに変更しておきたい場合に
は, `C-f'と打つか, あるいは, 無害なコマンドを実行してアンドゥの連続実
行系列を断ち切ってから, さらにアンドゥコマンドを打ちます.

普通のアンドゥは, カレントバッファにおけるすべての変更に作用します. 
カレントリージョン内に制限した"選択的なアンドゥ"（selective undo）を行
うこともできます.  これには, リージョンを設定してから, 数引数（値は関
係ない）を指定して`undo'コマンドを, つまり, `C-u C-x u'や`C-u C-_'を実
行します.  これにより, リージョン内のもっとも最近の変更がもとに戻りま
す.  同じリージョン内の変更をさらにもとに戻すには, `undo'コマンドを繰
り返します（これには数引数は必要ない）.  暫定マーク（transient-mark）
モードでは, リージョンが活性のときに`undo'を使うと選択的なアンドゥを行
います.  つまり, 数引数は必要ありません.

バッファを誤って変更してしまった場合, もとに戻すもっとも簡単な方法は, 
モード行の先頭部分から星印が消えるまで`C-_'を繰り返し打つことです.  そ
うすれば, すべての修正を取り消したことになります.  アンドゥコマンドに
よりモード行から星印が消えた場合はつねに, バッファの内容がファイルを訪
問したときと同じであるか, 最後に保存したときと同じであることを意味しま
す.

意図してバッファを変更したかどうかあやふやなときは, 一度だけ`C-_'を打
ちます.  もとに戻すことで最後の変更箇所がわかりますから, それが意図し
た変更かどうか判断できるでしょう.  意図した変更でなければ, もとに戻し
たままにしておきます.  意図した変更であったなら, 上記の方法で変更し直
します.

すべてのバッファでアンドゥ情報を記録するわけではありません.  空白で始
まる名前のバッファでは記録しません.  これらのバッファは, Emacsやその拡
張部分が内部的に使用するもので, ユーザーが通常見たり編集したりしないテ
キストを保持しています.

単なるカーソル移動はアンドゥできません.  バッファの内容を変更したとき
だけアンドゥ情報が保存されます.  ただし, いくつかのカーソル移動コマン
ドはマークを設定しますから, これらのコマンドをときどき使えば, マークリ
ング（*Note Mark Ring::）から取り出しながら, 通ってきたそれぞれの箇所
へ戻ることができます.

バッファに関するアンドゥ情報が大きくなると, Emacsはもっとも古いアンドゥ
情報から順に（ガベッジコレクション中に）破棄していきます.  保持すべき
アンドゥ情報の量を指定するには, 2つの変数`undo-limit'と
`undo-strong-limit'を設定します.  これらの変数の値は, 保存領域のバイト
数です.

変数`undo-limit'は緩い限界（soft limit）を設定します.  Emacsは, このサ
イズに達するまでのコマンド分のアンドゥデータを保持します.  データ量が
このサイズを超える場合もありますが, このデータ量を超えるような古いコマ
ンド分のデータは保持しません.  デフォルトは, 20000です.  変数
`undo-strong-limit'は, 厳密な限界（stricter limit）を設定します.  この
量を超えるデータに対応するコマンドのデータは破棄します.  初期値は30000
です.

これらの変数の値に関わらず, 最新の変更を破棄することはありませんので, 
意図しない大きな変更を加えてしまった直後にガベッジコレクションが発生し
ても, その変更をアンドゥできないというようなことはありません.

アンドゥコマンドを実行するキーが`C-x u'と`C-_'と2つある理由は, 1文字キー
にするほど重要なのですが, どうやって`C-_'を打つか自明でないキーボード
もあるからです.  `C-x u'は, どの端末でも素直に打てる代替手段なのです.



File: emacs-ja, Node: Basic Files, Next: Basic Help, Prev: Undo, Up: Basic

ファイル
========

Emacsバッファ内でテキストを作成したり変更したりするには, これまでに説
明したコマンドで十分なはずです.  より高度なEmacsコマンドといっても, こ
れらの操作を容易にするだけです.  しかし, テキストを恒久的なものとする
には, "ファイル"（file）に保存する必要があります.  ファイルとは, オペ
レーティングシステムが保存するために名前を付けたテキストの一塊であり, 
あとでその名前で取り出せます.  Emacsでファイルを編集する場合を含めて, 
ファイルの内容を眺めたり利用したりするには, ファイル名を指定する必要が
あります.

`/usr/rms/foo.c'という名前のファイルがあるとしましょう.  このファイル
を編集し始めるには, Emacsではつぎのように打ちます.

     C-x C-f /usr/rms/foo.c RET

ここで, ファイル名は, コマンド`C-x C-f'（`find-file'）に対する"引数"
（argument）として与えます.  このコマンドは引数を読むために"ミニバッファ
"を使います.  引数の入力を終えるには, RETを打ちます（*Note
Minibuffer::）.

Emacsはコマンドに従い, ファイルを"訪問"（visiting）します.  つまり, バッ
ファを作成し, ファイルの内容をそのバッファにコピーし, ユーザーが編集で
きるようにそのバッファを表示します.  テキストを変更したら, `C-x C-s'
（`save-buffer'）と打てば, 新しいテキストをファイルに"保存"（save）で
きます.  これにより, バッファの変更した内容をファイル`/usr/rms/foo.c'
にコピーし戻したので, 変更は恒久的になります.  ユーザーが保存するまで
は, 変更はEmacs内部のみに存在するだけで, ファイル`foo.c'自体は未変更の
ままです.

ファイルを作成するには, そのファイルが既存であるかのように, `C-x C-f'
でファイルを訪問するだけです.  これにより, 空のバッファが作られ, ファ
イルに収めたいテキストを挿入できるようになります.  `C-x C-s'でバッファ
を保存したときに, ファイルが実際に作成されます.

もちろん, ファイルについてはもっと知っておく必要があります.  *Note
Files::.



File: emacs-ja, Node: Basic Help, Next: Blank Lines, Prev: Basic Files, Up: Basic

ヘルプ
======

キーの機能を忘れてしまった場合には, ヘルプ文字`C-h'（あるいは`C-h'の別
名であるF1）を使って, 調べられます.  `C-h k'と打ってから, 調べたいキー
を続けて打ちます.  たとえば, `C-h k C-n'は, `C-n'が何をするか教えてく
れます.  `C-h'はプレフィックスキーです.  `C-h k'は, `C-h'の1つのサブコ
マンド（コマンド`describe-key'）です.  `C-h'には他にもサブコマンドがあ
り, それぞれ異なる種類のヘルプを表示します.  `C-h'を2回打てば, ヘルプ
機能自体の説明を見ることができます.  *Note Help::.



File: emacs-ja, Node: Blank Lines, Next: Continuation Lines, Prev: Basic Help, Up: Basic

空行
====

空行の挿入と削除に関する特別なコマンドや技法を紹介します.

`C-o'
     カーソルの直後に1行以上の空行を挿入する（`open-line'）.
`C-x C-o'
     連続する空行を1行だけ残してすべて削除する（`delete-blank-lines'）.

既存の行のまえに新たに1行を挿入するには, 
新しい行のテキストを打ってからRETを打つこともできます. 
しかし, まず空行を作ってから, 
そこに希望のテキストを挿入するほうが何をしているのかがわかりやすいでしょう. 
キー`C-o'（`open-line'）を使えば簡単です. 
これはポイントの直後に改行を挿入して, 
ポイントは改行の直前に置かれたままとなります. 
`C-o'に続けて, 新しい行のテキストを打ちます. 
`C-o F O O'は, ポイントの最終的な位置を除けば, 
`F O O RET'と同じ効果を持ちます. 

複数の空行を作るには, `C-o'を数回打つか, 作りたい空行の個数を指定する
数引数を指定します.  数引数の指定方法は, *Note Arguments::.  詰め込み
接頭辞を設定してある場合, 行の先頭で`C-o'コマンドを使うと, このコマン
ドは新しい行に詰め込み接頭辞を挿入します.  *Note Fill Prefix::.

余分な空行を削除するには, コマンド`C-x C-o'（`delete-blank-lines'）を
使います.  連続する複数の空行の中で`C-x C-o'を実行すると, 1行を残して
すべての空行を削除します.  空行が1行だけの場合, その空行自体を削除しま
す.  空行でない行にポイントがある場合, その行に続くすべての空行を削除
します.



File: emacs-ja, Node: Continuation Lines, Next: Position Info, Prev: Blank Lines, Up: Basic

継続行
======

RETで分割せずに1行に文字を加え続けると, その行は画面上で2行以上を占め
るようになります.  このとき, そのような行の最後の行を除くすべての行の
右端には, `\'が表示されます.  この`\'は, 画面上の後続の行はテキスト内
の独立した行ではなく, 画面に収まりきらない長い行が"継続"（continuation）
していることを意味します.  この継続を, "折り返し"（wrapping）とも呼び
ます.

行が長くなりすぎたときにEmacsが自動的に改行を挿入すると便利なことがあ
ります.  画面上での継続は, このようには機能しません.  自動的に改行する
ようにするには, 自動詰め込み（auto-fill）モード（*Note Filling::）を使
います.

継続のかわりの方法として, Emacsは長い行を"切り捨て"（truncation）て表
示することもできます.  つまり, 画面やウィンドウの幅に収まりきらない文
字は表示しません.  もちろん, 一時的に見えないだけで, バッファ内には存
在しています.  切り捨てていることを示すために, `\'ではなく`$'を右端に
用います.

水平スクロールを使っていたり, ウィンドウを左右に並べていると, 継続のか
わりに切り捨て表示します（*Note Windows::）.  特定のバッファの変数
`truncate-lines'に`nil'以外を設定すると, そのバッファを切り捨て表示に
できます（*Note Variables::）.  変数`truncate-lines'の値を変更すると, 
この変数はカレントバッファにローカルになります.  そうするまでは, デフォ
ルト値が使われます.  デフォルトの初期値は`nil'です.  *Note Locals::.

テキストの表示方法に影響する変数については, *Note Display Vars::.



File: emacs-ja, Node: Position Info, Next: Arguments, Prev: Continuation Lines, Up: Basic

カーソル位置の情報
==================

バッファのある部分の大きさや位置に関する情報を得るコマンドや行を数える
コマンドを紹介します.

`M-x what-page'
     ポイントがあるページの番号とそのページ内での行番号を表示する.
`M-x what-line'
     ポイントがある行のバッファ内での行番号を表示する.
`M-x line-number-mode'
     現在行の自動行番号表示をオン／オフする.
`M-='
     カレントリージョンの行数を表示する（`count-lines-region'）.  リー
     ジョンに関しては, *Note Mark::.
`C-x ='
     ポイントの直後にある印字文字の文字コード, ポイントの文字位置, ポ
     イントの桁位置を表示する（`what-cursor-position'）.

行番号に関するコマンドは2つあります.  `M-x what-line'は現在行の行番号
を計算して, エコー領域に表示します.  指定した行番号の行へ移動するには,
`M-x goto-line'を使います.  このコマンドは, 行番号を聞いてきます.  こ
れらの行番号は, バッファの先頭を1行目と数えます.

モード行で現在行の行番号を知ることもできます.  *Note Mode Line::.  バッ
ファをナロイングしてある場合, モード行中の行番号は参照可能な範囲内での
相対的なものになります（*Note Narrowing::）.  対照的に, `what-line'は, 
ナロイングされた範囲内での行番号と, バッファ全体での行番号の両方を表示
します.

これに対し, `M-x what-page'は, ファイルの先頭からページを数え, さらに
ページ内での行番号も数えて, 両方を表示します.  *Note Pages::.

この話題に関連して, `M-='（`count-lines-region'）も説明しておきましょ
う.  これは, リージョンの行数を数えて表示します（*Note Mark::）.  カレ
ントページの行数を数えるコマンド`C-x l'については, *Note Pages::.

コマンド`C-x ='（`what-cursor-position'）は, カーソルがある箇所の桁位
置を求めたり, ポイントに関するその他の種々の情報を得るために使います. 
エコー領域につぎのように表示します.

     Char: c (0143, 99, 0x63)  point=21044 of 26883(78%)  column 53 

（これは, 例の中の`column'のまえにポイントがあるときの実際の出力. ）

`Char:'のあとの4つの値は, ポイントの直後の文字を表していて, 文字そのも
の, 続いて, 文字コードの8進表示, 10進表示, 16進表示です.  非ASCIIのマ
ルチバイト文字に対しては, バッファのコーディングシステムにおいて当該文
字をまちがいなく, かつ, 単一バイトで符号化できる場合には, `ext'とバッ
ファのコーディングシステムで表した文字コードの16進表示が続きます
（*Note Coding Systems::）.  文字の符号が1バイトより長い場合には,
Emacsは`ext ...'を表示します.

`point='のあとは, ポイント位置を文字単位に数えたものです.  バッファの
先頭を位置1, つぎの1文字を2, というように数えます.  つぎの大きな数字は
バッファ内の総文字数です.  続く括弧の中は, ポイント位置の全サイズに対
する百分率です.

`column'に続くものは, ウィンドウの左端からの桁数で表したポイントの水平
位置です.

バッファをナロイングしていて, バッファの先頭と末尾のテキストの一部が表
示されていない場合, `C-x ='は, 現在参照可能な範囲に関する情報も表示し
ます.  たとえばつぎのようになります.

     Char: C (0103, 67, 0x43)  point=252 of 889(28%) <231 - 599>  column 0 

ここで, 新たに追加された2つの数字が, ポイントを設定できる文字位置の下
限と上限を示します.  これら2つの位置のあいだの文字が参照可能な文字です.
*Note Narrowing::.

ポイントがバッファの末尾（あるいは参照可能な部分の末尾）にある場合, 
`C-x ='は, ポイントの直後の文字に関する情報は表示しません. 
出力はつぎのようになります. 

     point=26957 of 26956(100%)  column 0 

`C-u C-x ='は, バッファ内の位置と桁位置のかわりに, 文字に関する追加情
報, つまり, 文字集合名とその文字集合内でその文字を識別するコードを表示
します.  ASCII文字は, 文字集合`ASCII'に属するものと識別します.  さらに, 
文字を完全に符号化するのに単一バイトより多く必要な場合であっても,
`ext'のあとに文字コードを表示します.  コーディングシステムが
iso-2022-7bitであるバッファ内にあるLatin-1のアクサングレーブ付きの文字
Aの例を示します. (1) (*Note Position Info-Footnotes::)

     Char: `A (04300, 2240, 0x8c0, ext ESC , A @) (latin-iso8859-1 64)


File: emacs-ja  Node: Position Info-Footnotes, Up: Position Info

(1) Latin-1文字を表示できる端末であれば, `Char:'のあとに表示され
る文字は, 実際に, アクサングレーブ付きの文字Aになる.



File: emacs-ja, Node: Arguments, Next: Repeating, Prev: Position Info, Up: Basic

数引数
======

数学や計算機の用語では, "引数"（argument）という単語は『関数や操作に与
えるデータ』を意味します.  Emacsのすべてのコマンドには, "数引数"
（numeric argument）（"前置引数"（prefix argument）とも呼ぶ）を指定で
きます.  コマンドによっては, 引数を反復回数として解釈します.  たとえば, 
引数10を`C-f'に指定すると, カーソルを通常の1文字ではなく, 10文字分前向
きに移動します.  これらのコマンドでは, 引数を指定しないと引数1を指定し
たのと同等になります.  この種のコマンドの多くでは, 負の引数を指定する
と, 逆向きの移動や逆の操作を指示することになります.

端末のキーボードにMETAキーがある場合, 数引数を入力するもっとも簡単な方
法は, METAキーを押し下げたままで, 数字やマイナス記号を打ちます.  たと
えば, M-5 C-n は, カーソルを5行下に移動します.  `Meta-1', `Meta-2',
`Meta--'などの文字がこのように動作するのは, これらのキーが, 後続のコマ
ンドに引数を与えるように定義されたコマンド（`digit-argument'と
`negative-argument'）にバインドされているからです.  コントロールやコン
トロールとメタで修飾した数字と`-'も, 同様に数引数を指定します.

引数を指定する別の方法は, `C-u'（`universal-argument'）コマンドに続け
て引数の数字を入力することです.  `C-u'では, 修飾キーを押し下げ続けるこ
となく引数の数字を打てます.  `C-u'はすべての端末で使えます.  負の引数
を指定するには, `C-u'のあとにまずマイナス記号を打ちます.  マイナス記号
だけだと-1を意味します.

`C-u'のあとに数字でもマイナス記号でもない文字を打つと, 『4倍する』とい
う特別な意味になります.  つまり, 後続のコマンドに渡す引数を4倍します.
`C-u'を2回打つと, 引数を16倍します.  したがって, `C-u C-u C-f'は, カー
ソルを前向きに16文字分移動します.  16文字は通常の画面で約1/5行に相当す
るので, カーソルを『速く』移動させたい場合に便利な方法です.  便利な他
の組み合せは, `C-u C-n'や`C-u C-u C-n'（画面の下方への移動に便利）,
`C-u C-u C-o'（『数多く』の空行を作る）, `C-u C-k'（4行キルする）です.

コマンドによっては, 引数の値ではなく, 引数の有無だけを問題にします. 
たとえば, コマンド`M-q'（`fill-paragraph'）に引数を指定しないとテキス
トの詰め込みのみを行います.  引数を指定すると, さらに幅揃えも行います. 
（`M-q'に関する詳細は, *Note Filling::. ）`C-u'だけを使えば, このよう
なコマンドに簡単に引数を指定できます.

引数の値を反復回数として使うにも関わらず, 引数がないと特別な動作をする
コマンドもあります.  たとえば, `C-k'（`kill-line'）に引数Nを指定すると, 
行区切りの改行も含めてN行をキルします.  これに対し, 引数を指定しない場
合は特別な動作となります.  つまり, つぎの改行文字までのテキストをキル
するか, 行末にポイントがある場合は改行そのものをキルします.  したがっ
て, 引数を指定せずに`C-k'を2回実行すると, 引数1を指定した`C-k'と同様に, 
空行でない1行をキルします.  （`C-k'の詳細については, *Note
Killing::. ）

いくつかのコマンドは, `C-u'だけの引数を通常の引数とは異なるものとして
扱います.  また, マイナス記号のみの引数を-1と区別するコマンドもありま
す.  これらの例外については, 必要になったときに説明します.  これらの例
外は, それぞれのコマンドを使いやすくするためにあります.

数引数を使って, 文字のコピーを複数個挿入することもできます.  この操作
は, 数字以外の文字ならば簡単です.  たとえば, `C-u 6 4 a'で, 文字`a'を
64個挿入できます.  しかし, 数字では機能しません.  `C-u 6 4 1'は, 引数
が641であることを意味し, 何も挿入しません.  引数と挿入したい数字を区切
るには, もう1つ`C-u'を打ちます.  たとえば, `C-u 6 4 C-u 1'で, 数字`1'
を64個挿入できます.

コマンドのまえに引数を打つということを強調するために, また, コマンドの
あとのミニバッファ引数と区別するために, 『数引数』と同様に用語『前置引
数』を使います.



File: emacs-ja, Node: Repeating, Next: Minibuffer, Prev: Arguments, Up: Basic

コマンドを繰り返す
==================

コマンド`C-x z'（`repeat'）は, Emacsコマンドを何回も反復する別の方法で
す.  このコマンドは, 直前のEmacsコマンドが何であっても, それを繰り返し
ます.  繰り返されるコマンドは, まえと同じ引数を使います.  毎回, 新たに
引数を読むことはしません.

コマンドを2回以上繰り返すには, `z'を追加して打ちます.  1つの`z'で, コ
マンドを1回繰り返します.  `z'以外の文字を打つか, マウスボタンを押すと, 
繰り返しを終了します.

たとえば, 20文字削除するために`C-u 2 0 C-d'と打ったとしましょう.  `C-x
z z z'と打てば, （引数を含めて）削除コマンドをさらに3回繰り返し, 全部
で80文字削除できます.  始めの`C-x z'でコマンドを1回繰り返し, そのあと
のそれぞれの`z'で1回ずつ繰り返します.



File: emacs-ja, Node: Minibuffer, Next: M-x, Prev: Basic, Up: Top

ミニバッファ
************

"ミニバッファ"は, 単純な数よりも複雑な引数をEmacsコマンドが読み取るた
めに用いる機構です.  ミニバッファ引数は, ファイル名, バッファ名, Lisp
関数名, Emacsコマンド名, Lisp式など, 引数を読み取るコマンドに応じて多
種多様です.  ミニバッファでは, 通常のバッファと同様の編集機能を用いて
引数のテキストを編集できます.

ミニバッファが使われているときには, ミニバッファはエコー領域に表示され
て, 端末のカーソルもエコー領域に移動します.  ミニバッファの行の先頭に
は"プロンプト"（prompt）が表示されます.  プロンプトにより, 何を入力し
それがどのように使われるかを知ることができます.  プロンプトは, 引数を
要求しているコマンドの名前から導かれることが多いです.  プロンプトは通
常コロンで終ります.

コロンのあとの括弧の中に"デフォルト引数"（default argument）が表示され
ることもあります.  これもプロンプトの一部です.  （たとえば, RETだけを
打って）空の引数を入力したときには, デフォルトが引数として使われます. 
たとえば, バッファ名を読み取るコマンドは, つねに, デフォルトを表示しま
すが, それはRETだけを打ったときに使われるバッファ名です.

ミニバッファ引数を入力するもっとも簡単な方法は, 目的のテキストを入力し
てから, ミニバッファから抜けるRETで終えることです.  `C-g'を打てば, 引
数を必要とするコマンドを取り消して, ミニバッファを抜けることができます.

ミニバッファは画面のエコー領域を使うため, 習慣的にエコー領域を使用する
Emacsの機能と衝突する可能性があります.  Emacsは, そのような衝突を以下
のように扱います.

   * ミニバッファを使用中にコマンドがエラーを起こしても, ミニバッファ
     を取り消すことはない.  しかしながら, エラーメッセージを表示するた
     めにエコー領域が必要なので, しばらくのあいだミニバッファを隠す. 
     数秒経過するか, 何かを打つと, ただちにミニバッファを表示する.

   * `C-x ='のように, エコー領域にメッセージを表示するコマンドをミニバッ
     ファで実行すると, メッセージは通常どおり表示して, しばらくのあい
     だミニバッファを隠す.  数秒経過するか, 何かを打つと, ただちにミニ
     バッファを表示する.

   * ミニバッファを使用中は, キー入力をエコーしない.

* Menu:

* File: Minibuffer File.  Entering file names with the minibuffer.
* Edit: Minibuffer Edit.  How to edit in the minibuffer.
* Completion::		  An abbreviation facility for minibuffer input.
* Minibuffer History::    Reusing recent minibuffer arguments.
* Repetition::		  Re-executing commands that used the minibuffer.



File: emacs-ja, Node: Minibuffer File, Next: Minibuffer Edit, Prev: Minibuffer, Up: Minibuffer

ファイル名入力用のミニバッファ
==============================

最初からテキストを伴って始まるミニバッファもあります.  たとえば, ファ
イル名を指定しなければならない場合, ミニバッファはスラッシュで終る"デ
フォルトディレクトリ" （default directory）を含んでいます.  これにより, 
ディレクトリを指定しなくても, どのディレクトリからファイルを探すかわか
ります.

たとえば, ミニバッファがつぎのような内容で始まったとしましょう.

     Find File: /u2/emacs/src/

ここで, `Find File: 'がプロンプトです.  `buffer.c'と打てば, ファイル
`/u2/emacs/src/buffer.c'を指定したことになります.  付近のディレクトリ
のファイルを指定するには, `..'を使います.  したがって,
`../lisp/simple.el'と打てば, `/u2/emacs/lisp/simple.el'という名前のファ
イルになります.  あるいは, 不要なディレクトリ名であれば, `M-DEL'でキル
できます（*Note Words::）.

デフォルトディレクトリをまったく使いたくない場合は, `C-a C-k'と打って
キルできます.  しかし, デフォルトをキルする必要はありません.  単に無視
すればよいのです.  スラッシュやティルダで始まる絶対ファイル名を挿入し
ます.  たとえば, ファイル`/etc/termcap'を指定するには, そのファイル名
を挿入して, ミニバッファがつぎの内容になるようにします.

     Find File: /u2/emacs/src//etc/termcap

GNU Emacsでは, （普通は意味のある書き方ではない）連続した2個のスラッシュ
に特別な意味を与えています.  『2番目のスラッシュよりまえの文字はすべて
無視する』という意味になります.  したがって, 先の例では,
`/u2/emacs/src/'は無視され, `/etc/termcap'というファイル名になります.

`insert-default-directory'に`nil'を設定すると, ミニバッファにはデフォ
ルトディレクトリを挿入しません.  つまり, ミニバッファは空で始まります. 
しかし, 入力したファイル名が相対的なものであれば, 同じデフォルトディレ
クトリ相対に解釈されます.



File: emacs-ja, Node: Minibuffer Edit, Next: Completion, Prev: Minibuffer File, Up: Minibuffer

ミニバッファでの編集
====================

ミニバッファは（少々特殊だが）普通のEmacsバッファなので, 通常のEmacsコ
マンドを使って, 入力中の引数のテキストを編集できます.

ミニバッファでは, RETはミニバッファから抜けるように定義されているので, 
ミニバッファで改行を挿入するためにRETを使うことはできません.  改行を挿
入するには, `C-o'や`C-q C-j'とします.  （改行とは実は文字「コントロー
ルJ」. ）

ミニバッファには独自のウィンドウがあり, そのウィンドウは画面上の場所を
占有しています.  しかし, ミニバッファが使われていないときには, あたか
も何もないかのようにふるまいます.  ミニバッファが使われているときは, 
そのウィンドウは他のウィンドウと同様になります.  ミニバッファで引数を
入力し終えるまでは, `C-x o'で他のウィンドウに切り替えて, そこでテキス
トを編集したり他のファイルを訪問したりもできます.  他のウィンドウでテ
キストをキルしてから, ミニバッファウィンドウに戻ってそのテキストをヤン
クして引数として使うこともできます.  *Note Windows::.

しかし, ミニバッファウィンドウの使用にはいくつかの制限があります.  ミ
ニバッファウィンドウではバッファを切り替えられません.  ミニバッファと
そのウィンドウは恒久的に結び付いています.  また, ミニバッファウィンド
ウを分割したり消去したりすることもできません.  しかし, `C-x ^'を使う通
常の方法で, ウィンドウの高さを大きくすることは可能です.  ミニバッファ
リサイズ（resize-minibuffer）モードをオンにしておくと, ミニバッファに
入力したテキストを表示するのに必要なだけ, ミニバッファウィンドウは縦に
広がります.  `M-x resize-minibuffer-mode'を使って, このマイナモードを
オン／オフします（*Note Minor Modes::）.

ミニバッファウィンドウではスクロールは特殊な動きをします.  ミニバッファ
がちょうど1行分の高さで, 画面に収まらないほど長い1行のテキストが入って
いるときには, スクロールするときに継続行のあいだでは何文字かを自動的に
重複して表示します.  変数`minibuffer-scroll-overlap'で, 重複させる文字
数を指定します.  デフォルトは20です.

ミニバッファの中で別のウィンドウにある種のヘルプテキストを表示するよう
なコマンドを実行したときには, `C-M-v'を使ってミニバッファの中からヘル
プテキストをスクロールできます.  これは, ミニバッファを抜けるまで有効
です.  この機能は, 補完をしているミニバッファが, 補完候補を別のウィン
ドウに表示するような場合に特に便利です.  *Note Other Window::.

Emacsでは, 通常, ミニバッファを使っている最中には, ミニバッファを用い
るコマンドの多くを実行できないようにしています.  これは, 再帰的なミニ
バッファの使用で初心者が混乱するのを避けるためです.  このようなコマン
ドをミニバッファから利用できるようにするには, 変数
`enable-recursive-minibuffers'に`nil'以外を設定します.



File: emacs-ja, Node: Completion, Next: Minibuffer History, Prev: Minibuffer Edit, Up: Minibuffer

補完
====

ある種の引数では, 引数の値の入力に"補完"（completion）を利用できます. 
補完とは, 引数の一部分を打つと, Emacsがその残りの部分をすべて, あるい
は既存の入力部分から決定可能な限り残りの部分を補う機能です.

補完を使えるときには, TAB, RET, SPCの各キーは, ミニバッファ内の既存の
テキストをそれを含むより長い文字列に補完するように再定義してあります. 
補完は, 引数を読み取るコマンドが用意した"補完候補"群（completion
alternatives）に対して入力されたテキストとの一致をとることで行われます.
`?'キーは, 入力から補完可能な候補一覧を表示するように定義してあります.

たとえば, `M-x'がコマンド名を読み取るためにミニバッファを使っている場
合, `M-x'は, 補完に備えて, 使用可能なすべてのEmacsコマンド名の一覧を用
意します.  補完キーは, ミニバッファ内のテキストをすべてのコマンド名に
照らし合わせて, ミニバッファの既存の名前から導かれる名前の追加文字列を
探し出して, その文字列をそれまでに入力してあるテキストに付け加えます. 
これにより, `M-x insert-buffer RET'と打つかわりに, `M-x ins SPC b RET'
と打つことが可能になるのです.

補完では, 大文字小文字を区別します.  というのは, 補完対象となる名前
（バッファ名, ファイル名, コマンド名）のほとんどでは, 大文字小文字を区
別しているからです.  したがって, `fo'を, `Foo'とは補完しません.  大文
字小文字を区別しない引数に対しては, 補完も両者を区別しません.

* Menu:

* Example: Completion Example.
* Commands: Completion Commands.
* Strict Completion::
* Options: Completion Options.



File: emacs-ja, Node: Completion Example, Next: Completion Commands, Prev: Completion, Up: Completion

補完の例
--------

具体的な例で考えてみましょう.  `M-x au TAB'と打つと, TABは`au'で始まる
候補（この場合はコマンド名）を探します.  `au'で始まるものには,
`auto-fill-mode'と`auto-save-mode'を含めていくつかありますが, どれも少
なくとも`auto-'までは同じです.  そこで, ミニバッファ内の`au'は`auto-'
に変わります.

ここでただちにTABをもう一度打っても, つぎにくる文字の候補が複数, つま
り, `cfilrs'のどれかなので, さらに文字が追加されることはありません. 
そのかわり, TABは補完候補の一覧を別のウィンドウに表示します.

続けて`f TAB'と打つと, 今度のTABは文字列`auto-f'を探します.  `auto-f'
から始まるコマンド名は`auto-fill-mode'だけなので, 補完は残りの部分を補
います.  これで, `au TAB f TAB'と打つだけで, ミニバッファには
`auto-fill-mode'が入ります.  TABキーがこのような効果を持つのは, このキー
がミニバッファ内ではコマンド`minibuffer-complete'にバインドしてあるか
らだということに注意してください.



File: emacs-ja, Node: Completion Commands, Next: Strict Completion, Prev: Completion Example, Up: Completion

補完コマンド
------------

補完を使えるミニバッファでは, つぎのような補完コマンドを定義してありま
す.

`TAB'
     ミニバッファのテキストを可能な限り補完する（`minibuffer-complete'）.
`SPC'
     ミニバッファのテキストを1語だけ補完する
     （`minibuffer-complete-word'）.
`RET'
     可能な限り補完したあと, ミニバッファのテキストを引数として渡す
     （`minibuffer-complete-and-exit'）.
`?'
     ミニバッファのテキストから補完可能な候補の一覧を表示する
     （`minibuffer-list-completions'）.

SPCはTABとほぼ同じように補完しますが, つぎのハイフンや空白を超えて補完
することはありません.  ミニバッファの文字が`auto-f'であるとしましょう. 
ここでSPCを打つと, SPCは`auto-fill-mode'に補完できることを探しだします
が, `fill-'までで補完を止めます.  その結果, `auto-fill-'となります. 
ここでもう一度SPCを打つと, 今度は`auto-fill-mode'まで完全に補完します. 
補完を行えるミニバッファ内では, SPCはコマンド
`minibuffer-complete-word'を実行します.

補完候補一覧を表示しているウィンドウから補完を選ぶには, つぎのコマンド
を使えます.

`Mouse-2'
     補完候補一覧の候補上でマウスボタン2をクリックすると, その補完を選
     択する（`mouse-choose-completion'）.  通常は, ポイントがミニバッ
     ファ内にあるときにこのコマンドを使うだろうが, ミニバッファではな
     く候補一覧でクリックする必要がある.

`PRIOR'
`M-v'
     ミニバッファで, PRIOR, PAGE-UP, `M-v'のいずれかを打つと, 補完候補
     一覧のバッファを表示しているウィンドウを選択できる
     （`switch-to-completions'）.  この機能は, 以下のコマンドの利用を
     簡単にする.  （通常の方法でもそのウィンドウを選択できるが, この方
     法のほうが便利であろう. ）

`RET'
     *補完候補一覧のバッファで*RETを打つと, ポイント位置にある補完かポ
     イントに続く補完を選択する（`choose-completion'）.  このコマンド
     を使う場合, 補完候補一覧を表示しているウィンドウにまず移動する必
     要がある.

`RIGHT'
     *補完候補一覧のバッファで*右向き矢印キーRIGHTを打つと, ポイントは
     つぎの補完候補に移動する（`next-completion'）.

`LEFT'
     *補完候補一覧のバッファで*左向き矢印キーLEFTを打つと, ポイントは
     まえの補完候補に移動する（`previous-completion'）.



File: emacs-ja, Node: Strict Completion, Next: Completion Options, Prev: Completion Commands, Up: Completion

強い補完
--------

ミニバッファでの補完において, RETは引数の使われ方に依存して3種類の異な
る動作を示します.

   * "強い"補完（strict completion）は, 既知の補完候補以外を引数に与え
     ると意味がない場合に使われる.  たとえば, `C-x k'が削除するバッファ
     名を読み取るとき, 既存のバッファ名以外を与えても意味がない.  強い
     補完では, ミニバッファのテキストを補完して候補の1つに完全に一致し
     ないとRETで終了できない.

   * "慎重な"補完（cautious completion）は, 強い補完に似ているが, テキ
     ストがすでに完全に一致していて補完の必要がない場合にのみ, RETで終
     了できる点が異なる.  テキストが完全に一致していない場合は, RETは
     終了せずにテキストを補完する.  完全に一致すれば, 2度目のRETで終了
     できる.

     慎重な補完は, 既存でなければならないファイルの名前を読み取るよう
     な場合に使われる.

   * "弱い"補完（permissive completion）は, どんな文字列でも意味を持つ
     ような場合に使われ, 補完候補一覧は単なる目安でしかない.  たとえば,
     `C-x C-f'が訪問するファイル名を読み取るとき, 新規作成ならばどんな
     ファイル名でも許される.  弱い補完では, RETはミニバッファのテキス
     トを補完することなく, そのまま受理する.

補完コマンドは, つぎにくる文字として複数の可能性がある場合, 補完可能な
全候補一覧をウィンドウに表示します.  また, `?'と打てば, このような一覧
を表示できます.  補完候補一覧が長いときには, `C-M-v'でスクロールできま
す（*Note Other Window::）.



File: emacs-ja, Node: Completion Options, Next: Minibuffer History, Prev: Strict Completion, Up: Completion

補完のオプション
----------------

ファイル名の補完を行う場面では, ある種のファイル名を通常無視します. 
変数`completion-ignored-extensions'は, 文字列のリストを保持します.  こ
れらの文字列の1つで終る名前のファイルは, 補完候補としては無視します. 
この変数の標準値には, `".o"', `".elc"', `".dvi"', `"~"'が含まれます. 
この効果は, たとえば, `foo'は, `foo.o'が存在したとしても, `foo.c'に補
完されます.  ただし, 補完候補の*すべて*が無視すべき文字列で終るもので
ある場合には, これらの候補を無視しません.  無視した拡張子を持つものが
補完候補一覧に入ることはありません.  一覧にはつねに補完可能な候補のす
べてを表示します.

通常, 補完コマンドは, つぎにくる文字を自動的に決定できない場合には, す
べての補完候補一覧を表示します.  変数`completion-auto-help'に`nil'が設
定されていると, 一覧を表示しません.  補完候補を表示するには, `?'を打つ
必要があります.

`complete'ライブラリは, 一度に複数の単語を補完できる, より強力な補完機
能を提供します.  たとえば, `p-b'と省略されたコマンド名を`print-buffer'
と補完できます.  というのは, 頭文字が`p'と`b'である2つの単語で始まるコ
マンドが他にはないからです.  このライブラリを使うには, 個人の
`~/.emacs'ファイルに`(load "complete")'を入れておきます（*Note Init
File::）.

補完示唆（icomplete）モードでは, それまでに入力したテキストから補完で
きるものを常時更新して表示します.  このマイナモードをオン／オフするコ
マンドは`M-x icomplete-mode'です.



File: emacs-ja, Node: Minibuffer History, Next: Repetition, Prev: Completion, Up: Minibuffer

ミニバッファ履歴
================

ミニバッファで入力した引数はすべて"ミニバッファ履歴リスト" 
（minibuffer history list）に保存され, あとで別の引数中で使うことがで
きます.  特別のコマンドで, 以前に使った引数のテキストをミニバッファに
入れます.  これらは, ミニバッファの古い内容を破棄するので, 過去の引数
の履歴の中を動き廻っていると考えることができます.

`UP'
`M-p'
     ミニバッファ履歴中の1つまえ（古い）の引数文字列に移動する
     （`previous-history-element'）.
`DOWN'
`M-n'
     ミニバッファ履歴中の1つつぎ（新しい）の引数文字列に移動する
     （`next-history-element'）.
`M-r REGEXP RET'
     ミニバッファ履歴中の引数文字列を古いほうへ遡ってREGEXPに一致する
     ものに移動する（`previous-matching-history-element'）.
`M-s REGEXP RET'
     ミニバッファ履歴中の引数文字列を新しいほうへ辿ってREGEXPに一致す
     るものに移動する（`next-matching-history-element'）.

履歴リストに保存されている引数を再利用するもっとも簡単な方法は, 履歴リ
ストの中を1つ1つ移動していくことです.  ミニバッファの中では, 1つまえ
（古い）のミニバッファの入力内容に『移動する』には`M-p'
（`previous-history-element'）を, 1つあと（新しい）の入力内容に移動す
るには`M-n'（`next-history-element'）を打ちます.

ミニバッファの内容は, 履歴から持ってきた以前の入力内容で完全に置き換え
られます.  この内容を引数として使うには, 通常と同じようにRETでミニバッ
ファを抜けます.  引数として再使用するまえに, テキストを編集してもかま
いません.  編集してもミニバッファに『持ってきた』履歴のもともとの要素
は変更されません.  ただし, 当然, 新しい引数は履歴リストの最後に追加さ
れます.

多くのミニバッファ引数には, デフォルト値があります.  ミニバッファ履歴
操作コマンドが, これらのデフォルト値を知っている場合もあります.  その
場合, `M-n'で履歴中の『未来』へ移動する (1) (*Note Minibuffer
History-Footnotes::) ことで, このデフォルト値をテキストとしてミニバッ
ファに挿入できます.  将来的には, ミニバッファにデフォルト値がある場合
には, つねにこの機能を利用できるようにしたいと考えています.

履歴の中を前向きや後向きに探索するコマンドもあります.  これらのコマン
ドは, ミニバッファで指定した正規表現に一致する履歴要素を探索します.
`M-r'（`previous-matching-history-element'）は, 履歴のより古い要素を探
します.  一方, `M-s'（`next-matching-history-element'）は, より新しい
要素を探します.  特例なのですが, これらのコマンドは, コマンドを呼び出
す時点ですでにミニバッファに入っているにも関わらず, ミニバッファから引
数を読み取ります.  インクリメンタルサーチの場合と同様に, 正規表現に大
文字を使うと, 大文字小文字を区別して探索します（*Note Search Case::）.


ミニバッファを使えば入力は必ず履歴リストに記録されますが, 引数の種類ご
とに別々の履歴リストがあります.  たとえば, ファイル名に関する履歴リス
トは, ファイル名を読み取るすべてのコマンドで使われます.  （特別な機能
として, この履歴リストには, 絶対ファイル名を入力しなくても絶対ファイル
名が記録される. ）

特定目的用の履歴リストがいくつかあります.  `M-x'が読むコマンド名用, バッ
ファ名用, `query-replace'のようなコマンドの引数用, `compile'が読むコン
パイルコマンド用などです.  さらに, ほとんどのミニバッファ引数が利用す
る『その他』の履歴リストも1つあります.

変数`history-length'は, ミニバッファ履歴リストの最大長を指定します. 
履歴リストが設定された長さに達すると, そのあとは, 新しい要素を追加する
たびに最古の要素を削除します.  ただし, 変数`history-length'の値が`t'で
あると, 長さの制限はなくなり要素を削除しません.


File: emacs-ja  Node: Minibuffer History-Footnotes, Up: Minibuffer History

(1) 【訳注】履歴として残っている文字列データの最後尾よりさらに先に移動
すること.



File: emacs-ja, Node: Repetition, Next: M-x, Prev: Minibuffer History, Up: Minibuffer

ミニバッファコマンドの繰り返し
==============================

ミニバッファを少なくとも1回使ったコマンドは, その引数の値とともにすべ
て特別な履歴リストに記録されますから, コマンド全体を繰り返すことができ
ます.  特に, `M-x'はコマンド名を読み取るためにミニバッファを使うので, 
必ず履歴に記録されます.

`C-x ESC ESC'
     最近のミニバッファコマンドを再実行する（`repeat-complex-command'）.
`M-x list-command-history'
     `C-x ESC ESC'で繰り返せるすべてのコマンドを新しいものから順に並べ
     たコマンド履歴全体を表示する.

`C-x ESC ESC'は, ミニバッファを利用した最近のコマンドを再度実行します. 
引数を指定しなければ, そのような最後のコマンドを繰り返します.  数引数
は, どのコマンドを繰り返すかを指定します.  1は最後のコマンドを指し, 大
きい数ほどより以前のコマンドを指します.

`C-x ESC ESC'は, 過去のコマンドをLisp式に変換し, その式のテキストで初
期化したミニバッファに入ります.  RETだけを打てば, コマンドは以前とまっ
たく同様に繰り返されます.  Lisp式を編集してコマンドを変更してもかまい
ません.  最終的な式が何であれ, その式を実行します.  繰り返したコマンド
は, 履歴リスト内に既存の最後に実行したコマンドと同一でない限り, コマン
ド履歴の先頭に追加されます.

Lisp構文が理解できないとしても, 繰り返しのためにどのコマンドが表示され
たか, たぶんわかるでしょう.  テキストを変更しなければ, 以前とまったく
同じに繰り返されます.

`C-x ESC ESC'でいったんミニバッファに入ってしまえば, ミニバッファ履歴
リストコマンド（`M-p', `M-n', `M-r', `M-s', *Note Minibuffer History::）
を使って, 保存されたすべてのコマンドの履歴リストの中を動き廻れます. 
目的のコマンドを捜しあてたら, 通常の方法でその式を編集できますし, これ
も通常と同じようにRETを打てば実行できます.

ミニバッファを使った過去のコマンド一覧は, Lispのリストとして変数
`command-history'に格納されます.  各要素はそれぞれ1つのコマンドとその
引数を表すLisp式です.  Lispプログラムからは, `command-history'の要素を
引数として`eval'を呼べばコマンドを再実行できます.


File: emacs-ja, Node: M-x, Next: Help, Prev: Minibuffer, Up: Top

名前でコマンドを実行する方法
****************************

使用頻度の高いコマンドや素早い打鍵が必要なEmacsコマンドは, 使い勝手を
よくするために, キー（文字の短い列）にバインドしてあります.  短縮する
必要のないその他のEmacsコマンドはキーにバインドしてありません.  これら
のコマンドを実行するには, コマンド名を使う必要があります.

慣習として, コマンド名は1単語かハイフンで区切った2語以上の単語です. 
たとえば, `auto-fill-mode'や`manual-entry'です.  たとえ打鍵文字数が多
くなったとしても, （意図が）不明瞭な文字数個をキーとして使うよりも, 英
単語をコマンド名として使うほうが覚えやすいのです.

コマンドをその名前で実行するには, `M-x'で始めて, コマンド名を打ち込み,
RETで終えます.  `M-x'は, コマンド名を読むためにミニバッファを使います.
RETキーはミニバッファを抜けてコマンドを実行します.  このとき, "プロン
プト"として文字列`M-x'をミニバッファの先頭に表示して, 実行するコマンド
名を入力しなければならないことをユーザーに示します.  ミニバッファの詳
細については, *Note Minibuffer::.

コマンド名の入力には, 補完を使えます.  たとえば, つぎのように打って, 
コマンド`forward-char'を起動できます.

     M-x forward-char RET

あるいは,

     M-x forw TAB c RET

とします.  ここで, `forward-char'は, `C-f'キーで起動されるコマンドと同
じです.  コマンドがキーにバインドしてあるかどうかに関わらず, `M-x'です
べてのEmacsコマンドを名前で起動できます.

コマンド名を入力中に`C-g'を打つと, `M-x'コマンドを取り消してミニバッファ
から抜け出し, 最終的にはトップレベルに戻ります.

`M-x'で起動するコマンドに数引数を渡すには, `M-x'を打つまえに, 数引数を
指定します.  `M-x'は, 実行する関数に引数を渡します.  引数の値は, コマ
ンド名を読み込んでいるあいだ, プロンプトに表示されます.

入力したコマンドに専用のキーバインドがある場合には, Emacsはその旨エコー
領域に表示します.  この表示は, コマンドの実行が終了したあと, 2秒間表示
されます（すぐに何かを打てば, この限りではない）.  たとえば, コマンド
`M-x forward-word'を入力した場合, `M-f'と打ったほうが簡単に同じコマン
ドを実行できるという意味のメッセージが表示されます.
`suggest-key-bindings'に`nil'を設定すれば, これらのメッセージ表示をオ
フにできます.

本書では, 名前で実行するコマンドの説明において, 名前を終えるために必要
なRETを省略します.  つまり, `M-x auto-fill-mode RET'ではなく, `M-x
auto-fill-mode'とします.  コマンド名に続く引数も示す場合のように, RET
が必要なことを強調する場合にのみ, RETを書きます.

`M-x'は, `execute-extended-command'を実行することで動作します.
`execute-extended-command'は, 他のコマンドの名前を読み取って, それを実
行する役割を担うコマンドです.


File: emacs-ja, Node: Help, Next: Mark, Prev: M-x, Up: Top

ヘルプ機能
**********

Emacsには, `C-h'のたった1文字で呼び出せる高度なヘルプ機能があります.
`C-h'は, 説明文表示コマンドのためだけに使われるプレフィックスキーです.
`C-h'のあとに打つ文字（列）を"ヘルプオプション"（help options）と呼び
ます.  `C-h'もヘルプオプションの1つであって, `C-h'の使い方を調べること
ができます.  途中で取り消すには, `C-g'を打ちます.  ファンクションキー
F1は, `C-h'と等価です.

`C-h C-h'（`help-for-help'）は, 利用可能なヘルプオプションの一覧を簡素
な説明とともに表示します.  ヘルプオプションを打つまでは, SPCやDELで一
覧をスクロールできます.

`C-h'やF1は, 他のさまざまな状況でも『ヘルプ』を意味します.  たとえば,
`query-replace'の実行中には, 今一致している文字列に対して適用可能な操
作を説明します.  プレフィックスキーに続けて`C-h'やF1を打つと, そのプレ
フィックスキーに続けることができるキーの一覧を表示します.  （`C-h'に独
自の意味を定義しているプレフィックスキーもあり, そのような場合には
`C-h'を使えない.  しかし, F1はすべてのプレフィックスキーで使える. ）

ほとんどのヘルプバッファでは, 特別なメジャーモードであるヘルプ（help）
モードを使います.  ヘルプ（help）モードでは, SPCとDELで画面を簡単にス
クロールできます.

* Menu:

* Help Summary::	Brief list of all Help commands.
* Key Help::		Asking what a key does in Emacs.
* Name Help::		Asking about a command, variable or function name.
* Apropos::		Asking what pertains to a given topic.
* Library Keywords::	Finding Lisp libraries by keywords (topics).
* Language Help::       Help relating to international language support.
* Help Mode::           Special features of Help mode and Help buffers.
* Misc Help::		Other help commands.



File: emacs-ja, Node: Help Summary, Next: Key Help, Prev: Help, Up: Help

ヘルプのまとめ
==============

定義されているヘルプコマンドを以下にまとめておきます.

`C-h a REGEXP RET'
     正規表現REGEXPに一致する名前を持つコマンドの一覧を表示する
     （`apropos-command'）.
`C-h b'
     現在有効なすべてのキーバインドの一覧を, マイナモードのバインディ
     ング, メジャーモードのバインディング, グローバルバインディングの
     順に表示する（`describe-bindings'）.
`C-h c KEY'
     KEYが実行するコマンドの名前を表示する（`describe-key-briefly'）. 
     ここで, `c'は『character』（文字）のcのこと.  KEYのさらに詳しい情
     報を得るには, `C-h k'を使う.
`C-h f FUNCTION RET'
     Lisp関数FUNCTIONの説明文を表示する（`describe-function'）.  コマ
     ンドはLisp関数なので, コマンド名も使える.
`C-h h'
     さまざまな文字集合の例文を例示する`hello'ファイルを表示する.
`C-h i'
     ドキュメントファイルを閲覧するプログラム, infoを起動する（`info'）.
     infoでは, 完全なEmacsマニュアルをオンラインで見ることができる.
`C-h k KEY'
     KEYが実行するコマンドの名前と説明文を表示する（`describe-key'）.
`C-h l'
     これまでに打鍵した最後の100文字を表示する（`view-lossage'）.
`C-h m'
     現在のメジャーモードの説明文を表示する（`describe-mode'）.
`C-h n'
     Emacsの変更点に関する説明を最新のものから順に表示する
     （`view-emacs-news'）.
`C-h p'
     トピックのキーワードで, 一致するパッケージを探す
     （`finder-by-keyword'）.
`C-h s'
     現在の構文テーブルとその意味の説明を表示する（`describe-syntax'）.
     *Note Syntax::.
`C-h t'
     Emacsの対話型のチュートリアルに入る（`help-with-tutorial'）.
`C-h v VAR RET'
     Lisp変数VARの説明文を表示する（`describe-variable'）.
`C-h w COMMAND RET'
     コマンドCOMMANDを実行するキーを表示する（`where-is'）.
`C-h C CODING RET'
     コーディングシステムCODINGを説明する（`describe-coding-system'）.
`C-h C RET'
     現在使用中のコーディングシステムを説明する.
`C-h I METHOD RET'
     入力方式を説明する（`describe-input-method'）.
`C-h L LANGUAGE-ENV RET'
     言語環境LANGUAGE-ENVにおいて使われる, 文字集合, コーディングシス
     テム, 入力方式を説明する（`describe-language-environment'）.
`C-h C-c'
     GNU Emacsのコピーライトを表示する.
`C-h C-d'
     GNU Emacsの新版の入手方法に関する情報を表示する.
`C-h C-f FUNCTION RET'
     infoに入って, Emacsの関数FUNCTIONを説明しているノードに移動する
     （`Info-goto-emacs-command-node'）.
`C-h C-k KEY'
     infoに入って, キー列KEYを説明しているノードに移動する
     （`Info-goto-emacs-key-command-node'）.
`C-h C-p'
     GNUプロジェクトに関する情報を表示する.
`C-h TAB SYMBOL RET'
     編集中のプログラム言語に応じて, シンボルSYMBOLに関するinfoドキュ
     メントを表示する（`info-lookup-symbol'）.



