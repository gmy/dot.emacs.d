Info file: emacs-ja,    -*-Text-*-
produced by `texinfo-format-buffer'
from file `emacs.texi'
using `texinfmt.el' version 2.38 of 3 July 1998.


Emacs 20.6版対応に改訂した`GNU Emacs Manual' 13版です.

INFO-DIR-SECTION Editors
START-INFO-DIR-ENTRY
* Emacs: (emacs).	The extensible self-documenting text editor.
END-INFO-DIR-ENTRY


Published by the Free Software Foundation 59 Temple Place, Suite 330
Boston, MA 02111-1307 USA

Copyright (C) 1985, 1986, 1987, 1993, 1994, 1995, 1996, 1997, 1998,
1999 Free Software Foundation, Inc.

Permission is granted to make and distribute verbatim copies of this
manual provided the copyright notice and this permission notice are
preserved on all copies.

Permission is granted to copy and distribute modified versions of this
manual under the conditions for verbatim copying, provided also that
the sections entitled "The GNU Manifesto", "Distribution" and "GNU
General Public License" are included exactly as in the original, and
provided that the entire resulting derived work is distributed under
the terms of a permission notice identical to this one.

Permission is granted to copy and distribute translations of this
manual into another language, under the above conditions for modified
versions, except that the sections entitled "The GNU Manifesto",
"Distribution" and "GNU General Public License" may be included in a
translation approved by the Free Software Foundation instead of in the
original English.





File: emacs-ja, Node: Executing Lisp, Next: Lisp Libraries, Prev: Debuggers, Up: Building

Lisp式の実行
============

Emacsには, LispやSchemeのための異なったメジャーモードがいくつかありま
す.  これらは編集コマンドという意味では同じですが, Lisp式を実行するコ
マンドが異なります.  各モードには固有の目的があります.

emacs-lispモード
     このモードはEmacs Lispで実行するプログラムのソースファイル編集用. 
     このモードでは, 現在の関数定義を評価する`C-M-x'を定義する.  *Note
     Lisp Libraries::.
lisp対話モード（Lisp Interaction mode）
     このモードはEmacs Lispの対話セッション用.  ポイントの直前のS式を
     評価し, その値をバッファに挿入する`C-j'を定義する.  *Note Lisp
     Interaction::.
lispモード
     このモードはEmacs Lisp以外のLispで実行するプログラムのソースコー
     ド編集用.  このモードでは, 現在の関数定義を下位のLispプロセスに送
     る`C-M-x'を定義する.  *Note External Lisp::.
下位lispモード（Inferior Lisp mode）
     このモードは下位Lispプロセスとの対話セッション用.  このモードは,
     lispモードとシェル（shell）モード（*Note Shell Mode::）の特別な機
     能の組み合わせ.
schemeモード
     lispモードと同様だが, Schemeプログラム編集用.
下位Schemeモード（Inferior Scheme mode）
     このモードは下位のSchemeプロセスとの対話セッション用.

Lispプログラム用の編集コマンドの大部分は事実上どこでも使えます.  *Note
Programs::.



File: emacs-ja, Node: Lisp Libraries, Next: Lisp Interaction, Prev: Executing Lisp, Up: Building

Emacs用のLispコードのライブラリ
===============================

Emacs編集コマンドのLispコードは, 習慣的に`.el'で終る名前のファイルに格
納されています.  これらの拡張子は, emacs-lispモードで編集するように
Emacsに指示します（*Note Executing Lisp::）.

Emacs Lispコードのファイルを実行するには, `M-x load-file'を使います. 
このコマンドは, ミニバッファでファイル名を読み取り, そのファイルの内容
をLispコードとして実行します.  あらかじめファイルを訪問しておく必要は
ありません.  いずれにしても, このコマンドはディスク上のファイルを読む
のであって, Emacsバッファのテキストを読むのではありません.

LispコードのファイルをEmacs Lispライブラリのディレクトリに置いておけば, 
そのファイルは`M-x load-library'でロードできます.  プログラムからは,
`load-library'を呼んでロードするか, あるいは, より基本的な類似の関数で
余分な引数も指定できる`load'でロードします.

`M-x load-library'が`M-x load-file'と異なる点は, 一連のディレクトリに
ついて3つのファイル名を順に調べるということです.  引数がLIBだとすると,
3つのファイル名とは, `LIB.elc', `LIB.el', そして最後に`LIB'です.
`LIB.elc'というファイルが存在すれば, これは習慣として`LIB.el'をコンパ
イルしたものです.  コンパイル済みのファイルはロードと実行が速いので, 
こちらをロードするほうが有利です.

`load-library'が`LIB.elc'よりも新しい`LIB.el'をみつけると, 警告を出力
します.  というのは, `.el'ファイルを変更後に再コンパイルし忘れている可
能性があるからです.

`load-library'の引数は, 通常, それ自体では正しいファイル名でないことが
多いため, ファイル名の補完はできません.  もちろん, このコマンドを使う
とき, 指定すべき正確なファイル名を普通は知らないでしょうが.

`M-x load-library'が探索するディレクトリの順番は, 変数`load-path'で指
定します.  その値は, ディレクトリ名の文字列から成るリストです.  リスト
のデフォルト値には, Emacs自身のLispコードを収めたディレクトリが含まれ
ます.  個人用のLispライブラリがあるならば, それらを1つのディレクトリに
まとめ, そのディレクトリ名を`load-path'に追加してください.  リスト内の
`nil'はカレントデフォルトディレクトリを表しますが, リストに`nil'を加え
ることはあまり勧められません.  リストに`nil'が本当に必要だと感じたとき
には, それについては`M-x load-file'を実行するのではいけないだろうかと
考えてみてください.

ライブラリの中で定義されているコマンドに対しては, そのライブラリを"自
動的にロード"（autoload）するように設定されているので, ほとんどの場合, 
ライブラリをロードするコマンドを指定する必要はないでしょう.  ライブラ
リをロードするために`load'を呼び出すようなコマンドを1つ試してみてくだ
さい.  こうすると, 「自動的にロードする」という定義がライブラリ内の実
際の定義で置き換わります.

Emacs Lispコードはバイトコードにコンパイルできます.  コンパイルすると, 
ロードが速くなり, ロードしても必要な記憶容量が少なくなり, 実行も速くな
ります.  *Note バイトコンパイル: (elisp-ja)Byte Compilation.。習慣とし
て, ライブラリのコンパイル済みのコードは, ライブラリのソースファイル名
に`c'を付けた名前の別のファイルに入ります.  したがって, `foo.el'のコン
パイル済みのコードは, `foo.elc'に入ります.  これが, `load-library'はま
ず`.elc'というファイルを探す理由です.



File: emacs-ja, Node: Lisp Eval, Next: External Lisp, Prev: Lisp Interaction, Up: Building

Emacs Lisp式の評価
==================

Emacs内で動かすつもりのLispプログラムは, emacs-lispモードで編集しましょ
う.  ファイル名が`.el'で終っているファイルを編集すると, 自動的にこのモー
ドになります.  一方, lispモードは, 他のLispシステム向けのLispプログラ
ムを編集するためのモードです.  陽にemacs-lispモードに移るには, コマン
ド`M-x emacs-lisp-mode'を使います.

Emacs内で動くプログラムのテストには, Emacsバッファにあるプログラムの一
部を評価すると便利です.  たとえば, Lispの関数定義のテキストを変更して
からその定義を評価すると, それ以降にその関数を呼び出すと使われるように
インストールされます.  Lisp式を評価すると非対話的な（コマンドではない）
関数を起動できるので, どんな種類の編集作業にも便利です.

`M-:'
     ミニバッファで1つのLisp式を読み取り, それを評価し, その値をエコー
     領域に表示する（`eval-expression'）.
`C-x C-e'
     ポイントの直前のLisp式を評価し, その値をエコー領域に表示する
     （`eval-last-sexp'）.
`C-M-x'
     ポイントを含むか直後にある関数定義（defun）を評価し, その値をエコー
     領域に表示する（`eval-defun'）.
`M-x eval-region'
     リージョン内のすべてのLisp式を評価する.
`M-x eval-current-buffer'
     バッファ内のすべてのLisp式を評価する.

`M-:'（`eval-expression'）は, Lisp式を対話的に評価するもっとも基本的な
コマンドです.  これは, ミニバッファで式を1つ読み取りますから, バッファ
の内容に関係なくバッファ内でどんな式でも実行できます.  式が評価された
あとは, `M-:'を打鍵したときのカレントバッファが, ふたたびカレントバッ
ファになります.

emacs-lispモードでは, キー`C-M-x'はコマンド`eval-defun'にバインドされ
ています.  このコマンドはポイントを含むか直後にある関数定義をLisp式と
して解析し評価します.  その値はエコー領域に表示されます.  このコマンド
は, 関数定義のテキストの変更をLisp環境に反映するのに便利です.

`C-M-x'は`defvar'式を特別扱いします.  通常, 変数にすでに値が定義されて
いる場合には, `defvar'式を評価しても何もしません.  しかし, `C-M-x'は,
`defvar'式で指定されている初期値に変数の値を戻します.  この特別な機能
は, Lispプログラムをデバッグするときに便利です.

コマンド`C-x C-e'（`eval-last-sexp'）は, ポイントのまえにあるLisp式を
評価しその値をエコー領域に表示します.  このコマンドはemacs-lispモード
だけでなく, すべてのメジャーモードで使えます.  このコマンドは,
`defvar'を特別扱いしません.

`C-M-x', `C-x C-e', `M-:'に数引数を指定すると, 値をエコー領域に表示す
るかわりにカレントバッファのポイント位置に挿入します.  引数の値は関係
ありません.

バッファでLisp式を評価するもっとも一般的なコマンドは`eval-region'です.
`M-x eval-region'は, リージョン内の1つ以上のLisp式を解析して, それらを
1つずつ順に評価します.  `M-x eval-current-buffer'も同様ですが, バッファ
全体を評価します.  これは, テスト準備が整ったLispコードのファイルの内
容を取り込むうまい方法です.  個々の関数のバグを発見して修正したら, 変
更した関数それぞれに`C-M-x'を使います.  これによって, Lispの環境とソー
スファイルが一致します.



File: emacs-ja, Node: Lisp Interaction, Next: Lisp Eval, Prev: Lisp Libraries, Up: Building

lisp対話バッファ
================

Emacsが動き始めたときに選択されるバッファ`*scratch*'は, Emacs内でLisp
式を対話的に評価するためのものです.

`*scratch*'バッファを使うもっとも簡単な方法は, Lisp式を挿入してから各
式の末尾で`C-j'と打つことです.  このコマンドは, ポイントの直前のLisp式
を読み取り, それを評価し, その値を表示形式でポイントのまえに挿入します. 
この結果は, 評価した式とその値の完全なtypescript (1) (*Note Lisp
Interaction-Footnotes::)です.

`*scratch*'バッファのメジャーモードはlisp対話（lisp interaction）モー
ドであり, `C-j'のバインディングを除けばemacs-lispモードと同じです.

この機能が存在する理由を説明しましょう.  Emacsが実行を開始すると何かし
らバッファが必要です.  しかし, ファイルを訪問するたびに新たにバッファ
が作られるので, このバッファはファイルを編集するのには適しません.  最
初のバッファをLispインタープリタのtypescriptにするというのが作者が考え
ついたもっともよい方法でした.  `M-x lisp-interaction-mode'と打つと, カ
レントバッファはlisp対話（lisp interaction）モードになります.

Emacs Lisp式を対話的に評価する別の方法は, 下位emacs-lispモードを使うこ
とです.  このモードは, シェル（shell）モード（*Note Shell Mode::）に似
たインターフェイスでEmacs Lisp式を評価できます.  `M-x ielm'と打てば, 
下位emacs-lispモードを使う`*ielm*'バッファが作られます.


File: emacs-ja  Node: Lisp Interaction-Footnotes, Up: Lisp Interaction

(1) 【訳注】入力と出力をすべて記録した対話記録



File: emacs-ja, Node: External Lisp, Next: Abbrevs, Prev: Lisp Eval, Up: Building

外部Lispの実行
==============

Emacsには他のLispシステム上でプログラムを実行する機能があります.  Lisp
プロセスをEmacsの下位プロセスとして実行し, それに式を渡して評価させる
ことができます.  また, Lispプログラムを編集するEmacsバッファの中で変更
した関数定義をそのまま下位のLispプロセスに渡すこともできます.

下位のLispプロセスを実行するには, `M-x run-lisp'と打ちます.  このコマ
ンドは, シェルコマンドとして`lisp'と入力するのと同じ`lisp'という名前の
プログラムを実行し, プログラムの入出力は`*lisp*'という名前のEmacsバッ
ファを介してやりとりされます.  つまり, Lispからの『端末出力』はバッファ
に入りポイントを進め, Lispへの『端末入力』はバッファのテキストから取ら
れます.  （実行したいLisp実行ファイルの名前を変えるには, 変数
`inferior-lisp-program'を設定する. ）

Lispに入力を与えるには, バッファの末尾に移動してから入力を打鍵し, 最後
にRETを打ちます.  `*lisp*'バッファは下位lisp（inferior lisp）モードに
なっていて, シェル（shell）モード（*Note Shell Mode::）のほとんどの機
能にlispモードの特別な特性を組み合わせています.  サブプロセスに1行を送
るというRETの定義は, シェル（shell）モードの機能の1つです.

外部Lispで実行するプログラムのソースファイルにはlispモードを使います. 
このモードは`M-x lisp-mode'で選択できます.  また, ほとんどのLispシステ
ムで使われる`.l' (1) (*Note External Lisp-Footnotes::) や`.lsp'や
`.lisp'で終る名前のファイルにはこのモードが自動的に使われます.


実行中のLispプログラムの関数を編集しているとき, 変更した定義を下位の
Lispプロセスに送るもっとも簡単な方法はキー`C-M-x'です.  lispモードでは, 
このキーは関数`lisp-eval-defun'を実行します.  この関数は, ポイントの周
りや直後の関数定義を探し, それをLispプロセスの入力へ送ります.  （Emacs
はカレントバッファが何であるかに関わりなく, どんな下位プロセスにも入力
を送ることができる. ）

`C-M-x'コマンドの（任意のLispシステムで実行するプログラムの編集用）
lispモードでの意味と（Emacsで実行するLispプログラムの編集用）
emacs-lispモードでの意味を比較してみましょう.  どちらのモードでもポイ
ントを含む関数定義をインストールしますが, 関連するLisp環境がどこにある
かに応じて, その方法は異なります.  *Note Executing Lisp::.


File: emacs-ja  Node: External Lisp-Footnotes, Up: External Lisp

(1) 【訳注】この拡張子はlexやflexのソースファイルにも使われる.


File: emacs-ja, Node: Abbrevs, Next: Picture, Prev: Building, Up: Top

略語の利用法
************

定義済みの略語（abbrev）とは, 挿入時に別のテキストに展開される単語のこ
とです.  略語を定義するときに, それをどう展開するか指定します.  たとえ
ば, `foo'を略語として, `find outer otter'に展開すると定義したとします. 
すると, `f o o SPC'と打鍵すればバッファには`find outer otter ' (1)
(*Note Abbrevs-Footnotes::) が挿入されます.

略語の別な形に, "動的略語展開"（dynamic abbrev expansion）があります. 
動的略語展開とは, バッファ中のポイントのまえにある文字列をバッファ内に
あるその文字列で始まる既存の単語に展開することで, 陽にコマンドを実行し
て行います.  *Note Dynamic Abbrevs::.

* Menu:

* Abbrev Concepts::   Fundamentals of defined abbrevs.
* Defining Abbrevs::  Defining an abbrev, so it will expand when typed.
* Expanding Abbrevs:: Controlling expansion: prefixes, canceling expansion.
* Editing Abbrevs::   Viewing or editing the entire list of defined abbrevs.
* Saving Abbrevs::    Saving the entire list of abbrevs for another session.
* Dynamic Abbrevs::   Abbreviations for words already in the buffer.
* Dabbrev Customization:: What is a word, for dynamic abbrevs.  Case handling.


File: emacs-ja  Node: Abbrevs-Footnotes, Up: Abbrevs

(1) 【訳注】展開を引き起こしたSPCも挿入されることに注意.



File: emacs-ja, Node: Abbrev Concepts, Next: Defining Abbrevs, Prev: Abbrevs, Up: Abbrevs

略語の考え方
============

略語とは, あらかじめどう"展開"するか定義された単語のことです.  略語に
続けて, 空白, タブ, ピリオドなどの単語の区切り文字を入力すると, 略語は
展開されて展開形に置き換わります.  たとえば, 略語`foo'を展開形`find
outer otter'に展開するように定義しておけば, `f o o .'と打鍵すると`find
outer otter.'をバッファに挿入できます.

略語は, 略語（abbrev）モード（マイナモード）がオンのときにだけ展開され
ます.  略語（abbrev）モードをオフにしても定義した略語が消えてしまうわ
けではなく, つぎにオンにしたときに同じ定義をふたたび使えます.  コマン
ド`M-x abbrev-mode'でこのモードのオン／オフをトグル（切り替えが）でき
ます.  また, 数引数を指定した場合, 引数が正のときには略語（abbrev）モー
ドはオンになり, それ以外のときにはオフになります.  *Note Minor
Modes::.  `abbrev-mode'は変数でもあります.  この変数が`nil'以外のとき
には略語（abbrev）モードはオンです.  この変数に値を設定すると, 自動的
にカレントバッファにローカルな変数になります.

略語定義は"モードに固有"にできます.  つまり, あるメジャーモードのとき
にだけ働くように定義できます.  略語は"グローバル"にも定義でき, そのと
きはすべてのメジャーモードで使えます.  同じ略語に, グローバルな定義と, 
さまざまなメジャーモードに固有な定義とを持たせることができます.  ある
メジャーモードに固有な定義は, グローバルな定義に優先します.

略語は, 編集作業中に対話的に定義できます.  略語の定義一覧を, あとで使
うためにファイルに保存することもできます.  大量の略語定義をセッション
ごとにロードする人もいます.



File: emacs-ja, Node: Defining Abbrevs, Next: Expanding Abbrevs, Prev: Abbrev Concepts, Up: Abbrevs

略語の定義方法
==============

`C-x a g'
     ポイントのまえの単語を展開形として, 略語を定義する. 
     （`add-global-abbrev'）.
`C-x a l'
     上と同様.  ただし, 現在のメジャーモードに固有な略語を定義する. 
     （`add-mode-abbrev'）.
`C-x a i g'
     バッファ中の1単語を略語として定義する. 
     （`inverse-add-global-abbrev'）.
`C-x a i l'
     バッファ中の1単語をモードに固有な略語として定義する. 
     （`inverse-add-mode-abbrev'）.
`M-x kill-all-abbrevs'
     このコマンドは現在有効なすべての略語定義を抹消し空にする.

略語を定義する普通の方法は, まず, 略語に置き換わってほしい展開形のテキ
ストを入力し, つぎにその直後にポイントをもっていき, `C-x a g'
（`add-global-abbrev'）と打鍵します.  すると, ミニバッファを用いて略語
を読み取り, ポイントの直前の単語（群）に対する略語として登録します. 
展開形として用いる単語の個数は, 数引数で指定します.  たとえば, 略語
`foo'をまえのように定義するには, テキスト`find outer otter'を挿入し, 
続いて`C-u 3 C-x a g f o o RET'と打鍵します.

`C-x a g'に数引数として0を指定すると, 展開形はリージョンの内容になりま
す.

コマンド`C-x a l'（`add-mode-abbrev'）も同様ですが, 特定のモードに固有
な定義になります.  モードに固有な略語は, 特定のメジャーモードの中だけ
で有効です.  `C-x a l'は, `C-x a l'と打鍵したときのメジャーモードに対
する略語を定義します.  引数の意味は`C-x a g'と同じです.

すでにバッファ内にあるテキストを略語として使いたい場合には, `C-x a g'
のかわりにコマンド`C-x a i g' （`inverse-add-global-abbrev'）, あるい
は, `C-x a l'のかわりにコマンド`C-x a i l' （`inverse-add-mode-abbrev'）
を使います.  これらは『逆さ』（inverse）コマンドと呼ばれます.  という
のは, これらのコマンドで使う（バッファにあるものとミニバッファから読む
ものの）2つの文字列の用途が逆さだからです.

略語の定義を変更するには, 単に新たに定義してください.  略語がすでに定
義されていると, 略語定義コマンドは置き換えてよいかどうかを確認してきま
す.

略語の定義を削除するには, 略語定義コマンドに負の数引数を指定します.
`C-u - C-x a g'や`C-u - C-x a l'のようにします.  前者はグローバルな定
義を, 後者はモードに固有な定義を削除します.

`M-x kill-all-abbrevs' は, グローバルとローカルのすべての略語定義を削
除します.



File: emacs-ja, Node: Expanding Abbrevs, Next: Editing Abbrevs, Prev: Defining Abbrevs, Up: Abbrevs

略語展開の制御
==============

ポイントの直前に略語があるときに白文字や区切り文字（SPC, コンマなど）
を打鍵すると, 略語はつねに展開されます.  より正確には, 英単語の構成文
字以外のどんな文字でも略語展開は起こり, 英単語の構成文字の任意の組み合
わせを略語に使用できます.  略語の通常の使い方は, 略語を入力してから区
切り文字を入力して展開を行わせるという方法です.

略語展開では大文字小文字を保存します.  したがって, `foo'は`find outer
otter'に, `Foo'は`Find outer otter'に展開されます.  また, 変数
`abbrev-all-caps'に応じて, `FOO'は（変数の値が`nil'以外のときは）`FIND
OUTER OTTER', あるいは, `Find Outer Otter'に展開されます

以下は略語展開を制御するために使うコマンドです.

`M-''
     これまで入力した部分をこれから入力する略語から分離する.
`C-x a e'
     ポイントの直前の略語を展開する（`expand-abbrev'）.  このコマンド
     は略語（abbrev）モードがオンでなくても働く.
`M-x expand-region-abbrevs'
     リージョン中のいくつかの, あるいはすべての略語を展開する.

接頭辞が付いた略語を展開したい場合もあるでしょう.  略語`cnst'は
`construction'に展開されるとして, `reconstruction'と入力するためにこの
略語を使いたいとします.  `recnst'と打鍵してもだめです.  というのは,
`recnst'は定義済みの略語ではないからです.  ではどうすればよいかという
と, 接頭辞`re'と略語`cnst'のあいだでコマンド`M-'' 
（`abbrev-prefix-mark'）を使うのです.  まず`re'と打ち込みます.  続いて
`M-''と打鍵します.  するとバッファにハイフン（`-'）が挿入され, 切れ目
が入ったことを示します.  それから略語`cnst'を入力します.  バッファには
`re-cnst'と入っています.  ここで単語構成文字以外の文字を打ち込めば, 略
語`cnst'が`construction'に展開されます.  展開時には`M-''が挿入したハイ
フン（`-'）は削除されます.  結果は, 望みどおりの`reconstruction'です.

もし, 略語を展開しないでそのまま残しておきたい場合には, `C-q'に続けて
区切り文字を入れます.  つまり, `foo C-q ,'とすると, バッファには`foo,'
のまま残ります.

まちがって略語を展開してしまった場合には, `C-_'（*Note Undo::）と打鍵
すれば, 展開をアンドゥし略語に戻せます.  このとき略語展開を引き起こし
た区切り文字も削除されます.  略語を展開せずに区切り文字とともに入力し
たいならば, 区切り文字を`C-q'でクォートして挿入します.  区切り文字を削
除せずに直前に展開したものを略語に戻すには, コマンド`M-x
unexpand-abbrev'を使うこともできます.

`M-x expand-region-abbrevs' は, リージョン全体にわたって定義済みの略語
を探し, みつかったそれぞれについてそれを展開するかを聞いてきます.  こ
のコマンドは, 略語（abbrev）モードをオンにし忘れて略語を用いたテキスト
を入力してしまったときに便利です.  あるいは, 特別な略語定義一式を用い
て一度に全体を置き換えるときにも便利です.  このコマンドは略語（abbrev）
モードがオンでなくても使えます.

略語を展開するときには, フック`pre-abbrev-expand-hook' （*Note Hooks::）
が実行されます.



File: emacs-ja, Node: Editing Abbrevs, Next: Saving Abbrevs, Prev: Expanding Abbrevs, Up: Abbrevs

略語の表示と編集
================

`M-x list-abbrevs'
     すべての略語定義を表示する.
`M-x edit-abbrevs'
     略語の一覧を編集する.  定義を追加, 変更, 削除できる.

`M-x list-abbrevs'の出力はつぎのようになります.

     (lisp-mode-abbrev-table)
     "dk"	       0    "define-key"
     (global-abbrev-table)
     "dfn"	       0    "definition"

（空行には意味はない.  また, いくつかのモードの略語表は省略した. ）

括弧で括られた名前から成る行は, 特定モードの略語表のヘッダです.
`global-abbrev-table'には, グローバルな略語定義が入っています.  また, 
メジャーモード名からとったそれ以外の名前の略語表には, モードに固有な略
語が入っています.

各略語表では, 空でない各行が1つの略語を定義します.  行の先頭の単語は略
語です.  つぎに続く数字はこの略語を展開した回数です.  Emacsは, 略語が
実際にどれだけ使われているか数えていて, あまり使わない定義を削除できる
ようにしています.  行の最後の文字列が展開形です.

`M-x edit-abbrevs'により, Emacsバッファ内の略語一覧を編集することで略
語定義の追加, 変更, 削除を行えます.  一覧の形式は上で述べたものと同じ
です.  このバッファは`*Abbrevs*'と呼ばれ, 略語編集（edit-abbrevs）モー
ドになっています.  このバッファで`C-c C-c'と打鍵すると, バッファで指定
したように略語定義が登録され, バッファにない略語定義は削除されます.

コマンド`edit-abbrevs'は実際には`list-abbrevs'と同ですが, 前者はバッファ
`*Abbrevs*'を選択するのに対し, 後者はバッファを別のウィンドウに表示す
るだけです.



File: emacs-ja, Node: Saving Abbrevs, Next: Dynamic Abbrevs, Prev: Editing Abbrevs, Up: Abbrevs

略語の保存
==========

以下のコマンドは, 編集セッション間で略語定義を保存するためのものです.

`M-x write-abbrev-file RET FILE RET'
     ファイルFILEにすべての略語定義を書き出す.
`M-x read-abbrev-file RET FILE RET'
     ファイルFILEから略語定義を読み込み, その指定どおりに定義する.
`M-x quietly-read-abbrev-file RET FILE RET'
     上と同様だが, 処理経過を表示しない.
`M-x define-abbrevs'
     カレントバッファ内の定義で略語を定義する.
`M-x insert-abbrevs'
     すべての略語とその展開形をカレントバッファに挿入する.

`M-x write-abbrev-file'は, ミニバッファからファイル名を読み取り, その
ファイルにすべての略語定義情報を書き出します.  このコマンドは, 以後の
セッションで使うために略語定義を保存するために使います.  ファイルに保
存されるテキストは一連のLisp式であり, これらの式を実行すると, 現状と同
じ略語が定義されます.

`M-x read-abbrev-file'は, ミニバッファからファイル名を読み取り, そのファ
イルを読み込んでファイルの内容に従って略語を定義します.  `M-x
quietly-read-abbrev-file'も同じですが, 現在何が進行しているかをエコー
領域に表示しません.  このコマンドは, `.emacs'ファイルで使うことに主眼
があります.  どちらのコマンドも, 空の引数を指定すると変数
`abbrev-file-name'に指定したファイル名を使います.  この変数のデフォル
トは`"~/.abbrev_defs"'です.

Emacsは, 略語定義を変更してあると自動的に略語定義を保存するかどうか, 
（`C-x s'や`C-x C-c'などで）すべてのファイルを保存するかどうか問い合わ
せるときに同時に聞いてきます.  この機能は, 変数`save-abbrevs'の値を
`nil'にすると禁止できます.

コマンド`M-x insert-abbrevs'と`M-x define-abbrevs'は, 上で述べたコマン
ドと同様ですが, Emacsバッファ内のテキストに作用します.  `M-x
insert-abbrevs'は, カレントバッファのポイントの直前にすべての略語定義
を記述したテキストを挿入します.  `M-x define-abbrevs'は, カレントバッ
ファ全体を解析し, その内容に従って略語を定義します.



File: emacs-ja, Node: Dynamic Abbrevs, Next: Dabbrev Customization, Prev: Saving Abbrevs, Up: Abbrevs

動的略語展開
============

これまでに述べてきた略語の機能は, テキストを挿入するときに自動的に働き
ますが, すべての略語を陽に登録しておく必要があります.  一方, "動的略語
"（dynamic abbrevs）は, バッファの内容に基づいて略語の展開形を自動的に
決定することができます.  ただし, 陽に指示したときだけ, 動的略語展開を
行います.

`M-/'
     バッファのポイントの直前の単語を"動的略語"（dynamic abbrev）とし
     て, その略語で始まる単語をバッファ内から探索し展開する
     （`dabbrev-expand'）.

`C-M-/'
     ポイントの直前の単語を動的略語として補完する
     （`dabbrev-completion'）.

たとえば, バッファ内に`does this follow 'があるときに`f o M-/'と打鍵す
ると, バッファ内で`fo'で始まる近くにある単語が`follow'なので`follow'が
挿入されます.  `M-/'に数引数を指定すると, ポイントから先頭に向かって探
して, 2番目のもの, 3番目のものというように異なる展開形に展開できます.
`M-/'を繰り返すことにより, 次々にさらに先頭へ向かって探して別の候補に
展開します.  ポイントよりまえのすべてのテキストを探し終えた場合には, 
ポイントよりうしろのテキストを探します.  変数`dabbrev-limit'が`nil'以
外 (1) (*Note Dynamic Abbrevs-Footnotes::) ならば, バッファ内のどの範
囲まで展開候補を探すかを指定します.

カレントバッファを探し終ると, 変数`dabbrev-check-all-buffers'を`nil'に
設定していない限り, `M-/'は他のバッファも探します.

`C-u - M-/'のように`M-/'に負の数引数を指定すると, まずポイントのうしろ
から展開候補を探し, つぎにポイントのまえから展開候補を探します.  `M-/'
を繰り返して別の展開候補を探す場合には, 引数を指定しません.  これによ
り, ポイントよりうしろのすべての展開候補を試してから, つぎにポイントよ
りまえのすべての展開候補を試せます.

動的略語を展開したあとでは, 展開形のもともとの場所でつぎに続く単語（群）
をコピーすることができます.  コピーしたい単語ごとに単に`SPC M-/'と打鍵
します.  単語のあいだの空白や句読点も単語とともにコピーされます.

コマンド`C-M-/'（`dabbrev-completion'）は, 動的略語の補完を行います. 
展開候補を1つずつ試すかわりに, すべての候補を全部探してそれらに共通す
るテキストを挿入します.  それらに共通部分がなければ, `C-M-/'は候補一覧
を表示するので普通の方法でその中から1つ選びます.  *Note Completion::.

動的略語展開は略語（abbrev）モードと完全に独立しています.  `M-/'による
単語の展開は, 略語（abbrev）モードで定義済みかどうかとは完全に独立して
います.


File: emacs-ja  Node: Dynamic Abbrevs-Footnotes, Up: Dynamic Abbrevs

(1) 【訳注】文字数を指定する.



File: emacs-ja, Node: Dabbrev Customization, Next: Picture, Prev: Dynamic Abbrevs, Up: Abbrevs

動的略語のカスタマイズ方法
==========================

通常, 動的略語展開では大文字小文字を区別しないで候補を探します.  つま
り, 展開候補と略語の大文字小文字が一致する必要はありません.

この機能は変数`dabbrev-case-fold-search'で制御できます.  値が`t'のとき
は, 候補を探すときに大文字小文字を区別しません.  値が`nil'のときは, 候
補と略語の大文字小文字が一致する必要があります.  変数
`dabbrev-case-fold-search'の値は, デフォルトでは真である
`case-fold-search'です.  したがって, 変数`case-fold-search'が展開候補
を探すときの大文字小文字の区別を制御します.

通常, 動的略語展開は*打ち込んだ略語の*大文字小文字のパターンを保存しま
す.  つまり, 略語の大文字小文字のパターンに合うように展開形の大文字小
文字を変換します.

変数`dabbrev-case-replace'は, 略語の大文字小文字のパターンを保存するか
どうかを制御します.  値が`t'のときは, たいていの場合, パターンを保存し
ます.  `nil'のときは, つねに展開形をそのままコピーします.
`dabbrev-case-replace'の値は, デフォルトでは真である`case-replace'です. 
したがって, 変数`case-replace'が展開形をそのままコピーするかどうかを制
御します.

しかしながら, 展開形の大文字小文字のパターンが複雑であるとき, 略語の始
めから終りまでがそのパターンに一致する場合, これらの変数に関わらず展開
形をそのままコピーします.  たとえば, バッファに
`variableWithSillyCasePattern'とあって`v a M-/'と打鍵すると, 大文字小
文字のパターンを含め展開形をそのままコピーします.

変数`dabbrev-abbrev-char-regexp'が`nil'以外の場合, 動的展開においてど
んな文字を単語構成文字とみなすかを制御します.  これに指定する正規表現
は1文字のみに一致するものである必要があり, 2文字以上に一致してはいけま
せん.  同じ正規表現は, どの文字が展開形を構成するかも指定します.  値と
して`nil'を指定すると特別な意味があり, 略語は単語の構成文字だけから成
り, 展開形は単語と記号文字から成るという意味になります.

シェルスクリプトやmakefileなどでは, 変数名には接頭辞`$'があったりなかっ
たりします.  これらのテキスト用のメジャーモードでは, 変数
`dabbrev-abbrev-skip-leading-regexp'を設定して余分な接頭辞を扱えるよう
に動的展開をカスタマイズできます.  この変数には, 動的略語展開で無視す
べき余分な接頭辞に一致する正規表現を指定します.


File: emacs-ja, Node: Picture, Next: Sending Mail, Prev: Abbrevs, Up: Top

絵の編集
********

テキスト文字で書いた絵（たとえば, プログラムのコメントとしてレジスタを
フィールドに分割した絵）を編集するには, コマンド`M-x edit-picture'を使っ
てピクチャー（picture）モードに入ります.

ピクチャー（picture）モードでは, "1/4平面"モデル（quarter-plane）に基
づいて編集を行います.  つまり, 右側と下側に無限に続く領域にテキスト文
字が散在するのです.  このモデルでは行末は存在しません.  行中で空白でな
い文字が最後に現れる場所がわかるだけです.

もちろん, Emacsはつねにテキストを文字の列としてとらえ, 実際には行に終
りがあります.  しかし, ピクチャー（picture）モードでは, よく使われるコ
マンドの大部分を1/4平面モデルに従って動作するように置き換えています. 
空白を挿入したりタブを空白に置き換えることで, そのようにします.

Emacsの基本的な編集コマンドの大部分は, ピクチャー（picture）モードでは
1/4平面モデルにおいて本質的には同じ動作をするように再定義されています. 
さらに, ピクチャー（picture）モードでは, `C-c'で始まるキー列を絵の編集
用の特別なコマンドとして定義します.

これらのキーの1つである`C-c C-c'は非常に重要です.  絵が, 普通は別のメ
ジャーモードで編集される大きなファイルの一部であることがしばしばありま
す.  `M-x edit-picture'は直前のメジャーモードを記録しておき, あとで
`C-c C-c'コマンド（`picture-mode-exit'）でそのモードに戻れるようにしま
す.  また, 数引数を指定しなければ, `C-c C-c'は行末の空白を削除します.

ピクチャー（picture）モードのすべての特別なコマンドは, （`picture'ライ
ブラリがロードされていれば）他のモードでも使えますが, ピクチャー
（picture）モード以外ではキーにバインドされていません.  以下では『1桁』
移動などと説明しますが, ピクチャー（picture）モードのすべてのコマンド
は, それに対応する通常のコマンドと同じように数引数を扱えます.

ピクチャー（picture）モードに入るときにフック`picture-mode-hook'を実行
します（*Note Hooks::）.

* Menu:

* Basic Picture::         Basic concepts and simple commands of Picture Mode.
* Insert in Picture::     Controlling direction of cursor motion
                            after "self-inserting" characters.
* Tabs in Picture::       Various features for tab stops and indentation.
* Rectangles in Picture:: Clearing and superimposing rectangles.



File: emacs-ja, Node: Basic Picture, Next: Insert in Picture, Prev: Picture, Up: Picture

ピクチャーモードの基本編集
==========================


ピクチャー（picture）モードでも, ほとんどのキーは通常と同じ動作をしま
すが, 1/4平面流の動作です.  たとえば, `C-f'は,
`picture-forward-column'を実行するように再定義してあります.  このコマ
ンドはポイントを1桁右に動かし, 必要なら空白を挿入して, 行末がないかの
ようにふるまいます.  `C-b'は, `picture-backward-column'を実行するよう
に再定義してあります.  このコマンドはポイントを1桁左に動かし, 必要に応
じてタブを複数の空白に変換します.  `C-n'と`C-p'は, それぞれ
`picture-move-down'と`picture-move-up'を実行するように再定義してありま
す.  これらのコマンドは, 必要に応じて空白を挿入したりタブを変換して, 
ポイントが同じ桁位置に留まるように移動します.  `C-e'は
`picture-end-of-line'を実行します.  このコマンドは, 行の最後の白文字以
外の文字の直後に移動します.  画面モデルは行頭には影響しないので, `C-a'
を変更する必要はありません.

テキストの挿入は, 上書き（overwrite）モードを用いて1/4平面モデルに対応
させてあります（*Note Minor Modes::）.  自己挿入文字は, 既存のテキスト
を右側へ押しやるのではなく, 既存のテキストを桁ごとに置き換えます.  RET
は`picture-newline'を実行します.  このコマンドは, つぎの行の先頭に移動
し, その行が新たなテキストで置き換わるようにします.

ピクチャー（picture）モードでは, テキストの削除やキルのかわりに消去し
ます.  DEL（`picture-backward-clear-column'）は, 直前の文字を削除する
のではなく空白で置き換え, また, ポイントを1つまえに戻します.  `C-d'
（`picture-clear-column'）は直後の1つ以上の文字を空白で置き換えますが, 
ポイントは動かしません.  （文字を空白で置き換えて, かつ, ポイントを先
へ進めるには, SPCを使う. ）`C-k'（`picture-clear-line'）は行の内容を実
際にキルしますが, バッファから改行を削除しません.

実際に挿入を行うには, 特別なコマンドを使う必要があります.  `C-o'
（`picture-open-line'）は, 現在行のつぎに空行を作りますが, 行を分割し
ません.  `C-M-o'（`split-line'）はピクチャー（picture）モードでも意味
があるので変更してありません.  `C-j'（`picture-duplicate-line'）は現在
行の下に現在行と同じ内容の行を挿入します.

ピクチャー（picture）モードで実際に削除を行うには, `C-w'か（他のモード
での`C-d'と同じ`delete-char'に定義されている）`C-c C-d', あるいは, 絵
の矩形領域コマンドの1つを使います（*Note Rectangles in Picture::）.



File: emacs-ja, Node: Insert in Picture, Next: Tabs in Picture, Prev: Basic Picture, Up: Picture

挿入後のポイント移動制御
========================

ピクチャー（picture）モードでは『自己挿入』文字は上書きしてポイントを
動かしますから, ポイントをどのように動かすかについて本質的な制限はあり
ません.  通常ポイントは右に動きますが, 『自己挿入』文字のあとで上下左
右斜めの8方向のいずれの方向へ移動するか指定できます.  これは, バッファ
に直線を引くときに役立ちます.

`C-c <'
     挿入後, 左へ移動（`picture-movement-left'）.
`C-c >'
     挿入後, 右へ移動（`picture-movement-right'）.
`C-c ^'
     挿入後, 上へ移動（`picture-movement-up'）.
`C-c .'
     挿入後, 下へ移動（`picture-movement-down'）.
`C-c `'
     挿入後, 左上（『北西』）へ移動（`picture-movement-nw'）.
`C-c ''
     挿入後, 右上（『北東』）へ移動（`picture-movement-ne'）.
`C-c /'
     挿入後, 左下（『南西』）へ移動（`picture-movement-sw'）.
`C-c \'
     挿入後, 右下（『南東』）へ移動（`picture-movement-se'）.

2つの移動コマンドは, 現在指定されている挿入後の移動方向に基づいて動作
します.  コマンド`C-c C-f'（`picture-motion'）は, 現在指定されている
『挿入』後の移動方向と同じ方向へ移動しますが, `C-c C-b'
（`picture-motion-reverse'）は反対方向へ移動します.



File: emacs-ja, Node: Tabs in Picture, Next: Rectangles in Picture, Prev: Insert in Picture, Up: Picture

ピクチャーモードのタブ
======================

ピクチャー（picture）モードにはタブ相当の動作が2種類あります.  文脈に
基づくタブを行うには`M-TAB' （`picture-tab-search'）を使います.  引数
を指定しないと, 先行する空行でない行において白文字に続く『興味ある』つ
ぎの文字の下方に移動します.  ここで『つぎ』とは『開始位置より水平位置
が1より大きい』という意味です.  `C-u M-TAB'のように引数を指定すると, 
現在行において『興味ある』文字に移動します.  `M-TAB'はテキストを変更せ
ずにポイントを移動するだけです.  『興味ある』文字は, 変数
`picture-tab-chars'で定義されますが, 文字集合を定義する必要があります. 
この変数の構文は正規表現で使われる`[...]'の構文に似ていますが, `['と
`]'で囲みません.  この変数のデフォルト値は`"!-~"'です.

TABそれ自身は, `picture-tab'を実行します.  このコマンドは, 現在のタブ
ストップの設定に基づいて動作します.  これは他のモードの
`tab-to-tab-stop'に相当します.  通常これはポイントを動かすだけですが, 
数引数を指定すると移動先までのテキストをクリアします.

文脈に基づくタブとタブストップに基づくタブは, コマンド`C-c TAB'
（`picture-set-tab-stops'）で結び付けることができます.  このコマンドは, 
現在行において`M-TAB'が重要と考える位置にタブストップを設定します.
TABとともにこのコマンドを使えば, 文脈に基づくタブと同じ効果を得られま
す.  しかし, `M-TAB'で十分ならばそのほうが便利でしょう.

本当のタブ文字を絵に使わないように抑制したほうが便利な場合があります. 
たとえば, `C-x TAB'で絵をめちゃくちゃにしてしまうことを防止できます. 
タブ文字の使用を抑制するには, 変数`indent-tabs-mode'に`nil'を設定しま
す.  *Note Just Spaces::.



File: emacs-ja, Node: Rectangles in Picture, Next: Sending Mail, Prev: Tabs in Picture, Up: Picture

ピクチャーモードの矩形領域コマンド
==================================

ピクチャー（picture）モードでは, 1/4平面モデルに適合するように, テキス
トの矩形領域に作用するコマンドを定義します.  標準的な矩形領域コマンド
も役立つでしょう（*Note Rectangles::）.

`C-c C-k'
     矩形領域を空白でクリアする（`picture-clear-rectangle'）.  数引数
     を指定するとテキストを削除する.
`C-c C-w R'
     同様だが, まず矩形領域の内容をレジスタRに保存する
     （`picture-clear-rectangle-to-register'）.
`C-c C-y'
     ポイント位置を左上隅として最後にキルした矩形領域をバッファに上書
     きする（`picture-yank-rectangle'）.  数引数を指定すると挿入する.
`C-c C-x R'
     同様だが, レジスタRの矩形領域を使う
     （`picture-yank-rectangle-from-register'）.

絵の矩形領域コマンド, `C-c C-k'（`picture-clear-rectangle'）と`C-c
C-w'（`picture-clear-rectangle-to-register'）は, 標準の矩形領域コマン
ドが矩形領域を削除するのに対しクリアする点で異なります.  これは, ピク
チャー（picture）モードでの`C-d'の意味の変更方法に類似したものです.

しかし, ピクチャー（picture）モードでも矩形領域の削除は便利なので, 数
引数を与えるとこれらのコマンドは矩形領域を削除します.  引数を指定して
もしなくても`C-c C-k'は`C-c C-y'のために矩形領域を（レジスタに）保存し
ます.

ピクチャー（picture）モードのヤンクコマンドは標準のそれとは, 挿入のか
わりに上書きする点で異なります.  これはピクチャー（picture）モードでの
テキストの挿入が他のモードでのそれと異なっているのと同じです.  `C-c
C-y'（`picture-yank-rectangle'）は, もっとも最近にキルした矩形領域を
（上書きで）挿入しますが, `C-c C-x'
（`picture-yank-rectangle-from-register'）は同様のことを指定されたレジ
スタ内の矩形領域で行います.


File: emacs-ja, Node: Sending Mail, Next: Rmail, Prev: Picture, Up: Top

メイルの送信
************

Emacsでメッセージを送信するには, まずコマンド（`C-x m'）を打って
`*mail*'バッファを選択して初期化します.  続いて, このバッファでテキス
トとヘッダを編集し, 最後に別のコマンド（`C-c C-s'か`C-c C-c'）を打って
メッセージを送信します.

`C-x m'
     送信メッセージを作成する（`compose-mail'）.
`C-x 4 m'
     同様だが, 別のウィンドウにメッセージを表示する
     （`compose-mail-other-window'）.
`C-x 5 m'
     同様だが, 新たにフレームを作る（`compose-mail-other-frame'）.
`C-c C-s'
     メイル（mail）モードでは, メッセージを送信する（`mail-send'）.
`C-c C-c'
     メッセージを送信しメイルバッファを閉じる（`mail-send-and-exit'）.

コマンド`C-x m'（`compose-mail'）は, `*mail*'という名前のバッファを選
択し, そのバッファ内に送信するメッセージの雛型を作ります.  `C-x 4 m'
（`compose-mail-other-window'）は, 別のウィンドウで`*mail*'バッファを
選択し, 直前のカレントバッファは見えるようにしておきます.  `C-x 5 m'
（`compose-mail-other-frame'）は, 新たにフレームを作って`*mail*'バッファ
を選択します.

メイル作成バッファはEmacsの普通のバッファなので, メイルを書いている途
中で別のバッファに切り替えてあとで戻ってくる（あるいは戻らない）ことが
できます.  メッセージを書きかけのまま送信していないのに再度`C-x m'コマ
ンドを使うと, Emacsは古いメッセージを消してよいかどうか聞いてきます.
`n'と答えると, 書きかけの古い内容の`*mail*'バッファが選択されるので, 
古いメッセージを書き終えて送信できます.  `C-u C-x m'でもこのようにでき
ます.  メッセージを送信すると`*mail*'バッファは『変更なし』と印が付け
られ, つぎに`C-x m'を使っても確認を求めないようにします.

`*mail*'バッファに書きかけのメッセージを残したまま別のメッセージを送信
したい場合には, `M-x rename-uniquely'を使って`*mail*'バッファを別の名
前に変更してください（*Note Misc Buffer::）.  そして, `C-x m'コマンド
や他のコマンドで新しい`*mail*'バッファを作ります.  こうすれば個々のメ
イルバッファを独立に編集できます.

* Menu:

* Format: Mail Format.	     Format of the mail being composed.
* Headers: Mail Headers.     Details of permitted mail header fields.
* Aliases: Mail Aliases.     Abbreviating and grouping mail addresses.
* Mode: Mail Mode.	     Special commands for editing mail being composed.
* Spook: Distracting NSA.    How to distract the NSA's attention.
* Mail Methods::             Using alternative mail-composition methods.



File: emacs-ja, Node: Mail Format, Next: Mail Headers, Prev: Sending Mail, Up: Sending Mail

メイルバッファの形式
====================

メッセージにはテキスト, つまり, 本文以外にも, 誰が, いつ, 誰に, なぜ送っ
たかなどを示す"ヘッダフィールド"があります.  `Date'（日付）や`Sender'
（送り手）などのヘッダフィールドは, メッセージを送信するときに自動的に
作成されます.  受け手（宛先）などの他のヘッダフィールドは, メッセージ
がきちんと送信されるようにあなた自身が指定する必要があります.

メイル（mail）モードには, ヘッダフィールドを編集するためのコマンド群が
あり, 一部のヘッダフィールドはバッファ内で自動的に初期化されます.  通
常の編集コマンドを使ってヘッダフィールドに挿入したり編集したりできます.

バッファ内のつぎの行は, ヘッダとテキストを分ける特別な区切り行です.

     --text follows this line--

この行のあとに続くものはすべてメッセージのテキストになります.  このま
えにあるものはヘッダです.  実際に送信されるメッセージには, この区切り
行自身は含まれません.  区切り行として使うテキストは変数
`mail-header-separator'で制御します.

以下は, メイルバッファ内のヘッダとテキストの例です.

     To: gnu@gnu.org
     CC: lungfish@spam.org, byob@spam.org
     Subject: The Emacs Manual
     --Text follows this line--
     Please ignore this message.



File: emacs-ja, Node: Mail Headers, Next: Mail Aliases, Prev: Mail Format, Up: Sending Mail

メイルヘッダフィールド
======================

メイルバッファ内のヘッダフィールドは, 行頭のフィールド名で始まり, コロ
ン`:'で区切られます.  フィールド名（およびメイルアドレス）では, 大文字
小文字の区別はありません.  コロンと省いてもよい白文字のあとにフィール
ドの内容を書きます.

ヘッダフィールドには好き勝手にどんな名前でも使えますが, 一般にはきちん
と意味のある標準的なフィールド名だけを使います.  以下は送信メッセージ
で一般的に使われるフィールドの一覧です.

`To'
     このフィールドには, メッセージの送付先であるメイルアドレスを書く.
     1つより多くのアドレスを書く場合には, 空白ではなくコンマで区切る.

`Subject'
     `Subject'フィールドの内容としては, メッセージが何についてのものか
     を書く.  `Subject'フィールドが有効な理由は, 大部分のメイル閲覧プ
     ログラムが, 各メッセージの本文ではなく`Subject'を使ってメイル一覧
     を表示するため.

`CC'
     このフィールドには`To'フィールドと同様にメッセージ送付先の追加メ
     イルアドレスを書く.  ただし, これらのアドレスにあげられた人達は, 
     自分宛てのメッセージだとは思わないように.

`BCC'
     このフィールドにはメッセージ送付先の追加アドレスを書くが, 実際に
     送付されるメッセージのヘッダにはこのフィールドは含まれない.  この
     ようにして送信したコピーを"ブラインドカーボンコピー" （blind
     carbon copies）と呼ぶ.

     すべての送信メッセージのブラインドカーボンコピーを自分自身に送る
     には, 変数`mail-self-blind'に`t'を設定する.

`FCC'
     このフィールドには, メッセージを送信するたびにEmacsがそのコピーを
     追加していくファイルの名前を指定する.  ファイルがrmail形式であれ
     ば, Emacsはメッセージをrmail形式で書き込む.  それ以外の場合,
     Emacsはシステムメイルファイル形式で書き込む.

     送信メッセージを編集するたびに毎回決まったファイル名を`FCC'フィー
     ルドに指定するには, 変数`mail-archive-file-name'にそのファイル名
     を設定する.  送信メッセージから`FCC'フィールドを削除しない限り, 
     メッセージを送信するたびにこのファイルにメッセージが書き込まれる.

`From'
     `From'フィールドは, メイル送信時に使っているアカウントが自分のも
     のでない場合に, 送信者が本当は誰なのかを示すために用いる.  返信に
     は通常このフィールドが使われるので, `From'フィールドの内容は正し
     いメイルアドレスであること.  自分で`From'フィールドを指定しなけれ
     ば, Emacsはデフォルトで変数`user-mail-address'の値を使う.

`Reply-to'
     返信を別のアドレスに送ってほしい場合にこのフィールドを使う. 
     （rmailを含む）大部分のメイル閲覧プログラムは, `From'のアドレスよ
     り`Reply-to'のアドレスを優先して自動的に返信を送る.  `Reply-to'
     フィールドをヘッダに加えておけば, `From'のアドレスが返信時に引き
     起こすであろうどんな問題でも回避できる.

     すべての送信メッセージの`Reply-to'フィールドに決まったアドレスを
     指定するには, 変数`mail-default-reply-to'に（文字列で）そのアドレ
     スを設定する.  こうすると, `mail'は指定された`Reply-to'フィールド
     を付けてメッセージを初期化する.  メッセージを送信するまえに, 必要
     なら, このフィールドを削除したり変更したりできる.  Emacsが動き始
     めたときに環境変数`REPLYTO'が設定されていれば, その環境変数の値で
     変数`mail-default-reply-to'を初期化する.

`In-reply-to'
     このフィールドは返信しようとしているメッセージについての情報を書
     く.  メイルシステムによっては, この情報を使ってメイルを互いに関連
     付ける.  rmailでメッセージに返信するときには, rmailが自動的にこの
     フィールドを埋めるので, 気にする必要はない（*Note Rmail::）.

`References'
     このフィールドには, 関連する以前のメッセージのメッセージID一覧を
     書く.  rmailでメッセージに返信するときには, rmailが自動的にこの
     フィールドを埋める.

ヘッダフィールド, `To', `CC', `BCC', `FCC'は, いくつあってもよく, しか
も, これらの各フィールドにはコンマで区切って複数のアドレスを書けます. 
こうすれば, メッセージの送付先をいくつでも指定できます.  `To', `CC',
`BCC'フィールドでは継続行を使えます.  これらのフィールドに続く白文字で
始まる行は, すべてフィールドの一部であると見なします.  以下は継続行を
用いた`To'フィールドの例です.

     To: foo@here.net, this@there.net,
       me@gnu.cambridge.mass.usa.earth.spiral3281

メッセージを送信するときに, `From'フィールドを書いてないと, Emacsがか
わってこの項目を補います.  変数`mail-from-style'でその書式を（以下のよ
うに）制御します.

`nil'
     `king@grassland.com'のように電子メイルアドレスだけを補う.
`parens'
     `king@grassland.com (Elvis Parsley)'のように, 電子メイルアドレス
     と氏名を補う.
`angles'
     `Elvis Parsley <king@grassland.com>'のように, 氏名と電子メイルア
     ドレスを補う.
`system-default'
     システムに`From'フィールドを埋めさせる.



File: emacs-ja, Node: Mail Aliases, Next: Mail Mode, Prev: Mail Headers, Up: Sending Mail

メイルの別名
============

`~/.mailrc'という名前のファイルで"メイルの別名" （mail alias）を定義で
きます.  メイルの別名とは, 複数のメイルアドレスやそれらのグループに付
けた覚えやすい短い名前のことです.  他の多くのメイルプログラムと同様に,
`To', `From', `CC', `BCC', `Reply-to'のフィールドに別名が現れるとEmacs
は別名を展開し, 当該フィールドの先頭に`Resent-'を付加します.

`~/.mailrc'ファイルで別名を定義するには, 以下のような形式の行を書きま
す.

     alias SHORTADDRESS FULLADDRESSES

FULLADDRESSESは1つ以上のメイルアドレスであり, SHORTADDRESSをそれらのア
ドレスに展開します.  複数のアドレスを書く場合は, 空白で区切ります.  ア
ドレスに空白が含まれる場合は, アドレス全体をダブルクォート`"'で括りま
す.

たとえば, `gnu@gnu.org'とあなたのローカルアドレスに対する別名を
`maingnu'とするには, つぎのように書きます.

     alias maingnu gnu@gnu.org local-gnu

また, Emacsは`.mailrc'ファイル内の「取り込み」コマンドも認識します. 
つぎのように書きます.

     source FILENAME

ファイル`~/.mailrc'は主に他のメイル閲覧プログラムが使用するものです. 
このファイルには, 他にもさまざまなコマンドを指定できます.  Emacsは, こ
のファイル内の別名定義（`alias'）と取り込みコマンド（`source'）以外は
すべて無視します.

Emacsの中だけでメイルの別名を定義する別の方法は, `define-mail-alias'コ
マンドを使うことです.  このコマンドは, 別名と完全なアドレスを順次尋ね
てきます.  これを使えば, つぎのようにして個人の`.emacs'ファイルで別名
を定義できます.

     (define-mail-alias "maingnu" "gnu@gnu.org")

 `define-mail-alias'は, `mail-aliases'という変数に別名を追加記録します.
Lispのリスト操作に慣れているなら, `mail-aliases'に直接設定してもかまい
ません.  変数`mail-alias'の初期値は`t'となっていて, Emacsは`.mailrc'か
ら別名定義を読み込むという指定です.

`~/.mailrc'のかわりに使う別のファイルの名前は, 変数
`mail-personal-alias-file'に設定します.

 通常, Emacsはメッセージ送信時に別名を展開します.  送信に先だってみず
からメイルアドレスを展開する必要はありませんが, メイルが実際にどこへ送
信されるか確認したければ別名を展開することもできます.  そうするには, 
コマンド`M-x expand-mail-aliases'を使います.  アドレスを保持するメイル
ヘッダに書かれているすべてのメイルの別名を展開します.

もし好みに合うなら, メイルの別名を打ち込んだらただちに略語展開すること
もできます（*Note Abbrevs::）.  この機能を使うにはつぎのようにします.

     (add-hook 'mail-setup-hook 'mail-abbrevs-setup)

これを個人の`.emacs'ファイルに入れてもかまいません.  *Note Hooks::. 
この機能を使う場合には, `define-mail-alias'のかわりに
`define-mail-abbrev'を使う必要があります.  前者は, このパッケージでは
動作しません.  メイル用略語パッケージでは, `mail-aliases'のかわりに変
数`mail-abbrevs'を使い, さらに, すべての別名は小文字に変換されます.

メイル用略語パッケージには, `C-c C-a' 
（`mail-interactive-insert-alias'）コマンドもあって, 別名を（補完を使っ
て）読み取り, その定義をポイント位置に挿入します.  この機能は, Emacsが
別名を通常展開しない本文や`Subject'フィールドなどを編集しているときに
便利です.

単語の区切り文字を挿入したあとで略語が展開されることに注意してください. 
しかし, `C-n'と`M->'を再定義して展開が行われるように設定することもでき
ます.  つぎのようにします.

     (add-hook 'mail-setup-hook
               '(lambda ()
                  (substitute-key-definition
                    'next-line 'mail-abbrev-next-line
                    mail-mode-map global-map)
                  (substitute-key-definition
                    'end-of-buffer 'mail-abbrev-end-of-buffer
                    mail-mode-map global-map)))



File: emacs-ja, Node: Mail Mode, Next: Distracting NSA, Prev: Mail Aliases, Up: Sending Mail

メイルモード
============

メイルバッファで使われるメジャーモードはメイル（mail）モードです.  テ
キスト（text）モードに似ていますが, プレフィックス`C-c'で始まる多くの
特別なコマンドがあります.  これらのコマンドはすべてメッセージの編集や
送信に関するものです.  さらに, メイル（mail）モードでは, 文字`%'を単語
の切れ目と定義しています.  これは, 単語コマンドを使ってメイルアドレス
を編集するときに便利です.

`mail'コマンドやそれに関連するコマンドが自動的に設定するバッファでは, 
普通, メイル（mail）モードを使います.  しかし, ファイルを訪問している
バッファをメイル（mail）モードに切り替えることもできます.  これは, メッ
セージの草稿をファイルに保存してあるときなどに便利です.

* Menu:

* Mail Sending::        Commands to send the message.
* Header Editing::      Commands to move to header fields and edit them.
* Citing Mail::         Copying all or part of a message you are replying to.
* Mail Mode Misc::      Spell checking, signatures, etc.



File: emacs-ja, Node: Mail Sending, Next: Header Editing, Prev: Mail Mode, Up: Mail Mode

メイルの送信
------------

メイル（mail）モードには, 編集したメッセージを送信するコマンドが2つあ
ります.

`C-c C-s'
     メッセージを送信し, メイルバッファは選択したままにする
     （`mail-send'）.
`C-c C-c'
     メッセージを送信し, 別のバッファを選択する（`mail-send-and-exit'）.

`C-c C-s'（`mail-send'）はメッセージを送信してメイルバッファに『変更な
し』の印を付けます（変更フラグをクリアする）.  しかし, メッセージバッ
ファは選択したままですから, メッセージを修正して（新たな受け手に）再度
送信できます.  `C-c C-c'（`mail-send-and-exit'）はメッセージを送信して
から, ウィンドウを削除するか別のバッファに切り替えます.  メイルバッファ
は使い終えたので, デフォルトではその選択優先度は最低になります.  普通
はこのコマンドでメッセージを送信します.

ファイルを訪問しているバッファでは, メッセージ送信後でも変更フラグをク
リアしません.  ファイルを保存した場合にだけ変更フラグをクリアすべきだ
からです.  この結果, 同一メッセージを2回送信しようとしても警告は出ませ
ん.

非ASCII文字を含むメッセージを送信するときには, それらをコーディングシ
ステム（*Note Coding Systems::）で符号化する必要があります.  通常, コー
ディングシステムは, 選択した言語環境（*Note Language Environments::）
によって自動的に指定されます.  変数`sendmail-coding-system'を設定する
と, 送信メイルのコーディングシステムを明示できます.

このように決めたコーディングシステムが, メッセージ内の文字を扱えない場
合には, Emacsは, 可能なコーディングシステムの一覧を表示して, 使用する
コーディングシステムを問い合わせます.



File: emacs-ja, Node: Header Editing, Next: Citing Mail, Prev: Mail Sending, Up: Mail Mode

メイルヘッダの編集
------------------

メイル（mail）モードには, 特定のヘッダフィールドへ移動したりヘッダのア
ドレスを補完する特別なコマンドがあります.

`C-c C-f C-t'
     ヘッダフィールド`To'へ移動する.  フィールドがなければ作成する
     （`mail-to'）.
`C-c C-f C-s'
     ヘッダフィールド`Subject'へ移動する.  フィールドがなければ作成す
     る（`mail-subject'）.
`C-c C-f C-c'
     ヘッダフィールドへ`CC'移動する.  フィールドがなければ作成する
     （`mail-cc'）.
`C-c C-f C-b'
     ヘッダフィールド`BCC'へ移動する.  フィールドがなければ作成する
     （`mail-bcc'）.
`C-c C-f C-f'
     ヘッダフィールド`FCC'へ移動する.  フィールドがなければ作成する
     （`mail-fcc'）.
`M-TAB'
     メイルアドレスを補完する（`mail-complete'）.

ポイントを特定のヘッダフィールドに移動するコマンドは5つあって, すべて
プレフィックス`C-c C-f'で始まります（`C-f'は『フィールド』（fields）の
f）.  これらは上に示してあります.  当該フィールドが存在しなければ, こ
れらのコマンドはそのフィールドを作成します.  これらの特定のフィールド
に移動するコマンドを用意したのは, これらのフィールドを編集する可能性が
高いからです.

`To:', `CC:', `BCC:'などのメイルアドレスを含むヘッダフィールドを編集中
には, `M-TAB'（`mail-complete'）と打てばメイルアドレスを補完できます. 
完全な名前が決定できるならば, アドレスに対応する完全な名前を挿入します. 
変数`mail-from-style'と同様に, 変数`mail-complete-style'は, 完全な名前
を挿入するのか, どのスタイルを使うのかを制御します（*Note Mail
Headers::）.

補完のため使う正しいメイルアドレスは, ローカルのユーザー名一覧と個人の
メイルの別名からとられます.  正しいメイルアドレスの情報源を追加するこ
ともできます.  これに関するオプションを調べるには, カスタマイズバッファ
を使ってください.

メッセージの本文で`M-TAB'と打つと, テキスト（text）モードと同様に
`ispell-complete-word'を起動します.



File: emacs-ja, Node: Citing Mail, Next: Mail Mode Misc, Prev: Header Editing, Up: Mail Mode

メイルの引用
------------

メイル（mail）モードには, 返信対象であるメッセージの全部や一部をヤンク, 
つまり, "引用"（cite）するためのコマンドもあります.  こうしたコマンド
はrmailコマンドを使ってメッセージを送信する場合にだけ使えます.

`C-c C-y'
     rmailで選択したメッセージをヤンクする（`mail-yank-original'）.
`C-c C-r'
     rmailバッファで選択したリージョンをヤンクする（`mail-yank-region'）.
`C-c C-q'
     別のメッセージからの引用を段落に詰め込む
     （`mail-fill-yanked-message'）.

rmailコマンドを使ってrmailメイルリーダからメイル送信を起動したときには,
`C-c C-y'を使って返信対象のメッセージをメイルバッファに挿入できます. 
このコマンドは, 引用メッセージの各行を空白3文字で字下げしてほとんどの
ヘッダフィールドを削除します.  数引数は字下げする文字数を指定します.
`C-u'だけを指定すると, 字下げをせずにヘッダフィールドも削除しません.
`C-c C-y'は, つねにrmailバッファのカレントメッセージを使います.  した
がって, rmailで1つメッセージを選択してから`*mail*'バッファに切り替えて
ヤンクし, また, rmailに切り替えて別のメッセージを選択してというように
すれば, 複数の古いメッセージを挿入できます.

`C-c C-y'が各行の先頭に挿入する文字列は指定できます.  変数
`mail-yank-prefix'に望みの文字列を設定します.  （値が`nil'だと字下げし
ない. デフォルトはこれ. ）しかし, `C-u C-c C-y'と打った場合, 変数
`mail-yank-prefix'の値に関係なく, 各行の行頭には何も挿入しません.

届いたメイルの一部だけをヤンクするには, rmailで目的の部分にリージョン
を設定します.  そして`*mail*'バッファに移って`C-c C-r' 
（`mail-yank-region'）と打ちます.  コピーされる各行は,
`mail-yank-prefix'に従って字下げされるか行頭に文字列が挿入されます.

`C-c C-y'や`C-c C-r'を使い終ったら, `C-c C-q' 
（`mail-fill-yanked-message'）と打てばヤンクした古いメッセージを段落に
詰め込めます (1) (*Note Citing Mail-Footnotes::).  引用したメッセージ
を1つの段落に詰め込むには, `M-q'を使います.  詰め込み処理で行頭の文字
を自動的に正しく扱えない場合には, 詰め込み接頭辞を陽に指定して試してく
ださい.  *Note Filling::.


File: emacs-ja  Node: Citing Mail-Footnotes, Up: Citing Mail

(1) 【訳注】これは欧文用のコマンドで, 日本語で入力する場合にはあまり関
係ない.



File: emacs-ja, Node: Mail Mode Misc, Next: Distracting NSA, Prev: Citing Mail, Up: Mail Mode

その他のメイルモードコマンド
----------------------------

`C-c C-t'
     メッセージの本文の先頭に移動する（`mail-text'）.
`C-c C-w'
     ファイル`~/.signature'をメッセージの本文の末尾に挿入する
     （`mail-signature'）.
`C-c C-i FILE RET'
     FILEの内容を送信メッセージの末尾に挿入する（`mail-attach-file'）.
`M-x ispell-message'
     メッセージの本文について綴りの訂正を行う.  ただし, 他のメッセージ
     からの引用部分については行わない.

`C-c C-t'（`mail-text'）は, ポイントをヘッダの区切り行のあと, つまり, 
メッセージ文の先頭に移動します.

`C-c C-w'（`mail-signature'）は, あなたを識別するための決まり文句（サ
イン）をメッセージの末尾に追加します.  このテキストは, ホームディレク
トリのファイル`~/.signature'から取ります.  このサインを自動的に挿入す
るようにするには, 変数`mail-signature'に`t'を設定します.  そうすると, 
メイルメッセージに自動的にファイル`~/.signature'の内容が付加されます. 
特定のメッセージにサインを付けたくなければ, 送信前にバッファ内で削除し
てください.

変数`mail-signature'に文字列を指定することもできます.  すると, 送信メッ
セージを編集し始めると, その文字列はサインとして自動的に挿入されます. 
この変数にそれ以外のLisp式を指定すると, 毎回その式が評価されその値（文
字列であること）がサインになります.

コマンド`M-x ispell-message'で, 書きあげたメッセージの綴りを訂正できま
す.  このコマンドは, 引用部分については調べませんが, あなた自身が打ち
込んだテキストは検査します.  （字下げや`mail-yank-prefix'を利用して, 
引用部分とあなたの入力部分を区別します. ）*Note Spelling::.

送信メッセージにファイルを付加するには, カレントバッファにファイルを挿
入する普通のコマンド`C-x i'を使います.  しかし, 専用コマンド`C-c C-i'
（`mail-attach-file'）を使うほうがより便利なことがしばしばあります. 
このコマンドは, 指定したファイルの内容をバッファの最後, サインがあれば
そのうしろに, ファイル名を含んだ区切り行を付けて挿入します.

（`C-x m'が自動的に行うように）メイル（mail）モードをオンにすると, ノー
マルフック, `text-mode-hook'と`mail-mode-hook'とが実行されます.  新た
な送信メッセージを初期化するときには, ノーマルフック`mail-setup-hook'
を実行します.  メイルヘッダに特別なフィールドを追加したりメイルバッファ
の外見を変えたいならば, これらのフックを使ってください.  *Note
Hooks::.

これらのフックの主な違いは, どの時点で起動されるかです.  `M-x mail'と
打鍵すると, `*mail*'バッファを作成後ただちに`mail-mode-hook'が実行され
ます.  続いて`mail-setup'関数がバッファにデフォルトの内容を入れます. 
そのあとで, `mail-setup-hook'が実行されます.



File: emacs-ja, Node: Distracting NSA, Next: Mail Methods, Prev: Mail Mode, Up: Sending Mail

NSAを悩ますには
===============

`M-x spook'は, ランダムに選んだキーワードから成る行を送信メッセージに
付け加えます.  破壊活動を画策していると思わせるような単語の一覧表から
キーワードを選びます.

この機能の思想的背景には, NSA (1) (*Note Distracting NSA-Footnotes::) 
は自分たちが関心を持つ特定のキーワードを含んだすべての電子メイルを盗聴
（盗読？）しているのではないかという疑いがあります.  （NSAは否定してい
ますが, 彼らなら*当然*そういい張るだろう. ）多くの人々が怪しい単語をメッ
セージに付加しておけば, NSAはこうした疑わしいメイルの盗聴で非常に忙し
くなり, おしまいにはこうした行為を止めるのではないかと考えたからです.

以下は, 送信メッセージを編集し始めると自動的に怪しいキーワードを付け加
える方法です.

     (add-hook 'mail-setup-hook 'spook)

これでNSAが混乱してもしなくても, 少なくとも人々を楽しませることができ
ます.


File: emacs-ja  Node: Distracting NSA-Footnotes, Up: Distracting NSA

(1) 【訳注】NSAとはNational Security Agency （合衆国国家安全保障局）の
略.  合衆国の公益に基づいて必要により, 電話やInternetなどの盗聴を行っ
ていると噂されている.  この部分は日本国内だけでメイルをやりとりする限
りにおいてはあまり関係はないだろう.



File: emacs-ja, Node: Mail Methods, Next: Rmail, Prev: Distracting NSA, Up: Sending Mail

メイル作成方式
==============

本章では, メイルを編集／送信するためのEmacsの通常のモード, メイル
（mail）モードについて説明してきました.  本書ではふれていませんが,
MH-Eやメッセージ（message）モードを含む別のメイル編集／送信機能もEmacs
にはあります.  コマンド, `C-x m', `C-x 4 m', `C-x 5 m'は, 指定されたど
の方式にも対応しています.  ですから, メイルを送信するEmacsのさまざまな
コマンドや機能を利用できます.

メイル作成方式を指定するには, 変数`mail-user-agent'を設定します.  現時
点で正しい設定として認められるものは, `sendmail-user-agent',
`mh-e-user-agent', `message-user-agent'です.

異なるメイル作成方式を選択すると, 本章で述べた`*mail*'バッファやメイル
（mail）モードについての説明は役に立ちません.  異なったメイル作成方式
では, 異なった名前のバッファで異なった形式のまったく異なったコマンドを
使うかもしれないからです.



File: emacs-ja, Node: Rmail, Next: Dired, Prev: Sending Mail, Up: Top

メイルの閲覧rmail
*****************

rmailは, 受け取ったメイルを読んだり処理したりするためのEmacsのサブシス
テムです.  rmailは, メイルメッセージをrmailファイルと呼ばれるファイル
に格納します.  rmailファイル内のメッセージを読むには, rmailモードとい
う特別なメジャーモードで行います.  このモードでは, メイルを取り扱うコ
マンドを実行するようにほとんどのアルファベット文字を再定義しています. 
コマンド`rmail-mode'でrmailモードに切り替えます.  するといつものように
フック`rmail-mode-hook'が実行されます.  しかし, このコマンドを直接実行
しないでください.  正しいrmailファイルを訪問しているバッファでない限り, 
このコマンドはまともに動きません.

* Menu:

* Basic: Rmail Basics.       Basic concepts of Rmail, and simple use.
* Scroll: Rmail Scrolling.   Scrolling through a message.
* Motion: Rmail Motion.      Moving to another message.
* Deletion: Rmail Deletion.  Deleting and expunging messages.
* Inbox: Rmail Inbox.        How mail gets into the Rmail file.
* Files: Rmail Files.        Using multiple Rmail files.
* Output: Rmail Output.	     Copying message out to files.
* Labels: Rmail Labels.      Classifying messages by labeling them.
* Attrs: Rmail Attributes.   Certain standard labels, called attributes.
* Reply: Rmail Reply.        Sending replies to messages you are viewing.
* Summary: Rmail Summary.    Summaries show brief info on many messages.
* Sort: Rmail Sorting.       Sorting messages in Rmail.
* Display: Rmail Display.    How Rmail displays a message; customization.
* Editing: Rmail Editing.    Editing message text and headers in Rmail.
* Digest: Rmail Digest.      Extracting the messages from a digest message.
* Out of Rmail::	     Converting an Rmail file to mailbox format.
* Rot13: Rmail Rot13.	     Reading messages encoded in the rot13 code.
* Movemail: Movemail.        More details of fetching new mail.



File: emacs-ja, Node: Rmail Basics, Next: Rmail Scrolling, Prev: Rmail, Up: Rmail

rmailの基本概念
===============

もっとも簡単なrmailの使い方では, `~/RMAIL'という1つのrmailファイルにす
べてのメイルを保存します.  これを"主rmailファイル"（primary Rmail file）
といいます.  コマンド`M-x rmail'は, 主rmailファイルを読み込み, inbox
(1) (*Note Rmail Basics-Footnotes::) 内の新しいメイルを併合して, 最初
の未読メッセージを表示してメイルを読み始められるようにします.  変数
`rmail-file-name'で, 主rmailファイルの名前を指定します.

rmailは, rmailファイルの1つのメッセージだけが見えるようにナロイングし
ます.  表示されているメッセージを"カレントメッセージ"（current message）
と呼びます.  rmailモードの特別なコマンドを使えば, カレントメッセージを
削除 (2) (*Note Rmail Basics-Footnotes::) する, 別のファイルへコピーす
る, 返信を送る, 別のメッセージへ移動することができます.  また, 複数の
rmailファイルを作って, それらのあいだでメッセージを移すこともできます.


rmailファイル内では, 一般にメッセージは受け取った順に並べられます.  別
の順序にソートすることもできます.  メッセージには"メッセージ番号"
（message numbers）として連続した整数が割り振られます.  カレントメッセー
ジの番号は, rmailのモード行に表示され, そのあとにファイル内の総メッセー
ジ数も表示されます.  `j'キーにメッセージ番号を指定すれば, その番号のメッ
セージに移動できます（*Note Rmail Motion::）.

Emacsの習慣に従って, rmailファイルの変更はファイルを保存したときにだけ
反映されます.  `s'（`rmail-save'）で保存しますが, 削除（*Note Rmail
Deletion::）と指定されたメッセージをファイルからまず抹消します.  抹消
せずにファイルを保存するには, `C-x C-s'を使います.  さらに, inboxから
新着メイルを併合したあとにもrmailファイルを保存します（*Note Rmail
Inbox::）.

rmailを終了するには`q'（`rmail-quit'）を使います.  （メッセージを）抹
消しrmailファイルを保存してから, 別のバッファに切り替えます.  しかし, 
正しく「終了」する必要はありません.  rmailから別のバッファへ切り替えて, 
そのあと戻らなければ終了したことになります.  （rmailコマンド`b',
`rmail-bury'がこれを行う. ）（変更したファイルにするのと同様に）rmail
ファイルを確実に保存するようにしてください.  これには, `C-x s'がよいで
しょう（*Note Saving::）.


File: emacs-ja  Node: Rmail Basics-Footnotes, Up: Rmail Basics

(1) 【訳注】システムが到着メイルを格納するファイルのこと.  実際のファ
イル名はシステムに依存する.

(2) 【訳注】あとで説明されるように, 「削除」といっても実際には「削除印」
を付けるだけ.



File: emacs-ja, Node: Rmail Scrolling, Next: Rmail Motion, Prev: Rmail Basics, Up: Rmail

メッセージをスクロールする
==========================

rmailが表示するメッセージが画面に入りきらないとき, 残りの部分を読むに
はスクロールする必要があります.  これには, `C-v', `M-v', `M-<'を使いま
すが, rmailではスクロールを頻繁に行うので, もっと簡単な操作を用意して
あります.

`SPC'
     先へ進める（`scroll-up'）.
`DEL'
     まえへ戻す（`scroll-down'）.
`.'
     メッセージの先頭へ戻る（`rmail-beginning-of-message'）.

メッセージを読むときもっとも多く行うことは画面単位でのスクロールなので,
rmailでは, SPCとDELは, それぞれ, `C-v'（`scroll-up'）と`M-v'
（`scroll-down'）の同義になっています.

コマンド`.'（`rmail-beginning-of-message'）は, 選択されているメッセー
ジの先頭に移動します.  このコマンドは`M-<'とまったく同じというわけでは
ありません.  まず, マークを設定しません.  さらに, カレントメッセージを
変更してあるとバッファの境界を再設定します.



File: emacs-ja, Node: Rmail Motion, Next: Rmail Deletion, Prev: Rmail Scrolling, Up: Rmail

メッセージ間での移動
====================

もっとも基本的な操作は, メッセージを読むことです.  rmailでこれを行うに
は, メッセージをカレントメッセージにします.  メッセージは受け取った順
に並んでいるので, 通常はファイルの中を順に移動して読んでいきます.
rmailに入ると, カレントメッセージにしたことがない最初のメッセージから
始まります（つまり, 未読を意味する`unseen'属性が付いている最初のもの.
*Note Rmail Attributes::）.  先へ進めば他の新しいメッセージを読めます. 
まえへ戻れば古いメッセージを読み直せます.

`n'
     削除されたメッセージを飛ばして, 削除されていないつぎのメッセージ
     へ移動する（`rmail-next-undeleted-message'）.
`p'
     削除されていないまえのメッセージへ移動する
     （`rmail-previous-undeleted-message'）.
`M-n'
     削除されたメッセージも含めてつぎのメッセージへ移動する
     （`rmail-next-message'）.
`M-p'
     削除されたメッセージも含めてまえのメッセージへ移動する
     （`rmail-previous-message'）.
`j'
     最初のメッセージへ移動する.  数引数Nを指定すると, メッセージ番号N
     のメッセージへ移動する（`rmail-show-message'）.
`>'
     最後のメッセージへ移動する（`rmail-last-message'）.
`<'
     最初のメッセージへ移動する（`rmail-first-message'）.

`M-s REGEXP RET'
     正規表現REGEXPに一致するつぎのメッセージへ移動する
     （`rmail-search'）.

`- M-s REGEXP RET'
     正規表現REGEXPに一致するまえのメッセージへ移動する.

`n'と`p'は, rmailでメッセージ間を移動する普通の方法です.  これらのコマ
ンドは, メッセージ間を順々に移動していきますが, 期待どおりに削除された
メッセージは飛び越えます.  コマンドの定義名は
`rmail-next-undeleted-message'と`rmail-previous-undeleted-message'です. 
削除されたメッセージを飛び越したくない場合, たとえば, 削除されたメッセー
ジをアンデリート (1) (*Note Rmail Motion-Footnotes::)したいときは, 
（`n'や`p'の）変形である`M-n'や`M-p' （`rmail-next-message',
`rmail-previous-message'）を使います.  これらのコマンドに数引数を指定
すると, 反復回数とみなします.

rmailでは, 数字を打つだけで数引数を指定できます.  始めに`C-u'を打つ必
要はありません.

`M-s'（`rmail-search'）コマンドは, rmailにおける探索を行います.  通常
のインクリメンタルサーチコマンド`C-s'もrmailで使えますが, これはカレン
トメッセージの中だけを探索します.  `M-s'コマンドの目的は, 他のメッセー
ジを探すことです.  正規表現（*Note Regexps::）を読み終えてから, つぎの
メッセージの先頭から一致するものを探し始めます.  そしてみつかったメッ
セージを選択します.  REGEXPが空だと`M-s'は最後に使った正規表現を再使用
します.

ファイル内で逆向きに他のメッセージを探索するには, `M-s'に負の数引数を
指定します.  rmailでは, `- M-s'と打てばよいのです.

ラベルをもとにメッセージを探索することもできます.  *Note Rmail
Labels::.

メッセージ番号を指定してメッセージへ移動するには, メッセージ番号を引数
として`j'（`rmail-show-message'）を使います.  引数がないと`j'は最初の
メッセージを選択します.  `<'（`rmail-first-message'）も最初のメッセー
ジを選択します.  `>'（`rmail-last-message'）は最後のメッセージを選択し
ます.


File: emacs-ja  Node: Rmail Motion-Footnotes, Up: Rmail Motion

(1) 【訳注】メッセージに付けた削除印を消すこと.



File: emacs-ja, Node: Rmail Deletion, Next: Rmail Inbox, Prev: Rmail Motion, Up: Rmail

メッセージの削除
================

メッセージを保存しておく必要がなくなったら, そのメッセージを"削除"
（delete）できます.  「無視せよ」という意味の削除印をメッセージに付け
ます.  すると, いくつかのrmailコマンドはそのメッセージが存在しないもの
として扱います.  しかし, そのメッセージはまだrmailファイルの中にあって, 
メッセージ番号も付いています.

rmailファイルを"抹消"（expunging）すると, 削除印が付いたメッセージを本
当に消し去ります.  残ったメッセージには番号を順に振り直します.  抹消は, 
アンダイジェスト（*Note Rmail Digest::）を除いて, メッセージ番号を変更
する唯一の動作です.

`d'
     カレントメッセージを削除し, 削除されていないつぎのメッセージへ移
     動する（`rmail-delete-forward'）.
`C-d'
     カレントメッセージを削除し, 削除されていないまえのメッセージへ移
     動する（`rmail-delete-backward'）.
`u'
     カレントメッセージをアンデリートする, あるいは, 削除されたまえの
     メッセージへ戻ってアンデリートする
     （`rmail-undelete-previous-message'）.
`x'
     rmailファイル（の削除の付いたメッセージ）を抹消する
     （`rmail-expunge'）.

rmailにはメッセージを削除するコマンドが2つあります.  どちらもカレント
メッセージを削除し, 別のメッセージを選択します.  `d'
（`rmail-delete-forward'）はすでに削除したメッセージを飛ばしてつぎのメッ
セージへ移動しますが, `C-d'（`rmail-delete-backward'）はまえのメッセー
ジへ移動します.  指定した方向に削除されていないメッセージがないときは, 
削除したばかりのメッセージがカレントメッセージのままです.  どちらのコ
マンドに対しても, 数引数を指定すると, 削除後の移動方向を反転します.

rmailがメッセージを削除するときはいつでも, `rmail-delete-message-hook'
に登録されている関数（群）を起動します.  フック関数が起動されるときに
は, メッセージに削除印が付いていますが, rmailバッファではそのメッセー
ジはカレントメッセージのままです.

削除したすべてのメッセージをrmailファイルから本当に消すには`x'
（`rmail-expunge'）と打ちます.  これを実行するまえならば, "アンデリー
ト"（undelete）, つまり, メッセージの削除印を消すことができます.  アン
デリートコマンド, `u'（`rmail-undelete-previous-message'）は`d'コマン
ドの効果をほとんどの場合打ち消します.  カレントメッセージが削除されて
いれば, カレントメッセージをアンデリートします.  そうでなければ, 削除
されたメッセージがみつかるまでまえへ戻り, そのメッセージをアンデリート
します.

普通は`u'で`d'をアンドゥできます.  なぜなら, `d'で削除したメッセージを
まえへ戻って探してそのメッセージを`u'がアンデリートするからです.  しか
し, `d'がメッセージを削除してから後続のすでに削除されたメッセージを飛
び越す場合には, うまくいきません.  この場合, `u'コマンドは飛び越したメッ
セージのうちの最後のものをアンデリートします.  この問題を回避する簡単
な方法はありません.  ですが, `u'コマンドを繰り返せば, 最終的にはアンデ
リートしたいメッセージに辿り着きます.  あるいは, `M-p'コマンドで目的の
削除されたメッセージに移動してから`u'を打ってアンデリートします.

削除されたメッセージには, `deleted'という属性が付きます.  その結果, カ
レントメッセージが削除されているとモード行に`deleted'と表示されます. 
メッセージを削除する, あるいは, アンデリートすると, 実際には, メッセー
ジにこの属性を付加する, あるいは, 取り去るだけです.  *Note Rmail
Attributes::.



File: emacs-ja, Node: Rmail Inbox, Next: Rmail Files, Prev: Rmail Deletion, Up: Rmail

rmailファイルとinbox
====================

オペレーティングシステムは, "inbox"と呼ばれるファイルに到着したメイル
を格納します.  rmailを起動すると, `movemail'と呼ばれるCプログラムが走
り, inboxから主rmailファイルへ新着メッセージをコピーします.  ただし, 
主rmailファイルには, 以前のrmailセッションで保存したメッセージも入って
います.  実際にrmailで読むメイルはこのファイルの中にあるのです.  この
操作を, "新着メイルの取得"といいます.  rmail内で`g'と打てば, いつでも
新着メイルを取得できます.

変数`rmail-primary-inbox-list'には, 主rmailファイルのinboxとなるファイ
ルのリストを格納します.  この変数を明示的に設定しなければ, 環境変数
`MAIL'で初期化するか, あるいは, 最後の手段として, デフォルトのinboxを
使うことを意味する`nil'に設定します.  デフォルトのinboxはオペレーティ
ングシステムに依存して, `/var/mail/USERNAME',
`/usr/spool/mail/USERNAME', `/usr/mail/USERNAME'になります.

システムのデフォルトを調べるには, `C-h v rmail-primary-inbox RET'を使
います.  コマンド`set-rmail-inbox-list'で, 任意のrmailファイルに対して
使うinboxファイルを指定できます.  *Note Rmail Files::を参照してくださ
い.

rmailファイルとinboxに分ける理由は2つあります.

  1. inboxのファイル形式は, オペレーティングシステムや使用するメイルソ
     フトに依存して異なる.  rmailの一部分だけが違いを知っていればよく, 
     しかも, rmail独自の形式への変換方法だけを知っていればよい.

  2. メイル紛失という危険を犯さずにinboxを参照するのはたいへん厄介であ
     る.  というのは, メイル配送プログラムと相互排除を行う必要があるか
     ら.  さらに, オペレーティングシステムごとに相互排除の手法が異なる. 
     いったんinboxからメイルを取り出し, あとは別のrmailファイルを使う
     方式では, rmailファイルしか扱わないのでrmailの各所で相互排除する
     必要がなくなる.

rmailでは独自の内部形式（Babyl形式）を使っています.  当初からUNIXやGNU
システムの普通のinbox形式で十分であると気づいていて, inbox形式を内部形
式として使おうと計画しています.  しかし, たとえファイルの形式が同一で
あっても, rmailファイルはinboxファイルとは独立して存在し続けるでしょう.



File: emacs-ja, Node: Rmail Files, Next: Rmail Output, Prev: Rmail Inbox, Up: Rmail

複数のrmailファイルの扱い方
===========================

rmailはデフォルトでは個人の主rmailファイルを操作します.  このファイル
は, `~/RMAIL'という名前で, システムのinboxファイルから到着メイルを受け
取ります.  しかし, 別のrmailファイルを作ってそれをrmailで編集すること
もできます.  これらのファイルはそれぞれ独自のinboxからメイルを受け取っ
たり, あるいは, rmailコマンドでそれらのあいだでメッセージを移せます
（*Note Rmail Output::）.

`i FILE RET'
     FILEをEmacsに読み込み, それに対してrmailを実行する（`rmail-input'）.

`M-x set-rmail-inbox-list RET FILES RET'
     現在のrmailファイルに対してメイルを取り込むinboxファイルを指定す
     る.

`g'
     現在のrmailファイルのinboxから新着メイルを取得する
     （`rmail-get-new-mail'）.

`C-u g FILE RET'
     inboxファイルFILEから新着メイルを取得する.

主rmailファイル以外のファイルに対してrmailを実行するには, rmailで`i'
（`rmail-input'）コマンドを使います.  このコマンドは, 指定されたファイ
ルをrmailモードで訪問します.  rmailの外からでも`M-x rmail-input'を使え
ます.

`i'で読み込むファイルは, 通常, 正しいrmailファイルであるべきです.  そ
うでなければ, rmailは既知のさまざまな形式を用いてメッセージに分解しよ
うと試みます.  それに成功すれば, ファイル全体をrmailファイルに変換しま
す.  存在しないファイル名を指定すると, `i'コマンドは新たなrmailファイ
ル用の新しいバッファを初期化します.

メニューからrmailファイルを選択することもできます.  まず, メニューバー
から項目Classifyを選びます.  続いて, Classifyメニューから項目Input
Rmail Fileを選びます.  そして, 望みのrmailファイルを選択します.  変数
`rmail-secondary-file-directory'と 変数`rmail-secondary-file-regexp'で, 
メニューに含めるべきファイルを指定します.  最初の変数では探すべきディ
レクトリを指定し, 2番目の変数ではディレクトリ中のどのファイルか（正規
表現に一致するもの）を指定します.  これらの変数は出力用のファイルを選
択するときにも使われます.

各rmailファイルには, inboxファイル名の一覧を持たせることができます. 
この一覧は, `M-x set-rmail-inbox-list RET FILES RET'で指定します.  引
数には, コンマで区切っていくつもファイル名を書けます.  引数が空でもか
まいませんが, その場合, そのファイルにはinboxがないという指定になりま
す.  いったんinboxの一覧を指定すれば, 新たに指定し直さない限り, rmail
ファイルはそれを覚えています.

特別な例外として, 主rmailファイルにinboxファイルを指定しないと, システ
ム標準のinboxを使用します.

`g'（`rmail-get-new-mail'）コマンドは, 指定されたinboxから現在のrmail
ファイルにメイルを併合します.  rmailファイルにinboxが指定されていなけ
れば, `g'は何もしません.  コマンド`M-x rmail'も, 主rmailファイルに新着
メイルを併合します.

普通のinboxでないファイルからメイルを併合するには, `C-u g'のように`g'
キーに数引数を指定します.  すると, ファイル名を読み取り, そのファイル
からメイルを併合します.  `g'に引数を指定したときには, inboxファイルを
削除したり変更したりしません.  したがって, これは, メッセージファイル
を別のメッセージファイルへ併合する一般的な方法です.



