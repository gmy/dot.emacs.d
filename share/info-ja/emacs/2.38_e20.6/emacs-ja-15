Info file: emacs-ja,    -*-Text-*-
produced by `texinfo-format-buffer'
from file `emacs.texi'
using `texinfmt.el' version 2.38 of 3 July 1998.


Emacs 20.6版対応に改訂した`GNU Emacs Manual' 13版です.

INFO-DIR-SECTION Editors
START-INFO-DIR-ENTRY
* Emacs: (emacs).	The extensible self-documenting text editor.
END-INFO-DIR-ENTRY


Published by the Free Software Foundation 59 Temple Place, Suite 330
Boston, MA 02111-1307 USA

Copyright (C) 1985, 1986, 1987, 1993, 1994, 1995, 1996, 1997, 1998,
1999 Free Software Foundation, Inc.

Permission is granted to make and distribute verbatim copies of this
manual provided the copyright notice and this permission notice are
preserved on all copies.

Permission is granted to copy and distribute modified versions of this
manual under the conditions for verbatim copying, provided also that
the sections entitled "The GNU Manifesto", "Distribution" and "GNU
General Public License" are included exactly as in the original, and
provided that the entire resulting derived work is distributed under
the terms of a permission notice identical to this one.

Permission is granted to copy and distribute translations of this
manual into another language, under the above conditions for modified
versions, except that the sections entitled "The GNU Manifesto",
"Distribution" and "GNU General Public License" may be included in a
translation approved by the Free Software Foundation instead of in the
original English.





File: emacs-ja, Node: General Variables, Next: Misc Variables, Prev: Environment, Up: Environment

一般的な変数
------------

`AUTHORCOPY'
     GNUSパッケージで投稿したニュース記事の保管用ファイルの名前.
`CDPATH'
     相対ディレクトリ名を指定したときに, そのディレクトリを探索するた
     めに`cd'コマンドが使う.
`DOMAINNAME'
     Emacsが動いているマシンが属するInternetのドメイン名.  GNUSパッケー
     ジが使う.
`EMACS_UNIBYTE'
     この環境変数を定義すると, Emacsはユニバイトバッファやユニバイト文
     字列を使うようにすべてを設定する.  起動時に, 毎回, コマンド行オプ
     ション`--unibyte'を使うのと等価である.  *Note Initial Options::.
`EMACSDATA'
     Emacsに付属の機種独立なファイルを探すために使う変数
     `data-direcotry'の初期化に用いる.  Emacs作成時の`paths.h'での設定
     に優先する.
`EMACSLOADPATH'
     ロードすべきEmacs Lispファイルを探索するディレクトリをコロンで区
     切った並び.  Emacs作成時の`paths.h'での設定に優先する.
`EMACSLOCKDIR'
     複数のユーザーが同じファイルを同時に編集するの防ぐために用いるロッ
     クファイルを置くディレクトリ.  Emacs作成時の`paths.h'での設定に優
     先する.
`EMACSPATH'
     Emacsに特有のバイナリファイルを置く場所.  Emacs作成時の`paths.h'
     での設定に優先する.
`ESHELL'
     シェル（shell）モードで使い, 環境変数`SHELL'の設定に優先する.
`HISTFILE'
     ログインとつぎのログインのあいだでシェルコマンドを保存しておくファ
     イルの名前.  この変数のデフォルトは, シェルとしてcshやtcshを使う
     場合は`~/.history', bashの場合は`~/.bash_history', kshの場合は
     `~/.sh_history', その他の場合には`~/.history'である.
`HOME'
     ディレクトリ木構造上でのユーザーのファイルの置き場所.  ティルダ
     （`~'）で始まるファイル名の展開に使われる.  MS-DOSでは, Emacsが起
     動されたディレクトリがデフォルトであるが, `/bin'で終る場合には
     `/bin'は取り除く.
`HOSTNAME'
     Emacsが動いているマシンの名前.
`INCPATH'
     コロンで区切ったディレクトリの並び.  `complete'パッケージがファイ
     ルを探すために使う.
`INFOPATH'
     infoファイルを収めたディレクトリをコロンで区切った並び.  Emacs作
     成時の`paths.h'での設定に優先する.
`LANG'
`LC_ALL'
`LC_CTYPE'
     ユーザーの好みのローケル.  ローケル名に, Nを1から4として,
     `8859-N', `8859_N', `8859N'が含まれると, 自動的に`Latin-N'をEmacs
     起動時の言語環境に指定する.  Nが9であると`Latin-5'を指定する.
`LOGNAME'
     ユーザーのログイン名.  `USER'も参照.
`MAIL'
     ユーザーのシステムメイルスプールの名前.
`MAILRC'
     メイルの別名を収めたファイルの名前.  デフォルトは`~/.mailrc'.
`MH'
     mhシステムの設定ファイルの名前.  デフォルトは`~/.mh_profile'.
`NAME'
     ユーザーの実世界での名前.
`NNTPSERVER'
     ニュースサーバーの名前.  mhやGNUSパッケージで用いる.
`ORGANIZATION'
     読者が所属している組織の名前.  GNUSパッケージで投稿する記事のヘッ
     ダ「Organization:」の設定に使う.
`PATH'
     実行ファイルを置いたディレクトリをコロンで区切った並び.  （MS-DOS
     ではセミコロンで区切る. ）この変数はEmacs Lispの変数`exec-path'の
     設定に使われる.  Emacsの中ではこのLisp変数の値を使うことになる.
`PWD'
     設定すると, Emacs起動時のデフォルトディレクトリになる.
`REPLYTO'
     設定すると, 変数`mail-default-reply-to'の初期値を指定する.  *Note
     Mail Headers::.
`SAVEDIR'
     ニュース記事を保存するデフォルトのディレクトリ名.  GNUSパッケージ
     が使う.
`SHELL'
     Emacs内から起動するプログラムの解析や実行に用いるインタープリタの
     名前.
`TERM'
     Emacsが動いている端末の名前.  バッチモードでの実行でなければこの
     変数を設定する必要がある.  MS-DOSではデフォルトは`internal'であり, 
     マシン固有の画面を扱う内蔵の端末エミュレータを意味する.
`TERMCAP'
     変数`TERM'で指定した端末をどのように制御するか記述したtermcapライ
     ブラリファイルの名前.  デフォルトは`/etc/termcap'.
`TMPDIR'
     Emergeパッケージが使い, 作業用ファイルの接頭辞.
`TZ'
     現在のタイムゾーン（時刻帯）を指定し必要なら夏時間も指定する.
     MS-DOSではデフォルトは国別コードに基づく.  詳しくはファイル
     `msdos.c'を参照.
`USER'
     ユーザーのログイン名.  `LOGNAME'も参照.  MS-DOSではデフォルトは
     `root'.
`VERSION_CONTROL'
     変数`version-control'（*Note Backup Names::）の初期化に使う.



File: emacs-ja, Node: Misc Variables, Next: Display X, Prev: General Variables, Up: Environment

その他の変数
------------

これらの変数は特定の場合に限って使われます.

`COMSPEC'
     MS-DOSにおいて, 使用するコマンドインタープリタの名前.  環境変数
     `SHELL'のデフォルト値になる.

`NAME'
     MS-DOSにおいて, この変数は変数`USER'のデフォルト値になる.

`TEMP'
`TMP'
     MS-DOSにおいて, 作業用ファイルを置くディレクトリの名前を指定する.

`EMACSTEST'
     MS-DOSにおいて, 内蔵の端末エミュレータの動作を記録するために使う
     ファイルを指定する.  この機能はバグレポートを提出するときに有益で
     ある.

`EMACSCOLORS'
     MS-DOSシステムにおいて, スクリーンの初期表示色を設定してEmacs起動
     時に瞬間的にデフォルトの表示色が閃かないようにする.  この変数の値
     は, デフォルトのフェイスの（1文字目で）前景色と（2文字目で）背景
     色を符号化した2文字であること.  それぞれの文字は, 標準的なPCのテ
     キストモード画面の表示色を表す16進符号であること.

     PCの画面では, 通常, 8色の背景色しか扱えない.  しかし, EmacsはDOS
     の画面を16色の背景色のモードに切り替えるので, 背景色の下位4bitす
     べてが実際に使われる.

`WINDOW_GFX'
     Sunのウィンドウシステムを初期化するときに使う.



File: emacs-ja, Node: Display X, Next: Font X, Prev: Environment, Up: Command Arguments

ディスプレイ名の指定
====================

環境変数`DISPLAY'は, Emacsを含むすべてのXクライアントにウィンドウをど
こに表示するかを教えます.  普通の状況では, Xサーバーを起動してローカル
でジョブを走らせると, この変数の値はデフォルトで設定されます.  場合に
よっては, 自分でディスプレイを指定する必要があるでしょう.  たとえば, 
リモートログインしてリモート側でクライアントプログラムを実行し, 表示は
ローカルの画面にする場合です.

Emacsを使う場合, デフォルトのディスプレイを変更する主な理由は, 他のシ
ステムにログインしてそのシステム上でEmacsを実行し, ウィンドウはローカ
ルの画面に表示するためです.  他のシステムにログインするのは, そのシス
テム上に編集したいファイルがあるか, あるいは, 実行したいEmacsの実行ファ
イルがそのシステムにあるからでしょう.

環境変数`DISPLAY'の書式は`HOST:DISPLAY.SCREEN'です.  HOSTはXウィンドウ
システムのサーバーマシンの名前, DISPLAYは同じマシンの別のサーバーと読
者のサーバー（X端末）を区別するために任意に割り振られた番号, SCREENは
稀にしか使いませんが1つのXサーバーで複数の端末画面を制御する場合に使い
ます.  ピリオドとSCREENは省いてかまいません.  指定する場合, SCREENは普
通はゼロです.

たとえば, 読者のホストの名前は`glasperle'であり, 読者のサーバーは使用
できるサーバーのうちで最初（でたぶん唯一）のものであるとすれば,
`DISPLAY'は`glasperle:0.0'となります.

Emacsを実行するときに明示的にディスプレイ名を指定できます.  変数
`DISPLAY'を変更する, あるいは, オプションの`-d DISPLAY'や
`--display=DISPLAY'を指定します.  たとえばつぎのようにします

     emacs --display=glasperle:0 &

オプション`-nw'を指定するとXを直接使用することを禁止できます.  これも
初期化オプションです.  Emacsに対して制御端末に通常のASCII文字を表示す
るように指示します.

セキュリティの設定によっては, リモートシステムのプログラムから読者のロー
カルのシステムに表示するのが禁止されます.  この場合, Emacsを走らせると
つぎのようなメッセージが出力されます.

     Xlib:  connection to "glasperle:0.0" refused by server

この問題は, `xhost'コマンド (1) (*Note Display X-Footnotes::) を用いて, 
ローカルマシンにリモートシステムからのアクセス許可を与えれば解決できま
す.


File: emacs-ja  Node: Display X-Footnotes, Up: Display X

(1) 【訳注】ホスト単位でアクセスを制御する`xhost'コマンドより, ユー
ザー単位でアクセスを制御する`xauth'のほうが望ましいだろう.



File: emacs-ja, Node: Font X, Next: Colors X, Prev: Display X, Up: Command Arguments

フォント指定オプション
======================

デフォルトでは, Emacsは`9x15'という名前のフォントでテキストを表示しま
す.  この場合, 各文字の幅は9ピクセル, 高さは15ピクセルです.  コマンド
行のオプション`-fn NAME'で別のフォントを指定できます.

`-fn NAME'
     デフォルトのフォントとしてフォントNAMEを使う.

`--font=NAME'
     `--font'は, `-fn'の別名.

Xにおいては, 各フォントはダッシュで区切った11個の単語や数字からなる長
い名前を持ちます.  短い愛称を持つフォントもあり, `9x15'はそのような愛
称です.  どちらの名前を用いてもかまいません.  フォント名にはワイルドカー
ドパターンを使えますが, その場合には, EmacsはXにパターンに一致するフォ
ントを1つ選ばせます.  以下の例は, `6x13'という愛称を持つフォントを指定
することになります.

     emacs -fn "-misc-fixed-medium-r-semicondensed--13-*-*-*-c-60-iso8859-1" &

個人のファイル`.Xdefaults'でもフォントを指定できます.

     emacs.font: -misc-fixed-medium-r-semicondensed--13-*-*-*-c-60-iso8859-1

長いフォント名はつぎのような形式です.

     -MAKER-FAMILY-WEIGHT-SLANT-WIDTHTYPE-STYLE...
     ...-PIXELS-HEIGHT-HORIZ-VERT-SPACING-WIDTH-CHARSET

FAMILY
     フォントファミリ名.  たとえば`courier'.
WEIGHT
     通常, `bold', `medium', `light'のいずれか.  フォントによっては他
     の単語もありえる.
SLANT
     `r'（roman）, `i'（italic）, `o'（oblique）, `ri'（reverse italic）,
     `ot'（other）のいずれか.
WIDTHTYPE
     通常, `condensed', `extended', `semicondensed', `normal'のいずれ
     か.  フォントによっては他の単語もありえる.
STYLE
     付加的な書体名.  この部分は普通は空であり, ほとんどの長いファイル
     名では2つのハイフンである.
PIXELS
     ピクセル単位でのフォントの高さ.
HEIGHT
     印刷機の「ポイント」の1/10（約1/720インチ）を単位とした画面上での
     フォントの高さ.  いいかえれば, フォントのポイントサイズの10倍. 
     垂直解像度を指定すれば, HEIGHTとPIXELSは比例する.  したがって, ど
     ちらか一方を指定して他方には`*'を用いるのが一般的である.
HORIZ
     フォントが仮定するインチあたりのピクセル数で表した画面の水平解像
     度.
VERT
     フォントが仮定するインチあたりのドット数で表した画面の垂直解像度. 
     通常, 読者のシステムのフォントの解像度は読者の画面に適しているは
     ずなので, これとHORIZには普通は`*'を指定する.
SPACING
     `m'（monospace）, `p'（proportional）, `c'（character cell）のい
     ずれか.  Emacsでは`m'と`c'のフォントを利用できる.
WIDTH
     ピクセル単位で表した文字の平均幅の10倍.
CHARSET
     フォントの描く文字集合.  通常は`iso8859-1'を使うであろう. (1)
     (*Note Font X-Footnotes::)

固定幅フォント, つまり, すべての文字が同じ幅のフォントだけを使ってくだ
さい.  Emacsはまだ可変幅のフォントを正しく表示できません.  長いフォン
ト名のSPACING欄が`m'や`c'のフォントは固定幅フォントです.  読者のシステ
ムで利用可能な固定幅フォントをすべて表示するには, プログラム`xlsfotns'
を用いてつぎのようにします.

     xlsfonts -fn '*x*' | egrep "^[0-9]+x[0-9]+"
     xlsfonts -fn '*-*-*-*-*-*-*-*-*-*-*-m*'
     xlsfonts -fn '*-*-*-*-*-*-*-*-*-*-*-c*'

特定のフォントの字形を見るにはコマンド`xfd'を使います.  たとえば,

     xfd -fn 6x13

とするとフォント`6x13'全体を表示します.

Emacsが動作中のときは, カレントフレーム（*Note Frame Parameters::）, 
あるいは, 特定の種類のテキスト（*Note Faces::）のフォントを設定できま
す.


File: emacs-ja  Node: Font X-Footnotes, Up: Font X

(1) 【訳注】日本語の場合は, 通常, `jisx0208.1983-0'などを使
うであろう.



File: emacs-ja, Node: Colors X, Next: Window Size X, Prev: Font X, Up: Command Arguments

ウィンドウ表示色オプション
==========================

カラーディスプレイでは, Emacsの表示画面のさまざまな部分に使う表示色を
指定できます.  システムで利用可能な表示色を調べるにはファイル
`/usr/lib/X11/rgb.txt' (1) (*Note Colors X-Footnotes::)を見ます.  表示
色を指定しないと, 背景色のデフォルトは白, それ以外の表示色のデフォルト
は黒です.  モノクロディスプレイでは, 前景色は黒, 背景色は白, ディスプ
レイで表示できるなら境界部分は灰色です.

以下は, 表示色を指定するオプションの一覧です.

`-fg COLOR'
`--foreground-color=COLOR'
     前景色を指定する.
`-bg COLOR'
`--background-color=COLOR'
     背景色を指定する.
`-bd COLOR'
`--border-color=COLOR'
     Xのウィンドウの境界部分の表示色を指定する.
`-cr COLOR'
`--cursor-color=COLOR'
     ポイント位置を表すEmacsのカーソルの表示色を指定する.
`-ms COLOR'
`--mouse-color=COLOR'
     マウスがEmacsのウィンドウ内にあるときのマウスカーソルの表示色を指
     定する.
`-r'
`--reverse-video'
     反転表示する.  背景色と前景色を入れ替える.

たとえば, 珊瑚色のマウスカーソルと青石板色のテキストカーソルを用いるに
は, つぎのように入力します.

     emacs -ms coral -cr 'slate blue' &

オプション`-r'かXリソースの`reverseVideo'で前景色と背景色を入れ替えら
れます.


File: emacs-ja  Node: Colors X-Footnotes, Up: Colors X

(1) 【訳注】表示色として指定できる『名前』がわかるだけ.  どのような色
に表示されるかは`xcolors'などのコマンドで調べるとよい.




File: emacs-ja, Node: Window Size X, Next: Borders X, Prev: Colors X, Up: Command Arguments

ウィンドウジオメトリオプション
==============================

オプション`-geometry'は, Emacsの初期フレームのサイズと位置を制御します. 
ウィンドウのジオメトリ（サイズと位置）を指定する書式はつぎのとおりです.

`-g WIDTHxHEIGHT{+-}XOFFSET{+-}YOFFSET'
     WIDTHとHEIGHTでウィンドウの（文字の桁数と行数で数えた）サイズを,
     XOFFSETとYOFFSETで（ピクセル単位で）位置を指定する.

`--geometry=WIDTHxHEIGHT{+-}XOFFSET{+-}YOFFSET'
     同じことを記述する別の方法.

`{+-}'はプラス記号かマイナス記号のいずれかを意味します.  XOFFSETのまえ
のプラス記号で画面左端からの距離を, マイナス記号で右端からの距離を意味
します.  YOFFSETのまえのプラス記号で画面上端からの距離を, マイナス記号
で下端からの距離を意味します.  XOFFSETとYOFFSETの値自体は正でも負でも
よいのですが, その意味は変わらずに方向を変えるだけです.

Emacsがジオメトリを解釈する単位は, `xterm'と同じ単位です.  WIDTHと
HEIGHTは文字数で数えますから, 大きなフォントでは小さいフォントよりも大
きなフレームになります.  XOFFSETとYOFFSETはピクセル単位で数えます.

モード行とエコー領域はフレームの最後の2行を占めるので, 初期のテキスト
ウィンドウの高さはジオメトリで指定した高さより2だけ小さくなります.  X
ツールキット版でないEmacsでは, 指定した数からさらに1行をメニューバーに
利用します.

ジオメトリ指定のすべての部分を指定する必要はありません.

XOFFSETとYOFFSETの両方を省くとウィンドウマネージャがEmacsのフレームの
位置を決めますが, マウスで置き場所を指定できる場合もあります.  たとえ
ば, `164x55'は（普通の幅のウィンドウを横に並べて2つ置けるサイズの）164
桁で55行のウィンドウを指定します.

デフォルトではEmacsの幅は80文字で高さは40行です.  いずれか一方, あるい
は, 両方を省略できます.  ジオメトリを数で始めると幅であると解釈します.
`x'で始まり数が続けば高さであると解釈します.  したがって, `81'は幅だけ
を指定し, `x45'は高さだけを指定します.

`+'か`-'で始まれば位置指定となり, 幅と高さの両方を省いたことを意味しま
す.  したがって, `-3'はXOFFSETのみを指定します.  （位置指定の要素が1つ
だけの場合にはつねにXOFFSETです. ）`+3-3'はXOFFSETとYOFFSETを指定し, 
画面の左底近くにフレームを置きます.

ファイル`.Xdefaults'ですべての部分か一部分のデフォルトを指定し, オプショ
ン`--geometry'で特定の部分を上書きできます.



File: emacs-ja, Node: Borders X, Next: Title X, Prev: Window Size X, Up: Command Arguments

内部境界と外部境界
==================

Emacsのフレームには内部境界と外部境界があります.  内部境界はフレームの
4辺の周りに付いた背景色の縁取りです.  Emacs自身が内部境界を付加します. 
外部境界は, 内部境界の外側にウィンドウマネージャが付加します.  これに
は, ウィンドウを移動したりアイコン化するためにクリックできるさまざまな
箱が付く場合もあります.

`-ib WIDTH'
`--internal-border=WIDTH'
     内部境界の幅としてWIDTHを指定.

`-bw WIDTH'
`--border-width=WIDTH'
     外部境界の幅としてWIDTHを指定.

フレームのサイズ指定には境界は含みません.  フレームの位置は外部境界の
外側から測ります.

内部境界の幅をNピクセルにするには, オプション`-ib N'を使います.  デフォ
ルトは1です.  外部境界の幅を指定するには, （ウィンドウマネージャが指定
を無視するかもしれませんが）`-bw N'を使います.  外部境界のデフォルトの
幅は2です.



File: emacs-ja, Node: Title X, Next: Icons X, Prev: Borders X, Up: Command Arguments

フレームタイトル
================

Emacsのフレームには, 指定したタイトルがあるかもしれないし, ないかもし
れません.  フレームタイトルを指定すると, ウィンドウの装飾部分やアイコ
ンにフレーム名として表示されます.  Emacsのフレームにタイトルが指定され
ていなければ, デフォルトのタイトルは, （フレームが1つしかない場合には）
実行プログラムの名前, あるいは, （複数のフレームがあれば）選択したウィ
ンドウのバッファの名前になります.

コマンド行オプションでEmacsの初期フレームのタイトルを指定できます.

`-title TITLE'
`--title=TITLE'
`-T TITLE'
     Emacsの初期フレームのタイトルとしてTITLEを指定する.

オプション`--name'（*Note Resources X::）もEmacsの初期フレームのタイト
ルを指定します.



File: emacs-ja, Node: Icons X, Next: Resources X, Prev: Title X, Up: Command Arguments

アイコン
========

ほとんどのウィンドウマネージャは, フレームを『アイコン化』することを許
しています.  つまり, フレームを見えなくしてから, その場所に小さな識別
しやすい『アイコン』を置きます.  アイコンウィンドウをクリックするとフ
レーム自体が再度表示されます.  一度にたくさんのクライアントを動かして
おく場合, クライアントのほとんどをアイコンにしておけば画面が乱雑になら
ずにすみます.

`-i'
`--icon-type'
     Emacsのアイコンとしてヌーの絵を使う.

`-iconic'
`--iconic'
     Emacsをアイコン化した状態で起動する.

オプション`-i'や`--icon-type'は, GNUのヌーの絵を表示したアイコンウィン
ドウを使う指定です.  省略すると, Emacsは使用するアイコンの種類をウィン
ドウマネージャに選ばせます.  これは, 通常, フレームのタイトルを含んだ
小さな長方形のウィンドウです. (1) (*Note Icons X-Footnotes::)

オプション`-iconic'は, すぐにはフレームを開かずにアイコンで始めるよう
にEmacsを起動します.  この場合, アイコンウィンドウはEmacsが起動したこ
とだけを教えてくれます.  アイコンを開くまで通常のテキストフレームは表
示されません.


File: emacs-ja  Node: Icons X-Footnotes, Up: Icons X

(1) 【訳注】uwm, twmなど古典的なウィンドウマネージャのふるまい.



File: emacs-ja, Node: Resources X, Next: Lucid Resources, Prev: Icons X, Up: Command Arguments

Xリソース
=========

Xウィンドウシステムで動いているプログラムでは, クラスとリソースの階層
によってユーザーのオプションを取りまとめます.  これらのオプションのデ
フォルト値は, `~/.Xdefaults'という名前の個人のXリソースファイルで指定
できます.

ファイル内の各行は, 1つのオプション, 関連したオプション群, 1つのプログ
ラム, あるいは, 複数（または全部）のプログラムの値を指定します.

プログラムは特定の意味を持ったリソース名を定義します.  リソースをどの
ようにクラス名にグループ化するかも定義します.  たとえば, Emacsでは, リ
ソース`internalBorder'は内部境界の幅を制御し, リソース`borderWidth'は
外部境界の幅を制御します.  どちらのリソースもクラス`BorderWidth'の一部
です.  これらの名前では大文字小文字を区別します.

`~/.Xdefaults'では, 以下のように1行に1つのリソースを指定します.

     emacs.borderWidth: 2

あるいは, クラス内のすべてのリソースに同じ値を指定するにはクラス名を使
います.  たとえば, つぎのようにします.

     emacs.BorderWidth: 2

クラスに値を指定すると, それはそのクラス内のすべてのリソースのデフォル
ト値になります.  個別にリソースの値を指定することもできます.  その場合, 
特定のリソースの値はクラスの値に優先します.  したがって, つぎの例では, 
すべての境界のデフォルトの幅として2を指定しますが, 外部境界の値は4にな
ります.

     emacs.Borderwidth: 2
     emacs.borderwidth: 4

ファイル内での行の順番は関係ありません.  また, コマンド行オプションは
つねにXリソースファイルに優先します.

上の例の文字列`emacs'もリソース名です.  この名前は, Emacsを起動するた
めに指定した実行ファイルの名前を表します.  Emacsを別の名前でインストー
ルしたならば, `emacs'のかわりにその名前のリソースを探します.

`-name NAME'
`--name=NAME'
     Emacsの初期フレームのリソース名（およびタイトル）としてNAMEを使う. 
     このオプションは, 初期フレーム以外には影響しないが, Lispプログラ
     ムからはフレーム作成時にフレーム名を指定できる.

     このオプションを指定しないと, デフォルトではEmacsの実行ファイル名
     をリソース名として使う.

`-xrm RESOURCE-VALUES'
`--xrm=RESOURCE-VALUES'
     EmacsのこのジョブだけのXリソースの値を指定する.  （以下を参照）.

整合性のために, `-name'は, どの特定のフレームにも属さないリソースの値
を探すときの名前も指定します.

Emacsを起動するコマンド名と同じ名前のリソースはクラスにも属します.  そ
の名前は`Emacs'です.  `emacs'のかわりに`Emacs'と書けば, 実行ファイルの
名前やフレームタイトルに関わらず, すべてのEmacsジョブのすべてのフレー
ムにリソースが適用されます.  たとえば, つぎのようにします.

     Emacs.BorderWidth: 2
     Emacs.borderWidth: 4

コマンド行オプション`-xrm RESOURCES'を使えば, 追加のリソースの値を
Emacsに指定できます.  テキストRESOURCESは, Xリソースファイルの中で使う
ものと同じ書式です.  DATAで複数のリソースを指定するには, ファイルの場
合と同様に, そのあいだに改行を置きます.  また, `#include "FILENAME"'を
使えば, ファイル内のリソース指定を取り込めます.  `-xrm'で指定したリソー
スの値は, これ以外のリソース指定に優先します.

以下は, Emacsのオプションを指定するリソース名とそれが属するクラスの一
覧です.

`background'（クラス`Background'）
     背景の表示色名.

`bitmapIcon'（クラス`BitmapIcon'）
     `on'ならば（ヌーの絵の）ビットマップアイコンを使う.  `off'ならば
     ウィンドウマネージャにアイコンを選ばせる.

`borderColor'（クラス`BorderColor'）
     外部境界の表示色名.

`borderWidth'（クラス`BorderWidth'）
     外部境界の（ピクセル単位の）幅.

`cursorColor'（クラス`Foreground'）
     テキストカーソル（ポイント）の表示色名.

`font'（クラス`Font'）
     テキストのフォント名（あるいはフォントセット名 *Note Fontsets::）.

`foreground'（クラス`Foreground'）
     テキストの表示色名.

`geometry'（クラス`Geometry'）
     ウィンドウのサイズと位置.  Emacsフレームだけでなく個々のメニュー
     にも影響するので, このリソースを`emacs*geometry'とは指定しないよ
     うに注意すること.

     このリソースで指定した位置は, Emacsの初期フレーム（あるいは, 特定
     のフレーム名を指定したリソースはそのフレーム）だけに適用される. 
     しかし, サイズはすべてのフレームに適用される.

`iconName'（クラス`Title'）
     アイコンに表示する名前.

`internalBorder'（クラス`BorderWidth'）
     内部境界の（ピクセル単位の）幅.

`menuBar'（クラス`MenuBar'）
     `on'ならばフレームにメニューバーを付ける.  `off'ならばメニューバー
     を付けない.

`minibuffer'（クラス`Minibuffer'）
     `none'ならばこのフレームにミニバッファを付けない.  かわりに, 独立
     したミニバッファフレームを使う.

`paneFont'（クラス`Font'）
     ツールキット版でないEmacsのメニューのタイトルに使うフォント名.

`pointerColor'（クラス`Foreground'）
     マウスカーソルの表示色.

`reverseVideo'（クラス`ReverseVideo'）
     `on'ならば前景色と背景色を入れ替え, `off'ならば指定された表示色を
     用いる.

`verticalScrollBars'（クラス`ScrollBars'）
     `on'ならばフレームにスクロールバーを付ける.  `off'ならばスクロー
     ルバーを付けない.

`selectionFont'（クラス`Font'）
     ツールキット版でないEmacsのポップアップメニューの項目に使うフォン
     ト名.  （ツールキット版では, *Note Lucid Resources::, あるいは,
     *Note Motif Resources::を参照. ）

`title'（クラス`Title'）
     Emacsの初期フレームのタイトルバーに表示する名前.

以下は, 特定のフェイス（*Note Faces::）の見え方を制御するリソースです.

`FACE.attributeFont'
     フェイスFACEのフォント.
`FACE.attributeForeground'
     フェイスFACEの前景色.
`FACE.attributeBackground'
     フェイスFACEの背景色.
`FACE.attributeUnderline'
     フェイスFACEの下線フラグ.  下線を使うには`on'か`true'を指定する.



File: emacs-ja, Node: Lucid Resources, Next: Motif Resources, Prev: Resources X, Up: Command Arguments

LucidメニューのXリソース
========================

Lucidメニューウィジェットを含めたXツールキットを使うEmacsがインストー
ルされている場合には, メニューバーは別のウィジェットであり独自のリソー
スを持ちます.  リソース名には（Emacsの起動名かすべてのEmacsの起動を意
味する`Emacs'に続けて）`pane.menubar'が含まれます.  これらはつぎのよう
に指定します.

     Emacs.pane.menubar.RESOURCE:  VALUE

たとえば, メニューバーの項目に`8x16'フォントを指定するには, つぎのよう
に書きます.

     Emacs.pane.menubar.font:  8x16

*メニューバーを使わない*ツールキットのポップアップメニューの項目のリソー
スには, 同様に, `menu*'があります.  たとえば, ポップアップメニューに
`8x16'のフォントを指定するには, つぎのように書きます.

     Emacs.menu*.font:	8x16

対話ボックスのフォントを指定するには, `menu'のかわりに`dialog'を使って
つぎのように書きます.

     Emacs.dialog*.font:	8x16

経験によれば, `pane.menubar'や`menu*'のまえに`shell.'を付ける必要があ
るシステムもあります.  他のシステムでは`shell.'を付加してはいけません.

以下は, メニューバーとポップアップメニューのリソースの一覧です.

`font'
     メニュー項目のテキストのフォント.
`foreground'
     前景色.
`background'
     背景色.
`buttonForeground'
     メニューバーにおいて, 選択した項目の前景色.
`horizontalSpacing'
     項目間の横方向のピクセル単位の間隔.  デフォルトは3.
`verticalSpacing'
     項目間の縦方向のピクセル単位の間隔.  デフォルトは1.
`arrowSpacing'
     （サブメニューを表す）矢印とそれに関連したテキストとの横方向のピ
     クセル単位の間隔.  デフォルトは10.
`shadowThickness'
     ウィジェットの周りの影付けの厚み.



File: emacs-ja, Node: Motif Resources, Next: Basic, Prev: Lucid Resources, Up: Command Arguments

MotifメニューのXリソース
========================

Motifウィジェットを含めたXツールキットを使うEmacsがインストールされて
いる場合には, メニューバーは別のウィジェットであり独自のリソースを持ち
ます.  リソース名には（Emacsの起動名かすべてのEmacsの起動を意味する
`Emacs'に続けて）`pane.menubar'が含まれます.  これらはつぎのように指定
します.

     Emacs.pane.menubar.SUBWIDGET.RESOURCE:  VALUE

メニューバーの個々の文字列はサブウィジェットです.  サブウィジェットの
名前はメニュー項目の文字列と同じです.  たとえば, メニューバーの中の単
語`Files'は`emacs.pane.menubar.Files'という名前のサブウィジェットの一
部です.  ほとんどの場合, メニューバー全体に同じリソースを指定するでしょ
う.  それには, 特定のサブウィジェット名のかわりに`*'を使います.  たと
えば, `8x16'フォントをメニューバーの項目に使うには, つぎのようにします.

     Emacs.pane.menubar.*.fontList:  8x16

これは, サブメニューのリソース値も指定します.

メニューバー内のサブメニューの各項目には, それぞれ独自のXリソース名が
あります.  たとえば, `Files'サブメニューには項目`Save Buffer'がありま
す.  サブメニューの項目のリソース指定はつぎのようになります.

     Emacs.pane.menubar.popup_*.MENU.ITEM.RESOURCE: VALUE

たとえば, `Save Buffer'のフォントを指定するには, つぎのようにします.

     Emacs.pane.menubar.popup_*.Files.Save Buffer.fontList: 8x16

`Edit'の下の`Spell'の下にある`Check Message'のような2段下のサブメニュー
の項目では, リソースの雛型はつぎのようになります.

     Emacs.pane.menubar.popup_*.popup_*.MENU.RESOURCE: VALUE

たとえば, つぎのようになります.

     Emacs.pane.menubar.popup_*.popup_*.Spell.Check Message: VALUE
  
サブメニューのリソースを指定せずに, すべてのメニューバーの項目のリソー
スを指定することは不可能です.  サブメニューの項目をメニューバー自体と
は異なる見え方にするには, 2段階の指定が必要です.  まずメニューバーのリ
ソースを指定し, そのあとでサブメニューの値だけを上書きします.  たとえ
ば, つぎのようにします.

     Emacs.pane.menubar.*.fontList:  8x16
     Emacs.pane.menubar.popup_*.fontList: 8x16

ツールキットのポップアップメニューでは, `pane.menubar'のかわりに
`menu*'を使います.  たとえば, ポップアップメニューの項目に`8x16'フォン
トを指定するには, つぎのように書きます.

     Emacs.menu*.fontList:  8x16

以下は, メニューバーとポップアップメニューのリソース指定の一覧です.

`armColor'
     押せるボタンの表示色.
`fontList'
     使用するフォント.
`marginBottom'
`marginHeight'
`marginLeft'
`marginRight'
`marginTop'
`marginWidth'
     境界内で項目の周りに置く空白の量.
`borderWidth'
     メニュー項目を縁取る境界の幅.
`shadowThickness'
     境界の影付けの幅.
`bottomShadowColor'
     境界の下端と右端の影付けの表示色.
`topShadowColor'
     境界の上端と左端の影付けの表示色.




File: emacs-ja, Node: Antinews, Next: MS-DOS, Prev: Command Arguments, Up: Top

Emacs 19逆向きニュース
**********************

過去に暮す方々のために, Emacsバージョン19への格下げ情報です.  Emacs 20
のある種の機能の欠落による大いなる簡潔さを甘受されることを願って.

   * マルチバイト文字対応と行末変換機能は完全に除去してある.  （これを
     とてつもない進歩ととらえる人もいる. ）文字コードは0から255の範囲
     に限られる.  また, UNIX流のシステムに持ち込んだファイルでは,
     MS-DOG型のファイルを扱っていることを警告するために, 各行の末尾に
     ^Mがあることがある.

   * 同様に, フォントセット, コーディングシステム, 入力方式も除去した.

   * どのエディタを使っているか忘れないように, 通常, モード行には
     `Emacs'と表示する.

   * スクロールバーはつねにウィンドウの右側にある.  これで, ウィンドウ
     内のテキストとはっきり区別できる.

   * `M-x customize'の機能は, とても簡潔な機能の`M-x edit-options'に置
     き換えた.  これで*すべて*のユーザーオプションを先頭から眺めること
     ができ, あちこち探しまわる必要はないだろう.  また, これには`s'や
     `x'のようにユーザーオプションを設定するコマンドもいくつかある.

   * Emacs19では, マウスでリージョンを選択したあとにDELETEキーを使って
     も特別なことは何も起こらない.  マウスを操作していないときと同じよ
     うに動作し, 単に直前の1文字を削除する.

   * `C-x C-w'は, 新しいファイル名に合わせてメジャーモードを変更しない. 
     モードを変更するには, `M-x normal-mode'を使う.

   * 暫定（transient-mark）マークモードでは, どのウィンドウにおいても
     ウィンドウ内にリージョンがある限りそれを強調表示する.

   * アウトライン（outline）モードでは, 上書き属性を使わない.  かわり
     に, まえにある改行文字をコード015に変更して行を隠す.  たとえこの
     ままファイルに保存しても, ファイル内では文字コード015は改行に戻っ
     ている.

   * `enable-recursive-minibuffers'が`nil'であっても, ミニバッファを再
     帰的に利用する賢い方法がある.  ミニバッファ以外の*ウィンドウに切
     り替え*てから, ミニバッファコマンドを使うだけでよい.  このように
     すれば何段でもミニバッファのレベルを積み重ねられるが, `M-x
     top-level'でもとに戻ってしまう.

   * ミニバッファ履歴リストの長さの制限を取り除いた.  このリストは, セッ
     ション開始時から入力したすべてのミニバッファ引数を保持する.

   * 動的略語展開では, とても簡潔にかつ素直に大文字小文字変換を扱う. 
     大文字小文字を保存するように指定してあると, 打ち込んだ略語の大文
     字小文字のパターンと同じになるように展開する.

   * コマンド`compose-mail'はなくなった.  現在, `C-x m'は`mail'を直接
     実行する.

   * 特殊文字を含むファイル名をクォートする方法はない.  見た目とおりの
     ものを得る.  つまり, リモートにあるように見える名前のものはリモー
     トにある.

   * `grep'がなくなることはないので, `M-x grep-find'は除去した.


   * diredのコマンドを若干再配置した.  つまり, 2文字列のコマンドは軽快
     な1文字のコマンドに置き換えた.

        * `dired-mark-executables'は`*'
        * `dired-mark-directories'は`/'
        * `dired-mark-symlinks'は`@'
        * `dired-change-marks'は`c'
        * `dired-unmark-all-files'は`C-M-?'
        * `dired-unmark-all-marks'は`C-M-? RET'

     ただし, `dired-flag-garbage-files'は`&'と打つので, この場合には過
     去にひたっていられなくなる.

   * Cモードでは, ブロックコメントに好きなスタイルを指定できる.  たと
     えば,

          /*       
          blah     
          blah     
          */       

     というスタイルを利用するには, 変数`c-block-comments-indent-p'を
     `t'にする.

   * フォントロック（font-lock）モードが使用するフェイスをカスタマイズ
     するには, 変数`font-lock-face-attributes'を使う.  詳しくは, この
     変数の説明文字列を参照.

   * 効率のために, フォントロック（font-lock）モードは, 選択したメジャー
     モード用の飾りとしては最小限のものをデフォルトで使用する.

   * バッファを消去すると, そのバッファ内の位置を保持していたレジスタ
     の値は, 牢獄を指すようになる.

   * 関数`set-frame-font'は`set-default-font'と改名した.

   * 変数`tex-main-file'はなくなった.  もちろん, 値を設定すればこの変
     数を作成できるが, 特に何をするわけでもない.

   * 変数`scroll-preserve-screen-position'とこの変数で制御していた機能
     は除去した.

   * 関数`add-untranslated-filesystem'と関数
     `remove-untranslated-filesystem'は除去し, より簡潔な関数
     `using-unix-filesystems'で置き換えた.

   * コンピュータの記憶容量が減少し続けるため, Emacs 19では他の数多く
     の関数やファイルも除去した.  それらをすべてここで取り上げる必要は
     あるまい.  それらのどれかを使うと, 「undefined（未定義）」とか
     「unbound（未束縛）」というエラーメッセージが出る.


File: emacs-ja, Node: MS-DOS, Next: Manifesto, Prev: Antinews, Up: Top

EmacsとMS-DOS
*************

ここでは, （『MS-DOG』とも呼ばれる）MS-DOS『オペレーティングシステム』
で稼働するEmacsの癖について簡単にふれます.  MS-DOS用に作成したEmacsの
バイナリは, Windows 3.x, Windows NT, Windows 9X, OS-2上でDOSアプリケー
ションとしても動作します.  MS-DOS用に作成したEmacsを使っている限り, 本
章の情報はこれらすべてのシステムにあてはまります.

Windows NTやWindows 9Xに専用のEmacsを作ることも可能です.  その場合には, 
本章のほとんどは関係ありません.  長いファイル名, 複数のフレーム, スク
ロールバー, マウスメニュー, サブプロセスの利用を含めて, 本書の他の部分
で説明した動作に近い動作をします.  しかし, テキストファイルとバイナリ
ファイルに関する節は適用できます.  また, 本章の最後の2つの節は,
Windows NTと9Xだけに適用できます.

* Menu:

* Input: MS-DOS Input.         Keyboard and mouse usage on MS-DOS.
* Display: MS-DOS Display.     Fonts, frames and display size on MS-DOS.
* Files: MS-DOS File Names.    File name conventions on MS-DOS.
* Text and Binary::            Text files on MS-DOS use CRLF to separate lines.
* Printing: MS-DOS Printing.   How to specify the printer on MS-DOS.
* I18N: MS-DOS and MULE.       Support for internationalization on MS-DOS.
* Processes: MS-DOS Processes. Running subprocesses on MS-DOS.
* Windows Processes::          Running subprocesses on Windows.
* Windows System Menu::        Controlling what the ALT key does.



File: emacs-ja, Node: MS-DOS Input, Next: MS-DOS Display, Prev: MS-DOS, Up: MS-DOS

MS-DOSのキーボードとマウス
==========================

PCのキーボードの左側のALTキーは, METAキーに割り当てられます.  SUPERキー
とHYPERキーのエミュレーションには, 選択肢が2つあります.  変数
`dos-hyper-key'と`dos-super-key'を1にすれば, 右側のCTRLキーを選びます. 
変数`dos-hyper-key'と`dos-super-key'を2にすれば, 右側のALTキーを選びま
す.  `dos-super-key'と`dos-hyper-key'のいずれも1でなければ, デフォルト
で右側のALTキーもMETAに割り当てられます.  しかし, MS-DOSの国際化キーボー
ド用プログラム`KEYB.COM'をインストールしてある場合は, 右側のALTをMETA
には割り当て*ません*.  というのは, 米国配列のキーボードでない場合, 右
側のALTは`~'や`@'として使われるからです.  この場合には, 左側のALTのみ
をMETAとして使えます.

変数`dos-keypad-mode'は, 数字キーパッド上のキーが返すキーコードを制御
する変数です.  ファイル`_emacs'につぎの行を入れておけば, ENTERキーが
`C-j'として働くように定義できます.

     ;; 数字キーパッドのEnterキーをC-jとして動作させる. 
     (define-key function-key-map [kp-enter] [?\C-j])

（ほとんどのワークステーションでの呼称から）EmacsでDELと呼ばれるキーは,
PCではBS（バックスペース）です.  このため, PC特有の端末初期化において
は, BSキーはDELとして動作するようにしています.  同じ理由から, DELキー
は C-dとして動作するようにしてあります.

MS-DOS用のEmacsでは, `C-BREAK'を`C-g'のような中断文字として認識します. 
これは, Emacsが入力を読もうとしないと`C-g'が打鍵されたことを検出できな
いからです.  そのため, 動作中のコマンドを止めるために`C-g'を使えません
（*Note Quitting::）.  対照的に, `C-BREAK'は（他のシステムでの`C-g'の
ように）打鍵するとすぐに検出*される*ので, 動作中のコマンドを停止したり
緊急脱出したりするために使えます（*Note Emergency Escape::）.

MS-DOS用Emacsは, （デフォルトの端末だけで）マウスを使えます.  メニュー
やメニューバー（*Note Menu Bar::）の利用を含めて, マウスコマンドはドキュ
メントどおりに動作します.  MS-DOS用Emacsではスクロールバーは使えません.
PCのマウスには, 通常, 2つのボタンしかありません.  これらは`Mouse-1'と
`Mouse-2'として動作しますが, 2つのボタンを同時に押せば`Mouse-3'として
動作します.

MS-DOS用EmacsがWindows上で動作している場合には, クリップボードの操作を
利用できます.  キルリングにテキストを置いたり, キルリングからテキスト
をヤンクしたりするコマンドでは, Xウィンドウシステムの場合と同様に, ま
ずWindowsのクリップボードを調べます（*Note Mouse Commands::）.
Windows上のMS-DOS用Emacsは, 一次セレクションとカットバッファのみを利用
し, 二次セレクションはつねに空です.

Windowsで実装されているクリップボードの参照方法のため, クリップボード
に置けるテキストの長さは, Emacsが利用できるDOSの空きメモリ量に制限され
ます.  通常, 620Kバイトまでのテキストをクリップボードに置けますが, こ
の上限はシステムの設定に依存し, 他のプログラムのサブプロセスとして
Emacsを実行しているときには少なくなります.  削除したテキストがクリップ
ボードに入りきらなければ, Emacsはその旨のメッセージを出力して, テキス
トをクリップボードへ置きません.

Windowsのクリップボードにはナル文字を入れられません.  キルしたテキスト
にナル文字が含まれる場合には, Emacsはそのようなテキストをクリップボー
ドへ置きません.  さらに, エコー領域には, その旨, メッセージを表示しま
す.

変数`dos-display-scancodes'の値が`nil'以外のときには, キーを打つたびに,
Emacsは各キーのASCII（コードの）値とキーボードスキャンコードを出力しま
す.  この機能は, デバッグ用のコマンド`view-lossage'を補佐します.



File: emacs-ja, Node: MS-DOS Display, Next: MS-DOS File Names, Prev: MS-DOS Input, Up: MS-DOS

MS-DOSの画面
============

MS-DOSの画面では, ボールド体（太字体）やイタリック体（斜体）などのフォ
ントの変種を使えませんが, 個々に前景色と背景色を指定できるフェイスを複
数個使えます.  したがって, 関連するフェイスに異なる表示色を定義すれば, 
（`font-lock', エンリッチ（enriched）モードなどの）フォントを用いる
Emacsのパッケージの全機能を利用できます.  コマンド
`list-colors-display'（*Note Frame Parameters::）とコマンド
`list-faces-display'（*Note Faces::）を使えば, 利用可能なフェイスと表
示色, それらの見え方を知ることができます.

本章の*Note MS-DOS and MULE::では, DOSの画面に組み込まれたフォントでは
表せない字形や文字をEmacsがどのように表示するかを説明します.

MS-DOSでも複数のフレーム（*Note Frames::）を利用できます.  しかし, そ
れらはすべて重なっているので, 一度には1つのフレームしか見ることができ
ません.  見えている1つのフレームが画面全体を覆います.  MS-WindowsのDOS
ボックスでEmacsを実行しているときには, 見えているフレームを画面全体よ
り小さくはできますが, それでも, 一度に1つのフレームしか表示できません.

コマンド`mode4350'は43行表示と50行表示を切り替えますが, ハードウェアに
依存します.  コマンド`mode25'は, デフォルトの80x25の画面サイズに切り替
えます.

デフォルトでは, Emacsは80桁で, 25行, 28行, 35行, 40行, 43行, 50行の画
面サイズしか知りません.  しかし, ビデオアダプタに別の画面サイズに切り
替える特別なビデオモードがあれば, Emacsでもそれらを利用できます.
EmacsにフレームサイズをN行M桁に切り替える指示をすると,
`screen-dimensions-NxM'という変数があるかどうか調べます.  変数があれば, 
その値（整数である必要がある）を切り替え先のビデオモードとして使います. 
（Emacsは, `screen-dimensions-NxM'の値をレジスタ`AL'に入れ, BIOSの関数
`Set Video Mode'を呼び出し, ビデオモードを切り替えます. ）たとえば, ビ
デオモードを85にすると66x80の画面に切り替わるアダプタがあるとします.
`_emacs'につぎの行を加えれば, Emacsでこの画面サイズを使えるようになり
ます.

     (setq screen-dimensions-66x80 85)

MS-DOS用Emacsでは, フレームサイズは利用可能な特定のサイズにしか設定で
きませんから, フレームサイズの変更要求すべてに答えられるわけではありま
せん.  使えないサイズが要求されると, Emacsは指定されたサイズのつぎに大
きいサイズを選びます.  たとえば, 36x80のフレームを要求すると, かわりに,
40x80になります.

変数`screen-dimensions-NxM'は, 指定サイズに正確に一致するときだけ使わ
れます.  利用可能なつぎに大きなサイズの候補を探すときには無視します. 
上述の例では, VGAで38x80を使えて, 変数`screen-dimensions-38x80'に適切
な値を定義したとしても, 36x80のフレームを要求した場合には, 40x80の画面
になってしまいます.  このような場合に38x80のサイズにしたければ, 変数
`screen-dimensions-36x80'にも`screen-dimensions-38x80'と同じビデオモー
ドの値を入れます.

MS-DOSでは, フレームサイズを変更すると, 他のすべてのフレームのサイズも
変更してしまいます.



File: emacs-ja, Node: MS-DOS File Names, Next: Text and Binary, Prev: MS-DOS Display, Up: MS-DOS

MS-DOSにおけるファイル名
========================

他のシステムではファイル名の構成要素の区切りにはスラッシュを使いますが,
MS-DOSでは, 普通, バックスラッシュ`\'を使います.  MS-DOS用Emacsでは, 
スラッシュもバックスラッシュも使えて, さらに, ファイル名に含まれるドラ
イブ名も理解します.

MS-DOSでは, ファイル名に大文字小文字の区別はなく8文字に制限されますが, 
ピリオドとさらに3文字を付加できます.  Emacsは他のシステム向けのファイ
ル名を扱ううえで, これらの制限を熟知しています.  たとえば, ドット`.'で
始まるファイル名は, MS-DOSでは正しくないので, Emacsはそれを透過的に下
線`_'に変換します.  したがって, デフォルトの初期化ファイル（*Note Init
File::）は, MS-DOSでは`_emacs'と呼ばれます.  ピリオドの前後の文字数制
限を越えた部分は, 通常, MS-DOSが無視します.  したがって, ファイル
`LongFileName.EvenLongerExtension'を訪れると, 実際には`longfile.eve'を
訪れることになりますが, モード行にはもとの長い名前が表示されます.  こ
れ以外には, MS-DOSにおいて正しいファイル名を指定するのは, ユーザーの責
任です.  上述した透過的な変換は, Emacsに組み込まれたファイル名にのみに
作用します.

MS-DOSでの上述のファイル名の制限のために, もとのファイル名の文字をいく
つか捨てずにバックアップファイル（*Note Backup Names::）の名前を構成す
ることは不可能です.  たとえば, バックアップを1つしか使っていなくても,
`docs.txt'のバックアップファイルの名前は`docs.tx~'となります.

Windows 9x上のDOSアプリケーションとしてEmacsを実行する場合には, 長いファ
イル名の使用を有効にできます.  そうすると, Emacsは, ファイル名を切り詰
めたり小文字に変換したりせずに, 指定したとおりのファイル名をそのまま使
います.  長いファイル名の使用を有効にするには, Emacsを起動するまえに, 
環境変数`LFN'に`y'と設定します.  残念ながら, Windows NTではDOSプログラ
ムから長いファイル名を使えませんので, MS-DOS用Emacsからは短い8+3の別名
しか見えません.

MS-DOSにはホームディレクトリという概念がないので, MS-DOS用Emacsでは,
Emacsをインストールしてあるディレクトリを環境変数`HOME'の値であるとい
うことにします.  つまり, Emacsのバイナリ`emacs.exe'がディレクトリ
`c:/utils/emacs/bin'に置いてあるとすれば, Emacsは, 環境変数`HOME'が
`c:/utils/emacs'と設定されているかのようにふるまいます.  特に, ここが
初期化ファイル`_emacs'を探す場所となります.  このことを心に留めておけ
ば, UNIXでのように, ホームディレクトリの別名としてファイル名に`~'を使
えます.  Emacsを起動するまえに環境変数`HOME'を設定することもでき, その
場合には, 上述のデフォルトのふるまいに優先します.

DJGPPのエミュレーションライブラリの機能では入出力装置はディレクトリ
`/dev'に置かれていると仮定するので, MS-DOS用Emacsはディレクトリ名
`/dev'を特別扱いします.  いかなるディスク上でも`/dev'というディレクト
リ名を使わないように忠告しておきます.



File: emacs-ja, Node: Text and Binary, Next: MS-DOS Printing, Prev: MS-DOS File Names, Up: MS-DOS

テキストファイルとバイナリファイル
==================================

GNU Emacsでは, テキスト行の区切りとして改行文字を使います.  これは,
GNU Emacsが開発されたUNIXでの習慣であり, UNIXをモデルとしたGNUシステム
での習慣でもあります.

MS-DOSとMS-Windowsでは, テキスト行の区切りとして, 通常, 復帰・行送りの
2文字列を使います.  （行送りは改行と同じ文字です. ）したがって, Emacs 
において典型的なファイルを便利に編集するには, これらの行末
（end-of-line, EOL）文字列を変換する必要があります.  Emacsは通常つぎの
ようにします.  ファイルを読み込むときには復帰・行送りを改行に変換し, 
ファイルを書き出すときには改行を復帰・行送りに変換します.  国際文字コー
ドの変換を扱う機構でもこの変換を行います（*Note Coding Systems::）.

ほとんどのファイルにおけるこの特別な書式変換のために, Emacsが報告する
文字位置（*Note Position Info::）は, オペレーティングシステム上でのファ
イルサイズ情報と食い違います.

内容がテキストではないある種のファイルは, 変換すべきではありません. 
したがって, MS-DOS用Emacsは, ある種のファイルを"バイナリファイル"とし
て区別して, そのまま読み書きします.  （この区別はMS-DOSのものではなく,
Emacsがもたらすものです. ）これらには, 実行プログラム, 圧縮したアーカ
イブなどが含まれます.  Emacsはファイル名を用いて, バイナリファイルとし
て扱うべきかどうか決定します.  変数`file-name-buffer-file-type-alist'
には, バイナリファイルを表すファイル名のパターンを定義しておきます.
`file-name-buffer-file-type-alist'に指定したバイナリファイルのパターン
にファイル名が一致すると, Emacsは行末変換だけでなく*すべて*の符号変換
を抑制するコーディングシステム（*Note Coding Systems::）
`no-conversion'を使います.

さらに, Emacsは, ファイルの内容から行区切りとして復帰・行送りでなく改
行を用いていると判断すると, ファイルの読み書きにおいて変換を行いません. 
したがって, 特に努力しなくても, UNIXやGNUシステムからのファイルを
MS-DOS上で読んだり編集でき, それらのファイルの行末はUNIX流の行末のまま
です.

コマンド`find-file-text'やコマンド`find-file-binary'を用いると, ファイ
ルをテキストとして扱うかバイナリとして扱うかを指定して訪れることができ
ます.  行末変換はコーディングシステムの一般的な変換機構の一部なので, 
コーディングシステムを指定するコマンド（*Note Specify Coding::）によっ
てファイルをテキストとして扱うかバイナリとして扱うかを指定することもで
きます.  たとえば, `C-x RET c undecided-unix RET C-x C-f foobar.txt' 
とすれば, 行末変換をせずにファイル`foobar.txt'を訪れることができます.

モード行にはカレントバッファで行末変換を行ったかどうか表示されます. 
モード行の始めのほうにあるコーディングシステムを表す文字のうしろには, 
通常, コロンが表示されます.  バッファでMS-DOSの行末変換を使っている場
合には, この文字はバックスラッシュに変わります.

NFSやSambaを用いてUNIXやGNUシステムを使ったコンピュータ上のファイルシ
ステムを参照するとき, これらのファイルシステム上のどのファイルに対して
は, 新規作成時でなくても, Emacsは行末変換を行うべきではありません.  こ
うするためには, 該当するファイルシステムを"無変換"のファイルシステムと
指定するために, 関数`add-untranslated-filesystem'を呼びます.  この関数
は, ファイルシステム名である引数を1つとりますが, これにはドライブ名や
ディレクトリ名を含めることもできます.  たとえば,

     (add-untranslated-filesystem "Z:")

は, ドライブZを無変換のファイルシステムとして指定しますし,

     (add-untranslated-filesystem "Z:\\foo")

は, ドライブZ上のディレクトリ`\foo'を無変換のファイルシステムとして指
定します.

個人の`_emacs'ファイルやサイトの全ユーザーに便利なように
`site-start.el'の中で, `add-untranslated-filesystem'を使うことが多いで
しょう.

`add-untranslated-filesystem'の効果を取り消すには, 関数
`remote-untranslated-filesystem'を使います.  この関数は, まえに
`add-untranslated-filesystem'に使ったのと同じ文字列を引数としてとりま
す.



File: emacs-ja, Node: MS-DOS Printing, Next: MS-DOS and MULE, Prev: Text and Binary, Up: MS-DOS

印刷とMS-DOS
============

`lpr-buffer'（*Note Hardcopy::）や`ps-print-buffer'（*Note
Postscript::）のような印刷コマンドは, UNIX流のプログラム`lpr'がない場
合には, プリンタポートに直接出力を送ればMS-DOSやMS-Windowsでも動作しま
す.  このふるまいは, UNIX上の`lpr'での印刷（*Note Hardcopy::, *Note
Postscript Variables::）を制御する変数と同じ変数で制御されますが,
MS-DOSやMS-Windows上でのこれらの変数のデフォルト値は, UNIX上での値と同
じではありません.

DOS流の通常の印刷のように, ローカルのプリンタを使いたい場合には, Lisp
変数`lpr-command'に`""'（デフォルト値）を設定し, `printer-name'にはプ
リンタポートの名前を設定します.  たとえば, ローカルのプリンタポートな
らば（デフォルト値の）`"PRN"'や`"LPT2"', シリアルプリンタならば
`"COM1"'です.  `printer-name'にはファイル名も設定できます.  その場合に
は, 『印刷』結果は, そのファイルに追加書きされます.  `printer-name'に
`"NUL"'を設定すると, 印刷結果は（システムの空デバイスに送られて）黙っ
て捨てられます.

MS-Windowsでは, Windowsのネットワークソフトウェアをインストールしてあ
れば, `printer-name'に, 他のマシンとの共用プリンタのUNC共用名（たとえ
ば`"//joes_pc/hp4si"'）を設定すれば, そのプリンタを利用することもでき
ます.  （スラッシュでもバックスラッシュでもかまいません. ）共用プリン
タの名前を調べるには, DOSコマンドプロンプトで`net view'を実行してサー
バー一覧を取得してから, `net view SERVER-NAME'を実行してサーバーが共有
するプリンタ（とディレクトリ）の名前を調べます.

`printer-name'にファイル名を設定するときには, 絶対ファイル名を使うのが
最良です.  Emacsは, カレントバッファのデフォルトディレクトリに応じて作
業ディレクトリを変更します.  `printer-name'のファイル名が相対的である
と, 印刷を行ったバッファのディレクトリごとに, そのような名前のファイル
ができてしまいます.

コマンド`print-buffer'や`print-region'は, 各印刷ページに見出しを付ける
ために, `pr'プログラムを呼び出したり, `lpr'プログラムに対して特別なフ
ラグを使います.  MS-DOSやMS-Windowsには, 通常, これらのコマンドはあり
ませんから, デフォルトでは, 変数`lpr-headers-switches'は, ページ見出し
を付ける要求を無視するように設定してあります.  したがって,
`print-buffer'や`print-region'は, それぞれ, `lpr-buffer'や`lpr-region'
と同じ出力になります.  （たとえばGNU Textutilsなどの）適当な`pr'プログ
ラムがあるならば, `lpr-headers-switches'に`nil'を設定します.  すると,
Emacsはページ見出しを付けるために`pr'を呼び出し, `printer-name'の指定
に従って出力結果を印刷します.

`lpr'と同じ動作をする`lpr'がある場合には, 変数`lpr-command'に`"lpr"'と
設定できます.  すると, 他のシステムと同様に, Emacsは`lpr'を使って印刷
します.  （プログラム名が`lpr'でない場合には, `lpr-command'にはプログ
ラムを探す場所を設定する. ）`lpr-command'が`""'以外の場合には, 変数
`lpr-switches'には標準的な意味があります.  変数`printer-name'の値が文
字列である場合には, UNIXの場合と同様に, `lpr'のオプション`-P'の値とし
て使われます.

同様の一連の変数, `ps-lpr-command', `ps-lpr-switches',
`ps-printer-name'（*Note Postscript Variables::）は, PostScriptファイ
ルの印刷方法を定義します.  これらの変数は, 上に述べた非PostScript印刷
用の対応する変数と同じように使われます.  つまり, `ps-printer-name'の値
は, 非PostScript印刷での`printer-name'の使い方と同様に, PostScript出力
の送り先の装置（やファイル）の名前として使われます.  （つまり, 別々の2
つのポートに2台のプリンタを接続してあり, その一方がPostScriptプリンタ
の場合, 異なる2組の変数群を使える. ）

変数`ps-lpr-command'のデフォルト値は`""'であり, PostScript出力を
`ps-printer-name'で指定するプリンタポートへ送ることを意味します.  しか
し, `ps-lpr-command'には, PostScriptファイルを受理するプログラムの名前
を設定してもかまいません.  つまり, 非PostScriptプリンタがある場合, こ
の変数に（Ghostscriptなどの）PostScriptインタープリタプログラムの名前
を設定できます.  インタープリタプログラムに渡す必要があるオプションは,
`ps-lpr-switches'を用いて指定します.  （`ps-printer-name'の値が文字列
の場合, その値は, オプション`-P'の値として, オプション列に付加される. 
これは, `lpr'を使う場合にだけ有用であろう.  というのは, インタープリタ
を使う場合, 典型的には, `ps-printer-name'には文字列以外を設定して無視
させる. ）

たとえば, ポート`LPT2'に接続したEpsonプリンタに印刷するために
Ghostscriptを使うには, つぎの内容を個人のファイル`_emacs'に入れます.

     (setq ps-printer-name t)  ; Ghostscriptは -P を理解しない
     (setq ps-lpr-command "c:/gs/gs386")
     (setq ps-lpr-switches '("-q" "-dNOPAUSE"
     			"-sDEVICE=epson"
     			"-r240x72"
     			"-sOutputFile=LPT2"
     			"-Ic:/gs"))

（この例では, ディレクトリ`"c:/gs"'にGhostscriptをインストールしてある
と仮定. ）

MS-DOSとMS-Windowsでは, 後方互換のために, `dos-printer'（や
`dos-ps-printer'）の値を設定してあると, `printer-name'（や
`ps-printer-name'）の値を上書きします.




File: emacs-ja, Node: MS-DOS and MULE, Next: MS-DOS Processes, Prev: MS-DOS Printing, Up: MS-DOS

MS-DOSでの国際化対応
====================

MS-DOS上のEmacsは, UNIXや他のプラットフォーム上と同じ国際化文字集合を
扱えます（*Note International::）.  これには, 異なる文字集合のあいだの
変換を行うコーディングシステムも含みます.  しかしながら,
MS-DOS/MS-WindowsとUNIXとの非互換性に起因するDOSに固有な特色があり, ユー
ザーは理解しておく必要があります.  本節では, これらの特色について述べ
ます.

`M-x dos-codepage-setup'
     Emacs画面とコーディングシステムをカレントDOSコードページに適した
     ものに設定する.

`M-x codepage-setup'
     特定のDOSコードページ用のコーディングシステムを作成する.

MS-DOSは, 一度には256文字から成る単一の文字集合を扱えるように設計され
ていますが, さまざまな文字集合から選択できます.  代替文字集合は, "DOS
コードページ"と呼ばれます.  各コードページは, 128個の全ASCII文字を含み
ますが, 残りの128文字（コード128〜255）は, コードページごとに異なりま
す.  各DOSコードページは, 850や862などの3桁の数字で識別します.

同時に複数のフォントを使えるXウィンドウに比べると, MS-DOSでは1つのセッ
ションでは複数のコードページを使えません.  MS-DOSはシステムブート時に
単一のコードページをロードします.  コードページを変更するにはMS-DOSを
リブートする必要があります (1) (*Note MS-DOS and MULE-Footnotes::).
MS-Windowsなどの他のシステムでDOSプログラムを実行する場合にも, 同様の
制約が課せられます.

MS-DOS上でオプション`--unibyte' （*Note Initial Options::）を指定して
Emacsを起動すると, Emacsは, いかなる変換も非ASCII文字には行いません. 
非ASCII文字はそのまま読み書きし, 画面には8ビットコードをそのまま送りま
す.  つまり, MS-DOS上のユニバイトEmacsは, なんであれカレントコードペー
ジを使いますが, それ以外の文字を表現することはできません.

MS-DOS上でのマルチバイト操作には, Emacsは, 選択されているDOSコードペー
ジで表示できる文字群を知っておく必要があります.  そのため, 起動後, 選
択しているコードページ番号をシステムに問い合わせ, 変数`dos-codepage'に
その番号を保存します.  実際に使っているコードページとは異なっていても, 
カレントコードページのデフォルト値437を返すシステムもあります.  （典型
的には, ディスプレイ装置に組み込まれたコードページを使用すると発生する. 
）個人の初期化ファイルで変数`dos-codepage'を設定すれば, Emacsが使うコー
ドページ（番号）を別のものに指定できる.

マルチバイトEmacsは, 特定のDOSコードページだけを扱えます.  これらには, 
日本語用コードページ932のような極東の文字を表示できものや, 単一のISO
8859文字集合を符号化できるものが含まれます.

極東用コードページは, それらの国々用のMULE文字集合の1つを直接表示でき
ますから, Emacsは, コードページで扱える適切な端末コーディングシステム
を設定するだけです.  本節の残りで述べる特別な機能は, ISO 8859文字集合
を符号化するコードページに関することです.

ISO文字集合の1つに対応したコードページに対しては, Emacsはコードページ
番号に基づいた文字集合名を知っています.  Emacsは, カレントコードページ
を用いたファイルの読み書きを扱うコーディングシステムを自動的に作成し, 
デフォルトでこのコーディングシステムを使います.  コードページ番号をNNN 
とすると, このようなコーディングシステムの名前は`cpNNN'です. (2)
(*Note MS-DOS and MULE-Footnotes::)

すべての`cpNNN'コーディングシステムは, モード行の表示に（『DOS』の）文
字`D'を使います.  端末コーディングシステムとファイル入出力用のデフォル
トのコーディングシステムは, 起動時に, 正しく`cpNNN'コーディングシステ
ムに設定されますから, MS-DOSでは, モード行は普通`-DD\-'で始まります.
*Note Mode Line::.  極東用DOS端末は, `cpNNN'コーディングシステムを使用
せず, そのため, 初期のモード行はUNIXのようになります.

コードページ番号は, 使用する文字群を指定しますから, Emacsは, その文字
群用の言語環境を選択するために`set-language-environment'を自動的に実行
します（*Note Language Environments::）.

バッファ内に異なるISO 8859文字集合に属する文字, すなわち, 選択している
DOSコードページで扱えない文字が含まれる場合, Emacsはその文字をASCII文
字の列で表示します.  たとえば, カレントコードページに文字``o' （アクサ
ングレーブ付きの小文字の`o'）の字形がないときには, 中括弧で囲って1文字
であることを表して, `{`o}'と表示します.  （このようにすると, ギリシャ
文字やヘブライ文字などの非Latin文字のなかには, とても見難くなるのもが
あるが, その言語を知っている人には少なくとも読める. ）1文字でも画面上
は数桁を占めますが, 実際には単一の文字であり, Emacsのすべてのコマンド
も1文字として扱います.

DOSコードページ内のすべての文字がISO 8859文字に対応するわけではなく, 
箱を描くための文字や他の図形用文字もあります.  Emacs内部ではこれらの文
字を表現できませんので, これらの文字を含んだファイルを読み込むと, これ
らの文字は, 変数`dos-unsupported-character-glyph'で指定した特定の文字
コードに変換されます.

Emacsは, ISO 8859以外の他の多く文字集合を扱えますが, それらをMS-DOS上
では表示できません.  そのようなマルチバイト文字がバッファ内にあると,
MS-DOS上のEmacsは, 変数`dos-unsupported-character-glyph'の指定どおりに
表示します.  デフォルトでは, その字形は, 白抜きの三角形です.  コマンド
`C-u C-x ='を使って, そのような文字の実際の文字コードと文字集合を表示
してください.  *Note Position Info::.

デフォルトでは, Emacsはカレントコードページを扱えるコーディングシステ
ムを定義します.  （他国のDOSマシンで書いたファイルを訪問するなどの）他
のコードページ用のコーディングシステムを定義するには, コマンド`M-x
codepage-setup'を使います.  これは, 3桁のコードページ番号を問い合わせ
てきますが, 補完を使えます.  そして, 指定したコードページ用のコーディ
ングシステムを作成します.  これで, 新たなコーディングシステムを使って
ファイルを読み書きできますが, このコーディングシステムを使うには, ファ
イルコマンドで明示する必要があります（*Note Specify Coding::）.

これらのコーディングシステムは, DOSコードページで符号化したファイルを
他のオペレーティングシステム上のEmacsで訪問する場合にも利用できます.


File: emacs-ja  Node: MS-DOS and MULE-Footnotes, Up: MS-DOS and MULE

(1) 通常, 1つの特定のコードページはディスプレイメモリに組み込んであり, 
他のコードページは, `CONFIG.SYS'などのシステム設定ファイルを変更
してリブートするとインストールできる.

(2) ISO 8859用のEmacsの標準コーディングシステムは, この目的には正しく
ない.  というのは, 典型的なDOSコードページは, 標準のISO文字集合に一致
しない.  たとえば, 文字`c,'（セディーユ付きの`c'）は, 標
準のLatin-1文字集合ではコード231であるが, 対応するDOSコードページ850で
はこの文字はコード135である.



File: emacs-ja, Node: MS-DOS Processes, Next: Windows Processes, Prev: MS-DOS and MULE, Up: MS-DOS

サブプロセス（MS-DOS）
======================

MS-DOSはシングルプロセスの『オペレーティングシステム』なので, 非同期な
サブプロセスは利用できません.  特に, シェル（shell）モードやその派生モー
ドは動きません.  綴りの修正やGUDなどの非同期のサブプロセスを用いた
Emacsの機能のほとんどは, MS-DOSでは動きません.  疑うならば試してみてく
ださい.  動作不能なコマンドは, 「非同期サブプロセスを使えない」旨のエ
ラーメッセージを出力します.

MS-DOS用Emacsでも, `M-x compile'によるコンパイル, `M-x grep'によるファ
イルの探索, `M-x diff'によるファイルの比較は動作しますが, これらは下位
プロセスを同期して走らせます.  つまり, 下位プロセスが終了するまではいっ
さい編集はできません.

対照的に, Windows専用にコンパイルしたEmacsでは, 非同期プロセスを使えま
す.  *Note Windows Processes::.

`lpr-buffer'（*Note Hardcopy::）や`ps-print-buffer'（*Note
Postscript::）のような印刷コマンドは, MS-DOSではプリンタポートの1つに
出力を送ることで動作します.  *Note MS-DOS Printing::.

MS-DOSで同期的にサブプロセスを動かす場合には, プログラムが確実に終了し, 
しかも, キーボードからまったく入力しないことを確認してください.
MS-DOSにはプロセスを終了させる一般的な方法がないので, プログラムがみず
から終了できない場合には, それを終了させることができなくなります.  こ
のような場合, `C-c'や`C-BREAK'を押すと助かる場合もあります.

MS-DOSでは, 他のマシンのファイルを参照することはできません.  MS-DOSに
ネットワーク機能が組み込まれていなければ, メイルの送信, Webの閲覧, リ
モートログインなどのネットワーク向けのコマンドも使えません.

MS-DOSでのdiredは, 他のシステムではシステムの`ls'コマンドを使う場面で
パッケージ`ls-lisp'を使います.  したがって, MS-DOSのdiredでは変数
`dired-listing-switches'に設定できるオプションは限られます.  使えるオ
プションは, `-A', `-a', `-c', `-i', `-r', `-S', `-s', `-t', `-u'です.



File: emacs-ja, Node: Windows Processes, Next: Windows System Menu, Prev: MS-DOS Processes, Up: MS-DOS

サブプロセス（Windows 95, NT）
==============================

（DOS版と対比して）Windows専用にコンパイルしたEmacsでは, 非同期のサブ
プロセスを完全に使えます.  Windows版では, 32ビットのWindowsアプリケー
ションを実行している限りは, 同期であれ非同期であれサブプロセスはうまく
動作します.  しかし, サブプロセスでDOSアプリケーションを実行すると, ア
プリケーションの実行に問題を生じたり実行できなかったりします.  さらに,
2つのDOSアプリケーションを同時に2つのサブプロセスで実行すると, システ
ムをリブートしなければならなくなります.

Windows 95の標準のコマンドインタープリタ（および, ほとんどのコマンド行
ユーティリティ）はDOSアプリケーションなので, この種のシステムを使う場
合には上記の問題は重要になります.  しかし, これに関してわれわれにでき
ることは何もなく, Microsoftだけが修正できるのです.

DOSアプリケーションのサブプロセスを1つだけ実行するならば, 『行儀がよく』
て, しかも, 画面を直接操作するなどの非標準的な動作をしない限りは, サブ
プロセスは予想どおりに動作するはずです.  CPUモニタ（監視）アプリケーショ
ンを使うと, DOSアプリケーションが停止しているときでさえも, マシンは
100%ビジーになりますが, これはCPUモニタがプロセッサの負荷を調べる方法
に起因します.

別のサブプロセスでDOSアプリケーションを実行する場合には, まえもってDOS
アプリケーションを終了しておく必要があります.  Emacsは, DOSのサブプロ
セスに割り込んだり停止させることができません.  このようなサブプロセス
を終了する唯一の方法は, そのプログラムに終了を指示するコマンドを与える
ことです.

別々のサブプロセスにおいて2つのDOSアプリケーションを同時に実行しようと
すると, 一方あるいは両方が非同期であるとしても, 2番目に起動したものは
最初のものが終了するまで休止してしまいます.

最初のサブプロセスを操作できて終了を指示できるならば, 2番目のサブプロ
セスは正常に実行を継続するはずです.  しかし, 2番目が同期サブプロセスで
あれば, 最初のサブプロセスが終了するまではEmacs自体が固まってしまいま
す.  ユーザー入力なしに終了できない場合には, Windows 95を使っている限
りリブート以外の選択はありません.  Windows NTであれば, プロセスを調べ
るアプリケーションを使って, 適当なntvdmを終了させます（するとDOSの2つ
のサブプロセスも終了します）.

このような状況でWindows 95をリブートすることが必要になったときには,
`Start'メニューの中の`Shutdown'コマンドを使ってはいけません.  たいてい
の場合, システムが固まってしまいます.  かわりに, `CTL-ALT-DEL'を打鍵し
て`Shutdown'を選びます.  処理に数分かかる場合もありますが, 多くの場合, 
機能してくれます.



File: emacs-ja, Node: Windows System Menu, Next: Manifesto, Prev: Windows Processes, Up: MS-DOS

Windowsのシステムメニューの利用
===============================

Windows専用にコンパイルしたEmacsでは, ALTキーを押してWindowsのメニュー
を立ち上げる機能を切ってあります.  これは, EmacsではALTはMETAの働きを
するからです.  Emacsを利用しているときには, ユーザーはしばしばいったん
METAキーを押してから何もせずに放します.  この動作でWindowsのメニューが
立ち上がってしまうと, 以降のコマンドの意味が変ってしまいます.  多くの
ユーザーにはこれでは邪魔でしょう.

`w32-pass-alt-to-system'に`nil'以外の値を設定すれば, ALTキーを押したと
きの処理はWindowsのデフォルトに戻ります.



File: emacs-ja, Node: Manifesto, Next: Acknowledgments, Prev: MS-DOS, Up: Top

GNU宣言
*******

     GNU宣言（GNU Manifesto）（以下参照）は, GNUプロジェクトの初期の頃
     に, Richard Stallmanが参加とサポートを求めるために書いたものであ
     る.  当初2〜3年間は, 開発について説明するために参考として用いつつ
     更新していたが, 現在では, 人々がよく目にするので変更しないでおく
     ことが最善であると考えている.

     その時以来, 我々は, いくつかの表現をわかりやすくしたつもりだがよ
     く誤解を招く点があることがわかった.  そこで, そのような点を明確に
     するべく, 1993年に脚注として追記した.

     現在配布可能なGNUソフトウェアに関する最新情報は, GNU's Bulletin
     （[訳注]日本語版であれば「GNUダイジェスト」）の最新号をご覧いただ
     きたい.  ここに引用するには情報量が多すぎるので.


GNUとは何か？ GnuはUnixではない（Gnu's Not Unix）！
===================================================

GNUとはGnu's Not Unixの略であり, 誰もがフリーに使えるよう (1) (*Note
Manifesto-Footnotes::), 私が今作成しているUnixと完全互換のソフトウェア・
システムの名称である.  何人ものプログラマが私を手伝ってくれている.  時
間やお金, プログラム, 機器の寄付を大いに必要としている.

既に我々のもとには, エディタ・コマンド記述用のLispを備えているEmacsと
いうテキスト・エディタや, ソース・レベル・デバッガ, yacc互換の構文解析
部生成ツール, リンカ, その他約35個のユーティリティがある.  シェル（コ
マンド・インタープリタ）はほぼ完成している.  移植性の良い新しい最適化C
コンパイラは自分自身をコンパイルできるようになり, 今年中にはリリースで
きるだろう.  初期段階のカーネルはあるが, Unixをエミュレートするために
はもっと多くの機能が必要である.  カーネルとコンパイラが完成すれば, プ
ログラム開発にふさわしいGNUシステムを配布できるだろう.  テキスト処理に
はTeXを採用するつもりだが, nroff関連の作業も進行中である.  また, フリー
で移植性の良いX Window Systemも採用する.  そのあとは, 移植性の良い
Common Lispや, Empireゲーム, スプレッドシート, その他数多くのものを, 
オンライン・ドキュメントと共に追加していく.  最終的には, Unixシステム
に標準で付いている有用なツール全てに加えて, さらにはそれ以上のものを提
供したいと考えている.

GNUは, Unixのプログラムを実行できるようにするつもりだが, Unixとは同一
のものにはならない.  他のオペレーティング・システムでの我々の経験を基
に, より使いやすくなるよう, 全面的に改良していくからである.  特に, 長
いファイル名の使用やファイルのバージョン番号, 耐クラッシュ性に優れたファ
イル・システム, ファイル名の補完機能（[訳注]ファイル名を途中まで指定し
ただけでそのあとはシステムが完全なファイル名を追加してくれる機能）, 端
末に依存しない表示のサポート, おそらく最終的には, いくつかのLispプログ
ラムと通常のUnixプログラムが1つの画面を共有できるようなLispベースのウィ
ンドウ・システムを作る予定である.  システム・プログラミング言語として
は, C言語とLispの両方が使用可能になるだろう.  通信用には, UUCP, MIT
Chaosnet, Internetの各プロトコルをサポートしようと考えている.

GNUでは, 最初は68000/16000（[訳注]モトローラ68000とナショナル・セミコ
ンダクタの16000）クラスの仮想記憶を備えたマシンを対象とする.  というの
は, GNUを最も実行しやすいマシンだからである.  もっと能力の小さなマシン
上でGNUを動作させるための努力は, そのマシン上で使いたい人の手に委ねる
ことにする.

とんでもない誤解を避けるために, このプロジェクトの名称としての「GNU」
の場合は, 「G」を発音していただきたい.  （[訳注]もともと普通名詞のGnu
はヌーという動物であり, その発音を採用するとGNU projectはヌー・プロジェ
クトになりnew projectと間違われる可能性もある. ）


なぜGNUを作成しなければならないのか？
=====================================

もし私の好きなプログラムを他の人も好きであれば, 私はその人とプログラム
を分かち合わなくてはならない, という黄金律（[訳注]自分の欲することは他
の人にも為すという考え方）を考案した.  ソフトウェア販売会社は, ユーザ1
人1人に他人と共有しない契約をさせることによって, ユーザを分離し支配し
ようとしている.  そのような方法で他のユーザとの連帯意識を壊すことは私
は嫌である.  機密保持契約やソフトウェア・ライセンス契約へのサインは良
心からできない.  何年もの間, 私はそういった傾向やその他の冷遇に抵抗す
るために, AIラボ内で活動してきたが, 最後にはその傾向や冷遇は度を越して
いった.  私に対してAIラボが行なった事は私の意志に反するので, そこに留
まることができなくなった.

信念を曲げることなくコンピュータを使い続けるために, フリーでないソフト
ウェアがなくてもうまくやっていけるようなフリー・ソフトウェアのしっかり
した団体を組織することを決意した.  私がGNUを配布することをMITが合法的
に阻止するのを拒否するために, 私はAIラボを辞職した.


なぜGNUはUnix互換なのか？
=========================

Unixは私の理想とするシステムではないが, それほど悪いシステムでもない.
Unixの基本的な機能は良いものなので, それらを生かしつつ, Unixに欠けてい
るものを補っていけるだろうと考えている.  また, Unix互換のシステムであ
れば, GNUを採用する他の多くの人々にとっても有用であろう.


GNUをどうやって配布するか？
===========================

GNUはパブリック・ドメインには置かない.  それにより, 誰もがGNUを修正し
て再配布でき, 配布者が再配布することを禁止されることもない.  つまり, 
独占的な修正はできないのである.  私は, あらゆるバージョンのGNU （[訳注]
誰でもソース・コードをアクセスできるという意味で）が確実にフリーであり
続けて欲しいのである.


なぜ他の多くのプログラマが協力してくれるのか？
==============================================

私は, 他の数多くのプログラマがGNUに熱狂し, そして協力したがっているこ
とを知った.

多くのプログラマが, システム・ソフトウェアの営利化に不満を抱いている. 
その営利化とは, プログラマに金儲けをさせる代わりに, 他の一般のプログラ
マを仲間ではなく競争相手として見るよう仕向けるからである.  プログラマ
間の友情を示す基本的な行為は, プログラムの共有である.  現在の典型的な
市場の取り決めは, プログラマが他のプログラマを友人として接することを根
本的に禁じてしまっている.  ソフトウェアの購入者は, 友情をとるか, 法律
に従うかを選択しなくてはならない.  当然, 友情のほうが大切であると考え
る人のほうが多いだろう.  しかし, 法律に従うべきであると考える人のなか
には, このようなことが簡単に選択できない人が多い.  そういう人は人の誠
意を信じない人間になっており, プログラミングは単なる金儲けの一手段でし
かないと考えているからである.

独占的なプログラムではなくGNUに関する作業を行ない, GNUを使っていれば, 
誰に対しても排斥的ではなくなり法を守ることもできる.  さらに, GNUは共有
という点において, 激励するための一例となり, 人々が我々に参加すべく結集
するための旗印となる.  これにより, もし我々がフリーでないソフトウェア
を使っていては得られないある種の和の感情を抱くことができる.  私が対話
したプログラマのうちの約半数が, これはお金には換えられない大切な幸福で
あると言っている.


あなたはどのようにしたら貢献できるか？
======================================

私は, コンピュータ・メーカにはマシンとお金の寄付を求めている.  個人に
対してはプログラムと労働の寄付を求めている.

マシンの寄付を受けた場合は, その見返りの1つとして, GNUが近いうちにその
マシン上で動作するようになるだろう.  マシンは完成していてシステムが使
える状態であり, 住宅区域で使用可能で, 特殊な冷却や電力を必要としないも
のでなくてはならない.

私は非常に多くのプログラマがGNUのためにパートタイムで作業する熱意があ
ることを知った.  ほとんどのプロジェクトでは, そういったパートタイムで
の分散した作業をまとめていくことは非常に困難だろう.  しかし, Unixを置
き換えるというこの特定の作業に関しては, そのような問題はない.  完全な
Unixシステムには数百ものユーティリティ・プログラムがあり, その1つ1つに
は別個にドキュメントが付いている.  たいていのインタフェース仕様は,
Unixとの互換性の観点から決定されている.  プログラマ各人が単一のUnixユー
ティリティと互換の代替品を作成できれば, そのようなユーティリティをひと
まとめにしても正しく動作するはずである.  マーフィーの例で言えば, いく
つか予期せぬ問題が生じたとしても, これらの構成要素をまとめることは可能
な作業であろう.  （カーネル作業には, より緊密なコミュニケーションが必
要なので, 少人数で密接なグループでの作業となる. ）

お金の寄付を受けた場合は, フルタイムかパートタイムで2〜3人を雇えるだろ
う.  給料はプログラマの標準収入ほど高くはないが, お金を稼ぐことと同じ
ように共同体精神を築くことは重要だと考えている人を私は捜している.  私
は, この給料とは, プログラマが別の方法で生計を立てなくても, GNU作業に
全力投球できるようにするための一手段としてとらえている.


なぜ全てのコンピュータ・ユーザが恩恵をうけるのか？
==================================================

いったんGNUが作成されれば, 誰もが良質のシステム・ソフトウェアを無料で
入手できるようになる. (2) (*Note Manifesto-Footnotes::)

これは, Unixライセンスの価格を誰もが節約できることだけではなく多くのこ
とを意味する.  つまり, 非常に無駄となるシステム・プログラミングの重複
を避けることができる.  代わりに, その労力は現在の技術水準の進歩に向け
ることができる.

完全なシステム・ソースは誰に対しても配布可能になる.  そのため, システ
ムに変更を施さなくてはならないユーザは, 自分でいつでも自由にそれを行なっ
たり, あるいは, 自分の代わりにそれを行なってくれるプログラマや企業を雇
うことができるようになる.  ユーザはもはや, ソース・コードを所有するプ
ログラマや企業のなすがままになることはなく, 変更を施すことに関しては独
立した存在でいられる.

大学側は, 学生にシステム・コードを学習し, 改良するよう奨めることにより, 
はるかに良い教育環境の提供が可能になる.  ハーバード大学のコンピュータ
研究所では, ソース・コードを公開して見れないようなプログラムは一切, シ
ステムにインストールしないという方針が習慣であり, 特定のプログラムをイ
ンストールすることを実際に拒否することを支持した.  このことに私は非常
に勇気づけられた.

最後に, システム・ソフトウェアを誰が所有しているのかを, それを使ってやっ
ていいことといけないことを考慮することのオーバーヘッドが解消されるだろ
う.

人々にプログラムの使用料を支払わせる契約（複製のライセンスを含む）は常
に, 人がいくら（つまり, どのプログラムに）支払わなくてはならないかを理
解するのに欠くことのできない厄介な機構を通じて, 社会は多大なコストを被っ
ている.  そして, 警察国家でもなければ, そのような機構に全ての人を従わ
せることはできない.  例えば, 多大なコストをかけて空気を製造しなくては
ならない宇宙ステーションのことを考えてみよう.  空気1リットルごとの息継
ぎに課金すれば公平かもしれないが, たとえ皆が空気料金を支払う余裕があっ
たとしても, そのために一日中メータ付きの空気マスクを付けるとなれば耐え
難いことである.  まして, マスクを外したかどうかをTVカメラが至る所で見
張っているなどというのは, 全くとんでもないことである.  それよりは, 料
金を頭割りにした税金で空気工場を維持して, マスクを外すほうがましである.

プログラムの一部または全てを複写することは, プログラマにとって呼吸する
のと同じくらい自然なことであり生産的なものである.  だから, プログラム
はフリーであるべきである.


GNUの目標への異議と, 簡単にできる反証
=====================================

     『プログラムがフリーであれば誰もそれを使わないだろう.  なぜならば, 
     無料ということは, サポートを当てにできないからである. 』

     『サポートを提供するために料金をプログラムに課す必要がある. 』

人々が, サービスのない無料のGNUよりも, サービス付きの有料のGNUのほうに
支払うというのであれば, GNUを無料で入手した人々に対して, サービスだけ
を提供する企業は利益を得て当然である. (3) (*Note
Manifesto-Footnotes::)

本当のプログラミング作業を行なうサポートと, 単なる支援とは区別すべきで
ある.  前者は, ソフトウェア業者からのサポートを当てにできない種類のも
のである.  もしあなたの問題が多くの人々の問題になっていなかった場合に
は, ソフトウェア業者は邪魔しないでほしいと言うだろう.

あなたのビジネスがサポートに頼らざるをえない場合は, 必要なソース・コー
ドとツールを全て自分で抱えるしかない.  そうすれば, あなたの問題点を直
してもらうための人を雇うことができる.  人に翻弄されることはない.  Unix
を使う場合, ソース・コードが高価なので, ほとんどのビジネスではこのよう
なことはできない.  GNUを使えば, これは簡単に実現する.  有能な人材がい
なかったとしても可能であり, しかも, 問題点を修正できないのは配布規定の
せいでは断じてない.  GNUは, 世界中の全ての問題ではなく, その一部のみを
取り除いている.

一方, コンピュータについて何も知らないユーザには支援が必要である.  自
分で容易に処理できる範疇であっても, その方法を知らない場合に支援が必要
なのである.

そのようなサービスは, 単なる指導や修理サービスだけを行なっている企業が
請け負うことができるだろう.  ユーザがお金を支払ってもサービス付きの製
品を購入するほうが良いと考えているのであれば, 無料の製品に対するサービ
スにも喜んでお金を払うだろう.  サービス会社は, 品質と価格の面で競争す
ることになり, ユーザは特定のサービス会社にこだわる必要がなくなる.  一
方, サービスを必要としない我々等などであれば, サービスへの対価を支払わ
なくても, プログラムを使うことができる.

     『広告なしでは多くの人々に知らせることは無理であり, その費用だけ
     でもプログラムに料金を課すべきである. 』

     『誰もが無料で入手できるようなプログラムを宣伝しても仕方がな
     い. 』

GNU等の情報を, 多くのコンピュータ・ユーザに知らせられるような無料また
はきわめて安価な広告媒体がいろいろとある.  しかし, 宣伝すれば, より多
くのマイクロコンピュータ・ユーザに知らせられるというのも事実かもしれな
い.  本当にそうであれば, GNUを無料で複写したり配布するサービスを宣伝す
るビジネスは, その広告費用にかかった以上の成功をおさめるはずである. 
この方法は, 宣伝によって利益を得るユーザだけが広告料を払うものである.

他方では, 多くの人々が友人からGNUを入手するので, 上記のような企業が成
功しないというのであれば, その宣伝がGNUを広める上で, 本当に必要なもの
ではないということである.  なぜ自由市場擁護者は, このことを自由市場に
決めさせたくないのだろうか？ (4) (*Note Manifesto-Footnotes::)

     『私の会社は, 競争の頂点に立つために独占的なオペレーティング・シ
     ステムが必要である. 』

GNUにより, オペレーティング・システム・ソフトウェアは競争の世界から取
り除かれることになるだろう.  このオペレーティング・システム・ソフトウェ
アの分野では, あなたは競争の頂点に立つことはできないし, 競争相手もそう
なることはできない.  この分野では, あなたとその競争相手は互いに利益を
受け, 競い合うのは他の分野でということになる.  あなたのビジネスがオペ
レーティング・システムの販売であった場合には, GNUは好ましくなく, あな
たにとって厳しい状況になるだろう.  あるいは他の種類のビジネスならば, 
オペレーティング・システムの販売といった高価なビジネスにあなたが強要さ
れないよう, GNUがあなたを救うことができる.

私は, 多くのメーカやユーザからの寄付に支えられてGNUが発展し, そのよう
な人々の個々のコストが軽減されていくのをこの目で見たいと思う. (5)
(*Note Manifesto-Footnotes::)

     『プログラマは自分の創造性に対して報酬を受けるに値しないのではな
     いか？』

何事にも報酬があるとしたら, それは社会的貢献である.  創造性は社会的貢
献となりうるが, それは社会がその成果を自由に使用できる場合に限られる. 
もしプログラマが, 革新的なプログラムを作成したことで報酬を得るとしたら, 
そのようなプログラムの利用を制限した場合にも同じ理由で罰に値する.

     『プログラマは, 自分の創造性に対して報酬を要求してはいけないので
     はないか？』

仕事に対して支払いを求めたり, 自分の収入を最大に増やすよう求めることは, 
破壊的な手段を使わない限り, 何ら悪いことではない.  しかし, 今日のソフ
トウェア分野で習慣となっている手段は, 破壊的行為に基づいている.

プログラムの使用を制限してプログラムのユーザからお金をとることは, その
制限のせいで, 使用できるプログラムの種類や方法が減ってしまうので, 破壊
的行為となる.  これは, 人類がプログラムから得られる富の量を減らしてし
まう.  故意に制限すると決定したときには, 意図的な破壊という有害な結果
をもたらすだろう.

善良な市民がそのような破壊的手段を用いないのは, そうしないことこそが裕
福であると思っているからである.  もし誰もが破壊的手段を用いたとしたら, 
我々は互いの破壊行為によってさらに貧しくなっていくばかりであろう.  こ
れがカント哲学の倫理, または黄金律である.  皆が情報を隠し持った結果と
して生じる結末を私は好まないので, そうすることは悪いことであると考えざ
るを得ない.  明確に言えば, 自分の創造性が報われたいという欲望は, その
創造性の全部または一部を, 一般の世の中から奪う言い訳にはならない.

     『プログラマは飢えてしまわないだろうか？』

プログラマに強要できる者はいないということは言える.  我々の大半は, 街
に立ってしかめ面をしてもどうにもお金を稼ぐことはできない.  しかし, 結
果的には, 我々がしかめ面をしながらひもじい思いをしつつ街に立って一生を
過ごすことになったとしても, それを厳しく非難されはしない.  我々には他
にすることがあるからである.

しかし, これは, 質問者の暗黙の仮定, つまり, ソフトウェアの所有権がなけ
れば, プログラマは一銭たりとも収入を得ることはできないという仮定を受け
入れているので間違った答えである.  おそらく, 一か八かということなのだ
ろう.

プログラマが飢えてしまわない本当の理由は, 単に今ほどの額ではないだけで
あって, プログラミングに対しては支払われる可能性が依然としてあるからで
ある.

複写を制限することだけが, ソフトウェアにおけるビジネスの唯一の基礎では
ない.  それが最も多くのお金をもたらすので, 一番の共通基盤になっている
だけである.  もし顧客のほうから複写の制限を禁じたり拒絶すれば, ソフト
ウェア・ビジネスの組織の土台は, 今ではあまり多くは使用されていないよう
な別の種類ものへと変わるだろう.

おそらく, 新しい基盤のもとではプログラミングは現在と同じくらいの利益に
しかならないだろう.  しかし, それだからといって変化に反対する理由には
ならない.  販売員が今と同じ給料を得ることが不公平だというのではない. 
プログラマも同様に今と同じ給料を得たとしても, 不公平にはならないだろう. 
（実際, プログラマは給料以上のことを行なうだろうから. ）

     『人々には自分の創造性がどのように使用されるのかを制御する権利が
     あるのではないか？』

『自分のアイデアの使用を制御すること』は実は, 他人の人生を制御し, 一般
にその人の人生をもっと困難にするために用いられる性質のものである.

（弁護士のように）知的所有権の問題を勉強した人によれば, 知的所有物には
本来の権利もないと言っている.  政府が認めている推定上の知的所有権の類
は, 特定の目的のための特定の法律によって作り出されたものである.

例えば, 特許制度は, 発明家がその発明の細部を公開するよう促進するために
制定された.  その目的は, 発明家を保護するというよりは, 社会を保護する
ことにあった.  当時, 17年という特許の保護期間は, 技術水準の進歩に比べ
て短いものであった.  特許は製造業者の間だけの問題なので, ライセンス契
約のコストや手間が製品作りの準備に比べれば少ないような人々にとっての特
許とは, さほどの損害にはならない場合が多い.  特許製品を使用するたいて
いの個人を妨害してはいない.

著作権という概念は, 著者がノンフィクション作品の中に他の著者から長々と
頻繁に真似ていた古代には存在しなかった.  この習慣は役に立っていたし, 
現在でも多くの著者の作品に部分的に生き続けている習慣である.  著作権制
度は, 著述業を明白に促進するために作られた.  その制度が作られた分野と
して本があるが, これは印刷するだけで安く複製できるのでほとんど損害を与
えることはなく, 何よりも本を読む個人を妨害することはなかった.

全ての知的所有権は, 社会が認めるライセンスにすぎない.  というのは, 良
きにつけ悪しきにつけ, 知的所有権を認めることにより社会全体が利益を得る
と考えられたからである.  しかし, どのような特殊な状況においても, 我々
には問直さなければならないことがある.  「我々はそのようなライセンスを
認めることで本当により裕福になるのか？」, 「我々はどのような種類の行為
を人に許可しているというだろうか？」と.

今日のプログラム事情は, 100年前の書物のときとは全く異なっている.  例え
ば, プログラムを複写するときの最も簡単な方法は, 隣の人からさらに隣の人
へと順にまわしていくという事実や, プログラムにはソース・コードとオブジェ
クト・コードがあってそれぞれ別のものであるという事実, プログラムは読ん
だり楽しむものではなく使用されるものであるという事実が混ぜ合わされて, 
著作権を押し通す人が, 物質的にも精神的にも社会全体に害を及ぼしている状
況を作り出しているのである.  つまり, 法的に著作権の強要が可能かどうか
にかかわらず, 人はそのようなことをすべきではないということである.

     『競争が物事をより良くしていく. 』

競争の典型はレースである.  勝者には報酬が与えられるので, 誰もがもっと
速く走ろうと努力する.  資本主義が本当にこの方法で機能すればよいが, 資
本主義の擁護者は, この方法で常に機能することを前提としている点が間違っ
ている.  例えば, なぜ報酬が与えられるのかを走者が忘れてしまい, 手段を
選ばず勝つことのみに執着したとすれば, 他の走者を攻撃するといった他の作
戦をとるかもしれない.  走者達が真っ先に殴り合いをしてしまえば, 皆のゴー
ルインが遅れてしまうだろう.

ソフトウェアの占有と秘密は, 真っ先に殴り合う走者と道義的には同じである. 
悲しいことに, 我々の唯一の審判でさえ, 殴り合いに反対していないように見
える.  ただ走者を（『10ヤード走るごとに1発殴ってもよい』というふうにし
て）規制するだけである.  審判は本来, そのような走者達の中に分け入って, 
暴力を働こうとした走者を罰してしかるべきである.

     『金銭的な刺激がなくなっては誰もプログラミングなどしないのではな
     いか？』

実際には, 多くの人々が金銭的刺激が皆無であってもプログラムを書いている
だろう.  プログラミングには, 一部の人にとってはたまらないほどの魅力が
あり, そういう人こそプログラミングに最も向いている.  音楽で生計を立て
る望みがないからといって, プロの音楽家がいなくなることはない.

しかし, この疑問は実際, よく提起されるのだが, 現実に即してはいない. 
プログラマへの支払いは少なくなっても, 無くなることはない.  したがって, 
正しい質問は, 『金銭的な魅力が減っても人はプログラムを書くか？』となる. 
私の経験がそれを語っている.

10年以上もの間, 世界中の多くの最優秀プログラマが, よそでならもっと収入
を得られたはずにも関わらず, AIラボで働いてきた.  彼らは, 金銭ではない
報酬, 例えば, 名声や感謝といったものを得てきた.  そして, 創造は楽しく
もあり, それ自体が自分への報償であった.

やがて, 彼らの大半は, 多くの給料をもらいながら引き続き興味ある同じ仕事
ができる機会を与えられて去っていった.

この事実は, 人は金持ちになること以外の理由でもプログラムを書くというこ
とを示している.  しかし, より多くのお金を得る機会があれば, 人はそれを
期待し求めもするだろう.  給料が少ない組織は, 多いところと競争すれば劣
勢にはなるが, 給料の多い組織が息詰まっても, 少ないほうまで悪くなるわけ
ではない.

     『我々は絶望的になってプログラマを必要としているのではないか.  我々
     の隣人を助けるのをやめるようプログラマが我々に要求すれば, 我々は
     それに従わざるを得ない. 』

あなたは, そういった要求に従うほど決して絶望的ではない.  忘れないでい
ただきたい.  そのような要求に従わなければ数百万ドルの価値となるが, 従
えば1セントもの賛辞には値しないのである！

     『プログラマは何とかして生計を立てなくてはならない. 』

短い目で見ればこれは当てはまる.  だが, プログラマが, プログラムの使用
権を売らずに生計を立てていける方法はいくらでもある.  この方法は, 他に
生計を立てる手立てがないからではなく, プログラマやビジネスマンに多額の
お金をもたらすので, 今では慣習的となっている.  他の方法を見つけようと
思えば簡単に見つかる.  その例をいくつか示しておく.

新しいコンピュータを導入している製造業者は, 新しいハードウェアにオペレー
ティング・システムを移植する作業に対して支払うだろう.

プログラミングに関する教育や指導, 保守といったサービスをビジネスとする
場合にもプログラマを雇うことができるだろう.

新しいアイデアを持った人は, プログラムをフリーウェアとして配布し, それ
に満足したユーザに寄付を求めたり, 簡単な指導サービスをビジネスにするこ
とができるだろう.  私は, この方法を既に実践して成功した人々を知ってい
る.

似たような要求があるユーザ同士は, ユーザ・グループを組織し, 会費を払う. 
グループでは, ソフトウェア業者と契約して, メンバーが使いたいプログラム
を作成してもらう.

あらゆる種類の開発が, 以下に示す「ソフトウェア税」で積み立てることがで
きる.

     コンピュータを買う人は誰でも, ソフトウェア税として, その価格のxパー
     セントを支払うようにする.  政府は, これを, ソフトウェア開発のため
     にNSF （[訳注]米国科学財団, National Science Foundation）のような
     機関に与える.

     ただし, コンピュータの購入者がソフトウェア開発に寄付する場合には, 
     相当額の税金控除となる.  自分で選んだプロジェクトへ寄付することが
     できる.  ほとんどは, プロジェクトの成果を利用したいような所を選ぶ
     だろう.  本来支払うべき税金の合計を上限として, 寄付金の額に応じて
     控除することができる.

     全体の税率は, 課税額に応じて重み付けをし, 納税者の投票によって決
     定可能とする.

     その結果,

        * コンピュータを使用するコミュニティはソフトウェア開発を支援す
          る.
        * そのコミュニティは, どの程度のサポートが必要なのかを決定する.
        * 自分達の負担したものがどのプロジェクトに費されるかに関心のあ
          るユーザは, 自分で（[訳注]立ち上げて欲しい）プロジェクトを選
          ぶことができる.

長い目で見た場合には, プログラムをフリーにすることは, 欠乏の無い世界へ
の第一歩であり, そこでは誰も生計を立てるためだけにあくせく働く必要はな
いだろう.  人々は, 週に10時間の課せられた仕事, 例えば, 法律の制定や, 
家族との相談, ロボットの修理, 小惑星の試掘といった必要な仕事をこなした
あとは, プログラミングといった楽しめる活動に自由に専念することになるだ
ろう.  もはやプログラミングで生計を立てる必要はなくなる.

我々は既に, 社会全体が実質的生産のためにしなければならない作業量を大幅
に減らしてきたが, そのうちのほんのわずかが労働者の娯楽に変わっただけで
ある.  というのは, 生産活動に伴い多くの非生産活動が必要とされるからで
ある.  その主な原因は, 官僚主義と競争に対する差の無い骨折りである.  フ
リー・ソフトウェアは, ソフトウェア生産の分野でこれらの乱費流出を大幅に
減らすだろう.  生産における技術的利得が我々にとっての労働の軽減になる
よう, 我々はこれを行なっていかなければならないのである.


