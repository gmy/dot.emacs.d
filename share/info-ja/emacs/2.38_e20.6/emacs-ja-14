Info file: emacs-ja,    -*-Text-*-
produced by `texinfo-format-buffer'
from file `emacs.texi'
using `texinfmt.el' version 2.38 of 3 July 1998.


Emacs 20.6版対応に改訂した`GNU Emacs Manual' 13版です.

INFO-DIR-SECTION Editors
START-INFO-DIR-ENTRY
* Emacs: (emacs).	The extensible self-documenting text editor.
END-INFO-DIR-ENTRY


Published by the Free Software Foundation 59 Temple Place, Suite 330
Boston, MA 02111-1307 USA

Copyright (C) 1985, 1986, 1987, 1993, 1994, 1995, 1996, 1997, 1998,
1999 Free Software Foundation, Inc.

Permission is granted to make and distribute verbatim copies of this
manual provided the copyright notice and this permission notice are
preserved on all copies.

Permission is granted to copy and distribute modified versions of this
manual under the conditions for verbatim copying, provided also that
the sections entitled "The GNU Manifesto", "Distribution" and "GNU
General Public License" are included exactly as in the original, and
provided that the entire resulting derived work is distributed under
the terms of a permission notice identical to this one.

Permission is granted to copy and distribute translations of this
manual into another language, under the above conditions for modified
versions, except that the sections entitled "The GNU Manifesto",
"Distribution" and "GNU General Public License" may be included in a
translation approved by the Free Software Foundation instead of in the
original English.





File: emacs-ja, Node: Function Keys, Next: Named ASCII Chars, Prev: Init Rebinding, Up: Key Bindings

ファンクションキーの再定義
--------------------------

キー列には通常の文字以外にもファンクションキーを含めることができます. 
キーボードの文字がLispの文字（実は整数です）で表されるのに対し, ファン
クションキーはLispシンボルで表されます.  ファンクションキーに単語のラ
ベルが付いているなら, その単語が対応するLispシンボルの名前になります. 
たとえば普通に見られるファンクションキーとLispシンボルの対応はつぎのと
おりです.

`left', `up', `right', `down'
     カーソル矢印キー.

`begin', `end', `home', `next', `prior'
     その他のカーソル移動キー.

`select', `print', `execute', `backtab'
`insert', `undo', `redo', `clearline'
`insertline', `deleteline', `insertchar', `deletechar'
     その他のファンクションキー.

`f1', `f2', ... `f35'
     （キーボードの上端に並んでいる）番号の付いたファンクションキー.

`kp-add', `kp-subtract', `kp-multiply', `kp-divide'
`kp-backtab', `kp-space', `kp-tab', `kp-enter'
`kp-separator', `kp-decimal', `kp-equal'
     （普通のキーボードの右側にまとまっている）キーパッドのキーで, 名
     前や句読点が印字されているもの.

`kp-0', `kp-1', ... `kp-9'
     キーパッドの数字キー

`kp-f1', `kp-f2', `kp-f3', `kp-f4'
     キーパッドのPFキー.

これらの名前は習慣的なものですが, システムによっては（とりわけXウィン
ドウシステムを使っている場合は）, 別の名前になっている場合があります. 
あるファンクションキーにどのシンボルが対応しているか調べるには, `C-h
c'に続いてそのキーを打鍵してください.

ファンクションキーのシンボルを含むキー列（あるいは, ASCII以外の文字を
含むもの）は文字列ではなくベクタで指定してください.  ベクタの構文では
要素と要素のあいだは空白で区切り, 全体を中括弧``[...]''で囲みます.  た
とえば, ファンクションキー`f1'をコマンド`rmail'にバインドするには, つ
ぎのようにします.

     (global-set-key [f1] 'rmail)

右矢印キーをコマンド`fowared-char'にバインドするには, つぎのようにしま
す.

     (global-set-key [right] 'forward-char)

これは, シンボル`right'を要素とするベクタのLisp構文です.  （このバイン
ディングはEmacsのデフォルト設定に入っている. ）

ベクタを用いたキーの再定義ついてより詳しくは, *Note Init Rebinding::.

キー列の中でファンクションキーと文字を混ぜることができます.  以下の例
は, `C-x NEXT'をコマンド`forward-page'にバインドしています.

     (global-set-key [?\C-x next] 'forward-page)

ここで, `?\C-x'はLispの文字定数で, 文字`C-x'を表します.  ベクタのもう1
つの要素である`next'は, シンボルですから`?'は不要です.

ファンクションキーに対して, 修飾キーCTRL, META, HYPER, SUPER, ALT,
SHIFTを指定できます.  これらの修飾キーを指定するには, シンボル名のまえ
に`C-', `M-', `H-', `s-', `A-', `S-'を付けてください.  たとえば,
`Hyper-Meta-RIGHT'で1語先へ移動するにはつぎのように指定します.

     (global-set-key [H-M-right] 'forward-word)



File: emacs-ja, Node: Named ASCII Chars, Next: Non-ASCII Rebinding, Prev: Function Keys, Up: Key Bindings

名前の付いたASCIIコントロール文字
---------------------------------

TAB, RET, BS, LFD, ESC, DELはもともとASCIIの特定のコントロール文字に対
応していたのですが, よく使われるため別にそれ専用のキーを持つようになり
ました.  のちに人々はEmacsでこれらのキーとそれらと『同じ』文字をCTRLキー
と組み合わせて打鍵した場合とを区別できると便利だと気がつきました.

EmacsではXウィンドウシステムを使っている場合, これら2種類の入力を区別
します.  つまり, キーボード上の特殊キーの方は`tab', `return',
`backspace', `linefeed', `escape', `delete'という名前のファンクション
キーとして扱うのです.  これらのファンクションキーは, *もし*それ固有の
バインディングが指定されていなければ, 自動的に対応するASCII文字に変換
されます.  その結果, 特にこの2種類を区別したいと思わない限りは, ユーザー
もLispプログラムもこれらの区分について気にする必要はありません.

（たとえば）TABと`C-i'を区別したくないなら, ASCII文字TAB（8進コード011）
に対応するバインディング1つだけを指定してください.  区別したいのなら, 
このASCII文字に対するバインディングに加えて, 『ファンクションキー』
`tab'に対するバインディングも指定します.

通常のASCII端末では, TABと`C-i' （および上記の対応する組のそれぞれ）を
区別する方法はありません.  というのは, 端末はどちらが押されても同じ文
字を送出するからです.



File: emacs-ja, Node: Non-ASCII Rebinding, Next: Mouse Buttons, Prev: Named ASCII Chars, Up: Key Bindings

キーボード上の非ASCII文字
-------------------------

アクセント付き文字などの非ASCII文字を送出するキーがあるキーボードでは, 
それらのキーの再定義には, 少々トリックが必要です.  2つの解決方法があり
ます.  1つめは, `set-keyboard-coding-system'（*Note Specify Coding::）
を使って, キーボードのコーディングシステムを指定することです.  そうす
れば, つぎのように書いて, 通常の方法でそれらのキーを再定義できます.

     (global-set-key [?CHAR] 'some-function)

ただし, CHARを挿入するには, 定義したいキーを打ちます.

キーボードのコーディングシステムを指定しないと, 上のようにはできません. 
そのかわりに, 端末が実際に送出するコードを調べる必要があります.  Emacs
でこれを簡単に行うには, `C-x b temp RET'で空バッファを作成し, `M-x
toggle-enable-multibyte-characters RET'でユニバイトにしてから, このバッ
ファに文字を挿入するキーを打ちます.

文字のまえにポイントを移動して, `C-b C-x ='と打ちます.  8進数, 10進数,
16進数の3通りで表した文字コードを括弧で括ったメッセージがミニバッファ
に表示されます.  定義するには, 3つの数字の2番目, つまり, 10進数をベク
タの中に書きます.

     (global-set-key [DECIMAL-CODE] 'some-function)



File: emacs-ja, Node: Mouse Buttons, Next: Disabling, Prev: Non-ASCII Rebinding, Up: Key Bindings

マウスボタンの再定義
--------------------

Emacsではマウスボタンを表すのにもLispシンボルを使います.  Emacsのもっ
とも一般的なマウスイベントは"クリック"（click）イベントです.  これはマ
ウスボタンを押して, マウスを移動せずにボタンを放したときに発生します. 
ボタンを押した状態でマウスを移動すると"ドラッグ"（drag）イベントになり
ます.  そして最後にマウスボタンを放したときにも, やはり"ドラッグ"イベ
ントが発生します.

基本的なクリックイベントに対応するシンボルは, 左ボタンに対しては
`mouse-1', 左から2番目のボタンに対しては`mouse-2', などとなっています.
2番目のボタンをクリックしたときカレントウィンドウを分割するには, つぎ
のように設定します.

     (global-set-key [mouse-2] 'split-window-vertically)

ドラッグイベントについても同様ですが, イベント名の`mouse'のまえに
`drag-'が付きます.  たとえば, 第1ボタンを押したままドラッグすると
`drag-mouse-1'イベントが発生します.

マウスボタンが押されたときに発生するイベントに対してバインディングを指
定することもできます.  これらのイベントは`drag-'のかわりに`down-'で始
まります.  これらのイベントはキーバインディングが定義されているときだ
け生成されます.  `down-'イベントのあとには, 必ず, 対応するクリック／ド
ラグッイベントが発生します.

必要ならば, シングルクリック／ダブルクリック／トリプルクリックを区別す
ることもできます.  ダブルクリックとは, ほぼ同じ位置でマウスボタンを2回
クリックすることです.  最初のクリックで通常のクリックイベントが発生し
ます.  最初のクリックから十分短い時間内に2回目のクリックが起こると, ク
リックイベントではなくダブルクリックイベントが発生します.  ダブルクリッ
クイベントは, `double-'で始まります.  たとえば, `double-mouse-3'です.

つまり, 同じ場所で2回クリックがあったとき, 2回目のクリックに特別な意味
を与えることはできますが, ただし最初のクリックで発生する通常のシングル
クリックに対して定義された動作も実行されることを前提としなければなりま
せん.

このような制限のため, ダブルクリックで行えることが制約されますが, ユー
ザーインターフェイスデザイナは, よいユーザーインターフェイスがつねにそ
のような制約に従うべきだとの考えを述べています.  つまり, ダブルクリッ
クはシングルクリックと類似した動作をすべきであり, 『それよりいくらか多
く』の動作をするのがよい, ということです.  そして, ダブルクリックイベ
ントに対応するコマンドがその「いくらか多く」のぶんの動作を行うべきだと
いうことです.

ダブルクリックイベントに対してバインディングが定義されていなければ, ダ
ブルクリックは2つのシングルクリックとして扱われます.  その結果, シング
ルクリックに対応するコマンドが2回実行されることになります.

Emacsではさらにトリプルクリックイベントも使えます（その場合, 名前は
`triple-'で始まる）.  しかし4重クリックをイベントタイプとして区別しま
せん.  ですから, 3回目以降の連続したクリックは, すべてトリプルクリック
イベントとして報告されます.  ただし, 連続したクリックの回数はイベント
リストに記録されていますから, 本当に4重以上のクリックを区別したければ
そうすることもできます.  4重以上のクリックに特別な意味を与えるのはお勧
めできませんが, 4回だと1回と同じ, 5回だと2回と同じというように3つの選
択肢のあいだで巡回できるようにするのは場合によっては有効かもしれません.

Emacsはまた, ドラッグやボタンイベントでも複数回の押し下げを記録します. 
たとえば, ボタンを2回押してからそのままマウスを移動した場合, Emacsは
`double-drag-'で始まるイベントを生成します.  ドラッグでなくボタンを押
し下げただけの場合は同様に, `double-down-'で始まるイベントを生成します
（ただし, 他のボタンイベントと同様に, そのイベントに対するバインディン
グがなければ無視される）.

変数`double-click-time'は, どれくらいの時間間隔内であれば2つの隣接する
クリックをダブルクリックとみなすかを指定します.  単位はミリ秒です.  値
が`nil'であれば, ダブルクリックを検出しません.  値が`t'であれば, 時間
間隔の上限はないものとして扱います.

マウスイベントに対応するシンボルにはさらに, `C-', `M-', `H-', `s-',
`A-', `S-'の各プレフィックスで, 修飾キーの情報も組み込めます.  順番は, 
プレフィックスに続いて`double-'や`triple-'があり, そのあとが`drag-'や
`down-'ということになります.

フレームには, モード行やスクロールバーなどのバッファ中のテキストを表示
する以外の部分もあります.  マウスイベントがこれらの特別な部分で発生し
たものかどうかを調べるために, ダミーの「プレフィックスキー」があります. 
たとえば, マウスがモード行でクリックされた場合, まず`mode-line'という
プレフィックスキーが送られ, 続いて通常のマウスボタンに対応したイベント
が送られます.  ですから, モード行で第1ボタンがクリックされたときに
`scroll-up'を実行するにはつぎのようにします.

     (global-set-key [mode-line mouse-1] 'scroll-up)

ダミーのプレフィックスキーとその意味はつぎのとおりです.

`mode-line'
     マウスがウィンドウのモード行にある.
`vertical-line'
     マウスが横に隣接するウィンドウ間の境界線上にある.  （スクロールバー
     を表示させると, 境界線のかわりにスクロールバーが現れる. ）
`vertical-scroll-bar'
     マウスが縦スクロールバー上にある.  （Emacsで使えるスクロールバー
     は, 現在のところ縦スクロールバーのみ. ）

1つのキー列の中に2つ以上のマウスボタンイベントを含めることもできますが, 
普通はあまりしないでしょう.



File: emacs-ja, Node: Disabling, Next: Keyboard Translations, Prev: Mouse Buttons, Up: Key Bindings

使用禁止コマンド
----------------

コマンドを使用禁止にすると, コマンドの実行にはユーザーの確認が必要にな
ります.  コマンドを使用禁止にする目的は, 初心者がそのコマンドをまちがっ
て実行してしまい, 混乱するのを防ぐためです.

Emacs上で使用禁止コマンドを対話的に実行しようとすると, コマンド名, 説
明文, とりあえずどうすべきかの指示を表示したウィンドウが現れます.  つ
ぎにEmacsはコマンドを実行するか, 使用禁止を解除してから実行するか, 実
行を取り消すかを問い合わせてきます.  コマンドの使用禁止を解除すること
を選ぶと, Emacsさらに, 以後恒久的にそうするのか, または現在のセッショ
ン内だけそうするのかも問い合わせてきます.  恒久的に使えるようにすると, 
自動的に個人の`.emacs'ファイルを編集します.

コマンドを使用禁止にする機構は, コマンドに対応するLispシンボルの属性
`disabled'に`nil'以外の値を設定することです.  これを行うLispプログラム
はつぎのようになります.

     (put 'delete-region 'disabled t)

属性`disabled'の値が文字列であれば, コマンドを使用しようとしたときに表
示されるメッセージにその文字列も含まれるようになります.

     (put 'delete-region 'disabled
          "It's better to use `kill-region' instead.\n")

コマンドを使用禁止にするには, `.emacs'ファイルを直接編集するか, かわっ
てこのファイルを編集するコマンド`M-x disable-command'を使います.  同様
に, コマンド`M-x enable-command'は, `.emacs'ファイルを編集してコマンド
を恒久的に使える状態にします.  *Note Init File::.

コマンドが使用禁止であるかどうかは, そのコマンドを起動するキー列には無
関係です.  したがって, `M-x'でそのコマンドを起動してもEmacsはその可否
を問い合わせてきます.  Lispプログラムからコマンドを関数として呼び出す
場合には使用禁止にしても何の効果もありません.



File: emacs-ja, Node: Keyboard Translations, Next: Syntax, Prev: Key Bindings, Up: Customization

キーボード変換
==============

キーボードの機種によっては, Emacsが使用するすべての特殊文字を送ってく
れないものがあります.  もっともよくある問題は, DEL文字に関するものです. 
いくつかのキーボードでは, このきわめて重要な文字を簡単に打ち込む手段が
ありません.  それは, 削除には`C-h'を使うことを前提としているからです. 
そのようなキーボードで削除のためのキーを打つと, Emacsはそれをプレフィッ
クス文字`C-h'として解釈し, どのヘルプ機能を使うか問い合わせてきてしま
います.  それはユーザーがしたかったことではありません.

Emacs内でこの問題を回避するには, `C-h'をDELに, DELを`C-h'に変換するキー
ボード変換を以下のように設定することで回避できます.

     ;; C-hをDELに変換する. 
     (keyboard-translate ?\C-h ?\C-?)

     ;; DELをC-hに変換する. 
     (keyboard-translate ?\C-? ?\C-h)

キーボード変換はキーマップによるキーバインディング（*Note Keymaps::）
と同じではありません.  Emacsには状況ごとに使い分けられる多数のキーマッ
プがあるのに対し, キーボード変換は一式だけしかなく, Emacsが端末から読
むすべての文字に対してその変換が適用されます.  キーボード変換は入力処
理のいちばん下位のレベルで行われ, キーマップ上の検索はキーボード変換を
施した結果に対して行われます.

XウィンドウシステムではDELETEというキーはファンクションキーであり,
ASCII文字DELとは別ものです.  *Note Named ASCII Chars::.  キーボード変
換はASCII文字入力だけに適用され, ファンクションキーとは無関係ですから,
Xウィンドウシステムでは上の例はDELETEキーに対して効果をもたらしません. 
しかし, Xウィンドウシステムでは上のようなキーボード変換そのものが不要
です.  というのは, EmacsはXウィンドウシステムではBACKSPACEキーと`C-h'
も区別でき, 通常, BAKSPACEをDELとして扱うからです.

キーボード変換の使い方に関する詳しい情報は, *Note 入力イベントの変換:
(elisp-ja)Translating Input.を参照してください.



File: emacs-ja, Node: Syntax, Next: Init File, Prev: Keyboard Translations, Up: Customization

構文テーブル
============

単語や対応した括弧の対を認識するEmacsコマンドはすべて, "構文テーブル"
（syntax table）によって制御されます.  構文テーブルは, どの文字が開き
括弧で, どの文字が単語の中身で, どの文字がシングルクォートかといったこ
とを記述しています.  各メジャーモードにはそれぞれ専用の構文テーブルが
あり（ただし, 互いに関係のあるメジャーモードが1つの構文テーブルを共用
することはある）, 各バッファごとにそのときのメジャーモードの構文テーブ
ルが使われます.  カレントバッファに設定されている構文テーブルはすべて
のコマンドが使うので, 以下ではこれを『現在の』構文テーブルと呼びます. 
構文テーブルは文字テーブル（char-table）型のLispオブジェクトであり, そ
の要素は数値です.

現在の構文テーブルの内容に関する記述を表示するには, `C-h s'
（`descirbe-syntax'）を使います.  記述の表示には各文字ごとに, その文字
の現在の構文を設定するために`modify-syntax-entry'に渡すべき文字列, お
よび, その文字列の英語での説明が含まれます.

構文テーブルに関する詳しい情報については, *Note 構文テーブル:
(elisp-ja)Syntax Tables.を参照してください.



File: emacs-ja, Node: Init File, Next: Quitting, Prev: Syntax, Up: Customization

初期化ファイル`~/.emacs'
========================

Emacsが実行を開始するとき, 通常はユーザーのホームディレクトリにあるファ
イル`.emacs'や`.emacs.el'からLispプログラムをロードします.  このファイ
ルがEmacsの初期化の仕方を指定するので, このファイルのことを"初期化ファ
イル"（init file）と呼びます.  コマンド行オプション`-q'で, Emacsに初期
化ファイルを読まないことを指示したり, `-u'（あるいは`--user'）で, 別の
ユーザーの初期化ファイルを指定できます（*Note Entering Emacs::）.

"デフォルトの初期化ファイル"もあります.  これは`default.el'という名前
のライブラリファイルで, Emacsはライブラリ探索パスをとおしてその場所を
探します.  Emacsの配布には`default.el'は含まれていません.  ローカルな
カスタマイズのためにサイトで`default.el'を用意することもあります.  こ
のファイルがあれば（`-q'を指定したときを除いて）Emacsを開始するときつ
ねにロードされます.  しかし, あるならば個人の初期化ファイルが最初にロー
ドされます.  その中で`inhibit-default-init'に`nil'以外の値を設定すると,
`default.el'はロードされません.

各サイトには"サイトスタートアップファイル"があるかもしれません.  ある
ならば, このファイルの名前は`site-start.el'です.  Emacsはユーザーの初
期化ファイルを読むまえにこのファイルもロードします.  このファイルのロー
ドを抑止するには, オプション`-no-site-file'を指定します.

`.emacs'に大量のコードがある場合には, `~/.emacs.el'と改名してバイトコ
ンパイルしておくべきです.  Emacs Lispプログラムのコンパイルについてよ
り詳しくは, *Note バイトコンパイル: (elisp-ja)Byte Compilation.。

単なるカスタマイズを超えるような実際のEmacsプログラムを書くのであれば,
`The Emacs Lisp Reference Manual' (1) (*Note Init File-Footnotes::)を
読むべきです.  *Note Emacs Lisp: (elisp-ja)Top.

* Menu:

* Init Syntax::	        Syntax of constants in Emacs Lisp.
* Init Examples::       How to do some things with an init file.
* Terminal Init::       Each terminal type can have an init file.
* Find Init::	        How Emacs finds the init file.


File: emacs-ja  Node: Init File-Footnotes, Up: Init File

(1) 【訳注】日本語訳：『Emacs Lispリファレンスマニュアル』, アスキー出
版局, ISBN4-7561-3414-9




File: emacs-ja, Node: Init Syntax, Next: Init Examples, Prev: Init File, Up: Init File

初期化ファイルの構文
--------------------

ファイル`.emacs'にはLispの関数呼び出し式を書きます.  関数呼び出しは, 
関数名に続けて引数リストを並べ, 全体を括弧で囲みます.  たとえば,
`(setq fill-column 60)'は, 関数`setq'によって, 変数`fill-column'
（*Note Filling::）に60を設定します.

`setq'の2番目の引数は変数の新しい値を表す式です.  これは, 定数でも, 変
数でも, 関数呼び出し式でもかまいません.  `.emacs'ファイルでは定数を使
うことがもっとも多いでしょう.  定数にはつぎのものがあります.

数値：
     数値は10進表記し, 先頭にマイナス符号があってもよい.

文字列：
     Lispの文字列の構文はCの文字列の構文とほぼ同じだが, 多少違うところ
     もある.  文字列定数の始まりと終りにはダブルクォートを使う.

     文字列の中には, 改行や特殊文字をそのまま入れることができる.  しか
     し, バックスラッシュで始まる形式, つまり, 改行は`\n', バックスペー
     スは`\b', 復帰は`\r', タブは`\t', ページ送りは`\f'（コントロールL）, 
     エスケープは`\e', バックスラッシュは`\\', ダブルクォートは`\"', 8
     進コードOOOの文字は`\OOO'で表すことができ, そのほうが読みやすい. 
     バックスラッシュとダブルクォートの2つだけは, 文字列に含めるのに必
     ずこのような形で書き表す必要がある.

     `\C-'はコントロール文字を表すプレフィックスとして使用できる.  た
     とえば, `\C-s'でASCIIのコントロールSを表す.  同様に, `\M-'はメタ
     文字を表すプレフィックスとして使用できる.  たとえば, `\M-a'で
     `Meta-A', `\M-\C-a'で`Control-Meta-A'を表す.

文字：
     Lispの文字定数は, `?'に続けて文字または`\'で始まるエスケープシー
     ケンスを書いたもの.  たとえば, `?x', `?\n', `?\)'などは文字定数.
     Lispでは文字と文字列は別ものなので注意すること.  ある場面では文字
     列が必要であり, 別の場面では文字が必要である.

真：
     `t'は「真」を表す.

偽：
     `nil'は「偽」を表す.

その他のLispオブジェクト：
     シングルクォートに続けてそのLispオブジェクトを書く.



File: emacs-ja, Node: Init Examples, Next: Terminal Init, Prev: Init Syntax, Up: Init File

初期化ファイルの例
------------------

以下にはよく使われるLispの式の例をあげておきます.

   * Cモードにおいて, 行の途中でTABが押されたときにはタブ文字を挿入す
     るように設定する.

          (setq c-tab-always-indent nil)

     変数の値を「真」にするには`t'を設定し, 逆に「偽」にするには`nil'
     を設定する.

   * 探索をデフォルトで大文字小文字を区別するように設定する（ただし, 
     違う設定に変更しているバッファは除く）.

          (setq-default case-fold-search nil)

     ここでは`setq-default'で変数のデフォルト値を設定し, その変数に対
     してローカルな値を設定していないすべてのバッファで有効である.
     `setq'で`case-fold-search'に値を設定すると, カレントバッファのロー
     カルな値だけに影響し, 初期化ファイルで記述したいこととは異なるだ
     ろう.

   * Emacsが自動的にメイルアドレスを割り出せない場合に備え, この変数に
     自分のメイルアドレスを指定する.

          (setq user-mail-address "coon@yoyodyne.com")

     メイルアドレスを必要とする多くのEmacsパッケージは,
     `user-mail-address'の値を使う.

   * 新たに作ったバッファのデフォルトのモードをテキストモードにする.

          (setq default-major-mode 'text-mode)

     `text-mode'を指定しているのは, これがテキストモードに入るためのコ
     マンドだから.  コマンド名のまえのシングルクォートは, シンボルを定
     数として扱うため.  さもないと`text-mode'という変数を参照すること
     になってしまう.

   * 西ヨーロッパのほとんどの言語を扱えるLatin-1文字集合をデフォルトと
     する (1) (*Note Init Examples-Footnotes::).

          (set-language-environment "Latin-1")

   * テキストモードやそれに関連するモードでは, 自動詰め込みモードをオ
     ンにする.

          (add-hook 'text-mode-hook
            '(lambda () (auto-fill-mode 1)))

     これはノーマルフック変数（*Note Hooks::）にフック関数を追加する例. 
     ここでは関数として`lambda'で始まるリストを指定し, シングルクォー
     トを前置して式ではなく定数として扱わせる.

     Lispの関数について説明するのは本書の範囲外だが, この例を理解する
     には, テキストモードに入るときに`(auto-fill-mode 1)'が実行される
     のだと考えておけば十分.  この式を別の式に変えたり, 式を複数並べて
     もかまわない.

     Emacsには`turn-on-auto-fill'という関数が用意されており, その定義
     は`(lambda () (auto-fill-mode 1))'になっている.  したがって, 上の
     例をもっと簡単に書くとつぎのようになる.

          (add-hook 'text-mode-hook 'turn-on-auto-fill)

   * あらかじめ用意してあるLispライブラリ`foo' （実際には標準Emacsディ
     レクトリに置かれたファイル`foo.elc' または`foo.el'）をロードする.

          (load "foo")

     `load'に渡す引数が相対ファイル名, つまり, `/'や`~'で始まらない場
     合には, `load'は`load-path'（*Note Lisp Libraries::）のディレクト
     リ群を順に探索する.

   * 自分のホームディレクトリにあるコンパイル済みのLispファイル
     `foo.elc'をロードする.

          (load "~/foo.elc")

     ここでは絶対ファイル名が使われているので, 探索は行わない.

   * キー`C-x l'で関数`make-symbolic-link'が実行されるようにバインディ
     ングを設定する.

          (global-set-key "\C-xl" 'make-symbolic-link)

     または

          (define-key global-map "\C-xl" 'make-symbolic-link)

     ここでもシンボル`make-symbolic-link'を変数としての値ではなく定数
     とするためにシングルクォートが使われていることに注意.

   * 上と同じだが, Lispモードの中だけでのバインディングを設定する.

          (define-key lisp-mode-map "\C-xl" 'make-symbolic-link)

   * 基本（fundamental）モードで`next-line'を実行するようになっている
     すべてのキーを, かわりに`forward-line'を実行するように直す.

          (substitute-key-definition 'next-line 'forward-line
                                     global-map)

   * `C-x C-v'を未定義にする.

          (global-unset-key "\C-x\C-v")

     キーを未定義にする必要のある場合の1つとして, そのキーをプレフィッ
     クスにしたい場合がある.  たとえば, `C-x C-v ANYTHING'を定義すると,
     `C-x C-v'は自動的プレフィックスになるが, しかしそのまえに`C-x
     C-v'の通常の（プレフィックスではない）定義を未定義に戻しておく必
     要がある.

   * `$'をテキスト（text）モードでの区切り文字にする.  `$'を文字定数と
     して指定していることに注意.

          (modify-syntax-entry ?\$ "." text-mode-syntax-table)

   * コマンド`narrow-to-region'を確認なしに使えるようにする.

          (put 'narrow-to-region 'disabled nil)


File: emacs-ja  Node: Init Examples-Footnotes, Up: Init Examples

(1) 【訳注】日本語環境を設定するには,
     (set-language-environment "Japanese")
とする.



File: emacs-ja, Node: Terminal Init, Next: Find Init, Prev: Init Examples, Up: Init File

端末に固有の初期化
------------------

各端末種別ごとに, Emacsがその端末で動くときにロードするライブラリを指
定できます.  つまり, TERMTYPEという名前の端末でEmacsを起動するときには,
`term/TERMTYPE'というライブラリがロードされます.  ライブラリの探索は通
常どおり`load-path'の各ディレクトリに対して行われ, ファイルの拡張子は
`.elc'か`.el'です.  通常, これらのライブラリはほとんどのEmacsライブラ
リを収めたディレクトリの下の`term'というサブディレクトリに置かれます.

端末固有のライブラリの普通の用途は, 端末のファンクションキーによって送
出されるエスケープシーケンスを`function-key-map'を使って意味のある名前
に対応付けることです.  このような設定を行うファイルの例として, たとえ
ばファイル`term/kl201.el'を見てみてください.  多くのファンクションキー
はtermcapデータベースの情報に基づいて自動的に対応付けがなされます.  端
末固有ライブラリでは, termcapで指定されていないファンクションキーだけ
を対応付ければよいのです.

端末種別にハイフンが含まれている場合は, ライブラリ名の選択には最初のハ
イフンよりまえの部分だけが使われます.  つまり, 端末種別`aaa-48'と
`aaa-30-rv'では, どちらも`term/aaa'をロードします.  ライブラリ中のコー
ドでは`(getenv "TERM")'を使って必要なら完全な端末種別名を取得できます.

端末ライブラリの名前は, 変数`term-file-prefix'と端末種別とを連結して作
られます.  ファイル`.emacs'中で`term-file-prefix'を`nil'に設定すると端
末ライブラリのロードを抑止できます.

Emacsは`.emacs'と端末ライブラリを読んだあと, 初期化の最後にフック
`term-setup-hook'を実行します.  端末ライブラリによる指定を一部変更した
り, 端末ライブラリがない端末の初期設定を行いたければ, このフックにフッ
ク関数を追加してください.  *Note Hooks::.



File: emacs-ja, Node: Find Init, Next: Quitting, Prev: Terminal Init, Up: Init File

個人の初期化ファイルの探し方
----------------------------

通常, Emacsは環境変数`HOME'に基づいて`.emacs'を探し, ファイル名の`~'の
意味を定めます.  しかし, `su'を実行したあとでは, Emacsは（su実行前の）
もとのユーザーの`.emacs'を読もうとし, suした先のユーザーのではありませ
ん.  これは, たとえスーパーユーザーになっているとしても, 本来のユーザー
独自のエディタのカスタマイズを使うべきだと考えるからです.

より正確には, Emacsはまずどのユーザーの初期化ファイルを使うかを決めま
す.  それにはまず環境変数`LOGNAME'および`USER'からユーザー名を取得しま
す.  これらの環境変数がみつからなければ, Emacsは実効ユーザーIDを参照し
ます.  ユーザー名と実ユーザーIDが一致すれば, Emacsは`HOME'を利用します. 
一致しない場合は, システムのユーザーデータベースからそのユーザー名に対
応するホームディレクトリを探して使用します.



File: emacs-ja, Node: Quitting, Next: Lossage, Prev: Customization, Up: Top

中断とアボート
==============

`C-g'
`C-BREAK（MS-DOS）'
     中断する.  動作中のコマンドや打鍵途中のコマンドを取り消す.
`C-]'
     アボートする.  いちばん内側の再帰編集レベルを強制的に終了し, その
     再帰編集レベルを起動したコマンドを取り消す
     （`abort-recursive-edit'）.
`ESC ESC ESC'
     中断かアボートのいずれか意味のあるほうを実行する
     （`keyboard-escape-quit'）.
`M-x top-level'
     現在実行中のすべての再帰編集レベルを強制的に終了する.
`C-x u'
     バッファの内容に対して行った直前の変更を取り消す（`undo'）.

実行を完了していないコマンドを取り消すには, 2つの方法があります.  1つ
は`C-g'で"中断"すること, もう1つは`C-]'や`M-x top-level'で"アボート"す
ることです.  中断とは, 打鍵途中のコマンドや動作中のコマンドを取り消す
ことをいいます.  アボートとは, 再帰編集レベルから抜け出し, かつ, その
再帰編集レベルを起動したコマンドを取り消すことをいいます（*Note
Recursive Edit::）.

`C-g'での中断は, 打鍵途中のコマンドや不要な数引数を打ってしまったとき
にとりやめるのに使います.  また, 実行途中のコマンドを比較的安全な方法
で止めますから, 長時間かかるコマンドをうっかり始めてしまったときにも使
えます.  特に, キル操作を中断しても安全です.  テキストは, まだ*すべて*
バッファ内にあるか, または, *すべて*キルリングに入っている（あるいは, 
その両方に入っている）からです.  なお, インクリメンタルサーチを中断す
る場合には, 文字列探索のところで説明してあるように, 特別な動作を行いま
す.  一般には, サーチから抜け出すには`C-g'を2回連打する必要があります
（*Note Incremental Search::）.

MS-DOSでは, `C-BREAK'は`C-g'と同様に中断として働きます.  MS-DOSでは, 
コマンドの実行中にユーザーとのやりとりを行う状態にないときには, `C-g'
を検出できないからです.  これに対して, `C-BREAK'はつねに認識*でき*ます.
*Note MS-DOS Input::.

`C-g'はつぎのように動作します.  `C-g'が打鍵されると変数`quit-flag'に
`t'が設定されます.  Emacs Lispはこの変数を頻繁に調べ, 値が`nil'以外だ
と中断処理を行います.  `C-g'が実際にコマンドとして実行されるのは,
Emacsが入力待ち状態にあるときに`C-g'を打った場合だけです.

最初の`C-g'が認識されないうちに2つめの`C-g'を打って中断すると, 『緊急
脱出』機能を発動したことになりシェルに戻ります.  *Note Emergency
Escape::.

中断できない場合もありえます.  Emacsがオペレーティングシステムに何かを
頼んで待っているときには, 待ち状態を起こしたシステムコールを使った
Emacs側で特別な手当てをしない限り中断できません.  Emacsでは, ユーザー
が中断しそうなシステムコールには手当てを施してありますが, 手当てしてい
ない場所を叩く可能性はあります.  よくあるのは, NFS経由の入出力を待って
いるときです.  Emacs側ではこれを中断する方法はわかっているのですが, 多
くのNFSの実装では, NFSサーバーが固まったときにユーザープログラムがNFS
の待ちを中断することを許していないのです.

`C-]'によるアボート（`abort-recursive-edit'）は, 再帰編集レベルから脱
出し, かつ, その再帰編集レベルを起動したコマンドを取り消すのに使います.
`C-g'による中断はこのような目的には使えませんし, このようなことはでき
ません.  というのは, `C-g'は, ある再帰編集レベルの*中で* 打ちかけたコ
マンドを取り消すのに使うからです.  どちらの操作も必要なものです.  たと
えば, 再帰編集中に数引数を入力しようとして`C-u 8'と打鍵した場合, `C-g'
で数引数を取り消しても再帰編集に留まったままです.

コマンド`ESC ESC ESC' （`keyboard-escape-quit'）は, 中断かアボートのい
ずれかを行います.  このキーを使うのは, 多くのPCのソフトでESCが『抜け出
す』の意味に使われているからです.  `C-g'と同様に, 数引数を取り消したり, 
選択したリージョンをクリアしたり, 問い合わせ型置換操作から抜け出します.
`C-]'と同様に, ミニバッファや再帰編集から抜け出します.  また, `C-x 1'
のように, フレームを複数ウィンドウに分割しているのをやめることもできま
す.  しかしながら, 実行中のコマンドを止めることはできません.  なぜなら, 
このコマンドは普通のコマンドとして実行されるので, Emacsがコマンドを読
み込む状態にならないとこのコマンドを認識しないからです.

コマンド`M-x top-level'は, 現在入っているすべての再帰編集レベルから抜
け出すのに『十分な』数の`C-]'と同等です.  `C-]'は一度に1レベルだけ抜け
出すのに対し, `M-x top-level'はすべてのレベルを一気に抜け出します.
`C-]'も`M-x top-level'も他のコマンドと同様の普通のコマンドですから,
`C-g'とは違って, Emacsがコマンドを受け付ける状態のときだけ動作します.
`C-]'は普通のキーであり, キーマップにそのバインディングがあるのでその
ように動作するのです.  *Note Recursive Edit::.

`C-x u'（`undo'）は, 正確にいえばコマンドを取り消すわけではありません
が, 動作を完了してしまったコマンドを取り消すものと考えることができます.
*Note Undo::.



File: emacs-ja, Node: Lossage, Next: Bugs, Prev: Quitting, Up: Top

Emacsのトラブルに対する対処
===========================

本節では, Emacsが正常に動作し損なうさまざまな条件と, それらの見分け方, 
直し方について説明します.

* Menu:

* DEL Gets Help::       What to do if DEL doesn't delete.
* Stuck Recursive::     `[...]' in mode line around the parentheses.
* Screen Garbled::      Garbage on the screen.
* Text Garbled::        Garbage in the text.
* Unasked-for Search::  Spontaneous entry to incremental search.
* Memory Full::         How to cope when you run out of memory.
* After a Crash::       Recovering editing in an Emacs session that crashed.
* Emergency Escape::    Emergency escape---
                          What to do if Emacs stops responding.
* Total Frustration::   When you are at your wits' end.



File: emacs-ja, Node: DEL Gets Help, Next: Stuck Recursive, Prev: Lossage, Up: Lossage

DELで削除できない
-----------------

DELが文字を削除するかわりに`Control-h'のようにヘルプに入ってしまう場合
には, 使っている端末がDELに対してまちがった文字コードを送出しています. 
この問題に対処するには, キーボード変換表を変更します（*Note Keyboard
Translations::）.



File: emacs-ja, Node: Stuck Recursive, Next: Screen Garbled, Prev: DEL Gets Help, Up: Lossage

再帰編集レベル
--------------

再帰編集レベルはEmacsの重要で有用な機能ですが, それについて理解してい
ない人にとっては, 誤動作に見える可能性があります.

モード行のメジャー／マイナモード名を囲む丸括弧の周囲に中括弧`[...]'が
表示されているときは, 再帰編集レベルに入っています.  意図してそうした
のでなかったり, 再帰編集レベルの意味を理解していないのであれば, 再帰編
集レベルから抜け出すべきです.  それには`M-x top-level'と打ちます.  こ
れをトップレベルへの抜け出しと呼びます.  *Note Recursive Edit::.



File: emacs-ja, Node: Screen Garbled, Next: Text Garbled, Prev: Stuck Recursive, Up: Lossage

画面上のゴミ
------------

画面上のデータがまちがっているように見えたら, まず最初にすべきことは, 
テキストが本当にまちがっているのかどうか調べることです.  `C-l'と打って
画面全体を再描画します.  これで画面が正しそうになるのなら, 問題は画面
更新にあったのです.  （そうでない場合は, *Note Text Garbled::）.

画面更新の問題は, 使っている端末に対応するtermcapの定義がまちがってい
る場合が多いです.  Emacsの配布に含まれるファイル`etc/TERMS'には, この
種の問題で既知のものに対する修正が入っています.  ファイル`INSTALL'には, 
この種の問題に対する一般的なアドバイスの節があります.  いちばんありが
ちなのは, ある種の画面操作に対するパディング (1) (*Note Screen
Garbled-Footnotes::) が不足している場合です.  この種の問題があるかどう
か調べるには, 他のメーカ製の別の端末でEmacsを動かしてみてください.  あ
る機種の端末では頻繁に問題が起きるのに別の機種の端末では問題がないなら,
termcapの定義がまちがっている可能性があります.  しかし, ある種の機能を
有するか欠如している端末で現れるEmacsのバグである可能性もあります.



File: emacs-ja  Node: Screen Garbled-Footnotes, Up: Screen Garbled

(1) 【訳注】端末にとっては無意味で無害な文字を, （動作が完了するまでの）
時間稼ぎのために送出すること.



File: emacs-ja, Node: Text Garbled, Next: Unasked-for Search, Prev: Screen Garbled, Up: Lossage

テキスト内のゴミ
----------------

`C-l'を実行してもテキストが変ならば, 正しいと思われる状態になるまで,
`C-x u'を使って変更をもとに戻してみてください.  また, どのコマンドで変
になったのか調べるために, `C-h l'を試してみてください.

バッファの先頭や末尾で大量のテキストが失われているようなら, モード行に
単語`Narrow'が表示されていないか確認してください.  もしそうなら, おそ
らくテキストは失われているのではなく, 一時的に見えなくなっているのでしょ
う.  見えるようにするには, `C-x n w'と打ってください.  *Note
Narrowing::.



File: emacs-ja, Node: Unasked-for Search, Next: Memory Full, Prev: Text Garbled, Up: Lossage

自発的なインクリメンタルサーチの開始
------------------------------------

Emacsが画面の最下行に自発的に`I-search:'と表示するようなら, 劣悪な
xon/xoffの『フロー制御プロトコル』に従って端末が`C-s'と`C-q'を送ってい
るためでしょう.

もしこの状態が起きたら, もっともよいのは端末をフロー制御なしに設定する
か, または, パディングを十分に増やして端末がけっして`C-s'を送らないよ
うにすることです.  （パディングを増やす1つの方法は, より大きい値を変数
`baud-rate'に設定すること.  この値はボーという単位で表した端末の出力速
度. ）

フロー制御を止められない場合の次善の策は, Emacsにフロー制御を処理させ
ることです.  それには, 関数`enable-flow-control'を呼び出してください.

典型的な場合, ある種の端末タイプに限ってフロー制御を使う必要があります.
`enable-flow-control-on'を使って, そのような種類の端末に限ってフロー制
御を行うようにできます.  たとえば, VT-100端末とH19端末にはフロー制御を
行う必要があるのなら, ファイル`.emacs'につぎのものを入れます.

     (enable-flow-control-on "vt100" "h19")

フロー制御を使っている場合には, `C-s'のかわりに`C-\', `C-q'のかわりに
`C-^'を使う必要があります.  （これらの割り当てはキーボード変換によって
行われる.  *Note Keyboard Translations::. ）



File: emacs-ja, Node: Memory Full, Next: After a Crash, Prev: Unasked-for Search, Up: Lossage

メモリ不足
----------

`Virtual memory exceeded'というエラーメッセージが出たら, 変更したバッ
ファを`C-x s'で保存してください.  この方法で保存する場合, 必要なメモリ
は最小限ですみます.  Emacsは上記のエラーが起きたときでも使える予備のメ
モリを確保していますから, `C-x s'を完了するのには十分なはずです.

変更済みのバッファを保存したら, Emacsを終了して別のEmacsを起動してもよ
いですし, `M-x kill-some-buffer'を使って現在動いているEmacsのメモリを
解放してもよいです.  大量のテキストが入っているバッファを消せば, 安全
に編集を続行できます.  空きメモリが十分な量になると予備のメモリを自動
的に確保し直し, 再度メモリ不足になったときに備えます.

メモリ不足になったときには, `M-x buffer-menu'を使ってバッファを保存し
たり消したりしないでください.  このコマンドはけっこうメモリを必要とす
るので, 確保した予備のメモリだけでは十分でない可能性があるからです.



File: emacs-ja, Node: After a Crash, Next: Emergency Escape, Prev: Memory Full, Up: Lossage

クラッシュからの回復
--------------------

Emacsやコンピュータがクラッシュしても, クラッシュ時に編集していたファ
イルは自動保存ファイルから回復できます.  それには, Emacsを再度起動して
から, コマンド`M-x recover-session'を入力してください.

このコマンドは, まず, 中断されたセッションファイルの一覧を日付とともに
バッファに表示します.  その中からどのセッションを回復するか選んでくだ
さい.  通常は, 最新のセッションを選べばよいでしょう.  望みのセッション
の行にポイントを動かして, `C-c C-c'と打ちます.

すると, `recover-session'は, そのセッションで編集中だった各ファイルに
ついて回復するかどうか問い合わせてきます.  `y'と答えると, そのファイル
と自動保存ファイルの日付を表示してから, 回復するかどうか再度問い合わせ
てきます.  再問い合わせに対しては`yes'で答える必要があります.  そうす
ると, Emacsはそのファイルを訪れますが, テキストは自動保存ファイルから
持ってきます.

`recover-session'が完了すると, 回復を指定したファイルはEmacsバッファに
入っています.  そうしたらこれらのバッファを保存してください.  保存して
始めてもとのファイルが更新されます.



File: emacs-ja, Node: Emergency Escape, Next: Total Frustration, Prev: After a Crash, Up: Lossage

緊急脱出
--------

バグのために, Emacsが`quit-flag'を検査しないループに入ってしまうことも
ありえます.  このため, このフラグが設定されている状態で再度`C-g'が打た
れるとただちに実行を休止する特別な機能がEmacsにはあり, いつでもGNU
Emacsから抜け出すことができます.  通常, Emacsはすみやかに`quit-flag'を
認識し（中断し）ますから, この特別な機能が使われることはまずありません. 
（MS-DOSや互換システムでは, `C-BREAK'を2回連打する. ）

`C-g'の連打によって休止したEmacsを再開すると, Emacsは休止直前に実行し
ていた動作に戻るまえに, つぎの2つの質問をしてきます.

     Auto-save? (y or n)
     Abort (and dump core)? (y or n)

それぞれの質問に対し, `y'か`n'に続けてRETで答えてください.

`Auto-save?'に`y'と答えると, 自動保存を行う設定になっている変更された
バッファすべてに対してただちに自動保存を実行します.

`Abort (and dump core)?'に`y'と答えると, Emacsは不正命令を実行してコア
ダンプを作ります.  コアダンプがあると, Emacsが中断できなかった理由をウィ
ザード (1) (*Note Emergency Escape-Footnotes::) が追究できます.  コア
ダンプを作り終えるとEmacsの実行は終了します.  `n'と答えると実行は継続
します.  運がよければ, Emacsが最終的には`quit-flag'を検査して正常に中
断できるでしょう.  運が悪ければ, またループに入ったままになりますから, 
再度`C-g'を打ってEmacsをまた休止します.

本当はEmacsが固まったのではなく単に遅いだけの場合には, 意図せずに`C-g'
を連打してしまうことがあります.  その場合には, 再開して2つの質問に`n'
と答えればもとの状態に戻れます.  中断要求はすぐに受け付けられるでしょ
う.

XウィンドウシステムのもとでEmacsが動作している場合には, `C-g'連打の機
能は切ってあります.  というのは, ウィンドウマネージャを使ってEmacsを終
了させたり, 別のウィンドウを開いて別のプログラムを動かせるからです.

MS-DOSや互換システムでは, （MS-DOSやBIOSの）システムコールが固まってい
る場合やEmacsが非常にきつい（Lispコードでは*なく*Cのコードで）無限ルー
プに入っている場合には, `C-BREAK'を2回打っても緊急脱出の機能を使えない
場合があります.


File: emacs-ja  Node: Emergency Escape-Footnotes, Up: Emergency Escape

(1) 【訳注】「名人, 熟練者, 魔術師」の意味だが, 特定のコンピュータや
（特に）ソフトウェアに精通した人を指す.



File: emacs-ja, Node: Total Frustration, Next: Bugs, Prev: Emergency Escape, Up: Lossage

いらいらしたら…
----------------

Emacsを使うこと（や, その他のこと）がきわめて不愉快になったり, ここま
でにあげたどの方法でも問題が解決しない場合でも, Emacsはまだ手助けがで
きます.

まず, Emacsがコマンドに応答しないようなら, `C-g C-g'と打ってEmacsから
抜け出し, 新たに別のEmacsを起動してください.

つぎに, `M-x doctor RET'と打ってください.

doctorプログラムがあなたのいらいらを鎮めてくれるでしょう.  doctorに何
かを話すときには, RET RETと打っていい終える必要があります.  こうすると,
doctorは患者が話し終えたことを認識します.



File: emacs-ja, Node: Bugs, Next: Contributing, Prev: Lossage, Up: Top

バグの報告
==========

Emacsのバグに出会うこともあるでしょう.  バグを修正する／できるとは約束
できませんし, そもそもバグだと認めないかもしれませんが, 読者が遭遇した
問題については知らせてほしいと考えています.  たしかにそれをバグだと認
めて修正しようということになる場合も多いのです.

バグを修正するには, まず, 報告してもらう必要があります.  効果的に報告
してもらうためには, 報告の仕方を知っていただく必要があります.

* Menu:

* Criteria:  Bug Criteria.	 Have you really found a bug?
* Understanding Bug Reporting::	 How to report a bug effectively.
* Checklist::			 Steps to follow for a good bug report.
* Sending Patches::		 How to send a patch for GNU Emacs.



File: emacs-ja, Node: Bug Criteria, Next: Understanding Bug Reporting, Prev: Bugs, Up: Bugs

バグの発生時期
--------------

Emacsが不正命令を実行したり, （『ディスクが満杯』などの外部の問題では
なく）プログラムに問題があるというオペレーティングシステムのメッセージ
を表示して止まった場合には, たしかにバグがあるといえます.

Emacsの画面の更新結果がバッファの内容に対応していないなら, それもたし
かにバグです.  コマンドの実行が思わしくなくても`C-l'で再表示させると正
しくなる場合には, 画面更新がまちがっているのです.

あるコマンドを実行するのに無限に時間がかかるというのはバグの可能性があ
りますが, たしかにEmacsの責任かどうかを確認する必要があります.  コマン
ドによってはとても時間がかかるものもあります.  `C-g'（MS-DOSでは
`C-BREAK'）を打ってから`C-h l'を打つことで, Emacsが受け付けた入力がた
しかに読者が意図したものだったかどうか確認できます.  すぐに処理される
コマンドだという*確信*があるなら, バグを報告してください.  そのコマン
ドがすごく時間のかかるものかどうかわからないなら, マニュアルで調べるか
知っている人に聞いてください.

よく知っているコマンドであって, 普通なら問題なく結果が得られるはずなの
に, かわりにEmacsがエラーメッセージを出すようなら, 恐らくそれはバグで
しょう.

コマンドが正しくない動作をするのなら, それはバグです.  ただし, コマン
ドが本当は何をするのが正しいか確認してください.  そのコマンドに馴染み
がないとか, そのコマンドがどう動作するはずなのか確信が持てない場合は, 
コマンドは実際には正しく動作しているのかもしれません.  バグという結論
に飛びつくまえに, よく知っている人に見てもらってください.

最後に, コマンドの意図された定義が編集操作に対して最良でない可能性があ
ります.  これは重要な問題ではありますが, ユーザーがどう判断するかの問
題でもあります.  既存の機能について無知なために, まちがっていると結論
を出してしまうのも簡単です.  まずドキュメントをひととおり調べて, 十分
に納得し, それでもなお自分にとって必要な機能がない, と断言できるまでは, 
コマンドの定義が悪いなどとはいわないほうがよいでしょう.  マニュアルを
熟読してもコマンドが何をするのかよくわからなければ, 索引や用語集を活用
してよくわからない単語について調べましょう.

十分熟読しても, なおコマンドが何をするのかわからないなら, それは「マニュ
アルのバグ」として報告すべきでしょう.  マニュアルは, 読者を含めて,
Emacsの専門家でない人が読んでもすべてのことが明らかになるようなもので
あるべきです.  ドキュメントのバグを報告することも, プログラムのバグを
報告することと同じくらい重要なことです.

関数や変数のオンラインの説明文がマニュアルと一致しない場合は, どちらか
がまちがっていますから, これもバグです.



File: emacs-ja, Node: Understanding Bug Reporting, Next: Checklist, Prev: Bug Criteria, Up: Bugs

バグの報告とは
--------------

バグがあると確信したら, それを報告すること, しかも, 役立つ形で報告する
ことが重要です.  もっとも有用なのは, どのようなコマンドを打ち込んだか
を, Emacsを起動するシェルのコマンドから始めて問題が起きるところまです
べて正確に記述することです.

バグを報告するときもっとも重要なことは*事実*を報告することです.  仮説
や口頭説明は, 詳細な生データのかわりにはなりません.  事実を報告するこ
とは単純なはずなのに, 多くの人はかわりに説明をでっちあげてそれを報告し
たがります.  その説明がEmacsの実装方式の想像に基づいたものであるならば, 
その説明はまったく役に立たないでしょう.  事実が欠けていたらバグに関す
る真の情報を得られません.

たとえば, ユーザーがとても大きなファイルを訪れるために`C-x C-f
/glorp/baz.ugh RET'と打ち込んだら, Emacsが`I feel pretty today'と表示
したとしましょう.  もっともよいバグレポートは, まさにこの文のように報
告することです.  すべての事実だけを報告できるからです.

問題はファイルの大きさにあると仮定して, 「大きなファイルを訪問したら,
Emacsが`I feel pretty today'と表示した」などと書いてはいけません.  こ
れが『説明をでっちあげた』報告です.  問題はファイル名に`z'が含まれてい
たために生じたのかもしれないのです.  もしそうだとしたら, 報告に基づい
て適当な「大きなファイル」を訪問してみても, そのファイル名に`z'が含ま
れていなければ何も悪いところがみつからないでしょう.  報告の文面からは, 
名前に`z'を含んだファイルを試しに訪問してみるべきだとはわかりません.

あるいは, ファイルがちょうど25個の空白文字で始まっているために問題が起
きたのかもしれません.  ですから, 報告に際しては, そのバグを再現させる
のに必要なファイルがあれば, それらのファイルの正確な内容も教えてくださ
い.  その問題は, たまたま, `C-x C-a'と打った直後にのみ発生するのだとし
たらどうでしょう？` ' ですから, Emacsを起動してから問題に遭遇するまで
に打ち込んだものすべてを教えてほしいのです.

どの訪問コマンドを使っても同じように問題が発生すると*知っている* ので
ない限り, `C-x C-f'と打ったと報告するかわりに「ファイルを訪問した」と
いうのさえいけません.  同様に, 「1行に3文字入っているとき」ではなく, 
「`RET A B C RET C-p'と打ち込んだあとで」のように, あなたがテキストを
入れたやり方そのものを報告してください.

このように, バグを報告するときには, いかなる説明も推測しないでください. 
問題を実際に*デバッグ*して憶測ではない説明を報告してもらえるなら, それ
は有益ですが, 事実も含めてください.



File: emacs-ja, Node: Checklist, Next: Sending Patches, Prev: Understanding Bug Reporting, Up: Bugs

バグレポートのチェックリスト
----------------------------

バグレポートを送る最良の方法は, 電子メイルでEmacs保守チーム
`bug-gnu-emacs@gnu.org'に送ることです.  （重要な改良の提案などもここに
送ってください）.

他から出されたバグレポートが読みたければ, ニュースグループ
`gnu.emacs.bug'で読めます.  ただし, 傍観者として見る場合には, 見たもの
について批判するべきではない, ということを承知しておいてください.  バ
グレポートの目的はEmacs保守チームに情報を提供することです.  傍観者は, 
この目的に干渉しない限りは, 歓迎します.  特に, 大量のデータが添付され
ているバグレポートもありますので, 傍観者はそのことを非難すべきではあり
ません.

ネットニュース経由でバグレポートを投稿しないでください.  ネットニュー
スよりもメイルのほうが送り手のメイルアドレスが確実にわかり信頼できます. 
もっと情報が必要なときには, メイルで問い合わせる必要があるかも知れませ
ん.

電子メイルを送れない場合には, 紙や他の機械可読な媒体で下記へ送ってくだ
さい.

GNU Emacs Bugs
Free Software Foundation
59 Temple Place, Suite 330
Boston, MA 02111-1307 USA

バグを修正するとは約束できません.  しかし, 重大なバグや, 醜いバグや, 
簡単に直せるバグなら, 直したいと思います.

Emacsのバグレポートを送るのに便利な方法の1つは, コマンド`M-x
report-emacs-bugs'を使うことです.  このコマンドはメイルバッファ（*Note
Sending Mail::）を開いて, 自動的に重要な情報*の一部*を書き込みます. 
しかし, 必要な情報をすべて入れられるわけではありませんから, 以下の指針
を読んでそれに従い, メッセージを送るまえに重要な情報を自分で打ち込んで
ください.

保守チームがバグの調査を開始するためには, 以下のすべてがバグレポートに
含まれている必要があります.

   * Emacsのバージョン番号.  これがないと, GNU Emacsの最新版でバグを探
     すべきかどうか判断できない.

     バージョン番号を調べるには, `M-x emacs-version RET'と打つ.  この
     コマンドが動作しないようなら, GNU Emacsではないエディタを使ってい
     るようなので, どこか別のところへバグを報告する.

   * 使っているマシンの種類, オペレーティングシステムの名前とバージョ
     ン.  `M-x emacs-version RET'でこれらの情報も表示される.
     `*Messages*'バッファからその出力をコピーすれば, すべての情報をま
     ちがいなく送れる.

   * Emacsをインストールしたときの`configure'コマンドの引数.

   * Emacsソースに変更を加えた場合は, そのすべてのリスト.  （ソースを
     修正したEmacsで起きたバグまでも調査する時間はない.  しかし, 修正
     を加えたのにそれを教えてくれなければ, 厄介ごとを他人に押し付けて
     いるだけ. ）

     これらの変更については正確に記してほしい.  英語での説明では不十分. 
     ソースのコンテキストdiffを送ること.

     独自のファイルを追加したり, 別のマシンに移植するのも, ソースの変
     更にあたる.

   * その他, GNU Emacsの標準のインストール手順と違っているところがあれ
     ば, すべて詳しく記述する.

   * そのバグを再現するために必要なすべてのファイルの内容.

     ファイルをまったく訪問せずに問題が再現可能なら, ぜひ教えてほしい. 
     そのほうがデバッグがずっと楽になる.  どうしてもファイルが必要なら, 
     必ずその内容が正確にわかるようにすること.  たとえば, 行末に空白文
     字が付いているかどうかとか, バッファの最終行に改行文字があるかど
     うかが問題になることは頻繁にある（最終行に改行があるかどうかで何
     か違いがあるべきではないのだが, もし違いが生じるようならそれもバ
     グといえる）.

   * バグを再現させるために打ち込む正確なコマンド列.

     Emacsへの入力を正確に記録する簡単な方法は, ドリブルファイルに書く
     ことである.  ドリブルファイルを開始するには, Emacsを実行開始した
     直後に, `M-:'かバッファ`*scratch*'でつぎのLisp式を実行する.

          (open-dribble-file "~/dribble")

     それ以降はEmacsプロセスが終了するまで, Emacsはすべての入力をドリ
     ブルファイルにコピーする.

   * 表示に関するバグの可能性がある場合には, 端末種別（環境変数`TERM'
     の値）, （すべてのマシンで同じとは限らないので）`/etc/termcap'ファ
     イル中の当該端末のtermcapの定義すべて, および, Emacsが実際に端末
     に送った出力.

     端末への出力を収集するには, Emacsを実行開始した直後に, `M-:'かバッ
     ファ`*scratch*'でつぎのLisp式を実行する.

          (open-termscript "~/termscript")

     それ以降, Emacsはプロセスが終了するまでのすべての端末出力の写しを
     指定されたtermscriptファイルに書き出す.  Emacsが起動するときに問
     題が起きるのなら, 上の式を`.emacs'ファイルに入れて, Emacsが最初に
     画面を開くときに一緒にtermscriptファイルも書き始めるようにする.

     ただし, 端末に依存したバグは, そのバグの出る端末なしで直すことは
     難しいことが多く, ときとして不可能であることも承知しておいてほし
     い.

   * 正しくないと結論したことがどう正しくないのか記述する.  たとえば, 
     「Emacsプロセスが致命的なシグナルを受け取る」とか「最終的なテキス
     トはつぎのようになるが, これは正しくない. 」など.

     もちろん, Emacsが致命的なシグナルを受け取るのなら, それは誰にでも
     わかる.  しかし, バグが正しくないテキストだとすると, 保守チームに
     はどこが正しくないのかわからない可能性がある.  そういう可能性のあ
     る書き方はやめてほしい.

     遭遇する問題が致命的なシグナルだとしても, はっきりとそう書くべき
     である.  たとえば, Emacsのソースが一部違っている版だったとか, シ
     ステムのCライブラリのバグに遭遇したといった奇妙なことに出会ったと
     しよう（実話！）.  あなたが使っているEmacsはクラッシュするが, 保
     守チームのほうでは何ともない.  クラッシュすると*いって*もらえれば, 
     保守チームのほうで実行してクラッシュしなければバグが再現しないと
     わかる.  しかしそういってもらえないと, バグが再現したのかどうかさ
     えわからずに, 試してみた結果からは何の結論も得られない.

   * バグの結果がEmacsのエラーメッセージであれば, そのエラーメッセージ
     の文面を正確に報告することと, Emacs中のLispプログラムがどうやって
     そのエラーの箇所に到達したかを示すバックトレースを報告することが
     重要.

     エラーメッセージの文面を正確に報告するには, `*Message*'バッファか
     らメッセージをバグレポートにコピーする.  一部ではなく, 全体をコピー
     してほしい.

     エラーのバックトレースを取得するには, エラーが発生するよりまえにLisp式
     `(setq debug-on-error t)'を評価する
     （つまり, まずこのLisp式を実行して, それからエラーを再現させる）. 
     すると, エラーが起きたときにLispデバッガが実行され, 
     デバッガがバックトレースを表示する. 
     このデバッガのバックトレース出力を, バグレポートにコピーする. 

     このやり方は, バグを再現できるときだけ使える.  再現できない場合は, 
     最低限, エラーメッセージだけでもすべてコピーする.

   * 個人のファイル`.emacs'を含めてロードしたLispコードのどれかが,
     Emacsの動作に影響するような変数設定を行っていないか確認する.  ま
     た, （オプション`-q'を指定して初期化ファイルのロードを抑制して）
     個人のファイル`.emacs'をロードせずに起動したEmacsでもエラーが再現
     するかどうか調べる.  これでエラーが再現*しない*なら, エラーの再現
     に必要なので, ロードしたすべてのプログラムの内容を正確に報告する.

   * 問題が初期設定ファイルや標準のEmacsシステムに含まれないLispプログ
     ラムに依存するなら, まずそれらを保守している人に相談して, それら
     のプログラムの問題ではないことを確認する.  その人たちが, そのコー
     ドはEmacsの正しい使い方をしていると確認したうえで, その人たちがバ
     グを報告するべきである.

   * GNU Emacsのソースに関して何かコメントしたいなら, その部分のコード
     を前後数行を含めて示したうえでコメントする.  行番号だけ書くという
     のはやめてほしい.

     開発中のソースの行番号とユーザーが入手するソースの行番号とは同じ
     ではない.  あなたが使っているバージョンのソースの何行目が, 開発中
     のソースの何行目に対応しているか調べるのは余分な手間であり, 正確
     にはわからないかもしれない.

   * GDBなどのC言語用のデバッガからの追加情報があると, 保守チームの手
     元にないマシンでもバグの原因がわかることもある.  もしGDBの使い方
     がわからないようなら, GDBのマニュアルをぜひ読んでほしい.  たいし
     て長くないし, GDBを使うのは簡単.  GDBのオンライン形式のマニュアル
     を含むGDBの配布は, たいていはEmacsの配布と同じ場所に置いてある.
     GDBを用いてEmacsを実行するには, Emacsをコンパイルしたサブディレク
     トリ`src'に移動してから, `gdb emacs'を行う必要がある.  GDBがディ
     レクトリ`src'にあるファイル`.gdbinit'を読めるように, このディレク
     トリがカレントディレクトリであることが重要.

     ただし, バグの原因を示すために追加情報を集める場合には, 追加情報
     をいつ集めるかをよく考える必要がある.

     たとえば, 多くの人はバックトレースだけを送ってくるが, それ単体で
     はあまり役に立たない.  引数の記録つきの単純なバックトレースでは,
     GNU Emacsの内部で何が起きているかについての情報はほとんどない. 
     というのは, バックトレースに表示される引数のほとんどはLispオブジェ
     クトへのポインタだから.  それらのポインタの値そのものは, なんら重
     要ではない.  重要なのは, ポインタが指している先のオブジェクトの内
     容（そしてその内容もまたポインタであることが多い）.

     役に立つ情報を提供するには, Lispオブジェクトの値をLispの記法で示
     す必要がある.  スタックの底付近にある数個のフレームについて, Lisp
     オブジェクトであるような各変数に対してこれを行ってほしい.  デバッ
     ガは単なる整数だと思うので, どの変数がLispオブジェクトであるかは
     ソースを見てほしい.

     変数の値をLispの記法で示すには, まず, その値をプリントしてから,
     GDBのユーザー定義コマンド`pr'を使ってLispオブジェクトをLispの記法
     で表示させる.  （別のデバッガを使わなければならない場合は, オブジェ
     クトを引数として関数`debug_print'を呼び出す）.  コマンド`pr'は, 
     ファイル`.gdbinit'で定義されており, （コアダンプではなく）実行中
     のプロセスをデバッグするときだけ使える.

     Lispでエラーが発生したときにEmacsを中断してGDBに戻るようにするに
     は, `Fsignal'にブレークポイントを設定する.

     実行中のLisp関数の簡素な一覧を表示するには, GDBのコマンド
     `xbacktrace'を打つ.

     Lisp関数の引数を調べたい場合には, スタック上を上に移動していき関
     数`Ffuncall'のフレームに到達するごとに, つぎのようなGDBコマンドを
     打つ.

          p *args
          pr

     関数が受け取った最初の引数を出力するには, つぎのようにする.

          p args[1]
          pr

     2番目以降の引数でも同様に出力できる.  `Ffuncall'の引数`nargs'は,
     `Ffuncall'が受け取った引数の個数を表す.  この個数は, Lisp関数自身
     とその関数に対する引数とを合わせた数.

     ファイル`.gdbinit'は, データタイプやLispオブジェクトの中身を調べ
     るのに役立つコマンド類を定義する.  それらのコマンドの名前は`x'で
     始まる.  これらのコマンドは`pr'より下位のレベルで動作し使い難いが, 
     コアダンプをデバックしたり, Emacsが致命的なシグナルを受理したとき
     のように`pr'がうまく動かないときでも使える.

   * バグの症状がEmacsが応答しなくなるというものでも, Emacsが『ハング』
     した（固まった）と考えてはいけない.  無限ループに入っているのかも
     しれない.  どちらであるかを調べるには, GDBのもとでバグを再現させ, 
     応答しなくなったところでEmacsを止める.  （EmacsがXウィンドウシス
     テムを直接使っている場合は, GDBのジョブに対して`C-z'を打てばEmacs
     を止められる）.  そして, コマンド`step'で1ステップずつ実行を試み
     る.  固まっているのならコマンド`step'から戻ってこない.  ループし
     ているなら`step'から戻ってくる.

     こうして調べた結果, Emacsがシステムコールの中で固まっているとわかっ
     たら, Emacsを再度止めて, システムコールの引数を調べる.  そしてバ
     グレポートには, ソース中でのシステムコールの正確な位置と, 引数が
     何だったかを正確に記入する.

     Emacsが無限ループしているのなら, ループの始まりと終りを調べる. 
     もっとも簡単にこれを調べるには, GDBのコマンド`finish'を使う.  こ
     のコマンドを使うたびに, 1つのスタックフレームから抜けるまでEmacs
     は実行を継続する.  戻ってこなくなるまで, 繰り返し`finish'を打つ. 
     戻ってこないのは, そのフレームで無限ループが起こっているからであ
     る.

     ここでEmacsを再度停止し, 戻ってこなくなったフレームに*ちょうど戻
     る*まで, 繰り返し`finish'を使う.  つぎに, `next'を使ってそのフレー
     ム内で1ステップずつ実行する.  こうすれば, ループがどこで始まりど
     こで終るかわかる.  さらに, ループ内で使われているデータを調べて, 
     ループが終るべきところでなぜ終らないかを追求してみてほしい.  これ
     らの情報すべてを, バグレポートに含める.

以下には, バグレポートに必要ないものをあげておきます.

   * バグの生起条件に関する記述.  再現可能なバグに対しては不要.

     バグに出会った人はしばしば, 入力をどう変えるとバグが出なくなると
     か, あるいは, 相変わらず出るといったことを探求するのに時間をかけ
     る.

     これは時間がかかるわりには, 役に立たない.  というのは, 保守チーム
     がデバッグを行うときには, デバッガのもとでブレークポイントを設定
     しながらバグの出る1つの例を実行するのであって, 何通りもの例から帰
     納的に推論するわけではない.  だから, 別の例を探すのに時間をかけた
     りしないでほしい.

     もちろん, もとの例の*かわりに*使えるもっと簡単な例がみつかれば, 
     それは役に立つ.  簡単な例なら, 出力中のエラーもみつけやすくなり, 
     デバッガを使って実行するにも短い時間ですむ.

     ただし, 単純化は必須ではない.  もし単純化できなかったり, 単純化す
     る時間がなければ, もとの例のままでよいので, バグレポートを出して
     ほしい.

   * Emacs実行のシステムコールトレース

     ある特別な種類のバグについては, システムコールトレースは非常に役
     立つが, 多くの場合はほとんど有用な情報は得られない.  したがって, 
     多くの人がシステムコールのトレースこそクラッシュに関する情報を報
     告するのに欠かせないものだと思っているらしいのは, 不思議である. 
     これはたぶん, ソースコードやデバッグ用シンボルのないプログラムを
     デバッグした経験から生まれた習慣だろう.

     ほとんどのプログラムでは, システムコールのトレースより, バックト
     レースのほうがずっとずっと役に立つ.  Emacsでさえ, 単純なバックト
     レースのほうが有用である.  しかし, 十分な情報を提供するには, バッ
     クトレースの補記として, 変数の値を表示し`pr'でLispオブジェクトと
     しても表示する（上記参照）.

   * バグに対する修正.

     バグに対する修正は, よい品質のものなら有用である.  しかし, 修正が
     正しいことを示すテスト例などのバグレポートに必要な情報を省かない
     でほしい.  修正に問題があるとわかって別のやり方でバグをつぶすかも
     しれないし, 報告された修正がまったく理解できないこともありえる. 
     そして, どんなバグを修正しようとしているのかわからない, あるいは, 
     その修正がなぜ改良になるのかわからなければ, その修正を採用するわ
     けにいかない.

     我々にとって, 読者のパッチが理解しやすく, インストールしやすくす
     るための指針については, *Note Sending Patches::.

   * バグが何であるか, また何に依存しているかについての予想.

     こういう予想は, たいていはまちがっている.  専門家でさえ, まずデバッ
     ガで事実を調べない限り, 正しい予想はできない.



File: emacs-ja, Node: Sending Patches, Next: Contributing, Prev: Checklist, Up: Bugs

GNU Emacsに対する修正を送る
---------------------------

GNU Emacsに対する改良や虫取りのための修正を送ろうということであれば, 
おおいに助かります.  修正を送るにあたっては, 保守チームがそれを役立て
やすいように, 以下の指針に従ってください.  さもないと, 送られた情報は
有用であっても, 役立てるには余分な作業が必要になります.  GNU Emacsの保
守は最善の環境でやっても手間のかかる仕事ですから, 手助けしていただくに
しても十分な配慮が必要なのです.

   * その修正がどのような問題を解決するものか, またはどのような改善を
     もたらすものなのかの説明を送ってほしい.  バグに対する修正の場合は, 
     バグレポートのコピーと, なぜこの修正でバグが取れるのかの説明を含
     める.

     （バグレポートへのポインタを示すよりも, バグレポートのコピーを含
     めるほうが望ましい.  というのは, ポインタだとバグレポートを探す必
     要があるし, そのバグを直し終えていると, バグレポートを消してしまっ
     ているかもしれない. ）

   * 修正したと思う問題に対応した適切なバグレポート全体をつねに含めて
     ほしい.  保守チームのほうでも修正を適用するまえにその変更が適切な
     ものであることを確信する必要がある.  たとえ修正が正しいものであっ
     ても, もとの問題を再現する方法がないと, 修正内容を正しく理解でき
     ないかもしれない.

   * 将来そのソースを読むすべての人に, その変更がなぜ必要だったか理解
     するのを助けるに足るだけのコメントをソースに入れる.

   * 異なる理由に基づく変更を混ぜない.  あくまでも*別々に*送る.

     異なる理由に基づいて2つの変更を行った場合, その両方を採用すること
     はないだろう.  どちらか一方だけを採用するかもしれない.  もしそれ
     らをいっしょくたに1つのdiffにしてしまうと, それを分離するために余
     計な作業が必要になる.  どの部分の変更がどちらの目的に対応している
     のか調べる必要がある.  その時間を割けないと, その変更をまったく採
     用しないということにもなりかねない.

     それぞれの変更を行ってすぐに, 別個に, 説明を付けて送ってもらえれ
     ば, 2つの変更が一緒になるなどということはないし, それぞれの変更を
     分離するなどの余計な作業をせずに適切に考慮できる.

   * それぞれの変更は完成したらすぐに送ってほしい.  ときどき, 多くの変
     更を溜めておいてまとめて送ったほうがいいと思っている人に出会う. 
     上で説明したように, それは最悪のやり方.

     それぞれの変更は別個に送るべきなので, 変更を行ったらすぐに送れる
     はず.  そうすれば, 保守チームのほうでその変更が重要なものだと判断
     したらすぐ取り入れることができる.

   * diffファイルを作るときには, `diff -c'を使う.  コンテキストdiffで
     ないdiffファイルは正しく適用するのが難しい.  それ以上に, 調べるの
     もたいへん.  必ず保守チームの人間が修正を適用するかどうか検討する.
     `-u'形式は行番号だけのdiffよりはましだが, いちばん読みやすいのは
     `-c'形式.

     もしGNU diffを使っているのなら, Cのコードのdiffを作るときには
     `diff -c -F'^[_a-zA-Z0-9$]+ *(''を使う.  こうすると, 変更される各
     関数の名前が一緒に表示される.

   * どっちが古い版でどっちが新しい版か曖昧さがないようにする.  diffコ
     マンドの第1引数に古いファイル, 第2引数に新しいファイルを指定して
     diffファイルを作成する.  そして, それぞれのファイル名を見ればどっ
     ちが古い版でどっちが新しい版かわかるようにファイル名を付ける.

   * 変更に対する変更記録を書く.  そうしてあれば, 保守チームのほうで書
     く時間が節約でき, 保守チームが変更内容を理解する手助けにもなる.

     変更記録の目的は, 人が読んでどこが変わったかわかるようにすること. 
     だから, どの関数を変更したか具体的に書く.  大きい関数の場合は, 関
     数の中のどの箇所を変更したかも書いてあると助かる.

     その反面, どこが変更されたかわかるようにさえなっていれば, 変更の
     目的は変更記録で説明する必要はない.  たとえば, 新しい関数を追加し
     たのであれば, その関数が新しいということだけを書けば十分.  目的を
     説明したほうがよいと感じるなら, たぶんそのとおりだろう.  しかし, 
     説明はコード中のコメントに書く.  そのほうが役に立つ.

     ディレクトリ`src'とディレクトリ`lisp'のファイル`ChangeLog'を眺め
     て, どのような情報を入れるかとか, どのようなスタイルで書くかの参
     考にしてほしい.  誰が変更したかわかるように自分の名前をヘッダの行
     に記録したいなら, ヘッダ行も送ること.

   * 修正を行うにあたっては, 他のシステムで動かなくなるような変更は採
     用できないということを承知しておいてほしい.  自分が行う変更が, 他
     の種類のシステムにおいてはどのような影響をもたらすかについて熟慮
     してほしい.

     ときどき, おおむね改良になる*かも*しれないが, はっきり改良だとは
     いいがたいような変更を送ってくる人がいる.  そのような変更は, きわ
     めて慎重に検討しなければならないので, 採用するのは難しい.  もちろ
     ん, あなたがどのような理由でその変更が正しいのかよい説明を書いて
     くれれば, 保守チームがそれを理解する助けになる.

     もっとも安全な変更は, 特定のマシンの構成ファイルに対する変更.  そ
     れが安全だという理由は, その変更が他のマシンにおいて問題を引き起
     こすことはありえないから.

     修正を採用しても安全だとはっきりわかる形に設計することで, 保守チー
     ムの労力を軽減できる.



File: emacs-ja, Node: Contributing, Next: Service, Prev: Bugs, Up: Top

Emacsの開発に貢献するには
=========================

Emacsのプレテスト版が正しく動作することの確認を手助けしたかったり,
Emacsの改良作業に加わりたければ, `bug-gun-emacs@gnu.org'の保守チームに
連絡してください.  プレテスト参加者は, バグを報告するだけでなく, バグ
を探すことも要求されます.  Emacsの改良に加わりたければ, 保守チームにプ
ロジェクトの示唆を求めるか, あなたのアイデアを提案してください.

すでに改良したコードを書いてしまったのなら, それについて教えてください. 
まだ作業を始めていないのなら, 始めるまえに`bug-gnu-emacs@gnu.org'に連
絡したほうがよいです.  そうすれば, Emacsの残りの部分とよく適合する形で
拡張を行うにはどうしたらよいかのヒントがもらえるでしょう.



File: emacs-ja, Node: Service, Next: Command Arguments, Prev: Contributing, Up: Top

GNU Emacsに関する助言を得るには
===============================

GNU Emacsをインストールしたり, 使ったり, 変更したりするうえで手助けが
必要なら, 2つの方法があります.

   * メイリングリスト`help-gnu-emacs@gnu.org'にメッセージを送るか, ニュー
     スグループ`gnu.emacs.help'に投稿する.  （これらのメイリングリスト
     とニュースグループは相互乗り入れしているので, どちらを使ってもか
     まわない. ）

   * サービスディレクトリで, 有償で手助けしてくれるような人を探す.  サー
     ビスディレクトリは, Emacs配布物の中のファイル`etc/SERVICE'にある.


File: emacs-ja, Node: Command Arguments, Next: Antinews, Prev: Service, Up: Top

コマンド行引数
**************

GNU Emacsでは, コマンド行引数によりEmacs起動時にさまざまな動作を指定で
きます.  これらは他のエディタとの互換性のためや洗練されたふるまいを担
うものです.  通常の編集作業にはそれらを使うことはお勧めしません.

`-'で始まる引数は"オプション"（option）です.  それ以外の引数は訪れるべ
きファイルを指定します.  Emacsは, 起動すると指定したファイルを読み込み
ます.  コマンド行のいちばん最後のファイル名がカレントバッファとなりま
すが, それ以外のファイルも別々のバッファに入っています.  他のGNUのコマ
ンドと同様に, 特殊な引数`--'は, これよりあとの引数が`-'で始まっている
場合でも, すべてファイル名であることを指定します.

Emacsのコマンドオプションでは, Emacsが使用するXのウィンドウのサイズや
位置, 表示色などのさまざまなことを指定できます.  バッチモードでLisp関
数を実行するなどの進んだ利用のためのオプションも若干あります.  ここで
は, 目的別に利用可能なオプションを説明します.

オプションの書き方は2通りあります.  1文字の`-'で始まる短い形式と, `--'
で始まる長い形式です.  たとえば, `-d'は短い形式であり, `--display'はこ
れに対応した長い形式です.

`--'で始まる長い形式のほうが覚えやすいですが, 打ち込むのは面倒です. 
しかし, オプション名を完全にすべて入力する必要はありません.  曖昧でな
いように省略すれば十分です.  長いオプションが引数をとる場合には, オプ
ション名と引数のあいだに空白か等号を置きます.  つまり, `--display
sugar-bombs:0.0'と書くか, `--display=sugar-bombs:0.0'と書きます.  関係
が明瞭になることもあり, 以下の例でもつねに等号を使っていますので, 等号
を使うようお勧めします.

ほとんどのオプションは, Emacsをどう初期化するか, あるいは, Emacsセッショ
ンのパラメータをどう設定するか指示します.  これらを"初期化オプション"
（initial options）と呼びます.  動作を指定するオプションもいくつかあり
ます.  たとえば, ライブラリをロードする, 関数を呼び出す, Emacsを終了す
るなどです.  これらを"動作オプション"（action options）と呼びます.  こ
れらとファイル名をあわせて"動作引数"（action arguments）と呼びます.
Emacsはすべての動作引数を書かれた順に処理します.

* Menu:

* Action Arguments::	Arguments to visit files, load libraries,
			  and call functions.
* Initial Options::     Arguments that take effect while starting Emacs.
* Command Example::     Examples of using command line arguments.
* Resume Arguments::	Specifying arguments when you resume a running Emacs.
* Environment::         Environment variables that Emacs uses.

* Display X::           Changing the default display and using remote login.
* Font X::	        Choosing a font for text, under X.
* Colors X::	        Choosing colors, under X.
* Window Size X::       Start-up window size, under X.
* Borders X::	        Internal and external borders, under X.
* Title X::             Specifying the initial frame's title.
* Icons X::             Choosing what sort of icon to use, under X.
* Resources X::         Advanced use of classes and resources, under X.
* Lucid Resources::     X resources for Lucid menus.
* Motif Resources::     X resources for Motif menus.



File: emacs-ja, Node: Action Arguments, Next: Initial Options, Prev: Command Arguments, Up: Command Arguments

動作引数
========

以下は, 動作引数とオプションとその引数の一覧です.

`FILE'
     `find-file'を使ってファイルFILEを訪れる.  *Note Visiting::.

`+LINENUM FILE'
     `find-file'を使ってファイルFILEを訪れ, その中の行番号LINENUMの行
     に移動する.

`-l FILE'
`--load=FILE'
     関数`load'を使ってFILEという名前のLispライブラリをロードする.
     *Note Lisp Libraries::.  ライブラリは, カレントディレクトリか
     `EMACSLOADPATH'（*Note General Variables::）で指定されたEmacsのラ
     イブラリ探索パスから探す.

`-f FUNCTION'
`--funcall=FUNCTION'
     引数なしでLisp関数FUNCTIONを呼び出す.

`--eval EXPRESSION'
     Lisp式EXPRESSIONを評価する.

`--insert=FILE'
     ファイルFILEの内容をカレントバッファに挿入する.  これは`M-x
     insert-file'と同じ動作.  *Note Misc File Ops::.

`--kill'
     問い合わせずにEmacsを終了する.

初期化ファイルでは, 変数`command-line-args'内のリストの要素として動作
引数の値を参照できます.  初期化ファイルでは, この変数を読んだり設定す
ることで, 動作引数の通常の処理を無効にしたり新たなものを定義したりでき
ます.



File: emacs-ja, Node: Initial Options, Next: Command Example, Prev: Action Arguments, Up: Command Arguments

初期化オプション
================

初期化オプションはEmacsセッションのパラメータを指定します.  ここでは, 
より一般的な初期化オプションを説明します.  Xウィンドウシステムに関連す
る他のオプションはこのあとの節にあります.

初期化ファイルのロードに影響する初期化オプションもあります.  Emacsの通
常の動作は, まず`site-start.el'（が存在すればそれ）をロードし, 続いて
個人用の`~/.emacs'（が存在すればそれ）をロードし, 最後に`default.el'
（が存在すればそれ）をロードします.  これらのファイルのロードを抑制し
たり, 代替ファイルを指定するオプションがあります.

`-t DEVICE'
`--terminal=DEVICE'
     入出力端末装置としてDEVICEを使う.

`-d DISPLAY'
`--display=DISPLAY'
     Xウィンドウシステムを用い, ディスプレイ名DISPLAYのディスプレイに
     Emacsの初期フレームを開く.

`-nw'
`--no-windows'
     環境変数`DISPLAY'が設定されている場合でもそれを無視し, Xとは直接
     通信しない.

`-batch'
`--batch'
     Emacsを"バッチモード"で実行する.  つまり, 編集中のテキストを表示
     せずに, `C-z'と`C-c'などの標準の端末割り込み文字は通常の効果をも
     つ.  バッチモードのEmacsでは, プログラムの制御に従って通常エコー
     領域に表示されるもののみを`stderr'へ出力する.

     バッチモードは, シェルスクリプトやmakefileなどからEmacs Lispで書
     いたプログラムを実行するために使う.  バッチ処理を行うLispプログラ
     ムを起動するために, 通常, オプション`-l'や`-f'も使われる.

     `-batch'は, （初期化ファイルをロードしない）`-q'を含む.  また, す
     べてのコマンドオプションを処理し終えるとEamcsは終了する.  さらに, 
     明示的に指定しない限りバッファを自動的に保存しない.

`-q'
`--no-init-file'
     個人の初期化ファイル`~/.emacs'も`default.el'もロードしない.

`--no-site-file'
     `site-start.el'をロードしない.  オプション, `-q', `-u', `-batch'
     は, このファイルのロードには影響しない.  ファイル`site-start.el'
     のロードを抑止する唯一のオプションである.

`-u USER'
`--user=USER'
     自分の初期化ファイルのかわりにユーザーUSERのEmacs初期化ファイル
     `~USER/.emacs'をロードする.

`--debug-init'
     初期化ファイル内でのエラーに対しEmacs Lispデバッガを利用可能にす
     る.

`--unibyte'
     ユニバイトバッファやユニバイト文字列を使うようにすべてを設定する. 
     ユーザー（やLispプログラム）がマルチバイトバッファやマルチバイト
     文字列の使用を明示しない限り, すべてのバッファや文字列はユニバイ
     トである.  環境変数`EMACS_UNIBYTE'を設定しても同じ効果になる.

`--multibyte'
     `EMACS_UNIBYTE'の効果を禁止し, 通常のように, Emacsはデフォルトで
     マルチバイト文字を使う.



File: emacs-ja, Node: Command Example, Next: Resume Arguments, Prev: Initial Options, Up: Command Arguments

コマンド引数の例
================

以下は, 引数やオプションを指定したEmacsの使用例です.  ファイル
`hack-c.el'にはLispプログラムが入っているものとします.  これをロードす
ると, Cのプログラムを内容とするカレントバッファに対してなんらかの有用
な操作を行うものとします.

     emacs -batch foo.c -l hack-c -f save-buffer >& log

この意味は, `foo.c'を訪れ, （訪れたファイルを変更する）`hack-c.el'をロー
ドし, `foo.c'に保存し（`save-buffer'は`C-x C-s'にバインドされた関数）, 
（`-batch'があるので）終了してシェルへ戻ります.  また, `-batch'により
Emacsは表示端末を利用できないと仮定するので, 出力を`log'へリダイレクト
しても問題ないことが保証されます.



File: emacs-ja, Node: Resume Arguments, Next: Environment, Prev: Command Example, Up: Command Arguments

引数を指定したEmacsの再開
=========================

Emacsをいったん休止したあとで再開するときには動作引数を指定できます. 
その準備として, 個人の`.emacs'につぎのコードを入れておきます（*Note
Hooks::）.

     (add-hook 'suspend-hook 'resume-suspend-hook)
     (add-hook 'suspend-resume-hook 'resume-process-args)

さらに, （cshを使っているなら）シェルスクリプト`emacs.csh'か, （bashを
使っているなら）`emacs.bash'を実行する必要があります.  これらのスクリ
プトは`edit'という別名（エイリアス）を定義します.  この別名は, 訪れる
べきファイルなどのコマンド行引数を新たに与えてEmacsを（休止状態から）
再開します.

Emacsを再開する場合には動作引数しか使えません.  初期化引数は認識されま
せん.  なぜなら, 初期化を行うには遅すぎるのです.

（引数の有無に関わらず）Emacsの再開はEmacsジョブの親であるシェルから行
う必要があります.  `edit'が, プログラムやシェルスクリプトではなく, 別
名であるのはこのためです.  シェルの別のサブジョブから実行できる再開コ
マンドを実現することは不可能です.  たとえば, 環境変数`EDITOR'の値に指
定できるコマンドを定義する方法はありません.  したがって, この機能で
Emacsサーバーの機能（*Note Emacs Server::）を置き換えることはできませ
ん.

別名`edit'は, Emacsサーバーが稼働中ならEmacsサーバーの機能を使います. 
しかし, このことを完全に正確に調べる方法はありません.  実際にはEmacsが
終了していても, ファイル`/tmp/.esrv...'が存在するとサーバーが稼働中で
あると誤認してしまいます.  そのような場合には, そのファイルを探して削
除してください.



File: emacs-ja, Node: Environment, Next: Display X, Prev: Resume Arguments, Up: Command Arguments

環境変数
========

ここでは, Emacsがどうのように環境変数を使うか説明します.  環境変数とは, 
オペレーティングシステムからEmacsへ渡される文字列であり, 環境変数の集
まりが環境です.  環境変数名では大文字小文字を区別し大文字だけを使う習
慣があります.

環境変数はオペレーティングシステムが与えるものなので, それらを設定する
一般的な方法はありません.  設定方法は, オペレーティングシステム, 特に, 
使用するシェルに依存します.  たとえば, bashを使って環境変数
`ORGANIZATION'に`not very much'を設定するにはつぎのようにします.

     export ORGANIZATION="not very much"

cshやtcshの場合にはつぎのようにします.

     setenv ORGANIZATION "not very much"

EmacsがXウィンドウシステムを使うようになっている場合には, EmacsはXライ
ブラリから非常に多数の環境変数を受け継ぎます.  詳しくはXのドキュメント
を参照してください.

* Menu:

* General Variables::   Environment variables that all versions of Emacs use.
* Misc Variables::      Certain system-specific variables.



