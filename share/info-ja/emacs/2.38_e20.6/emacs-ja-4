Info file: emacs-ja,    -*-Text-*-
produced by `texinfo-format-buffer'
from file `emacs.texi'
using `texinfmt.el' version 2.38 of 3 July 1998.


Emacs 20.6版対応に改訂した`GNU Emacs Manual' 13版です.

INFO-DIR-SECTION Editors
START-INFO-DIR-ENTRY
* Emacs: (emacs).	The extensible self-documenting text editor.
END-INFO-DIR-ENTRY


Published by the Free Software Foundation 59 Temple Place, Suite 330
Boston, MA 02111-1307 USA

Copyright (C) 1985, 1986, 1987, 1993, 1994, 1995, 1996, 1997, 1998,
1999 Free Software Foundation, Inc.

Permission is granted to make and distribute verbatim copies of this
manual provided the copyright notice and this permission notice are
preserved on all copies.

Permission is granted to copy and distribute modified versions of this
manual under the conditions for verbatim copying, provided also that
the sections entitled "The GNU Manifesto", "Distribution" and "GNU
General Public License" are included exactly as in the original, and
provided that the entire resulting derived work is distributed under
the terms of a permission notice identical to this one.

Permission is granted to copy and distribute translations of this
manual into another language, under the above conditions for modified
versions, except that the sections entitled "The GNU Manifesto",
"Distribution" and "GNU General Public License" may be included in a
translation approved by the Free Software Foundation instead of in the
original English.





File: emacs-ja, Node: Nonincremental Search, Next: Word Search, Prev: Incremental Search, Up: Search

一括型探索
==========

Emacsでは, 従来方式の一括型探索コマンドもあります.  探索を開始するまえ
に探索文字列全体を打っておく必要があります.

`C-s RET STRING RET'
     STRINGを探索する.
`C-r RET STRING RET'
     STRINGを後向きに探索する.

一括型探索を実行するには, まず`C-s RET'と打ちます.  すると, 探索文字列
を読み取るためにミニバッファに移動します.  文字列をRETで終えると, 探索
を開始します.  文字列がみつからなければ, 探索コマンドはエラーになりま
す.

`C-s RET'はつぎのように動作します.  まず, `C-s'がインクリメンタルサー
チを起動します.  インクリメンタルサーチは, 特別な場合として, 引数が空
であったときには一括型探索を起動するようにプログラムしてあります. 
（さもなければ, そのような空の引数に意味はない. ）`C-r RET'もこのよう
に動作します.

しかし, `C-s RET'で実行される一括型探索は, `search-forward'をただちに
呼び出すわけではありません.  まず, つぎの文字が単語探索を指示する`C-w' 
であるかどうか調べます.  *Note Word Search::.

前向き／後向きの一括型探索は, コマンド`search-forward'と
`search-backward'で実装されています.  これらのコマンドは通常と同じよう
にキーにバインドできます.  インクリメンタルサーチコマンドから呼び出せ
るようになっているのは, 歴史的な理由, および, これらの機能にふさわしい
キー列を選ぶ労力を削減できるという理由からです.



File: emacs-ja, Node: Word Search, Next: Regexp Search, Prev: Nonincremental Search, Up: Search

単語探索
========

単語探索は, 単語の区切られ方を無視して, 単語の列を探索します.  より正
確には, 空白1個で区切った数個の単語を打ち込むと, 単語と単語のあいだに
複数個の空白／改行／句読点があったとしても, それらの文字列をみつけだす
ことができます.

単語探索は, テキスト清書系で整形済みの文書を編集する場合に便利です. 
整形した印刷出力を見ながら編集する場合, ソースファイルのどこで行が区切
られているのかわかりません.  単語探索を使えば, 単語の区切られ方を知ら
なくても探索できます.

`C-s RET C-w WORDS RET'
     句読点などの詳細は無視して, WORDSを探索する.
`C-r RET C-w WORDS RET'
     句読点などの詳細は無視して, 後向きにWORDSを探索する.

単語探索は, 一括型探索の特別な場合であって, `C-s RET C-w'で起動します. 
この入力に続いて, 探索文字列を入力し, 文字列はつねにRETで終えます.  一
括型であるため, 単語探索も引数を入力し終えるまで探索を開始しません. 
単語探索は, 正規表現を構築し, その正規表現で探索を行うことで動作します.
*Note Regexp Search::.

後向きの単語探索には`C-r RET C-w'を使います.

前向き／後向きの単語探索は, それぞれ, コマンド`word-search-forward'と
`word-search-backward'で実装されています.  これらのコマンドは通常どお
りキーに割り当てることができます.  インクリメンタルサーチコマンドから
呼び出せるようになっているのは, 歴史的な理由, および, これらの機能にふ
さわしいキー列を選ぶ労力を削減できるという理由からです.



File: emacs-ja, Node: Regexp Search, Next: Regexps, Prev: Word Search, Up: Search

正規表現探索
============

"正規表現"（regular expression, "regexp"と略す）とは, 一致する可能性が
ある一連の（無限個でもよい）文字列を表現するパターンです.  GNU Emacsで
は, インクリメンタルサーチでも一括型探索でも, 正規表現を用いてつぎの一
致箇所を探索できます.

正規表現によるインクリメンタルサーチを実行するには, `C-M-s'
（`isearch-forward-regexp'）と打ちます.  このコマンドは, `C-s'と同様に, 
探索文字列を逐次読み取ります.  ただし, 探索文字列をバッファのテキスト
に対して正確に照合するためのものとみなすのではなく, 正規表現として扱い
ます.  探索文字列にテキストを追加するごとに, 正規表現は長くなり, 新た
な正規表現を探索します.  （値は関係ない）前置引数を指定して`C-s'を起動
しても, 前向きに正規表現の探索を始められます.  後向きに正規表現を探索
するには, `C-M-r'（`isearch-backward-regexp'）を使うか, 前置引数を指定
して`C-r'を使います.

通常のインクリメンタルサーチにおいて特別な機能を持つコントロール文字は, 
正規表現のインクリメンタルサーチでも同じ機能を持ちます.  探索の開始直
後に`C-s'や`C-r'を打つと, 最後のインクリメンタルサーチに用いた正規表現
を再度使います.  つまり, 正規表現を用いる探索とそうでない探索とには, 
それぞれ独立のデフォルトがあるのです.  `M-p'と`M-n'で参照できる探索リ
ングもそれぞれ別々です.

正規表現のインクリメンタルサーチでSPCを打つと, 改行を含めた任意個の白
文字に一致します.  ちょうど1個の空白に一致させたいのであれば, `C-q
SPC'と打ちます.

正規表現のインクリメンタルサーチ中に正規表現に文字を加えると, カーソル
をもとに戻して探索し直すことがあります.  たとえば, `foo'を探索し終えた
ときに`\|bar'を追加したとします.  最初の`bar'が最初の`foo'に先行する場
合には, カーソルはまえに戻ります.

正規表現の一括型探索は, 関数`re-search-forward'と`re-search-backward'
で行われます.  これらは, `M-x'で呼び出したり, キーに割り当てたり, ある
いは, `C-M-s RET'や`C-M-r RET'として正規表現のインクリメンタルサーチの
方法で起動したりできます.

正規表現のインクリメンタルサーチコマンドに前置引数を指定すると,
`isearch-forward'や`isearch-backward'のように, 普通の文字列探索を行い
ます.  *Note Incremental Search::.



File: emacs-ja, Node: Regexps, Next: Search Case, Prev: Regexp Search, Up: Search

正規表現の構文
==============

正規表現には, 特別な使い方をする少数の文字とその他の"普通の"文字から成
る構文があります.  普通の文字は, 同じ文字だけに一致してそれ以外には一
致しない単純な正規表現です.  特別な文字は, `$', `^', `.', `*', `+',
`?', `[', `]', および, `\'です.  `\'が先行する場合を除いて, 正規表現に
現れるこれら以外の文字は普通の文字です.

たとえば, `f'は特別な文字ではなく, 通常の文字ですから, 文字列`f'に一致
してそれ以外の文字列には一致しない正規表現です.  （これは, 文字列`ff'
には一致し*ない*. ）同様に, `o'は, `o'だけに一致する正規表現です. 
（大文字小文字を区別しない場合, これらの正規表現は`F'や`O'にも一致する
が, これらは例外というよりは, 『同じ文字列』の一般化として捉える. ）

任意の2つの正規表現AとBを連結できます.  その結果は, Aが文字列の始めの
適当な部分に一致して, かつ, Bが文字列の残りの部分に一致する場合に, 文
字列に一致するような正規表現です.

簡単な例として, 正規表現`f'と`o'を連結すると, 正規表現`fo'を得ますが, 
これは文字列`fo'だけに一致します.  簡単ですね.  多少とも複雑なことを行
うには, 特別な文字を使う必要があります.  以下にその一覧をあげます.

`. （ピリオド）'
     特別な文字であり, 改行以外の任意の1文字に一致する.  連結を使って
     `a.b'のような正規表現を作れる.  これは, `a'で始まり`b'で終る任意
     の3文字の文字列に一致する.

`*'
     単独では構成要素ではない.  直前の正規表現を可能な限り反復すること
     を意味する後置演算子である.  すなわち, （`o'が存在しない場合も含
     めて）`o*'は任意個の`o'に一致する.

     `*'はつねに先行する*最小*の正規表現に適用される.  したがって,
     `fo*'は`fo'を繰り返すのではなく, `o'を繰り返す.  この正規表現は
     `f', `fo', `foo'などに一致する.

     `*'を用いた構成は, 一致を処理するときには, ただちに得られる限りの
     反復回数に展開される.  そうしてから, 残りのパターンを処理する. 
     一致に失敗すると, バックトラック（後戻り）が発生して, `*'を用いた
     構成の反復回数を減らして, パターンの残りの部分が一致するようにす
     る.  たとえば, 文字列`caaar'に対して`ca*ar'を一致させることを考え
     てみる.  始めに, `a*'を3つの`a'すべてに一致させようとする.  しか
     し, 残りのパターンが`ar'なのに`r'しか残っていないため, この試みは
     失敗する.  そこで, つぎは`a*'を`a'2つだけに一致させる.  こうする
     と, 残りの正規表現も正しく一致する.

`+'
     `*'に似た後置演算子だが, 直前の正規表現に1回以上一致する必要があ
     る.  たとえば, `ca+r'は, 文字列`car'や`caaaar'には一致するが, 文
     字列`cr'には一致ない.  `ca*r'の場合は, 上記の3つすべてに一致する.

`?'
     `*'に似た後置演算子だが, 直前の正規表現に1回だけ一致するか, ある
     いは, 1回も一致しない.  たとえば, `ca?r'は, `car'や`cr'に一致する
     が, 他のものには一致しない.

`[ ... ]'
     `['で始まり`]'で終る"文字集合"を表す.  もっとも単純な場合は, この
     2つの中括弧のあいだにある文字の1つ1つがこの文字集合に一致する.

     したがって, `[ad]'は, `a'1文字か`d'1文字のどちらにも一致する.
     `[ad]*'は, `a'と`d'だけから成る（空の文字列を含む）任意の文字列に
     一致する.  このことから, `c[ad]*r'は, `cr', `car', `cdr',
     `caddaar'などに一致することがわかる.

     文字集合には, 文字範囲の指定を含めることもでき, 始めの文字と終り
     の文字のあいだに`-'を書く.  つまり, `[a-z]'はすべてのASCII小文字
     に一致する.  範囲指定と個々の文字を自由に織り混ぜてよく,
     `[a-z$%.]'のように書ける.  これは, 任意のASCII小文字, `$', `%', 
     ピリオドに一致する.

     文字集合の内側では, 正規表現の通常の特別な文字を特別扱いしないこ
     とに注意.  文字集合の内側では, まったく別の特別な文字, `]', `-', 
     および, `^'が存在する.

     文字集合に`]'を含めるには, `]'を最初の文字として指定する必要があ
     る.  たとえば, `[]a]'は, `]'や`a'に一致する.  `-'を含めるのであれ
     ば, `-'を文字集合の最初の文字か最後の文字として指定して, 範囲指定
     のあとに置く.  したがって, `[]-]'は, `]'と`-'の両方に一致する.

     文字集合に`^'を含めるには, `^'を文字集合の2番目以降に置く.

     大文字小文字を区別する探索で文字範囲を指定するときは, 範囲の両端
     を, 大文字だけ, 小文字だけ, あるいは, 英字以外だけで書くべきであ
     る.  `A-z'のような大文字小文字を混ぜた文字範囲の動作は, 定義が明
     確ではなく, 将来のEmacsでは変更するかもしれない.

`[^ ... ]'
     `[^'は"文字の補集合"の始まりを意味し, 指定した文字を除く任意の文
     字に一致する.  すなわち, `[^a-z0-9A-Z]'は, 英文字と数字を*除く*す
     べての文字に一致する.

     `^'は先頭になければ文字集合では特別な意味を持たない.  `^'に続く文
     字は先頭にあるものとして扱われる（いいかえれば, ここでは`-'や`]'
     は特別な意味を持たない）.

     文字の補集合は, 一致しない文字として改行を指定しない限り, 改行に
     も一致する.  この点は, `grep'のようなプログラムでの正規表現の扱い
     方と対照的.

`^'
     空の文字列に一致する特別な文字で, テキスト行の先頭のみに一致する. 
     それ以外では, 一致に失敗する.  したがって, `^foo'は, 行頭にある
     `foo'に一致する.

`$'
     `^'と似ていて, 行末のみに一致する.  したがって, `x+$'は, 行末にあ
     る1文字以上の`x'から成る文字列に一致する.

`\'
     2つの機能がある.  （`\'を含む）特別な文字をクォートする（意味を抑
     える）ことと, 特別な構成を導入すること.

     `\'は特別な文字をクォートするので, `\$'は文字`$'だけに一致する正
     規表現, `\['は文字`['だけに一致する正規表現, というようになる.

注意：` '従来との互換性のために, 特別な文字が, それらの特別な意味をな
しえない文脈で使われた場合には, 普通の文字として扱われます.  たとえば,
`*foo'では, `*'の対象となる正規表現が直前にないため, `*'は普通の文字と
して扱われます.  このようなふるまいに依存することはよい習慣ではありま
せん.  特別な文字を書く位置に関係なく特別な文字はクォートするべきです.

多くの場合, 任意の文字を伴う`\'はその文字だけに一致します.  しかし, い
くつか例外があって, `\'で始まる2文字列が特別な意味を持つ場合があります.
2文字目にくる文字は, 単独で使った場合には普通の文字として扱われるもの
です.  以下に`\'の構成を列挙します.

`\|'
     選択肢を指定する.  `\|'をあいだに伴った2つの正規表現AとBは, AかB
     のいずれかに一致する文字列に一致する正規表現となる.

     したがって, `foo\|bar'は, `foo'か`bar'に一致するが, それ以外の文
     字列には一致しない.

     `\|'は, 周囲にある適用しうる正規表現の中でも最大のものに適用され
     る.  `\|'によるグループ化を制限するのは, これを囲む`\( ... \)'に
     よるグループ化だけ.

     何度`\|'を使っても処理できるだけの十分なバックトラック能力がある.

`\( ... \)'
     以下の3つの目的を果たすグループ化のための構成.

       1. 他の操作に使うために一連の選択肢`\|'を括る.  したがって,
          `\(foo\|bar\)x'は, `foox'か`barx'のいずれかに一致する.

       2. 後置演算子, `*', `+', `?'を適用できるように, 複雑な正規表現
          を括る.  したがって, `ba\(na\)*'は, `bananana'のように, （0
          個以上の）任意個の文字列`na'に一致する.

       3. あとで参照できるように, 一致した部分文字列を記録する.

     最後の使い方は, 括弧によるグループ化という考え方から派生したもの
     ではない.  同一の`\( ... \)'構成に与えた2つめの別の機能である. 
     実用上, これら2つの意味が混同されることはない.

`\D'
     D番目に現れた`\( ... \)'に一致したテキストと同じテキストに一致す
     る.

     一致を処理するときには, `\( ... \)'構成の末尾に達すると, この構成
     に一致したテキストの始めと終りを記録する.  そして, 正規表現のそれ
     よりうしろでは, 『D番目に現れた`\( ... \)'に一致したテキスト』と
     いう意味で`\'に続けて数字Dを使える.

     1つの正規表現内に現れる最初の9個の`\( ... \)'に一致する文字列には, 
     正規表現中で開き括弧が現れた順に, 1から9までの番号を割りふる.  そ
     のため, `\1'から`\9'で, 対応する`\( ... \)'に一致したテキストを参
     照できる.

     たとえば, `\(.*\)\1'は, 改行を含まない文字列で, かつ, 前半と後半
     が同一である文字列に一致する.  `\(.*\)'は前半部分に一致し, それは
     どのようなものでもかまわない.  一方, それに続く`\1'は, 前半部分と
     まったく同じテキストに一致しなければならない.

     ある`\( ... \)'が, （直後に`*'がある場合などに簡単に起こりえる）
     複数回一致する場合には, 最後に一致したものだけを記録する.

`\`'
     空の文字列に一致するが, 一致対象であるバッファや文字列の先頭に限
     る.

`\''
     空の文字列に一致するが, 一致対象であるバッファや文字列の末尾に限
     る.

`\='
     空の文字列に一致するが, ポイント位置に限る.

`\b'
     同じく空の文字列に一致するが, 単語の先頭や末尾に限る.  したがって,
     `\bfoo\b'は, 単語として独立して現れる`foo'に一致する.
     `\bballs?\b'は, 単語として独立して現れる`ball'や`balls'に一致する.

     `\b'は, バッファの先頭や末尾にあるテキストとは無関係に, バッファ
     の先頭や末尾にも一致する.

`\B'
     空の文字列に一致するが, 単語の先頭や末尾*以外*に限る.

`\<'
     空の文字列に一致するが, 単語の先頭に限る.  `\<'は, 単語構成文字が
     続く場合に限って, バッファの先頭にも一致する.

`\>'
     空の文字列に一致するが, 単語の末尾に限る.  `\>'は, 単語構成文字で
     終了している場合に限って, バッファの末尾にも一致する.

`\w'
     任意の単語構成文字に一致する.  エディタの構文テーブルによってこの
     文字が決まる.  *Note Syntax::.

`\W'
     単語構成文字以外の文字に一致する.

`\sC'
     構文がCである文字だけに一致する.  ここで, Cは構文コードを表す文字. 
     たとえば, `w'は単語構成要素を, `-'は白文字を, `('は開き括弧を表す
     といった具合.  （改行を含む）白文字は, `-'や空白で表す.

`\SC'
     構文がCでない任意の文字に一致する.

単語や構文に関連する構成要素は, 構文テーブル（*Note Syntax::）の設定で
制御されます.

複雑な正規表現を以下に示します.  これは, 任意個の白文字がうしろに続く
文末を認識するためにEmacsが使うものです.  空白とタブ文字を区別できるよ
うに, Lispの構文で示してあります.  Lisp構文では, 文字列定数はダブルクォー
トで始まり, ダブルクォートで終ります.  `\"'は正規表現の一部としてのダ
ブルクォートを表し, `\\'は正規表現の一部としてのバックスラッシュを表し
ます.  `\t'はタブ文字, `\n'は改行文字を表します.

     "[.?!][]\"')]*\\($\\|\t\\|  \\)[ \t\n]*"

この正規表現は4つの部分が繋がってできています.  ピリオド, `?', `!'のい
ずれかに一致する文字集合.  閉じ中括, 2種類の引用符, 括弧に一致する文字
集合の任意回数の繰り返し.  バックスラッシュ付きの括弧で括った, 行末, 
タブ, 空白2つのいずれかに一致する選択肢.  白文字に一致する文字集合の任
意回数の繰り返し.

これと同じ正規表現を対話的に入力するときには, タブを入力するにはTABを
打ち, 改行を入力するには`C-j'を打ちます.  また, Lisp構文上ではバックス
ラッシュを2つ続けてますが, 対話的に入力するには, 1つのバックスラッシュ
だけを打ちます.



File: emacs-ja, Node: Search Case, Next: Replace, Prev: Regexps, Up: Search

探索と大文字小文字の区別
========================

Emacsのインクリメンタルサーチでは, 小文字だけで探索文字列を指定すると, 
探索対象のテキストの大文字小文字の違いを通常無視します.  したがって,
`foo'を探索するように指定すると, `Foo'にも`foo'にも一致します.  正規表
現, 特に文字集合の場合でも同様です.  `[ab]'は, `a', `A', `b', `B'のい
ずれにも一致します.

インクリメンタルサーチする探索文字列のどこかに大文字があると, 大文字小
文字を区別して探索します.  したがって, `Foo'の探索では, `foo'や`FOO'を
みつけだせません.  このことは, 文字列の探索だけでなく正規表現の探索に
もあてはまります.  探索文字列から大文字を消去すれば, この効果はなくな
ります.

変数`case-fold-search'に`nil'を設定すれば, 大文字小文字の違いを含めて, 
すべての文字はそのとおりに一致するようになります.  これは, バッファご
との変数です.  変数を変更してもカレントバッファだけに影響しますが, 変
更可能なデフォルトの値があります.  *Note Locals::.  この変数は, 置換コ
マンド（*Note Replace::）やミニバッファの履歴探索コマンド（*Note
Minibuffer History::）が行う探索を含む, 一括型探索にも適用されます.



File: emacs-ja, Node: Replace, Next: Other Repeating Search, Prev: Search Case, Up: Search

置換コマンド
============

大域的な探索置換操作は, 他のエディタ (1) (*Note Replace-Footnotes::) 
で必要なほどEmacsでは必要はありませんが, Emacsでも使えます.  多くのエ
ディタにあるような単純なコマンド`M-x replace-string'の他にも, パターン
の各出現ごとに置換するかどうか尋ねてくる`M-x query-replace'コマンドが
あります.

置換コマンドは, 通常, ポイントからバッファの末尾までのテキストを操作し
ます.  しかし, 暫定マーク（transient-mark）モードでは, マークが活性で
ある場合にはリージョンを操作します.  置換コマンドはどれも, 1つの文字列
（や正規表現）を1つの置換文字列に置き換えます.  コマンド
`expand-region-abbrevs'（*Note Expanding Abbrevs::）を使って, いくつか
の置き換えを並行に行うことができます.

* Menu:

* Unconditional Replace::  Replacing all matches for a string.
* Regexp Replace::         Replacing all matches for a regexp.
* Replacement and Case::   How replacements preserve case of letters.
* Query Replace::          How to use querying.


File: emacs-ja  Node: Replace-Footnotes, Up: Replace

(1) エディタの中には, テキストに1か所の修正を加える場合でさえ, 探索置
換操作が唯一の手段であるものもある.



File: emacs-ja, Node: Unconditional Replace, Next: Regexp Replace, Prev: Replace, Up: Replace

無条件置換
----------

`M-x replace-string RET STRING RET NEWSTRING RET'
     STRINGのすべての出現をNEWSTRINGで置換する.
`M-x replace-regexp RET REGEXP RET NEWSTRING RET'
     正規表現REGEXPに一致するものすべてをNEWSTRINGで置換する.

ポイント以降にある`foo'のすべての出現を`bar'で置き換えるには, 2つの引
数`foo'と`bar'を指定したコマンド`M-x replace-string'を使います.  置換
はポイント以降でのみ実施されますから, バッファ全体に対して置換を行いた
いときには, まずバッファの先頭に移動しておく必要があります.  バッファ
の末尾までに現れるすべての出現を置換します.  バッファの一部に置換を限
定したいときには, 置換を実行するまえに, バッファの当該部分にナロイング
しておきます（*Note Narrowing::）.  暫定マーク（transient-mark）モード
においては, リージョンが活性のときには, 置換はリージョン内に限定されま
す.

`replace-string'を終了すると, ポイントは最後に置換した出現箇所に置かれ
ます.  マークは（`replace-string'コマンドを起動したとき）以前のポイン
ト位置に設定されます.  その位置に戻るには`C-u C-SPC'を使います.

数引数を指定すると, 単語区切りで囲まれた出現だけを置換対象とします. 
引数の値は関係ありません.



File: emacs-ja, Node: Regexp Replace, Next: Replacement and Case, Prev: Unconditional Replace, Up: Replace

正規表現による置換
------------------

`M-x replace-string'コマンドは, 1つの文字列に正確に一致するものだけを
置き換えます.  これに類似したコマンド`M-x replace-regexp'は, 指定した
パターンに一致する任意のものを置き換えます.

`replace-regexp'では, NEWSTRINGが定数である必要はありません.  REGEXPに
一致したものの全体あるいはその一部を参照できます.  NEWSTRINGの中の`\&'
は, 置換対象の文字列全体（つまり, REGEXPに一致したものの全体）を表しま
す.  NEWSTRINGの中の`\D'（Dは数字）は, REGEXPの中のD番目の括弧のグルー
プ化部分に一致した部分を表します.  置き換えるテキスト内に`\'を含めるに
は, `\\'と入力する必要があります.

     M-x replace-regexp RET c[ad]+r RET \&-safe RET

たとえばこの例は, `cadr'を`cadr-safe'で, `cddr'を`cddr-safe'で置換しま
す.

     M-x replace-regexp RET \(c[ad]+r\)-safe RET \1 RET

この例は, 逆の置換を行います.



File: emacs-ja, Node: Replacement and Case, Next: Query Replace, Prev: Regexp Replace, Up: Replace

置換コマンドと大文字小文字の区別
--------------------------------

置換コマンドの第1引数がすべて小文字である場合, `case-fold-search'が
`nil'以外であるときには, 大文字小文字を区別せずに置換対象を探索します.
`case-fold-search'が`nil'であるときには, すべての探索において大文字小
文字を区別します.

さらに, 引数NEWSTRINGが, すべて小文字, あるいは, 一部が小文字のときに
は, 置換コマンドは, 各置換対象の大文字小文字のパターンを保存しようとし
ます.  つまり, コマンド

     M-x replace-string RET foo RET bar RET

は, 小文字の`foo'を小文字の`bar'に, すべて大文字の`FOO'を`BAR'に, 大文
字で始まる`Foo'を`Bar'に置換します.  （`replace-string'が区別できるの
は, これら3つの選択肢, つまり, 小文字のみ, すべて大文字, 大文字で始ま
るだけ. ）

置換文字列に大文字を使ったときには, これを挿入するときは大文字は大文字
のままです.  第1引数に大文字を使ったときには, 第2引数では大文字小文字
を変換せずにつねに指定どおりに置き換えます.  同様に, `case-replace'や
`case-fold-search'に`nil'を設定すると, 大文字小文字を変換せずに置換し
ます.



File: emacs-ja, Node: Query Replace, Next: Other Repeating Search, Prev: Replacement and Case, Up: Replace

問い合わせ型置換
----------------

`M-% STRING RET NEWSTRING RET'
`M-x query-replace RET STRING RET NEWSTRING RET'
     STRINGのいくつかの出現をNEWSTRINGで置換する.
`C-M-% REGEXP RET NEWSTRING RET'
`M-x query-replace-regexp RET REGEXP RET NEWSTRING RET'
     正規表現REGEXPに一致するもののいくつかをNEWSTRINGで置換する.

`foo'のすべての出現ではなく, そのうちのいくつかだけを`bar'に変更したい
ときには, 通常の`replace-string'を使うことはできません.  かわりに,
`M-%'（`query-replace'）を使います.  このコマンドは`foo'の出現をみつけ
るたびに, その出現を表示し, 置換するかどうか聞いてきます.
`query-replace'に数引数を指定すると, 単語区切り文字で区切られた出現だ
けを対象とします.  通常どおり`case-replace'が`nil'以外であれば,
`replace-string'と同じく, このコマンドも大文字小文字の違いを保存します.

問い合わせることを除けば, `query-replace'は`replace-string'と同様に動
作し, `query-replace-regexp'は`replace-regexp'と同様に動作します.  こ
のコマンドは, `C-M-%'で実行できます.

STRINGの出現やREGEXPに一致したものが表示されたときに打てる文字はつぎの
とおりです.


`SPC'
     出現をNEWSTRINGで置換する.

`DEL'
     この出現を置換せずにつぎの出現箇所に進む.

`, （カンマ）'
     この出現を置換し, 結果を表示する.  そして, つぎに何をするか指示す
     る文字を聞いてくる.  置換自体はすでに完了しているので, この状況で
     はDELとSPCは等価であり, つぎの出現箇所へ移動するという意味.

     この時点では, `C-r'（下記参照）を打って, 置換したテキストを変更で
     きる.  また, `C-x u'と打って, 置換をアンドゥする（もとに戻す）こ
     ともできるが, そうすると, `query-replace'を終了してしまう.  さら
     に先の置換を行いたいときには, `C-x ESC ESC RET'を使って再開する必
     要がある（*Note Repetition::）.

`RET'
     これ以上何も置換しないで終了する.

`. （ピリオド）'
     この出現を置換してから, これ以上探索せずに終了する.

`!'
     これ以降, 問い合わせずに残りの出現すべてを置換する.

`^'
     誤って変更してしまった場合などに, 1つまえの出現箇所（あるいは置換
     してしまった出現箇所）に戻る.  これは, マークリングから位置を取り
     出して動作する.  `query-replace'は直前の1つの置換位置だけを記録す
     るため, `^'を続けて入力しても意味はない.

`C-r'
     単にNEWSTRINGで置換するだけでなく, この出現を編集する必要がある場
     合などに, 再帰編集レベルに入る.  編集し終えて`C-M-c'で再帰編集を
     抜けると, つぎの出現箇所に移動する.  *Note Recursive Edit::.

`C-w'
     出現を削除してから, `C-r'と同様に再帰編集レベルに入る.  再帰編集
     を使って, 削除したSTRINGの出現を置き換えるテキストを挿入する.  編
     集し終えて`C-M-c'で再帰編集を抜けると, つぎの出現箇所に移動する.

`C-l'
     画面を再表示する.  そうしたら, この出現に対して何を行うかを指示す
     る別の文字を打つ必要がある.

`C-h'
     これらのオプションの要約メッセージを表示する.  そうしたら, この出
     現に対して何を行うかを指示する別の文字を打つ必要がある.

上記のコマンドの別名である文字が他にもいくつかあります.  `y', `n', `q'
は, それぞれ, SPC, DEL, RETに等価です.

これ以外の文字は`query-replace'を終了し, その文字はキー列の一部になり
ます.  したがって, `C-k'と打つと, `query-replace'を終了してから, 行末
までをキルします.

一度抜けた`query-replace'を再開するには, `C-x ESC ESC'を使います.  こ
のコマンドは`query-replace'を繰り返します.  というのは,
`query-replace'はミニバッファで引数を読み取るからです.  *Note C-x ESC
ESC: Repetition.

ファイル名に対して正規表現に一致する部分を置換することで, ファイルの改
名, コピー, リンクを行うdiredコマンドについては, *Note Transforming
File Names::も参照してください.



File: emacs-ja, Node: Other Repeating Search, Next: Fixit, Prev: Replace, Up: Search

他の探索繰り返しコマンド
========================

正規表現に一致するものをみつけるコマンドは, 他にもいくつかあります. 
それらは, ポイント位置からバッファの末尾までを操作対象とします.  さら
に, パターンに大文字が含まれていないときや, `case-fold-search'が`nil'
以外であるときには, 大文字小文字の違いを無視して一致を探します.


`M-x occur RET REGEXP RET'
     REGEXPに一致するものを含むバッファ内の各行の一覧を表示する.  数引
     数で, 一致した各行の前後何行を表示するか指定する.  デフォルトは0
     行.  バッファの一部に探索を制限するには, その部分にナロイングする
     （*Note Narrowing::）.

     出力を表示したバッファ`*Occur*'は, もとの文脈での出現位置を探すた
     めのメニューとして機能する.  `*Occur*'に表示された出現を`Mouse-2'
     でクリックするか, あるいは, ポイントをそこに置いてRETを打つ.  こ
     の操作により, 探索を行ったバッファに切り替え, 選択した出現のもと
     の位置にポイントを移動する.

`M-x list-matching-lines'
     `M-x occur'と同じ.

`M-x count-matches RET REGEXP RET'
     ポイント以降でREGEXPに一致するものの個数を表示する.

`M-x flush-lines RET REGEXP RET'
     ポイント以降にあってREGEXPに一致するものを含む各行を削除する.

`M-x keep-lines RET REGEXP RET'
     ポイント以降にあってREGEXPに一致するものを含ま*ない*各行を削除す
     る.

さらに, Emacsから`grep'を使って, 一連のファイルに対して正規表現に一致
するものを探して, 一致するものを含むファイルを順番に, あるいは, 任意の
順に訪問できます.  *Note Grep Searching::.


File: emacs-ja, Node: Fixit, Next: Files, Prev: Search, Up: Top

打ちまちがい訂正用コマンド
**************************

本章では, 入力直後にテキストのまちがいに気づいたとき, あるいは, テキス
トを作成中に気が変わったときに特に便利なコマンドを説明します.

まちがった編集を訂正するもっとも基本的なコマンドは, アンドゥコマンド,
`C-x u'や`C-_'です.  このコマンドは, （通常）1つのコマンド, コマンドの
一部分（`query-replace'の場合）, いくつかの連続した自己挿入文字をアン
ドゥします.  `C-_'や`C-x u'を連続して繰り返すと, アンドゥ情報がある限
り, 次々と以前の変更をアンドゥします.  より詳しくは, *Note Undo::.

* Menu:

* Kill Errors:: Commands to kill a batch of recently entered text.
* Transpose::   Exchanging two characters, words, lines, lists...
* Fixing Case:: Correcting case of last word entered.
* Spelling::    Apply spelling checker to a word, or a whole file.



File: emacs-ja, Node: Kill Errors, Next: Transpose, Prev: Fixit, Up: Fixit

誤りの訂正
==========

`DEL'
     ポイントの直前の文字を削除する（`delete-backward-char'）.
`M-DEL'
     ポイントの直前の単語をキルする（`backward-kill-word'）.
`C-x DEL'
     ポイントから文の先頭までをキルする（`backward-kill-sentence'）.

DEL文字（`delete-backward-char'）はもっとも重要な訂正コマンドです.  ポ
イントの直前にある文字を削除します.  自己挿入文字のコマンドに続けてDEL
を打つと, そのコマンドを取り消すと考えることができます.  しかし, コマ
ンドを取り消す一般的な方法はDELであるなどと誤解しないでください.

まちがいが数文字よりも長いときには, `M-DEL'や`C-x DEL'を使うほうが便利
でしょう.  `M-DEL'は直前の単語の先頭までをキルし, `C-x DEL'は直前の文
の先頭までをキルします.  文を書いている途中で気が変わったときには,
`C-x DEL'が特に便利です.  `M-DEL'と`C-x DEL'は, キルしたテキストを
`C-y'や`M-y'で戻せるように保存します.  *Note Yanking::.

何を打とうとしているのか混乱したりわからなくなったりしたときには, 打ち
まちがいがたとえ数文字であっても`M-DEL'はとても便利です.  このような場
合, 画面を見ながらでないとDELでは訂正できません.  `M-DEL'ならば, ほと
んど何も考えずに単語全体をキルして, 入力を再開できます.



File: emacs-ja, Node: Transpose, Next: Fixing Case, Prev: Kill Errors, Up: Fixit

テキストの入れ替え
==================

`C-t'
     2つの文字を入れ替える（`transpose-chars'）.
`M-t'
     2つの単語を入れ替える（`transpose-words'）.
`C-M-t'
     釣り合っている2つの式を入れ替える（`transpose-sexps'）.
`C-x C-t'
     2つの行を入れ替える（`transpose-lines'）.

2つの文字を入れ替えてしまうというよくあるまちがいは, それらが隣接して
いるならば, `C-t'コマンド（`transpose-chars'）で直せます.  通常, `C-t'
は, ポイントの両側にある文字を入れ替えます.  行末では, 行末の文字と改
行文字を入れ替えるという役に立たないことではなくて, `C-t'はその行の最
後の2文字を入れ替えます.  よって, 入れ替えまちがいにすぐに気づいたなら,
`C-t'だけで訂正できます.  まちがいにすぐに気づかなかったときには, 2つ
の入れ替わっている文字のあいだにカーソルを移動する必要があります.  空
白とそのまえの単語の最後の文字とを入れ替えてしまったときには, 単語移動
コマンドでその場所へ戻るのがよいでしょう.  それ以外の場合には, 後向き
探索（`C-r'）が最良であることがままあります.  *Note Search::.


`M-t'（`transpose-words'）は, 
ポイントの直前の単語とポイントの直後の単語を入れ替えます. 
ポイントは単語を1つ前向きに横断し, 
ポイントの直前の単語かポイントを含む単語を前向きに引きずっていきます. 
単語のあいだにある句読点文字は動きません. 
たとえば, `FOO, BAR'は`BAR FOO,'ではなくて, 
`BAR, FOO'と入れ替わります. 

`C-M-t'（`transpose-sexps'）は, 2つの式（*Note Lists::）を入れ替えるコ
マンドです.  また, `C-x C-t'（`transpose-lines'）は, 行を入れ替えます. 
これらのコマンドは`M-t'に似た動作をしますが, テキストを構文単位に分け
る点が異なります.

入れ替えコマンドに数引数を指定すると, 反復回数になります.  ポイントの
直前やポイントを含む文字（単語, S式, 行）をいくつ先の文字（単語, S式, 
行）へ移動するか指定します.  たとえば, `C-u 3 C-t'は, ポイントの直前の
文字を3文字先の文字へ移動します.  つまり, `f-!-oobar'を`oobf-!-ar'にし
ます.  これは `C-t'を3回繰り返したのと同じことです.  `C-u - 4 M-t'は, 
ポイントの直前の単語を4つまえの単語へ移動します.  `C-u - C-M-t'は, 引
数を指定しない`C-M-t'の効果を打ち消します.

数引数0には特別な意味があります（さもないと, コマンドを0回繰り返しても
何もしない）.  ポイントの直後の文字（単語, S式, 行）とマークの直後の文
字（単語, S式, 行）を入れ替えます.



File: emacs-ja, Node: Fixing Case, Next: Spelling, Prev: Transpose, Up: Fixit

大文字小文字変換
================

`M-- M-l'
     ポイントの直前の単語を小文字に変換する.  `Meta--'はメタ・マイナス.
`M-- M-u'
     ポイントの直前の単語をすべて大文字に変換する.
`M-- M-c'
     ポイントの直前の単語を最初の文字だけ大文字にして残りを小文字にす
     る.

とてもよくあるまちがいは, 単語を打つときに大文字小文字をまちがうことで
す.  このため, 単語の大文字小文字を変換するコマンド, `M-l', `M-u',
`M-c'に負の引数を指定すると, カーソル（ポイント）を移動しないという特
別な機能があります.  単語を打ちまちがえたとすぐに気づいたときには, 単
に大文字小文字を変換して, 入力を続けられます.  *Note Case::.



File: emacs-ja, Node: Spelling, Next: Files, Prev: Fixing Case, Up: Fixit

綴りの検査と訂正
================

本節では, 1つの単語やバッファのある部分の綴りを検査するコマンドを説明
します.  これらのコマンドは, Emacsの一部ではない綴り検査プログラム（ス
ペルチェッカ）ispellを使って動作します.  *Note Ispell:
(ispell.info)Top.

`M-x flyspell-mode'
     フライスペル（flyspell）モードをオンにする.  綴り誤りのあるすべて
     の単語を強調表示する.
`M-$'
     ポイント位置にある単語の綴りを検査し訂正する（`ispell-word'）.
`M-TAB'
     綴り辞書に基づいてポイントの直前の単語を補完する
     （`ispell-complete-word'）.
`M-x ispell-buffer'
     バッファ内の各単語の綴りを検査し訂正する.
`M-x ispell-region'
     リージョン内の各単語の綴りを検査し訂正する.
`M-x ispell-message'
     引用部分を除いて, メイルメッセージの草稿の各単語の綴りを検査し訂
     正する.
`M-x ispell-change-dictionary RET DICT RET'
     辞書としてDICTを使ってispellプロセスを再起動する.
`M-x ispell-kill-ispell'
     ispellプロセスを終了させる.

フライスペル（flyspell）モードは, Emacsで編集しているときに全自動で綴
り検査をする方法です.  単語を変更したり挿入したりするたびにその単語を
検査します.  認識できない単語をみつけると, その単語を強調表示します. 
これはユーザーの編集には干渉しませんが, ある単語が強調表示されたら, そ
の単語へ移動して訂正できます.  カレントバッファでこのモードをオン／オ
フするには, `M-x flyspell-mode'と打ちます.

フライスペル（flyspell）モードがある単語を綴りまちがいであると強調表示
したときには, その単語を`Mouse-2'でクリックできます.  すると, 訂正候補
やどんな操作を行えるか表示されます.  単語を手動で編集して好きなように
訂正してもかまいません.

Emacsの他の綴り検査機能は, 明示的にコマンドを実行したときに単語の検査
を行います.  バッファ全体やその一部分の綴りを検査する機能は, Emacsセッ
ション以外で作成した綴り誤りを含むかもしれないテキストには有益です.

ポイントの周りかポイントのつぎにある単語の綴りを検査し, 場合によっては
訂正するには, `M-$'（`ispell-word'）コマンドを使います.  単語が正しく
ないときには, その単語についてどうするかのさまざまな選択肢を提示します.

カレントバッファ全体を検査するには, `M-x ispell-buffer'を使います.  カ
レントリージョンだけを検査するには, `M-x ispell-region'を使います.  書
きかけの電子メイルメッセージの綴りを検査するには, `M-x ispell-message'
を使います.  これは, バッファ全体を検査しますが, 字下げしてある部分や
他のメッセージからの引用と思われる部分は検査しません.

これらのコマンドは, 正しくない単語に出会うたびに, どうするか聞いてきま
す.  通常, 検査した単語に似ている『近い』単語をいくつか含めた選択肢一
覧を表示します.  そうしたら, 文字を打たなくてはなりません.  以下に有効
な返答をあげます.

`SPC'
     この単語をスキップする.  この単語は正しくないとしておくが, ここで
     は変更しない.

`r NEW RET'
     （今回だけは）NEWで置き換える.

`R NEW RET'
     単語をNEWで置き換える.  さらに, バッファの他の箇所でも置き換えら
     れるように`query-replace'を実行する.

`DIGIT'
     （今回だけは）この単語を『近い』単語の1つで置き換える.  『近い』
     単語にはそれぞれ数字が付いているので, その数字を打つ.

`a'
     正しくない単語を容認する.  この編集セッションに限って, 正しいかの
     ように扱う.

`A'
     正しくない単語を容認する.  この編集セッションのこのバッファに限っ
     て, 正しいかのように扱う.

`i'
     この単語を個人辞書ファイルに入れ, ispellは今後のセッションを含め
     てこれ以降この単語を正しいものとして扱う.

`u'
     この単語を小文字に変換して個人辞書ファイルに入れる.

`m'
     `i'と同様だが, 辞書の補完情報も記録できる.

`l WORD RET'
     WORDに一致する単語を辞書から探す.  みつかった単語は, 新たな『近い』
     単語一覧となり, 数字を打って置き換える単語を選べる.  WORDには, ワ
     イルドカード`*'を使うこともできる.

`C-g'
     対話的な綴り検査を終了する.  `C-u M-$'で, あとで再開できる.

`X'
     `C-g'と同じ.

`x'
     対話的な綴り検査を終了し, 綴り検査を始めた箇所へポイントを戻す.

`q'
     対話的な綴り検査を終了し, ispellプロセスを終了させる.

`C-l'
     画面を再描画する.

`C-z'
     このキーは普通のコマンドの意味（Emacsを休止する, あるいは, このフ
     レームをアイコン化する）.

テキスト（text）モードやその関連したモードでは`M-TAB'キーにバインドし
てあるコマンド`ispell-complete-word'は, 綴り訂正に基づいた補完一覧を提
示します.  単語の始めの部分を挿入してから`M-TAB'と打つと, 補完一覧ウィ
ンドウを表示します.  補完一覧から1つを選ぶには, 候補のうえで`Mouse-2'
をクリックするか, カーソルを補完ウィンドウの単語の箇所に移動してから
RETと打ちます.  *Note Text Mode::.


一度綴り検査を行うと, ispellプロセスは（何かすることを待って）動き続け
ます.  ですから, つぎに綴り検査コマンドを使うと, より早く実行を完了し
ます.  ispellプロセスを取り除きたいときには, `M-x ispell-kill-ispell'
を使います.  ispellプロセスは綴り訂正をしているとき以外には何もしない
ので, 通常はこのコマンドを使う必要はありません.

ispellは2つの辞書を使います.  標準辞書と個人辞書です.  変数
`ispell-dictionary'は, 使用すべき標準辞書のファイル名を指定します.  こ
の値が`nil'ならば, デフォルトの辞書を使います.  `M-x
ispell-change-dictionary'コマンドはこの変数を設定して, 設定した辞書を
使うようにispellサブプロセスを再起動します.



File: emacs-ja, Node: Files, Next: Buffers, Prev: Fixit, Up: Top

ファイルの扱い方
****************

オペレーティングシステムは, データを指定した"ファイル"（file）に恒久的
に保存します.  ですから, Emacsで編集するテキストの多くはファイルから取
り込み, 最終的にはファイルに格納されます.

ファイルを編集するには, Emacsに対してファイルを読むように指示して, ファ
イルの内容のコピーを入れたバッファを用意させる必要があります.  これを, 
ファイルを"訪問する／訪れる"（visiting）といいます.  編集コマンドはバッ
ファ内のテキストに直接作用します.  つまり, Emacs内にあるコピーを操作し
ます.  バッファをファイルに"保存"（save）した場合に限り, 変更はファイ
ルそのものに反映されます.

ファイルを訪問したり保存したりすることに加えて, Emacsは, ファイルを, 
削除したり, コピーしたり, 名前を変更したり, 別のファイルへ追加したり, 
複数の版を保持したり, ファイルディレクトリを操作したりできます.

* Menu:

* File Names::          How to type and edit file-name arguments.
* Visiting::            Visiting a file prepares Emacs to edit the file.
* Saving::              Saving makes your changes permanent.
* Reverting::           Reverting cancels all the changes not saved.
* Auto Save::           Auto Save periodically protects against loss of data.
* File Aliases::        Handling multiple names for one file.
* Version Control::     Version control systems (RCS, CVS and SCCS).
* Directories::         Creating, deleting, and listing file directories.
* Comparing Files::     Finding where two files differ.
* Misc File Ops::       Other things you can do on files.
* Compressed Files::    Accessing compressed files.
* Remote Files::        Accessing files on other sites.
* Quoted File Names::   Quoting special characters in file names.



File: emacs-ja, Node: File Names, Next: Visiting, Prev: Files, Up: Files

ファイル名
==========

ファイルを操作するほとんどのEmacsコマンドには, ファイル名を指定する必
要があります.  （保存と復元の操作を除く.  バッファはこれらの操作に対し
て使うファイル名を記録している. ）ファイル名は, ミニバッファを使って入
力します（*Note Minibuffer::）.  長いファイル名の指定を簡単にする補完
も使えます.  *Note Completion::.

多くの操作には, "デフォルトファイル名"があり, RETだけを打って空の引数
を指定した場合に使われます.  通常, デフォルトファイル名は, カレントバッ
ファで訪問したファイルの名前です.  こうすることで, Emacsのファイルコマ
ンドで当該ファイルを操作するのが簡単になります.

各バッファにはデフォルトディレクトリがあります.  通常は, そのバッファ
の訪問先のファイルのディレクトリと同じです.  ディレクトリを指定しない
でファイル名を入力すると, デフォルトディレクトリを使います.  スラッシュ
（`/'）で始まらない相対的なディレクトリを指定すると, デフォルトディレ
クトリ相対に解釈します.  デフォルトディレクトリは変数
`default-directory'に保持されていて, バッファごとに別々の値を持ちます.

たとえば, デフォルトファイル名が`/u/rms/gnu/gnu.tasks'ならば, デフォル
トディレクトリは`/u/rms/gnu/'です.  ディレクトリを指定しないで`foo'と
だけ打つと, `/u/rms/gnu/foo'を意味します.  `../.login'は,
`/u/rms/.login'を意味します.  `new/foo'は, ファイル名
`/u/rms/gnu/new/foo'を意味します.

コマンド`M-x pwd'は, カレントバッファのデフォルトディレクトリを表示し, 
コマンド`M-x cd'は, それを（ミニバッファで読んだ値に）設定します.  バッ
ファのデフォルトディレクトリは, `cd'コマンドを使ったときだけ変更されま
す.  ファイルを訪問しているバッファのデフォルトディレクトリは, 訪問し
たファイルのディレクトリに初期化されます.  `C-x b'で作ったバッファのデ
フォルトディレクトリは, その時点のカレントバッファのデフォルトディレク
トリと同じです.

デフォルトディレクトリは, ミニバッファでファイル名を読むときに, 実際に
ミニバッファに表示されます.  これには2つの目的があります.  デフォルト
が何であるかを*示す*ことで, 相対ファイル名を打ち込めるようにし, しかも, 
その意味を確実に知ることができるようにします.  もう1つは, デフォルトディ
レクトリを*編集*して, 別のディレクトリを指定できるようにします.  変数
`insert-default-directory'を`nil'に設定すると, デフォルトディレクトリ
を挿入しません.

ミニバッファで入力するとき, テキストの一部として入っているデフォルトディ
レクトリを無視して, 絶対ファイル名を打っても何の問題もありません.  最
終的なミニバッファの内容は不正なように見えても, そうではありません. 
たとえば, ミニバッファには`/usr/tmp/'が入っていて`/x1/rms/foo'を追加す
ると, `/usr/tmp//x1/rms/foo'となります.  Emacsは連続した2個のスラッシュ
の始めのスラッシュまでをすべて無視するので, 結果として`/x1/rms/foo'と
なります.  *Note Minibuffer File::.

ファイル名の中の`$'は環境変数で置き換えられます.  たとえば, シェルコマ
ンド`export FOO=rms/hacks'で, 環境変数`FOO'を設定してあるとします.  そ
うすると, `/u/rms/hacks/test.c'の略称として`/u/$FOO/test.c'や
`/u/${FOO}/test.c'を使えます.  環境変数の名前は, `$'のうしろにある英数
字全部です.  あるいは, `$'のうしろにある括弧で囲まれたものです.  シェ
ルコマンドで設定した環境変数がEmacsに影響を及ぼすのは, Emacsを起動する
まえに設定したものに限ります.

名前の中に`$'があるファイルを参照するには, `$$'と打ちます.  1個の`$'に
対して変数の置き換えを行うときに, この2個の`$'は1個の`$'に変換されます. 
あるいは, ファイル名全体を`/:'でクォートします（*Note Quoted File
Names::）.

（変数の）置き換えを行うLisp関数は`substitute-in-file-name'です.  置き
換えは, ミニバッファで読んだファイル名だけに適用されます.

変数`file-name-coding-system'に`nil'以外を設定すると, ファイル名に非
ASCIIを含めることができます.  *Note Specify Coding::.



File: emacs-ja, Node: Visiting, Next: Saving, Prev: File Names, Up: Files

ファイルを訪問する
==================

`C-x C-f'
     ファイルを訪問する（`find-file'）.
`C-x C-r'
     ファイルを眺めるために訪問し, 変更を許さない
     （`find-file-read-only'）.
`C-x C-v'
     最後に訪問したファイルのかわりに, 別のファイルを訪問する
     （`find-alternate-file'）.
`C-x 4 f'
     別のウィンドウでファイルを訪問する（`find-file-other-window'）. 
     選択されているウィンドウに表示されている内容は変化しない.
`C-x 5 f'
     新たなフレームでファイルを訪問する（`find-file-other-frame'）. 
     選択されているフレームに表示されている内容は変化しない.
`M-x find-file-literally'
     ファイルの内容をいっさい変換せずに訪問する.

ファイルを"訪問する／訪れる"とは, ファイルの内容のコピーを編集できるよ
うにEmacsバッファに入れることです.  Emacsは, 訪問する各ファイルごとに
新たにバッファを作ります.  バッファ名は, ディレクトリ部分を取りさった
ファイル名から作ります.  たとえば, ファイル名`/usr/rms/emacs.tex'のバッ
ファ名は`emacs.tex'となります.  その名前のバッファがすでに存在するなら
ば, まだ使われていない名前になるようなもっとも小さい数を使って, `<2>',
`<3>'などを付加して唯一の名前を作ります.

各ウィンドウのモード行にはウィンドウ内に表示しているバッファ名が示され
ているので, 編集しているバッファが何かいつでもわかります.

編集コマンドによる変更は, Emacsバッファに対して行われます.  バッファを
"保存"するまでは, 変更は, 訪問先のファイルや他のどんな恒久的なものにも
影響しません.  バッファを保存するとは, バッファの現在の内容をそのバッ
ファの訪問先のファイルに書き出すことです.  *Note Saving::.

バッファに未保存の変更がある場合, バッファは"変更されている"といいます. 
バッファを保存しないと変更内容が失われてしまうので, これは重要なことで
す.  モード行の左端近くに2個の星印を表示して, バッファが変更されている
ことを示します.

ファイルを訪問するには, コマンド`C-x C-f'（`find-file'）を使います. 
このコマンドに, 訪問したいファイル名を続けてRETで終えます.

ファイル名はミニバッファ（*Note Minibuffer::）で読まれ, このときデフォ
ルトや標準的な方法の補完を使えます（*Note File Names::）.  ミニバッファ
内で`C-g'と打てば, `C-x C-f'をアボートできます.

`C-x C-f'が正しく完了したことは, 画面上に新たに現れるテキストとモード
行に現れる新たなバッファ名で確認できます.  指定したファイルが存在せず
作成もできない場合や読めない場合には, エコー領域にエラーメッセージが表
示されます.

すでに訪問しているファイルを再度訪問すると, `C-x C-f'は別のコピーを作
らずに, そのファイルを入れた既存のバッファを選択します.  しかし, そう
するまえに, 訪問してから, あるいは, 保存してから以降にファイルが変更さ
れたかどうか検査します.  ファイルが変更されていると警告メッセージを表
示します.  *Note Interlocking::.

新たにファイルを作りたいときにはどうするのでしょう？` ' 単に訪問すれば
よいのです.  Emacsはエコー領域に`(New File)'と表示しますが, それ以外に
関しては, あたかも空のファイルが存在するかのようにふるまいます.  変更
してから保存すれば, ファイルを作成できます.

Emacsはファイルの内容から, 行区切りの方法, すなわち, （GNU/LinuxやUNIX
で使われる）改行, （Microsoftシステムで使われる）復帰改行, 
（Machintoshで使われる）復帰のみを認識します.  さらに, Emacsの通常の方
法, つまり, 改行文字で行を区切るように内容を自動的に変換します.  これ
は, コーディングシステム変換（*Note Coding Systems::）の一般的な機能の
一部であり, さまざまの異なるオペレーティングシステムから持ってきたファ
イルを同一の方法で編集できるようにします.  テキストを変更してファイル
に保存すると, Emacsは逆変換を行い, 必要ならば, 改行を復帰改行や復帰の
みに戻します.

指定したファイルが実際にはディレクトリならば, `C-x C-f'はEmacsのディレ
クトリブラウザであるdiredを起動するので, ディレクトリの内容を『編集』
できます（*Note Dired::）.  diredは, ディレクトリ内のファイルを, 消去
したり, 眺めたり, 操作するのに便利です.  しかし, 変数 
`find-file-run-dired'が`nil'ならば, ディレクトリを訪問しようとするとエ
ラーになります.

指定したファイル名にワイルドカード文字が含まれていると, Emacsは一致す
るすべてのファイルを訪問します.  ワイルドカード文字そのものを含む名前
のファイルを訪問するには, *Note Quoted File Names::.

オペレーティングシステムが変更を許さないファイルを訪問すると, Emacsは
バッファを読み出し専用に設定するので, 修正できなかったり, 修正できても
あとで保存に手間取ります.  `C-x C-q'（`vc-toggle-read-only'）で, バッ
ファを書き込み可能にできます.  *Note Misc Buffer::.

ときには, 自分でまちがって変更しないように, ファイルを読み出し専用で訪
問したい場合があります.  そういう場合には, コマンド`C-x C-r'
（`find-file-read-only'）でファイルを訪問します.

（ファイル名をまちがって打ったりして）存在しないファイルを意図せずに訪
問してしまったときには, `C-x C-v'コマンド（`find-alternate-file'）を使っ
て本当の目的のファイルを訪問します.  `C-x C-v'は`C-x C-f'と同様ですが, 
（バッファが変更されていればまず保存するかどうか聞いてから）カレントバッ
ファを消去します.  訪問するファイル名を読むときには, ミニバッファにデ
フォルトファイル名全体を挿入し, ディレクトリ部分の直後にポイントを置き
ます.  これは, ファイル名をほんの少しまちがって入力したときに便利です.

存在するのに読めないファイルを訪問すると, `C-x C-f'はエラーを通知しま
す.

`C-x 4 f'（`find-file-other-window'）は, 別のウィンドウで, 指定したファ
イルを入れたバッファを選択することを除けば, `C-x C-f'と同じです.  `C-x
4 f'を実行するまえに選択されていたウィンドウは, 同じバッファを表示した
ままです.  ウィンドウを1つだけ表示しているときにこのコマンドを使うと, 
そのウィンドウを2つに分けて, 一方のウィンドウにはまえと同様に同じバッ
ファを表示しますが, もう一方には新たに指示したファイルを表示します.
*Note Windows::.

`C-x 5 f'（`find-file-other-frame'）も同様ですが, 新たなフレームを開く
か, 捜しているファイルを表示している既存のフレームを見えるようにします. 
ウィンドウシステムを使っているときだけ, この機能を利用できます.  *Note
Frames::.

特別な符号化や変換をせずにファイルを文字の列として編集したいときには,
`M-x find-file-literally'コマンドを使います.  このコマンドは, `C-x
C-f'のようにファイルを訪問しますが, 形式変換（*Note Formatted Text::）, 
文字コード変換（*Note Coding Systems::）, （圧縮を）自動展開（*Note
Compressed Files::）といったことをしません.  （そのままの文字の列とし
てではなく）普通の方法で同じファイルをすでに訪問している場合には, この
コマンドは, そのままの文字の列として訪問するかどうか聞いてきます.

2つの特別なフック変数で, ファイルを訪問する操作を修正して拡張できます. 
存在しないファイルを訪問すると, `find-file-not-found-hooks'のリスト内
の関数群を実行します.  この変数は関数のリストを保持していて, 呼び出し
た関数の中のどれかが`nil'以外を返すまで1つ1つ順に呼び出します.  ファイ
ルが存在するかどうかに関わらず, どんなファイルを訪問するときでも
`find-file-hooks'には関数のリストが入っていると仮定され, それらの1つ1
つを順にすべて呼び出します.  いずれの場合でも, 関数は引数を受け取りま
せん.  2つの変数のうち, 先に`find-file-not-found-hooks'を使います.  こ
れらの変数はノーマルフックではありま*せん*.  これらの名前が`-hook'では
なくて`-hooks'で終っていることで, その事実を表しています.  *Note
Hooks::.

編集するファイルに対して自動的にメジャーモード（*Note Choosing Modes::）
を設定し, そのファイルに対して特別なローカル変数（*Note File
Variables::）を定義する方法がいくつかあります.



File: emacs-ja, Node: Saving, Next: Reverting, Prev: Visiting, Up: Files

ファイルを保存する
==================

Emacsにおいてバッファを"保存"するとは, バッファの内容をそのバッファの
訪問先のファイルへ書き戻すことです.

`C-x C-s'
     カレントバッファを訪問先のファイルに保存する（`save-buffer'）.
`C-x s'
     任意のバッファかすべてのバッファをそれぞれの訪問先のファイルに保
     存する（`save-some-buffers'）.
`M-~'
     カレントバッファを変更していないことにする（`not-modified'）.
`C-x C-w'
     カレントバッファを指定したファイルに保存する（`write-file'）.
`M-x set-visited-file-name'
     カレントバッファを保存するファイルの名前を変更する.

ファイルを保存して変更を恒久的なものとするには, `C-x C-s'
（`save-buffer'）と打ちます.  保存を完了すると`C-x C-s'はつぎのような
メッセージを表示します.

     Wrote /u/rms/gnu/gnu.tasks

選択されているバッファが変更されていなければ（バッファを作って以降, あ
るいは, 最後に保存して以降に, 変更されていない）, 保存しても何もならな
いので実際には保存しません.  かわりに, `C-x C-s'はつぎのようなメッセー
ジをエコー領域に表示します.

     (No changes need to be saved)

コマンド`C-x s'（`save-some-buffers'）は, 変更された任意のバッファやす
べてのバッファを保存できるようにします.  各バッファについて, 何をする
か聞いてきます.  このとき選べる返答は, `query-replace'に対するものに似
ています.

`y'
     このバッファを保存し, 残りのバッファについても質問する.
`n'
     このバッファを保存しないが, 残りのバッファについては質問する.
`!'
     このバッファを保存し, 残りのすべてのバッファについても質問せずに
     保存する.
`RET'
     何も保存せずに`save-some-buffers'を終了する.
`.'
     このバッファを保存し, 他のバッファについては何も聞かずに
     `save-some-buffers'を終える.
`C-r'
     質問対象のバッファを閲覧する.  閲覧（view）モードから抜けると,
     `save-some-buffers'に戻りふたたび質問する.
`C-h'
     これらのオプションについてのヘルプメッセージを表示する.

Emacsから抜けるキー列`C-x C-c'は, `save-some-buffers'を起動するので, 
同じ質問をしてきます.

バッファを変更したけれども変更を保存したくないならば, それを避けるため
の処置をすべきでしょう.  そうしないと, `C-x s'や`C-x C-c'を使うたびに, 
まちがってバッファを保存してしまいがちです.  1つの方法は, `M-~'
（`not-modified'）と打つことです.  これは, バッファが変更されているこ
とを示すフラグを消します.  こうしておくと, 保存コマンドはバッファを保
存する必要がないと結論します.  （`~'は「否定」（not）を意味する数学記
号としてしばしば使われる.  よって`M-~'は, メタ付き「否定」. ）
`set-visited-file-name'（下記参照）を使って, 別のファイルを訪問してい
るバッファである旨の印を付けることもできます.  このときファイル名には, 
重要でない使っていないものを指定します.  あるいは, ファイルからテキス
トを再度読み直して, ファイルを訪問したり保存したりした以降のすべての変
更を取り消します.  これを"復元"（reverting）といいます.  *Note
Reverting::.  すべての変更がもとに戻るまでアンドゥコマンド`C-x u'を繰
り返し使って, 変更しなかったことにもできます.  しかし, 復元のほうが簡
単です.

`M-x set-visited-file-name'は, カレントバッファで訪問しているファイル
の名前を変更します.  このコマンドは, ミニバッファで新たなファイル名を
読み取ります.  そして, 訪問先ファイル名を設定し直し, それに従って（新
しい名前が使われていなければ）バッファ名も変更します.
`set-visited-file-name'は, 新たに指定した訪問先のファイルへはバッファ
を保存しません.  あとで保存する場合に備えて, Emacs内部の記録を変更する
だけです.  また, バッファには『変更された』旨の印を付け, `C-x C-s'がそ
のバッファを保存*しようとする*ようにします.

別のファイルを訪問しているという旨の印をバッファに付けて, ただちに保存
したい場合には, `C-x C-w'（`write-file'）を使います.  このコマンドは,
`set-visited-file-name'に続けて`C-x C-s'を実行するのと等価です.  ファ
イルを訪問していないバッファに対して`C-x C-s'を使うことは, `C-x C-w'と
同じ効果があります.  つまり, ファイル名を読み取り, バッファにはそのファ
イルを訪問しているという印を付け, バッファをそのファイルに保存します. 
ファイルを訪問していないバッファのデフォルトのファイル名は, バッファの
デフォルトディレクトリとバッファ名を組み合わせて作ります.

新しいファイル名がメジャーモードを示唆するものであれば, `C-x C-w'は, 
多くの場合, そのメジャーモードに切り替えます.  コマンド
`set-visited-file-name'もそのようにします.  *Note Choosing Modes::.

Emacsがファイルを保存しようとするときに, ディスク上の最新版の日付が
Emacsが最後に読み書きしたものと合わなかったら, Emacsはそのことを通知し
ます.  というのは, 同時に編集したために引き起こされた問題である可能性
があるので, ユーザーにただちに知らせる必要があるからです.  *Note
Interlocking::.

変数`require-final-newline'が`nil'以外だと, Emacsはファイルを保存する
たびに, ファイルの末尾に改行がなければ改行を挿入します.  デフォルトは
`nil'です.

* Menu:

* Backup::              How Emacs saves the old version of your file.
* Interlocking::        How Emacs protects against simultaneous editing
                          of one file by two users.



File: emacs-ja, Node: Backup, Next: Interlocking, Prev: Saving, Up: Saving

バックアップファイル
--------------------

多くのオペレーティングシステムでは, ファイルを書き換えるとファイルに入っ
ていたそれまでの記録は自動的に破棄されます.  したがって, Emacsでファイ
ルを保存すると, ファイルの古い内容は捨てられます.  しかし, 実際に保存
するまえに, 古い内容を"バックアップ"ファイルと呼ばれる別のファイルに
Emacsが注意深くコピーすれば, 古い内容は破棄されません.

ほとんどのファイルでは, バックアップファイルを作るかどうかは変数
`make-backup-files'で決まります.  多くのオペレーティングシステムでは, 
この変数のデフォルト値は`t'であり, Emacsはバックアップファイルを作りま
す.

版管理システム（*Note Version Control::）が管理するファイルに対しては, 
バックアップファイルを作るかどうかは変数`vc-make-backup-files'で決まり
ます.  デフォルトは`nil'です.  というのは, すべての古い版を版管理シス
テムに保管してあるので, バックアップファイルは冗長だからです.  *Note
VC Workfile Handling::.

変数`backup-enable-predicate'のデフォルト値は, `/tmp'にあるファイルの
バックアップファイルを作らないようにします.

Emacsでは, 単一のバックアップファイルを保持することも, 編集した各ファ
イルごとに一連の番号付きバックアップファイルを保持することもできます.

Emacsがファイルのバックアップファイルを作るのは, バッファからそのファ
イルへ最初に保存したときだけです.  たとえ何度ファイルを保存したとして
も, そのバックアップファイルは, ファイルを訪問する以前の内容を保持し続
けます.  通常これは, 今の編集セッションを始める以前の内容をバックアッ
プファイルが保持していることを意味します.  しかしながら, バッファを消
去してから再度ファイルを訪問すると, それ以降に保存するときには新たにバッ
クアップファイルを作ります.

少なくとも一度は保存したとしても, バッファからもう1つバックアップファ
イルを作るように明示的に指示することもできます.  `C-u C-x C-s'でバッファ
を保存すると, このとき保存した版は, バッファを再度保存するときにはバッ
クアップファイルになります.  `C-u C-u C-x C-s'もバッファを保存しますが, 
まずファイルの古い内容をバックアップファイルにします.  `C-u C-u C-u
C-x C-s' はその両方を行います.  ファイルの以前の内容からバックアップファ
イルを作り, さらに, バッファを再度保存するとこのとき保存した版からもう
1つバックアップファイルを作るように準備します.

* Menu:

* Names: Backup Names.		How backup files are named;
				  choosing single or numbered backup files.
* Deletion: Backup Deletion.	Emacs deletes excess numbered backups.
* Copying: Backup Copying.	Backups can be made by copying or renaming.



File: emacs-ja, Node: Backup Names, Next: Backup Deletion, Prev: Backup, Up: Backup

単一バックアップファイルと番号付きバックアップファイル
......................................................

単一バックアップファイルを作ることを選択すると（デフォルト）, バックアッ
プファイルの名前は, 編集しているファイルの名前に`~'を付加したものにな
ります.  したがって, `eval.c'のバックアップファイルは`eval.c~'となりま
す.

番号付きの一連のバックアップファイルを作ることを選択すると, バックアッ
プファイルの名前は, もとのファイル名に`.~'と数字ともう1つ`~'を付加した
ものになります.  したがって, `eval.c'のバックアップファイルは,
`eval.c.~1~', `eval.c.~2~', …, `eval.c.~259~'というようにどこまでも続
きます.

保護機構のために普通の名前でバックアップファイルを書けなくなると, ユー
ザーのホームディレクトリの`%backup%~'にバックアップファイルを書きます. 
そのファイルはたった1つしか存在できないので, 最新のバックアップにしか
利用できません.

単一バックアップか番号付きバックアップかの選択は, 変数
`version-control'で制御されます.  この変数に設定できる値はつぎのとおり
です.

`t'
     番号付きバックアップを作る.
`nil'
     ファイルに対して番号付きバックアップファイルがすでにあるならば番
     号付きバックアップを作る.  さもなければ, 単一バックアップを作る.
`never'
     どんな場合にも番号付きバックアップを作らない.  つねに単一バックアッ
     プを作る.

各バッファではローカルに`version-control'を設定できるので, そのバッファ
のファイルに対するバックアップの作成方法を制御できます.  たとえば,
rmailモードでは, rmailファイルのバックアップを1個だけに限定するために,
`version-control'にはローカルに`never'を設定します.  *Note Locals::.

環境変数`VERSION_CONTROL'を設定すると, さまざまなGNUユーティリティにど
のようにバックアップファイルを扱うか指示できます.  Emacsも環境変数に従っ
て動作し, 開始時にそれに一致するようにLisp変数`version-control'を設定
します.  環境変数の値が`t'か`numbered'なら, `version-control'は`t'にな
ります.  環境変数の値が`nil'か`existing'なら, `version-control'は`nil'
になります.  環境変数の値が`never'か`simple'なら, `version-control'は
`never'になります.



File: emacs-ja, Node: Backup Deletion, Next: Backup Copying, Prev: Backup Names, Up: Backup

バックアップの自動削除
......................

ディスク容量を無限に浪費することを避けるために, Emacsは番号付きバック
アップの版を自動的に削除できます.  一般には, Emacsは始めの数個と最新の
数個のバックアップを残して, そのあいだのものをすべて削除します.  これ
は, 新たにバックアップを作るごとに行われます.

2つの変数`kept-old-versions'と`kept-new-versions'は, このような削除を
制御します.  それらの値は, それぞれ, 新たにバックアップを作るときに, 
保持すべき最古（番号が最小）のバックアップの個数, 保持すべき最新（番号
が最大）のバックアップの個数です.  それらの値は, バックアップの新版を
作った直後に使われることに注意してください.  新たに作ったバックアップ
も, `kept-new-versions'の数に含まれます.  デフォルトでは, どちらの変数
も2です.

`delete-old-versions'が`nil'以外ならば, 何もいわずに余分な中間の版を削
除します.  デフォルト値である`nil'ならば, 余分な中間の版を削除するかど
うかを聞いてきます.

diredの`.'（ピリオド）コマンドも古い版を削除するために使えます.  *Note
Dired Deletion::.



File: emacs-ja, Node: Backup Copying, Next: Interlocking, Prev: Backup Deletion, Up: Backup

コピーと改名
............

バックアップファイルは, 古いファイルをコピーする, あるいは, それを改名
することで作ります.  古いファイルに複数の名前があると, これには違いが
出てきます.  古いファイルを改名してバックアップファイルにすると, （古
いファイルの）別の名前もバックアップファイルを指します.  古いファイル
をコピーした場合には, （古いファイルの）別の名前は編集しているファイル
を指し続け, その名前で参照される内容も新しい内容になります.

バックアップファイルを作る方法は, 元ファイルの所有者とグループにも影響
します.  コピーするならば, 何も変更されません.  改名すると, ファイルの
所有者はあなたになり, ファイルのグループはデフォルトになります（オペレー
ティングシステムごとにグループのデフォルトは異なる）.

所有者を変更することは, 多くの場合, よいことです.  というのは, 所有者
がつねに最後にファイルを編集した人を表すからです.  同様に, バックアッ
プの所有者はその版を作った人を表します.  ときには, ファイルの所有者を
変更すべきでないファイルがあります.  そのようなファイルについては,
`backup-by-copying-when-mismatch'をローカルに設定するローカル変数リス
トをファイルに入れておくのがよいです.

改名するかコピーするかは, 3つの変数で制御されます.  デフォルトは, 改名
です.  変数`backup-by-copying'が`nil'以外ならばコピーします.  `nil'の
ときには, 変数`backup-by-copying-when-linked'が`nil'以外ならば, 複数の
名前を持つファイルではコピーし, 編集中のファイルには名前が1つだけなら
改名します.  変数`backup-by-copying-when-mismatch'が`nil'以外のときに
は, 改名するとファイルの所有者やグループが変更されるときにはコピーしま
す.  スーパーユーザーでEmacsを起動すると,
`backup-by-copying-when-mismatch'のデフォルトは`t'です.

ファイルを版管理システム（*Note Version Control::）で管理している場合
には, 通常Emacsはそのファイルのバックアップを通常の方法では作りません. 
チェックインとチェックアウトは, ある意味でバックアップを作ることに似て
います.  残念なことに, これらの操作は典型的にはハードリンクを切るとい
う類似性があります.  つまり, あるファイルの別の名前を使っていたとする
とそのファイル名がなくなるのです.  Emacsにできることはありません.  版
管理システムが処理します.



File: emacs-ja, Node: Interlocking, Next: Reverting, Prev: Backup, Up: Saving

同時編集に対する保護
--------------------

2人のユーザーが同じファイルを訪問し, 両者がそれを編集し, 両者がそれを
保存すると, 同時編集が発生します.  こういったことが起きていることを誰
も知らせなければ, 最初に保存したユーザーは, あとになって自分の変更が失
われていることを知るでしょう.

ある種のシステムでは, 2人目のユーザーがファイルを変更し始めたことを
Emacsがただちに検知して警告を発します.  すべてのシステムでは, ファイル
を保存するときにEmacsが検査して, 他人の変更を上書きしようとしているな
らば警告します.  ファイルを保存するかわりに適切な修正操作を行えば, 他
人の作業結果を失うことを避けられます.

ファイルを訪問しているEmacsバッファで初めて修正を行うと, Emacsはそのユー
ザーがファイルを"ロック"したと記録します.  （同じディレクトリ内に異な
る名前のシンボリックリンクを作ることで実現する. ）変更を保存すると
Emacsはロックを消します.  つまり, ファイルを訪問しているEmacsバッファ
に未保存の変更があるときにはファイルをロックしておくのです.

他人がロックしているファイルを訪問先とするバッファを修正し始めると"衝
突"が起こります.  Emacsが衝突を検知すると, Lisp関数
`ask-user-about-lock'を呼び出して, どうするかを聞いてきます.  この関数
をカスタマイズのために再定義することもできます.  この関数の標準の定義
では, ユーザーに質問をし, 3つの返答を受理します.

`s'
     ロックを横取りする.  ファイルをすでに変更していた人はロックを失い, 
     あなたがロックを得る.
`p'
     続行する.  誰かがファイルをロックしたままであるにもかかわらず, ファ
     イルを編集する.
`q'
     放棄する.  これはエラー（`file-locked'）を引き起こし, バッファ内
     で修正しようとしたことは, 実際には行われない.

ロックはファイル名に基づいて動作することに注意してください.  ファイル
に複数の名前があると, Emacsには2つの名前が同じファイルであることはわか
らないので, 2人のユーザーが異なる名前で同じファイルを編集することは防
げません.  しかし, 名前に基づいたロックなので, 保存しない限り実在しな
い新規ファイルの編集をEmacsはインターロック (1) (*Note
Interlocking-Footnotes::) できます.

Emacsがロックを作れる構成になっていないシステムもあります.  また, ロッ
クファイルを書けない場合もあります.  こういった状況では, Emacsがあらか
じめトラブルを検知することはできませんが, 他人の変更を上書きしてファイ
ルを保存しようとしたときには, 衝突を検知できます.

Emacsやオペレーティングシステムがクラッシュすると, 古いロックファイル
が残っていることあります.  そのため, ときどき偽の衝突についての警告を
受けとることがあるかもしれません.  偽の衝突であると確信できれば, Emacs
にとにかく続行するように指示する`p'を使います.

Emacsは, バッファを保存するたびに, ディスク上のファイルの最終変更日時
が最後に訪問／保存したときから更新されていないことをまず検査します. 
変更日時が不一致ならば, なんらかの方法でそのファイルが変更されたことを
示し, Emacsが本当に保存するとそれらの変更が失われてしまいます.  これを
避けるために, Emacsは警告のメッセージを表示し, 保存するまえに確認を求
めます.  ファイルが変更された理由を承知していて, それが問題でないこと
を知っていることもあるでしょう.  そうならば, `yes'と答えて続行できます. 
さもなければ, `C-g'で保存を中断して, その事態を調査するべきです.

同時編集が発生したことを知らされたときにまず行うべきことは, `C-u C-x
C-d'（*Note Directories::）でディレクトリ一覧を見ることです.  このコマ
ンドは, ファイルの現在の所有者を表示します.  その人に連絡して, 編集を
続けないように警告しましょう.  そのつぎの段階は, 別の名前でEmacsバッファ
を保存して, `diff'で2つのファイルを比較することでしょう.


File: emacs-ja  Node: Interlocking-Footnotes, Up: Interlocking

(1) 【訳注】進行中の動作が完了するまでは, つぎの動作を開始させないよう
にすること.



File: emacs-ja, Node: Reverting, Next: Auto Save, Prev: Saving, Up: Files

バッファを復元する
==================

広範囲にファイルを変更したあとで気が変わったときには, そのような変更を
捨てるためにファイルのまえの版を読み込みます.  これには, カレントバッ
ファに作用する`M-x revert-buffer'を使います.  意図せずにバッファを復元
することは, たくさんの作業結果を失うことになるので, このコマンドには
`yes'で確認を与える必要があります.

`revert-buffer'は, ファイルの先頭から同じ距離（文字数）にポイントを保
ちます.  少し編集しただけなら, 復元前後のポイント位置はだいたい同じ部
分にあります.  徹底的に変更してしまったときには, 古いファイルでのポイ
ント位置ではまったく異なるテキスト部分に位置付けるでしょう.

復元すると, 改めて変更するまでは, そのバッファには『変更なし』の印が付
きます.

diredバッファのように, ファイル以外のデータを反映するバッファでも復元
できる場合があります.  その場合, 復元とは, 適切なデータに基づいて内容
を計算し直すことを意味します.  `C-x b'で明示的に作ったバッファを復元す
ることはできません.  そういった指示をすると, `revert-buffer'はエラーを
報告します.

自動的にかつ頻繁に変更されるファイル, たとえば, 実行中のプロセスから出
力されるログ, を編集するときには, `C-x C-f'でファイルを再訪問すると何
も聞かずにファイルを復元できると便利です.

こういったふるまいを指示するには, 変数`revert-without-query'に正規表現
のリストを設定します.  これらの正規表現の1つにファイル名が一致すると,
`find-file'と`revert-buffer'は, バッファが変更されていない限り, そのファ
イルが変更されていても復元します.  （テキストを編集してしまったときに
は, 変更を捨てさるのはまちがっている. ）



File: emacs-ja, Node: Auto Save, Next: File Aliases, Prev: Reverting, Up: Files

自動保存, 不慮の事故に対する備え
================================

Emacsは（打鍵数に基づいて）定期的に, 訪問しているすべてのファイルを何
も聞かずに保存します.  これを"自動保存"（auot-saving）と呼びます.  こ
れは, システムがクラッシュしたときに失ってしまう作業結果をある程度以下
に制限します.

自動保存を実施する時間になるとEmacsは各バッファを調べて, そのバッファ
に自動保存が指定されていて, かつ, 最後に自動保存した以後に変更されてい
る場合は, そのバッファを自動保存します.  実際にファイルを自動保存する
と, エコー領域にメッセージ`Auto-saving...'を表示します.  自動保存の最
中に発生したエラーは捕獲されるので, 打ち込んだコマンドの実行に干渉する
ことはありません.

* Menu:

* Files: Auto Save Files.       The file where auto-saved changes are
                                  actually made until you save the file.
* Control: Auto Save Control.   Controlling when and how often to auto-save.
* Recover::		        Recovering text from auto-save files.



File: emacs-ja, Node: Auto Save Files, Next: Auto Save Control, Prev: Auto Save, Up: Auto Save

自動保存ファイル
----------------

自動保存は, 通常, 訪問先のファイルそのものへは保存しません.  というの
は, 予定の半分を変更しただけでプログラムにまだ一貫性がないのに保存して
しまうのは望ましくないからです.  そのかわりに"自動保存ファイル"と呼ば
れる別のファイルに自動保存し, （`C-x C-s'などで）明示的に保存するよう
指示されたときだけ, 訪問先のファイルに保存します.

通常, 自動保存ファイルの名前は, 訪問先のファイルの名前の前後に`#'を付
加したものです.  したがって, ファイル`foo.c'を訪問したバッファは, ファ
イル`#foo.c#'に自動保存されます.  ファイルを訪問していないほとんどのバッ
ファは, 明示的に指定したときだけ自動保存されます.  それらのバッファの
自動保存ファイルの名前は, バッファ名のまえに`#%', あとに`#'を付けたも
のになります.  たとえば, 送信するメッセージを作成するバッファ`*mail*'
は, `#%*mail*#'というファイルに自動保存されます.  自動保存ファイルの名
前は, Emacsの一部（関数`make-auto-save-file-name'と
`auto-save-file-name-p'）をプログラムし直さない限り, この方法で作られ
ます.  バッファの自動保存に使うファイル名は, そのバッファで自動保存を
オンにしたときに計算されます.

大きなバッファで相当量のテキストを削除したときには, そのバッファの自動
保存を一時的にやめます.  意図せずにテキストを削除してしまった場合には, 
自動保存ファイルに削除してしまったテキストが残っているほうが, 自動保存
ファイルとしてより役に立つからです.  こうなったあとで自動保存をふたた
びオンにするには, `C-x C-s'でバッファを保存するか, `C-u 1 M-x
auto-save'を使います.

訪問先のファイルそのものに自動保存を行いたい場合には, 変数
`auto-save-visited-file-name'に`nil'以外の値を設定します.  こうすると, 
自動保存と明示的な保存には, 何の違いもありません.

訪問先のファイルにバッファを保存すると, バッファの自動保存ファイルは削
除されます.  これを禁止するには, 変数`delete-auto-save-files'に`nil'を
設定します.  `C-x C-w'や`set-visited-file-name'で訪問先ファイル名を変
更すると, 新たな訪問先ファイル名に合わせて自動保存ファイルも改名されま
す.



File: emacs-ja, Node: Auto Save Control, Next: Recover, Prev: Auto Save Files, Up: Auto Save

自動保存の制御
--------------

変数`auto-save-default'が`nil'以外ならば, ファイルを訪問するたびにその
ファイルのバッファの自動保存をオンにします（ただしバッチモードを除
く. *Note Entering Emacs::）.  この変数のデフォルトは`t'なので, 通常, 
ファイルを訪問したバッファは自動保存されます.  コマンド`M-x
auto-save-mode'で, 既存バッファの自動保存をオン／オフできます.  他のマ
イナモードのコマンドと同じように, 正の引数を指定すると`M-x
auto-save-mode'は自動保存をオンにし, 0か負の引数を指定すると自動保存を
オフにし, 引数を指定しないと自動保存のオン／オフを切り替えます.

Emacsは, 最後に自動保存してから何文字打鍵したかに基づいて定期的に自動
保存します.  変数`auto-save-interval'には, 自動保存の間隔を表す文字数
を指定します.  デフォルトは300です.

しばらく打鍵しないでいるときにも自動保存は行われます.  変数
`auto-save-timeout'は, 自動保存（およびガベッジコレクション）を行うま
でにEmacsが待つべき秒数を表します.  （カレントバッファが大きいと, 実際
の時間間隔も長くなる.  これは, 大きなバッファの自動保存には時間がかか
るので, その編集中は邪魔にならないようにするため. ）アイドルのときには, 
自動保存はつぎの2つのことを達成します.  1つは, 端末からしばらく離れて
いるときに, すべての作業結果が保存されることを保証すること.  もう1つは, 
実際に打鍵しているときの自動保存をいくぶんでも避けるようにすることです.

重大なエラーを受け取ったときにも, Emacsは自動保存を行います.  これには,
`kill %emacs'のようなシェルコマンドでEmacsジョブを強制終了した場合や, 
電話回線やネットワーク接続が途切れた場合を含みます.

コマンド`M-x do-auto-save'で, 自動保存の実施を明示的に指示できます.



File: emacs-ja, Node: Recover, Next: File Aliases, Prev: Auto Save Control, Up: Auto Save

自動保存ファイルからのデータ回復
--------------------------------

コマンド`M-x recover-file RET FILE RET'で, 自動保存ファイルの内容から
紛失データを復旧できます.  このコマンドは, FILEを訪問してから, （確認
したあとで）その自動保存ファイル`#FILE#' から内容を回復します.  そのあ
とに, `C-x C-s'でFILEそのものに復旧したテキストを保存します.  たとえば,
`foo.c'の自動保存のファイル`#foo.c#'から`foo.c'を復旧するにはつぎのよ
うにします.

     M-x recover-file RET foo.c RET
     yes RET
     C-x C-s

`M-x recover-file'は確認するまえに, 指定したファイルと自動保存ファイル
が置かれたディレクトリの一覧を表示するので, それらのサイズや日付を比較
できます.  自動保存ファイルのほうが古いと, `M-x recover-file'はそのファ
イルを読み込むようには聞いてきません.

Emacsやコンピュータがクラッシュしても, コマンド`M-x recover-session'を
使えば, 編集中だったすべてのファイルを自動保存ファイルから復旧できます. 
このコマンドは, まず, 記録されている中断されたセッション一覧を表示しま
す.  希望する箇所へポイントを移動し, `C-c C-c'と打ちます.

つぎに, `recover-session'はそのセッションで編集中だった各ファイルにつ
いてそのファイルを復旧するか聞いてきます.  `y'を答えると,
`recover-file'を呼び出し, 普通のとおりに動作します.  もとのファイルと
その自動保存ファイルの日付を表示し, ファイルを復旧するかどうかをもう一
度聞いてきます.

`recover-session'が終了すると, 復旧を選んだファイルはEmacsバッファに入っ
ています.  これらのバッファを保存してください.  こうすることで初めてファ
イルに保存できます.

中断されたセッションは, あとで復旧するために`~/.saves-PID-HOSTNAME'と
いうファイルに記録されています.  これらの名前の`~/.saves'の部分は,
`auto-save-list-file-prefix'の値です.  この変数を個人の`.emacs'ファイ
ルで設定すれば, 別の場所にセッション記録を置くことができます.  しかし, 
同様に`recover-session'も再定義して, 変更した新しい場所を探すようにす
る必要があります.  個人の`.emacs'ファイルで
`auto-save-list-file-prefix'に`nil'を設定すると, 復旧のためのセッショ
ンを記録しません.



File: emacs-ja, Node: File Aliases, Next: Version Control, Prev: Auto Save, Up: Files

ファイル名の別名
================

シンボリックリンクやハードリンクを使うことで, 同じファイルをいくつかの
異なるファイル名で指すことができます.  ハードリンクは, ファイルを直接
に指している別の名前です.  すべての名前は等しく有効で, それらに優劣は
ありません.  対照的に, シンボリックリンクは定義された別名の一種です.
`foo'が`bar'へのシンボリックリンクであるとき, どちらの名前でもファイル
を指せますが, `bar'が本当の名前であり, `foo'は別名にすぎません.  シン
ボリックリンクがディレクトリを指しているときには, より複雑な状況になり
ます.

同一のファイルに対して2つの名前で訪問すると, Emacsは通常2つの別々のバッ
ファを作成しますが, その状況を警告します.

同一のファイルを異なる名前で別々のバッファに訪問することを避けたいなら
ば, 変数`find-file-existing-other-name'に`nil'以外の値を設定します. 
そうすれば, どのファイル名を指定しようとも, `find-file'はファイルを訪
問している既存のバッファを使います.

変数`find-file-visit-truename'が`nil'以外であれば, バッファに記録する
ファイル名は, ユーザーが指定した名前ではなくて, ファイルの（すべてのシ
ンボリックリンクをその先の名前に置き換えて得られる）"実名"になります.
`find-file-visit-truename'を設定すると,
`find-file-existing-other-name'も暗に設定されます.



File: emacs-ja, Node: Version Control, Next: Directories, Prev: File Aliases, Up: Files

VC（版管理, バージョンコントロール）
====================================

"版管理システム"は, ファイルの変更されていない部分を通常は一度だけ格納
して, ソースファイルの複数の版を記録できるパッケージです.  版管理シス
テムは, 各版の作成時刻, 作成者, その版の変更部分に関する記述などの履歴
情報も記録します.

Emacsの版管理パッケージはVCと呼ばれます.  このコマンドは, 3つの版管理
システム, RCS, CVS, SCCSで動作します.  GNUプロジェクトでは, フリーソフ
トウェアでありFree Software Foundationから入手できるRCSとCVSを推奨しま
す.

* Menu:

* Introduction to VC::  How version control works in general.
* VC Mode Line::     How the mode line shows version control status.
* Basic VC Editing::    How to edit a file under version control.
* Old Versions::        Examining and comparing old versions.
* Secondary VC Commands::    The commands used a little less frequently.
* Branches::            Multiple lines of development.
* Snapshots::           Sets of file versions treated as a unit.
* Miscellaneous VC::    Various other commands and features of VC.
* Customizing VC::      Variables that change VC's behavior.



File: emacs-ja, Node: Introduction to VC, Next: VC Mode Line, Prev: Version Control, Up: Version Control

VC入門
------

VCはEmacsから版管理システムを使えるようにして, 編集作業を版管理操作に
滑らかに統合します.  VCは統一された版管理インターフェイスを提供するの
で, どの版管理システムを使っているかに関わらず, 同じ使い方ができます.

本節では, 版管理を概観するとともに, VCが扱う版管理システムの概要を説明
します.  使用する版管理システムにすでに慣れているならば, 本節は読み飛
ばしてください.

* Menu:

* Version Systems::  Supported version control back-end systems.
* VC Concepts::      Words and concepts related to version control.



File: emacs-ja, Node: Version Systems, Next: VC Concepts, Prev: Introduction to VC, Up: Introduction to VC

利用可能な版管理システム
........................

VCでは, 現在3つの版管理システム, つまり, バックエンドで動作します.
RCS, CVS, SCCSの3つです.

RCSはフリーの版管理システムでFree Software Foundationから入手ができま
す.  RCSは, 扱えるバックエンドの中では, たぶん, もっとも成熟したもので
す.  VCコマンド群は, RCSに概念的にもっとも近いものです.  RCSでできるほ
とんどのことはVCからもできます.

CVSは, RCSの上に作られてRCSの機能を拡張していて, より洗練されたリリー
ス管理, 複数ユーザーの並行開発を許しています.  CVSの下では, VCの基本的
な編集操作を使えますが, あまり一般的でない操作に関しては, コマンド行か
らCVSを呼ぶ必要があります.  CVSを使うには保管庫（リポジトリ,
repository）を設定しなければなりませんが, ここで扱うには複雑すぎる話題
です.

SCCSはフリーではありませんが, 版管理システムとしては広く使われています. 
能力の観点からすれば, VCが扱える3つのうちでもっとも弱いです.  SCCSに欠
けている機能（たとえばスナップショット）はVC自身で実現して補っています
が, 複数の枝分かれのようなVCの他のいくつかの機能はSCCSでは利用できませ
ん.  RCSを使えない理由があるときに限ってSCCSを使うべきです.



