Info file: emacs-ja,    -*-Text-*-
produced by `texinfo-format-buffer'
from file `emacs.texi'
using `texinfmt.el' version 2.38 of 3 July 1998.


Emacs 20.6版対応に改訂した`GNU Emacs Manual' 13版です.

INFO-DIR-SECTION Editors
START-INFO-DIR-ENTRY
* Emacs: (emacs).	The extensible self-documenting text editor.
END-INFO-DIR-ENTRY


Published by the Free Software Foundation 59 Temple Place, Suite 330
Boston, MA 02111-1307 USA

Copyright (C) 1985, 1986, 1987, 1993, 1994, 1995, 1996, 1997, 1998,
1999 Free Software Foundation, Inc.

Permission is granted to make and distribute verbatim copies of this
manual provided the copyright notice and this permission notice are
preserved on all copies.

Permission is granted to copy and distribute modified versions of this
manual under the conditions for verbatim copying, provided also that
the sections entitled "The GNU Manifesto", "Distribution" and "GNU
General Public License" are included exactly as in the original, and
provided that the entire resulting derived work is distributed under
the terms of a permission notice identical to this one.

Permission is granted to copy and distribute translations of this
manual into another language, under the above conditions for modified
versions, except that the sections entitled "The GNU Manifesto",
"Distribution" and "GNU General Public License" may be included in a
translation approved by the Free Software Foundation instead of in the
original English.





File: emacs-ja, Node: VC Concepts, Next: VC Mode Line, Prev: Version Systems, Up: Introduction to VC

VCの概念
........

ファイルが版管理の管理下にあるとき, そのファイルは版管理システムに"登
録され"ているといいます.  各登録されたファイルには, ファイルの現状とそ
の変更履歴を記述した対応する"マスタファイル"が存在します.  この情報は, 
現在の版や以前の版を再構成するのに十分です.  通常, マスタファイルには, 
それぞれの版について, その版の変更点を言葉で記述した"記録項目"も記録さ
れています.

版管理の下で管理されているファイルを, そのマスタファイルに対応する"作
業ファイル"と呼ぶこともあります.  普通のファイルと同様に, 作業ファイル
を編集して変更します.  （SCCSやRCSでは, ファイルを編集するまえにファイ
ルを"ロック" (1) (*Note VC Concepts-Footnotes::) する必要がある. ）一
連の変更を終えたら, ファイルを"チェックイン", つまり, 記録項目とともに
変更をマスタファイルに記録します.

CVSでは, 1つのマスタファイルに対応する作業ファイルを複数個持てます. 
しばしば, 各ユーザーが1個ずつ作業ファイルを持てます.  RCSでもこのよう
にできますが, RCSの通常の使い方ではありません.

典型的な版管理システムには, 複数のユーザーが同じファイルを使う際の調停
を行うためのなんらかの機構が必要です.  1つの方法は（Emacsが同時編集の
検出に使うロックに類似だが, それとは別の）"ロック"を使うことです.  別
の方法は, ファイルをチェックインする時点で, 他人の変更分を併合すること
です.

ロックを使う版管理の場合, 作業ファイルは変更できないように通常は読み出
し専用です.  版管理システムに対して, 書き込み可能な作業ファイルを作り, 
それをロックするように要求します.  一度には1人のユーザーだけがこれをで
きます.  自分の変更分をチェックインすると, ファイルのロックを外し, 作
業ファイルをふたたび読み出し専用にします.  これにより, 他のユーザーが
さらに変更するためにファイルをロックできるようになります.  SCCSはつね
にロックを使いますし, RCSも通常はロックを使います.

RCSでは別の方法もあって, 各ユーザーがいつでも作業ファイルを変更できま
す.  このモードではロックは必要ありませんが, 使うこともできます.  新版
を記録する方法は, やはりチェックインです.

CVSでは, 通常, 各ユーザーはいつでも各自の作業ファイルを変更できますが, 
チェックイン時に他のユーザーの変更分を併合する必要があります.  しかし,
CVSでもロックを使うようにもできます（*Note Backend Options::）.


File: emacs-ja  Node: VC Concepts-Footnotes, Up: VC Concepts

(1) 【訳注】Emacsが同時編集を防ぐためのロックとは別のロック.



File: emacs-ja, Node: VC Mode Line, Next: Basic VC Editing, Prev: Introduction to VC, Up: Version Control

VCとモード行
------------

版管理の下にあるファイルを訪問すると, Emacsはそのことをモード行に示し
ます.  たとえば, `RCS-1.3'は, そのファイルにはRCSが使われていて, 現在
の版が1.3であることを表します.

バックエンドの名前と版番号のあいだの文字は, ファイルの版管理状態を示し
ます.  `-'は, （ロックを使っているのであれば）作業ファイルがロックされ
ていないこと, あるいは, （ロックを使っていないのであれば）ファイルが変
更されていないことを表します.  `:'は他のユーザー（たとえば, `jim'）が
ロックしていることを表し, `RCS:jim:1.3'のように表示されます.



File: emacs-ja, Node: Basic VC Editing, Next: Old Versions, Prev: VC Mode Line, Up: Version Control

VC下の基本的な編集
------------------

主要なVCコマンドは, 状況に応じてロックかチェックインを行う汎用コマンド
です.

`C-x C-q'
`C-x v v'
     このファイルに対して論理的なつぎの版管理操作を実施する.

正確にいえば, この操作を行うコマンドは`vc-next-action'であって, `C-x v
v'にバインドしてあります.  しかし, `C-x C-q'の通常の意味は, 読み出し専
用バッファを書き込み可能にするか, あるいは, その逆を行います.  この操
作を, 適切な版管理操作を実施することで版管理下で管理されているファイル
に対しても同じことを正しく行うように拡張したのです.  登録されたファイ
ルに対して`C-x C-q'を打つと, `C-x v v'のように動作します.

このコマンドの正確な動作は, ファイルの状態と版管理システム（バックエン
ド）がロックを使うかどうかに依存します.  SCCSとRCSは通常はロックを使い
ますが, CVSは通常はロックを使いません.

* Menu:

* VC with Locking::     RCS in its default mode, SCCS, and optionally CVS.
* Without Locking::     Without locking: default mode for CVS.
* Log Buffer::          Features available in log entry buffers.
               


File: emacs-ja, Node: VC with Locking, Next: Without Locking, Prev: Basic VC Editing, Up: Basic VC Editing

ロック使用時の基本的な編集
..........................

（SCCSの場合とRCSのデフォルトの場合）ファイルに対してロックを使う場合,
`C-x C-q'は, ファイルをロックする, あるいは, ファイルをチェックインす
るのいずれかを行います.

   * ファイルがロックされていなければ, `C-x C-q'はそれをロックし, 変更
     できるように書き込み可能にする.

   * 同じユーザーがファイルをロックしていて, かつ, 変更されていれば,
     `C-x C-q'はチェックインを行う.  このとき, 新版に対する記録項目を
     まず読み取る.  *Note Log Buffer::.

   * 同じユーザーがファイルをロックしているが, ロックしてからまったく
     変更していないときには, `C-x C-q'はロックを外してファイルをふたた
     び読み出し専用にする.

   * 他のユーザーがファイルをロックしている場合, `C-x C-q'はそのユーザー
     から『ロックを横取りする』かどうか聞いてくる.  横取りするように答
     えると, ファイルをロックし直すが, まえにロックしていたユーザーに
     はロックを横取りされたことを伝える.

以上の規則は, CVSでロックを使用している場合にも適用できますが, 『ロッ
クを横取りする』ことはありません.



File: emacs-ja, Node: Without Locking, Next: Log Buffer, Prev: VC with Locking, Up: Basic VC Editing

ロック非使用時の基本的な編集
............................

CVSのデフォルトのように, ロックを使わないときには, 作業ファイルはいつ
でも書き込み可能です.  ファイルを編集するまえにすべきことは何もありま
せん.  モード行の状態表示は, ファイルが変更されていなければ`-'です. 
作業ファイルに変更を保存するとただちに`:'に変わります.

以下は, CVSを使っているときの`C-x C-q'の動作です.

   * 他のユーザーが変更分をマスタファイルにチェックインしていると, そ
     れらを自分用の作業ファイルに併合（*Note Merging::）するかどうか聞
     いてくる.  自分の変更分をチェックインするまえには, これを行う必要
     がある.

   * マスタファイルに新たな変更がなくても, 自分用の作業ファイルを変更
     してある場合には, `C-x C-q'はその変更をチェックインする.  これを
     行うために, 新版に対する記録項目をまず読み取る.  *Note Log
     Buffer::.

   * ファイルが変更されていなければ, `C-x C-q'は何もしない.

以上の規則は, RCSのロックを使わないモードにも適用できますが, マスタファ
イルから自動的に変更を併合する機能は実装してありません.  残念なことに, 
あなたが編集を始めたあとに, 他のユーザーが同じファイルに変更をチェック
インしても何も警告されないのです.  しかも, このような事態が発生すると, 
あなたが自分の版をチェックインしたときに, そのユーザーの変更は実質的に
は取り除かれてしまいます（とはいえ, マスタファイルの中には残っているの
で, 完全になくなるわけではない）.  したがって, 自分の変更をチェックイ
ンするまえには, 現在の版が変更されていないことを確認する必要があります.
Emacsの将来の版では, このような危険性を取り除き, RCSでも自動併合を行え
るように考えています.

また, このモードでもRCSのロックを使えますが, 必須ではありません.  ファ
イルを変更していないときに`C-x C-q'を使うと, RCSの通常の（ロックを使う）
モードのように, ファイルをロックします.



File: emacs-ja, Node: Log Buffer, Next: Old Versions, Prev: Without Locking, Up: Basic VC Editing

記録項目用バッファの機能
........................

変更をチェックインすると, `C-x C-q'は記録項目をまず読みます.  記録項目
を入力するように, `*VC-Log*'というバッファを立ち上げます.  入力し終え
たら, `*VC-Log*'で`C-c C-c'と打ちます.  実際にチェックインを行うと, こ
のように行われます.

チェックインをアボートするには, そのバッファでは`C-c C-c'を打た*ない*
でください.  別のバッファに切り替えて, 別の編集をします.  別のファイル
をチェックインしようとしない限り, 入力していた記録項目は`*VC-Log*'バッ
ファに残っていますから, チェックインを完了するため, いつでもそのバッファ
に戻れます.

複数のソースファイルを同じ理由で変更したときには, 多くのファイルに同じ
記録項目を指定できると便利です.  こうするには, まえの記録項目の履歴を
使います.  コマンド, `M-n', `M-p', `M-s', `M-r'は, ミニバッファの履歴
コマンドのように働きます（ただし, これらのコマンドはミニバッファの外部
で使う）.

ファイルにチェックインするたびに, 記録項目用バッファはVC記録（vc-log）
モードになります.  このモードは2つのフック, `text-mode-hook'と
`vc-log-mode-hook'を起動します.  *Note Hooks::.



File: emacs-ja, Node: Old Versions, Next: Secondary VC Commands, Prev: Basic VC Editing, Up: Version Control

旧版の調査と比較
----------------

版管理の便利な機能の1つは, ファイルの任意の版を調べたり, 2つの版を比較
できることです.

`C-x v ~ VERSION RET'
     訪問しているファイルの版VERSIONをそれ専用のバッファで調べる.

`C-x v ='
     カレントバッファの内容とファイルのチェックインした最新版とを比較
     する.

`C-u C-x v = FILE RET OLDVERS RET NEWVERS RET'
     FILEの指定した2つの版を比較する.

`C-x v g'
     表示色を変えてCVSの注記コマンドの結果を表示する.

1つの旧版を調べるには, ファイルを訪問して`C-x v ~ VERSION RET' 
（`vc-version-other-window'）と打ちます.  これにより, ファイルの版
VERSIONのテキストを`FILENAME.~VERSION~'という名前のファイルに収め, 別
のウィンドウのそれ専用のバッファでそのファイルを訪問します.  （RCSでは, 
旧版を選択して, それから枝分かれを作成できる.  *Note Branches::. ）

しかし通常は, コマンド`C-x v ='（`vc-diff'）でファイルの2つの版を比較
したほうが, もっと便利です.  引数を指定しない`C-x v ='では, カレントファ
イルの内容（必要があればファイルに保存する）とファイルのチェックインし
てある最新版とを比較します.  数引数を指定した`C-u C-x v ='では, ファイ
ル名と2つの版番号を読み取ってから, 指定したファイルの2つの版を比較しま
す.

登録したファイルのかわりにディレクトリ名を指定すると, このコマンドは, 
そのディレクトリとその下にあるサブディレクトリに置かれているすべての登
録されたファイルの指定した2つの版を比較します.

チェックインしてある版は, その番号で指定します.  入力が空だと, （チェッ
クインしてある版とは異なるかもしれない）作業ファイルの現在の内容を指定
します.  版番号のかわりに, スナップショット名（*Note Snapshots::）を指
定することもできます.

このコマンドは, 変数`diff-switches'で指定されるオプションを用いて,
`diff'プログラムを実行して動作します.  その出力は別のウィンドウの特別
なバッファに表示されます.  `M-x diff'コマンドと違って, `C-x v ='では新
版と旧版の相違箇所には移動できません.  というのは, 通常, 一方の版, あ
るいは, 両方の版は, 比較するときにはファイルとしては存在していないから
です.  それらは, マスタファイルの記録の中に存在するだけです.  `M-x
diff'についてより詳しくは, *Note Comparing Files::.

CVSで管理しているファイルに関しては, 一目でわかるように複数の表示色を
使って, CVS注記コマンドの結果を表示できます.  これには, `M-x
vc-annotate'を使います.  赤は新版, 青は旧版, それらの中間色は中間の版
を表します.  数引数Nは, 時間尺度を伸ばします.  つまり, ある表示色で表
す期間をN倍します.



File: emacs-ja, Node: Secondary VC Commands, Next: Branches, Prev: Old Versions, Up: Version Control

VCの副次的なコマンド
--------------------

本節では, VCの副次的なコマンドを説明します.  1日に一度くらい使うような
コマンドです.

* Menu:

* Registering::         Putting a file under version control.
* VC Status::           Viewing the VC status of files.
* VC Undo::             Cancelling changes before or after check-in.
* VC Dired Mode::       Listing files managed by version control. 
* VC Dired Commands::   Commands to use in a VC Dired buffer.



File: emacs-ja, Node: Registering, Next: VC Status, Prev: Secondary VC Commands, Up: Secondary VC Commands

VCへのファイル登録
..................

ファイルを訪問してから`C-x v i'（`vc-register'）と打つだけで, 
ファイルを版管理の管理下に置けます. 

`C-x v i'
     訪問したファイルを版管理に登録する.

ファイルを登録するには, Emacsはそのファイルに対してどの版管理システム
を使うか選ぶ必要があります.  `vc-default-back-end'に, `RCS', `CVS',
`SCCS'のいずれかを設定すれば, 明示的に指定できます.  あるいは, `RCS',
`SCCS', `CVS'という名前のサブディレクトリがあるなら, Emacsは対応する版
管理システムを使います.  指定がまったくなければ, デフォルトでは, RCSが
インストールされていればRCS, さもなければSCCSを選びます.

ロックを使用している場合には, `C-x v i'は, ファイルのロックを解除し読
み出し専用にします.  ファイルの編集を始めたい場合には, `C-x C-q'と打ち
ます.  CVSにファイルを登録したあとでは, `C-x C-q'と打って最初の版を記
録する必要があります.

新しく登録されたファイルの最初の版番号は, デフォルトでは1.1です.  異な
るデフォルトを指定するには, 変数`vc-default-init-version'に設定します. 
あるいは, `C-x v i'に数引数を指定すると, そのファイルだけに使う最初の
版番号をミニバッファで読みます.

`vc-initial-comment'が`nil'以外ならば, `C-x v i'はこのソースファイルの
目的を記した初期コメントを読みます.  これは記録項目（*Note Log
Buffer::）を読むのと同じように動作します.



File: emacs-ja, Node: VC Status, Next: VC Undo, Prev: Registering, Up: Secondary VC Commands

VC状態表示コマンド
..................

`C-x v l'
     版管理の状態と変更履歴を表示する.

ファイルの詳しい版管理状態や履歴を見るには, `C-x v l'（`vc-print-log'）
と打ちます.  記録項目を含めてカレントファイルの変更履歴を表示します. 
出力は別のウィンドウに表示されます.



File: emacs-ja, Node: VC Undo, Next: VC Dired Mode, Prev: VC Status, Up: Secondary VC Commands

版管理操作のアンドゥ
....................

`C-x v u'
     バッファとファイルを最新のチェックインしてある版に復元する.

`C-x v c'
     訪問先ファイルのマスタファイルに最後に入れた変更を取り除く.  つま
     り, 最後のチェックインをアンドゥする.

これまでの一連の変更を破棄してチェックインしてある最新版へ復元したいと
きは, `C-x v u'（`vc-revert-buffer'）を使います.  ロックを使用している
ときには, ファイルのロックを解除するので, 変更を始めるまえにまずファイ
ルをロックし直す必要があります.  チェックインした最新版から変更してい
ないと判断できない限り, `C-x v u'は確認を求めてきます.

`C-x v u'は, ファイルをロックしたけれどもやはりファイルを変更しないと
決めたときに, ロックを解除するコマンドでもあります.

すでにチェックインしてしまった変更を取り消すには, `C-x v c'
（`vc-cancel-version'）を使います.  このコマンドは, チェックインした最
新版のすべての記録を捨てさります.  さらに, `C-x v c'は, 作業ファイルと
バッファを以前の版（捨てた最新版の1つまえの版）に復元するかどうか聞い
てきます.

`no'と答えると, VCはバッファでの変更を保持してファイルもロックしたまま
にします.  チェックインした変更に明らかなまちがいがあるとわかったとき
に, この「復元しない」という選択肢は便利です.  誤りを含んだチェックイ
ンを取り消し, 誤りを訂正してから, 改めてファイルをチェックインできます.

`C-x v c'がバッファを復元しないときには, そのかわりに, バッファ内のす
べての版管理ヘッダの展開形をもとの形に戻します（*Note Version
Headers::）.  なぜなら, バッファはもはや既存のどの版にも対応しないから
です.  ふたたびチェックインすると, チェックインの過程で, 新たな版番号
として正しくヘッダを展開します.

しかしながら, RCSの`$Log$'ヘッダを
自動的にもとの形に戻すことは不可能です. 
このヘッダの機能を使うなら, 取り消した版に対応する項目を削除することで, 
もとの形に手で戻す必要があります. 

多くの作業結果を簡単に失ってしまうので, `C-x v c'を起動するときには十
分注意してください.



File: emacs-ja, Node: VC Dired Mode, Next: VC Dired Commands, Prev: VC Undo, Up: Secondary VC Commands

VC下のdired
...........

大きなプログラムを扱っているときは, ディレクトリの木構造全体の中でどの
ファイルが変更されたのかを調べたり, 版管理の下に置かれているすべてのファ
イルの状態を一度に見られると便利です.  コマンド`C-x v d'
（`vc-directory'）を使えば, 版管理に関連したファイルだけを含んだディレ
クトリ一覧を作れます.

`C-x v d'は, VC diredモードを使うバッファを作ります.  これは, 普通の
diredバッファ（*Note Dired::）にそっくりですが, （ロックされていたり, 
未更新の）注意を払うべきファイルだけを通常は表示します.  これを"簡素な
表示"と呼びます.  変数`vc-dired-terse-display'に`nil'を設定すると, VC
diredは, 関連するすべてのファイル, つまり, 版管理の下に置かれたファイ
ルとすべてのサブディレクトリを表示します（"完全な表示"）.  VC diredバッ
ファのコマンド`v t'は, 簡素な表示と完全な表示を切り替えます.  （*Note
VC Dired Commands::. ）

デフォルトでは, VC diredは, 指定したディレクトリやそれより下に置かれた
注意を払うべきファイルや関連するファイルの再帰的な一覧を作ります.  こ
の動作を変えるには, 変数`vc-dired-recurse'に`nil'を設定します.  すると,
VC diredは, 指定したディレクトリにあるファイルだけを表示します.

各ファイルを表す行には, ハードリンク数, 所有者, グループ, ファイルサイ
ズのかわりに版管理状態があります.  ファイルが変更されていなければ, つ
まり, マスタファイルの内容に同期しているならば, 版管理状態は空です. 
そうでなければ, 括弧で括ったテキストになります.  RCSとSCCSでは, ファイ
ルをロックしているユーザーの名前が示されます.  CVSでは, cvs状態（`cvs
status'）を簡略化したものが示されます.  つぎは, RCSを使っている場合の
例です.

       /home/jim/project:

       -rw-r--r-- (jim)      Apr  2 23:39 file1
       -r--r--r--            Apr  5 20:21 file2

ファイル, `file1'と`file2'が, 版管理の下に置かれていて, `file1'はユー
ザーjimがロックしていて, `file2'はロックされていません.

つぎは, CVSを使っている場合の例です.

       /home/joe/develop:

       -rw-r--r-- (modified) Aug  2  1997 file1.c
       -rw-r--r--            Apr  4 20:09 file2.c
       -rw-r--r-- (merge)    Sep 13  1996 file3.c

保管庫のものに比べて, `file1.c'は変更されていますが, `file2.c'は変更さ
れていません.  `file3.c'も変更されていますが, 保管庫には他の変更がチェッ
クインされています.  `file3.c'をチェックインするまえに, それらの変更を
併合する必要があります.

VC diredで（『完全な表示』のときに）サブディレクトリを表示するときには, 
版管理の下には絶対に置かれないものは省略します.  デフォルトでは, `RCS'
や`CVS'などのVCのサブディレクトリが含まれます.  これは, 変数
`vc-directory-exclusion-list'を設定してカスタマイズできます.

普通のdiredのように, `C-u C-x v d'と打てば, `ls'プログラムに渡す追加オ
プションを指定して, VC diredの出力書式を微調整できます.



File: emacs-ja, Node: VC Dired Commands, Next: Branches, Prev: VC Dired Mode, Up: Secondary VC Commands

VC diredコマンド
................

VC diredモードでも, 通常のdiredコマンドはすべて普通に動作しますが, `v'
は例外で, 版管理プレフィックスとして再定義してあります.  `vc-diff'や
`vc-print-log'のようなVCコマンドは, `v ='や`v l'いうように打てば起動で
きます.  これらのコマンドの多くは, 現在行のファイルに作用します.

コマンド`v v'（`vc-next-action'）は, 印を付けたすべてのファイルに作用
するので, 複数のファイルを一度にロックしたりチェックインしたりできます. 
複数のファイルに作用する場合, 各ファイルの現状に応じて個別に扱います. 
つまり, あるファイルはロックしたり, 別のファイルはチェックインしたりし
ます.  これは混乱の原因かもしれません.  同じ状態の一連のファイルに印を
付けて, 混乱を防止するのはユーザーの責任です.

ファイルをチェックインするときには, `v v'は1つの記録項目を読んで, それ
をチェックインするすべてのファイルに使います.  これは, 同じ変更に属す
る一連のファイルを一度にチェックインする場合に便利です.

`v t'（`vc-dired-toggle-terse-mode'）と打てばいつでも, （ロックされて
いたり, 内容が未更新のものだけを表示する）簡素な表示と完全な表示とを切
り替えられます.  特別なコマンド`* l'（`vc-dired-mark-locked'）もありま
す.  これは現在ロックされている（CVSの場合には, 内容が未更新である）す
べてのファイルに印を付けます.  つまり, 現在ロックされいるもの以外のす
べてのファイルをバッファから削除する別の方法は, `* l t k'と打つことで
す.



File: emacs-ja, Node: Branches, Next: Snapshots, Prev: Secondary VC Commands, Up: Version Control

ファイルの複数の枝分かれ
------------------------

版管理の用途の1つは, ファイルの複数の『現在』版を維持することです.  た
とえば, さまざまな完了していない新しい機能を徐々に付け加えているプログ
ラムの異なる版を持つかもしれません.  そういった開発の独立した流れを"枝
"（branch）と呼びます.  VCでは, 枝を作ったり, 別の枝へ切り替えたり, 2
つの枝を併合したりできます.  しかし, 今のところ, RCSだけで枝を使えるこ
とに注意してください.

ファイルの開発の主要な流れを"幹"（trunk）と呼びます.  幹にある版は, 普
通, 1.1, 1.2, 1.3, …と番号が付けられます.  そのような版のどれからでも, 
独立した枝を始めることができます.  版1.2から始まる枝の版番号は1.2.1.1
となり, 同じ枝の後続の版番号は1.2.1.2, 1.2.1.3, 1.2.1.4, …となります. 
版1.2から始まる別の枝があれば, それらの版番号は, 1.2.2.1, 1.2.2.2,
1.2.2.3, …となります.

版番号の最後の要素を省略したものを"枝番号"と呼びます.  これは, その枝
にある版の中でもっとも大きい番号の版, "先頭版"を指します.  まえの例の
枝は, 枝番号1.2.1と1.2.2です.

* Menu:

* Switching Branches::    How to get to another existing branch.
* Creating Branches::     How to start a new branch.
* Merging::               Transferring changes between branches.
* Multi-User Branching::  Multiple users working at multiple branches 
                            in parallel.



File: emacs-ja, Node: Switching Branches, Next: Creating Branches, Prev: Branches, Up: Branches

枝の切り替え
............

枝を切り替えるには, `C-u C-x C-q'と打ってから, 選択したい版番号を指定
します.  その版を*ロックしない*（書き込み不可）で訪問するので, ロック
するまえに調べることができます.  このような枝の切り替えが可能なのは, 
ファイルがロックされていない場合に限ります.

枝の中での版番号を省略して枝番号だけを指定できます.  すると, その枝の
先頭版を選ぶことになります.  RETだけを打つと, Emacsは幹の上のもっとも
大きい版を選びます.

（幹を含む）どれかの枝へ切り替えたあとでは, 明示的に他の枝を選択するま
で, それ以降のVCコマンドはその枝を使います.



File: emacs-ja, Node: Creating Branches, Next: Merging, Prev: Switching Branches, Up: Branches

新しい枝の作成
..............

先頭版（枝の中にある最新版）から新たな枝を作るには, 必要ならまずその版
を選択してから, `C-x C-q'でそれをロックし, 必要な変更を施します.  そし
て, 変更をチェックインするときに, `C-u C-x C-q'を使います.  このコマン
ドでは, 新版に対する版番号を指定できます.  現在の版から始まる枝として
適切な番号を指定する必要があります.  たとえば, 現在の版が2.5ならば, そ
の時点で存在する枝の数に依存しますが, 枝番号は, 2.5.1, 2.5.2, …です.

旧版（先頭版ではないもの）から新しい枝を作るには, その版をまず選択して
から（*Note Switching Branches::）, それを`C-x C-q'でロックします.  旧
版をロックすると, 本当に新しい枝を作るのかどうか確認してきます.  noで
答えると, かわりに, 最新版をロックするかどうか聞いてきます.

変更してから, ふたたび`C-x C-q'と打って新版にチェックインします.  こう
すると選択した版から始まる新しい枝を自動的に作ります.  新しい枝を特に
指定する必要はありません.  なぜなら, 枝の先頭版でないところに新版を付
け加える唯一の方法だからです.

枝を作ったあとでは, その枝に『留まり』ます.  つまり, それ以降にチェッ
クインすると, その枝に新版が作られます.  枝を去るには, `C-u C-x C-q'で
明示的に別の版を選ぶ必要があります.  ある枝から別の枝へ変更を移すには, 
次節で説明する併合コマンドを使ってください.



File: emacs-ja, Node: Merging, Next: Multi-User Branching, Prev: Creating Branches, Up: Branches

枝の併合
........

ある枝で変更を完了したときには, それらの変更をファイルの開発の主流（幹）
に取り込みたいことがしばしばあるでしょう.  これは簡単な操作ではありま
せん.  というのは, 幹でも開発は進行しているので, 別の向きに変更されて
いるファイルに変更を"併合"する必要があるからです.  VCでは, `vc-merge'
コマンドで併合（とそれ以外のことも）できます.

`C-x v m (vc-merge)'
     作業ファイルに変更を併合する.

`C-x v m'（`vc-merge'）は, 一連の変更を作業ファイルの現在の版に併合し
ます.  このコマンドはまず, ミニバッファで枝番号か2つの版番号を読み取り
ます.  そして, その枝での変更, あるいは, 指定した2つの版のあいだの変更
を調べ, それらをファイルの現在の版に併合します.

例として, 枝1.3.1である機能を実装し終えたとしましょう.  この間, 幹でも
開発が進んでいて版1.5になっています.  枝での変更を幹に併合するには, ま
ず, `C-u C-x C-q RET'と打って, 幹の先頭版へ行きます.  版1.5が現在の版
になります.  ファイルのロックを使っている場合には, `C-x C-q'と打って, 
版1.5をロックして変更できるようにします.  続いて`C-x v m 1.3.1 RET'と
打ちます.  すると, 枝1.3.1での（枝の開始点である版1.3から枝の中にある
最新版までの）一連の変更を取り出して, それらを作業ファイルの現在の版に
併合します.  ここで, 変更された作業ファイルをチェックインできます.  つ
まり, 枝での変更を取り込んだ版1.6を作れるのです.

チェックインするまえに, 枝から併合したあとにさらに編集することも可能で
す.  しかし, 併合した版をチェックインしたあとで, ロックしてさらに編集
するのが, 普通は賢いやり方です.  こうすれば, 変更履歴をよりよく記録に
残せます.

すでに修正されているファイルに変更を併合するときには, 変更が重複する場
合があります.  この状況を"矛盾"と呼びます.  矛盾した変更の辻褄を合わせ
ることを"矛盾の解消"と呼びます.

併合中に矛盾が起こると, VCはこれらを検出し, それらをエコー領域に表示し
てユーザーに伝え, 併合を補佐してほしいかどうか聞いてきます.  yesで答え
ると, ediffセッションを開始します（*Note Ediff: (ediff)Top..）.

noで答えると, 矛盾する変更はどちらも"矛盾印"で囲ってファイルに挿入しま
す.  矛盾する部分は, 下の例のようになります.  作業ファイルの名前は
`name'であり, ユーザーBの変更を収めたマスタファイルの版は1.11です.

     <<<<<<< name
       USER A'S VERSION
     =======
       USER B'S VERSION
     >>>>>>> 1.11

この矛盾を解消するようにファイルを手で編集できます.  あるいは, ファイ
ルを訪問してから`M-x vc-resolve-conflicts'と打ちます.  すると上に述べ
たediffセッションを開始します.



File: emacs-ja, Node: Multi-User Branching, Next: Snapshots, Prev: Merging, Up: Branches

複数ユーザーの枝
................

ファイルの異なる枝上で同時に複数の開発者が作業すると有益なことがしばし
ばあります.  CVSでは, デフォルトで, これができます.  RCSでは, 複数のソー
スディレクトリを作れば可能です.  RCSのマスタファイルを置いた共通のディ
レクトリを指す`RCS'という名前のリンクを各ソースディレクトリに置きます. 
こうすれば, 各ソースディレクトリでは, それぞれ独自に版を選択できます. 
しかし, 同じ共通のRCSレコードをすべてで共有します.

ソースファイルにRCSの版管理ヘッダ（*Note Version Headers::）が入ってい
れば, この技法は信頼性があり自動的に動作します.  ヘッダにより, Emacsは
いつでも作業ファイルに入っている版番号がわかります.

ファイルに版管理ヘッダが入っていないときには, 各セッションごとにどの枝
で作業しているかをEmacsに明示する必要があります.  こうするには, ファイ
ルを訪問してから, `C-u C-x C-q'と打ち, 正しい枝番号を指定します.  これ
により, 編集セッションではどの枝を操作しているかをEmacsが知っているこ
とを保証します.



File: emacs-ja, Node: Snapshots, Next: Miscellaneous VC, Prev: Branches, Up: Version Control

スナップショット
----------------

"スナップショット"とは, ファイルの版（登録されたファイルそれぞれに1つ
ずつ）の集合に名前を付けたもので, 一塊として扱うことができます.  スナッ
プショットの重要な種類の1つは, "リリース"です.  これは, ユーザーへ配布
する準備が整ったシステムの（理論的には）安定した版のことです.

* Menu:

* Making Snapshots::		The snapshot facilities.
* Snapshot Caveats::		Things to be careful of when using snapshots.



File: emacs-ja, Node: Making Snapshots, Next: Snapshot Caveats, Prev: Snapshots, Up: Snapshots

スナップショットの作成と使用
............................

スナップショットに対しては, 基本的なコマンドが2つあります.  1つは名前
を指定してスナップショットを作り, もう1つは指名したスナップショットを
取り出すことです.

`C-x v s NAME RET'
     カレントディレクトリやその下に置いてある登録されたファイルのそれ
     ぞれの保存された最新版をNAMEという名前のスナップショットとして定
     義する（`vc-create-snapshot'）.

`C-x v r NAME RET'
     カレントディレクトリやその下に置いてある登録されたファイルすべて
     について, スナップショットNAMEに対応する版を選択する.

     カレントディレクトリやその下に置いてある登録されたファイルのいず
     れかがロックされていると, このコマンドは何も変更せずにエラーを報
     告する.  これは, 進行中の作業結果を上書きしてしまうことを避けるた
     め.

スナップショットはとても少量の資源しか使いません.  ファイル名一覧とス
ナップショットに属する版番号を記録するに十分な量だけでいいのです.  し
たがって, 使いものになるものをスナップショットにすることを躇うことはあ
りません.

`C-x v ='や`C-x v ~'（*Note Old Versions::）の引数として, スナップショッ
トの名前を指定できます.  したがって, スナップショットと現在のファイル, 
あるいは, 2つのスナップショット同士, あるいは, 指定した名前の版とスナッ
プショット同士を比較できます.



File: emacs-ja, Node: Snapshot Caveats, Next: Miscellaneous VC, Prev: Making Snapshots, Up: Snapshots

スナップショットの弱点
......................

VCのスナップショット機能は, RCSの名前付きコンフィギュレーションサポー
ト（named-configuration support）をモデルにしています.  RCS固有の機能
を使っているため, RCSを使って作ったVCのスナップショットは, VCを使わな
くても見えます.

SCCSでは, VC自身でスナップショット機能を実装しています.  VCが使うファ
イルには, 名前／ファイル／版番号の3つ組みが含まれます.  これらのスナッ
プショットは, VCを使ったときだけ見えます.

スナップショットはチェックインした版の集合です.  ですから, スナップショッ
トを作るときには, すべてのファイルをチェックインしてあり, しかもロック
していないことを確認してください.

ファイルを改名したり削除すると, スナップショットに問題を生じます.  こ
れはVCに固有の問題ではなく, 版管理システムに一般的な設計上の問題で, ま
だ誰も満足ゆく解決をできていません.

登録されたファイルを改名するなら, そのマスタファイルも一緒に改名する必
要があります（コマンド`vc-rename-file'は自動的にこれを行う）.  SCCSを
使っているならば, ファイル名を新しい名前にしてスナップショットの記録も
更新する必要があります（`vc-rename-file'はこれも行う）.  記録された名
前ではもはや存在しないマスタファイルを参照する古いスナップショットは無
効です.  VCは（古い名前では）取り出せません.  スナップショットを手で更
新する方法を説明するためにRCSやSCCSを詳しく説明することは, 本書の範囲
を越えています.

`vc-rename-file'を使えば, 取り出し操作に使える程度にはスナップショット
を保てますが, すべての問題を解決できるわけではありません.  たとえば, 
プログラムのいくつかのファイルでは, 名前で他のファイルを参照しているで
しょう.  少なくとも, makefileでは, 改名したファイルを指しているでしょ
う.  古いスナップショットを取り出すと, 改名したファイルは新しい名前で
取り出しますが, makefileで使っている名前ではありません.  ですから, 取
り出しただけではプログラムは動かないでしょう.



File: emacs-ja, Node: Miscellaneous VC, Next: Customizing VC, Prev: Snapshots, Up: Version Control

VCのその他のコマンドと機能
--------------------------

本節では, 使用頻度の少ないVCの機能を説明します.

* Menu:

* Change Logs and VC::  Generating a change log file from log entries.
* Renaming and VC::     A command to rename both the source and master 
                          file correctly.
* Version Headers::     Inserting version control headers into working files.



File: emacs-ja, Node: Change Logs and VC, Next: Renaming and VC, Prev: Miscellaneous VC, Up: Miscellaneous VC

変更記録とVC
............

プログラムに対してRCSやCVSを使い, しかも, それらに変更記録ファイル
（*Note Change Log::）を保持しているならば, 版管理の記録項目から変更記
録項目を自動的に生成できます.

`C-x v a'
     カレントディレクトリにある変更記録ファイルを訪れる.  そして, その
     ディレクトリに置いてある登録された各ファイルについて, 変更記録ファ
     イルにある最新の項目以降にチェックインされた版に関する新たな項目
     を作成する.  （`vc-update-change-log'）.

     このコマンドはRCSやCVSだけで動作し, SCCSでは動作しない.

`C-u C-x v a'
     上と同様であるが, カレントバッファのファイルに関する項目だけを探
     す.

`M-1 C-x v a'
     上と同様だが, 現在訪問しているファイルのうち版管理の下に置かれて
     いるファイルすべてに関する項目を探す.  このコマンドはRCSでのみ動
     作する.  しかも, デフォルトディレクトリに関するすべての項目を変更
     記録に追加するが, これは適切でないこともある.

たとえば, `ChangeLog'の最初の行の日付が1999年4月10日であり, それ以降の
チェックインはNathaniel Bowditchが1999年5月22日に`Ignore log messages
that start with `#'.'という記録で`rcs2log'にチェックインしたものだけだ
としましょう.  そうすると, `C-x v a'は`ChangeLog'を訪問して, つぎのよ
うなテキストを挿入します.

     1999-05-22  Nathaniel Bowditch  <nat@apn.org>

             * rcs2log: Ignore log messages that start with `#'.

このあと, 変更記録の新しい項目を好きなように編集できます.

残念ながら, ChangeLogファイルには日付しか記録していないので, 新たな変
更記録項目がChangeLogファイルの既存の項目と重複することがあります.  そ
のような日付の重複は, 手作業で削除する必要があります.

通常, ファイル`foo'に関する記録項目は, 
`* foo: TEXT OF LOG ENTRY'のように表示されます. 
記録項目のテキストが`(FUNCTIONNAME):'で始まると, 
`foo'のうしろの`:'は省かれます. 
たとえば, `vc.el'に関する記録項目が
`(vc-do-command): Check call-process status.'であれば, 
`ChangeLog'の中のテキストはつぎのようになります. 

     1999-05-06  Nathaniel Bowditch  <nat@apn.org>

             * vc.el (vc-do-command): Check call-process status.

`C-x v a'が複数の変更記録項目を一度に追加するときには, 同じ作者がほぼ
同じ日時にチェックインしたものならば, 関連する記録項目をまとめます. 
そのようないくつかのファイルに対する記録項目がすべて同じテキストならば,
1つの項目にまとめます.  たとえば, 最後にチェックインしたものに, 以下の
記録があったとします.

* `vc.texinfo'の記録項目: `Fix expansion typos.'
* `vc.el'の記録項目: `Don't call expand-file-name.'
* `vc-hooks.el'の記録項目: `Don't call expand-file-name.'

これらは`ChangeLog'の中ではつぎのようになります.

     1999-04-01  Nathaniel Bowditch  <nat@apn.org>

             * vc.texinfo: Fix expansion typos.

             * vc.el, vc-hooks.el: Don't call expand-file-name.

通常, `C-x v a'は記録項目を空行で区切りますが, 
関連する記録項目のテキストを`{CLUMPNAME} 'のような
ラベルで始めれば, 関連する複数の記録項目を1つの塊にする
（区切りの空行を入れない）ように印を付けられます. 
ラベル自体は`ChangeLog'にはコピーされません. 
たとえば, 記録項目がつぎのようであるとします. 

* `vc.texinfo'の記録項目: `{expand} Fix expansion typos.'
* `vc.el'の記録項目: `{expand} Don't call expand-file-name.'
* `vc-hooks.el'の記録項目: `{expand} Don't call expand-file-name.'

すると, `ChangeLog'のテキストはつぎのようになります.

     1999-04-01  Nathaniel Bowditch  <nat@apn.org>

             * vc.texinfo: Fix expansion typos.
             * vc.el, vc-hooks.el: Don't call expand-file-name.

記録項目のテキストが`#'で始まると, その記録項目は`ChangeLog'にはコピー
されません.  たとえば, コメントの綴りまちがいだけを変更したときには, 
記録項目を`#'で始めれば, このような自明なものを`ChangeLog'に入れないで
すみます.



File: emacs-ja, Node: Renaming and VC, Next: Version Headers, Prev: Change Logs and VC, Up: Miscellaneous VC

VC作業ファイルとマスタファイルの改名
....................................

登録したファイルを改名するときには, そのマスタファイルも同様に改名して
正しい結果を得られるようにする必要があります.  指定どおりにソースファ
イルを改名し, それに従ってマスタファイルも改名するには,
`vc-rename-file'を使います.  このコマンドは, 当該ファイルを指名してい
るどんなスナップショット（*Note Snapshots::）も更新するので, スナップ
ショットでも新しい名前を使うようになります.  それにも関わらず, 修正し
たスナップショットは動作しないかもしれません（*Note Snapshot Caveats::）.

誰かがロックしているファイルに対しては, `vc-rename-file'を使えません.



File: emacs-ja, Node: Version Headers, Next: Customizing VC, Prev: Renaming and VC, Up: Miscellaneous VC

版管理ヘッダの挿入
..................

版を識別する文字列を作業ファイルへ直接入れておくと便利なこともあります.
"版管理ヘッダ"と呼ばれる特別な文字列は, 各版ごとにその版番号で置き換え
られます.

RCSを使っていて, かつ, 作業ファイルに版管理ヘッダが入っていれば, Emacs
は, 版管理ヘッダを使って現在の版とファイルのロック状態を決定できます. 
これは, 版管理ヘッダがないときにマスタファイルを参照するより, 信頼でき
ます.  複数の枝を使う環境では, VCが正しくふるまうためには版管理ヘッダ
が必要です（*Note Multi-User Branching::）.

版管理ヘッダの探索は, 変数`vc-consult-headers'で制御されます.  `nil'以
外ならば, 編集中の版番号を決定するためにEmacsはヘッダを探します.
`nil'を設定すると, この機能はオフになります.

適切なヘッダ文字列を入れるには, コマンド`C-x v h' 
（`vc-insert-headers'）を使います.

`C-x v h'
     版管理システムで使うヘッダをファイルに挿入する.

デフォルトのヘッダ文字列は, 
RCSでは`$Id$', SCCSでは`%W%'です. 
変数`vc-header-alist'に設定すれば, 他のヘッダを指定できます. 
この値は, `(PROGRAM . STRING)'の形式の
要素から成るリストです. 
ここで, PROGRAMは`RCS'または`SCCS'であり, 
STRINGは使用する文字列です. 

1つの文字列のかわりに, 文字列のリストを指定することもできます.  そうす
ると, リストの各文字列は, 別々の行に別のヘッダとして挿入されます.

この変数に入れる文字列を書くときには, 『余分な』バックスラッシュを使う
必要がよくあります.  この文字列を含むEmacs Lispファイルが版管理の下に
置かれているときに, 定数中の文字列がヘッダと解釈されることを防ぐためで
す.

各ヘッダは, ポイント位置の新しい行に, コメント区切りの内側にタブで囲ん
で挿入されます.  通常, 現在のモードのコメント開始文字列とコメント終了
文字列を使いますが, 特定のモードでは, この目的のための特別なコメント区
切りがあります.  変数`vc-comment-alist'がそれらを指定します.  このリス
トの各要素は`(MODE STARTER ENDER)'という形式です.

変数`vc-static-header-alist'は, バッファ名に基づいた追加の文字列を指定
します.  この値は, `(REGEXP . FORMAT)'の形式の要素から成るリストでなく
てはいけません.  REGEXPがバッファ名に一致するたびに, FORMATをヘッダの
一部として挿入します.  バッファ名に一致する各要素と`vc-header-alist'に
指定された各文字列ごとにヘッダ行を挿入します.  `vc-header-alist'の文字
列を要素の書式FORMATで処理してヘッダ行を作ります.
`vc-static-header-alist'のデフォルト値はつぎのとおりです.

     (("\\.c$" .
       "\n#ifndef lint\nstatic char vcid[] = \"\%s\";\n\
     #endif /* lint */\n"))

これは, つぎのようなテキストを挿入します.


     #ifndef lint
     static char vcid[] = "STRING";
     #endif /* lint */

上のテキストは空行で始まっていることに注意してください.

複数の版管理ヘッダをファイルに入れる場合には, ファイル内ではそれらを一
緒にまとめて入れておきます.  `revert-buffer'のマーカを保存する機構は,
2つの版管理ヘッダのあいだに置かれたマーカを扱えないこともあります.



File: emacs-ja, Node: Customizing VC, Next: Directories, Prev: Miscellaneous VC, Up: Version Control

VCのカスタマイズ
----------------

VCをカスタマイズする方法はたくさんあります.  設定可能なオプションは, 
次節に述べる4つに分類できます.

* Menu:

* Backend Options::       Customizing the back-end to your needs.
* VC Workfile Handling::  Various options concerning working files.
* VC Status Retrieval::   How VC finds the version control status of a file,
                            and how to customize this.
* VC Command Execution::  Which commands VC should run, and how.



File: emacs-ja, Node: Backend Options, Next: VC Workfile Handling, Prev: Customizing VC, Up: Customizing VC

VCのバックエンドに対するオプション
..................................

RCSとCVSには, ファイルのロックを使うかどうかを指定できます（ロックに関
しては*Note VC Concepts::）.  VCはどちらを選んだかを識別し, そのように
ふるまいます.

RCSでは, デフォルトはロックを使います.  しかし, ファイルをロックしてい
なくても変更をチェックインできる, "弱いロック"と呼ばれるモードがありま
す.  特定のファイルに対して弱いロックを使うように切り替えるには, `rcs
-U'を使います.  詳しくは, `rcs'のマニュアルページを参照してください.

CVSでは, デフォルトはロックを使いません.  いつでも誰もが作業ファイルを
変更できます.  しかし, これを制限する方法があり, ロックに似たふるまい
をします.

1つの方法は, 環境変数`CVSREAD'に何か値を設定することです.  この変数が
定義されていると, CVSはデフォルトでは作業ファイルを読み出し専用にしま
す.  Emacs内では, `C-x C-q'と打ってファイルを書き込み可能にする必要が
あります.  そうすると, 事実上ロックを使っているかのように編集できます. 
しかしながら, 実際にロックされているわけではないので, 複数のユーザーが
各自のファイルを同時に書き込み可能にできてしまいます.  `CVSREAD'を初め
て設定するときには, ファイルの保護が正しく設定されるように, あなたのモ
ジュールすべてを新たにチェックアウトしたことを確認してください.

ロックに似たふるまいを達成する別の方法は, CVSの"監視"機能を使うことで
す.  ファイルを監視するようにしておくと, CVSはデフォルトでそのファイル
を読み出し専用にします.  そのため, Emacs内では`C-x C-q'を使って書き込
み可能にする必要があります.  VCは, `cvs edit'を実行してファイルを書き
込み可能にします.  すると, CVSは, あなたがファイルを変更しようとしてい
ることを他の開発者に通知します.  監視機能の詳しい使い方については, CVS
の解説を参照してください.

変数`vc-handle-cvs'に`nil'を設定すれば, CVSの管理下に置いたファイルに
対してVCを使わないようにできます.  こうすると, Emacsは, これらのファイ
ルをあたかも登録されていないかのように扱い, それらに対してVCコマンドは
使えません.  すべてのCVS操作を手動で行う必要があります.



File: emacs-ja, Node: VC Workfile Handling, Next: VC Status Retrieval, Prev: Backend Options, Up: Customizing VC

VC作業ファイルの扱い方
......................

Emacsは, 版管理の下に置かれたソースファイルに対しては, 通常バックアッ
プファイルを作りません.  版管理を使っているファイルに対してもバックアッ
プファイルを作りたいなら, 変数`vc-make-backup-files'に`nil'以外の値を
設定します.

ロックの状態に関わらず, 普通, 作業ファイルはつねに存在します.
`vc-keep-workfiles'に`nil'を設定すると, `C-x C-q'で新版をチェックイン
すると, 作業ファイルを削除します.  しかし, Emacsでファイルを訪問しよう
とすると, 作業ファイルをふたたび作ります.  （CVSでは, 作業ファイルはつ
ねに存在する. ）

版管理されているファイルをシンボリックリンクを介して編集することは, 危
険なことになりえます.  版管理システムを迂回してしまいます.  つまり, ロッ
クせずにファイルを編集できてしまい, 変更のチェックインには失敗します. 
また, 他のユーザーがあなたの変更を上書きしてしまうかもしれません.  こ
ういったことを防ぐために, VCは, 訪問する各シンボリックリンクを検査して, 
それが版管理の下に置かれたファイルを指しているかどうか調べます.

変数`vc-follow-symlinks'は, シンボリックリンクが版管理されているファイ
ルを指しているときにどうするかを制御します.  その値が`nil'ならば, VCは
警告メッセージを表示するだけです.  `t'ならば, VCは自動的にリンクを辿っ
て, かわりに本当のファイルを訪問し, エコー領域にこのことを表示します. 
値が`ask'（デフォルト）ならば, VCはリンクを辿るかどうかを毎回聞いてき
ます.



File: emacs-ja, Node: VC Status Retrieval, Next: VC Command Execution, Prev: VC Workfile Handling, Up: Customizing VC

VC状態検索
..........

ファイルのロック状態を推測するとき, VCはまずファイルのRCSの版管理ヘッ
ダ文字列を探します（*Note Version Headers::）.  ヘッダ文字列がなかった
り, SCCSを使っているときは, VCは通常, 作業ファイルのパーミッションを調
べます.  ここまでは, すぐにできます.  しかし, ファイルのパーミッション
を信頼できない場合もあります.  この場合, やや手間がかかりますが, マス
タファイルを調べる必要があります.  さらに, マスタファイルは, ファイル
がロックされているかどうかは教えてくれますが, 作業ファイルがロックされ
た版を本当に含んでいるかどうかは教えてくれません.

ロック状態を調べるために版管理ヘッダを使わないようにVCに指示するには, 
変数`vc-consult-headers'に`nil'を設定します.  すると, VCは（信頼できる
なら）ファイルパーミッションを使うか, マスタファイルを調べます.

変数`vc-mistrust-permissions'を設定することで, ファイルパーミッション
を信頼するかどうかの基準を指定できます.  その値は, `t'（つねにファイル
パーミッションを疑い, マスタファイルを調べる）, `nil'（つねにファイル
パーミッションを信頼する）, あるいは, 可否を決定する1引数の関数です. 
その引数は, サブディレクトリ, `RCS', `CVS', `SCCS'のいずれかの名前です. 
関数の戻り値が`nil'以外ならば, ファイルパーミッションを疑います.  作業
ファイルのパーミッションがまちがって変更されていると思うなら,
`vc-mistrust-permissions'に`t'を設定します.  すると, VCはつねにファイ
ルの状態を決定するためにマスタファイルを調べます.



File: emacs-ja, Node: VC Command Execution, Next: Directories, Prev: VC Status Retrieval, Up: Customizing VC

VCコマンドの実行
................

`vc-suppress-confirm'が`nil'以外ならば, `C-x C-q'と`C-x v i'は確認せず
にカレントバッファを保存し, `C-x v u'も確認せずに作用します.  （この変
数は`C-x v c'には影響しない.  その操作は思い切ったものなので, つねに確
認するべき. ）

VCモードは, RCS, CVS, SCCSのシェルコマンドを実行することで, その作業の
多くを行います.  `vc-command-messages'が`nil'以外ならば, VCはどのシェ
ルコマンドを実行しているか表示し, コマンドが終了したときに追加メッセー
ジを表示します.

変数`vc-path'を設定すれば, 版管理プログラムを探すための追加のディレク
トリを指定できます.  これらのディレクトリは, 通常の探索パスを探すまえ
に探されます.  しかし, 通常は適切なファイルを自動的にみつけられます.



File: emacs-ja, Node: Directories, Next: Comparing Files, Prev: Version Control, Up: Files

ファイルディレクトリ
====================

ファイルシステムは, ファイル群を"ディレクトリ"にまとめます.  "ディレク
トリ一覧"は, ディレクトリの中にある, すべてのファイルの一覧表です.
Emacsには, ディレクトリを作成したり削除したりするコマンド, 短形式（ファ
イル名のみ）や長形式（サイズ, 日付, 作者を含む）のディレクトリ一覧を作
成するコマンドがあります.  diredと呼ばれるディレクトリブラウザもありま
す.  *Note Dired::.

`C-x C-d DIR-OR-PATTERN RET'
     短形式でディレクトリ一覧を表示する（`list-directory'）.
`C-u C-x C-d DIR-OR-PATTERN RET'
     長形式でディレクトリ一覧を表示する.
`M-x make-directory RET DIRNAME RET'
     DIRNAMEという名前の新しいディレクトリを作る.
`M-x delete-directory RET DIRNAME RET'
     DIRNAMEという名前のディレクトリを削除する.  ディレクトリは空であ
     る必要があり, さもないとエラー.

ディレクトリ一覧を表示するコマンドは`C-x C-d'（`list-directory'）です. 
表示するディレクトリや一覧に含めるファイルを指定するワイルドカードを含
むパターンをミニバッファから読み取ります.  たとえば,

     C-x C-d /u2/emacs/etc RET

とすると, ディレクトリ`/u2/emacs/etc'の中のすべてのファイルを表示しま
す.  ファイル名のパターンを指定した例はつぎのとおりです.

     C-x C-d /u2/emacs/src/*.c RET

通常, `C-x C-d'はファイル名だけを含んだ短形式のディレクトリ一覧を表示
します.  （値は無関係な）数引数を指定すると, （`ls -l'のように）サイズ, 
日付, 作者を含む長形式の一覧を作ります.

ディレクトリ一覧のテキストは, 下位プロセスで`ls'を実行して取得します.
Emacsの2つの変数で, `ls'へ渡すオプションを制御します.
`list-directory-brief-switches'は, 短形式一覧のときに使うオプションを
与える文字列です（デフォルトは`"-CF"'）.
`list-directory-verbose-switches'は, 長形式一覧のときに使うオプション
を与える文字列です（デフォルトは`"-l"'）.



File: emacs-ja, Node: Comparing Files, Next: Misc File Ops, Prev: Directories, Up: Files

ファイルの比較
==============

コマンド`M-x diff'は, 2つのファイルを比較し, `*Diff*'という名前のEmacs
バッファにその違いを表示します.  このコマンドは, 値が文字列である変数
`diff-switches'で指定されたオプションを使って`diff'プログラムを実行し
ます.

バッファ`*Diff*'のメジャーモードはコンパイル（compilation）モードです. 
ですから, `C-x `'を使って, 2つのソースファイルで変更されている箇所を次々
に訪れることができます.  特定の変更箇所にポイントを移動してから, RETや
`C-c C-c'を打つか, そこで`Mouse-2'をクリックすると, そこに対応するソー
スの場所へ移動できます.  コンパイル（compilation）モードの他の特別なコ
マンドを使うこともできます.  SPCとDELでスクロール, `M-p'と`M-n'でカー
ソル移動できます.  *Note Compilation::.

コマンド`M-x diff-backup'は, 指定されたファイルとその最新のバックアッ
プとを比較します.  バックアップファイルの名前を指定すると,
`diff-backup'はそのもとのファイルとバックアップファイルとを比較します.

コマンド`M-x compare-windows'は, カレントウィンドウの中のテキストと, 
つぎのウィンドウの中のテキストを比較します.  それぞれのウィンドウのポ
イント位置から比較を始めます.  それぞれの開始位置は, 各バッファのマー
クリングに積まれます.  そして, 各ウィンドウでそれぞれのポイントを1文字
ずつ進めることを, 両者のウィンドウで一致しないものに出会うまで行います. 
そして, コマンドは終了します.  Emacsのウィンドウについてより詳しくは,
*Note Windows::.

数引数を指定すると, `compare-windows'は白文字の違いを無視します.  変数
`compare-ignore-case'が`nil'以外ならば, 大文字小文字の違いも同様に無視
します.

2つの似たファイルの併合に便利な機能に関しては, *Note Emerge::.



File: emacs-ja, Node: Misc File Ops, Next: Compressed Files, Prev: Comparing Files, Up: Files

その他のファイル操作
====================

Emacsには, ファイルをさまざまに操作するコマンドがあります.  それらすべ
ては1つのファイルを操作します.  これらのコマンドは, ワイルドカードを含
むファイル名を受け付けません.

`M-x view-file'では, ファイルを1画面分ずつ順番に眺めることができます. 
このコマンドは, ミニバッファでファイル名を読み取ります.  Emacsバッファ
にファイルを読み込んだあと, `view-file'は先頭を表示します.  そうしたら,
1ウィンドウ分先へスクロールするにはSPC, 逆向きにスクロールするにはDEL
を打ちます.  ファイル内を動き廻るための他のいろいろなコマンドもありま
すが, 変更するためのコマンドはありません.  コマンド一覧を見るには, こ
のモードで`?'と打ちます.  コマンド群は, Emacsの普通のカーソル移動コマ
ンドとほとんど同じです.  ファイル閲覧を終了するには, `q'を打ちます. 
閲覧用のコマンドは, 閲覧（view）モードと呼ばれる特別なメジャーモードで
定義されています.

関連したコマンド, `M-x view-buffer'は, Emacsの既存のバッファを閲覧しま
す.  *Note Misc Buffer::.

`M-x insert-file'は, 指定したファイルの内容をカレントバッファのポイン
ト位置に挿入します.  ポイントの位置はそのままですが, 挿入された部分の
直後にマークを設定します.

`M-x write-region'は, `M-x insert-file'の逆です.  指定したファイルにリー
ジョンの内容をコピーします.  `M-x append-to-file'は, 指定したファイル
の末尾にリージョンのテキストを付け加えます.  *Note Accumulating
Text::.

`M-x delete-file'は, シェルの`rm'コマンドのように, 指定したファイルを
削除します.  1つのディレクトリ内のたくさんのファイルを削除するのなら,
diredを使うほうが便利です（*Note Dired::）.

`M-x rename-file'は, ミニバッファで2つのファイル名, OLDとNEWを読み取り, 
ファイルOLDをNEWに改名します.  NEWという名前のファイルが既存のときには, 
確認に`yes'で応答する必要があります.  そうしないと, 改名しません.  こ
れは, 改名により名前NEWの古い意味が失われるからです.  OLDとNEWが異なる
ファイルシステムの上にあるときには, ファイルOLDを（NEWに）コピーしてか
ら削除します.

似たコマンド`M-x add-name-to-file'は, 既存ファイルの名前を消さずに別の
名前を追加するために使います.  新しい名前は, 既存ファイルが置かれてい
る同じファイルシステムに属している必要があります.

`M-x copy-file'は, ファイルOLDを読んで, 新しいファイルNEWに同じ内容を
書き出します.  NEWという名前のファイルが既存なら, 確認を求めてきます. 
というのは, コピーするとファイルNEWの古い内容を上書きしてしまうからで
す.

`M-x make-symbolic-link'は, 2つのファイル名, TARGETとLINKNAMEを読み取っ
て, TARGETを指すLINKNAMEという名前のシンボリックリンクを作ります.  こ
の結果, 将来LINKNAMEをオープンしようとすると, その時点でTARGETという名
前のファイルを参照します.  その時点で名前TARGETが使われていなければ, 
エラーになります.  このコマンドは引数TARGETを展開しないので, リンク先
に相対名を書くことができます.

LINKNAMEが使われていると, リンクを作るときに確認を求めます.  すべての
システムでシンボリックリンクを使えるわけではないことに注意してください.



File: emacs-ja, Node: Compressed Files, Next: Remote Files, Prev: Misc File Ops, Up: Files

圧縮されたファイルの参照
========================

Emacsには, 圧縮されたファイルを訪問すると自動的に展開し, それを変更し
て保存すると自動的に再度圧縮するライブラリがあります.  この機能を利用
するには, コマンド`M-x auto-compression-mode'を打ちます.

（自動展開を含む）自動圧縮がオンのときには, Emacsはファイル名で圧縮さ
れたファイルを認識します.  ファイル名の語尾が`.gz'のものは, `gzip'で圧
縮されたファイルであることを表します.  他の語尾の場合には, 他の圧縮プ
ログラムであることを表します.

自動展開と自動圧縮は, Emacsがファイルの内容を使うすべての操作に適用さ
れます.  ファイルを訪問する, ファイルに保存する, ファイルの内容をバッ
ファに挿入する, ファイルをロードする, ファイルをバイトコンパイルするこ
とを含みます.



File: emacs-ja, Node: Remote Files, Next: Quoted File Names, Prev: Compressed Files, Up: Files

リモートファイル
================

特別なファイル名の構文を使って, 他のマシン上のファイルを参照できます.

     /HOST:FILENAME
     /USER@HOST:FILENAME

このようにすると, Emacsは, 指定したホスト上のファイルを読み書きするた
めにFTPプログラムを使います.  あなたのユーザー名かUSERを使ってFTPでロ
グインします.  毎回パスワードを聞かれることもありますが, これはHOSTへ
のログインに使われます.

普通, リモートファイル名にユーザー名を指定しないと, あなたのユーザー名
を使うことを意味します.  しかし, 変数`ange-ftp-default-user'に文字列を
設定しておけば, その文字列をかわりに使います.  （FTPによるファイル参照
を実装するEmacsのパッケージは, `ange-ftp'と呼ばれる. ）

変数`file-name-handler-alist'に`nil'を設定すると, FTPファイル名機能を
完全にオフにできます (1) (*Note Remote Files-Footnotes::).


File: emacs-ja  Node: Remote Files-Footnotes, Up: Remote Files

(1) ファイル名をクォートする`/:'の機能もオフになる.



File: emacs-ja, Node: Quoted File Names, Next: Buffers, Prev: Remote Files, Up: Files

クォートしたファイル名
======================

特殊文字や特別な構文の特別な効果を抑えるために, 絶対ファイル名を"クォー
ト"できます.  そうするには, 先頭に`/:'を加えます.

たとえば, リモートにあるように見えるローカルなファイル名をクォートして, 
リモートファイル名として扱われるのを防ぎます.  したがって, ディレクト
リが`/foo:'という名前であり, その中に`bar'という名前のファイルがあると
き, Emacsでは, そのファイルを`/:/foo:/bar'で参照できます.

`/:'は, `~'をユーザーのホームディレクトリを表す特殊文字として扱わない
ようにもします.  たとえば, `/:/tmp/~hack'は, ディレクトリ`/tmp'の中に
ある`~hack'というファイル名を指します.

同様に, `/:'は`$'を含むファイル名をミニバッファで入力する方法の1つです. 
しかし, `$'をクォートするには, `/:'は（ミニ）バッファの先頭に置く必要
があります.

ワイルドカード文字を`/:'でクォートすることもできます.  たとえば,
`/:/tmp/foo*bar'でファイル`/tmp/foo*bar'を訪問します.  しかしながら, 
多くの場合, 単にワイルドカード文字そのものを入力できます.  たとえば,
`/tmp'にある`foo'で始まり`bar'で終る名前のファイルが`foo*bar'であると
きには, `/tmp/foo*bar'と指定すると, 単に`/tmp/foo*bar'を訪問します.



File: emacs-ja, Node: Buffers, Next: Windows, Prev: Files, Up: Top

複数のバッファの使い方
**********************

Emacs内で編集しているテキストは"バッファ"（buffer）と呼ばれるオブジェ
クトの中に存在します.  ファイルを訪問するたびに, ファイルのテキストを
保持するバッファを作ります.  diredを起動するたびに, ディレクトリ一覧を
保持するバッファを作ります.  `C-x m'でメッセージを送信するときには, メッ
セージのテキストを保持するためにバッファ`*mail*'が使われます.  コマン
ドの説明文を求めると, `*Help*'と呼ばれるバッファに説明文が現れます.

どんなときでも, 1つのバッファだけが"選択"されています.  このバッファを
"カレントバッファ"とも呼びます.  バッファが1つしかないかのように, コマ
ンドが『バッファ』に作用するといういい方をよくします.  しかし, 実際に
は, コマンドが選択されたバッファに作用するということです（多くのコマン
ドはそうする）.

複数のウィンドウがあるとき, 各ウィンドウはそこに表示しているバッファを
選んでいますが, いつでもそれらのウィンドウのうち1つだけが選択されてい
て, そのウィンドウに表示されているバッファが選択されているバッファです. 
各ウィンドウのモード行は, そのウィンドウに表示しているバッファの名前を
表示します（*Note Windows::）.

各バッファにはどんな長さでもよい名前があり, バッファ名を指定してバッファ
を選択できます.  多くのバッファはファイルを訪問することで作成され, そ
れらの名前はファイル名から導き出します.  好きな名前で空のバッファを作
ることもできます.  Emacsを新たに始めると, Emacs内でLisp式の評価に使え
る`*scratch*'という名前のバッファができます.  バッファ名では大文字小文
字を区別します.

各バッファは独立に, どのファイルを訪問しているか, 変更されているか, ど
のメジャーモードとマイナモードを使っているかを記録しています. （*Note
Major Modes::）.  どのEmacs変数も各バッファに"ローカルに"することがで
きます.  つまり, あるバッファでの変数の値を他のバッファでのその変数の
値とは違う値にできます.  *Note Locals::.

* Menu:

* Select Buffer::       Creating a new buffer or reselecting an old one.
* List Buffers::        Getting a list of buffers that exist.
* Misc Buffer::	        Renaming; changing read-onlyness; copying text.
* Kill Buffer::	        Killing buffers you no longer need.
* Several Buffers::     How to go through the list of all buffers
			  and operate variously on several of them.
* Indirect Buffers::    An indirect buffer shares the text of another buffer. 



File: emacs-ja, Node: Select Buffer, Next: List Buffers, Prev: Buffers, Up: Buffers

バッファの作成と選択
====================

`C-x b BUFFER RET'
     BUFFERという名前のバッファを選択または作成する
     （`switch-to-buffer'）.
`C-x 4 b BUFFER RET'
     同様だが, 別のウィンドウでBUFFERを選択する
     （`switch-to-buffer-other-window'）.
`C-x 5 b BUFFER RET'
     同様だが, 別のフレームでBUFFERバッファを選択する
     （`switch-to-buffer-other-frame'）.

BUFNAMEという名前のバッファを選択するには, `C-x b BUFNAME RET'と打ちま
す.  これは, 引数BUFNAMEでコマンド`switch-to-buffer'を実行します.  バッ
ファ名の略称形を補完することができます（*Note Completion::）.  `C-x b'
に空の引数を指定すると, どのウィンドウにも表示されていない最近選択した
バッファを意味します.

ほとんどのバッファは, ファイルを訪問することで作られるか, テキストを表
示するようなEmacsコマンドによって作られますが, `C-x b BUFNAME RET'と打っ
て, 明示的にバッファを作ることもできます.  こうすると, ファイルを訪問
していない新しい空のバッファを作り, 編集できるようにそのバッファを選択
します.  このようなバッファは, 自分用のメモを作るのに使います.  これら
のバッファを保存しようとすると, 使用するファイル名を聞かれます.  新し
いバッファのメジャーモードは, `default-major-mode'の値で決まります
（*Note Major Modes::）.

`C-x C-f'やファイルを訪問する他のコマンドは, ファイルを訪問している既
存のバッファへの切り替えにも使えることに注意してください.  *Note
Visiting::.

Emacsは, 内部目的用のバッファには, 空白で始まるバッファ名を使います.
Emacsは, これらのバッファを少々特別に扱います.  たとえば, デフォルトで
は, アンドゥ情報を記録しません.  このようなバッファ名は避けるのが最良
です.



File: emacs-ja, Node: List Buffers, Next: Misc Buffer, Prev: Select Buffer, Up: Buffers

既存バッファの一覧
==================

`C-x C-b'
     既存バッファを一覧表示する（`list-buffers'）.

既存のすべてのバッファを一覧表示するには, `C-x C-b'と打ちます.  各行は, 
バッファ名, メジャーモード, 訪問しているファイルを示します.  バッファ
は選択された順に表示されます.  もっとも最近に選択されたバッファが始め
にきます.

行頭の`*'は, バッファが『修正され』ていることを示します.  いくつかのバッ
ファが修正されているなら, `C-x s'でいくつかのバッファを保存する時期か
もしれません（*Note Saving::）.  `%'は, 読み出し専用バッファを示します.
`.'は選択されているバッファに付けられます.  つぎは, バッファ一覧の例で
す.

      MR Buffer         Size  Mode           File
      -- ------         ----  ----           ----
     .*  emacs.tex      383402 Texinfo       /u2/emacs/man/emacs.tex
         *Help*         1287  Fundamental	
         files.el       23076 Emacs-Lisp     /u2/emacs/lisp/files.el
       % RMAIL          64042 RMAIL          /u/rms/RMAIL
      *% man            747   Dired          /u2/emacs/man/		
         net.emacs      343885 Fundamental   /u/rms/net.emacs
         fileio.c       27691 C              /u2/emacs/src/fileio.c
         NEWS           67340 Text           /u2/emacs/etc/NEWS
         *scratch*	   0	 Lisp Interaction

バッファ`*Help*'は, ヘルプ要求で作られたものです.  このバッファはファ
イルを訪問していません.  バッファ`man'は, ディレクトリ`/u2/emacs/man/'
に対してdiredが作ったものです.



File: emacs-ja, Node: Misc Buffer, Next: Kill Buffer, Prev: List Buffers, Up: Buffers

その他のバッファ操作
====================

`C-x C-q'
     バッファの読み出し専用状態を切り替える（`vc-toggle-read-only'）.
`M-x rename-buffer RET NAME RET'
     カレントバッファの名前を変更する.
`M-x rename-uniquely'
     名前の最後に`<NUMBER>'を付加してカレントバッファ名を変更する.
`M-x view-buffer RET BUFFER RET'
     バッファBUFFERをスクロールする.

バッファは, "読み出し専用"にもなります.  そうすると, その内容を変更す
るコマンドは許されません.  モード行では, 左端付近に`%%'や`%*'を表示し
て, 読み出し専用バッファであることを示します.  通常, 読み出し専用バッ
ファは, テキストを操作する特別なコマンドを持つdiredやrmailなどのサブシ
ステムが作ります.  書き込みを禁止されたファイルを訪問しても読み出し専
用バッファが作られます.

読み出し専用バッファで変更したいときには, コマンド`C-x C-q'を使います
（`vc-toggle-read-only'）.  これは, 読み出し専用バッファは書き込み可能
にし, 書き込み可能バッファは読み出し専用にします.  多くの場合, これは
変数`buffer-read-only'を設定することで動作します.  この変数は各バッファ
でローカルな値を持ち, 値が`nil'以外だとバッファは読み出し専用になりま
す.  ファイルが版管理の下に置かれている場合には, `C-x C-q'は版管理シス
テムを介してバッファだけでなくファイルの読み出し専用の状態も変更します.
*Note Version Control::.

`M-x rename-buffer'は, カレントバッファの名前を変更します.  ミニバッファ
引数として新しい名前を指定します.  デフォルトはありません.  すでに他の
バッファに使っている名前を指定すると, エラーになり, 名前は変更されませ
ん.

`M-x rename-uniquely'は, 他のどれとも違う唯一の名前にするために, カレ
ントバッファ名に数字の接尾辞を付け加えて似た名前に変更します.  このコ
マンドは引数を必要としません.  このコマンドは複数のシェルバッファを作
るのに便利です.  バッファ`*Shell*'を改名すれば, `M-x shell'をふたたび
実行してバッファ名`*Shell*'の新しいシェルバッファを作れます.  一方, 古
いシェルバッファは, 新しい名前で存在し続けます.  この方法は, メイルバッ
ファ, コンパイルバッファ, 特定の名前のバッファを作るEmacsの多くの機能
にも有効です.

`M-x view-buffer'は, 既存のEmacsバッファを調べることを除けば, `M-x
view-file'（*Note Misc File Ops::）によく似ています.  閲覧（view）モー
ドには, バッファを簡単にスクロールするためのコマンドがありますが, 変更
するコマンドはありません.  `q'で閲覧（view）モードから抜けると, ウィン
ドウにまえに表示していたバッファ（とその中での箇所）に切り替わります. 
あるいは, `e'で閲覧（view）モードから抜けると, 閲覧していたバッファと
そのポイント位置はそのまま残ります.

コマンド, `M-x append-to-buffer'と`M-x insert-buffer'は, 1つのバッファ
から別のバッファへテキストをコピーするのに使います.  *Note
Accumulating Text::.



File: emacs-ja, Node: Kill Buffer, Next: Several Buffers, Prev: Misc Buffer, Up: Buffers

バッファの消去
==============

Emacsのセッションをしばらく続けると, たくさんの数のバッファが溜ってい
るでしょう.  もう必要としないバッファを"消去"したほうがよいと思うかも
しれません.  多くのオペレーティングシステムでは, バッファを消去すると
そのメモリ領域を解放してオペレーティングシステムに返すので, 他のプログ
ラムが使えるようになります.  バッファを消去するコマンドをいくつかあげ
ます.

`C-x k BUFNAME RET'
     バッファBUFNAMEを消去する（`kill-buffer'）.
`M-x kill-some-buffers'
     1つ1つ各バッファを消去するかどうか聞いてくる.


`C-x k'（`kill-buffer'）は, ミニバッファで指定した名前のバッファを消去
します.  ミニバッファでRETだけ打ったときに使われるデフォルトは, カレン
トバッファを消去することです.  カレントバッファを消去すると, 別のバッ
ファが選択されます.  どのウィンドウにも表示されていない, もっとも最近
に選択されたバッファです.  ファイルを訪問して修正してある（編集後に保
存していない）バッファを消去しようとすると, バッファを消去するまえに
`yes'での確認を求めます.

コマンド`M-x kill-some-buffers'は, 1つ1つ各バッファについて消去するか
聞いてきます.  `y'と答えると, そのバッファを消去します.  カレントバッ
ファや未保存の変更を含むバッファを消去しようとすると, 新しいバッファを
選択するか`kill-buffer'のように確認を求めてきます.

バッファメニュー機能（*Note Several Buffers::）も, さまざまなバッファ
を削除するのに便利です.

バッファを削除するときに, 毎回何か特別なことをしたいならば, フック
`kill-buffer-hook'にフック関数を追加します（*Note Hooks::）.

多くの人々がやるように, 何日にもわたってたった1つのEmacsセッションを実
行する場合, 数日前に使ったバッファで一杯になることがあります.  コマン
ド`M-x clean-buffer-list'は, それらのバッファを消去する便利な方法です. 
長い期間にわたって使っていない未修正のバッファすべてを消去します.  3日
間表示していない普通のバッファは消去されます.  しかし, 特定のバッファ
を自動的には消去しないようにしたり, ほんの数時間使用しないだけで消去す
るようにも指定できます.

真夜中（midnight）モードをオンにすれば, このようなバッファの消去を毎日
真夜中に行わせることもできます.  真夜中（midnight）モードは, 毎日真夜
中に動作します.  真夜中に, `clean-buffer-list', あるいは, ノーマルフッ
ク`midnight-hook'に指定した関数を実行します.

真夜中（midnight）モードをオンにするには, カスタマイズ（customization）
バッファを使って, 変数`midnight-mode'に`t'を設定します.  *Note Easy
Customization::.



File: emacs-ja, Node: Several Buffers, Next: Indirect Buffers, Prev: Kill Buffer, Up: Buffers

複数バッファの操作
==================

"バッファメニュー"（buffer-menu）機能は『バッファに対するdired』に似て
います.  このコマンドは, バッファ一覧を収めたEmacsバッファを編集するこ
とで, さまざまなEmacsバッファを操作できます.  バッファの保存, 消去（こ
こではdiredとの一貫性のために"削除"と呼ぶ）, 表示を行うことができます.

`M-x buffer-menu'
     すべてのEmacsバッファの一覧を収めたバッファを編集し始める.

コマンド`buffer-menu'は, すべてのEmacsバッファの一覧をバッファ`*Buffer
List*'に書き, そのバッファをバッファメニュー（buffer-menu）モードにし
て選択します.  そのバッファは読み出し専用で, 本節で述べる特別なコマン
ドでのみ変更できます.  普通のEmacsカーソル移動コマンドは, `*Buffer
List*'バッファでも使えます.  つぎにあげるコマンドは, 現在行に書かれて
いるバッファに作用します.

`d'
     バッファを削除（消去）するように指示し, 1行下へ移動する.  この指
     示は, その行のバッファ名のまえに`D'を表示する.  指示した削除は,
     `x'コマンドを打ったときに実行される.
`C-d'
     `d'に似ているが, 1行下へ移動するかわりに上へ移動する.
`s'
     バッファを保存するように指示する.  この指示により, 行には`S'が表
     示される.  指示した保存は, `x'コマンドを打ったときに実行される. 
     同じバッファに対して, 保存と削除の両方を指示できる.
`x'
     まえに指示した削除と保存を実行する.
`u'
     現在行に対する指示を消し, 1行下へ移動する.
`DEL'
     1つまえの行に移動し, その行に対するどんな指示も消す.

`d', `C-d', `s', `u'コマンドは, フラグを追加または削除して, 1行下へ
（あるいは上へ）移動します.  これらのコマンドは, 反復回数として数引数
を取ります.

つぎにあげるコマンドは, 現在行に書かれているバッファにただちに作用しま
す.

`~'
     バッファに『変更なし』と印を付ける.  コマンド`~'を打つと, ただち
     に実行する.
`%'
     バッファの読み出し専用フラグをトグルする.  コマンド`%'を打つと, 
     ただちに実行する.
`t'
     タグテーブルとしてバッファを訪問する.  *Note Select Tags Table::.

他のバッファや複数のバッファを選択するコマンドもあります.

`q'
     バッファメニューをやめる.  このウィンドウには, ここに表示していた
     もっとも最近のバッファを表示する.
`RET'
`f'
     `*Buffer List*'のかわりに, この行のバッファをただちに選択する.
`o'
     `C-x 4 b'のように, 別のウィンドウでこの行のバッファをただちに選択
     する.  `*Buffer List*'はそのまま.
`C-o'
     別のウィンドウにこの行のバッファをただちに表示するが, そのウィン
     ドウを選択しない.
`1'
     この行のバッファを画面一杯のウィンドウにただちに選択する.
`2'
     ただちに2つのウィンドウにして, この行のバッファをその1つに, 
     （`*Buffer List*'バッファを除いて）まえに選択していたバッファをも
     う1つに表示する.
`b'
     この行のバッファを一覧の最後に移す.
`m'
     `v'コマンドでバッファメニューをやめたときに, この行のバッファを別
     のウィンドウに表示するように印を付ける.  この指示は, 行頭に`>' を
     表示する.  （1つのバッファに, 削除指示と表示指示の両方を付けるこ
     とはできない. ）
`v'
     ただちにこの行のバッファを選択し, 別のウィンドウ群には`m'コマンド
     で印を付けたバッファ群を表示する.  印を付けたバッファがなければ, 
     このコマンドは`1'コマンドと同じ.

`buffer-menu'が直接行うことは, 適切なバッファを作成してそれに切り替え
てから, バッファメニュー（buffer-menu）モードにすることです.  それ以外
の上に述べたことはすべて, バッファメニュー（buffer-menu）モードが用意
した特別なコマンドで実装されています.  その結果, `*Buffer List*'バッファ
から別のEmacsバッファへ切り替えて, そこで編集できます.  あとで`*Buffer
List*'バッファをふたたび選択してすでに指示した操作を実行したり, このバッ
ファを削除したり, 無視したりもできます.

`buffer-menu'と`list-buffers'の唯一の違いは, `buffer-menu'は選択された
ウィンドウで`*Buffer List*'バッファに切り替えることです.
`list-buffers'は別のウィンドウにこのバッファを表示するだけです.
`list-buffers'を実行し（つまり, `C-x C-b'と打つ）, `*Buffer List*'バッ
ファを手動で選択すると, ここに述べたすべてのコマンドを使えます.

バッファを作成したり削除したりしても, バッファ`*Buffer List*'は自動的
に更新されません.  その内容はただのテキストにすぎません.  バッファを作
成／削除／改名したら, 現在のバッファの状態を見るために`*Buffer List*'
を更新する方法は, `g'（`revert-buffer'）を打つか, `buffer-menu'コマン
ドを再度実行することです.



File: emacs-ja, Node: Indirect Buffers, Next: Windows, Prev: Several Buffers, Up: Buffers

間接バッファ
============

"間接バッファ"は, 他のバッファとテキストを共有します.  そのような他の
バッファを間接バッファの"基底バッファ"と呼びます.  ある意味で, ファイ
ルのあいだのシンボリックリンクに似ています.

`M-x make-indirect-buffer BASE-BUFFER RET INDIRECT-NAME RET'
     BASE-BUFFERを基底バッファとする間接バッファINDIRECT-NAMEを作る.

間接バッファのテキストはつねに基底バッファのテキストと同じです.  どち
らか片方を編集して変更すると, 他方のバッファでもすぐにそれが見えます. 
しかし, それ以外のすべての点では, 間接バッファとその基底バッファは完全
に別のものです.  これらは, 異なる名前, 異なるポイントの値, 異なるナロ
イング, 異なるマーカ, 異なるメジャーモード, 異なるローカル変数を持ちま
す.

間接バッファではファイルを訪問できませんが, 基底バッファではできます. 
間接バッファを保存しようとすると, 実際には基底バッファを保存します. 
基底バッファを消去すると間接バッファも消去されますが, 間接バッファを消
去しても基底バッファには影響しません.

間接バッファの使い方の1つは, アウトラインを複数の視点で表示することで
す.  *Note Outline Views::.


File: emacs-ja, Node: Windows, Next: Frames, Prev: Buffers, Up: Top

複数のウィンドウ
****************

Emacsは, フレームを2つ以上のウィンドウに分割できます.  複数のウィンド
ウは, 異なるバッファの一部分, あるいは, 1つのバッファの異なる部分を表
示することができます.  複数フレームはつねに複数ウィンドウを意味します. 
というのは, 各フレームはそれ独自のウィンドウの集合を持つからです.  各
ウィンドウはたった1つのフレームだけに属します.

* Menu:

* Basic Window::        Introduction to Emacs windows.
* Split Window::        New windows are made by splitting existing windows.
* Other Window::        Moving to another window or doing something to it.
* Pop Up Window::       Finding a file or buffer in another window.
* Force Same Window::   Forcing certain buffers to appear in the selected
                          window rather than in another window.
* Change Window::       Deleting windows and changing their sizes.



File: emacs-ja, Node: Basic Window, Next: Split Window, Prev: Windows, Up: Windows

Emacsウィンドウの概念
=====================

各Emacsウィンドウは, いつでも1つのEmacsバッファを表示します.  1つのバッ
ファは複数のウィンドウに表示できます.  その場合, そのテキストの変更は, 
そのバッファを表示しているすべてのウィンドウで表示されます.  しかし, 
同じバッファを表示している各ウィンドウではバッファの異なる部分を表示す
ることができます.  なぜなら, 各ウィンドウはそれ自身のポイント値を持つ
からです.

どんなときでも, 1つのウィンドウだけが"選択されたウィンドウ"です.  その
ウィンドウに表示されているバッファがカレントバッファです.  端末のカー
ソルは, そのウィンドウのポイント位置を示します.  別の各ウィンドウにも
それぞれ同じようにポイント位置がありますが, 端末にはカーソルは1つしか
ないので, それらの位置を示す方法がありません.  Xウィンドウシステムで複
数フレームを表示しているときには, 各フレームには, そのフレームで選択さ
れたウィンドウにカーソルがあります.  選択されているフレームのカーソル
は塗り潰されている矩形で, それ以外のフレームのカーソルは中空の矩形です.

ポイントを移動するコマンドは, 選択されているEmacsウィンドウのポイント
値に対してだけ影響します.  たとえ同じバッファを表示しているとしても, 
他のEmacsウィンドウのポイント値は変更しません.  選択しているウィンドウ
で選択しているバッファを変更する`C-x b'といったコマンドでも同様です. 
他のウィンドウには少しも影響しません.  しかし, 別のウィンドウを選択し
てそのバッファを切り替える`C-x 4 b'のようなコマンドもあります.  さらに, 
（たとえば）`C-h f'（`describe-function'）や`C-x C-b'（`list-buffers'）
などを含むウィンドウに情報を表示するコマンドは, 選択されているウィンド
ウに影響することなく, 選択されていないウィンドウのバッファを切り替えま
す.

複数のウィンドウが同じバッファを表示するとき, 異なるリージョンを持つこ
とができます.  というのは, 各ウィンドウは, それぞれ異なるポイント値を
持てるからです.  しかしながら, 各バッファにはたった1つのマーク位置しか
ないため, マークの値はすべて同じになります.

各ウィンドウにはそれ専用のモード行があり, そこにはウィンドウに表示して
いるバッファの名前, 修正状態, バッファのメジャーモード, バッファのマイ
ナモードを表示します.  モード行に関して詳しくは, *Note Mode Line::.




File: emacs-ja, Node: Split Window, Next: Other Window, Prev: Basic Window, Up: Windows

ウィンドウの分割
================

`C-x 2'
     選択されているウィンドウを上下2つに分割する. 
     （`split-window-vertically'）.
`C-x 3'
     選択されているウィンドウを左右2つに分割する
     （`split-window-horizontally'）.
`C-Mouse-2'
     ウィンドウのモード行やスクロールバー上の位置で, そのウィンドウを
     分割する.

コマンド`C-x 2'（`split-window-vertically'）は, 選択されているウィンド
ウを上下2つのウィンドウに分割します.  どちらのウィンドウも同じポイント
値, 同じバッファを表示するところから始まります.  デフォルトでは2つのウィ
ンドウは, それぞれ, 分割されるウィンドウの半分の高さになります.  数引
数は上のウィンドウの行数を指定します.

`C-x 3'（`split-window-horizontally'）は, 選択されているウィンドウを左
右2つのウィンドウに分割します.  数引数は左側のウィンドウの桁数を指定し
ます.  2つのウィンドウはスクロールバーで分けられます.  画面幅に満たな
いウィンドウのモード行は, 切り詰められます.  Emacsが強調表示を扱えない
端末では, 切り詰めたモード行が反転表示されない場合があります.

モード行やスクロールバーで`C-Mouse-2'をクリックすることで, ウィンドウ
を左右や上下に分割できます.  分割する線はクリックした位置を通ります. 
モード行でクリックすると, 新しいスクロールバーはクリックした点上を通り
ます.  スクロールバーでクリックすると, 分割したウィンドウのモード行は
クリックした位置に並びます.

ウィンドウの幅が十分でないと, 長すぎて行に入りきらないテキスト行が多く
なります.  これらの行すべてを継続すると混乱してしまうかもしれません. 
変数`truncate-partial-width-windows'に`nil'以外を設定すると, 画面幅に
満たないすべてのウィンドウで切り詰めを強制できます.  これは, 表示され
ているバッファや`truncate-lines'の値とは独立しています.  *Note
Continuation Lines::.

水平スクロールは左右に並べたウィンドウでよく使われます.  *Note
Display::.

`split-window-keep-point'の値が`nil'以外（デフォルト）ならば, `C-x 2'
で分割した2つのウィンドウは, 分割前のウィンドウのポイント値を継承しま
す.  つまり, スクロールを避けられません.  この変数が`nil'ならば, `C-x
2'は, 画面上のテキストが移動しないように, 各ウィンドウで見えている部分
にポイントを移動しようと試みます.  また, 分割前にカーソルがあった行を
表示しているウィンドウを選択します.  遅い端末では後者の動作を好むユー
ザーもいます.



File: emacs-ja, Node: Other Window, Next: Pop Up Window, Prev: Split Window, Up: Windows

別のウィンドウの使い方
======================

`C-x o'
     別のウィンドウを選択する（`other-window'）.  （小文字の）`o'であっ
     てゼロではない.
`C-M-v'
     つぎのウィンドウをスクロールする（`scroll-other-window'）.
`M-x compare-windows'
     選択されているウィンドウのテキストとつぎのウィンドウのテキストで
     一致していないつぎの箇所を探す.
`Mouse-1'
     ウィンドウのモード行で`Mouse-1'をクリックすると, そのウィンドウを
     選択するがポイントは移動しない（`mouse-select-window'）.

別のウィンドウを選択するには, そのモード行で`Mouse-1'をクリックします. 
キーボードからは, `C-x o'（`other-window'）でウィンドウを切り替えられ
ます.  これは「other」の`o'であってゼロではありません.  2つ以上のウィ
ンドウがあるときは, このコマンドはすべてのウィンドウを, 一般的には, 上
から下へ, 左から右へ巡回します.  もっとも右下のウィンドウのつぎは, 左
上隅にあるウィンドウに戻ります.  数引数は, ウィンドウを巡回する回数を
意味します.  負の引数では逆順に巡回します.  ミニバッファを使っていると
きには, ミニバッファが巡回の最後のウィンドウになります.  ミニバッファ
ウィンドウから別のウィンドウに切り替えて, あとで戻ってきて, ミニバッファ
引数が要求しているものを与えてから終了できます.  *Note Minibuffer
Edit::.

通常のスクロールコマンド（*Note Display::）は, 選択されているウィンド
ウのみに作用しますが, つぎのウィンドウをスクロールするコマンドが1つあ
ります.  `C-M-v'（`scroll-other-window'）は, `C-x o'が選択するウィンド
ウをスクロールします.  `C-v'のように正負の引数を取ります.  （ミニバッ
ファでは, ミニバッファヘルプがあると, 標準の巡回順でつぎのウィンドウで
はなくて, ミニバッファヘルプを表示しているウィンドウをスクロールす
る. ）

コマンド`M-x compare-windows'は, 2つのウィンドウで見えている2つのファ
イル, つまり, バッファを比較して, 一致しないつぎの箇所へ移動します. 
詳細は, *Note Comparing Files::.



