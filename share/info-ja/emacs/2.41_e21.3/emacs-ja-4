Info file: emacs-ja,    -*-Text-*-
produced by `texinfo-format-buffer'
from file `emacs.texi'
using `texinfmt.el' version 2.41 of  1 Mar 2005.

INFO-DIR-SECTION Emacs
START-INFO-DIR-ENTRY
* Emacs-ja: (emacs-ja).	            Emacs21.3日本語マニュアル.
END-INFO-DIR-ENTRY








File: emacs-ja, Node: Nonincremental Search, Next: Word Search, Prev: Incremental Search, Up: Search

一括型探索
==========

Emacsでは、従来方式の一括型探索コマンドもあります。探索を開始するまえに
探索文字列全体を打っておく必要があります。

`C-s RET STRING RET'
     STRINGを探索する。
`C-r RET STRING RET'
     STRINGを後向きに探索する。

一括型探索を実行するには、まず`C-s RET'と打ちます。すると、探索文字列を
読み取るためにミニバッファに移動します。文字列をRETで終えると、探索を開
始します。文字列がみつからなければ、探索コマンドはエラーを表示します。

`C-s RET' はつぎのように動作します。まず、`C-s'がいつものようにインクリ
メンタルサーチを起動します。インクリメンタルサーチは、特別な場合として、
引数が空であったときには一括型探索(`search-forward')を起動するようにプ
ログラムしてあります。（さもなければ、そのような空の引数に意味はない）．
しかし、`C-s RET'で実行される一括型探索は、`search-forward'をただちに呼
び出すわけではありません。まず、つぎの文字が単語探索を指示する`C-w'であ
るかどうか調べます。*Note Word Search::。`C-r RET' も逆方向のインクリメ
ンタルサーチとして同様に機能します．

前向き／後向きの一括型探索は、コマンド`search-forward'と
`search-backward'で実装されています。これらのコマンドは通常と同じように
キーにバインドできます。インクリメンタルサーチコマンドから呼び出せるよ
うになっているのは、歴史的な理由、および、キー列を選ぶ労力を削減できる
という理由からです。



File: emacs-ja, Node: Word Search, Next: Regexp Search, Prev: Nonincremental Search, Up: Search

単語探索
========

単語探索は、単語の区切られ方を無視して、単語の列を探索します。より正確
には、空白1個で区切った数個の単語を打ち込むと、単語と単語のあいだに複数
個の空白／改行／句読点があったとしても、それらの文字列をみつけだすこと
ができます。

単語探索は、テキスト清書系で整形済みの文書を編集する場合に便利です。整
形した印刷出力を見ながら編集する場合、ソースファイルのどこで行が区切ら
れているのかわかりません。単語探索を使えば、単語の区切られ方を知らなく
ても探索できます。

`C-s RET C-w WORDS RET'
     句読点などの詳細は無視して、WORDSを探索する。
`C-r RET C-w WORDS RET'
     句読点などの詳細は無視して、後向きにWORDSを探索する。

単語探索は、一括型探索の特別な場合であって、
`C-s RET C-w'で起動します。
この入力に続いて、探索文字列を入力し、
文字列はつねにRETで終えます。
一括型であるため、単語探索も引数を入力し終えるまで探索を開始しません。
単語探索は、正規表現を構築し、その正規表現で探索を行うことで
動作します。
*Note Regexp Search::。

後向きの単語探索には`C-r RET C-w'を使います。

前向き／後向きの単語探索は、それぞれ、コマンド`word-search-forward'と
`word-search-backward'で実装されています。これらのコマンドは通常どおり
キーに割り当てることができます。インクリメンタルサーチコマンドから呼び
出せるようになっているのは、歴史的な理由、および、これらの機能にふさわ
しいキー列を選ぶ労力を削減できるという理由からです。



File: emacs-ja, Node: Regexp Search, Next: Regexps, Prev: Word Search, Up: Search

正規表現探索
============

"正規表現"（regular expression、"regexp"と略す）とは、一致する可能性が
ある一連の（無限個でもよい）文字列を表現するパターンです。GNU Emacsでは、
インクリメンタルサーチでも一括型探索でも、正規表現を用いた探索ができま
す。

正規表現によるインクリメンタルサーチを実行するには、
`C-M-s'（`isearch-forward-regexp'）と打つか，（値は関係ない）前置引数を
指定して`C-s'を起動します。このコマンドは、`C-s'と同様に、探索文字列を
逐次読み取ります。ただし、探索文字列をバッファのテキストに対して正確に
照合するためのものとみなすのではなく、正規表現として扱います。探索文字
列にテキストを追加するごとに、正規表現は長くなり、新たな正規表現を探索
します。後向きに正規表現を探索するには、
`C-M-r'（`isearch-backward-regexp'）を使うか、前置引数を指定して`C-r'を
使います。

通常のインクリメンタルサーチにおいて特別な機能を持つコントロール文字は、
正規表現のインクリメンタルサーチでも同じ機能を持ちます。探索の開始直後
に`C-s'や`C-r'を打つと、最後のインクリメンタルサーチに用いた正規表現を
再度使います。つまり、正規表現を用いる探索とそうでない探索とには、それ
ぞれ独立のデフォルトがあるのです。`M-p'と`M-n'で参照できる探索リングも
それぞれ別々です。

正規表現のインクリメンタルサーチでSPCを打つと、
改行を含めた任意個の白文字に一致します。
ちょうど1個の空白に一致させたいのであれば、
`C-q SPC'と打ちます。

正規表現のインクリメンタルサーチ中に正規表現に文字を加えると、カーソル
をもとに戻して探索し直すことがあります。たとえば、`foo'を探索し終えたと
きに`\|bar'を追加したとします。最初の`bar'が最初の`foo'に先行する場合に
は、カーソルはまえに戻ります。

正規表現の一括型探索は、関数`re-search-forward'と`re-search-backward'で
行われます。これらは、`M-x'で呼び出したり、キーに割り当てたり、あるいは、
`C-M-s RET'や`C-M-r RET'として正規表現のインクリメンタルサーチの方法で
起動したりできます。

正規表現のインクリメンタルサーチコマンドに前置引数を指定すると、
`isearch-forward'や`isearch-backward'のように、
普通の文字列探索を行います。
*Note Incremental  Search::。



File: emacs-ja, Node: Regexps, Next: Search Case, Prev: Regexp Search, Up: Search

正規表現の構文 *(2004/03/26)*
=============================

このマニュアルではよく使われる正規表現について説明しています．主にリス
プのプログラムで使われる追加機能については *Note Regular Expressions:
(elisp)Regular Expressions を参照してください．

正規表現には、特別な使い方をする少数の文字とその他の"普通の"文字から成
る構文があります。普通の文字は、同じ文字だけに一致してそれ以外には一致
しない単純な正規表現です。特別な文字は、`$'、`^'、`.'、`*'、`+'、`?'、
`['、`]'、および、`\'です。`\'が先行する場合を除いて、正規表現に現れる
これら以外の文字は普通の文字です(正規表現をリスプコード内で使う場合には
`\' が倍必要になります．具体的には，この章の終わりにあるサンプルを参照
してください)。

たとえば、`f'は特別な文字ではなく、通常の文字ですから、文字列`f'に一致
してそれ以外の文字列には一致しない正規表現です。（これは、文字列`ff'に
は一致し*ない*。）同様に、`o'は、`o'だけに一致する正規表現です。（大文
字小文字を区別しない場合、これらの正規表現は`F'や`O'にも一致するが、こ
れらは例外というよりは、『同じ文字列』の一般化として捉える。）

任意の2つの正規表現AとBを連結できます。その結果は、Aが文字列の始めの適
当な部分に一致して、かつ、Bが文字列の残りの部分に一致する場合に、文字列
に一致するような正規表現です。

簡単な例として、正規表現`f'と`o'を連結すると、正規表現`fo'を得ますが、
これは文字列`fo'だけに一致します。簡単ですね。多少とも複雑なことを行う
には、特別な文字を使う必要があります。以下にその一覧をあげます。

`.' (ピリオド)
     特別な文字であり、改行以外の任意の1文字に一致する。連結を使って
     `a.b'のような正規表現を作れる。これは、`a'で始まり`b'で終る任意の
     3文字の文字列に一致する。

`*'
     単独では構成要素ではない。
     直前の正規表現を可能な限り反復することを意味する後置演算子である。
     すなわち、（`o'が存在しない場合も含めて）
     `o*'は任意個の`o'に一致する。

     `*'はつねに先行する*最小*の正規表現に適用される。したがって、
     `fo*'は`fo'を繰り返すのではなく、`o'を繰り返す。この正規表現は`f'、
     `fo'、`foo'などに一致する。

     `*'を用いた構成は、一致を処理するときには、ただちに得られる限りの
     反復回数に展開される。そうしてから、残りのパターンを処理する。一致
     に失敗すると、バックトラック（後戻り）が発生して、`*'を用いた構成
     の反復回数を減らして、パターンの残りの部分が一致するようにする。た
     とえば、文字列`caaar'に対して`ca*ar'を一致させることを考えてみる。
     始めに、`a*'を3つの`a'すべてに一致させようとする。しかし、残りのパ
     ターンが`ar'なのに`r'しか残っていないため、この試みは失敗する。そ
     こで、つぎは`a*'を`a'2つだけに一致させる。こうすると、残りの正規表
     現も正しく一致する。

`+'
     `*'に似た後置演算子だが、
     直前の正規表現に1回以上一致する必要がある。
     たとえば、`ca+r'は、文字列`car'や`caaaar'には一致するが、
     文字列`cr'には一致ない。
     `ca*r'の場合は、上記の3つすべてに一致する。

`?'
     `*'に似た後置演算子だが、直前の正規表現に1回だけ一致するか、あるい
     は、1回も一致しない。たとえば、`ca?r'は、`car'や`cr'に一致するが、
     他のものには一致しない。

`*?', `+?', `??'
     上記は最小一致の(non-greedy，貪欲でない)演算子である．`*', `+',
     `?' のような普通の演算子は "greedy" (貪欲，最長一致) である．つま
     り，正規表現に対してできる限り長い文字が一致する．`?'  を付加する
     と貪欲でない最小一致にになるので，最小の部分が一致する．

     つまり，`ab*' と `ab*?' は両方とも `a' に一致するし，`abbbb' にも
     一致できる．しかし，`abbbb' に対して両者の正規表現をためしてみると，
     `ab*'ではすべての部分(最長一致)が一致するのに対して，`ab*?' では
     `a' だけ(最小一致)が一致する．

     最小一致の演算子は開始点以降でできる限り短い部分に一致するように検
     索を行う．順方向の検索では一致する最も近い位置は常にカーソルの場所
     である．それゆえ，`a.*?$' を 改行に続く `abbab' に対して検索すると
     全体に一致する．最初の`a'に一致するので，これが可能になる．

`\{N\}'
     は N 回の繰り返しを表す後置演算子である．つまり，後に続く正規表現
     をちょうど N 回繰り返す文字に一致する．例えば，`x\{4\}' は `xxxx'
     に一致する．

`\{N,M\}'
     は後置的な演算子である．N 〜 M 回繰り返すことを意味する．
     つまり，すくなくとも N 回は正規表現が一致しなければならず，
     M 回を超えてもいけない．もし M を指定しなければ，上限が無
     くなるが，すくなくとも N 回は一致しなければならない．
     `\{0,1\}' は `?' と同じである．
      `\{0,\}' は
     `*' と同じである．
      `\{1,\}' は `+' と同じになる．

`[ ... ]'
     `['で始まり`]'で終る"文字集合"を表す。もっとも単純な場合は、この2
     つの中括弧のあいだにある文字の1つ1つがこの文字集合に一致する。

     したがって、`[ad]'は、`a'1文字か`d'1文字のどちらにも一致する。
     `[ad]*'は、`a'と`d'だけから成る
     （空の文字列を含む）任意の文字列に一致する。
     このことから、`c[ad]*r'は、
     `cr'、`car'、`cdr'、`caddaar'などに一致することがわかる。

     文字集合には、文字範囲の指定を含めることもでき、始めの文字と終りの
     文字のあいだに`-'を書く。つまり、`[a-z]'はすべての ASCII 小文字に
     一致する。範囲指定と個々の文字を自由に織り混ぜてよく、`[a-z$%.]'の
     ように書ける。これは、任意の ASCII の小文字、`$'、`%'、ピリオドに
     一致する。

     文字集合の内側では、正規表現の通常の特別な文字を
     特別扱いしないことに注意。
     文字集合の内側では、まったく別の特別な文字、
     `]'、`-'、および `^' が存在する。

     文字集合に`]'を含めるには、`]'を最初の文字として指定する必要がある。
     たとえば、`[]a]'は、`]'や`a'に一致する。`-'を含めるのであれば、
     `-'を文字集合の最初の文字か最後の文字として指定して、範囲指定のあ
     とに置く。したがって、`[]-]'は、`]'と`-'の両方に一致する。

     文字集合に`^'を含めるには、`^'を文字集合の2番目以降に置く(最初に置
     くと，それは集合に補足するようになる．以下を参照)。

     大文字小文字を区別する探索で文字範囲を指定するときは、範囲の両端を、
     大文字だけ、小文字だけ、あるいは、英字以外だけで書くべきである。
     `A-z'のような大文字小文字を混ぜた文字範囲の動作は、定義が明確では
     なく、将来のEmacsでは変更するかもしれない。

`[^ ... ]'
     `[^'は"文字の補集合"の始まりを意味し、
     指定した文字を除く任意の文字に一致する。
     すなわち、`[^a-z0-9A-Z]'は、
     ASCII 文字と数字を*除く*すべての文字に一致する。

     `^'は先頭になければ文字集合では特別な意味を持たない。`^'に続く文字
     は先頭にあるものとして扱われる（いいかえれば、ここでは`-'や`]'は特
     別な意味を持たない）。

     文字の補集合は、一致しない文字として改行を指定しない限り、改行にも
     一致する。この点は、`grep'のようなプログラムでの正規表現の扱い方と
     対照的。

`^'
     空の文字列に一致する特別な文字で、テキスト行の先頭のみに一致する。
     それ以外では、一致に失敗する。したがって、`^foo'は、行頭にある
     `foo'に一致する。

`$'
     `^'と似ていて、行末のみに一致する。したがって、`x+$'は、行末にある
     1文字以上の`x'から成る文字列に一致する。

`\'
     2つの機能がある。（`\'を含む）特別な文字をクォートする（意味を抑え
     る）ことと、特別な構成を導入すること。

     `\'は特別な文字をクォートするので、`\$'は文字`$'だけに一致する正規
     表現、`\['は文字`['だけに一致する正規表現、というようになる。

注意：` '従来との互換性のために、特別な文字が、それらの特別な意味をなし
えない文脈で使われた場合には、普通の文字として扱われます。たとえば、
`*foo'では、`*'の対象となる正規表現が直前にないため、`*'は普通の文字と
して扱われます。このようなふるまいに依存することはよい習慣ではありませ
ん。特別な文字を書く位置に関係なく特別な文字はクォートするべきです。

多くの場合、任意の文字を伴う`\'はその文字だけに一致します。しかし、いく
つか例外があって、`\'で始まる2文字列が特別な意味を持つ場合があります。
2文字目にくる文字は、単独で使った場合には普通の文字として扱われるもので
す。以下に`\'の構成を列挙します。

`\|'
     選択肢を指定する。
     `\|'をあいだに伴った2つの正規表現AとBは、
     AかBのいずれかに一致する文字列に一致する正規表現となる。

     したがって、`foo\|bar'は、`foo'か`bar'に一致するが、それ以外の文字
     列には一致しない。

     `\|'は、周囲にある適用しうる正規表現の中でも最大のものに適用される。
     `\|'によるグループ化を制限するのは、これを囲む`\( ... \)'によるグ
     ループ化だけ。

     何度`\|'を使っても処理できるだけの十分なバックトラック能力がある。

`\( ... \)'
     以下の3つの目的を果たすグループ化のための構成。

       1. 他の操作に使うために一連の選択肢`\|'を括る。
          したがって、`\(foo\|bar\)x'は、
          `foox'か`barx'のいずれかに一致する。

       2. 後置演算子、`*'、`+'、`?'を適用できるように、複雑な正規表現を
          括る。したがって、`ba\(na\)*'は、`bananana'のように、（0個以
          上の）任意個の文字列`na'に一致する。

       3. あとで参照できるように、一致した部分文字列を記録する。

     この最後の運用は括弧でグループ化することの結果ではない．これは
     `\( ...  \)' の2番目の機能にすぎない．実際，これら2つの機能が衝突
     するようなことはない．衝突するような時には"shy"グループ化を利用で
     きる．

`\(?: ... \)'
     は"shy"グループを定義し，一致文字を記録しない．つまり，`\D' で参照
     することはできません．この機能は正規表現を機械的にまとめる時に役立
     ちます．これにより，グループナンバに影響を与えることなくグループ化
     を行うことができるのです．

`\D'
     D番目に現れた`\( ... \)'に一致したテキストと同じテキストに一致する。

     一致を処理するときには、`\( ... \)'構成の末尾に達すると、
     この構成に一致したテキストの始めと終りを記録する。
     そして、正規表現のそれよりうしろでは、
     『D番目に現れた`\( ... \)'に一致したテキスト』という意味で
     `\'に続けて数字Dを使える。

     1つの正規表現内に現れる最初の9個の`\( ... \)'に一致する文字列には、
     正規表現中で開き括弧が現れた順に、1から9までの番号を割りふる。その
     ため、`\1'から`\9'で、対応する`\( ... \)'に一致したテキストを参照
     できる。

     たとえば、`\(.*\)\1'は、改行を含まない文字列で、かつ、前半と後半が
     同一である文字列に一致する。`\(.*\)'は前半部分に一致し、それはどの
     ようなものでもかまわない。一方、それに続く`\1'は、前半部分とまった
     く同じテキストに一致しなければならない。

     ある`\( ... \)'が、（直後に`*'がある場合などに簡単に起こりえる）複
     数回一致する場合には、最後に一致したものだけを記録する。

`\`'
     空の文字列に一致するが、一致対象であるバッファや文字列(あるいは探
     索できる部分)の先頭に限る。

`\''
     空の文字列に一致するが、一致対象であるバッファや文字列(あるいは探
     索できる部分)の末尾に限る。

`\='
     空の文字列に一致するが、ポイント位置に限る。

`\b'
     同じく空の文字列に一致するが、単語の先頭や末尾に限る。
     したがって、`\bfoo\b'は、単語として独立して現れる`foo'に一致する。
     `\bballs?\b'は、単語として独立して現れる
     `ball'や`balls'に一致する。

     `\b'は、バッファの先頭や末尾にあるテキストとは無関係に、バッファの
     先頭や末尾にも一致する。

`\B'
     空の文字列に一致するが、単語の先頭や末尾*以外*に限る。

`\<'
     空の文字列に一致するが、単語の先頭に限る。`\<'は、単語構成文字が続
     く場合に限って、バッファの先頭にも一致する。

`\>'
     空の文字列に一致するが、単語の末尾に限る。`\>'は、単語構成文字で終
     了している場合に限って、バッファの末尾にも一致する。

`\w'
     任意の単語構成文字に一致する。
     エディタの構文テーブルによってこの文字が決まる。
     *Note Syntax::。

`\W'
     単語構成文字以外の文字に一致する。

`\sC'
     構文がCである文字だけに一致する。ここで、Cは構文クラスを表す文字。
     たとえば、`w'は単語構成要素を、`-' や` ' は白文字を、`.'は普通の句
     読点とった具合である．これについては，*Note Syntax:: を参照してく
     ださい．

`\SC'
     構文がCでない任意の文字に一致する。

`\cC'
     matches any character that belongs to the category C.  For
     example, `\cc' matches Chinese characters, `\cg' matches Greek
     characters, etc.  For the description of the known categories,
     type `M-x describe-categories RET'.

`\CC'
     matches any character that does *not* belong to category
     C.

単語や構文に関連する構成要素は、構文テーブル（*Note Syntax::）の設定で
制御されます。

複雑な正規表現を以下に示します。
これは、`sentence-end' に設定されるもので，任意個の白文字がうしろに続く文末を認識するためにEmacsが使うものです。
空白とタブ文字を区別できるように、Lispの構文で示してあります。
Lisp構文では、文字列定数はダブルクォートで始まり、
ダブルクォートで終ります。
`\"'は正規表現の一部としてのダブルクォートを表し、
`\\'は正規表現の一部としてのバックスラッシュを表します。
`\t'はタブ文字、`\n'は改行文字を表します。

     "[.?!][]\"')]*\\($\\| $\\|\t\\|  \\)[ \t\n]*"

この正規表現は4つの部分が繋がってできています。ピリオド、`?'、`!'のいず
れかに一致する文字集合。閉じ中括、2種類の引用符、括弧に一致する文字集合
の0回以上の繰り返し。バックスラッシュ付きの括弧で括った、行末、タブ、空
白2つのいずれかに一致する選択肢。白文字に一致する文字集合の任意回数の繰
り返し。

これと同じ正規表現をインクリメンタルサーチで入力するときには、タブを入
力するにはTABを打ち、改行を入力するには`C-j'を打ちます。また、Lisp構文
上ではバックスラッシュを2つ続けてますが、対話的に入力するには、1つのバッ
クスラッシュだけを打ちます。正規表現を入力するために普通のミニバッファ
を使うようなコマンドではミニバッファから`C-j'で抜けるのを避けるために
`C-q'を先に入力する必要があります．




File: emacs-ja, Node: Search Case, Next: Configuring Scrolling, Prev: Regexps, Up: Search

探索と大文字小文字の区別
========================

Emacsのインクリメンタルサーチでは、小文字だけで探索文字列を指定すると、
探索対象のテキストの大文字小文字の違いを通常無視します。
したがって、`foo'を探索するように指定すると、
`Foo'にも`foo'にも一致します。
正規表現、特に文字集合の場合でも同様です。
`[ab]'は、`a'、`A'、`b'、`B'のいずれにも一致します。

インクリメンタルサーチする探索文字列のどこかに大文字があると、大文字小
文字を区別して探索します。したがって、`Foo'の探索では、`foo'や`FOO'をみ
つけだせません。このことは、文字列の探索だけでなく正規表現の探索にもあ
てはまります。探索文字列から大文字を消去すれば、この効果はなくなります。

インクリメンタルサーチで`M-c'を入力すると大文字小文字を区別するかどうか
を切り替えることができます．この効果はその時だけで次回には有効になりま
せん．しかし，現在の検索では大文字を含める効果になります．

変数`case-fold-search'に`nil'を設定すれば、大文字小文字の違いを含めて、
すべての文字はそのとおりに一致するようになります。これは、バッファごと
の変数です。変数を変更してもカレントバッファだけに影響しますが、変更可
能なデフォルトの値があります。*Note Locals::。この変数は、置換コマンド
（*Note Replace::）やミニバッファの履歴探索コマンド（*Note Minibuffer
History::）が行う探索を含む、一括型探索にも適用されます。



File: emacs-ja, Node: Configuring Scrolling, Next: Replace, Prev: Search Case, Up: Search

スクロールの設定
================

`isearch-allow-scroll' を非nil 値に設定することで，インクリメンタルサー
チ中にスクロールなどを可能にすることができます．


標準的なスクロールコマンド
--------------------------
以下はインクリメンタルサーチ中に実行できる"スクロール"コマンドと通常の
キーバインドのリストです．


ウィンドウをスクロールするコマンド
..................................
`scroll-bar-toolkit-scroll' (`vertical-scroll-barmouse-1' in X-Windows)
`mac-handle-scroll-bar-event' (`vertical-scroll-barmouse-1' on a Mac)
`w32-handle-scroll-bar-event' (`vertical-scroll-barmouse-1' in MS-Windows)
`recenter' (`C-l') *Note Scrolling::.
`reposition-window' (`C-M-l') *Note Scrolling::.
`scroll-up' (`NEXT') *Note Scrolling::.
`scroll-down' (`PRIOR') *Note Scrolling::.


他のウィンドウで機能するコマンド
................................
`list-buffers' (`C-x C-b') *Note List Buffers::.
`scroll-other-window' (`C-M-v') *Note Other Window::.
`scroll-other-window-down' (`C-M-S-v') *Note Other Window::.
`beginning-of-buffer-other-window' (`M-home')
`end-of-buffer-other-window' (`M-end')


ウィンドウレイアウトを変更するコマンド
......................................
`delete-other-windows' (`C-x 1') *Note Change Window::.
`balance-windows' (`C-x +') *Note Change Window::.
`split-window-vertically' (`C-x 2') *Note Split Window::.
`enlarge-window' (`C-x ^') *Note Change Window::.


他のコマンドをスクロールコマンドとして設定
------------------------------------------
設定するためにはコマンドの isearch-scroll プロパティを t にします．例え
ば，以下のようにします．

     `(put 'my-command 'isearch-scroll t)'

ただし，"安全"なコマンドだけを設定すべきです．つまり，検索中に実行され
た時に矛盾するような状態にしないようにします．すなわち，続くものを一時
的に変更するようなコマンドはコマンドを終える前に保存しなければなりませ
ん．

  1. ポイント
  2. バッファの内容
  3. 選択されたウィンドウやフレーム
  4. 現在の一致データ (*Note Match Data: (elisp)Match Data)

さらに，現在のウィンドウを消してはならないし，コマンド自身がインクリメ
ンタルサーチを実行してはなりません．しかし，ウィンドウのサイズ変更や他
のウィンドウやフレームを作ったり消したりすることは可能です．

テキストを*水平方向*にスクロールさせるコマンドは害を与えませんが，動作
しません．そのようなスクロールは無効になります．



File: emacs-ja, Node: Replace, Next: Other Repeating Search, Prev: Configuring Scrolling, Up: Search

置換コマンド *(2004/03/27)*
===========================

大域的な探索置換操作は、
Emacsではそれほど必要性がありませんが、Emacsでも使えます。
多くのエディタにあるような単純なコマンド`M-x replace-string'の他にも、
パターンの各出現ごとに置換するかどうか尋ねてくる
`M-x query-replace'コマンドがあります。

置換コマンドは、通常、ポイントからバッファの末尾までのテキストを操作し
ます。しかし、暫定マーク（transient-mark，*Note Transient Mark::）モー
ドでは、マークが活性である場合にはリージョンを操作します。置換コマンド
はどれも、1つの文字列（や正規表現）を1つの置換文字列に置き換えます。コ
マンド`expand-region-abbrevs'（*Note Expanding Abbrevs::）を使って、い
くつかの置き換えを並行に行うことができます。

* Menu:

* Unconditional Replace::	Replacing all matches for a string.
* Regexp Replace::		Replacing all matches for a regexp.
* Replacement and Case::	How replacements preserve case of letters.
* Query Replace::		How to use querying.



File: emacs-ja, Node: Unconditional Replace, Next: Regexp Replace, Prev: Replace, Up: Replace

無条件置換 *(2004/03/27)*
-------------------------

`M-x replace-string RET STRING RET NEWSTRING RET'
     STRINGのすべての出現をNEWSTRINGで置換する。
`M-x replace-regexp RET REGEXP RET NEWSTRING RET'
     正規表現REGEXPに一致するものすべてをNEWSTRINGで置換する。

ポイント以降にある`foo'のすべての出現を`bar'で置き換えるには、2つの引数
`foo'と`bar'を指定したコマンド`M-x replace-string'を使います。置換はポ
イント以降でのみ実施されますから、バッファ全体に対して置換を行いたいと
きには、まずバッファの先頭に移動しておく必要があります。バッファの末尾
までに現れるすべての出現を置換します。バッファの一部に置換を限定したい
ときには、置換を実行するまえに、バッファの当該部分にナロイングしておき
ます（*Note Narrowing::）。暫定マーク（transient-mark）モードにおいては、
リージョンが活性のときには、置換はリージョン内に限定されます。

`replace-string'を終了すると、ポイントは最後に置換した出現箇所に置かれ
ます。マークは（`replace-string'コマンドを起動したとき）以前のポイント
位置に設定されます。その位置に戻るには`C-u C-SPC'を使います。

数引数を指定すると、単語区切りで囲まれた出現だけを置換対象とします。引
数の値は関係ありません。

`x' と `y'を交換したければ，すべての`x' を `y' で置換しなければならない
か？逆の場合も？これは以下のようにできます．

     M-x query-replace RET x RET @TEMP@ RET
     M-x query-replace RET y RET x RET
     M-x query-replace RET @TEMP@ RET y RET

`@TEMP@' という元の文章にはない文字があり，その文字が機能している．



File: emacs-ja, Node: Regexp Replace, Next: Replacement and Case, Prev: Unconditional Replace, Up: Replace

正規表現による置換
------------------

`M-x replace-string'コマンドは、1つの文字列に正確に一致するものだけを置
き換えます。これに類似したコマンド`M-x replace-regexp'は、指定したパター
ンに一致する任意のものを置き換えます。

`replace-regexp'では、
NEWSTRINGが定数である必要はありません。
REGEXPに一致したものの全体あるいはその一部を参照できます。
NEWSTRINGの中の`\&'は、
置換対象の文字列全体（つまり、REGEXPに一致したものの全体）を
表します。
NEWSTRINGの中の`\D'（Dは数字）は、
REGEXPの中のD番目の括弧のグループ化部分に
一致した部分を表します。
置き換えるテキスト内に`\'を含めるには、
`\\'と入力する必要があります。

     M-x replace-regexp RET c[ad]+r RET \&-safe RET

たとえばこの例は、`cadr'を`cadr-safe'で、
`cddr'を`cddr-safe'で置換します。

     M-x replace-regexp RET \(c[ad]+r\)-safe RET \1 RET

この例は、逆の置換を行います。



File: emacs-ja, Node: Replacement and Case, Next: Query Replace, Prev: Regexp Replace, Up: Replace

置換コマンドと大文字小文字の区別 *(2004/03/27)*
-----------------------------------------------

置換コマンドの第1引数がすべて小文字である場合、`case-fold-search'が
`nil'以外であるときには、大文字小文字を区別せずに置換対象を探索します。
`case-fold-search'が`nil'であるときには、すべての探索において大文字小文
字を区別します。

さらに、引数NEWSTRINGが、すべて小文字、あるいは、一部が小文字のときには、
置換コマンドは、各置換対象の大文字小文字のパターンを保存しようとします。
つまり、コマンド

     M-x replace-string RET foo RET bar RET

は、小文字の`foo'を小文字の`bar'に、すべて大文字の`FOO'を`BAR'に、大文
字で始まる`Foo'を`Bar'に置換します。（`replace-string'が区別できるのは、
これら3つの選択肢、つまり、小文字のみ、すべて大文字、大文字で始まるだ
け。）

置換文字列に大文字を使ったときには、これを挿入するときは大文字は大文字
のままです。第1引数に大文字を使ったときには、第2引数では大文字小文字を
変換せずにつねに指定どおりに置き換えます。同様に、`case-replace'や
`case-fold-search'に`nil'を設定すると、大文字小文字を変換せずに置換しま
す。



File: emacs-ja, Node: Query Replace, Prev: Replacement and Case, Up: Replace

問い合わせ型置換 *(2004/03/27)*
-------------------------------

`M-% STRING RET NEWSTRING RET'
`M-x query-replace RET STRING RET NEWSTRING RET'
     STRINGのいくつかの出現をNEWSTRINGで置換する。
`C-M-% REGEXP RET NEWSTRING RET'
`M-x query-replace-regexp RET REGEXP RET NEWSTRING RET'
     正規表現REGEXPに一致するもののいくつかをNEWSTRINGで置換する。

`foo'のすべての出現ではなく、そのうちのいくつかだけを`bar'に変更したい
ときには、通常の`replace-string'を使うことはできません。かわりに、
`M-%'（`query-replace'）を使います。このコマンドは`foo'の出現をみつける
たびに、その出現を表示し、置換するかどうか聞いてきます。質問する以外は
`query-replace' は `replace-string' のように機能します．通常どおり
`case-replace'が`nil'以外であれば、`replace-string'と同じく、このコマン
ドも大文字小文字の違いを保存します。`query-replace'に数引数を指定すると、
単語区切り文字で区切られた出現だけを対象とします。


`C-M-%' は正規表現を検索し置換します (`query-replace-regexp')．

文字の出現や正規表現に一致したものが表示されたときに打てる文字はつぎの
とおりです。


`SPC'
     出現をNEWSTRINGで置換する。

`DEL'
     この出現を置換せずにつぎの出現箇所に進む。

`, （カンマ）'
     この出現を置換し、結果を表示する。そして、つぎに何をするか指示する
     文字を聞いてくる。置換自体はすでに完了しているので、この状況では
     DELとSPCは等価であり、つぎの出現箇所へ移動するという意味。

     この時点では、`C-r'（下記参照）を打って、置換したテキストを変更で
     きる。また、`C-x u'と打って、置換をアンドゥする（もとに戻す）こと
     もできるが、そうすると、`query-replace'を終了してしまう。さらに先
     の置換を行いたいときには、`C-x ESC ESC RET'を使って再開する必要が
     ある（*Note Repetition::）。

`RET'
     これ以上何も置換しないで終了する。

`. （ピリオド）'
     この出現を置換してから、これ以上探索せずに終了する。

`!'
     これ以降、問い合わせずに残りの出現すべてを置換する。

`^'
     誤って変更してしまった場合などに、
     1つまえの出現箇所（あるいは置換してしまった出現箇所）に戻る。
     これは、マークリングから位置を取り出して動作する。
     `query-replace'は直前の1つの置換位置だけを記録するため、
     `^'を続けて入力しても意味はない。

`C-r'
     単にNEWSTRINGで置換するだけでなく、
     この出現を編集する必要がある場合などに、再帰編集レベルに入る。
     編集し終えて`C-M-c'で再帰編集を抜けると、つぎの出現箇所に移動する。
     *Note Recursive Edit::。

`C-w'
     出現を削除してから、`C-r'と同様に再帰編集レベルに入る。再帰編集を
     使って、削除したSTRINGの出現を置き換えるテキストを挿入する。編集し
     終えて`C-M-c'で再帰編集を抜けると、つぎの出現箇所に移動する。

`e'
     ミニバッファで置換する文字を編集する．ミニバッファから RET で抜け
     るとミニバッファの内容で現在の一致箇所を置換する．続く一致箇所でも
     新しい文字で置換されます．

`C-l'
     画面を再表示する。そうしたら、この出現に対して何を行うかを指示する
     別の文字を打つ必要がある。

`C-h'
     これらのオプションの要約メッセージを表示する。そうしたら、この出現
     に対して何を行うかを指示する別の文字を打つ必要がある。

上記のコマンドの別名である文字が他にもいくつかあります。
`y'、`n'、`q'は、それぞれ、
SPC、DEL、RETに等価です。

これ以外の文字は`query-replace'を終了し、
その文字はキー列の一部になります。
したがって、`C-k'と打つと、
`query-replace'を終了してから、行末までをキルします。

一度抜けた`query-replace'を再開するには、
`C-x ESC ESC'を使います。
このコマンドは`query-replace'を繰り返します。
というのは、`query-replace'はミニバッファで引数を読み取るからです。
*Note C-x ESC ESC: Repetition。

ファイル名に対して正規表現に一致する部分を置換することで、
ファイルの改名、コピー、リンクを行うdiredコマンドについては、
*Note Transforming File Names::も参照してください。



File: emacs-ja, Node: Other Repeating Search, Prev: Replace, Up: Search

他の探索繰り返しコマンド *(2004/03/27)*
=======================================

正規表現に一致するものをみつけるコマンドは、他にもいくつかあります。そ
れらは、パターンに大文字が含まれていないときや、`case-fold-search'が
`nil'以外であるときには、大文字小文字の違いを無視して一致を探します。
`occur' や同種のコマンドを除くと，ポイント位置からバッファの末尾までか
暫定マークモード(Transient Mark mode) でアクティブなリージョンを操作対
象とします．



`M-x occur RET REGEXP RET'
     REGEXPに一致するものを含むバッファ内の各行の一覧を表示する。バッファ
     の一部に探索を制限するには、その部分にナロイングする（*Note
     Narrowing::）。数引数 Nで、一致した各行の前後N行を表示するように指
     定できる．

     出力を表示したバッファ`*Occur*'は、もとの文脈での出現位置を探すた
     めのメニューとして機能する。`*Occur*'に表示された出現を`Mouse-2'で
     クリックするか、あるいは、ポイントをそこに置いてRETを打つ。この操
     作により、探索を行ったバッファに切り替え、選択した出現のもとの位置
     にポイントを移動する。`o' や `C-o' は一致箇所を別ウィンドウに表示
     します．ただし，`C-o' は選択はしません．

`M-x list-matching-lines'
     `M-x occur'と同じ。

`M-x multi-occur RET BUFFERS RET REGEXP RET'
     この関数は複数のバッファを検索できることを除けば，`occur' と同様の
     ものである．

`M-x multi-occur-by-filename-regexp RET BUFREGEXP RET REGEXP RET'
     この関数は `multi-occur' と同様のものである．ただ，検索するバッファ
     をそのファイル名に対する正規表現で指定できる．

`M-x how-many RET REGEXP RET'
     ポイント以降でREGEXPに一致するものの個数を表示する。暫定マークモー
     ド(Transient Mark mode)ではリージョンが有効であれば，このコマンド
     はリージョン内だけを対象に動作する．

`M-x flush-lines RET REGEXP RET'
     ポイント以降にあってREGEXPに一致するものを含む各行を削除する。暫定
     マークモード(Transient Mark mode)ではリージョンが有効であれば，こ
     のコマンドはリージョン内だけを対象に動作する．

`M-x keep-lines RET REGEXP RET'
     ポイント以降にあってREGEXPに一致するものを含ま*ない*各行を削除する。
     暫定マークモード(Transient Mark mode)ではリージョンが有効であれば，
     このコマンドはリージョン内だけを対象に動作する．

タグテーブル (*Note Tags Search::) で複数のファイルを検索することができ
ます．あるいはDired で `A' (*Note Operating on Files::) を入力したり，
`grep' (*Note Grep Searching::) を利用しても複数のファイルを検索できま
す．



File: emacs-ja, Node: Fixit, Next: Keyboard Macros, Prev: Search, Up: Top

打ちまちがい訂正用コマンド
**************************

本章では、入力直後にテキストのまちがいに気づいたとき、あるいは、テキス
トを作成中に気が変わったときに特に便利なコマンドを説明します。

まちがった編集を訂正するもっとも基本的なコマンドは、アンドゥコマンド、
`C-x u'や`C-_'です。このコマンドは、（通常）1つのコマンド、コマンドの一
部分（`query-replace'の場合）、いくつかの連続した自己挿入文字をアンドゥ
します。`C-_'や`C-x u'を連続して繰り返すと、アンドゥ情報がある限り、次々
と以前の変更をアンドゥします。より詳しくは、*Note Undo::。

* Menu:

* Kill Errors:: Commands to kill a batch of recently entered text.
* Transpose::   Exchanging two characters, words, lines, lists...
* Fixing Case:: Correcting case of last word entered.
* Spelling::    Apply spelling checker to a word, or a whole file.



File: emacs-ja, Node: Kill Errors, Next: Transpose

誤りの訂正
==========

`DEL'
     ポイントの直前の文字を削除する（`delete-backward-char'）。
`M-DEL'
     ポイントの直前の単語をキルする（`backward-kill-word'）。
`C-x DEL'
     ポイントから文の先頭までをキルする（`backward-kill-sentence'）。

DEL文字（`delete-backward-char'）はもっとも重要な訂正コマンドです。ポイ
ントの直前にある文字を削除します。自己挿入文字のコマンドに続けてDELを打
つと、そのコマンドを取り消すと考えることができます。しかし、コマンドを
取り消す一般的な方法はDELであるなどと誤解しないでください。

まちがいが数文字よりも長いときには、
`M-DEL'や`C-x DEL'を使うほうが便利でしょう。
`M-DEL'は直前の単語の先頭までをキルし、
`C-x DEL'は直前の文の先頭までをキルします。
文を書いている途中で気が変わったときには、
`C-x DEL'が特に便利です。
`M-DEL'と`C-x DEL'は、
キルしたテキストを`C-y'や`M-y'で戻せるように保存します。
*Note Yanking::。

何を打とうとしているのか混乱したりわからなくなったりしたときには、打ち
まちがいがたとえ数文字であっても`M-DEL'はとても便利です。このような場合、
画面を見ながらでないとDELでは訂正できません。`M-DEL'ならば、ほとんど何
も考えずに単語全体をキルして、入力を再開できます。



File: emacs-ja, Node: Transpose, Next: Fixing Case, Prev: Kill Errors

テキストの入れ替え
==================

`C-t'
     2つの文字を入れ替える（`transpose-chars'）。
`M-t'
     2つの単語を入れ替える（`transpose-words'）。
`C-M-t'
     釣り合っている2つの式を入れ替える（`transpose-sexps'）。
`C-x C-t'
     2つの行を入れ替える（`transpose-lines'）。

2つの文字を入れ替えてしまうというよくあるまちがいは、
それらが隣接しているならば、
`C-t'コマンド（`transpose-chars'）で直せます。
通常、`C-t'は、ポイントの両側にある文字を入れ替えます。
行末では、行末の文字と改行文字を入れ替えるという役に立たない
ことではなくて、`C-t'はその行の最後の2文字を入れ替えます。
よって、入れ替えまちがいにすぐに気づいたなら、
`C-t'だけで訂正できます。
まちがいにすぐに気づかなかったときには、
2つの入れ替わっている文字のあいだにカーソルを移動する必要があります。
空白とそのまえの単語の最後の文字とを入れ替えてしまったときには、
単語移動コマンドでその場所へ戻るのがよいでしょう。
それ以外の場合には、後向き探索（`C-r'）が最良であることがままあります。
*Note Search::。


`M-t'（`transpose-words'）は、
ポイントの直前の単語とポイントの直後の単語を入れ替えます。
ポイントは単語を1つ前向きに横断し、
ポイントの直前の単語かポイントを含む単語を前向きに引きずっていきます。
単語のあいだにある句読点文字は動きません。
たとえば、`FOO, BAR'は`BAR FOO,'ではなくて、
`BAR, FOO'と入れ替わります。

`C-M-t'（`transpose-sexps'）は、2つの式（*Note Lists::）を入れ替えるコ
マンドです。また、`C-x C-t'（`transpose-lines'）は、行を入れ替えます。
これらのコマンドは`M-t'に似た動作をしますが、テキストを構文単位に分ける
点が異なります。

入れ替えコマンドに数引数を指定すると、反復回数になります。
ポイントの直前やポイントを含む文字（単語、S式、行）を
いくつ先の文字（単語、S式、行）へ移動するか指定します。
たとえば、`C-u 3 C-t'は、ポイントの直前の文字を3文字先の文字へ移動します。
つまり、`f-!-oobar'を`oobf-!-ar'にします。
これは `C-t'を3回繰り返したのと同じことです。
`C-u - 4 M-t'は、ポイントの直前の単語を4つまえの単語へ移動します。
`C-u - C-M-t'は、引数を指定しない`C-M-t'の効果を打ち消します。

数引数0には特別な意味があります（さもないと、コマンドを0回繰り返しても
何もしない）。ポイントの直後の文字（単語、S式、行）とマークの直後の文字
（単語、S式、行）を入れ替えます。



File: emacs-ja, Node: Fixing Case, Prev: Transpose

大文字小文字変換
================

`M-- M-l'
     ポイントの直前の単語を小文字に変換する。
     `Meta--'はメタ・マイナス。
`M-- M-u'
     ポイントの直前の単語をすべて大文字に変換する。
`M-- M-c'
     ポイントの直前の単語を最初の文字だけ大文字にして残りを小文字にする。

とてもよくあるまちがいは、単語を打つときに大文字小文字をまちがうことです。
このため、単語の大文字小文字を変換するコマンド、
`M-l'、`M-u'、`M-c'に負の引数を指定すると、
カーソル（ポイント）を移動しないという特別な機能があります。
単語を打ちまちがえたとすぐに気づいたときには、
単に大文字小文字を変換して、入力を続けられます。
*Note Case::。



File: emacs-ja, Node: Spelling, Prev: Fixing Case

綴りの検査と訂正
================

本節では、1つの単語やバッファのある部分の綴りを検査するコマンドを説明し
ます。これらのコマンドは、Emacsの一部ではない綴り検査プログラム（スペル
チェッカ）ispellを使って動作します。
*Note Ispell: (ispell.info)Top。

`M-x flyspell-mode'
     フライスペル（flyspell）モードをオンにする。綴り誤りのあるすべての
     単語を強調表示する。
`M-$'
     ポイント位置にある単語の綴りを検査し訂正する（`ispell-word'）。
`M-TAB'
     綴り辞書に基づいてポイントの直前の単語を補完する
     （`ispell-complete-word'）。
`M-x ispell-buffer'
     バッファ内の各単語の綴りを検査し訂正する。
`M-x ispell-region'
     リージョン内の各単語の綴りを検査し訂正する。
`M-x ispell-message'
     引用部分を除いて、メイルメッセージの草稿の各単語の綴りを検査し訂正
     する。
`M-x ispell-change-dictionary RET DICT RET'
     辞書としてDICTを使ってispellプロセスを再起動する。
`M-x ispell-kill-ispell'
     ispellプロセスを終了させる。

フライスペル（flyspell）モードは、
Emacsで編集しているときに全自動で綴り検査をする方法です。
単語を変更したり挿入したりするたびにその単語を検査します。
認識できない単語をみつけると、その単語を強調表示します。
これはユーザーの編集には干渉しませんが、
ある単語が強調表示されたら、その単語へ移動して訂正できます。
カレントバッファでこのモードをオン／オフするには、
`M-x flyspell-mode'と打ちます。

フライスペル（flyspell）モードがある単語を綴りまちがいであると強調表示
したときには、その単語を`Mouse-2'でクリックできます。すると、訂正候補や
どんな操作を行えるか表示されます。単語を手動で編集して好きなように訂正
してもかまいません。

Emacsの他の綴り検査機能は、明示的にコマンドを実行したときに単語の検査を
行います。バッファ全体やその一部分の綴りを検査する機能は、Emacsセッショ
ン以外で作成した綴り誤りを含むかもしれないテキストには有益です。

ポイントの周りかポイントのつぎにある単語の綴りを検査し、場合によっては
訂正するには、`M-$'（`ispell-word'）コマンドを使います。単語が正しくな
いときには、その単語についてどうするかのさまざまな選択肢を提示します。

カレントバッファ全体を検査するには、`M-x ispell-buffer'を使います。カレ
ントリージョンだけを検査するには、`M-x ispell-region'を使います。書きか
けの電子メイルメッセージの綴りを検査するには、`M-x ispell-message'を使
います。これは、バッファ全体を検査しますが、字下げしてある部分や他のメッ
セージからの引用と思われる部分は検査しません。

これらのコマンドは、正しくない単語に出会うたびに、どうするか聞いてきま
す。通常、検査した単語に似ている『近い』単語をいくつか含めた選択肢一覧
を表示します。そうしたら、文字を打たなくてはなりません。以下に有効な返
答をあげます。

`SPC'
     この単語をスキップする。この単語は正しくないとしておくが、ここでは
     変更しない。

`r NEW RET'
     （今回だけは）NEWで置き換える。

`R NEW RET'
     単語をNEWで置き換える。
     さらに、バッファの他の箇所でも置き換えられるように
     `query-replace'を実行する。

`DIGIT'
     （今回だけは）この単語を『近い』単語の1つで置き換える。『近い』単
     語にはそれぞれ数字が付いているので、その数字を打つ。

`a'
     正しくない単語を容認する。この編集セッションに限って、正しいかのよ
     うに扱う。

`A'
     正しくない単語を容認する。この編集セッションのこのバッファに限って、
     正しいかのように扱う。

`i'
     この単語を個人辞書ファイルに入れ、ispellは今後のセッションを含めて
     これ以降この単語を正しいものとして扱う。

`u'
     この単語を小文字に変換して個人辞書ファイルに入れる。

`m'
     `i'と同様だが、辞書の補完情報も記録できる。

`l WORD RET'
     WORDに一致する単語を辞書から探す。
     みつかった単語は、新たな『近い』単語一覧となり、
     数字を打って置き換える単語を選べる。
     WORDには、ワイルドカード`*'を使うこともできる。

`C-g'
     対話的な綴り検査を終了する。
     `C-u M-$'で、あとで再開できる。

`X'
     `C-g'と同じ。

`x'
     対話的な綴り検査を終了し、綴り検査を始めた箇所へポイントを戻す。

`q'
     対話的な綴り検査を終了し、ispellプロセスを終了させる。

`C-l'
     画面を再描画する。

`C-z'
     このキーは普通のコマンドの意味（Emacsを休止する、あるいは、このフ
     レームをアイコン化する）。

テキスト（text）モードやその関連したモードでは
`M-TAB'キーにバインドしてあるコマンド
`ispell-complete-word'は、
綴り訂正に基づいた補完一覧を提示します。
単語の始めの部分を挿入してから`M-TAB'と打つと、
補完一覧ウィンドウを表示します。
補完一覧から1つを選ぶには、
候補のうえで`Mouse-2'をクリックするか、
カーソルを補完ウィンドウの単語の箇所に移動してから
RETと打ちます。
*Note Text Mode::。


一度綴り検査を行うと、ispellプロセスは（何かすることを待って）動き続け
ます。ですから、つぎに綴り検査コマンドを使うと、より早く実行を完了しま
す。ispellプロセスを取り除きたいときには、`M-x ispell-kill-ispell'を使
います。ispellプロセスは綴り訂正をしているとき以外には何もしないので、
通常はこのコマンドを使う必要はありません。

ispellは2つの辞書を使います。標準辞書と個人辞書です。変数
`ispell-dictionary'は、使用すべき標準辞書のファイル名を指定します。この
値が`nil'ならば、デフォルトの辞書を使います。`M-x
ispell-change-dictionary'コマンドはこの変数を設定して、設定した辞書を使
うようにispellサブプロセスを再起動します。



File: emacs-ja, Node: Keyboard Macros, Next: Files, Prev: Fixit, Up: Top

キーボードマクロ *(2004/01/12)*
*******************************

この章では，編集作業を記録し，何度も繰り返す方法について紹介します．

"キーボードマクロ(keyboard macro)" はある一連のキー入力を表すもので，ユー
ザによって定義されます．たとえば，`C-n C-d'を40回も入力していることに気
付いたとしましょう．その時，`C-n C-d' を40回呼び出すようなキーボードマ
クロを定義すれば，作業効率を高めることができます．

"キーボードマクロ"は、ユーザーが一連のキー操作に基づいて定義したコマン
ドです。たとえば、`C-n C-d'という打鍵を40回繰り返す必要があるとわかった
ら、`C-n C-d'を実行するキーボードマクロを定義し、それを40回繰り返す指定
をして呼び出すと迅速に作業できます。

`C-x ('
     キーボードマクロの定義を開始する（`start-kbd-macro'）。
`C-x )'
     キーボードマクロの定義を終了する（`end-kbd-macro'）。
`C-x e'
     もっとも最近のキーボードマクロを実行する（`call-last-kbd-macro'）。
`C-u C-x ('
     もっとも最近のキーボードマクロを再実行したうえで、その定義にキーを
     追加する。
`C-x q'
     キーボードマクロの実行中にこの場所に到達したら、実行の確認を求める
     （`kbd-macro-query'）。
`M-x name-last-kbd-macro'
     もっとも最近に定義したキーボードマクロに（現在のEmacsセッションだ
     けで有効な）コマンド名を与える。
`M-x insert-kbd-macro'
     キーボードマクロの定義をLispコードとしてバッファに挿入する。
`C-x C-k'
     まえに定義したキーボードマクロを編集する（`edit-kbd-macro'）。
`M-x apply-macro-to-region-lines'
     リージョン内の各行に対して、最後に定義したキーボードマクロを実行す
     る。

キーボードマクロは、それがLispではなくEmacsのコマンド言語で記述されてい
るという点で、通常のEmacsコマンドとは違っています。このため、キーボード
マクロは初心者でも簡単に作れ、間に合わせとして定義するのにも向いていま
す。しかし、Emacsのコマンド言語は、プログラム言語として知的で汎用的な動
作を記述できるほど強力ではありません。そういう場合には、Lispを使ってく
ださい。

キーボードマクロは、定義内容のコマンド列を実際に実行しながら定義できま
す。いいかえれば、キーボードマクロを定義しているときに、その定義の第1回
目の実行が行われることになります。ですから、コマンドがどのように動作す
るかを目で見ながら確認でき、頭の中だけで動作を考えるよりも楽に定義でき
ます。コマンド列の最後まできてキーボードマクロを定義し終ると、第1回目の
実行も終ったことになります。そのあとは、マクロを呼び出すことで何回でも
そのコマンド列全体を実行できます。

* Menu:

* Basic Kbd Macro::     Defining and running keyboard macros.
* Save Kbd Macro::      Giving keyboard macros names; saving them in files.
* Kbd Macro Query::     Making keyboard macros do different things each time.



File: emacs-ja, Node: Basic Kbd Macro, Next: Save Kbd Macro, Prev: Keyboard Macros, Up: Keyboard Macros

基本的な使い方
--------------

キーボードマクロの定義を開始するには、`C-x ('コマンド
（`start-kbd-macro'）を打ってください。それ以降打鍵するものは通常どおり
実行されますが、それと同時にキーボードマクロの定義として取り込まれます。
モード行にもそのことを表す`Def'という表示が現れます。定義の終りまできた
ら、`C-x )'（`end-kbd-macro'）を打ち込むとキーボードマクロの定義が完了
します（`C-x )'はマクロの内容には含まれません！）。たとえば、

     C-x ( M-f foo C-x )

のように打鍵すると、1単語分ポイントを前進させ文字列`foo'をバッファに挿
入する、キーボードマクロを定義できます。

定義し終えたキーボードマクロは、コマンド`C-x e'（`call-last-kbd-macro'）
で再実行できますし、数引数として反復回数を指定することで多数回実行する
こともできます。`C-x )'にも引数として反復回数を指定でき、その場合は定義
完了とともにただちに指定した回数だけキーボードマクロを実行しますが、定
義しているとき（実行しているので）を1回目の実行として数えます。ですから、
`C-u 4 C-x )'と打つと、キーボードマクロをただちに3回実行します。`C-x
e'や`C-x )'に反復回数0を指定すると、キーボードマクロを無限回、つまり、
エラーが発生するか、`C-g'（MS-DOSでは`C-BREAK'）が打鍵されるまで、繰り
返し実行します。

テキスト上の規則的にとびとびの位置に対して操作を行いたい場合には、キー
ボードマクロを定義するときに、つぎに適用したい位置までポイントを移動す
るコマンドを含めておきます。たとえば、各行について変更を行いたければ、
ポイントを行頭に置いてからキーボードマクロを定義し始め、最後にポイント
をつぎの行の行頭に置いたところで定義を終えます。キーボードマクロを繰り
返し実行すると、次々と連続する行に対して操作を実行できます。

キーボードマクロの定義を完了してしまったあとでも、`C-u C-x ('を打ち込め
ば、その定義の末尾に内容を追加できます。このコマンドは、`C-x ('に続いて
現在のキーボードマクロの定義内容全体を打鍵したのと同じ効果を持ちます。
その結果、定義されたとおりにマクロを再実行します。

キーボードマクロの中で、通常のキーと同様にファンクションキーを使うこと
もできます。マウスイベントを使うことさえできますが、その場合は注意して
ください。キーボードマクロはマウスイベントを再現しますが、マウス位置と
しては最初にキーボードマクロを定義したときの位置がそのまま使われます。
その結果は予想し難いものになります。（現在のマウス位置を使っても、結果
はさらに予想し難いものになる。）

キーボードマクロの中で必ずうまくいくとは限らないことの1つに、
`C-M-c'（`exit-recursive-edit'）コマンドがあります。このコマンドがマク
ロの中で開始させた再帰編集を終らせる場合には、期待どおりに動くでしょう。
しかし、このコマンドがキーボードマクロを起動するまえに入っていた再帰編
集を終らせるとすると、その終了処理の過程でキーボードマクロの実行も終ら
せてしまいます。

定義済みのキーボードマクロを編集するには、`C-x C-k'（`edit-kbd-macro'）
と打ちます。このコマンドに続けてマクロを起動する打鍵、つまり、`C-x e'や
`M-x NAME'などのキー列を入れます。すると、キー列に対応するキーボードマ
クロの内容が整形されて特別な編集用メジャーモードのバッファに入ります。
そのバッファ中で`C-h m'と打つと編集方法が表示されます。編集し終えたら
`C-c C-c'と打ちます。

コマンド`M-x apply-macro-to-region-lines'は最後に定義されたキーボードマ
クロを現在のリージョンの各行に対して実行します。つまり、各行について、
行頭にポイントを置いてからキーボードマクロを実行します。



File: emacs-ja, Node: Save Kbd Macro, Next: Kbd Macro Query, Prev: Basic Kbd Macro, Up: Keyboard Macros

キーボードマクロの命名と保存
----------------------------

新たにつぎのキーボードマクロを定義したあとでも現在のキーボードマクロを
使いたいなら、`M-x name-last-kbd-macro'でキーボードマクロに名前を付けて
おく必要があります。このコマンドは、ミニバッファで名前を読み取り、その
名前でキーボードマクロを実行できるように定義します。マクロ名はLispシン
ボルであり、このように定義されているので、`M-x'で呼び出したり
`global-set-key' （*Note Keymaps::）でキーに対応付けたりできる有効なコ
マンド名になります。その名前にキーボードマクロ以外のものがすでに定義さ
れていると、エラーメッセージが表示され何の変更も起こりません。

キーボードマクロにコマンド名を付けると、その定義をファイルに保存できま
す。そうすると、別の編集セッションで使えるようになります。まず、定義を
保存したいファイルを訪問してから、つぎのコマンドを使ってください。

     M-x insert-kbd-macro RET MACRONAME RET

このコマンドは、実行するとそのキーボードマクロと同じ動作を行うLispコー
ドをバッファに挿入します。（`insert-kbd-macro'がLispコードの生成を代行
するので、Lispコードを理解する必要はない。）そうしたら、このファイルを
保存します。`load-file'（*Note Lisp Libraries::）でファイルをロードでき
ます。保存するファイルとして`~/.emacs'（*Note Init File::）を使えば、
Emacsを起動するとつねにそのマクロが定義されます。

`insert-kbd-macro'に数引数を指定すると、さらに（もしあれば）キーボード
マクロに割り当てたキーを記録するLispコードが追加されるので、ファイルを
ロードしたときに同じキーがマクロに割り当てられます。



File: emacs-ja, Node: Kbd Macro Query, Prev: Save Kbd Macro, Up: Keyboard Macros

変化のあるマクロの実行
----------------------

`C-x q'（`kbd-macro-query'）を使うと、`query-replace'と同様に変更するか
どうか尋ねてくるキーボードマクロを作れます。キーボードマクロを定義して
いるときに、問い合わせが起きてほしい箇所で`C-x q'を打ちます。マクロの定
義中は`C-x q'は何の動作もしませんが、あとでマクロを実行させたときには
`C-x q'の箇所で処理を続けるかどうか尋ねてくるようになります。

`C-x q'の問い合わせに対する有効な応答は、SPC（または`y'）、
DEL（または`n'）、RET（または`q'）、`C-l'、
`C-r'です。
これらの意味は`query-replace'と同じですが、
`query-replace'のすべての応答が意味を持つとは限りません。

SPCは続行、DELはこの回の反復の残りを飛ばしてただちにつぎの
反復に進むという意味になります。
RETではこの回の反復の残りも以後の反復もすべて取り消します。
`C-l'は画面を再描画し、再度どうするかを問い合わせてきます。

`C-r'で再帰編集レベルに入るので、そこでキーボードマクロにはない編集を行
えます。`C-M-c'で再帰編集から抜けると、再度どうするかを聞いてきます。こ
こでSPCを打つと、キーボードマクロの残りの部分が実行されます。キーボード
マクロの残りの部分が望みどおりの動作をする状態にポイントやテキストを保っ
ておくのは、ユーザーの責任です。

`C-u C-x q'、つまり、数引数を指定した`C-x q'は、
まったく違った動作をします。
キーボードマクロの定義中でも実行中でも、
キーボードから入力を受け付ける再帰編集に入ります。
定義中の場合、再帰編集の中で行った操作はマクロの一部にはなりません。
実行中の場合、再帰編集の中で各反復ごとに個別の編集を行う機会が得られます。
*Note Recursive Edit::。


File: emacs-ja, Node: Files, Next: Buffers, Prev: Keyboard Macros, Up: Top

ファイルの扱い方
****************

オペレーティングシステムは、データを指定した"ファイル"（file）に恒久的
に保存します。ですから、Emacsで編集するテキストの多くはファイルから取り
込み、最終的にはファイルに格納されます。

ファイルを編集するには、Emacsに対してファイルを読むように指示して、ファ
イルの内容のコピーを入れたバッファを用意させる必要があります。これを、
ファイルを"訪問する／訪れる"（visiting）といいます。編集コマンドはバッ
ファ内のテキストに直接作用します。つまり、Emacs内にあるコピーを操作しま
す。バッファをファイルに"保存"（save）した場合に限り、変更はファイルそ
のものに反映されます。

ファイルを訪問したり保存したりすることに加えて、Emacsは、ファイルを、削
除したり、コピーしたり、名前を変更したり、別のファイルへ追加したり、複
数の版を保持したり、ファイルディレクトリを操作したりできます。

* Menu:

* File Names::          How to type and edit file-name arguments.
* Visiting::            Visiting a file prepares Emacs to edit the file.
* Saving::              Saving makes your changes permanent.
* Reverting::           Reverting cancels all the changes not saved.
* Auto Save::           Auto Save periodically protects against loss of data.
* File Aliases::        Handling multiple names for one file.
* Version Control::     Version control systems (RCS, CVS and SCCS).
* Directories::         Creating, deleting, and listing file directories.
* Comparing Files::     Finding where two files differ.
* Misc File Ops::       Other things you can do on files.
* Compressed Files::    Accessing compressed files.
* Remote Files::        Accessing files on other sites.
* Quoted File Names::   Quoting special characters in file names.



File: emacs-ja, Node: File Names, Next: Saving

ファイル名
==========

ファイルを操作するほとんどのEmacsコマンドには、
ファイル名を指定する必要があります。
（保存と復元の操作を除く。
バッファはこれらの操作に対して使うファイル名を記録している。）
ファイル名は、ミニバッファを使って入力します（*Note Minibuffer::）。
長いファイル名の指定を簡単にする補完も使えます。
*Note Completion::。

多くの操作には、"デフォルトファイル名"があり、RETだけを打って空の引数を
指定した場合に使われます。通常、デフォルトファイル名は、カレントバッファ
で訪問したファイルの名前です。こうすることで、Emacsのファイルコマンドで
当該ファイルを操作するのが簡単になります。

各バッファにはデフォルトディレクトリがあります。通常は、そのバッファの
訪問先のファイルのディレクトリと同じです。ディレクトリを指定しないでファ
イル名を入力すると、デフォルトディレクトリを使います。スラッシュ（`/'）
で始まらない相対的なディレクトリを指定すると、デフォルトディレクトリ相
対に解釈します。デフォルトディレクトリは変数`default-directory'に保持さ
れていて、バッファごとに別々の値を持ちます。

たとえば、デフォルトファイル名が`/u/rms/gnu/gnu.tasks'ならば、
デフォルトディレクトリは`/u/rms/gnu/'です。
ディレクトリを指定しないで`foo'とだけ打つと、
`/u/rms/gnu/foo'を意味します。
`../.login'は、`/u/rms/.login'を意味します。
`new/foo'は、ファイル名`/u/rms/gnu/new/foo'を意味します。

コマンド`M-x pwd'は、カレントバッファのデフォルトディレクトリを表示し、
コマンド`M-x cd'は、それを（ミニバッファで読んだ値に）設定します。バッ
ファのデフォルトディレクトリは、`cd'コマンドを使ったときだけ変更されま
す。ファイルを訪問しているバッファのデフォルトディレクトリは、訪問した
ファイルのディレクトリに初期化されます。`C-x b'で作ったバッファのデフォ
ルトディレクトリは、その時点のカレントバッファのデフォルトディレクトリ
と同じです。

デフォルトディレクトリは、ミニバッファでファイル名を読むときに、実際に
ミニバッファに表示されます。これには2つの目的があります。デフォルトが何
であるかを*示す*ことで、相対ファイル名を打ち込めるようにし、しかも、そ
の意味を確実に知ることができるようにします。もう1つは、デフォルトディレ
クトリを*編集*して、別のディレクトリを指定できるようにします。変数
`insert-default-directory'を`nil'に設定すると、デフォルトディレクトリを
挿入しません。

ミニバッファで入力するとき、
テキストの一部として入っているデフォルトディレクトリを無視して、
絶対ファイル名を打っても何の問題もありません。
最終的なミニバッファの内容は不正なように見えても、
そうではありません。
たとえば、ミニバッファには`/usr/tmp/'が入っていて
`/x1/rms/foo'を追加すると、`/usr/tmp//x1/rms/foo'となります。
Emacsは連続した2個のスラッシュの始めのスラッシュまでをすべて無視するので、
結果として`/x1/rms/foo'となります。
*Note Minibuffer File::。

ファイル名の中の`$'は環境変数で置き換えられます。たとえば、シェルコマン
ド`export FOO=rms/hacks'で、環境変数`FOO'を設定してあるとします。そうす
ると、`/u/rms/hacks/test.c'の略称として`/u/$FOO/test.c'や
`/u/${FOO}/test.c'を使えます。環境変数の名前は、`$'のうしろにある英数字
全部です。あるいは、`$'のうしろにある括弧で囲まれたものです。シェルコマ
ンドで設定した環境変数がEmacsに影響を及ぼすのは、Emacsを起動するまえに
設定したものに限ります。

名前の中に`$'があるファイルを参照するには、`$$'と打ちます。1個の`$'に対
して変数の置き換えを行うときに、この2個の`$'は1個の`$'に変換されます。
あるいは、ファイル名全体を`/:'でクォートします（*Note Quoted File
Names::）。

（変数の）置き換えを行うLisp関数は`substitute-in-file-name'です。置き換
えは、ミニバッファで読んだファイル名だけに適用されます。

変数`file-name-coding-system'に`nil'以外を設定すると、
ファイル名に非ASCIIを含めることができます。
*Note Specify Coding::。



File: emacs-ja, Node: Visiting, Next: Saving

ファイルを訪問する
==================

`C-x C-f'
     ファイルを訪問する（`find-file'）。
`C-x C-r'
     ファイルを眺めるために訪問し、変更を許さない
     （`find-file-read-only'）。
`C-x C-v'
     最後に訪問したファイルのかわりに、別のファイルを訪問する
     （`find-alternate-file'）。
`C-x 4 f'
     別のウィンドウでファイルを訪問する（`find-file-other-window'）。選
     択されているウィンドウに表示されている内容は変化しない。
`C-x 5 f'
     新たなフレームでファイルを訪問する（`find-file-other-frame'）。選
     択されているフレームに表示されている内容は変化しない。
`M-x find-file-literally'
     ファイルの内容をいっさい変換せずに訪問する。

ファイルを"訪問する／訪れる"とは、
ファイルの内容のコピーを編集できるようにEmacsバッファに入れることです。
Emacsは、訪問する各ファイルごとに新たにバッファを作ります。
バッファ名は、ディレクトリ部分を取りさったファイル名から作ります。
たとえば、ファイル名`/usr/rms/emacs.tex'の
バッファ名は`emacs.tex'となります。
その名前のバッファがすでに存在するならば、
まだ使われていない名前になるようなもっとも小さい数を使って、
`<2>', `<3>'などを付加して唯一の名前を作ります。

各ウィンドウのモード行にはウィンドウ内に表示しているバッファ名が示され
ているので、編集しているバッファが何かいつでもわかります。

編集コマンドによる変更は、Emacsバッファに対して行われます。
バッファを"保存"するまでは、
変更は、訪問先のファイルや他のどんな恒久的なものにも影響しません。
バッファを保存するとは、
バッファの現在の内容をそのバッファの訪問先のファイルに書き出すことです。
*Note Saving::。

バッファに未保存の変更がある場合、バッファは"変更されている"といいます。
バッファを保存しないと変更内容が失われてしまうので、これは重要なことで
す。モード行の左端近くに2個の星印を表示して、バッファが変更されているこ
とを示します。

ファイルを訪問するには、コマンド`C-x C-f'（`find-file'）を使います。こ
のコマンドに、訪問したいファイル名を続けてRETで終えます。

ファイル名はミニバッファ（*Note Minibuffer::）で読まれ、このときデフォ
ルトや標準的な方法の補完を使えます（*Note File Names::）。ミニバッファ
内で`C-g'と打てば、`C-x C-f'をアボートできます。

`C-x C-f'が正しく完了したことは、画面上に新たに現れるテキストとモード行
に現れる新たなバッファ名で確認できます。指定したファイルが存在せず作成
もできない場合や読めない場合には、エコー領域にエラーメッセージが表示さ
れます。

すでに訪問しているファイルを再度訪問すると、
`C-x C-f'は別のコピーを作らずに、
そのファイルを入れた既存のバッファを選択します。
しかし、そうするまえに、訪問してから、あるいは、保存してから以降に
ファイルが変更されたかどうか検査します。
ファイルが変更されていると警告メッセージを表示します。
*Note Interlocking::。

新たにファイルを作りたいときにはどうするのでしょう？` ' 単に訪問すれば
よいのです。Emacsはエコー領域に`(New File)'と表示しますが、それ以外に関
しては、あたかも空のファイルが存在するかのようにふるまいます。変更して
から保存すれば、ファイルを作成できます。

Emacsはファイルの内容から、行区切りの方法、すなわち、（GNU/LinuxやUNIX
で使われる）改行、（Microsoftシステムで使われる）復帰改行、
（Machintoshで使われる）復帰のみを認識します。さらに、Emacsの通常の方法、
つまり、改行文字で行を区切るように内容を自動的に変換します。これは、コー
ディングシステム変換（*Note Coding Systems::）の一般的な機能の一部であ
り、さまざまの異なるオペレーティングシステムから持ってきたファイルを同
一の方法で編集できるようにします。テキストを変更してファイルに保存する
と、Emacsは逆変換を行い、必要ならば、改行を復帰改行や復帰のみに戻します。

指定したファイルが実際にはディレクトリならば、`C-x C-f'はEmacsのディレ
クトリブラウザであるdiredを起動するので、ディレクトリの内容を『編集』で
きます（*Note Dired::）。diredは、ディレクトリ内のファイルを、消去した
り、眺めたり、操作するのに便利です。しかし、変数 `find-file-run-dired'
が`nil'ならば、ディレクトリを訪問しようとするとエラーになります。

指定したファイル名にワイルドカード文字が含まれていると、
Emacsは一致するすべてのファイルを訪問します。
ワイルドカード文字そのものを含む名前のファイルを訪問するには、
*Note Quoted File Names::。

オペレーティングシステムが変更を許さないファイルを訪問すると、
Emacsはバッファを読み出し専用に設定するので、
修正できなかったり、修正できてもあとで保存に手間取ります。
`C-x C-q'（`vc-toggle-read-only'）で、
バッファを書き込み可能にできます。
*Note Misc Buffer::。

ときには、自分でまちがって変更しないように、ファイルを読み出し専用で訪
問したい場合があります。そういう場合には、コマンド`C-x
C-r'（`find-file-read-only'）でファイルを訪問します。

（ファイル名をまちがって打ったりして）存在しないファイルを意図せずに訪
問してしまったときには、`C-x C-v'コマンド（`find-alternate-file'）を使っ
て本当の目的のファイルを訪問します。`C-x C-v'は`C-x C-f'と同様ですが、
（バッファが変更されていればまず保存するかどうか聞いてから）カレントバッ
ファを消去します。訪問するファイル名を読むときには、ミニバッファにデフォ
ルトファイル名全体を挿入し、ディレクトリ部分の直後にポイントを置きます。
これは、ファイル名をほんの少しまちがって入力したときに便利です。

存在するのに読めないファイルを訪問すると、
`C-x C-f'はエラーを通知します。

`C-x 4 f'（`find-file-other-window'）は、
別のウィンドウで、指定したファイルを入れたバッファを選択することを除けば、
`C-x C-f'と同じです。
`C-x 4 f'を実行するまえに選択されていたウィンドウは、
同じバッファを表示したままです。
ウィンドウを1つだけ表示しているときにこのコマンドを使うと、
そのウィンドウを2つに分けて、一方のウィンドウにはまえと同様に同じバッファを
表示しますが、もう一方には新たに指示したファイルを表示します。
*Note Windows::。

`C-x 5 f'（`find-file-other-frame'）も同様ですが、
新たなフレームを開くか、
捜しているファイルを表示している既存のフレームを見えるようにします。
ウィンドウシステムを使っているときだけ、
この機能を利用できます。
*Note Frames::。

特別な符号化や変換をせずにファイルを文字の列として編集したいときには、
`M-x find-file-literally'コマンドを使います。このコマンドは、`C-x C-f'
のようにファイルを訪問しますが、形式変換（*Note Formatted Text::）、文
字コード変換（*Note Coding Systems::）、（圧縮を）自動展開（*Note
Compressed Files::）といったことをしません。（そのままの文字の列として
ではなく）普通の方法で同じファイルをすでに訪問している場合には、このコ
マンドは、そのままの文字の列として訪問するかどうか聞いてきます。

2つの特別なフック変数で、ファイルを訪問する操作を修正して拡張できます。
存在しないファイルを訪問すると、
`find-file-not-found-hooks'のリスト内の関数群を実行します。
この変数は関数のリストを保持していて、
呼び出した関数の中のどれかが`nil'以外を返すまで1つ1つ順に呼び出します。
ファイルが存在するかどうかに関わらず、
どんなファイルを訪問するときでも
`find-file-hooks'には関数のリストが入っていると仮定され、
それらの1つ1つを順にすべて呼び出します。
いずれの場合でも、関数は引数を受け取りません。
2つの変数のうち、先に`find-file-not-found-hooks'を使います。
これらの変数はノーマルフックではありま*せん*。
これらの名前が`-hook'ではなくて`-hooks'で終っていることで、
その事実を表しています。
*Note Hooks::。

編集するファイルに対して自動的にメジャーモード（*Note Choosing Modes::）
を設定し、そのファイルに対して特別なローカル変数（*Note File
Variables::）を定義する方法がいくつかあります。



File: emacs-ja, Node: Saving, Next: Reverting

ファイルを保存する
==================

Emacsにおいてバッファを"保存"するとは、バッファの内容をそのバッファの訪
問先のファイルへ書き戻すことです。

`C-x C-s'
     カレントバッファを訪問先のファイルに保存する（`save-buffer'）。
`C-x s'
     任意のバッファかすべてのバッファをそれぞれの訪問先のファイルに保存
     する（`save-some-buffers'）。
`M-~'
     カレントバッファを変更していないことにする（`not-modified'）。
`C-x C-w'
     カレントバッファを指定したファイルに保存する（`write-file'）。
`M-x set-visited-file-name'
     カレントバッファを保存するファイルの名前を変更する。

ファイルを保存して変更を恒久的なものとするには、`C-x
C-s'（`save-buffer'）と打ちます。保存を完了すると`C-x C-s'はつぎのよう
なメッセージを表示します。

     Wrote /u/rms/gnu/gnu.tasks

選択されているバッファが変更されていなければ（バッファを作って以降、あ
るいは、最後に保存して以降に、変更されていない）、保存しても何もならな
いので実際には保存しません。かわりに、`C-x C-s'はつぎのようなメッセージ
をエコー領域に表示します。

     (No changes need to be saved)

コマンド`C-x s'（`save-some-buffers'）は、変更された任意のバッファやす
べてのバッファを保存できるようにします。各バッファについて、何をするか
聞いてきます。このとき選べる返答は、`query-replace'に対するものに似てい
ます。

`y'
     このバッファを保存し、残りのバッファについても質問する。
`n'
     このバッファを保存しないが、残りのバッファについては質問する。
`!'
     このバッファを保存し、残りのすべてのバッファについても質問せずに保
     存する。
`RET'
     何も保存せずに`save-some-buffers'を終了する。
`.'
     このバッファを保存し、他のバッファについては何も聞かずに
     `save-some-buffers'を終える。
`C-r'
     質問対象のバッファを閲覧する。閲覧（view）モードから抜けると、
     `save-some-buffers'に戻りふたたび質問する。
`C-h'
     これらのオプションについてのヘルプメッセージを表示する。

Emacsから抜けるキー列`C-x C-c'は、
`save-some-buffers'を起動するので、同じ質問をしてきます。

バッファを変更したけれども変更を保存したくないならば、それを避けるため
の処置をすべきでしょう。そうしないと、`C-x s'や`C-x C-c'を使うたびに、
まちがってバッファを保存してしまいがちです。1つの方法は、
`M-~'（`not-modified'）と打つことです。これは、バッファが変更されている
ことを示すフラグを消します。こうしておくと、保存コマンドはバッファを保
存する必要がないと結論します。（`~'は「否定」（not）を意味する数学記号
としてしばしば使われる。よって`M-~'は、メタ付き「否定」。）
`set-visited-file-name'（下記参照）を使って、別のファイルを訪問している
バッファである旨の印を付けることもできます。このときファイル名には、重
要でない使っていないものを指定します。あるいは、ファイルからテキストを
再度読み直して、ファイルを訪問したり保存したりした以降のすべての変更を
取り消します。これを"復元"（reverting）といいます。*Note Reverting::。
すべての変更がもとに戻るまでアンドゥコマンド`C-x u'を繰り返し使って、変
更しなかったことにもできます。しかし、復元のほうが簡単です。

`M-x set-visited-file-name'は、
カレントバッファで訪問しているファイルの名前を変更します。
このコマンドは、ミニバッファで新たなファイル名を読み取ります。
そして、訪問先ファイル名を設定し直し、
それに従って（新しい名前が使われていなければ）
バッファ名も変更します。
`set-visited-file-name'は、
新たに指定した訪問先のファイルへはバッファを保存しません。
あとで保存する場合に備えて、Emacs内部の記録を変更するだけです。
また、バッファには『変更された』旨の印を付け、
`C-x C-s'がそのバッファを保存*しようとする*ようにします。

別のファイルを訪問しているという旨の印をバッファに付けて、ただちに保存
したい場合には、`C-x C-w'（`write-file'）を使います。このコマンドは、
`set-visited-file-name'に続けて`C-x C-s'を実行するのと等価です。ファイ
ルを訪問していないバッファに対して`C-x C-s'を使うことは、`C-x C-w'と同
じ効果があります。つまり、ファイル名を読み取り、バッファにはそのファイ
ルを訪問しているという印を付け、バッファをそのファイルに保存します。ファ
イルを訪問していないバッファのデフォルトのファイル名は、バッファのデフォ
ルトディレクトリとバッファ名を組み合わせて作ります。

新しいファイル名がメジャーモードを示唆するものであれば、
`C-x C-w'は、多くの場合、そのメジャーモードに切り替えます。
コマンド`set-visited-file-name'もそのようにします。
*Note Choosing Modes::。

Emacsがファイルを保存しようとするときに、
ディスク上の最新版の日付がEmacsが最後に読み書きしたものと合わなかったら、
Emacsはそのことを通知します。
というのは、同時に編集したために引き起こされた問題である可能性があるので、
ユーザーにただちに知らせる必要があるからです。
*Note Interlocking::。

変数`require-final-newline'が`nil'以外だと、Emacsはファイルを保存するた
びに、ファイルの末尾に改行がなければ改行を挿入します。デフォルトは
`nil'です。

* Menu:

* Backup::              How Emacs saves the old version of your file.
* Interlocking::        How Emacs protects against simultaneous editing
                          of one file by two users.



File: emacs-ja, Node: Backup, Next: Interlocking, Prev: Saving, Up: Saving

バックアップファイル
--------------------

多くのオペレーティングシステムでは、ファイルを書き換えるとファイルに入っ
ていたそれまでの記録は自動的に破棄されます。したがって、Emacsでファイル
を保存すると、ファイルの古い内容は捨てられます。しかし、実際に保存する
まえに、古い内容を"バックアップ"ファイルと呼ばれる別のファイルにEmacsが
注意深くコピーすれば、古い内容は破棄されません。

ほとんどのファイルでは、バックアップファイルを作るかどうかは変数
`make-backup-files'で決まります。多くのオペレーティングシステムでは、こ
の変数のデフォルト値は`t'であり、Emacsはバックアップファイルを作ります。

版管理システム（*Note Version Control::）が管理するファイルに対しては、
バックアップファイルを作るかどうかは
変数`vc-make-backup-files'で決まります。
デフォルトは`nil'です。
というのは、すべての古い版を版管理システムに保管してあるので、
バックアップファイルは冗長だからです。
*Note VC Workfile Handling::。

変数`backup-enable-predicate'のデフォルト値は、`/tmp'にあるファイルのバッ
クアップファイルを作らないようにします。

Emacsでは、単一のバックアップファイルを保持することも、編集した各ファイ
ルごとに一連の番号付きバックアップファイルを保持することもできます。

Emacsがファイルのバックアップファイルを作るのは、バッファからそのファイ
ルへ最初に保存したときだけです。たとえ何度ファイルを保存したとしても、
そのバックアップファイルは、ファイルを訪問する以前の内容を保持し続けま
す。通常これは、今の編集セッションを始める以前の内容をバックアップファ
イルが保持していることを意味します。しかしながら、バッファを消去してか
ら再度ファイルを訪問すると、それ以降に保存するときには新たにバックアッ
プファイルを作ります。

少なくとも一度は保存したとしても、バッファからもう1つバックアップファイ
ルを作るように明示的に指示することもできます。`C-u C-x C-s'でバッファを
保存すると、このとき保存した版は、バッファを再度保存するときにはバック
アップファイルになります。`C-u C-u C-x C-s'もバッファを保存しますが、ま
ずファイルの古い内容をバックアップファイルにします。`C-u C-u C-u C-x
C-s' はその両方を行います。ファイルの以前の内容からバックアップファイル
を作り、さらに、バッファを再度保存するとこのとき保存した版からもう1つバッ
クアップファイルを作るように準備します。

* Menu:

* Names: Backup Names.		How backup files are named;
				  choosing single or numbered backup files.
* Deletion: Backup Deletion.	Emacs deletes excess numbered backups.
* Copying: Backup Copying.	Backups can be made by copying or renaming.



File: emacs-ja, Node: Backup Names, Next: Backup Deletion, Prev: Saving, Up: Saving

単一バックアップファイルと番号付きバックアップファイル
......................................................

単一バックアップファイルを作ることを選択すると（デフォルト）、バックアッ
プファイルの名前は、編集しているファイルの名前に`~'を付加したものになり
ます。したがって、`eval.c'のバックアップファイルは`eval.c~'となります。

番号付きの一連のバックアップファイルを作ることを選択すると、バックアッ
プファイルの名前は、もとのファイル名に`.~'と数字ともう1つ`~'を付加した
ものになります。したがって、`eval.c'のバックアップファイルは、
`eval.c.~1~'、`eval.c.~2~'、…、`eval.c.~259~'というようにどこまでも続
きます。

保護機構のために普通の名前でバックアップファイルを書けなくなると、ユー
ザーのホームディレクトリの`%backup%~'にバックアップファイルを書きます。
そのファイルはたった1つしか存在できないので、最新のバックアップにしか利
用できません。

単一バックアップか番号付きバックアップかの選択は、変数
`version-control'で制御されます。この変数に設定できる値はつぎのとおりで
す。

`t'
     番号付きバックアップを作る。
`nil'
     ファイルに対して番号付きバックアップファイルがすでにあるならば番号
     付きバックアップを作る。さもなければ、単一バックアップを作る。
`never'
     どんな場合にも番号付きバックアップを作らない。つねに単一バックアッ
     プを作る。

各バッファではローカルに`version-control'を設定できるので、
そのバッファのファイルに対するバックアップの作成方法を制御できます。
たとえば、rmailモードでは、
rmailファイルのバックアップを1個だけに限定するために、
`version-control'にはローカルに`never'を設定します。
*Note Locals::。

環境変数`VERSION_CONTROL'を設定すると、
さまざまなGNUユーティリティに
どのようにバックアップファイルを扱うか指示できます。
Emacsも環境変数に従って動作し、
開始時にそれに一致するようにLisp変数`version-control'を設定します。
環境変数の値が`t'か`numbered'なら、
`version-control'は`t'になります。
環境変数の値が`nil'か`existing'なら、
`version-control'は`nil'になります。
環境変数の値が`never'か`simple'なら、
`version-control'は`never'になります。



File: emacs-ja, Node: Backup Deletion, Next: Backup Copying, Prev: Backup Names, Up: Saving

バックアップの自動削除
......................

ディスク容量を無限に浪費することを避けるために、Emacsは番号付きバックアッ
プの版を自動的に削除できます。一般には、Emacsは始めの数個と最新の数個の
バックアップを残して、そのあいだのものをすべて削除します。これは、新た
にバックアップを作るごとに行われます。

2つの変数`kept-old-versions'と`kept-new-versions'は、このような削除を制
御します。それらの値は、それぞれ、新たにバックアップを作るときに、保持
すべき最古（番号が最小）のバックアップの個数、保持すべき最新（番号が最
大）のバックアップの個数です。それらの値は、バックアップの新版を作った
直後に使われることに注意してください。新たに作ったバックアップも、
`kept-new-versions'の数に含まれます。デフォルトでは、どちらの変数も2で
す。

`delete-old-versions'が`nil'以外ならば、何もいわずに余分な中間の版を削
除します。デフォルト値である`nil'ならば、余分な中間の版を削除するかどう
かを聞いてきます。

diredの`.'（ピリオド）コマンドも古い版を削除するために使えます。
*Note Dired Deletion::。



File: emacs-ja, Node: Backup Copying, Prev: Backup Deletion, Up: Saving

コピーと改名
............

バックアップファイルは、古いファイルをコピーする、あるいは、それを改名
することで作ります。古いファイルに複数の名前があると、これには違いが出
てきます。古いファイルを改名してバックアップファイルにすると、（古いファ
イルの）別の名前もバックアップファイルを指します。古いファイルをコピー
した場合には、（古いファイルの）別の名前は編集しているファイルを指し続
け、その名前で参照される内容も新しい内容になります。

バックアップファイルを作る方法は、元ファイルの所有者とグループにも影響
します。コピーするならば、何も変更されません。改名すると、ファイルの所
有者はあなたになり、ファイルのグループはデフォルトになります（オペレー
ティングシステムごとにグループのデフォルトは異なる）。

所有者を変更することは、多くの場合、よいことです。というのは、所有者が
つねに最後にファイルを編集した人を表すからです。同様に、バックアップの
所有者はその版を作った人を表します。ときには、ファイルの所有者を変更す
べきでないファイルがあります。そのようなファイルについては、
`backup-by-copying-when-mismatch'をローカルに設定するローカル変数リスト
をファイルに入れておくのがよいです。

改名するかコピーするかは、3つの変数で制御されます。
デフォルトは、改名です。
変数`backup-by-copying'が`nil'以外ならばコピーします。
`nil'のときには、
変数`backup-by-copying-when-linked'が`nil'以外ならば、
複数の名前を持つファイルではコピーし、
編集中のファイルには名前が1つだけなら改名します。
変数`backup-by-copying-when-mismatch'が`nil'以外のときには、
改名するとファイルの所有者やグループが変更されるときにはコピーします。
スーパーユーザーでEmacsを起動すると、
`backup-by-copying-when-mismatch'のデフォルトは`t'です。

ファイルを版管理システム（*Note Version Control::）で管理している場合に
は、通常Emacsはそのファイルのバックアップを通常の方法では作りません。
チェックインとチェックアウトは、ある意味でバックアップを作ることに似て
います。残念なことに、これらの操作は典型的にはハードリンクを切るという
類似性があります。つまり、あるファイルの別の名前を使っていたとするとそ
のファイル名がなくなるのです。Emacsにできることはありません。版管理シス
テムが処理します。



File: emacs-ja, Node: Interlocking, Prev: Saving, Up: Saving

同時編集に対する保護
--------------------

2人のユーザーが同じファイルを訪問し、両者がそれを編集し、両者がそれを保
存すると、同時編集が発生します。こういったことが起きていることを誰も知
らせなければ、最初に保存したユーザーは、あとになって自分の変更が失われ
ていることを知るでしょう。

ある種のシステムでは、2人目のユーザーがファイルを変更し始めたことを
Emacsがただちに検知して警告を発します。すべてのシステムでは、ファイルを
保存するときにEmacsが検査して、他人の変更を上書きしようとしているならば
警告します。ファイルを保存するかわりに適切な修正操作を行えば、他人の作
業結果を失うことを避けられます。

ファイルを訪問しているEmacsバッファで初めて修正を行うと、Emacsはそのユー
ザーがファイルを"ロック"したと記録します。（同じディレクトリ内に異なる
名前のシンボリックリンクを作ることで実現する。）変更を保存するとEmacsは
ロックを消します。つまり、ファイルを訪問しているEmacsバッファに未保存の
変更があるときにはファイルをロックしておくのです。

他人がロックしているファイルを訪問先とするバッファを修正し始めると"衝突
が起こります。Emacsが衝突を検知すると、Lisp関数`ask-user-about-lock'を
呼び出して、どうするかを聞いてきます。この関数をカスタマイズのために再
定義することもできます。この関数の標準の定義では、ユーザーに質問をし、
3つの返答を受理します。

`s'
     ロックを横取りする。ファイルをすでに変更していた人はロックを失い、
     あなたがロックを得る。
`p'
     続行する。誰かがファイルをロックしたままであるにもかかわらず、ファ
     イルを編集する。
`q'
     放棄する。これはエラー（`file-locked'）を引き起こし、バッファ内で
     修正しようとしたことは、実際には行われない。

ロックはファイル名に基づいて動作することに注意してください。ファイルに
複数の名前があると、Emacsには2つの名前が同じファイルであることはわから
ないので、2人のユーザーが異なる名前で同じファイルを編集することは防げま
せん。しかし、名前に基づいたロックなので、保存しない限り実在しない新規
ファイルの編集をEmacsはインターロック (1) (*Note
Interlocking-Footnotes::) できます。

Emacsがロックを作れる構成になっていないシステムもあります。また、ロック
ファイルを書けない場合もあります。こういった状況では、Emacsがあらかじめ
トラブルを検知することはできませんが、他人の変更を上書きしてファイルを
保存しようとしたときには、衝突を検知できます。

Emacsやオペレーティングシステムがクラッシュすると、古いロックファイルが
残っていることあります。そのため、ときどき偽の衝突についての警告を受け
とることがあるかもしれません。偽の衝突であると確信できれば、Emacsにとに
かく続行するように指示する`p'を使います。

Emacsは、バッファを保存するたびに、ディスク上のファイルの最終変更日時が
最後に訪問／保存したときから更新されていないことをまず検査します。変更
日時が不一致ならば、なんらかの方法でそのファイルが変更されたことを示し、
Emacsが本当に保存するとそれらの変更が失われてしまいます。これを避けるた
めに、Emacsは警告のメッセージを表示し、保存するまえに確認を求めます。ファ
イルが変更された理由を承知していて、それが問題でないことを知っているこ
ともあるでしょう。そうならば、`yes'と答えて続行できます。さもなければ、
`C-g'で保存を中断して、その事態を調査するべきです。

同時編集が発生したことを知らされたときにまず行うべきことは、
`C-u C-x C-d'（*Note Directories::）でディレクトリ一覧を見ることです。
このコマンドは、ファイルの現在の所有者を表示します。
その人に連絡して、編集を続けないように警告しましょう。
そのつぎの段階は、別の名前でEmacsバッファを保存して、
`diff'で2つのファイルを比較することでしょう。


