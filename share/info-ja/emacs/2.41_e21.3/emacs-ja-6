Info file: emacs-ja,    -*-Text-*-
produced by `texinfo-format-buffer'
from file `emacs.texi'
using `texinfmt.el' version 2.41 of  1 Mar 2005.

INFO-DIR-SECTION Emacs
START-INFO-DIR-ENTRY
* Emacs-ja: (emacs-ja).	            Emacs21.3日本語マニュアル.
END-INFO-DIR-ENTRY








File: emacs-ja  Node: Several Buffers-Footnotes, Up: Several Buffers

(1) ファイルを訪問していないバッファや名前がスペースで始まるバッファは
削除されます．これらのバッファは Emacs 内部で使われます



File: emacs-ja, Node: Indirect Buffers, Next: Buffer Convenience, Prev: Kill Buffer, Up: Buffers

間接バッファ *(2004/07/16)*
===========================

"間接バッファ"は、他のバッファとテキストを共有します。そのような他のバッ
ファを間接バッファの"基底バッファ"と呼びます。ある意味で、ファイルのあ
いだのシンボリックリンクに似ています。

`M-x make-indirect-buffer RET BASE-BUFFER RET INDIRECT-NAME RET'
     BASE-BUFFERを基底バッファとする間接バッファINDIRECT-NAMEを作る。

`M-x clone-indirect-buffer RET'
     カレントバッファを双子のようなコピーとなる間接バッファを作る．

`C-x 4 c'
     カレントバッファの双子のようなコピーとなる間接バッファを作り，他の
     ウィンドウで選択する (`clone-indirect-buffer-other-window').

間接バッファのテキストは基底バッファのテキストと常に同一です．一方で編
集された変更は，他方でも即座に見ることができます．しかし，他の観点では
間接バッファと基底バッファは完全に分離しています．つまり，バッファ名も
カーソル位置も，ナローイングも，マークもメジャーモードも，ローカル変数
もすべて異なるのです．

間接バッファはファイルを訪問できませんが，基底バッファはできます．もし
間接バッファを保存しようとすると，実際には基底バッファで保存処理が行わ
れます．基底バッファをキルすると，事実上間接バッファもキルされます．し
かし，間接バッファをキルしても基底バッファには何ら影響を与えません．

間接バッファを使う一つの方法はアウトラインで複数箇所を表示させることです．
*Note Outline Views::．

間接バッファを作る手っ取り早い方法は `M-x clone-indirect-buffer' を使う
ことです．このコマンドは基底バッファがカレントバッファである間接バッファ
を作成し，選択します．前置引数があると，間接バッファの名前を問い合わせ
ます．そうしなければ，バッファ名は，カレントバッファの名前に，`<N>' を
追加して作成されます．`C-x 4 c' (`clone-indirect-buffer-other-window')
は `M-x clone-indirect-buffer' のように動作しますが，他のウィンドウで間
接バッファを選択します．例えば，新しい`*info*' や `*Help*' バッファを作
成したい場合には手軽なコマンドとなります．

より一般的なコマンドは `M-x make-indirect-buffer'です．このコマンドは
BASE-BUFFER の基底バッファから INDIRECT-NAME の名前の間接バッファを作成
します．BASE-BUFFER と INDIRECT-NAME はミニバッファで入力します．



File: emacs-ja, Node: Buffer Convenience, Prev: Kill Buffer, Up: Buffers

バッファに関連した便利な機能とカスタマイズ *(2004/07/16)*
=========================================================

この節はバッファ切り替えをより便利にするようなモードや機能を紹介してい
ます．

* Menu:

* Uniquify::                    Buffer names can contain directory parts.
* Iswitchb::                    Switching between buffers with substrings.
* Buffer Menus::                Configurable buffer menu.



File: emacs-ja, Node: Uniquify, Next: Iswitchb, Prev: Buffer Convenience, Up: Buffer Convenience

バッファ名を分かりやすく *(2004/07/16)*
---------------------------------------

同一のファイル名を持つファイルを開きバッファを作成するためには，Emacs
が区別できるバッファ名が必要になります．通常はバッファ名の最後に `<2>'，
`<3>' などを付加することでバッファ名を区別できるようにしています．

他の方法はバッファ名にそれぞれのディレクトリ名の一部を追加する方法です．
ディレクトリの追加方法は `uniquify-buffer-name-style' (*Note Easy
Customization::) をカスタマイズすることで設定できます．

例えば，`forward'を選択すると，バッファ名の最初にディレクトリ名の一部が付け
られます．この方法で，`/u/mernst/tmp/Makefile' と
`/usr/projects/zaphod/Makefile' を開くと，バッファ名はそれぞれ
`tmp/Makefile' と `zaphod/Makefile' になります (デフォルトではそれぞれ
`Makefile' and `Makefile<2>' となります)．

対照的に，`post-forward' は `Makefile|tmp' と `Makefile|zaphod'に，
`reverse' は`Makefile\tmp' と `Makefile\zaphod' のようなバッファ名にし
ます．`post-forward' と `reverse' の大きな違いが，1つのディレクトリ名で
は対応できない時です．`reverse' はディレクトリ名を逆順で追加していきま
す．つまり，`/top/middle/file' が `file\middle\top' になります．一方，
`post-forward' はファイル名の後に `file|top/middle' のように追加します．

どの方法を使っても，バッファ名を入力する際に，*見て確認*するのであれば，
方法は大して重要ではありません．しかし，熟練したユーザのように，ルール
を熟知していれば，見ることはないでしょう．そして，その場合，いずれかの
ルールでバッファ名が表示されていれば，思い出し利用するのが容易になるこ
とでしょう．



File: emacs-ja, Node: Iswitchb, Next: Buffer Menus, Prev: Uniquify, Up: Buffer Convenience

バッファ名検索でバッファを切り替える ― iswitchb *(2004/07/16)*
---------------------------------------------------------------


グローバルマイナーモードである Iswitchb はバッファ名を文字で検索するこ
とで切り替えを便利にする機能です．この機能はデフォルトで `C-x b', `C-x
4 b', `C-x 5 b' や`C-x 4 C-o' に割り当てられている機能をより便利な機能
で代替します．

これらのコマンドはバッファ名の入力を求めます．その時，選択したい名前の
一部だけを入力できます(最初から入力しなくていいのです)．一部の文字を入
力すると，Iswitchb は入力した文字を含むバッファ名のリストを表示します．

リストの最初のバッファは RET で選択します．つまり，特定のバッファを選択
したければ，リストの先頭に持ってくればいいのです．これには2つの方法があ
ります．1つはさらに文字を入力して，不要なバッファを除外して，バッファ名
のリストを絞り込むこと．もう一つは，`C-s' と `C-r' で希望のバッファが先
頭になるまで，リストの順番を変更させることです．

バッファ名を入力している間，TAB はバッファ名のリストをもとに補完する機
能があります．

Iswitchb を有効にするには `M-x iswitchb-mode' を実行するか
`iswitchb-mode' を `t' にカスタマイズ (*Note Easy Customization::) しま
す．



File: emacs-ja, Node: Buffer Menus, Prev: Iswitchb, Up: Buffer Convenience

バッファメニューのカスタマイズ *(2004/07/16)*
---------------------------------------------

`M-x bs-show'
     `M-x list-buffers' のバッファリストに似ているがカスタマイズが可能です．

`M-x bs-show' はカスタマイズは可能ですが，通常は `C-x C-b' で表示される
ものと似た一覧を表示します．通常のものよりもこちらが良ければ，このコマ
ンドを`C-x C-b' に割り当てることができます．バッファリストのカスタマイ
ズはカスタマイズグループの `bs' を利用できます (*Note Easy
Customization::)．

グローバルマイナーモードである MSB (MSBは「mouse select buffer」を表す)
はポップアップされるメニューをデフォルトとは異なるものにします．これは，
通常 `C-Down-Mouse-1' に割り当てられている `mouse-buffer-menu' を置き換
え，「buffer」メニューも置き換えます．カスタマイズはグループ `msb' でで
きます．



File: emacs-ja, Node: Windows, Next: Frames, Prev: Buffers, Up: Top

複数のウィンドウ *(2004/03/23)*
*******************************

Emacsは、フレームを2つ以上のウィンドウに分割できます。複数のウィンドウ
は、異なるバッファの一部分、あるいは、1つのバッファの異なる部分を表示す
ることができます。複数フレームはつねに複数ウィンドウを意味します。とい
うのは、各フレームはそれ独自のウィンドウの集合を持つからです。各ウィン
ドウはたった1つのフレームだけに属します。

* Menu:

* Basic Window::        Introduction to Emacs windows.
* Split Window::        New windows are made by splitting existing windows.
* Other Window::        Moving to another window or doing something to it.
* Pop Up Window::       Finding a file or buffer in another window.
* Force Same Window::   Forcing certain buffers to appear in the selected
                          window rather than in another window.
* Change Window::       Deleting windows and changing their sizes.
* Window Convenience::  Convenience functions for window handling.



File: emacs-ja, Node: Basic Window, Next: Split Window

Emacsウィンドウの概念 *(2004/03/23)*
====================================

各Emacsウィンドウは、いつでも1つのEmacsバッファを表示します。1つのバッ
ファは複数のウィンドウに表示できます。その場合、そのテキストの変更は、
そのバッファを表示しているすべてのウィンドウで表示されます。しかし、同
じバッファを表示している各ウィンドウではバッファの異なる部分を表示する
ことができます。なぜなら、各ウィンドウはそれ自身のポイント値を持つから
です。

どんなときでも、1つのウィンドウだけが"選択されたウィンドウ"です。そのウィ
ンドウに表示されているバッファがカレントバッファです。端末のカーソルは、
そのウィンドウのポイント位置を示します。別の各ウィンドウにもそれぞれ同
じようにポイント位置がありますが、端末にはカーソルは1つしかないので、そ
れらの位置を示す方法がありません。Xウィンドウシステムで複数フレームを表
示しているときには、各フレームには、そのフレームで選択されたウィンドウ
にカーソルがあります。選択されているフレームのカーソルは塗り潰されてい
る矩形で、それ以外のフレームのカーソルは中空の矩形です。

ポイントを移動するコマンドは、選択されているEmacsウィンドウのポイント値
に対してだけ影響します。たとえ同じバッファを表示しているとしても、他の
Emacsウィンドウのポイント値は変更しません。選択しているウィンドウでカレ
ントバッファを変更する`C-x b'といったコマンドでも同様です。他のウィンド
ウには少しも影響しません。しかし、別のウィンドウを選択してそのバッファ
を切り替える`C-x 4 b'のようなコマンドもあります。さらに、（たとえば）
`C-h f'（`describe-function'）や`C-x C-b'（`list-buffers'）などを含むウィ
ンドウに情報を表示するコマンドは、選択されているウィンドウに影響するこ
となく、選択されていないウィンドウのバッファを切り替えます。

複数のウィンドウが同じバッファを表示するとき、異なるリージョンを持つこ
とができます。というのは、各ウィンドウは、それぞれ異なるポイント値を持
てるからです。しかしながら、各バッファにはたった1つのマーク位置しかない
ため、マークの値はすべて同じになります。

各ウィンドウにはそれ専用のモード行があり、そこにはウィンドウに表示して
いるバッファの名前、修正状態、バッファのメジャーモード、バッファのマイ
ナモードを表示します。モード行に関して詳しくは、*Note Mode Line::。




File: emacs-ja, Node: Split Window, Next: Other Window, Prev: Basic Window

ウィンドウの分割 *(2004/03/23)*
===============================

`C-x 2'
     選択されているウィンドウを上下2つに分割する。
     （`split-window-vertically'）。
`C-x 3'
     選択されているウィンドウを左右2つに分割する
     （`split-window-horizontally'）。
`C-Mouse-2'
     ウィンドウのモード行やスクロールバー上の位置で、そのウィンドウを分
     割する。

コマンド`C-x 2'（`split-window-vertically'）は、選択されているウィンド
ウを上下2つのウィンドウに分割します。どちらのウィンドウも同じポイント値、
同じバッファを表示するところから始まります。デフォルトでは2つのウィンド
ウは、それぞれ、分割されるウィンドウの半分の高さになります。数引数は上
のウィンドウの行数を指定します。

`C-x 3'（`split-window-horizontally'）は、選択されているウィンドウを左
右2つのウィンドウに分割します。数引数は左側のウィンドウの桁数を指定しま
す。2つのウィンドウはスクロールバーで分けられます。画面幅に満たないウィ
ンドウのモード行は、切り詰められます。Emacsが強調表示を扱えない端末では、
切り詰めたモード行が反転表示されない場合があります。

モード行やスクロールバーで`C-Mouse-2'をクリックすることで、ウィンドウを
左右や上下に分割できます(この機能はX toolkitsによるスクロールバーでは動
作しません)。  分割する線はクリックした位置を通ります。モード行でクリッ
クすると、新しいスクロールバーはクリックした点上を通ります。スクロール
バーでクリックすると、分割したウィンドウのモード行はクリックした位置に
並びます。

ウィンドウの幅が十分でないと、長すぎて行に入りきらないテキスト行が
多くなります。
これらの行すべてを継続すると混乱してしまうかもしれません。
変数`truncate-partial-width-windows'に`nil'以外を設定すると、
画面幅に満たないすべてのウィンドウで切り詰めを強制できます。
これは、表示されているバッファや`truncate-lines'の値とは独立しています。
*Note Continuation Lines::。

水平スクロールは左右に並べたウィンドウでよく使われます。
*Note Display::。

`split-window-keep-point'の値が`nil'以外（デフォルト）ならば、`C-x 2'で
分割した2つのウィンドウは、分割前のウィンドウのポイント値を継承します。
つまり、スクロールを避けられません。この変数が`nil'ならば、`C-x 2'は、
画面上のテキストが移動しないように、各ウィンドウで見えている部分にポイ
ントを移動しようと試みます。また、分割前にカーソルがあった行を表示して
いるウィンドウを選択します。遅い端末では後者の動作を好むユーザーもいま
す。



File: emacs-ja, Node: Other Window, Next: Pop Up Window, Prev: Split Window

別のウィンドウの使い方 *(2004/03/23)*
=====================================

`C-x o'
     別のウィンドウを選択する（`other-window'）。（小文字の）`o'であっ
     てゼロではない。
`C-M-v'
     つぎのウィンドウをスクロールする（`scroll-other-window'）。
`M-x compare-windows'
     選択されているウィンドウのテキストとつぎのウィンドウのテキストで一
     致していないつぎの箇所を探す。
`Mouse-1'
     ウィンドウのモード行で`Mouse-1'をクリックすると、そのウィンドウを
     選択するがポイントは移動しない（`mouse-select-window'）。

別のウィンドウを選択するには、そのモード行で`Mouse-1'をクリックします。
キーボードからは、`C-x o'（`other-window'）で
ウィンドウを切り替えられます。
これは「other」の`o'であってゼロではありません。
2つ以上のウィンドウがあるときは、このコマンドはすべてのウィンドウを、
一般的には、上から下へ、左から右へ巡回します。
もっとも右下のウィンドウのつぎは、左上隅にあるウィンドウに戻ります。
数引数は、ウィンドウを巡回する回数を意味します。
負の引数では逆順に巡回します。
ミニバッファを使っているときには、
ミニバッファが巡回の最後のウィンドウになります。
ミニバッファウィンドウから別のウィンドウに切り替えて、
あとで戻ってきて、ミニバッファ引数が要求しているものを与えてから終了できます。
*Note Minibuffer Edit::。

通常のスクロールコマンド（*Note Display::）は、選択されているウィンドウ
のみに作用しますが、つぎのウィンドウをスクロールするコマンドが1つありま
す。`C-M-v'（`scroll-other-window'）は、`C-x o'が選択するウィンドウをス
クロールします。`C-v'のように正負の引数を取ります。（ミニバッファでは、
ミニバッファヘルプがあると、標準の巡回順でつぎのウィンドウではなくて、
ミニバッファヘルプを表示しているウィンドウをスクロールする。）

コマンド`M-x compare-windows'は、2つのウィンドウで見えている2つのファイ
ル、つまり、バッファを比較して、一致しないつぎの箇所へ移動します。詳細
は、*Note Comparing Files::。

`mouse-autoselect-window' を `nil' 以外にすると，別のウィンドウ上にマウ
スを移動させることでウィンドウを選択できます．この機能はデフォルトでは
オフになっています．



File: emacs-ja, Node: Pop Up Window, Next: Force Same Window, Prev: Other Window

別のウィンドウに表示する
========================

`C-x 4'は、（ウィンドウが1つだけならば分割して）別のウィンドウを選択し
て、そのウィンドウでバッファを選択するコマンドのプレフィックスキーです。
異なる`C-x 4'コマンドは、異なる方法で選択するバッファを探します。

`C-x 4 b BUFNAME RET'
     別のウィンドウでバッファBUFNAMEを選択する。このコマンドは、
     `switch-to-buffer-other-window'を実行する。
`C-x 4 C-o BUFNAME RET'
     別のウィンドウでバッファBUFNAMEを表示するが、そのウィンドウもその
     バッファも選択しない。このコマンドは、`display-buffer'を実行する。
`C-x 4 f FILENAME RET'
     ファイルFILENAMEを訪問して、
     別のウィンドウでそのバッファを選択する。
     このコマンドは、`find-file-other-window'を実行する。
     *Note Visiting::。
`C-x 4 d DIRECTORY RET'
     別のウィンドウでディレクトリDIRECTORYに対する
     diredバッファを選択する。
     このコマンドは、`dired-other-window'を実行する。
     *Note Dired::。
`C-x 4 m'
     別のウィンドウでメイルメッセージを作成し始める。このコマンドは、
     `mail-other-window'を実行する。これは、同じウィンドウを使う`C-x
     m'に類似したもの。（*Note Sending Mail::）。
`C-x 4 .'
     別のウィンドウで現在のタグテーブルのタグを探す。このコマンドは、
     `find-tag-other-window'を実行するが、`M-.'の複数ウィンドウ向けの変
     種（*Note Tags::）。
`C-x 4 r FILENAME RET'
     ファイルFILENAMEを読み出し専用で訪問し、
     別のウィンドウでそのバッファを選択する。
     このコマンドは `find-file-read-only-other-window'を実行する。
     *Note Visiting::。



File: emacs-ja, Node: Force Same Window, Next: Change Window, Prev: Pop Up Window

同じウィンドウへの強制表示
==========================

ある種のEmacsコマンドは、特別な内容を持つ特有のバッファに切り替えます。
たとえば、 `M-x shell'は、`*Shell*'という名前のバッファに切り替えます。
慣習では、これらのすべてのコマンドは、別のウィンドウにバッファを立ち上
げるようにプログラムされています。しかし、これらのバッファのいくつかを
選択されているウィンドウに表示するように指定できます。

バッファ名をリスト`same-window-buffer-names'に追加すると、
そういったコマンドは、選択されているウィンドウで特定のバッファに切り替えます。
たとえば、そのリストに要素`"*grep*"'を追加すれば、
`grep'コマンドは、選択されているウィンドウにその出力バッファを表示します。

`same-window-buffer-names'のデフォルト値は`nil'ではありません。（古い
Emacsパッケージが使うものも含めて）バッファ名、`*info*'、`*mail*'、
`*shell*'を指定してあります。このため、`M-x shell'が通常は選択されてい
るウィンドウで`*shell*'バッファに切り替えるのです。もしこの要素を
`same-window-buffer-names'から削除すると、`M-x shell'のふるまいは変わり
ます。かわりに別のウィンドウでバッファを立ち上げます。

これらのバッファを、より一般的に変数`same-window-regexps'で指定できます。
この変数には、正規表現のリストを設定します。そうすると、正規表現の1つに
一致するバッファはどれも、選択されているウィンドウでバッファを切り替え
て表示します。（繰り返すが、これは、普通は別のウィンドウに表示されるバッ
ファのみにあてはまる。）この変数のデフォルト値には、telnetバッファと
rloginバッファが指定されています。

類似の機能で、独立したフレームに表示させるバッファを指定することができます。
*Note Special Buffer Frames::。



File: emacs-ja, Node: Change Window, Next: Window Convenience, Prev: Force Same Window

ウィンドウの削除と再配置 *(2004/03/23)*
=======================================

`C-x 0'
     選択されているウィンドウを削除する（`delete-window'）。このキー列
     の最後の文字はゼロ。
`C-x 1'
     選択されているウィンドウを除いて、選択されているフレームのウィンド
     ウすべてを削除する（`delete-other-windows'）。
`C-x 4 0'
     選択されているウィンドウを削除し、その中に表示されているバッファを
     削除する（`kill-buffer-and-window'）。このキー列の最後の文字はゼロ。
`C-x ^'
     選択されているウィンドウの高さを大きくする（`enlarge-window'）。
`C-x }'
     選択されているウィンドウの幅を広くする
     （`enlarge-window-horizontally'）。
`C-x {'
     選択されているウィンドウの幅を狭くする
     （`shrink-window-horizontally'）。
`C-x -'
     バッファがそんなに多くの行を必要としないならウィンドウを縮める
     （`shrink-window-if-larger-than-buffer'）。
`C-x +'
     すべてのウィンドウを同じ高さにする（`balance-windows'）。
`Drag-Mouse-1'
     ウィンドウのモード行を`Mouse-1'で上下にドラッグして、ウィンドウの
     高さを変更する。
`Mouse-2'
     ウィンドウのモード行で`Mouse-2'をクリックすると、フレーム内のその
     ウィンドウ以外のすべてのウィンドウを削除する
     （`mouse-delete-other-windows'）。
`Mouse-3'
     ウィンドウのモード行で`Mouse-3'をクリックすると、そのウィンドウを
     削除する（`mouse-delete-window'）。フレームにウィンドウが1個しかな
     ければ，カレントバッファを他のバッファに切り替える．

ウィンドウを削除するには、`C-x 0'（`delete-window'）と打ちます（これは
ゼロ）。削除されたウィンドウが占めていた場所は、隣接のウィンドウに与え
られます。（ただし、ミニバッファのウィンドウを使っている場合でも、ミニ
バッファのウィンドウには与えない。）ウィンドウを一度削除すると、その属
性は失われます。ウィンドウの構成情報を回復する以外にウィンドウをもとに
戻す方法はありません。ウィンドウを削除しても、そこに表示していたバッファ
には何の影響もありません。バッファは存在し続け、どのウィンドウへでも
`C-x b'で選択できます。

`C-x 4 0'（`kill-buffer-and-window'）は、`C-x 0'よりも強いコマンドです。
これは、カレントバッファを削除し、そこで選択されていたウィンドウを削除
します。

`C-x 1'（`delete-other-windows'）は、別の意味でさらに強力です。選択され
ているウィンドウ（とミニバッファ）を除いて、すべてのウィンドウを削除し
ます。選択されているウィンドウは、エコー領域を除いたフレーム全体を使う
ように広がります。

モード行で`Mouse-2'をクリックしても、そのウィンドウを削除できます。モー
ド行で`Mouse-3'をクリックすると、そのウィンドウを除いて、フレーム内のす
べてのウィンドウを削除します。

ウィンドウの高さを調節するもっとも簡単な方法は、マウスを使うことです。
モード行で`Mouse-1'を押し下げてモード行を上下にドラッグすると、ウィンド
ウの高さを変更できます。

上下に接しているウィンドウの分割を再調整するには、`C-x
^'（`enlarge-window'）を使います。このコマンドは、現在選択されているウィ
ンドウを1行だけ、あるいは、数引数分の行数だけ大きくします。負の引数を指
定すると、選択されているウィンドウは小さくなります。
`C-x }'（`enlarge-window-horizontally'）は、選択されているウィンドウを
指定された桁数分だけ広くします。`C-x {'（`shrink-window-horizontally'）
は、選択されているウィンドウを指定された桁数分だけ狭くします。

ウィンドウを大きくするとき、その場所は隣のウィンドウから取ります。
その結果、ウィンドウが小さくなりすぎるとそのウィンドウは削除され、
その場所を隣接するウィンドウに与えます。
最小の大きさは変数`window-min-height'と
`window-min-width'で指定します。

コマンド`C-x -'（`shrink-window-if-larger-than-buffer'）は、選択されて
いるウィンドウの高さが、表示しているバッファのテキスト全体を表示するた
めに必要な高さよりも大きい場合には、その高さを縮めます。余った行はフレー
ム内の他のウィンドウに与えられます。

選択されているフレーム内のすべてのウィンドウの高さをすべて同じにするには、
`C-x +'（`balance-windows'）を使えます。



File: emacs-ja, Node: Window Convenience, Prev: Change Window

ウィンドウ関連の便利な機能とカスタマイズ *(2004/03/23)*
=======================================================

`M-x winner-mode' はグローバルマイナーモードで，ウィンドウの設定(つまり，
フレームがどのように分割されたかなどの情報)を記録します．このため，ウィ
ンドウ分割などのアンドゥが可能になるのです．アンドゥを行うためには，
`C-x left' (`winner-undo') を実行します．アンドゥを取り消す(リドゥ)は
`C-x right' (`M-x winner-redo') で行います．`winner-mode' を有効にする
他の方法として `winner-mode' をカスタマイズする方法もあります．

Windmove コマンドによりフレーム内で隣接するウィンドウ間を直接往き来でき
るようになります．例えば，`M-x windmove-right' は現在選択しているウィン
ドウの右にあるウィンドウを選択できます．同様のコマンドとして"left"，
up"，"down"がそれぞれ用意されています．`M-x
windmove-default-keybindings' を実行すると，これらのコマンドが
`S-right' のようなキーにバインドされます．(ただし，すべての端末で
Shift を押しながらカーソルキーを入力するようなキーが有効になるとは限り
ません)

「Follow minor mode」(`M-x follow-mode') は同じバッファを複数のウィンド
ウで同時に同期して表示させる機能です．このため，バッファの隣接したセク
ションが表示されることになります．*Note Follow Mode::．

`M-x scroll-all-mode' は現在表示されているウィンドウをすべて同時にスク
ロールさせる機能です．変数 `scroll-all-mode' をカスタマイズすることで有
効にできます．このモードは `M-x scroll-all-scroll-down-all', `M-x
scroll-all-page-down-all' と"up" に対応するコマンドを提供します．このモー
ドを便利にするために，これらのコマンドを適当なキーに割り当てておくとい
いでしょう．



File: emacs-ja, Node: Frames, Next: International, Prev: Windows, Up: Top

フレームとXウィンドウシステム
*****************************

Xウィンドウシステムで使っているときには、1つのEmacsセッションでXのレベ
ルで複数のウィンドウを作ることができます。Emacsに属するXの各ウィンドウ
は、Emacsのウィンドウを1つ以上含めことができる"フレーム"（frame）を表示
します。フレームは、最初は汎用のEmacsのウィンドウを1つ含みますが、上下
左右に小さなウィンドウに分割できます。フレームは通常、専用のエコー領域
とミニバッファを含みますが、それらを含まないものを作ることもできます。
その場合は、別のフレームのエコー領域やミニバッファを使います。

あるフレームでの編集は、別のフレームにも影響します。たとえば、あるフレー
ムでキルリングにテキストを入れると、別のフレームでヤンクできます。ある
フレームで`C-x C-c'でEmacsを終ると、すべてのフレームを終了します。1つの
フレームだけを削除するなら、`C-x 5 0'を使います。

混乱を避けるために、Emacsが実装している細分化できるものを『ウィンドウ』
と呼び、フレームを意味するときにはこの単語を使いません。

MS-DOS用にコンパイルしたEmacsは、ウィンドウシステムのある種の特徴をエミュ
レートするので、本章で説明する機能の多くを使うことができます。詳しくは、
*Note MS-DOS Input::。

* Menu:

* Mouse Commands::      Moving, cutting, and pasting, with the mouse.
* Secondary Selection:: Cutting without altering point and mark.
* Mouse References::    Using the mouse to select an item from a list.
* Menu Mouse Clicks::   Mouse clicks that bring up menus.
* Mode Line Mouse::     Mouse clicks on the mode line.
* Speedbar::            How to make and use a speedbar frame.
* Creating Frames::     Creating additional Emacs frames with various contents.
* Multiple Displays::   How one Emacs job can talk to several displays.
* Special Buffer Frames::  You can make certain buffers have their own frames.
* Frame Parameters::    Changing the colors and other modes of frames.
* Scroll Bars::	        How to enable and disable scroll bars; how to use them.
* Menu Bars::	        Enabling and disabling the menu bar.
* Faces::	        How to change the display style using faces.
* Font Lock::           Minor mode for syntactic highlighting using faces.
* Support Modes::       Font Lock support modes make Font Lock faster.
* Highlight Changes::   Using colors to show where you changed the buffer.
* Misc X::	        Iconifying and deleting frames. Region highlighting.
* Non-Window Terminals::  Multiple frames on terminals that show only one.



File: emacs-ja, Node: Mouse Commands, Next: Menu Mouse Clicks

編集用マウスコマンド
====================

リージョンを選択したりコピーしたりするマウスコマンドは、`xterm'プログラ
ムとほぼ互換です。Emacsと他のXクライアントプログラムとのあいだでコピー
するには、Xのマウスコマンドと同じものを使えます。

これらのマウスコマンドでリージョンを選択して、そのあとすぐにファンクショ
ンキーDELETEを打つと、選択したリージョンを削除します。ファンクションキー
BACKSPACEやASCII文字DELは、これを行いません。マウスコマンドとDELETEのあ
いだに別のキーを打ったときも、これを行いません。

`Mouse-1'
     クリックした位置にポイントを移動する（`mouse-set-point'）。通常、
     左ボタン。

`Drag-Mouse-1'
     ドラッグにより選択したテキストにリージョンを設定し、キルリングにそ
     れをコピーする（`mouse-set-region'）。リージョンの始めと終りの両方
     をこのコマンド1つで指定できる。

     ドラッグ中に、ウィンドウの上下からマウスが出ると、マウスがウィンド
     ウ内に戻ってくるまで、ウィンドウを一定の割合でスクロールする。こう
     して、画面全体に入りきらないリージョンでも選択できる。一度にスクロー
     ルする行数は、マウスがウィンドウの縁からどの程度離れているかに依存
     する。変数`mouse-scroll-min-lines'には最小の行数を指定する。

`Mouse-2'
     クリックした場所に、もっとも最近にキルしたテキストをヤンクする
     （`mouse-yank-at-click'）。通常、中ボタン。

`Mouse-3'
     このコマンド`mouse-save-then-kill'は、クリックした場所とリージョン
     の状態に依存して、いくつかの機能がある。

     もっとも基本的な場合は、ある場所で`Mouse-1'をクリックしてから、別
     の場所で`Mouse-3'をクリックしたとき。こうすると、これらの2点のあい
     だにあるテキストをリージョンとして選択する。さらに、新しいリージョ
     ンをキルリングへもコピーするので、別の場所へそれをコピーできる。

     テキスト上で`Mouse-1'をクリックしてから、スクロールバーでスクロー
     ルしたあとで`Mouse-3'をクリックすると、スクロールする以前の
     （`Mouse-1'でクリックした）場所を覚えていて、そこをリージョンの片
     方の端点として使う。こうすると、画面に入りきらないリージョンでも選
     択できる。

     より一般的には、強調表示されたリージョンがないならば、`Mouse-3'は、
     ポイントとクリックした位置のあいだのテキストをリージョンとして選択
     する。これは、ポイントがあった位置にマークを設定し、クリックした位
     置にポイントを移動することで行う。

     強調表示されたリージョンがある場合、あるいは、ボタン1をドラッグし
     てリージョンを設定してある場合、`Mouse-3'はクリックした場所に近い
     側のリージョンの端をクリック位置に移動して調整する。また、調整した
     リージョンのテキストは、キルリング内の古いリージョンのテキストを置
     き換える。

     もともと`Mouse-1'をダブルクリックあるいはトリプルクリックして、
     リージョンを単語や行単位で設定した場合には、
     `Mouse-3'によるリージョンの調整も単語や行単位で行われる。

     連続して2度同じ場所で`Mouse-3'を使うと、すでに選択してあるリージョ
     ンをキルする。

`Double-Mouse-1'
     このキーは、クリックした単語全体にリージョンを設定する。『シンボル』
     の構文（Cの下線のような）の文字をクリックすると、その文字を囲むシ
     ンボル全体にリージョンを設定する。

     開き括弧や閉じ括弧の構文の文字をクリックすると、その文字で始まり／
     終る括弧で囲まれた塊（sexp）にリージョンを設定する。文字列区切りの
     構文（Cのシングルクォートやダブルクォート）の文字をクリックすると、
     （その文字が文字列の始まりか終りかを発見的方法を使って決めて）文字
     列定数を囲むリージョンを設定する。

`Double-Drag-Mouse-1'
     このキーは、ドラッグした範囲内にある単語を囲むリージョンを設定する。

`Triple-Mouse-1'
     このキーは、クリックした行全体を囲むリージョンを設定する。

`Triple-Drag-Mouse-1'
     このキーは、ドラッグした範囲内にある行すべてを囲むリージョンを設定
     する。

マウスを使ったもっとも単純なテキストのキル方法は、片方の端で`Mouse-1'を
押し、もう一方の端で`Mouse-3'を2回押すことです。*Note Killing::。バッファ
から削除しないでキルリングにテキストをコピーするには、`Mouse-3'を一度だ
け押します。あるいは、`Mouse-1'でテキストを横断してドラッグするだけです。
そうすると、どこででも、それをヤンクすることでコピーできます。

キルしたりコピーしたりしたテキストをどこか別の場所にヤンクするには、マ
ウスをその場所に移動して`Mouse-2'を押します。*Note Yanking::。しかし、
`mouse-yank-at-point'が`nil'以外ならば、`Mouse-2'はポイント位置にヤンク
します。つまり、ウィンドウのどこをクリックしたのか、あるいは、フレーム
のどのウィンドウをクリックしたのかは問題ではありません。デフォルトの値
は`nil'です。この変数は二次セレクションのヤンクにも影響します。

別のXのウィンドウへテキストをコピーするには、その部分をキルするかキルリ
ングに保存します。Xの管理下では、"一次セレクション"も設定します。そのあ
とで、別のXのウィンドウで動いているプログラムの『ペースト』や『ヤンク』
コマンドを使って、セレクションからテキストを挿入します。

別のXのウィンドウからテキストをコピーするには、そのウィンドウで動いてい
るプログラムの『カット』や『コピー』コマンドを使って目的のテキストをセ
レクションにします。そのあとで、`C-y'や`Mouse-2'を使ってEmacsにヤンクし
ます。

これらのカット／ペーストコマンドはMS-Windows上でも動作します。

Emacsがテキストをキルリングに入れたり、キルリングのテキストを先頭へ巡回
するとき、EmacsはXサーバーの一次セレクションに設定します。このために、
別のXクライアントがテキストを参照できるのです。テキストが十分に短い場合
にのみ（`x-cut-buffer-max'は最大文字数を指定する）、Emacsはカットバッファ
にもテキストを収めます。長い文字列をカットバッファへ置くには時間がかか
ります。

キルリングの始めのテキストをヤンクするコマンドは、実際には、別のプログ
ラムの一次セレクションをまず調べ、そのあとで、カットバッファのテキスト
を調べます。どちらにもヤンクするテキストがなれば、キルリングの内容を使
います。



File: emacs-ja, Node: Secondary Selection, Next: Menu Mouse Clicks

二次セレクション
================

"二次セレクション"は、Xにおいてテキストを選択する別の方法です。これは、
ポイントやマークを使わないので、ポイントやマークを設定せずにテキストを
削除するのに使えます。

`M-Drag-Mouse-1'
     ボタンを押した場所を片方の端、ボタンを離した場所をもう一方の端とし
     て、二次セレクションを設定する（`mouse-set-secondary'）。強調表示
     されドラッグするにつれて変化する。

     ドラッグ中にウィンドウの上下からマウスが出ると、ウィンドウへマウス
     が戻ってくるまで、ウィンドウを一定の割合でスクロールする。こうして、
     画面全体に入りきらないリージョンも選択できる。

`M-Mouse-1'
     "二次セレクション"の一方の端を設定する（`mouse-start-secondary'）。

`M-Mouse-3'
     `M-Mouse-1'で指定した場所を一方の端として使い、二次セレクションを
     設定する。（`mouse-secondary-save-then-kill'）。同じ位置での2回目
     のクリックは、ちょうど作成した二次セレクションをキルする。

`M-Mouse-2'
     クリックした位置に二次セレクションを挿入する
     （`mouse-yank-secondary'）。ヤンクしたテキストの最後にポイントを置
     く。

`M-Mouse-1'のダブルクリックやトリプルクリックは、
`Mouse-1'のように単語や行単位に作用します。

`mouse-yank-at-point'が`nil'以外ならば、
`M-Mouse-2'はポイント位置にヤンクします。
そのときには、どこをクリックしたかは関係なく、
どのウィンドウをクリックしたかだけが関係します。
*Note Mouse Commands::。



File: emacs-ja, Node: Mouse References, Next: Menu Mouse Clicks

マウスで参照を辿る
==================

いくつかのEmacsバッファでは、いろいろなものの一覧を表示します。ファイル
一覧、バッファ一覧、補完候補一覧、パターンに一致したものの一覧などです。

これらのバッファにテキストをヤンクできても便利ということはないので、こ
れらの多くは`Mouse-2'を特別に定義して、クリックした項目を使ったり眺めた
りするコマンドとしています。

たとえば、diredバッファのファイル名を`Mouse-2'でクリックすると、そのファ
イルを訪問します。`*Compilation*'バッファのエラーメッセージを`Mouse-2'
でクリックすると、そのエラーメッセージに対応するソースコードへ行きます。
`*Completions*'バッファの補完候補を`Mouse-2'でクリックすると、その補完
候補を選択します。

反応するテキストの上にマウスが移動するとテキストが強調表示されるので、
`Mouse-2'がいつ特別な意味を持つか普通はわかります。



File: emacs-ja, Node: Menu Mouse Clicks, Next: Mode Line Mouse

メニューを出すマウスクリック
============================

CTRLやSHIFTキーで修飾されたマウスクリックは、メニューを立ち上げます。

`C-Mouse-1'
     バッファを選択するためのメニュー。

`C-Mouse-2'
     整形済みのテキストに使うフェイスやテキスト属性を指定するためのメニュー。
     *Note Formatted Text::。

`C-Mouse-3'
     モードに特有のメニュー。ほとんどのモードでは、このメニューは、すべ
     てのモード特有のメニューバーメニューを一緒にしたのと同じ項目を持つ。
     いくつかのモードでは、このボタン (1) (*Note Menu Mouse
     Clicks-Footnotes::) に異なるメニューを指定しているかもしれない。


`S-mouse-1'
     フレームの主要フォントの指定に関するメニュー。


File: emacs-ja  Node: Menu Mouse Clicks-Footnotes, Up: Menu Mouse Clicks

(1) いくつかのシステムでは、`Mouse-3'をモード特有のメニューに
使う。ユーザーを調査した結果、`Mouse-3'をリージョンの選択とキ
ルに使い続けることが好まれていることが判明した。ゆえに、このメニュー
に対して`C-Mouse-3'を使うことにした。



File: emacs-ja, Node: Mode Line Mouse, Next: Speedbar, Prev: Menu Mouse Clicks

モード行のマウスコマンド
========================

ウィンドウを選択したり操作するために、ウィンドウのモード行でマウスクリッ
クを使えます。

`Mouse-1'
     モード行で`Mouse-1'をクリックするとその上のウィンドウを選択する。
     モード行を`Mouse-1'でドラッグするとモード行を移動することができ、
     そのウィンドウの高さを変更できる。

`Mouse-2'
     モード行で`Mouse-2'をクリックすると、そのフレーム一杯にウィンドウ
     を広げる。

`Mouse-3'
     モード行で`Mouse-3'をクリックすると、その上のウィンドウを削除する。

`C-Mouse-2'
     モード行で`C-Mouse-2'をクリックすると、モード行をクリックした場所
     でその上のウィンドウを左右に分割する。

スクロールバーで`C-Mouse-2'をクリックすると、
対応するウィンドウを上下に分割します。
*Note Split Window::。



File: emacs-ja, Node: Creating Frames, Next: Speedbar, Prev: Mode Line Mouse

フレームの作成
==============

プレフィックスキー`C-x 5'は、`C-x 4'と同じようなサブコマンドがあるとい
う点で似ています。違いは、`C-x 5'コマンドは、選択されているフレームで新
たにウィンドウを作るのではなく、新しいフレームを作ることです（*Note
Pop Up Window::）。既存の見えているフレームやアイコン化されたフレームが、
要求された内容を表示しているなら、これらのコマンドは、必要ならフレーム
をいちばん手前にもってきたりアイコンを開いてから、既存のフレームを使い
ます。

さまざまな`C-x 5'コマンドは、選択するバッファの探し方や作成方法が異なり
ます。

`C-x 5 2'
     新しいフレームを作る（`make-frame-command'）。
`C-x 5 b BUFNAME RET'
     別のフレームでバッファBUFNAMEを選択する。これは、
     `switch-to-buffer-other-frame'を実行する。
`C-x 5 f FILENAME RET'
     ファイルFILENAMEを訪問して、別のフレームでそのバッファを選択する。
     これは、`find-file-other-frame'を実行する。
     *Note Visiting::。
`C-x 5 d DIRECTORY RET'
     別のフレームでディレクトリDIRECTORYに対するdiredバッファを選択する。
     これは、`dired-other-frame'を実行する。
     *Note Dired::。
`C-x 5 m'
     別のフレームでメイルメッセージの作成を始める。
     これは、`mail-other-frame'を実行する。
     これは、`C-x m'の他のフレームを使う変形版。
     *Note Sending Mail::。
`C-x 5 .'
     別のフレームで現在のタグテーブルからタグを探す。
     これは、`find-tag-other-frame'を実行し、
     `M-.'の複数フレーム向けの変形版。
     *Note Tags::。
`C-x 5 r FILENAME RET'
     ファイルFILENAMEを読み出し専用で訪問し、
     別のフレームでそのバッファを選択する。
     これは、`find-file-read-only-other-frame'を実行する。
     *Note Visiting::。

`default-frame-alist'にフレームパラメータを設定することで、新たに作成す
るフレームの見た目を制御できます。初期フレームだけに影響するパラメータ
を指定するには、変数`initial-frame-alist'を使います。詳しくは、*Note 初
期フレームのパラメータ: (elisp)Initial Parameters。

すべてのEmacsフレームに主要フォントを指定するもっとも簡単な方法は、
Xのリソース（*Note Font X::）を使うことですが、
つぎに示すように、`font'パラメータを指定するように
`default-frame-alist'を変更してもできます。

     (add-to-list 'default-frame-alist '(font . "10x20"))



File: emacs-ja, Node: Speedbar, Next: Special Buffer Frames, Prev: Mode Line Mouse

スピードバーフレームの作成と使い方
==================================

Emacsのフレームは、"スピードバー"を持つことができます。スピードバーは、
縦長のウィンドウで、訪問したりタグを探したりするためのスクロール可能な
ファイルメニューとして働きます。スピードバーを作るには、`M-x speedbar'
と打ちます。これは、選択されたフレームに対するスピードバーウィンドウを
作ります。そうすると、スピードバーのファイル名をクリックすると、対応す
るEmacsフレームでそのファイルを訪問できます。あるいは、タグの名前をクリッ
クすると、Emacsフレームでそのタグの箇所へ飛んで行きます。

最初、スピードバーには、カレントディレクトリの直下の内容を1行につき1つ
のファイルで表示します。各行には、`[+]'か`<+>'の箱があって、それを
`Mouse-2'でクリックするとその項目の内容を『開け』ます。その行の名前がディ
レクトリならば、それを開くと、そのディレクトリの内容をその行の下に追加
してスピードバーに表示します。その行が普通のファイルならば、それを開く
と、そのファイル内のタグ一覧をスピードバーに追加して表示します。ファイ
ルが開かれていると、`[+]'は`[-]'に変わります。ファイルを『閉じる』（内
容を隠す）ためにその箱をクリックできます。

rmailモード、infoモード、GUDモードを含むいくつかのメジャーモードには、
選択可能な有用な項目をスピードバーに追加する特別な方法があります。たと
えば、rmailモードでは、スピードバーにはrmailファイル一覧を表示します。
カレントメッセージを別のrmailファイルに移すには、目的のrmailファイルの
`<M>'の箱をクリックするだけです。

スピードバーは1つのEmacsフレームに属し、つねにそのフレームに作用します。
複数のフレームを使うときには、一部のフレームやすべてのフレームにスピー
ドバーを作れます。フレームのスピードバーを作るには、そのフレームで`M-x
speedbar'と打ちます。



File: emacs-ja, Node: Multiple Displays, Next: Special Buffer Frames, Prev: Speedbar

複数ディスプレイ
================

1つのEmacsは、複数のXディスプレイと通信できます。最初は、Emacsは1つのディ
スプレイだけを使います。環境変数`DISPLAY'や`--display'オプションに指定
されたものです（*Note Initial Options::）。他のディスプレイに接続するに
は、コマンド`make-frame-on-display'を使います。

`M-x make-frame-on-display RET DISPLAY RET'
     ディスプレイDISPLAY上に新しいフレームを作成する。

1つのXサーバーは複数のスクリーンを扱えます。1つのサーバーに属する2つの
スクリーンにフレームを開くとき、Emacsは1つのキーボードを共有しているこ
とを知っていて、これらのスクリーンから到着するすべてのコマンドを1つの入
力ストリームとして扱います。

異なるXサーバー上にフレームを開くとき、Emacsはそれぞれのサーバーに対し
て別々の入力ストリームを作ります。こうすることで、2つのディスプレイ上で
2人のユーザーが同時に打鍵でき、Emacsはそれらの入力をごっちゃにすること
はありません。各サーバーにはそれ自身が選択しているフレームがあります。
特定のXサーバーで入力したコマンドは、そのサーバーが選択しているフレーム
に適用されます。

これらの機能にも関わらず、異なるディスプレイで同じEmacsジョブを使ってい
る人達は、注意を怠ると、互いに干渉し合ってしまいます。たとえば、誰かが
`C-x C-c'と打つと、その人達が共有している（1つの）Emacsジョブは終了して
しまいます！



File: emacs-ja, Node: Special Buffer Frames, Next: Scroll Bars, Prev: Speedbar

特別なバッファフレーム
======================

ウィンドウが1つのときにはEmacsが普通2つめのウィンドウを作るような特定の
バッファでは、それ専用の特別なフレームに表示することができます。こうす
るには、変数`special-display-buffer-names'にバッファ名のリストを設定し
ます。そのリストに名前があるどのバッファも、Emacsコマンドが『別のウィン
ドウに』表示したいときには、特別なフレームを自動的に取得します。

たとえば、つぎのように変数を設定したとすると、補完一覧、`grep'の出力、
TeXモードのシェルバッファは、それぞれ個別のフレームを取得します。

     (setq special-display-buffer-names
           '("*Completions*" "*grep*" "*tex-shell*"))

これらのフレームとその中のウィンドウは、別のバッファのために自動的に分
割されたり再利用されることはありません。手動で変更するまで、そのために
作成されたバッファを表示し続けます。特別なバッファを消去すると、そのフ
レームも自動的に削除されます。

より一般的には、正規表現のリストを`special-display-regexps'に設定できま
す。すると、バッファの名前がそれらの正規表現に一致すると、バッファは専
用のフレームを取得します。（繰り返すが、これは通常、別のウィンドウに表
示するバッファにのみ適用する。）

変数`special-display-frame-alist'は、このようなフレームに対するフレーム
パラメータを指定します。これにはデフォルト値があるので、特に設定する必
要はありません。

Lispがわかる人のためにですが、`special-display-buffer-names'や
`special-display-regexps'の要素は、リストでもかまいません。その場合、最
初の要素はバッファ名か正規表現です。リストの残りは、フレームの作成方法
を指定します。これは、フレームパラメータの値を指定する連想リストにする
こともできます。これらの値は、`special-display-frame-alist'に指定された
パラメータの値より優先されます。あるいは、リストはつぎのような形式にす
ることもできます。

     (FUNCTION ARGS...)

ここで、FUNCTIONはシンボルです。こうすると、FUNCTIONを呼んでフレームを
作ります。関数呼び出しの最初の引数はバッファで、残りの引数はARGSです。

似たような機能で、バッファをどの選択されているウィンドウに表示するか指
定できます。*Note Force Same Window::。同じウィンドウに表示する機能は、
特別なフレームに表示する機能に優ります。したがって、バッファ名を
`special-display-buffer-names'に追加しても何の効果もなかったら、その機
能が同じバッファ名に対しても使われていないか調べてください。



File: emacs-ja, Node: Frame Parameters, Next: Scroll Bars, Prev: Special Buffer Frames

フレームパラメータの設定
========================

本節では、選択しているフレームの表示スタイルやウィンドウ管理のふるまい
を変更するコマンドを説明します。

`M-x set-foreground-color RET COLOR RET'
     選択しているフレームの前景色をCOLORと指定する。

`M-x set-background-color RET COLOR RET'
     選択しているフレームの背景色をCOLORと指定する。これは`modeline'フェ
     イスの前景色も変更するので、デフォルトと比較しても反転表示のままに
     なる。

`M-x set-cursor-color RET COLOR RET'
     選択しているフレームのカーソルの表示色をCOLORと指定する。

`M-x set-mouse-color RET COLOR RET'
     マウスカーソルが選択しているフレーム内にあるときのマウスカーソルの
     表示色をCOLORと指定する。

`M-x set-border-color RET COLOR RET'
     選択しているフレームの境界色をCOLORと指定する。

`M-x list-colors-display'
     定義されている表示色の名称とそれがどう見えるか表示する。このコマン
     ドは少し遅い。

`M-x auto-raise-mode'
     選択されているフレームをオートレイズするべきかどうか切り替える。オー
     トレイズとは、マウスカーソルがフレームに入るたびに、そのフレームを
     手前にもってくること。

     このオートレイズ機能はEmacs自身が実装していることに注意。
     ウィンドウマネージャの中にも、オートレイズを実装しているものがある。
     XのウィンドウマネージャでEmacsフレームのオートレイズを指定しているときには、
     それが動作するはず。
     しかし、それはEmacsの制御を超えているので、それに関しては
     `auto-raise-mode'は何の影響もない。

`M-x auto-lower-mode'
     選択されているフレームをオートローワするべきかどうか切り替える。オー
     トローワとは、マウスカーソルがフレームから出るたびに、そのフレーム
     をXのウィンドウスタックの底に移すこと。

     コマンド`auto-lower-mode'は、Xのウィンドウマネージャが実装するオー
     トローワには何の影響もない。それを制御するには、適切なウィンドウマ
     ネージャの機能を使う必要がある。

`M-x set-frame-font RET FONT RET'
     選択されたフレームに対する主要フォントとしてFONTを指定する。
     フェイス（*Note Faces::）が別のフォントを使うことを指定しているときを
     除いて、主要フォントは、フレームに表示するすべてのテキストに対して使われる。
     あなたのシステムで使えるフォント一覧を表示する方法については、
     *Note Font X::。

     ポップアップメニューから、フレームの主要フォントを設定することもで
     きる。このメニューを立ち上げるには`S-Mouse-1'を押す。

Xツールキットを使うEmacsの版では、表示色とフォントを設定する関数はメ
ニューやメニューバーには影響しません。というのは、メニューやメニューバー
は、それら自身のウィジェットクラスを使って表示されているからです。メ
ニューとメニューバーの見た目を変更するには、Xのリソースを使う必要があり
ます（*Note Resources X::）。表示色に関しては、*Note Colors X::。フォン
トの選択については、*Note Font X::。

フレームパラメータとそのカスタマイズについては、*Note フレームパラメー
タ: (elisp)Frame Parameters。



File: emacs-ja, Node: Scroll Bars, Next: Support Modes, Prev: Special Buffer Frames

スクロールバー
==============

Xを使っているときには、Emacsは通常、各Emacsウィンドウの左側に"スクロー
ルバー"（scroll bar）を作ります。スクロールバーは、ウィンドウの高さに延
びていて、内側に動く矩形の箱を表示します。この箱は、現在表示されている
バッファ内の部分を表しています。スクロールバーの全体の高さは、バッファ
の全体の長さを表します。

`Mouse-2'（通常、中ボタン）を使って、スクロールバーの内側の箱を上下に移
動したりドラッグできます。内側の箱をスクロールバーのいちばん上へ移動す
ると、バッファの先頭を見ることができます。スクロールバーのいちばん下に
内側の箱を移動すると、バッファの末尾が見えます。

スクロールバーで左や右ボタンを使うと、制御された増分でスクロールできま
す。`Mouse-1'（通常、左ボタン）は、クリックした場所の高さの行をウィンド
ウの最上端の行へ移動します。`Mouse-3'（通常、右ボタン）は、ウィンドウの
最上端の行をクリックした場所の高さの行へ移動します。同じ位置で繰り返し
クリックすると、同じ分量のスクロールを繰り返します。

スクロール以外では、スクロールバーで`C-Mouse-2'をクリックすると、ウィン
ドウを上下に分割できます。クリックした場所の行で分割されます。

コマンド`M-x scroll-bar-mode'で、
スクロールバー（scroll-bar）モードをオン／オフできます。
引数を指定しなければ、スクロールバーの使用をトグルします。
引数を指定した場合、引数が正のときだけスクロールバーを使うようにします。
このコマンドは、これから作成されるフレームを含めてすべての
フレームに作用します。
Xのリソース`verticalScrollBars'を使って、
スクロールバー（scroll-bar）モードの初期設定を制御できます。
*Note Resources X::。

選択されているフレームに対してのみスクロールバーをオン／オフするには、
`M-x toggle-scroll-bar'コマンドを使います。



File: emacs-ja, Node: Menu Bars, Next: Support Modes, Prev: Scroll Bars

メニューバー
============

`M-x menu-bar-mode'でメニューバーの表示をオン／オフできます。引数を指定
しないと、このコマンドはマイナモードであるメニューバー（menu-bar）モー
ドをトグルします。引数を指定した場合、引数が正ならメニューバー
（menu-bar）モードをオンにし、引数が正でないならオフにします。Xのリソー
ス`menuBarLines'を使って、メニューバー（menu-bar）モードの初期設定を制
御できます。*Note Resources X::。熟練したユーザーは、メニューバーをしば
しばオフにし、特に文字端末上ではそうします。というのは、テキスト表示に
1行余分に使えるからです。

メニューバーでコマンドを起動する方法については、*Note Menu Bar::。



File: emacs-ja, Node: Faces, Next: Support Modes, Prev: Scroll Bars

複数タイプフェイスの利用
========================

XでEmacsを使っているとき、文字表示に複数のスタイルを設定できます。制御
できるスタイルは、フォントの種類、前景色、背景色、下線を引くかどうかで
す。MS-DOS用Emacsは、各フェイスの前景色と背景色を制御して、フェイスの一
部だけを扱えます（*Note MS-DOS::）。

表示スタイルを制御する方法は、名前付き"フェイス"を定義することです。各
フェイスでは、フォントの種類、前景色、背景色、下線フラグを指定できます。
しかし、これらすべてを指定する必要はありません。バッファ内のテキストの
一部分に対して使用するフェイスを指定することで、そのテキストの見た目を
制御できます。

テキスト中のある文字に対して使う表示スタイルは、いくつかのフェイスを組
み合わせて決定されます。重ね合わせやテキスト属性で指定されていない表示
スタイルは、フレームそのものから得ます。

整形済みテキストを編集するモードであるエンリッチ（enriched）モードには、
フェイスを指定するためのコマンドやメニューがあります。バッファ内のテキ
ストに対するフォントの指定方法については、*Note Format Faces::。前景色
と背景色の指定方法については、*Note Format Colors::。

フェイスの見た目を変更するには、カスタマイズバッファを使います*Note
Face Customization::。Xのリソースを使って、特定のフェイスの属性を指定で
きます（*Note Resources X::）。

現在定義されているフェイスとその見た目を調べるには、`M-x
list-faces-display'と打ちます。あるフェイスを違うフレームでは違って見え
るようにできます。このコマンドは、コマンドを打ったフレーム上での見た目
を表示します。つぎは、標準的に定義されているフェイス一覧です。

`default'
     このフェイスは、他のフェイスを指定していない普通のテキストに使われ
     る。
`modeline'
     このフェイスはモード行に対して使われる。
     デフォルトでは、`default'フェイスの反転表示を設定。
     *Note Display Vars::。
`highlight'
     このフェイスは、さまざまモードでのテキストの強調表示部分に対して使
     われる。
`region'
     このフェイスは、選択されているリージョン（暫定マーク
     （transient-mark）モードがオンのとき。下記参照）の表示に使われる。
`secondary-selection'
     このフェイスは、二次セレクションの表示に使われる（*Note Secondary
     Selection::）。
`bold'
     このフェイスは、ボールド体（太字体）があるならば、ボールド体を用い
     たデフォルトフォントの変種。
`italic'
     このフェイスは、イタリック体（斜体）があるならば、イタリック体を用
     いたデフォルトフォントの変種。
`bold-italic'
     このフェイスは、ボールドイタリック体（太字斜体）があるならば、ボー
     ルドイタリック体を用いたデフォルトフォントの変種。
`underline'
     このフェイスは、テキストに下線を引く。

暫定マーク（transient-mark）モードがオンのときは、
マークが活性ならば、リージョンのテキストは強調表示されます。
これには`region'という名前のフェイスを使います。
このフェイスのスタイルを変更することで、
強調表示のスタイルを制御できます（*Note Face Customization::）。
暫定マーク（transient-mark）とマークの活性／不活性について詳しくは、
*Note Transient Mark::。

フェイスを使う簡単な方法の1つは、
フォントロック（font-lock）モードを使うことです。
特定のバッファにつねにローカルであるこのマイナモードは、
編集するテキストの構文に従ってフェイスを選択します。
このモードは、ほとんどの言語のコメントと文字列を認識できます。
いくつかの言語では、それ以外のさまざまな重要な構造も認識して、
適切に強調表示します。
フォントロック（font-lock）モードと構文の強調表示について詳しくは、
*Note Font Lock::。

画面上で強調表示されたバッファは、
コマンド`ps-print-buffer-with-faces'を使って印刷できます。
*Note Postscript::。



File: emacs-ja, Node: Font Lock, Next: Support Modes, Prev: Scroll Bars

フォントロックモード
====================

フォントロック（font-lock）モードはマイナモードです。特定のバッファにつ
ねにローカルであり、編集しているテキストの構文に従ってさまざまなフェイ
スを使って強調表示（または『フォント表示化』）します。このモードは、ほ
とんどの言語のコメントや文字列を認識できます。いくつかの言語では、他の
さまざまな重要な構成要素も認識し、正しく強調表示します。  たとえば、定
義されている関数名や予約語です。

コマンド`M-x font-lock-mode'は、引数に従ってフォントロック（font-lock）
モードをオン／オフし、引数がなければモードをトグルします。関数
`turn-on-font-lock'は、フォントロック（font-lock）モードを無条件でオン
にします。このコマンドは、モードフック関数で使うと便利です。たとえば、
Cのファイルを編集しているときにはいつでもフォントロック（font-lock）モー
ドをオンにするには、つぎのようにします。

     (add-hook 'c-mode-hook 'turn-on-font-lock)

フォントロック（font-lock）モードを扱えるすべての（メジャー）モードで自
動的にフォントロック（font-lock）モードをオンにするには、関数
`global-font-lock-mode'をつぎのように使います。

     (global-font-lock-mode 1)

フォントロック（font-lock）モードでは、テキストを編集していると、自動的
に変更した行の強調表示を更新します。ほとんどの変更は、後続行の強調表示
には影響しませんが、時折、影響することもあります。ある範囲の行を強調表
示し直すには、コマンド`M-g M-g'を使います（`font-lock-fontify-block'）。

ある種のメジャーモードでは、`M-g M-g'は、現在の関数定義全体をフォント表
示化し直します。（変数`font-lock-mark-block-function'は、現在の関数定義
の探し方を制御する。）別のメジャーモードでは、 `M-g M-g'は、ポイントの
まえとあとの16行をフォント表示化し直します。

数引数Nを指定すると、`M-g M-g'は、モードに関係なく、 ポイントのまえとあ
とのN行をフォント表示化し直します。

フォントロック（font-lock）モードの利点を十分に活用するには、ボールド体、
イタリック体、ボールドイタリック体のデフォルトフォントを選ぶ必要があり
ます。あるいは、カラーやグレースケールの画面が必要です。

変数`font-lock-maximum-decoration'は、複数のレベルを提供するモードでの
フォント表示化の好ましいレベルを指定します。レベル1は最低限のフォント表
示化です。いくつかのモードでは、もっとも高い3のレベルまであります。通常
デフォルトは『可能な限り大きい数』です。すべてのモードに適用する整数を
指定できます。あるいは、特定のメジャーモードに対して異なる数を指定でき
ます。たとえば、C/C++モードではレベル1を、それ以外ではデフォルトのレベ
ルを指定するには、つぎのようにします。

     (setq font-lock-maximum-decoration
           '((c-mode . 1) (c++-mode . 1)))

フォント表示化は、大きなバッファに対してはとても遅くなりえますから、抑
制することもできます。変数`font-lock-maximum-size'にバッファサイズを指
定すると、その値を越えるバッファについてはフォント表示化を抑制します。

コメントと文字列のフォント表示化（あるいは、『構文の』フォント表示化）は、
バッファのテキストの構文解析に頼っています。
速度向上のために、CモードやLispモードを含むいくつかのモードでは、
特別な習慣に頼っています。
最左桁にある開き括弧は、つねに関数定義の開始を表し、
そのため、つねに文字列やコメントの外側だということです。
（*Note Defuns::。）
この習慣に従わないと、フォントロック（font-lock）モードは、
文字列やコメントの内側にある最左桁の開き括弧のうしろでは、
違ったフォント表示化をすることもありえます。

変数`font-lock-beginning-of-syntax-function' （つねにバッファにローカル）
は、フォントロック（font-lock）モードが、コメントや文字列の外側であるこ
とが保証される位置をどのように探すかを指定します。最左桁の括弧の習慣を
使うモードでは、変数のデフォルト値は、`beginning-of-defun'です。  つま
り、フォントロック（font-lock）モードは習慣を使うようにということです。
この変数に`nil'を設定すると、フォントロック（font-lock）モードは、もは
や習慣に頼りません。これでまちがった結果を避けられますが、その代償は、
変更したテキストをフォント表示化するには、バッファのテキストをバッファ
の先頭から再走査する必要がある場合もあります。

多くのモードに対するフォントロックの強調表示パターンはすでにありますが、
フォント表示化するパターンを追加したいこともあるでしょう。関数
`font-lock-add-keywords'を使って、特定のモードに対する個人用の強調表示
パターンを追加できます。たとえば、Cのコメントで単語`FIXME:'を強調表示す
るには、つぎのように使います。

     (font-lock-add-keywords
      'c-mode
      '(("\\<\\(FIXME\\):" 1 font-lock-warning-face t)))



File: emacs-ja, Node: Support Modes, Next: Highlight Changes, Prev: Scroll Bars

フォントロックのモード
======================

フォントロックには、大きなバッファに対してフォントロック（font-lock）モー
ドを高速に動作させるモードがあります。高速ロック（fast-lock）モードと遅
延ロック（lazy-lock）モードです。これらは、フォントロック（font-lock）
モードの速度を向上するために2つの異なる方法を使います。

* Menu:

* Fast Lock Mode::      Saving font information in files.
* Lazy Lock Mode::      Fontifying only text that is actually displayed.
* Fast or Lazy::        Which support mode is best for you?



File: emacs-ja, Node: Fast Lock Mode, Next: Fast or Lazy, Prev: Support Modes, Up: Support Modes

高速ロックモード
----------------

大きなファイルを訪問したバッファに対してフォントロック（font-lock）モー
ドを速くするには、高速ロック（fast-lock）モードを使えます。高速ロック
（fast-lock）モードは、各ファイルに対するフォント情報を別のキャッシュファ
イル（cache file）に保存します。ファイルを訪問するたびに、最初からテキ
ストをフォント表示化し直すかわりに、キャッシュファイルからフォント情報
を読み直します。

コマンド`M-x fast-lock-mode'は、引数に従って高速ロック（fast-lock）モー
ドをオン／オフします（引数がないければトグル）。フォントロック
（font-lock）モードを使うときに、いつでも高速ロック（fast-lock）モード
をオンにするには、つぎのようにします。

     (setq font-lock-support-mode 'fast-lock-mode)

小さなバッファに対しては、キャッシュファイルを書く価値がありません。そ
れゆえ、変数`fast-lock-minimum-size'は、フォント情報をキャッシュする最
小のファイルサイズを指定します。

変数`fast-lock-cache-directories'は、
キャッシュファイルをどこに置くかを指定します。
その値は、ディレクトリ群のリストです。
`"."'は、編集しているファイルと同じディレクトリを表します。
デフォルト値は、`("." "~/.emacs-flc")'で、
可能ならば同じディレクトリを使い、
さもなければディレクトリ`~/.emacs-flc'を使うという意味です。

変数`fast-lock-save-others'は、あなたが所持していないファイルに対する
キャッシュファイルを高速ロック（fast-lock）モードが保存すべきかどうかを
指定します。値が`nil'以外ならば保存します（これがデフォルト）。



File: emacs-ja, Node: Lazy Lock Mode, Next: Fast or Lazy, Prev: Fast Lock Mode, Up: Support Modes

遅延ロックモード
----------------

大きなバッファに対してフォントロック（font-lock）モードを速くするには、
フォント表示化するテキストの量を減らす遅延ロック（lazy-lock）モードを使
えます。遅延ロック（lazy-lock）モードでは、バッファのフォント表示化は要
求駆動型です。表示されようとしているバッファの部分だけをフォント表示化
します。また、変更部分のフォント表示化は延期され、Emacsがある短い時間ア
イドルであったときにのみフォント表示化します。

コマンド`M-x lazy-lock-mode'は、遅延ロック（lazy-lock）モードを引数に従っ
てオン／オフします（引数がなければトグル）。フォントロック（font-lock）
モードを使うときに、いつでも遅延ロック（lazy-lock）モードをオンにするに
は、つぎのようにします。

     (setq font-lock-support-mode 'lazy-lock-mode)

小さなバッファに対してバッファのフォント表示化を避ける価値はありません。
ですから、変数`lazy-lock-minimum-size'は、要求駆動型でバッファのフォン
ト表示化を行う最小のバッファサイズを指定します。これより小さなバッファ
は、普通のフォントロック（font-lock）モードのように一度にフォント表示化
します。

バッファを変更したとき、遅延ロック（lazy-lock）モードは変更したテキスト
のフォント表示化を延期します。変数`lazy-lock-defer-time'は、変更部分の
フォント表示化を始めるまでにEmacsがアイドルであるべき秒数です。この値が
0ならは、普通のフォントロック（font-lock）モードと同じように、変更はす
ぐにフォント表示化されます。

遅延ロック（lazy-lock）モードは、通常、新たに見えてくるバッファ部分が初
めて表示されるまえにその部分をフォント表示化します。しかし、
`lazy-lock-defer-on-scrolling'の値が`nil'以外ならば、新たに見えてくるテ
キストは、Emacsが`lazy-lock-defer-time'秒だけアイドルしたときにのみフォ
ント表示化されます。

CやEmacs Lispモードを含むいくつかのモードでは、
ある1行の内容を変更すると後続行の文脈が変わり、
そのため、後続行をどうフォント表示化するかも変わります。
通常は、後続行を再フォント表示化するために`M-g M-g'を打つ必要があります。
しかし、変数`lazy-lock-defer-contextually'に
`nil'以外を設定していると、遅延ロック（lazy-lock）モードでは、
`lazy-lock-defer-time'秒後にこれを自動的に行います。

Emacsが長時間アイドルだと、遅延ロックは、バッファのまだ表示されていない
部分を、のちの表示に備えてフォント表示化します。これを"内密のフォント表
示化"（stealth fontification）と呼びます。

変数`lazy-lock-stealth-time'は、内密のフォント表示化を開始するまでに、
Emacsが何秒間アイドルであるべきかを指定します。値が`nil'だと、内密のフォ
ント表示化をしません。変数`lazy-lock-stealth-lines'と
`lazy-lock-stealth-verbose'は、内密のフォント表示化の粒度と冗長性を指定
します。



File: emacs-ja, Node: Fast or Lazy, Prev: Fast Lock Mode, Up: Support Modes

高速ロックか遅延ロックか？
--------------------------

フォントロックで使えるモードの1つを選択する目安となる簡単な指針をあげま
す。

   * 高速ロック（fast-lock）モードは、ファイルの訪問とバッファの削除
     （と関連する事象）の最中に作業する。それゆえ、バッファの編集やウィ
     ンドウのスクロールは、普通のフォントロック（font-lock）モードより
     速くも遅くもない。

   * 高速ロック（fast-lock）モードのキャッシュファイルの読み込みは、遅
     延ロック（lazy-lock）モードがウィンドウをフォント表示化するより遅
     い。よって、高速ロック（fast-lock）モードは、遅延ロック
     （lazy-lock）モードよりファイルの訪問が遅い。

   * 遅延ロック（lazy-lock）モードは、ウィンドウをスクロールする最中に、
     画面上に現れるテキストをフォント表示化する。よって、スクロールは、
     通常のフォントロック（font-lock）モードより遅い。

   * 遅延ロック（lazy-lock）モードは、バッファを編集中はフォント表示化
     しない（変更部分のフォント表示化を延期する）。よって、編集は、通常
     のフォントロック（font-lock）モードより速い。

   * 高速ロック（fast-lock）モードは、版管理の下に置かれたファイルでは
     だまされることがある。よって、そのファイルに対するキャッシュファイ
     ルが存在していても、バッファのフォント表示化が起こりえる。

   * 高速ロック（fast-lock）モードは、ファイルを訪問しているバッファで
     のみ動作する。遅延ロック（lazy-lock）モードは、どのバッファでも動
     作する。

   * 高速ロック（fast-lock）モードは、キャッシュファイルを生成する。遅
     延ロック（lazy-lock）モードは、生成しない。

変数`font-lock-support-mode'は、これらのどちらのモードを使うかを指定し
ます。たとえば、C/C++モードでは高速ロック（fast-lock）モードを使い、そ
れ以外のモードでは遅延ロック（lazy-lock）モードを使うように指定するには、
変数をつぎのように設定します。

     (setq font-lock-support-mode
           '((c-mode . fast-lock-mode) (c++-mode . fast-lock-mode)
             (t . lazy-lock-mode)))



File: emacs-ja, Node: Highlight Changes, Next: Misc X, Prev: Support Modes

変更部分強調表示モード
======================

バッファ内の最近に変更された部分を示すためにフェイス（典型的には表示色）を
用いるマイナモードをオンにするには、
`M-x highlight-changes-mode'を使います。



File: emacs-ja, Node: Misc X, Prev: Highlight Changes

その他のXウィンドウシステムでの機能
===================================

つぎのコマンドは、フレームを作成したり削除したり操作したりします。

`C-z'
     選択されているEmacsフレームをアイコン化する
     （`iconify-or-deiconify-frame'）。Emacsを休止するという`C-z'の通常
     の意味は、ウィンドウシステムでは有用ではない。そのため、別のバイン
     ドになっている。

     Emacsフレームのアイコンでこのコマンドを打つと、アイコンをフレーム
     に開く。

`C-x 5 0'
     選択されているフレームを削除する（`delete-frame'）。フレームがたっ
     た1つの場合には、このコマンドは許されない。

`C-x 5 o'
     別のフレームを選択し、それをいちばん手前にもってきて、そのフレーム
     が選択されるようにマウスを飛び込ませる。このコマンドを繰り返すと、
     端末上のすべてのフレームを巡回する。



File: emacs-ja, Node: Non-Window Terminals, Prev: Misc X

非ウィンドウ端末
================

Emacsが扱えるウィンドウシステムを使えない端末では、一度に1つのフレーム
しか表示できません。しかし、複数のEmacsフレームを作って、それらのフレー
ム間を切り替えられます。このような端末でのフレームの切り替えは、異なる
ウィンドウ構成の端末での切り替えとたいへんよく似ています。

新しいフレームを作りそれに切り替えるには、`C-x 5 2'を使います。既存のフ
レーム間を巡回するには、`C-x 5 o'を使います。カレントフレームを削除する
には、`C-x 5 0'を使います。

各フレームにはそれを区別する番号があります。一度には1つのフレームだけし
か表示できない端末では、選択されているフレームの番号Nが、モード行の先頭
近くに`FN'という形式で現れます。

`FN'は、実際にはフレームの名前です。望むなら別の名前を指定でき、その名
前でフレームを選択できます。選択されたフレームに新しい名前を指定するに
は、コマンド`M-x set-frame-name RET NAME RET'を使います。その名前でフレー
ムを選択するには、`M-x select-frame-by-name RET NAME RET'を使います。指
定した名前は、フレームを選択するとモード行に表示されます。



File: emacs-ja, Node: International, Next: Major Modes, Prev: Frames, Up: Top

国際化文字集合の使い方 *(2005/09/19)*
*************************************

Emacsでは広範囲の国際化文字集合を使えます。ラテンアルファベットの変種で
あるヨーロッパの言語はもちろん、中国語、キリル文字，デバナーガリー（ヒ
ンディー語とマラッタ語）、エチオピア語、ヘブライ語，ギリシア語、
IPA（International Phonetic Alphabet、万国表音文字）、日本語、韓国語、
ラオ語、ロシア語、タイ語、チベット語、ベトナム語の文字を含んでいます。
これらの機能は、MULE（『MULti-lingual Enhancement to GNU Emacs』）とし
て知られるEmacsの修正版から併合しました。

ワープロやメイラーのような他の国際化されたソフトにおいて使われる文字で
利用される様々なエンコードもサポートしています．

Emacsでは様々な文字の編集を行うことができます．

   * 非ASCII文字のテキストファイルを開き，保存し(コンパイラやスペルチャッ
     カやメイラーのような)プログラムを起動することで非ASCIIのテキストを
     渡すことができます．言語環境の設定(*Note Language Environments::)
     は特有の言語や環境に関する文字コードや他のオプションを設定します．

   * さまざまなスクリプトでエンコードされた非ASCII文字を表示できます．
     X上では適切なフォントやよく似たグラフィックスを用い(*Note
     Defining Fontsets::)，テキスト端末には特別なコードを送信して表示し
     ます．もしいくつかの文字が適切に表示されない時には *Note
     Undisplayable Characters::を参照ください．そこには，可能性のある問
     題点や解決方法が書いてあります．

   * 非ASCII文字を入力したり，検索したりできます．そのためには，その言
     語に適した入力方法(*Note Select Input Method::)にするか，自分の言
     語環境に合わせたデフォルトの入力方法を使う必要があります(Emacsの入
     力メソッドはLeimパッケージの機能であり，適切にインストールしてある
     必要があります)．キーボードが非ASCII文字を入力できるのであれば，キー
     ボードのコードを適切に選択しておかなければなりません (*Note
     Specify Coding::)．そうすれば，Emacsはこの文字を受け付けることがで
     きます．プレフィックス`C-x 8'を使うことで，Latin-1の文字を入力する
     ことができます．詳しくは*Note C-x 8: Single-Byte Character
     Supportを参照ください．X Window システムではEmacsがキーボード入力
     を適切に解釈できるように言語環境を設定する必要があります．詳細は
     *Note locales: Language Environmentsを参照ください．

この章の残りでは，これらの詳細を説明します．

* Menu:

* International Chars::     Basic concepts of multibyte characters.
* Enabling Multibyte::      Controlling whether to use multibyte characters.
* Language Environments::   Setting things up for the language you use.
* Input Methods::           Entering text characters not on your keyboard.
* Select Input Method::     Specifying your choice of input methods.
* Multibyte Conversion::    How single-byte characters convert to multibyte.
* Coding Systems::          Character set conversion when you read and
                              write files, and so on.
* Recognize Coding::        How Emacs figures out which conversion to use.
* Specify Coding::          Various ways to choose which conversion to use.
* Fontsets::                Fontsets are collections of fonts
                              that cover the whole spectrum of characters.
* Defining Fontsets::       Defining a new fontset.
* Undisplayable Characters:: When characters don't display.
* Single-Byte Character Support::
                            You can pick one European character set
                            to use without multibyte characters.
* Charsets::                How Emacs groups its internal character codes.



File: emacs-ja, Node: International Chars, Next: Enabling Multibyte, Prev: International, Up: International

国際化文字集合の紹介
====================

これらの文字のユーザーは、ファイルに格納するために、たくさんの標準的な
コーディングシステムを確立してきました。Emacsは内部的には単一のマルチバ
イト文字符号化を使用しているので、1つのバッファや1つの文字列の中に、こ
れらのすべての文字を混ぜ合わせることができます。この符号化では、非
ASCII文字を0200から0377の範囲のバイトの並びとして表現します。Emacsは、
ファイルを読み書きするとき、サブプロセスとデータを交換するとき、（場合
によっては）`C-q'コマンドを使うときに、マルチバイト文字符号化と他のさま
ざまなコーディングシステムのあいだで変換します（*Note Multibyte
Conversion::）。

コマンド`C-h h'（`view-hello-file'）は、多くの言語で『hello』と書いたファ
イル`etc/HELLO'を表示します。これは、さまざまな字体を例示します。

これらの文字集合を使っている国々であっても、一般にキーボードには、それ
らすべての文字に対するキーはありません。ですから、Emacsではさまざまな"
入力方式"（input methods） (1) (*Note International Chars-Footnotes::)
を使って、便利に文字を打ち込めるようにします。典型的には、1つの字体や1
つの言語について1つの入力方式があります。

プレフィックスキー`C-x RET'は、マルチバイト文字、コーディングシステム、
入力方式に関係するコマンドに使います。


File: emacs-ja  Node: International Chars-Footnotes, Up: International Chars

(1) 【訳注】GNU Emacsをインストールする時点で、対応する版の
LEIM（Library of Emacs Input Method）のソースをGNU Emacsのソースディレ
クトリに展開しておくと、自動的にインストールされる。



File: emacs-ja, Node: Enabling Multibyte, Next: Input Methods, Prev: International Chars, Up: International

マルチバイト文字を使用可能にする
================================

Emacs全体やバッファごとにマルチバイト文字の使用可／使用不可を設定できま
す。バッファでマルチバイト文字を使用不可にすると、そのバッファ内の各バ
イトは1つの文字を表します。たとえコードが0200から0377のあいだであっても
そうです。ヨーロッパの文字集合であるISO Latin-1とISO Latin-2を扱う古い
機能は、Emacs 19で動作していたように動き、他のISO 8859文字集合に対して
も動作します。

しかし、ISO Latinを使うために、マルチバイト文字を使用不可にする必要はあ
りません。Emacsのマルチバイト文字集合にはこれらの文字集合のすべての文字
が含まれ、EmacsはこれらのISOコードと相互に自動的に変換できます。

特定のファイルをユニバイト表現で編集するには、`find-file-literally'を使っ
てファイルを訪問します。*Note Visiting::。マルチバイト表現のバッファを
同じ文字の1バイト表現に変換するには、もっとも簡単な方法は、内容をファイ
ルに保存してから、バッファを削除し、`find-file-literally'でそのファイル
を訪問し直します。`C-x RET c'（`universal-coding-system-argument'）を使っ
て、ファイルを探したり保存するときのコーディングシステムとして
`raw-text'を指定することもできます。*Note Specify Coding::。`raw-text'
としてファイルを探しても、`find-file-literally'のようには、書式変換、圧
縮の展開、モードの自動選択を禁止しません。

デフォルトでマルチバイト文字を使用不可にするには、`--unibyte'オプション
（*Note Initial Options::）を指定してEmacsを始めるか、あるいは、環境変
数`EMACS_UNIBYTE'を設定します。`--unibyte'と同等な効果を得るには、
`enable-multibyte-characters'をカスタマイズするか、これと等価に、初期化
ファイル内で、変数`default-enable-multibyte-characters'を直接設定します。

環境変数の値、`/etc/passwd'の内容などの非ASCII 8ビット文字からの初期化
中にはマルチバイト文字列は作られません。しかし、`--unibyte'を指定したと
しても、一般のLispファイルのように、初期化ファイルは、通常、マルチバイ
トとして読み込みます。それらに含まれる非ASCII文字からマルチバイト文字列
が生成されるのを防ぐには、1行目の注釈に`-*-unibyte: t;-*-'を入れておき
ます。gnusなどのパッケージの初期化ファイルでも同じことをします。

モード行には、カレントバッファでマルチバイト文字が使用可かどうか表示さ
れます。使用可ならば、モード行の先頭付近のコロンのまえに2文字か数文字
（ほとんどの場合ダッシュ2個）があります。マルチバイト文字が使用不可なら
ば、コロンのまえにはダッシュが1個だけです。



File: emacs-ja, Node: Language Environments, Next: Input Methods, Prev: Enabling Multibyte, Up: International

言語環境
========

マルチバイト文字が使用可のときはいつでも、すべての扱える文字集合を
Emacsバッファの中で使えます。ある言語の文字を表示するために、Emacsバッ
ファでその言語を選択する必要はありません。しかし、さまざまなデフォルト
を設定するために"言語環境"を選択しておくことは重要です。言語環境は、言
語の選択というより、（多かれ少なかれ）実際には好みの文字を表します。

言語環境は、テキストを読み込むときにどのコーディングシステムを認識する
かを制御します（*Note Recognize Coding::）。言語環境は、ファイル、到着
メイル、ニュース、Emacsへ読み込むその他のテキストに適用されます。言語環
境は、ファイルを作成したときに使うデフォルトのコーディングシステムを指
定することもあります。各言語環境は、デフォルトの入力方式も指定します。

言語環境を選択するには、コマンド`M-x set-language-environment'を使いま
す。このコマンドを使ったときにどのバッファがカレントバッファであるかは
関係ありません。というのは、その効力は、そのEmacsセッションに全体に適用
されるからです。以下の言語環境を使えます。

     Chinese-BIG5、Chinese-CNS、Chinese-GB、Cyrillic-Alternativnyj、
     Cyrillic-ISO、Cyrillic-KOI8、Devanagari、English、Ethiopic、Greek、
     Hebrew、Japanese、Korean、Lao、Latin-1、Latin-2、Latin-3、Latin-4、
     Latin-5、Thai、Tibetan、Vietnamese。

いくつかのオペレーティングシステムでは、ローケル（locale）環境変数を設
定することで言語を指定できます。Emacsは、このよくある特別な場面を扱いま
す。文字種を表すローケル名が文字列`8859-N'を含むなら、Emacsは自動的に対
応する言語環境を選択します。

ある言語環境LANG-ENVの効果についての情報を表示するには、コマンド`C-h L
LANG-ENV RET' （`describe-language-environment'）を使います。このコマン
ドは、その言語環境がどの言語に役立つのか、その言語で使われる文字集合、
コーディングシステム、入力方式の一覧を表示します。また、その言語環境で
使われる文字を例示する例文も表示します。デフォルトでは、このコマンドは
選択されている言語環境を記述します。

どの言語環境もノーマルフック`set-language-environment-hook'でカスタマイ
ズできます。コマンド`set-language-environment'は、新しい言語環境を設定
したあとでこのフックを実行します。フック関数では、変数
`current-language-environment'を検査すれば、言語環境を知ることができま
す。

`set-language-environment'は、新しい言語環境を設定し始めるまえに、
まずフック`exit-language-environment-hook'を実行します。
このフックは、（直前の言語環境を設定した）
`set-language-environment'で施したカスタマイズをもとに戻すのに便利です。
たとえば、`set-language-environment-hook'を使って設定した
特定の言語環境で特別なキーバインディングを定義したときには、
それをそのキーのもとのバインディングに戻すために
`exit-language-environment-hook'を設定するべきです。



File: emacs-ja, Node: Input Methods, Next: Select Input Method, Prev: Enabling Multibyte, Up: International

入力方式
========

"入力方式"（input method）は、対話的に入力するために特別に設計された文
字変換の一種です。Emacsでは、典型的には、各言語向けに専用の入力方式があ
ります。ときには、同じ文字を使ういくつかの言語で入力方式を共有します。
複数の入力方式を使う言語も少しはあります。

入力方式のもっとも単純なものは、ASCII文字を別のアルファベットに対応させ
ることで動作します。ギリシア語とロシア語の入力方式はこのように動作しま
す。

より強力な方法は合成で、文字の列を1つの文字に変換します。多くのヨーロッ
パの入力方式は、文字のうしろにアクセント文字が続く列（あるいはその逆順）
から、1つの非ASCII文字を生成する合成を使います。たとえば、いくつかの入
力方式では、文字の列`a''を1つのアクセント付き文字に変換します。これらの
入力方式には、その方式に固有の特別なコマンドはありません。印字文字の列
を合成するだけです。

音節文字用の入力方式では、典型的には、対応付けたあとで合成します。タイ
語と韓国語の入力方式は、この方法で動作します。まず、文字を音声記号に対
応付けます。そして、1つの音節全体を構成するそれらの列を1つの音節記号に
対応付けます。

中国語や日本語では、より複雑な方法が必要です。
中国語の入力方式では、まず、中国語の単語の発音表記を入力する
（とりわけ入力方式`chinese-py'）か、
1文字の各部分部分の列（とりわけ入力方式`chinese-4corner'や
`chinese-sw'）を入力します。
1つの発音表記は、普通、多くの異なる中国語の文字に対応しているので、
特別なEmacsコマンドを使って候補群から1つを選ぶ必要があります。
`C-f'、`C-b'、`C-n'、`C-p'と数字キーは、
この状況で候補を選ぶために使われる特別な定義になっています。
TABは、すべての候補をバッファに表示します。

日本語の入力方式 (1) (*Note Input Methods-Footnotes::) では、まず、発音
表記を使って1つの単語全体を入力します。そして、単語がバッファに入ったあ
とで、Emacsは大きな辞書を使って1つ以上の文字へ変換します。1つの発音表記
は、たくさんの異なる日本語の単語に対応しているので、その中から選ぶ必要
があります。候補を巡回するには、`C-n'や`C-p'を使います。


ときには、入力方式での処理を切り離したほうが便利なことがあります。そう
すれば、入力した文字は後続の入力文字と結合されません。たとえば、入力方
式`latin-1-postfix'では、キー列`e ''は結合されてアクセント付き`e'になり
ます。これらを別々の文字として入力したいときはどうするのでしょう？

1つの方法は、アクセントを2回打つことです。これは、アルファベットとアク
セントを別々に入力する特別な機能です。たとえば、`e ' ''は、2つの文字
`e''になります。別の方法は、`e'のあとに結合されない別の文字を打ってから、
すぐにそれを消すことです。たとえば、 `e'と`''を入力するには、`e e
DEL''と打ちます。

別の方法はより一般的ですが、打つのは簡単ではありません。2つの文字のあい
だで`C-\ C-\'を打って、結合を止めます。これは、コマンド
`C-\'（`toggle-input-method'）を2回使っています。
*Note Select Input Method::。

`C-\ C-\'は、インクリメンタルサーチの中では特に便利です。というのは、結
合する文字を待つことを止めて、すでに入力したものを探索し始めるからです。

 変数`input-method-highlight-flag'と`input-method-verbose-flag'は、入力
方式に何が進行中かをどのように表示させるかを制御します。
`input-method-highlight-flag'が`nil'以外ならば、バッファでは（入力途中
の）部分列を強調表示します。`input-method-verbose-flag'が`nil'以外なら
ば、（ミニバッファの中でなければ）つぎに打鍵できる文字の一覧をエコー領
域に表示します。


