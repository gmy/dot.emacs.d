Info file: emacs-ja,    -*-Text-*-
produced by `texinfo-format-buffer'
from file `emacs.texi'
using `texinfmt.el' version 2.41 of  1 Mar 2005.

INFO-DIR-SECTION Emacs
START-INFO-DIR-ENTRY
* Emacs-ja: (emacs-ja).	            Emacs21.3日本語マニュアル.
END-INFO-DIR-ENTRY








File: emacs-ja  Node: Interlocking-Footnotes, Up: Interlocking

(1) 【訳注】進行中の動作が完了するまでは、つぎの動作を開始させないよう
にすること。



File: emacs-ja, Node: Reverting, Next: File Aliases, Prev: Saving

バッファを復元する
==================

広範囲にファイルを変更したあとで気が変わったときには、そのような変更を
捨てるためにファイルのまえの版を読み込みます。これには、カレントバッファ
に作用する`M-x revert-buffer'を使います。意図せずにバッファを復元するこ
とは、たくさんの作業結果を失うことになるので、このコマンドには`yes'で確
認を与える必要があります。

`revert-buffer'は、ファイルの先頭から同じ距離（文字数）にポイントを保ち
ます。少し編集しただけなら、復元前後のポイント位置はだいたい同じ部分に
あります。徹底的に変更してしまったときには、古いファイルでのポイント位
置ではまったく異なるテキスト部分に位置付けるでしょう。

復元すると、改めて変更するまでは、そのバッファには『変更なし』の印が付
きます。

diredバッファのように、ファイル以外のデータを反映するバッファでも復元で
きる場合があります。その場合、復元とは、適切なデータに基づいて内容を計
算し直すことを意味します。`C-x b'で明示的に作ったバッファを復元すること
はできません。そういった指示をすると、`revert-buffer'はエラーを報告しま
す。

自動的にかつ頻繁に変更されるファイル、たとえば、実行中のプロセスから出
力されるログ、を編集するときには、`C-x C-f'でファイルを再訪問すると何も
聞かずにファイルを復元できると便利です。

こういったふるまいを指示するには、変数`revert-without-query'に正規表現
のリストを設定します。これらの正規表現の1つにファイル名が一致すると、
`find-file'と`revert-buffer'は、バッファが変更されていない限り、そのファ
イルが変更されていても復元します。（テキストを編集してしまったときには、
変更を捨てさるのはまちがっている。）



File: emacs-ja, Node: Auto Save, Next: File Aliases, Prev: Reverting

自動保存、不慮の事故に対する備え
================================

Emacsは（打鍵数に基づいて）定期的に、訪問しているすべてのファイルを何も
聞かずに保存します。これを"自動保存"（auot-saving）と呼びます。これは、
システムがクラッシュしたときに失ってしまう作業結果をある程度以下に制限
します。

自動保存を実施する時間になるとEmacsは各バッファを調べて、そのバッファに
自動保存が指定されていて、かつ、最後に自動保存した以後に変更されている
場合は、そのバッファを自動保存します。実際にファイルを自動保存すると、
エコー領域にメッセージ`Auto-saving...'を表示します。自動保存の最中に発
生したエラーは捕獲されるので、打ち込んだコマンドの実行に干渉することは
ありません。

* Menu:

* Files: Auto Save Files.       The file where auto-saved changes are
                                  actually made until you save the file.
* Control: Auto Save Control.   Controlling when and how often to auto-save.
* Recover::		        Recovering text from auto-save files.



File: emacs-ja, Node: Auto Save Files, Next: Auto Save Control, Prev: Reverting, Up: Reverting

自動保存ファイル
----------------

自動保存は、通常、訪問先のファイルそのものへは保存しません。というのは、
予定の半分を変更しただけでプログラムにまだ一貫性がないのに保存してしま
うのは望ましくないからです。そのかわりに"自動保存ファイル"と呼ばれる別
のファイルに自動保存し、（`C-x C-s'などで）明示的に保存するよう指示され
たときだけ、訪問先のファイルに保存します。

通常、自動保存ファイルの名前は、訪問先のファイルの名前の前後に`#'を付加
したものです。したがって、ファイル`foo.c'を訪問したバッファは、ファイル
`#foo.c#'に自動保存されます。ファイルを訪問していないほとんどのバッファ
は、明示的に指定したときだけ自動保存されます。それらのバッファの自動保
存ファイルの名前は、バッファ名のまえに`#%'、あとに`#'を付けたものになり
ます。たとえば、送信するメッセージを作成するバッファ`*mail*'は、
`#%*mail*#'というファイルに自動保存されます。自動保存ファイルの名前は、
Emacsの一部（関数`make-auto-save-file-name'と`auto-save-file-name-p'）
をプログラムし直さない限り、この方法で作られます。バッファの自動保存に
使うファイル名は、そのバッファで自動保存をオンにしたときに計算されます。

大きなバッファで相当量のテキストを削除したときには、
そのバッファの自動保存を一時的にやめます。
意図せずにテキストを削除してしまった場合には、
自動保存ファイルに削除してしまったテキストが残っているほうが、
自動保存ファイルとしてより役に立つからです。
こうなったあとで自動保存をふたたびオンにするには、
`C-x C-s'でバッファを保存するか、
`C-u 1 M-x auto-save'を使います。

訪問先のファイルそのものに自動保存を行いたい場合には、変数
`auto-save-visited-file-name'に`nil'以外の値を設定します。こうすると、
自動保存と明示的な保存には、何の違いもありません。

訪問先のファイルにバッファを保存すると、バッファの自動保存ファイルは削
除されます。これを禁止するには、変数`delete-auto-save-files'に`nil'を設
定します。`C-x C-w'や`set-visited-file-name'で訪問先ファイル名を変更す
ると、新たな訪問先ファイル名に合わせて自動保存ファイルも改名されます。



File: emacs-ja, Node: Auto Save Control, Next: Recover, Prev: Auto Save Files, Up: Reverting

自動保存の制御
--------------

変数`auto-save-default'が`nil'以外ならば、ファイルを訪問するたびにその
ファイルのバッファの自動保存をオンにします（ただしバッチモードを除く。
*Note Entering Emacs::）。この変数のデフォルトは`t'なので、通常、ファイ
ルを訪問したバッファは自動保存されます。コマンド`M-x auto-save-mode'で、
既存バッファの自動保存をオン／オフできます。他のマイナモードのコマンド
と同じように、正の引数を指定すると`M-x auto-save-mode'は自動保存をオン
にし、0か負の引数を指定すると自動保存をオフにし、引数を指定しないと自動
保存のオン／オフを切り替えます。

Emacsは、最後に自動保存してから何文字打鍵したかに基づいて定期的に自動保
存します。変数`auto-save-interval'には、自動保存の間隔を表す文字数を指
定します。デフォルトは300です。

しばらく打鍵しないでいるときにも自動保存は行われます。変数
`auto-save-timeout'は、自動保存（およびガベッジコレクション）を行うまで
にEmacsが待つべき秒数を表します。（カレントバッファが大きいと、実際の時
間間隔も長くなる。これは、大きなバッファの自動保存には時間がかかるので、
その編集中は邪魔にならないようにするため。）アイドルのときには、自動保
存はつぎの2つのことを達成します。1つは、端末からしばらく離れているとき
に、すべての作業結果が保存されることを保証すること。もう1つは、実際に打
鍵しているときの自動保存をいくぶんでも避けるようにすることです。

重大なエラーを受け取ったときにも、Emacsは自動保存を行います。これには、
`kill %emacs'のようなシェルコマンドでEmacsジョブを強制終了した場合や、
電話回線やネットワーク接続が途切れた場合を含みます。

コマンド`M-x do-auto-save'で、自動保存の実施を明示的に指示できます。



File: emacs-ja, Node: Recover, Prev: Auto Save Control, Up: Reverting

自動保存ファイルからのデータ回復
--------------------------------

コマンド`M-x recover-file RET FILE RET'で、
自動保存ファイルの内容から紛失データを復旧できます。
このコマンドは、FILEを訪問してから、
（確認したあとで）その自動保存ファイル`#FILE#'
から内容を回復します。
そのあとに、`C-x C-s'でFILEそのものに復旧したテキストを保存します。
たとえば、`foo.c'の自動保存のファイル`#foo.c#'から
`foo.c'を復旧するにはつぎのようにします。

     M-x recover-file RET foo.c RET
     yes RET
     C-x C-s

`M-x recover-file'は確認するまえに、指定したファイルと自動保存ファイル
が置かれたディレクトリの一覧を表示するので、それらのサイズや日付を比較
できます。自動保存ファイルのほうが古いと、`M-x recover-file'はそのファ
イルを読み込むようには聞いてきません。

Emacsやコンピュータがクラッシュしても、コマンド`M-x recover-session'を
使えば、編集中だったすべてのファイルを自動保存ファイルから復旧できます。
このコマンドは、まず、記録されている中断されたセッション一覧を表示しま
す。希望する箇所へポイントを移動し、`C-c C-c'と打ちます。

つぎに、 `recover-session'はそのセッションで編集中だった各ファイルにつ
いてそのファイルを復旧するか聞いてきます。`y'を答えると、
`recover-file'を呼び出し、普通のとおりに動作します。もとのファイルとそ
の自動保存ファイルの日付を表示し、ファイルを復旧するかどうかをもう一度
聞いてきます。

`recover-session'が終了すると、復旧を選んだファイルはEmacsバッファに入っ
ています。これらのバッファを保存してください。こうすることで初めてファ
イルに保存できます。

中断されたセッションは、あとで復旧するために
`~/.saves-PID-HOSTNAME'というファイルに記録されています。
これらの名前の`~/.saves'の部分は、
`auto-save-list-file-prefix'の値です。
この変数を個人の`.emacs'ファイルで設定すれば、
別の場所にセッション記録を置くことができます。
しかし、同様に`recover-session'も再定義して、
変更した新しい場所を探すようにする必要があります。
個人の`.emacs'ファイルで`auto-save-list-file-prefix'に
`nil'を設定すると、復旧のためのセッションを記録しません。



File: emacs-ja, Node: File Aliases, Next: Directories, Prev: Reverting

ファイル名の別名
================

シンボリックリンクやハードリンクを使うことで、同じファイルをいくつかの
異なるファイル名で指すことができます。ハードリンクは、ファイルを直接に
指している別の名前です。すべての名前は等しく有効で、それらに優劣はあり
ません。対照的に、シンボリックリンクは定義された別名の一種です。`foo'が
`bar'へのシンボリックリンクであるとき、どちらの名前でもファイルを指せま
すが、`bar'が本当の名前であり、`foo'は別名にすぎません。シンボリックリ
ンクがディレクトリを指しているときには、より複雑な状況になります。

同一のファイルに対して2つの名前で訪問すると、Emacsは通常2つの別々のバッ
ファを作成しますが、その状況を警告します。

同一のファイルを異なる名前で別々のバッファに訪問することを避けたいならば、
変数`find-file-existing-other-name'に`nil'以外の値を設定します。
そうすれば、どのファイル名を指定しようとも、
`find-file'はファイルを訪問している既存のバッファを使います。

変数`find-file-visit-truename'が`nil'以外であれば、
バッファに記録するファイル名は、ユーザーが指定した名前ではなくて、
ファイルの（すべてのシンボリックリンクをその先の名前に置き換えて得られる）
"実名"になります。
`find-file-visit-truename'を設定すると、
`find-file-existing-other-name'も暗に設定されます。



File: emacs-ja, Node: Version Control, Next: Directories, Prev: File Aliases

VC（版管理、バージョンコントロール）
====================================

"版管理システム"は、ファイルの変更されていない部分を通常は一度だけ格納
して、ソースファイルの複数の版を記録できるパッケージです。版管理システ
ムは、各版の作成時刻、作成者、その版の変更部分に関する記述などの履歴情
報も記録します。

Emacsの版管理パッケージはVCと呼ばれます。このコマンドは、3つの版管理シ
ステム、RCS、CVS、SCCSで動作します。GNUプロジェクトでは、フリーソフトウェ
アでありFree Software Foundationから入手できるRCSとCVSを推奨します。

* Menu:

* Introduction to VC::  How version control works in general.
* VC Mode Line::     How the mode line shows version control status.
* Basic VC Editing::    How to edit a file under version control.
* Old Versions::        Examining and comparing old versions.
* Secondary VC Commands::    The commands used a little less frequently.
* Branches::            Multiple lines of development.
* Snapshots::           Sets of file versions treated as a unit.
* Miscellaneous VC::    Various other commands and features of VC.
* Customizing VC::      Variables that change VC's behavior.



File: emacs-ja, Node: Introduction to VC, Next: VC Mode Line, Prev: File Aliases, Up: File Aliases

VC入門
------

VCはEmacsから版管理システムを使えるようにして、編集作業を版管理操作に滑
らかに統合します。VCは統一された版管理インターフェイスを提供するので、
どの版管理システムを使っているかに関わらず、同じ使い方ができます。

本節では、版管理を概観するとともに、VCが扱う版管理システムの概要を説明
します。使用する版管理システムにすでに慣れているならば、本節は読み飛ば
してください。

* Menu:

* Version Systems::  Supported version control back-end systems.
* VC Concepts::      Words and concepts related to version control.



File: emacs-ja, Node: Version Systems, Next: VC Concepts, Prev: Introduction to VC, Up: Introduction to VC

利用可能な版管理システム
........................

VCでは、現在3つの版管理システム、つまり、バックエンドで動作します。RCS、
CVS、SCCSの3つです。

RCSはフリーの版管理システムでFree Software Foundationから入手ができます。
RCSは、扱えるバックエンドの中では、たぶん、もっとも成熟したものです。
VCコマンド群は、RCSに概念的にもっとも近いものです。RCSでできるほとんど
のことはVCからもできます。

CVSは、RCSの上に作られてRCSの機能を拡張していて、より洗練されたリリース
管理、複数ユーザーの並行開発を許しています。CVSの下では、VCの基本的な編
集操作を使えますが、あまり一般的でない操作に関しては、コマンド行から
CVSを呼ぶ必要があります。CVSを使うには保管庫（リポジトリ、repository）
を設定しなければなりませんが、ここで扱うには複雑すぎる話題です。

SCCSはフリーではありませんが、版管理システムとしては広く使われています。
能力の観点からすれば、VCが扱える3つのうちでもっとも弱いです。SCCSに欠け
ている機能（たとえばスナップショット）はVC自身で実現して補っていますが、
複数の枝分かれのようなVCの他のいくつかの機能はSCCSでは利用できません。
RCSを使えない理由があるときに限ってSCCSを使うべきです。



File: emacs-ja, Node: VC Concepts, Prev: Version Systems, Up: Introduction to VC

VCの概念
........

ファイルが版管理の管理下にあるとき、そのファイルは版管理システムに"登録
され"ているといいます。各登録されたファイルには、ファイルの現状とその変
更履歴を記述した対応する"マスタファイル"が存在します。この情報は、現在
の版や以前の版を再構成するのに十分です。通常、マスタファイルには、それ
ぞれの版について、その版の変更点を言葉で記述した"記録項目"も記録されて
います。

版管理の下で管理されているファイルを、そのマスタファイルに対応する"作業
ファイル"と呼ぶこともあります。普通のファイルと同様に、作業ファイルを編
集して変更します。（SCCSやRCSでは、ファイルを編集するまえにファイルを"
ロック" (1) (*Note VC Concepts-Footnotes::) する必要がある。）一連の変
更を終えたら、ファイルを"チェックイン"、つまり、記録項目とともに変更を
マスタファイルに記録します。

CVSでは、1つのマスタファイルに対応する作業ファイルを複数個持てます。し
ばしば、各ユーザーが1個ずつ作業ファイルを持てます。RCSでもこのようにで
きますが、RCSの通常の使い方ではありません。

典型的な版管理システムには、複数のユーザーが同じファイルを使う際の調停
を行うためのなんらかの機構が必要です。1つの方法は（Emacsが同時編集の検
出に使うロックに類似だが、それとは別の）"ロック"を使うことです。別の方
法は、ファイルをチェックインする時点で、他人の変更分を併合することです。

ロックを使う版管理の場合、作業ファイルは変更できないように通常は読み出
し専用です。版管理システムに対して、書き込み可能な作業ファイルを作り、
それをロックするように要求します。一度には1人のユーザーだけがこれをでき
ます。自分の変更分をチェックインすると、ファイルのロックを外し、作業ファ
イルをふたたび読み出し専用にします。これにより、他のユーザーがさらに変
更するためにファイルをロックできるようになります。SCCSはつねにロックを
使いますし、RCSも通常はロックを使います。

RCSでは別の方法もあって、各ユーザーがいつでも作業ファイルを変更できます。
このモードではロックは必要ありませんが、使うこともできます。新版を記録
する方法は、やはりチェックインです。

CVSでは、通常、各ユーザーはいつでも各自の作業ファイルを変更できますが、
チェックイン時に他のユーザーの変更分を併合する必要があります。しかし、
CVSでもロックを使うようにもできます（*Note Backend Options::）。


File: emacs-ja  Node: VC Concepts-Footnotes, Up: VC Concepts

(1) 【訳注】Emacsが同時編集を防ぐためのロックとは別のロック。



File: emacs-ja, Node: VC Mode Line, Next: Basic VC Editing, Prev: Introduction to VC, Up: File Aliases

VCとモード行
------------

版管理の下にあるファイルを訪問すると、Emacsはそのことをモード行に示しま
す。たとえば、`RCS-1.3'は、そのファイルにはRCSが使われていて、現在の版
が1.3であることを表します。

バックエンドの名前と版番号のあいだの文字は、ファイルの版管理状態を示します。
`-'は、（ロックを使っているのであれば）
作業ファイルがロックされていないこと、あるいは、
（ロックを使っていないのであれば）ファイルが変更されていないことを表します。
`:'は他のユーザー（たとえば、`jim'）がロックしていることを表し、
`RCS:jim:1.3'のように表示されます。



File: emacs-ja, Node: Basic VC Editing, Next: Old Versions, Prev: VC Mode Line, Up: File Aliases

VC下の基本的な編集
------------------

主要なVCコマンドは、状況に応じてロックかチェックインを行う汎用コマンド
です。

`C-x C-q'
`C-x v v'
     このファイルに対して論理的なつぎの版管理操作を実施する。

正確にいえば、この操作を行うコマンドは`vc-next-action'であって、
`C-x v v'にバインドしてあります。
しかし、`C-x C-q'の通常の意味は、
読み出し専用バッファを書き込み可能にするか、あるいは、その逆を行います。
この操作を、適切な版管理操作を実施することで
版管理下で管理されているファイルに対しても同じことを
正しく行うように拡張したのです。
登録されたファイルに対して`C-x C-q'を打つと、
`C-x v v'のように動作します。

このコマンドの正確な動作は、ファイルの状態と版管理システム（バックエン
ド）がロックを使うかどうかに依存します。SCCSとRCSは通常はロックを使いま
すが、CVSは通常はロックを使いません。

* Menu:

* VC with Locking::     RCS in its default mode, SCCS, and optionally CVS.
* Without Locking::     Without locking: default mode for CVS.
* Log Buffer::          Features available in log entry buffers.



File: emacs-ja, Node: VC with Locking, Next: Without Locking, Prev: Basic VC Editing, Up: Basic VC Editing

ロック使用時の基本的な編集
..........................

（SCCSの場合とRCSのデフォルトの場合）ファイルに対してロックを使う場合、
`C-x C-q'は、ファイルをロックする、あるいは、ファイルをチェックインする
のいずれかを行います。

   * ファイルがロックされていなければ、`C-x C-q'はそれをロックし、変更
     できるように書き込み可能にする。

   * 同じユーザーがファイルをロックしていて、かつ、変更されていれば、
     `C-x C-q'はチェックインを行う。
     このとき、新版に対する記録項目をまず読み取る。
     *Note Log Buffer::。

   * 同じユーザーがファイルをロックしているが、
     ロックしてからまったく変更していないときには、
     `C-x C-q'はロックを外してファイルをふたたび読み出し専用にする。

   * 他のユーザーがファイルをロックしている場合、`C-x C-q'はそのユーザー
     から『ロックを横取りする』かどうか聞いてくる。横取りするように答え
     ると、ファイルをロックし直すが、まえにロックしていたユーザーにはロッ
     クを横取りされたことを伝える。

以上の規則は、CVSでロックを使用している場合にも適用できますが、『ロック
を横取りする』ことはありません。



File: emacs-ja, Node: Without Locking, Next: Log Buffer, Prev: VC with Locking, Up: Basic VC Editing

ロック非使用時の基本的な編集
............................

CVSのデフォルトのように、ロックを使わないときには、作業ファイルはいつで
も書き込み可能です。ファイルを編集するまえにすべきことは何もありません。
モード行の状態表示は、ファイルが変更されていなければ`-'です。作業ファイ
ルに変更を保存するとただちに`:'に変わります。

以下は、CVSを使っているときの`C-x C-q'の動作です。

   * 他のユーザーが変更分をマスタファイルにチェックインしていると、それ
     らを自分用の作業ファイルに併合（*Note Merging::）するかどうか聞い
     てくる。自分の変更分をチェックインするまえには、これを行う必要があ
     る。

   * マスタファイルに新たな変更がなくても、
     自分用の作業ファイルを変更してある場合には、
     `C-x C-q'はその変更をチェックインする。
     これを行うために、新版に対する記録項目をまず読み取る。
     *Note Log Buffer::。

   * ファイルが変更されていなければ、`C-x C-q'は何もしない。

以上の規則は、RCSのロックを使わないモードにも適用できますが、マスタファ
イルから自動的に変更を併合する機能は実装してありません。残念なことに、
あなたが編集を始めたあとに、他のユーザーが同じファイルに変更をチェック
インしても何も警告されないのです。しかも、このような事態が発生すると、
あなたが自分の版をチェックインしたときに、そのユーザーの変更は実質的に
は取り除かれてしまいます（とはいえ、マスタファイルの中には残っているの
で、完全になくなるわけではない）。したがって、自分の変更をチェックイン
するまえには、現在の版が変更されていないことを確認する必要があります。
Emacsの将来の版では、このような危険性を取り除き、RCSでも自動併合を行え
るように考えています。

また、このモードでもRCSのロックを使えますが、必須ではありません。ファイ
ルを変更していないときに`C-x C-q'を使うと、RCSの通常の（ロックを使う）
モードのように、ファイルをロックします。



File: emacs-ja, Node: Log Buffer, Prev: Without Locking, Up: Basic VC Editing

記録項目用バッファの機能
........................

変更をチェックインすると、`C-x C-q'は記録項目をまず読みます。記録項目を
入力するように、`*VC-Log*'というバッファを立ち上げます。入力し終えたら、
`*VC-Log*'で`C-c C-c'と打ちます。実際にチェックインを行うと、このように
行われます。

チェックインをアボートするには、そのバッファでは`C-c C-c'を打た*ない*で
ください。別のバッファに切り替えて、別の編集をします。別のファイルを
チェックインしようとしない限り、入力していた記録項目は`*VC-Log*'バッファ
に残っていますから、チェックインを完了するため、いつでもそのバッファに
戻れます。

複数のソースファイルを同じ理由で変更したときには、多くのファイルに同じ
記録項目を指定できると便利です。こうするには、まえの記録項目の履歴を使
います。コマンド、`M-n'、`M-p'、`M-s'、`M-r'は、ミニバッファの履歴コマ
ンドのように働きます（ただし、これらのコマンドはミニバッファの外部で使
う）。

ファイルにチェックインするたびに、
記録項目用バッファはVC記録（vc-log）モードになります。
このモードは2つのフック、`text-mode-hook'と`vc-log-mode-hook'を
起動します。
*Note Hooks::。



File: emacs-ja, Node: Old Versions, Next: Secondary VC Commands, Prev: Basic VC Editing, Up: File Aliases

旧版の調査と比較
----------------

版管理の便利な機能の1つは、ファイルの任意の版を調べたり、2つの版を比較
できることです。

`C-x v ~ VERSION RET'
     訪問しているファイルの版VERSIONをそれ専用のバッファで調べる。

`C-x v ='
     カレントバッファの内容とファイルのチェックインした最新版とを比較す
     る。

`C-u C-x v = FILE RET OLDVERS RET NEWVERS RET'
     FILEの指定した2つの版を比較する。

`C-x v g'
     表示色を変えてCVSの注記コマンドの結果を表示する。

1つの旧版を調べるには、ファイルを訪問して`C-x v ~ VERSION RET'
（`vc-version-other-window'）と打ちます。
これにより、ファイルの版VERSIONのテキストを
`FILENAME.~VERSION~'という名前のファイルに収め、
別のウィンドウのそれ専用のバッファでそのファイルを訪問します。
（RCSでは、旧版を選択して、それから枝分かれを作成できる。
*Note Branches::。）

しかし通常は、コマンド`C-x v ='（`vc-diff'）でファイルの2つの版を比較し
たほうが、もっと便利です。引数を指定しない`C-x v ='では、カレントファイ
ルの内容（必要があればファイルに保存する）とファイルのチェックインして
ある最新版とを比較します。数引数を指定した`C-u C-x v ='では、ファイル名
と2つの版番号を読み取ってから、指定したファイルの2つの版を比較します。

登録したファイルのかわりにディレクトリ名を指定すると、このコマンドは、
そのディレクトリとその下にあるサブディレクトリに置かれているすべての登
録されたファイルの指定した2つの版を比較します。

チェックインしてある版は、その番号で指定します。入力が空だと、（チェッ
クインしてある版とは異なるかもしれない）作業ファイルの現在の内容を指定
します。版番号のかわりに、スナップショット名（*Note Snapshots::）を指定
することもできます。

このコマンドは、変数`diff-switches'で指定されるオプションを用いて、
`diff'プログラムを実行して動作します。
その出力は別のウィンドウの特別なバッファに表示されます。
`M-x diff'コマンドと違って、`C-x v ='では新版と旧版の
相違箇所には移動できません。
というのは、通常、一方の版、あるいは、両方の版は、
比較するときにはファイルとしては存在していないからです。
それらは、マスタファイルの記録の中に存在するだけです。
`M-x diff'についてより詳しくは、*Note Comparing Files::。

CVSで管理しているファイルに関しては、一目でわかるように複数の表示色を使っ
て、CVS注記コマンドの結果を表示できます。これには、`M-x vc-annotate'を
使います。赤は新版、青は旧版、それらの中間色は中間の版を表します。数引
数Nは、時間尺度を伸ばします。つまり、ある表示色で表す期間をN倍します。



File: emacs-ja, Node: Secondary VC Commands, Next: Miscellaneous VC, Prev: Old Versions, Up: File Aliases

VCの副次的なコマンド
--------------------

本節では、VCの副次的なコマンドを説明します。1日に一度くらい使うようなコ
マンドです。

* Menu:

* Registering::         Putting a file under version control.
* VC Status::           Viewing the VC status of files.
* VC Undo::             Cancelling changes before or after check-in.
* VC Dired Mode::       Listing files managed by version control.
* VC Dired Commands::   Commands to use in a VC Dired buffer.



File: emacs-ja, Node: Registering, Next: VC Status, Prev: Secondary VC Commands, Up: Secondary VC Commands

VCへのファイル登録
..................

ファイルを訪問してから`C-x v i'（`vc-register'）と打つだけで、
ファイルを版管理の管理下に置けます。

`C-x v i'
     訪問したファイルを版管理に登録する。

ファイルを登録するには、Emacsはそのファイルに対してどの版管理システムを
使うか選ぶ必要があります。`vc-default-back-end'に、`RCS'、`CVS'、
`SCCS'のいずれかを設定すれば、明示的に指定できます。あるいは、`RCS'、
`SCCS'、`CVS'という名前のサブディレクトリがあるなら、Emacsは対応する版
管理システムを使います。指定がまったくなければ、デフォルトでは、RCSがイ
ンストールされていればRCS、さもなければSCCSを選びます。

ロックを使用している場合には、`C-x v i'は、
ファイルのロックを解除し読み出し専用にします。
ファイルの編集を始めたい場合には、`C-x C-q'と打ちます。
CVSにファイルを登録したあとでは、
`C-x C-q'と打って最初の版を記録する必要があります。

新しく登録されたファイルの最初の版番号は、デフォルトでは1.1です。異なる
デフォルトを指定するには、変数`vc-default-init-version'に設定します。あ
るいは、`C-x v i'に数引数を指定すると、そのファイルだけに使う最初の版番
号をミニバッファで読みます。

`vc-initial-comment'が`nil'以外ならば、`C-x v i'はこのソースファイルの
目的を記した初期コメントを読みます。これは記録項目（*Note Log Buffer::）
を読むのと同じように動作します。



File: emacs-ja, Node: VC Status, Next: VC Undo, Prev: Registering, Up: Secondary VC Commands

VC状態表示コマンド
..................

`C-x v l'
     版管理の状態と変更履歴を表示する。

ファイルの詳しい版管理状態や履歴を見るには、`C-x v l'（`vc-print-log'）
と打ちます。記録項目を含めてカレントファイルの変更履歴を表示します。出
力は別のウィンドウに表示されます。



File: emacs-ja, Node: VC Undo, Next: VC Dired Mode, Prev: VC Status, Up: Secondary VC Commands

版管理操作のアンドゥ
....................

`C-x v u'
     バッファとファイルを最新のチェックインしてある版に復元する。

`C-x v c'
     訪問先ファイルのマスタファイルに最後に入れた変更を取り除く。つまり、
     最後のチェックインをアンドゥする。

これまでの一連の変更を破棄してチェックインしてある最新版へ復元したいときは、
`C-x v u'（`vc-revert-buffer'）を使います。
ロックを使用しているときには、ファイルのロックを解除するので、
変更を始めるまえにまずファイルをロックし直す必要があります。
チェックインした最新版から変更していないと判断できない限り、
`C-x v u'は確認を求めてきます。

`C-x v u'は、ファイルをロックしたけれどもやはりファイルを変更しないと決
めたときに、ロックを解除するコマンドでもあります。

すでにチェックインしてしまった変更を取り消すには、`C-x v
c'（`vc-cancel-version'）を使います。このコマンドは、チェックインした最
新版のすべての記録を捨てさります。さらに、`C-x v c'は、作業ファイルとバッ
ファを以前の版（捨てた最新版の1つまえの版）に復元するかどうか聞いてきま
す。

`no'と答えると、VCはバッファでの変更を保持してファイルもロックしたまま
にします。チェックインした変更に明らかなまちがいがあるとわかったときに、
この「復元しない」という選択肢は便利です。誤りを含んだチェックインを取
り消し、誤りを訂正してから、改めてファイルをチェックインできます。

`C-x v c'がバッファを復元しないときには、そのかわりに、バッファ内のすべ
ての版管理ヘッダの展開形をもとの形に戻します（*Note Version Headers::）。
なぜなら、バッファはもはや既存のどの版にも対応しないからです。ふたたび
チェックインすると、チェックインの過程で、新たな版番号として正しくヘッ
ダを展開します。

しかしながら、RCSの`$Log$'ヘッダを
自動的にもとの形に戻すことは不可能です。
このヘッダの機能を使うなら、取り消した版に対応する項目を削除することで、
もとの形に手で戻す必要があります。

多くの作業結果を簡単に失ってしまうので、
`C-x v c'を起動するときには十分注意してください。



File: emacs-ja, Node: VC Dired Mode, Next: VC Dired Commands, Prev: VC Undo, Up: Secondary VC Commands

VC下のdired
...........

大きなプログラムを扱っているときは、ディレクトリの木構造全体の中でどの
ファイルが変更されたのかを調べたり、版管理の下に置かれているすべてのファ
イルの状態を一度に見られると便利です。コマンド`C-x v
d'（`vc-directory'）を使えば、版管理に関連したファイルだけを含んだディ
レクトリ一覧を作れます。

`C-x v d'は、VC diredモードを使うバッファを作ります。これは、普通の
diredバッファ（*Note Dired::）にそっくりですが、（ロックされていたり、
未更新の）注意を払うべきファイルだけを通常は表示します。これを"簡素な表
示"と呼びます。変数`vc-dired-terse-display'に`nil'を設定すると、VC
diredは、関連するすべてのファイル、つまり、版管理の下に置かれたファイル
とすべてのサブディレクトリを表示します（"完全な表示"）。VC diredバッファ
のコマンド`v t'は、簡素な表示と完全な表示を切り替えます。（*Note VC
Dired Commands::。）

デフォルトでは、VC diredは、指定したディレクトリやそれより下に置かれた
注意を払うべきファイルや関連するファイルの再帰的な一覧を作ります。この
動作を変えるには、変数`vc-dired-recurse'に`nil'を設定します。すると、
VC diredは、指定したディレクトリにあるファイルだけを表示します。

各ファイルを表す行には、ハードリンク数、所有者、グループ、ファイルサイ
ズのかわりに版管理状態があります。ファイルが変更されていなければ、つま
り、マスタファイルの内容に同期しているならば、版管理状態は空です。そう
でなければ、括弧で括ったテキストになります。RCSとSCCSでは、ファイルをロッ
クしているユーザーの名前が示されます。CVSでは、cvs状態（`cvs status'）
を簡略化したものが示されます。つぎは、RCSを使っている場合の例です。

       /home/jim/project:

       -rw-r--r-- (jim)      Apr  2 23:39 file1
       -r--r--r--            Apr  5 20:21 file2

ファイル、`file1'と`file2'が、版管理の下に置かれていて、
`file1'はユーザーjimがロックしていて、
`file2'はロックされていません。

つぎは、CVSを使っている場合の例です。

       /home/joe/develop:

       -rw-r--r-- (modified) Aug  2  1997 file1.c
       -rw-r--r--            Apr  4 20:09 file2.c
       -rw-r--r-- (merge)    Sep 13  1996 file3.c

保管庫のものに比べて、`file1.c'は変更されていますが、`file2.c'は変更さ
れていません。`file3.c'も変更されていますが、保管庫には他の変更がチェッ
クインされています。`file3.c'をチェックインするまえに、それらの変更を併
合する必要があります。

VC diredで（『完全な表示』のときに）サブディレクトリを表示するときには、
版管理の下には絶対に置かれないものは省略します。デフォルトでは、`RCS'や
`CVS'などのVCのサブディレクトリが含まれます。これは、変数
`vc-directory-exclusion-list'を設定してカスタマイズできます。

普通のdiredのように、`C-u C-x v d'と打てば、`ls'プログラムに渡す追加オ
プションを指定して、VC diredの出力書式を微調整できます。



File: emacs-ja, Node: VC Dired Commands, Next: Switching Branches, Prev: VC Dired Mode, Up: Secondary VC Commands

VC diredコマンド
................

VC diredモードでも、通常のdiredコマンドはすべて普通に動作しますが、`v'
は例外で、版管理プレフィックスとして再定義してあります。`vc-diff'や
`vc-print-log'のようなVCコマンドは、`v ='や`v l'いうように打てば起動で
きます。これらのコマンドの多くは、現在行のファイルに作用します。

コマンド`v v'（`vc-next-action'）は、印を付けたすべてのファイルに作用す
るので、複数のファイルを一度にロックしたりチェックインしたりできます。
複数のファイルに作用する場合、各ファイルの現状に応じて個別に扱います。
つまり、あるファイルはロックしたり、別のファイルはチェックインしたりし
ます。これは混乱の原因かもしれません。同じ状態の一連のファイルに印を付
けて、混乱を防止するのはユーザーの責任です。

ファイルをチェックインするときには、`v v'は1つの記録項目を読んで、それ
をチェックインするすべてのファイルに使います。これは、同じ変更に属する
一連のファイルを一度にチェックインする場合に便利です。

`v t'（`vc-dired-toggle-terse-mode'）と打てばいつでも、（ロックされてい
たり、内容が未更新のものだけを表示する）簡素な表示と完全な表示とを切り
替えられます。特別なコマンド`* l'（`vc-dired-mark-locked'）もあります。
これは現在ロックされている（CVSの場合には、内容が未更新である）すべての
ファイルに印を付けます。つまり、現在ロックされいるもの以外のすべてのファ
イルをバッファから削除する別の方法は、`* l t k'と打つことです。



File: emacs-ja, Node: Branches, Next: Miscellaneous VC, Prev: Secondary VC Commands, Up: File Aliases

ファイルの複数の枝分かれ
------------------------

版管理の用途の1つは、ファイルの複数の『現在』版を維持することです。たと
えば、さまざまな完了していない新しい機能を徐々に付け加えているプログラ
ムの異なる版を持つかもしれません。そういった開発の独立した流れを"枝
（branch）と呼びます。VCでは、枝を作ったり、別の枝へ切り替えたり、2つの
枝を併合したりできます。しかし、今のところ、RCSだけで枝を使えることに注
意してください。

ファイルの開発の主要な流れを"幹"（trunk）と呼びます。幹にある版は、普通、
1.1、1.2、1.3、…と番号が付けられます。そのような版のどれからでも、独立
した枝を始めることができます。版1.2から始まる枝の版番号は1.2.1.1となり、
同じ枝の後続の版番号は1.2.1.2、1.2.1.3、1.2.1.4、…となります。版1.2か
ら始まる別の枝があれば、それらの版番号は、1.2.2.1、1.2.2.2、1.2.2.3、…
となります。

版番号の最後の要素を省略したものを"枝番号"と呼びます。これは、その枝に
ある版の中でもっとも大きい番号の版、"先頭版"を指します。まえの例の枝は、
枝番号1.2.1と1.2.2です。

* Menu:

* Switching Branches::    How to get to another existing branch.
* Creating Branches::     How to start a new branch.
* Merging::               Transferring changes between branches.
* Multi-User Branching::  Multiple users working at multiple branches
                            in parallel.



File: emacs-ja, Node: Switching Branches, Next: Creating Branches, Prev: VC Dired Commands, Up: Secondary VC Commands

枝の切り替え
............

枝を切り替えるには、`C-u C-x C-q'と打ってから、選択したい版番号を指定し
ます。その版を*ロックしない*（書き込み不可）で訪問するので、ロックする
まえに調べることができます。このような枝の切り替えが可能なのは、ファイ
ルがロックされていない場合に限ります。

枝の中での版番号を省略して枝番号だけを指定できます。
すると、その枝の先頭版を選ぶことになります。
RETだけを打つと、Emacsは幹の上のもっとも大きい版を選びます。

（幹を含む）どれかの枝へ切り替えたあとでは、明示的に他の枝を選択するま
で、それ以降のVCコマンドはその枝を使います。



File: emacs-ja, Node: Creating Branches, Next: Merging, Prev: Switching Branches, Up: Secondary VC Commands

新しい枝の作成
..............

先頭版（枝の中にある最新版）から新たな枝を作るには、必要ならまずその版
を選択してから、`C-x C-q'でそれをロックし、必要な変更を施します。そして、
変更をチェックインするときに、`C-u C-x C-q'を使います。このコマンドでは、
新版に対する版番号を指定できます。現在の版から始まる枝として適切な番号
を指定する必要があります。たとえば、現在の版が2.5ならば、その時点で存在
する枝の数に依存しますが、枝番号は、2.5.1、2.5.2、…です。

旧版（先頭版ではないもの）から新しい枝を作るには、その版をまず選択して
から（*Note Switching Branches::）、それを`C-x C-q'でロックします。旧版
をロックすると、本当に新しい枝を作るのかどうか確認してきます。noで答え
ると、かわりに、最新版をロックするかどうか聞いてきます。

変更してから、ふたたび`C-x C-q'と打って新版にチェックインします。こうす
ると選択した版から始まる新しい枝を自動的に作ります。新しい枝を特に指定
する必要はありません。なぜなら、枝の先頭版でないところに新版を付け加え
る唯一の方法だからです。

枝を作ったあとでは、その枝に『留まり』ます。つまり、それ以降にチェック
インすると、その枝に新版が作られます。枝を去るには、`C-u C-x C-q'で明示
的に別の版を選ぶ必要があります。ある枝から別の枝へ変更を移すには、次節
で説明する併合コマンドを使ってください。



File: emacs-ja, Node: Merging, Next: Multi-User Branching, Prev: Creating Branches, Up: Secondary VC Commands

枝の併合
........

ある枝で変更を完了したときには、それらの変更をファイルの開発の主流（幹）
に取り込みたいことがしばしばあるでしょう。これは簡単な操作ではありませ
ん。というのは、幹でも開発は進行しているので、別の向きに変更されている
ファイルに変更を"併合"する必要があるからです。VCでは、`vc-merge'コマン
ドで併合（とそれ以外のことも）できます。

`C-x v m (vc-merge)'
     作業ファイルに変更を併合する。

`C-x v m'（`vc-merge'）は、一連の変更を作業ファイルの現在の版に併合しま
す。このコマンドはまず、ミニバッファで枝番号か2つの版番号を読み取ります。
そして、その枝での変更、あるいは、指定した2つの版のあいだの変更を調べ、
それらをファイルの現在の版に併合します。

例として、枝1.3.1である機能を実装し終えたとしましょう。この間、幹でも開
発が進んでいて版1.5になっています。枝での変更を幹に併合するには、まず、
`C-u C-x C-q RET'と打って、幹の先頭版へ行きます。版1.5が現在の版になり
ます。ファイルのロックを使っている場合には、`C-x C-q'と打って、版1.5を
ロックして変更できるようにします。続いて`C-x v m 1.3.1 RET'と打ちます。
すると、枝1.3.1での（枝の開始点である版1.3から枝の中にある最新版までの）
一連の変更を取り出して、それらを作業ファイルの現在の版に併合します。こ
こで、変更された作業ファイルをチェックインできます。つまり、枝での変更
を取り込んだ版1.6を作れるのです。

チェックインするまえに、枝から併合したあとにさらに編集することも可能で
す。しかし、併合した版をチェックインしたあとで、ロックしてさらに編集す
るのが、普通は賢いやり方です。こうすれば、変更履歴をよりよく記録に残せ
ます。

すでに修正されているファイルに変更を併合するときには、変更が重複する場
合があります。この状況を"矛盾"と呼びます。矛盾した変更の辻褄を合わせる
ことを"矛盾の解消"と呼びます。

併合中に矛盾が起こると、VCはこれらを検出し、それらをエコー領域に表示し
てユーザーに伝え、併合を補佐してほしいかどうか聞いてきます。yesで答える
と、ediffセッションを開始します（*Note Ediff: (ediff)Top.）。

noで答えると、矛盾する変更はどちらも"矛盾印"で囲ってファイルに挿入しま
す。矛盾する部分は、下の例のようになります。作業ファイルの名前は`name'
であり、ユーザーBの変更を収めたマスタファイルの版は1.11です。

     <<<<<<< name
       USER A'S VERSION
     =======
       USER B'S VERSION
     >>>>>>> 1.11

この矛盾を解消するようにファイルを手で編集できます。あるいは、ファイル
を訪問してから`M-x vc-resolve-conflicts'と打ちます。すると上に述べた
ediffセッションを開始します。



File: emacs-ja, Node: Multi-User Branching, Next: Making Snapshots, Prev: Merging, Up: Secondary VC Commands

複数ユーザーの枝
................

ファイルの異なる枝上で同時に複数の開発者が作業すると有益なことがしばし
ばあります。CVSでは、デフォルトで、これができます。RCSでは、複数のソー
スディレクトリを作れば可能です。RCSのマスタファイルを置いた共通のディレ
クトリを指す`RCS'という名前のリンクを各ソースディレクトリに置きます。こ
うすれば、各ソースディレクトリでは、それぞれ独自に版を選択できます。し
かし、同じ共通のRCSレコードをすべてで共有します。

ソースファイルにRCSの版管理ヘッダ（*Note Version Headers::）が入ってい
れば、この技法は信頼性があり自動的に動作します。ヘッダにより、Emacsはい
つでも作業ファイルに入っている版番号がわかります。

ファイルに版管理ヘッダが入っていないときには、各セッションごとにどの枝
で作業しているかをEmacsに明示する必要があります。こうするには、ファイル
を訪問してから、`C-u C-x C-q'と打ち、正しい枝番号を指定します。これによ
り、編集セッションではどの枝を操作しているかをEmacsが知っていることを保
証します。



File: emacs-ja, Node: Snapshots, Next: Miscellaneous VC, Prev: Secondary VC Commands, Up: File Aliases

スナップショット
----------------

"スナップショット"とは、ファイルの版（登録されたファイルそれぞれに1つず
つ）の集合に名前を付けたもので、一塊として扱うことができます。スナップ
ショットの重要な種類の1つは、"リリース"です。これは、ユーザーへ配布する
準備が整ったシステムの（理論的には）安定した版のことです。

* Menu:

* Making Snapshots::		The snapshot facilities.
* Snapshot Caveats::		Things to be careful of when using snapshots.



File: emacs-ja, Node: Making Snapshots, Next: Snapshot Caveats, Prev: Multi-User Branching, Up: Secondary VC Commands

スナップショットの作成と使用
............................

スナップショットに対しては、基本的なコマンドが2つあります。1つは名前を
指定してスナップショットを作り、もう1つは指名したスナップショットを取り
出すことです。

`C-x v s NAME RET'
     カレントディレクトリやその下に置いてある登録されたファイルのそれぞ
     れの保存された最新版をNAMEという名前のスナップショットとして定義す
     る（`vc-create-snapshot'）。

`C-x v r NAME RET'
     カレントディレクトリやその下に置いてある登録されたファイルすべてに
     ついて、スナップショットNAMEに対応する版を選択する。

     カレントディレクトリやその下に置いてある登録されたファイルのいずれ
     かがロックされていると、このコマンドは何も変更せずにエラーを報告す
     る。これは、進行中の作業結果を上書きしてしまうことを避けるため。

スナップショットはとても少量の資源しか使いません。ファイル名一覧とスナッ
プショットに属する版番号を記録するに十分な量だけでいいのです。したがっ
て、使いものになるものをスナップショットにすることを躇うことはありませ
ん。

`C-x v ='や`C-x v ~'（*Note Old Versions::）の引数として、スナップショッ
トの名前を指定できます。したがって、スナップショットと現在のファイル、
あるいは、2つのスナップショット同士、あるいは、指定した名前の版とスナッ
プショット同士を比較できます。



File: emacs-ja, Node: Snapshot Caveats, Prev: Making Snapshots, Up: Secondary VC Commands

スナップショットの弱点
......................

VCのスナップショット機能は、RCSの名前付きコンフィギュレーションサポート
（named-configuration support）をモデルにしています。RCS固有の機能を使っ
ているため、RCSを使って作ったVCのスナップショットは、VCを使わなくても見
えます。

SCCSでは、VC自身でスナップショット機能を実装しています。VCが使うファイ
ルには、名前／ファイル／版番号の3つ組みが含まれます。これらのスナップ
ショットは、VCを使ったときだけ見えます。

スナップショットはチェックインした版の集合です。ですから、スナップショッ
トを作るときには、すべてのファイルをチェックインしてあり、しかもロック
していないことを確認してください。

ファイルを改名したり削除すると、スナップショットに問題を生じます。これ
はVCに固有の問題ではなく、版管理システムに一般的な設計上の問題で、まだ
誰も満足ゆく解決をできていません。

登録されたファイルを改名するなら、そのマスタファイルも一緒に改名する必
要があります（コマンド`vc-rename-file'は自動的にこれを行う）。SCCSを使っ
ているならば、ファイル名を新しい名前にしてスナップショットの記録も更新
する必要があります（`vc-rename-file'はこれも行う）。記録された名前では
もはや存在しないマスタファイルを参照する古いスナップショットは無効です。
VCは（古い名前では）取り出せません。スナップショットを手で更新する方法
を説明するためにRCSやSCCSを詳しく説明することは、本書の範囲を越えていま
す。

`vc-rename-file'を使えば、取り出し操作に使える程度にはスナップショット
を保てますが、すべての問題を解決できるわけではありません。たとえば、プ
ログラムのいくつかのファイルでは、名前で他のファイルを参照しているでしょ
う。少なくとも、makefileでは、改名したファイルを指しているでしょう。古
いスナップショットを取り出すと、改名したファイルは新しい名前で取り出し
ますが、makefileで使っている名前ではありません。ですから、取り出しただ
けではプログラムは動かないでしょう。



File: emacs-ja, Node: Miscellaneous VC, Next: Customizing VC, Prev: Secondary VC Commands, Up: File Aliases

VCのその他のコマンドと機能
--------------------------

本節では、使用頻度の少ないVCの機能を説明します。

* Menu:

* Change Logs and VC::  Generating a change log file from log entries.
* Renaming and VC::     A command to rename both the source and master
                          file correctly.
* Version Headers::     Inserting version control headers into working files.



File: emacs-ja, Node: Change Logs and VC, Next: Renaming and VC, Prev: Miscellaneous VC, Up: Miscellaneous VC

変更記録とVC
............

プログラムに対してRCSやCVSを使い、しかも、それらに変更記録ファイル
（*Note Change Log::）を保持しているならば、版管理の記録項目から変更記
録項目を自動的に生成できます。

`C-x v a'
     カレントディレクトリにある変更記録ファイルを訪れる。そして、そのディ
     レクトリに置いてある登録された各ファイルについて、変更記録ファイル
     にある最新の項目以降にチェックインされた版に関する新たな項目を作成
     する。（`vc-update-change-log'）。

     このコマンドはRCSやCVSだけで動作し、SCCSでは動作しない。

`C-u C-x v a'
     上と同様であるが、カレントバッファのファイルに関する項目だけを探す。

`M-1 C-x v a'
     上と同様だが、現在訪問しているファイルのうち版管理の下に置かれてい
     るファイルすべてに関する項目を探す。このコマンドはRCSでのみ動作す
     る。しかも、デフォルトディレクトリに関するすべての項目を変更記録に
     追加するが、これは適切でないこともある。

たとえば、`ChangeLog'の最初の行の日付が1999年4月10日であり、それ以降の
チェックインはNathaniel Bowditchが1999年5月22日に`Ignore log messages
that start with `#'.'という記録で`rcs2log'にチェックインしたものだけだ
としましょう。そうすると、`C-x v a'は`ChangeLog'を訪問して、つぎのよう
なテキストを挿入します。

     1999-05-22  Nathaniel Bowditch  <nat@apn.org>

             * rcs2log: Ignore log messages that start with `#'.

このあと、変更記録の新しい項目を好きなように編集できます。

残念ながら、ChangeLogファイルには日付しか記録していないので、新たな変更
記録項目がChangeLogファイルの既存の項目と重複することがあります。そのよ
うな日付の重複は、手作業で削除する必要があります。

通常、ファイル`foo'に関する記録項目は、
`* foo: TEXT OF LOG ENTRY'のように表示されます。
記録項目のテキストが`(FUNCTIONNAME):'で始まると、
`foo'のうしろの`:'は省かれます。
たとえば、`vc.el'に関する記録項目が
`(vc-do-command): Check call-process status.'であれば、
`ChangeLog'の中のテキストはつぎのようになります。

     1999-05-06  Nathaniel Bowditch  <nat@apn.org>

             * vc.el (vc-do-command): Check call-process status.

`C-x v a'が複数の変更記録項目を一度に追加するときには、同じ作者がほぼ同
じ日時にチェックインしたものならば、関連する記録項目をまとめます。その
ようないくつかのファイルに対する記録項目がすべて同じテキストならば、1つ
の項目にまとめます。たとえば、最後にチェックインしたものに、以下の記録
があったとします。

* `vc.texinfo'の記録項目: `Fix expansion typos.'
* `vc.el'の記録項目: `Don't call expand-file-name.'
* `vc-hooks.el'の記録項目: `Don't call expand-file-name.'

これらは`ChangeLog'の中ではつぎのようになります。

     1999-04-01  Nathaniel Bowditch  <nat@apn.org>

             * vc.texinfo: Fix expansion typos.

             * vc.el, vc-hooks.el: Don't call expand-file-name.

通常、`C-x v a'は記録項目を空行で区切りますが、
関連する記録項目のテキストを`{CLUMPNAME} 'のような
ラベルで始めれば、関連する複数の記録項目を1つの塊にする
（区切りの空行を入れない）ように印を付けられます。
ラベル自体は`ChangeLog'にはコピーされません。
たとえば、記録項目がつぎのようであるとします。

* `vc.texinfo'の記録項目: `{expand} Fix expansion typos.'
* `vc.el'の記録項目: `{expand} Don't call expand-file-name.'
* `vc-hooks.el'の記録項目: `{expand} Don't call expand-file-name.'

すると、`ChangeLog'のテキストはつぎのようになります。

     1999-04-01  Nathaniel Bowditch  <nat@apn.org>

             * vc.texinfo: Fix expansion typos.
             * vc.el, vc-hooks.el: Don't call expand-file-name.

記録項目のテキストが`#'で始まると、その記録項目は`ChangeLog'にはコピー
されません。たとえば、コメントの綴りまちがいだけを変更したときには、記
録項目を`#'で始めれば、このような自明なものを`ChangeLog'に入れないです
みます。



File: emacs-ja, Node: Renaming and VC, Next: Version Headers, Prev: Change Logs and VC, Up: Miscellaneous VC

VC作業ファイルとマスタファイルの改名
....................................

登録したファイルを改名するときには、そのマスタファイルも同様に改名して
正しい結果を得られるようにする必要があります。指定どおりにソースファイ
ルを改名し、それに従ってマスタファイルも改名するには、`vc-rename-file'
を使います。このコマンドは、当該ファイルを指名しているどんなスナップ
ショット（*Note Snapshots::）も更新するので、スナップショットでも新しい
名前を使うようになります。それにも関わらず、修正したスナップショットは
動作しないかもしれません（*Note Snapshot Caveats::）。

誰かがロックしているファイルに対しては、
`vc-rename-file'を使えません。



File: emacs-ja, Node: Version Headers, Prev: Renaming and VC, Up: Miscellaneous VC

版管理ヘッダの挿入
..................

版を識別する文字列を作業ファイルへ直接入れておくと便利なこともあります。
版管理ヘッダ"と呼ばれる特別な文字列は、各版ごとにその版番号で置き換えら
れます。

RCSを使っていて、かつ、作業ファイルに版管理ヘッダが入っていれば、Emacs
は、版管理ヘッダを使って現在の版とファイルのロック状態を決定できます。
これは、版管理ヘッダがないときにマスタファイルを参照するより、信頼でき
ます。複数の枝を使う環境では、VCが正しくふるまうためには版管理ヘッダが
必要です（*Note Multi-User Branching::）。

版管理ヘッダの探索は、変数`vc-consult-headers'で制御されます。
`nil'以外ならば、編集中の版番号を決定するためにEmacsはヘッダを探します。
`nil'を設定すると、この機能はオフになります。

適切なヘッダ文字列を入れるには、コマンド`C-x v h'
（`vc-insert-headers'）を使います。

`C-x v h'
     版管理システムで使うヘッダをファイルに挿入する。

デフォルトのヘッダ文字列は、
RCSでは`$Id$'、SCCSでは`%W%'です。
変数`vc-header-alist'に設定すれば、他のヘッダを指定できます。
この値は、`(PROGRAM . STRING)'の形式の
要素から成るリストです。
ここで、PROGRAMは`RCS'または`SCCS'であり、
STRINGは使用する文字列です。

1つの文字列のかわりに、文字列のリストを指定することもできます。そうする
と、リストの各文字列は、別々の行に別のヘッダとして挿入されます。

この変数に入れる文字列を書くときには、『余分な』バックスラッシュを使う
必要がよくあります。この文字列を含むEmacs Lispファイルが版管理の下に置
かれているときに、定数中の文字列がヘッダと解釈されることを防ぐためです。

各ヘッダは、ポイント位置の新しい行に、
コメント区切りの内側にタブで囲んで挿入されます。
通常、現在のモードのコメント開始文字列とコメント終了文字列を使いますが、
特定のモードでは、この目的のための特別なコメント区切りがあります。
変数`vc-comment-alist'がそれらを指定します。
このリストの各要素は
`(MODE STARTER ENDER)'という形式です。

変数`vc-static-header-alist'は、
バッファ名に基づいた追加の文字列を指定します。
この値は、`(REGEXP . FORMAT)'の形式の
要素から成るリストでなくてはいけません。
REGEXPがバッファ名に一致するたびに、
FORMATをヘッダの一部として挿入します。
バッファ名に一致する各要素と`vc-header-alist'に指定された各文字列ごとに
ヘッダ行を挿入します。
`vc-header-alist'の文字列を要素の書式FORMATで処理して
ヘッダ行を作ります。
`vc-static-header-alist'のデフォルト値はつぎのとおりです。

     (("\\.c$" .
       "\n#ifndef lint\nstatic char vcid[] = \"\%s\";\n\
     #endif /* lint */\n"))

これは、つぎのようなテキストを挿入します。


     #ifndef lint
     static char vcid[] = "STRING";
     #endif /* lint */

上のテキストは空行で始まっていることに注意してください。

複数の版管理ヘッダをファイルに入れる場合には、ファイル内ではそれらを一
緒にまとめて入れておきます。`revert-buffer'のマーカを保存する機構は、2
つの版管理ヘッダのあいだに置かれたマーカを扱えないこともあります。



File: emacs-ja, Node: Customizing VC, Prev: Miscellaneous VC, Up: File Aliases

VCのカスタマイズ
----------------

VCをカスタマイズする方法はたくさんあります。設定可能なオプションは、次
節に述べる4つに分類できます。

* Menu:

* Backend Options::       Customizing the back-end to your needs.
* VC Workfile Handling::  Various options concerning working files.
* VC Status Retrieval::   How VC finds the version control status of a file,
                            and how to customize this.
* VC Command Execution::  Which commands VC should run, and how.



File: emacs-ja, Node: Backend Options, Next: VC Workfile Handling, Prev: Customizing VC, Up: Customizing VC

VCのバックエンドに対するオプション
..................................

RCSとCVSには、ファイルのロックを使うかどうかを指定できます（ロックに関
しては*Note VC Concepts::）。VCはどちらを選んだかを識別し、そのようにふ
るまいます。

RCSでは、デフォルトはロックを使います。しかし、ファイルをロックしていな
くても変更をチェックインできる、"弱いロック"と呼ばれるモードがあります。
特定のファイルに対して弱いロックを使うように切り替えるには、`rcs -U'を
使います。詳しくは、`rcs'のマニュアルページを参照してください。

CVSでは、デフォルトはロックを使いません。いつでも誰もが作業ファイルを変
更できます。しかし、これを制限する方法があり、ロックに似たふるまいをし
ます。

1つの方法は、環境変数`CVSREAD'に何か値を設定することです。この変数が定
義されていると、CVSはデフォルトでは作業ファイルを読み出し専用にします。
Emacs内では、`C-x C-q'と打ってファイルを書き込み可能にする必要がありま
す。そうすると、事実上ロックを使っているかのように編集できます。しかし
ながら、実際にロックされているわけではないので、複数のユーザーが各自の
ファイルを同時に書き込み可能にできてしまいます。`CVSREAD'を初めて設定す
るときには、ファイルの保護が正しく設定されるように、あなたのモジュール
すべてを新たにチェックアウトしたことを確認してください。

ロックに似たふるまいを達成する別の方法は、CVSの"監視"機能を使うことです。
ファイルを監視するようにしておくと、CVSはデフォルトでそのファイルを読み
出し専用にします。そのため、Emacs内では`C-x C-q'を使って書き込み可能に
する必要があります。VCは、`cvs edit'を実行してファイルを書き込み可能に
します。すると、CVSは、あなたがファイルを変更しようとしていることを他の
開発者に通知します。監視機能の詳しい使い方については、CVSの解説を参照し
てください。

変数`vc-handle-cvs'に`nil'を設定すれば、CVSの管理下に置いたファイルに対
してVCを使わないようにできます。こうすると、Emacsは、これらのファイルを
あたかも登録されていないかのように扱い、それらに対してVCコマンドは使え
ません。すべてのCVS操作を手動で行う必要があります。



File: emacs-ja, Node: VC Workfile Handling, Next: VC Status Retrieval, Prev: Backend Options, Up: Customizing VC

VC作業ファイルの扱い方
......................

Emacsは、版管理の下に置かれたソースファイルに対しては、通常バックアップ
ファイルを作りません。版管理を使っているファイルに対してもバックアップ
ファイルを作りたいなら、変数`vc-make-backup-files'に`nil'以外の値を設定
します。

ロックの状態に関わらず、普通、作業ファイルはつねに存在します。
`vc-keep-workfiles'に`nil'を設定すると、`C-x C-q'で新版をチェックインす
ると、作業ファイルを削除します。しかし、Emacsでファイルを訪問しようとす
ると、作業ファイルをふたたび作ります。（CVSでは、作業ファイルはつねに存
在する。）

版管理されているファイルをシンボリックリンクを介して編集することは、危
険なことになりえます。版管理システムを迂回してしまいます。つまり、ロッ
クせずにファイルを編集できてしまい、変更のチェックインには失敗します。
また、他のユーザーがあなたの変更を上書きしてしまうかもしれません。こう
いったことを防ぐために、VCは、訪問する各シンボリックリンクを検査して、
それが版管理の下に置かれたファイルを指しているかどうか調べます。

変数`vc-follow-symlinks'は、シンボリックリンクが版管理されているファイ
ルを指しているときにどうするかを制御します。その値が`nil'ならば、VCは警
告メッセージを表示するだけです。`t'ならば、VCは自動的にリンクを辿って、
かわりに本当のファイルを訪問し、エコー領域にこのことを表示します。値が
`ask'（デフォルト）ならば、VCはリンクを辿るかどうかを毎回聞いてきます。



File: emacs-ja, Node: VC Status Retrieval, Next: VC Command Execution, Prev: VC Workfile Handling, Up: Customizing VC

VC状態検索
..........

ファイルのロック状態を推測するとき、VCはまずファイルのRCSの版管理ヘッダ
文字列を探します（*Note Version Headers::）。ヘッダ文字列がなかったり、
SCCSを使っているときは、VCは通常、作業ファイルのパーミッションを調べま
す。ここまでは、すぐにできます。しかし、ファイルのパーミッションを信頼
できない場合もあります。この場合、やや手間がかかりますが、マスタファイ
ルを調べる必要があります。さらに、マスタファイルは、ファイルがロックさ
れているかどうかは教えてくれますが、作業ファイルがロックされた版を本当
に含んでいるかどうかは教えてくれません。

ロック状態を調べるために版管理ヘッダを使わないようにVCに指示するには、
変数`vc-consult-headers'に`nil'を設定します。すると、VCは（信頼できるな
ら）ファイルパーミッションを使うか、マスタファイルを調べます。

変数`vc-mistrust-permissions'を設定することで、ファイルパーミッションを
信頼するかどうかの基準を指定できます。その値は、`t'（つねにファイルパー
ミッションを疑い、マスタファイルを調べる）、`nil'（つねにファイルパーミッ
ションを信頼する）、あるいは、可否を決定する1引数の関数です。その引数は、
サブディレクトリ、`RCS'、`CVS'、`SCCS'のいずれかの名前です。関数の戻り
値が`nil'以外ならば、ファイルパーミッションを疑います。作業ファイルのパー
ミッションがまちがって変更されていると思うなら、
`vc-mistrust-permissions'に`t'を設定します。すると、VCはつねにファイル
の状態を決定するためにマスタファイルを調べます。



File: emacs-ja, Node: VC Command Execution, Prev: VC Status Retrieval, Up: Customizing VC

VCコマンドの実行
................

`vc-suppress-confirm'が`nil'以外ならば、`C-x C-q'と`C-x v i'は確認せず
にカレントバッファを保存し、`C-x v u'も確認せずに作用します。（この変数
は`C-x v c'には影響しない。その操作は思い切ったものなので、つねに確認す
るべき。）

VCモードは、RCS、CVS、SCCSのシェルコマンドを実行することで、その作業の
多くを行います。`vc-command-messages'が`nil'以外ならば、VCはどのシェル
コマンドを実行しているか表示し、コマンドが終了したときに追加メッセージ
を表示します。

変数`vc-path'を設定すれば、版管理プログラムを探すための追加のディレクト
リを指定できます。これらのディレクトリは、通常の探索パスを探すまえに探
されます。しかし、通常は適切なファイルを自動的にみつけられます。



File: emacs-ja, Node: Directories, Next: Misc File Ops, Prev: File Aliases

ファイルディレクトリ
====================

ファイルシステムは、ファイル群を"ディレクトリ"にまとめます。
"ディレクトリ一覧"は、ディレクトリの中にある、
すべてのファイルの一覧表です。
Emacsには、ディレクトリを作成したり削除したりするコマンド、
短形式（ファイル名のみ）や長形式（サイズ、日付、作者を含む）の
ディレクトリ一覧を作成するコマンドがあります。
diredと呼ばれるディレクトリブラウザもあります。
*Note Dired::。

`C-x C-d DIR-OR-PATTERN RET'
     短形式でディレクトリ一覧を表示する（`list-directory'）。
`C-u C-x C-d DIR-OR-PATTERN RET'
     長形式でディレクトリ一覧を表示する。
`M-x make-directory RET DIRNAME RET'
     DIRNAMEという名前の新しいディレクトリを作る。
`M-x delete-directory RET DIRNAME RET'
     DIRNAMEという名前のディレクトリを削除する。ディレクトリは空である
     必要があり、さもないとエラー。

ディレクトリ一覧を表示するコマンドは`C-x C-d'（`list-directory'）です。
表示するディレクトリや一覧に含めるファイルを指定するワイルドカードを含
むパターンをミニバッファから読み取ります。たとえば、

     C-x C-d /u2/emacs/etc RET

とすると、ディレクトリ`/u2/emacs/etc'の中のすべてのファイルを表示します。
ファイル名のパターンを指定した例はつぎのとおりです。

     C-x C-d /u2/emacs/src/*.c RET

通常、`C-x C-d'はファイル名だけを含んだ短形式のディレクトリ一覧を表示し
ます。（値は無関係な）数引数を指定すると、（`ls -l'のように）サイズ、日
付、作者を含む長形式の一覧を作ります。

ディレクトリ一覧のテキストは、下位プロセスで`ls'を実行して取得します。
Emacsの2つの変数で、`ls'へ渡すオプションを制御します。
`list-directory-brief-switches'は、短形式一覧のときに使うオプションを与
える文字列です（デフォルトは`"-CF"'）。
`list-directory-verbose-switches'は、長形式一覧のときに使うオプションを
与える文字列です（デフォルトは`"-l"'）。



File: emacs-ja, Node: Comparing Files, Next: Misc File Ops, Prev: Directories

ファイルの比較
==============

コマンド`M-x diff'は、2つのファイルを比較し、`*Diff*'という名前のEmacs
バッファにその違いを表示します。このコマンドは、値が文字列である変数
`diff-switches'で指定されたオプションを使って`diff'プログラムを実行しま
す。

バッファ`*Diff*'のメジャーモードはコンパイル（compilation）モードです。
ですから、`C-x `'を使って、
2つのソースファイルで変更されている箇所を次々に訪れることができます。
特定の変更箇所にポイントを移動してから、
RETや`C-c C-c'を打つか、そこで`Mouse-2'をクリックすると、
そこに対応するソースの場所へ移動できます。
コンパイル（compilation）モードの他の特別なコマンドを使うこともできます。
SPCとDELでスクロール、
`M-p'と`M-n'でカーソル移動できます。
*Note Compilation::。

コマンド`M-x diff-backup'は、
指定されたファイルとその最新のバックアップとを比較します。
バックアップファイルの名前を指定すると、
`diff-backup'はそのもとのファイルとバックアップファイルとを比較します。

コマンド`M-x compare-windows'は、カレントウィンドウの中のテキストと、つ
ぎのウィンドウの中のテキストを比較します。それぞれのウィンドウのポイン
ト位置から比較を始めます。それぞれの開始位置は、各バッファのマークリン
グに積まれます。そして、各ウィンドウでそれぞれのポイントを1文字ずつ進め
ることを、両者のウィンドウで一致しないものに出会うまで行います。そして、
コマンドは終了します。Emacsのウィンドウについてより詳しくは、*Note
Windows::。

数引数を指定すると、`compare-windows'は白文字の違いを無視します。変数
`compare-ignore-case'が`nil'以外ならば、大文字小文字の違いも同様に無視
します。

2つの似たファイルの併合に便利な機能に関しては、*Note Emerge::。



File: emacs-ja, Node: Misc File Ops, Next: Compressed Files, Prev: Directories

その他のファイル操作
====================

Emacsには、ファイルをさまざまに操作するコマンドがあります。それらすべて
は1つのファイルを操作します。これらのコマンドは、ワイルドカードを含むファ
イル名を受け付けません。

`M-x view-file'では、ファイルを1画面分ずつ順番に眺めることができます。
このコマンドは、ミニバッファでファイル名を読み取ります。Emacsバッファに
ファイルを読み込んだあと、`view-file'は先頭を表示します。そうしたら、1
ウィンドウ分先へスクロールするにはSPC、逆向きにスクロールするにはDELを
打ちます。ファイル内を動き廻るための他のいろいろなコマンドもありますが、
変更するためのコマンドはありません。コマンド一覧を見るには、このモード
で`?'と打ちます。コマンド群は、Emacsの普通のカーソル移動コマンドとほと
んど同じです。ファイル閲覧を終了するには、`q'を打ちます。閲覧用のコマン
ドは、閲覧（view）モードと呼ばれる特別なメジャーモードで定義されていま
す。

関連したコマンド、`M-x view-buffer'は、
Emacsの既存のバッファを閲覧します。
*Note Misc Buffer::。

`M-x insert-file'は、指定したファイルの内容をカレントバッファのポイント
位置に挿入します。ポイントの位置はそのままですが、挿入された部分の直後
にマークを設定します。

`M-x write-region'は、`M-x insert-file'の逆です。
指定したファイルにリージョンの内容をコピーします。
`M-x  append-to-file'は、
指定したファイルの末尾にリージョンのテキストを付け加えます。
*Note Accumulating Text::。

`M-x delete-file'は、シェルの`rm'コマンドのように、指定したファイルを削
除します。1つのディレクトリ内のたくさんのファイルを削除するのなら、
diredを使うほうが便利です（*Note Dired::）。

`M-x rename-file'は、ミニバッファで2つのファイル名、OLDとNEWを読み取り、
ファイルOLDをNEWに改名します。NEWという名前のファイルが既存のときには、
確認に`yes'で応答する必要があります。そうしないと、改名しません。これは、
改名により名前NEWの古い意味が失われるからです。OLDとNEWが異なるファイル
システムの上にあるときには、ファイルOLDを（NEWに）コピーしてから削除し
ます。

似たコマンド`M-x add-name-to-file'は、既存ファイルの名前を消さずに別の
名前を追加するために使います。新しい名前は、既存ファイルが置かれている
同じファイルシステムに属している必要があります。

`M-x copy-file'は、ファイルOLDを読んで、新しいファイルNEWに同じ内容を書
き出します。NEWという名前のファイルが既存なら、確認を求めてきます。とい
うのは、コピーするとファイルNEWの古い内容を上書きしてしまうからです。

`M-x make-symbolic-link'は、2つのファイル名、TARGETとLINKNAMEを読み取っ
て、TARGETを指すLINKNAMEという名前のシンボリックリンクを作ります。この
結果、将来LINKNAMEをオープンしようとすると、その時点でTARGETという名前
のファイルを参照します。その時点で名前TARGETが使われていなければ、エラー
になります。このコマンドは引数TARGETを展開しないので、リンク先に相対名
を書くことができます。

LINKNAMEが使われていると、リンクを作るときに確認を求めます。すべてのシ
ステムでシンボリックリンクを使えるわけではないことに注意してください。



File: emacs-ja, Node: Compressed Files, Next: Remote Files, Prev: Misc File Ops

圧縮されたファイルの参照
========================

Emacsには、圧縮されたファイルを訪問すると自動的に展開し、それを変更して
保存すると自動的に再度圧縮するライブラリがあります。この機能を利用する
には、コマンド`M-x auto-compression-mode'を打ちます。

（自動展開を含む）自動圧縮がオンのときには、Emacsはファイル名で圧縮され
たファイルを認識します。ファイル名の語尾が`.gz'のものは、`gzip'で圧縮さ
れたファイルであることを表します。他の語尾の場合には、他の圧縮プログラ
ムであることを表します。

自動展開と自動圧縮は、Emacsがファイルの内容を使うすべての操作に適用され
ます。ファイルを訪問する、ファイルに保存する、ファイルの内容をバッファ
に挿入する、ファイルをロードする、ファイルをバイトコンパイルすることを
含みます。



File: emacs-ja, Node: Remote Files, Next: Quoted File Names, Prev: Compressed Files

リモートファイル
================

特別なファイル名の構文を使って、他のマシン上のファイルを参照できます。

     /HOST:FILENAME
     /USER@HOST:FILENAME

このようにすると、Emacsは、指定したホスト上のファイルを読み書きするため
にFTPプログラムを使います。あなたのユーザー名かUSERを使ってFTPでログイ
ンします。毎回パスワードを聞かれることもありますが、これはHOSTへのログ
インに使われます。

普通、リモートファイル名にユーザー名を指定しないと、
あなたのユーザー名を使うことを意味します。
しかし、変数`ange-ftp-default-user'に文字列を設定しておけば、
その文字列をかわりに使います。
（FTPによるファイル参照を実装するEmacsのパッケージは、
`ange-ftp'と呼ばれる。）

変数`file-name-handler-alist'に`nil'を設定すると、FTPファイル名機能を完
全にオフにできます (1) (*Note Remote Files-Footnotes::)。


File: emacs-ja  Node: Remote Files-Footnotes, Up: Remote Files

(1) ファイル名をクォートする`/:'の機能もオフになる。



File: emacs-ja, Node: Quoted File Names, Prev: Remote Files

クォートしたファイル名
======================

特殊文字や特別な構文の特別な効果を抑えるために、絶対ファイル名を"クォー
ト"できます。そうするには、先頭に`/:'を加えます。

たとえば、リモートにあるように見えるローカルなファイル名をクォートして、
リモートファイル名として扱われるのを防ぎます。したがって、ディレクトリ
が`/foo:'という名前であり、その中に`bar'という名前のファイルがあるとき、
Emacsでは、そのファイルを`/:/foo:/bar'で参照できます。

`/:'は、`~'をユーザーのホームディレクトリを表す特殊文字として扱わないよ
うにもします。たとえば、`/:/tmp/~hack'は、ディレクトリ`/tmp'の中にある
`~hack'というファイル名を指します。

同様に、`/:'は`$'を含むファイル名を
ミニバッファで入力する方法の1つです。
しかし、`$'をクォートするには、
`/:'は（ミニ）バッファの先頭に置く必要があります。

ワイルドカード文字を`/:'でクォートすることもできます。
たとえば、`/:/tmp/foo*bar'でファイル`/tmp/foo*bar'を訪問します。
しかしながら、多くの場合、単にワイルドカード文字そのものを入力できます。
たとえば、`/tmp'にある`foo'で始まり`bar'で終る名前の
ファイルが`foo*bar'であるときには、
`/tmp/foo*bar'と指定すると、単に`/tmp/foo*bar'を訪問します。



File: emacs-ja, Node: Buffers, Next: Windows, Prev: Files, Up: Top

複数のバッファの使い方 *(2004/07/16)*
*************************************

Emacs内で編集しているテキストは"バッファ"（buffer）と呼ばれるオブジェク
トの中に存在します。ファイルを訪問するたびに、ファイルのテキストを保持
するバッファを作ります。diredを起動するたびに、ディレクトリ一覧を保持す
るバッファを作ります。`C-x m'でメッセージを送信するときには、メッセージ
のテキストを保持するためにバッファ`*mail*'が使われます。コマンドの説明
文を求めると、`*Help*'と呼ばれるバッファに説明文が現れます。

どんなときでも、1つのバッファだけが"カレント"になります．このバッファを
選択されたバッファ"とも呼びます。バッファが1つしかないかのように、コマ
ンドが『バッファ』に作用するといういい方をよくします。しかし、実際には、
コマンドがカレントバッファに作用するということです（多くのコマンドはそ
うする）。

複数のウィンドウがあるとき、各ウィンドウは選択しているバッファを持ち，
それを表示しています．しかし，いつでもそれらのウィンドウのうち1つだけが
選択されていて、そのウィンドウに表示されているバッファがカレントバッファ
になります。各ウィンドウのモード行は、通常そのウィンドウで選択されてい
るバッファの名前を表示します（*Note Windows::）。

各バッファにはどんな長さでもよい名前があり、バッファ名を指定してバッファ
を選択できます。多くのバッファはファイルを訪問することで作成され、それ
らの名前はファイル名から導き出します。好きな名前で空のバッファを作るこ
ともできます。Emacsを新たに始めると、Emacs内でLisp式の評価に使える
`*scratch*'という名前のバッファができます。バッファ名では大文字小文字を
区別します。

各バッファは独立に、どのファイルを訪問しているか、
変更されているか、どのメジャーモードとマイナモードを使っているか
を記録しています。（*Note Major Modes::）。
どのEmacs変数も各バッファに"ローカルに"することができます。
つまり、あるバッファでの変数の値を
他のバッファでのその変数の値とは違う値にできます。
*Note Locals::。

バッファのサイズはいくつかの最大値よりも大きくなることはできません．最
大サイズはデータタイプ "Emacs integer" により表現できるバッファ位置によ
り規定されます．これは，Emacs がバッファ位置をそのデータタイプを使って
追跡しているためです．32ビットマシンでは最大バッファサイズは128MBになり
ます．

* Menu:

* List Buffers::                Getting a list of buffers that exist.
* Misc Buffer::                 Renaming; changing read-onlyness; copying text.
* Kill Buffer::                 Killing buffers you no longer need.
* Buffer Convenience::          Convenience and customization features for
                          buffer handling.



File: emacs-ja, Node: Select Buffer, Next: List Buffers, Prev: Buffers, Up: Buffers

バッファの作成と選択 *(2004/07/16)*
===================================

`C-x b BUFFER RET'
     BUFFERという名前のバッファを選択または作成する
     （`switch-to-buffer'）。
`C-x 4 b BUFFER RET'
     同様だが、別のウィンドウでBUFFERを選択する
     （`switch-to-buffer-other-window'）。
`C-x 5 b BUFFER RET'
     同様だが、別のフレームでBUFFERバッファを選択する
     （`switch-to-buffer-other-frame'）。

BUFNAMEという名前のバッファを選択するには、`C-x b BUFNAME RET'と打ちま
す。これは、引数BUFNAMEでコマンド`switch-to-buffer'を実行します。バッファ
名の略称形を補完することができます（*Note Completion::）。`C-x b'に空の
引数を指定すると、どのウィンドウにも表示されていない最近選択したバッファ
を意味します。

現在とは異なるウィンドウでバッファを選択するには `C-x 4 b BUFNAME
RET' を入力します．これは，関数 `switch-to-buffer-other-window' を実
行し，他のウィンドウで BUFNAME のバッファを表示します．デフォルトでは，バッ
ファを表示すると，隣接しているウィンドウに表示し，縦方向の高さを均等になるように
調節します．この機能を無効にし，ウィンドウ設定を保存するようにするには，
`even-window-heights' を `nil' にします．

同様に `C-x 5 b BUFFER RET' は関数
`switch-to-buffer-other-frame' を実行し，バッファを別フレームで選択します．

`special-display-buffer-names'と`special-display-regexps',
`same-window-buffer-names', `same-window-regexps' をカスタマイズするこ
とでこれらのコマンドがあるバッファをどう扱うか制御できます．これらの変
数の詳細は *Note Force Same Window:: と*Note Special Buffer Frames:: を
参照ください．さらに，変数 `display-buffer-reuse-frames' が 非-`nil' で
切り替えたいバッファがすでにフレームで表示されているなら，Emacsはそのフ
レームを前面に出します．

ほとんどのバッファは、ファイルを訪問することで作られるか、
テキストを表示するようなEmacsコマンドによって作られますが、
`C-x b BUFNAME RET'と打って、
明示的にバッファを作ることもできます。
こうすると、ファイルを訪問していない新しい空のバッファを作り、
編集できるようにそのバッファを選択します。
このようなバッファは、自分用のメモを作るのに使います。
これらのバッファを保存しようとすると、
使用するファイル名を聞かれます。
新しいバッファのメジャーモードは、
`default-major-mode'の値で決まります（*Note Major Modes::）。

`C-x C-f'やファイルを訪問する他のコマンドは、
ファイルを訪問している既存のバッファへの切り替えにも使えることに
注意してください。
*Note Visiting::。

Emacsは、内部目的用のバッファには、空白で始まるバッファ名を使います。
Emacsは、これらのバッファを少々特別に扱います。たとえば、デフォルトでは、
アンドゥ情報を記録しません。このようなバッファ名は避けるのが最良です。



File: emacs-ja, Node: List Buffers, Next: Misc Buffer, Prev: Buffers, Up: Buffers

既存バッファの一覧 *(2004/07/16)*
=================================

`C-x C-b'
     既存バッファを一覧表示する（`list-buffers'）。

既存のすべてのバッファを一覧表示するには、`C-x C-b'と打ちます。各行は、
バッファ名、メジャーモード、訪問しているファイルを示します。バッファは
選択された順に表示されます。もっとも最近に選択されたバッファが始めにき
ます。

最初のフィールドの`*'は、バッファが『修正され』ていることを示します。い
くつかのバッファが修正されているなら、`C-x s'でいくつかのバッファを保存
する時期かもしれません（*Note Saving::）。`%'は、読み出し専用バッファを
示します。`.'はカレントバッファに付けられます。つぎは、バッファ一覧の例
です。

     CRM Buffer                Size  Mode              File
     . * .emacs                3294  Emacs-Lisp        ~/.emacs
      %  *Help*                 101  Help
         search.c             86055  C                 ~/cvs/emacs/src/search.c
      %  src                  20959  Dired by name     ~/cvs/emacs/src/
       * *mail*                  42  Mail
      %  HELLO                 1607  Fundamental       ~/cvs/emacs/etc/HELLO
      %  NEWS                481184  Outline           ~/cvs/emacs/etc/NEWS
         *scratch*              191  Lisp Interaction
       * *Messages*            1554  Fundamental

バッファ`*Help*'は、ヘルプ要求で作られたものです。このバッファはファイ
ルを訪問していません。バッファ`src'は、ディレクトリ`~/cvs/emacs/src/'に
対してdiredが作ったものです。前置引数を付けることで訪問しているファイル
バッファのみを一覧できます．たとえば，`C-u C-x C-b' とすると可能です．



File: emacs-ja, Node: Misc Buffer, Next: Kill Buffer, Prev: List Buffers, Up: Buffers

その他のバッファ操作 *(2004/07/16)*
===================================

`C-x C-q'
     バッファの読み出し専用状態を切り替える（`toggle-read-only'）。
`M-x rename-buffer RET NAME RET'
     カレントバッファの名前を変更する。
`M-x rename-uniquely'
     名前の最後に`<NUMBER>'を付加してカレントバッファ名を変更する。
`M-x view-buffer RET BUFFER RET'
     バッファBUFFERをスクロールする。

バッファは、"読み出し専用"にもなります。そうすると、その内容を変更する
コマンドは許されません。モード行では、左端付近に`%%'や`%*'を表示して、
読み出し専用バッファであることを示します。通常、読み出し専用バッファは、
テキストを操作する特別なコマンドを持つdiredやrmailなどのサブシステムが
作ります。書き込みを禁止されたファイルを訪問しても読み出し専用バッファ
が作られます。

読み出し専用バッファで変更したいときには、コマンド`C-x C-q'を使います
（`toggle-read-only'）。これは、読み出し専用バッファは書き込み可能にし、
書き込み可能バッファは読み出し専用にします。これは変数
`buffer-read-only'を設定することで動作します。この変数は各バッファでロー
カルな値を持ち、値が`nil'以外だとバッファは読み出し専用になります。版管
理の下に置かれているファイルがある場合には、`C-x C-q' を
`vc-toggle-read-only' にバインドした方が便利かもしれません．それなら，
`C-x C-q' と入力することで，読み出し専用の変数を変更するだけでなく，ファ
イルの読み出し専用状態も確認します。*Note Version Control::。

`M-x rename-buffer'は、カレントバッファの名前を変更します。ミニバッファ
引数として新しい名前を指定します。デフォルトはありません。すでに他のバッ
ファに使っている名前を指定すると、エラーになり、名前は変更されません。

`M-x rename-uniquely'は、他のどれとも違う唯一の名前にするために、カレン
トバッファ名に数字の接尾辞を付け加えて似た名前に変更します。このコマン
ドは引数を必要としません。このコマンドは複数のシェルバッファを作るのに
便利です。バッファ`*Shell*'を改名すれば、`M-x shell'をふたたび実行して
バッファ名`*Shell*'の新しいシェルバッファを作れます。一方、古いシェルバッ
ファは、新しい名前で存在し続けます。この方法は、メイルバッファ、コンパ
イルバッファ、特定の名前のバッファを作るEmacsの多くの機能にも有効です。

`M-x view-buffer'は、既存のEmacsバッファを調べることを除けば、`M-x
view-file'（*Note Misc File Ops::）によく似ています。閲覧（view）モード
には、バッファを簡単にスクロールするためのコマンドがありますが、変更す
るコマンドはありません。`q'で閲覧（view）モードから抜けると、ウィンドウ
にまえに表示していたバッファ（とその中での箇所）に切り替わります。ある
いは、`e'で閲覧（view）モードから抜けると、閲覧していたバッファとそのポ
イント位置はそのまま残ります。

コマンド、`M-x append-to-buffer'と`M-x insert-buffer'は、
1つのバッファから別のバッファへテキストをコピーするのに使います。
*Note Accumulating Text::。



File: emacs-ja, Node: Kill Buffer, Next: Buffer Convenience, Prev: Misc Buffer, Up: Buffers

バッファの消去 *(2004/07/16)*
=============================

Emacsのセッションをしばらく続けると、たくさんの数のバッファが溜っている
でしょう。もう必要としないバッファを"消去"したほうがよいと思うかもしれ
ません。多くのオペレーティングシステムでは、バッファを消去するとそのメ
モリ領域を解放してオペレーティングシステムに返すので、他のプログラムが
使えるようになります。バッファを消去するコマンドをいくつかあげます。

`C-x k BUFNAME RET'
     バッファBUFNAMEを消去する（`kill-buffer'）。
`M-x kill-some-buffers'
     1つ1つ各バッファを消去するかどうか聞いてくる。


`C-x k'（`kill-buffer'）は、ミニバッファで指定した名前のバッファを消去
します。ミニバッファでRETだけ打ったときに使われるデフォルトは、カレント
バッファを消去することです。カレントバッファを消去すると、別のバッファ
がカレントバッファになります。どのウィンドウにも表示されていない、もっ
とも最近のカレントバッファです。ファイルを訪問して修正してある（編集後
に保存していない）バッファを消去しようとすると、バッファを消去するまえ
に`yes'での確認を求めます。

コマンド`M-x kill-some-buffers'は、1つ1つ各バッファについて消去するか聞
いてきます。`y'と答えると、そのバッファを消去します。カレントバッファや
未保存の変更を含むバッファを消去しようとすると、新しいバッファを選択す
るか`kill-buffer'のように確認を求めてきます。

バッファメニュー機能（*Note Several Buffers::）も、さまざまなバッファを
削除するのに便利です。

バッファを削除するときに、毎回何か特別なことをしたいならば、フック
`kill-buffer-hook'にフック関数を追加します（*Note Hooks::）。

多くの人々がやるように、何日にもわたってたった1つのEmacsセッションを実
行する場合、数日前に使ったバッファで一杯になることがあります。コマンド
`M-x clean-buffer-list'は、それらのバッファを消去する便利な方法です。長
い期間にわたって使っていない未修正のバッファすべてを消去します。3日間表
示していない普通のバッファは消去されます。しかし、特定のバッファを自動
的には消去しないようにしたり、ほんの数時間使用しないだけで消去するよう
にも指定できます。

真夜中（midnight）モードをオンにすれば、このようなバッファの消去を毎日
真夜中に行わせることもできます。真夜中（midnight）モードは、毎日真夜中
に動作します。真夜中に、`clean-buffer-list'、あるいは、ノーマルフック
`midnight-hook'に指定した関数を実行します。

真夜中（midnight）モードをオンにするには、
カスタマイズ（customization）バッファを使って、
変数`midnight-mode'に`t'を設定します。
*Note Easy Customization::。



File: emacs-ja, Node: Several Buffers, Next: Buffer Convenience, Prev: Kill Buffer, Up: Buffers

複数バッファの操作 *(2004/07/16)*
=================================

"バッファメニュー"（buffer-menu）機能は『バッファに対するdired』に似て
います。このコマンドは、バッファ一覧を収めたEmacsバッファを編集すること
で、さまざまなEmacsバッファを操作できます。バッファの保存、消去（ここで
はdiredとの一貫性のために"削除"と呼ぶ）、表示を行うことができます。

`M-x buffer-menu'
     すべてのEmacsバッファの一覧を収めたバッファを編集し始める。
`M-x buffer-menu-other-window.'
     似ていますが，他のウィンドウで行います．

コマンド`buffer-menu'は、すべてのEmacsバッファの一覧をバッファ`*Buffer
List*'に書き (1) (*Note Several Buffers-Footnotes::)、そのバッファをバッ
ファメニュー（buffer-menu）モードにして選択します。`*Buffer List*' で表
示されるリストは *Note List Buffers:: で述べたものと全く同じように見え
ます．そのバッファは読み出し専用で、本節で述べる特別なコマンドでのみ変
更できます。普通のEmacsカーソル移動コマンドは、`*Buffer List*'バッファ
でも使えます。つぎにあげるコマンドは、現在行に書かれているバッファに作
用します。

`d'
     バッファを削除（消去）するように指示し、1行下へ移動する。この指示
     は、その行のバッファ名のまえに`D'を表示する。指示した削除は、`x'コ
     マンドを打ったときに実行される。
`C-d'
     `d'に似ているが、1行下へ移動するかわりに上へ移動する。
`s'
     バッファを保存するように指示する。この指示により、行には`S'が表示
     される。指示した保存は、`x'コマンドを打ったときに実行される。同じ
     バッファに対して、保存と削除の両方を指示できる。
`x'
     まえに指示した削除と保存を実行する。
`u'
     現在行に対する指示を消し、1行下へ移動する。
`DEL'
     1つまえの行に移動し、その行に対するどんな指示も消す。

`d'、`C-d'、`s'、`u'コマンドは、フラグを追加または削除して、1行下へ（あ
るいは上へ）移動します。これらのコマンドは、反復回数として数引数を取り
ます。

つぎにあげるコマンドは、現在行に書かれているバッファにただちに作用しま
す。

`~'
     バッファに『変更なし』と印を付ける。コマンド`~'を打つと、ただちに
     実行する。
`%'
     バッファの読み出し専用フラグをトグルする。コマンド`%'を打つと、た
     だちに実行する。
`t'
     タグテーブルとしてバッファを訪問する。
     *Note Select Tags Table::。

他のバッファや複数のバッファを選択するコマンドもあります。

`q'
     バッファメニューをやめる。このウィンドウには、ここに表示していたもっ
     とも最近のバッファを表示する。
`RET'
`f'
     `*Buffer List*'のかわりに、この行のバッファをただちに選択する。
`o'
     `C-x 4 b'のように、別のウィンドウでこの行のバッファをただちに選択する。
     `*Buffer List*'はそのまま。
`C-o'
     別のウィンドウにこの行のバッファをただちに表示するが、そのウィンド
     ウを選択しない。
`1'
     この行のバッファを画面一杯のウィンドウにただちに選択する。
`2'
     ただちに2つのウィンドウにして、この行のバッファをその1つに、
     （`*Buffer List*'バッファを除いて）まえのカレントバッファをもう1つ
     に表示する。
`b'
     この行のバッファを一覧の最後に移す。
`m'
     `v'コマンドでバッファメニューをやめたときに、この行のバッファを別
     のウィンドウに表示するように印を付ける。この指示は、行頭に`>' を表
     示する。（1つのバッファに、削除指示と表示指示の両方を付けることは
     できない。）
`v'
     ただちにこの行のバッファを選択し、別のウィンドウ群には`m'コマンド
     で印を付けたバッファ群を表示する。印を付けたバッファがなければ、こ
     のコマンドは`1'コマンドと同じ。

`buffer-menu'が直接行うことは、適切なバッファを作成してそれに切り替えて
から、バッファメニュー（buffer-menu）モードにすることです。それ以外の上
に述べたことはすべて、バッファメニュー（buffer-menu）モードが用意した特
別なコマンドで実装されています。その結果、`*Buffer List*'バッファから別
のEmacsバッファへ切り替えて、そこで編集できます。あとで`*Buffer List*'
バッファをふたたび選択してすでに指示した操作を実行したり、このバッファ
を削除したり、無視したりもできます。

`buffer-menu'と`list-buffers'の唯一の違いは、`buffer-menu'は選択された
ウィンドウで`*Buffer List*'バッファに切り替えることです。
`list-buffers'は別のウィンドウにこのバッファを表示するだけです。
`list-buffers'を実行し（つまり、`C-x C-b'と打つ）、`*Buffer List*'バッ
ファを手動で選択すると、ここに述べたすべてのコマンドを使えます。

バッファを作成したり削除したりしても、
バッファ`*Buffer List*'は自動的に更新されません。
その内容はただのテキストにすぎません。
バッファを作成／削除／改名したら、
現在のバッファの状態を見るために`*Buffer List*'を更新する方法は、
`g'（`revert-buffer'）を打つか、
`buffer-menu'コマンドを再度実行することです。

関数 `buffer-menu-other-window' は `buffer-menu' と同じように動作します
が，バッファリストを別ウィンドウに表示することだけが異なります．


