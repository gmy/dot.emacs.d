Info file: emacs-ja,    -*-Text-*-
produced by `texinfo-format-buffer'
from file `emacs.texi'
using `texinfmt.el' version 2.41 of  1 Mar 2005.

INFO-DIR-SECTION Emacs
START-INFO-DIR-ENTRY
* Emacs-ja: (emacs-ja).	            Emacs21.3日本語マニュアル.
END-INFO-DIR-ENTRY








File: emacs-ja  Node: Input Methods-Footnotes, Up: Input Methods

(1) 【訳注】言語環境が`Japanese'のときにデフォルトで使用される
LEIMに含まれているもの。「ローマ字→ひらがな→漢字」と変換するが、あま
い使いやすくはない。WNN、かんな、SKKなどを使うには、Emacsの配布とは別の
非公式パッチを自前で当てる必要がある。ただし、これらを用いた場合、日本
語を入力できない場面もあることを承知しておく必要がある。



File: emacs-ja, Node: Select Input Method, Next: Multibyte Conversion, Prev: Input Methods, Up: International

入力方式の選択
==============

`C-\'
     選択されている入力方式をオン／オフする。

`C-x RET C-\ METHOD RET'
     カレントバッファに対して新しい入力方式を選択する。

`C-h I METHOD RET'
`C-h C-\ METHOD RET'
     入力方式METHODについて説明する（`describe-input-method'）。デフォ
     ルトでは、（あれば）現在の入力方式を説明する。この説明で、ある入力
     方式の使い方の詳細がわかるはず。

`M-x list-input-methods'
     使用可能なすべての入力方式の一覧を表示する。

カレントバッファに対する入力方式を選ぶには、`C-x RET
C-\'（`set-input-method'）を使います。このコマンドは、ミニバッファで入
力方式名を読みます。その名前は、通常、一緒に使うことを意図された言語環
境で始まります。変数`current-input-method'は、どの入力方式を選択したか
を記録します。

入力方式は、非ASCII文字を入力するために、さまざまなASCII文字の列を使い
ます。ときには、一時的に入力方式をオフにできると便利なこともあります。
そうするには、`C-\'（`toggle-input-method'）と打ちます。入力方式をふた
たびオンにするには、`C-\'をもう一度打ちます。

`C-\'を打ったときに、入力方式をまだ選択していないと、
入力方式を指定するように聞いてきます。
これは、入力方式を指定するために
`C-x RET C-\'を使うのと同じ効果があります。

言語環境を選択すると、さまざまなバッファで使うデフォルトの入力方式を指
定します。デフォルトの入力方式を指定してあれば、`C-\'と打てばカレントバッ
ファでそれを選択できます。変数`default-input-method'は、デフォルトの入
力方式を指定します（`nil'は入力方式なしの意味）。

アルファベット文字に対するいくつかの入力方式は、その文字向けに一般的に
使用されるさまざまなキーボード配列をエミュレートするようにキーボードを
（実質的に）マッピングし直すことで動作します。マッピングし直す方法は、
あなたの実際のキーボード配列に依存します。使っているキーボード配列を指
定するには、コマンド`M-x quail-set-keyboard-layout'を使います。

使用可能なすべての入力方式の一覧を表示するには、`M-x
list-input-methods'と打ちます。この一覧には、モード行に表示される入力方
式を表す文字列を含めて、各入力方式についての情報が示されます。



File: emacs-ja, Node: Multibyte Conversion, Next: Recognize Coding, Prev: Select Input Method, Up: International

ユニバイトとマルチバイトの非ASCII文字
=====================================

マルチバイト文字が使用可のときには、文字コード0240（8進数）から0377（8
進数）の文字は、実際にそのままではバッファ内に存在しません。正しい非
ASCII印字文字は、0400から始まるコードになります。

0240から0377の不正な範囲の自己挿入文字を打った場合、Emacsは、ISO
Latin-N文字集合の1つを使おうとしていると仮定して、Latin-Nの文字を表す
Emacsのコードに変換します。言語環境の選択を介して、*どの*ISO Latin文字
集合を使うのか指定できます（*Note Language Environments::）。何も選んで
ないと、デフォルトはLatin-1です。

`C-q'でこの範囲の8進コードを入力すると、同じことが起こります。



File: emacs-ja, Node: Coding Systems, Next: Recognize Coding, Prev: Multibyte Conversion, Up: International

コーディングシステム
====================

さまざまな言語を使うユーザーは、それらを表現するための標準的なコーディ
ングシステムを数多く確立してきました。Emacsはこれらのコーディングシステ
ムを内部的には使用しません。そのかわり、データを読むときには、さまざま
なコーディングシステムからEmacs独自のコーディングシステムに変換し、デー
タを書くときには、内部コーディングシステムから他のコーディングシステム
に変換します。ファイルの読み書き、端末とのやりとり、サブプロセスとのデー
タ交換において、変換できます。

Emacsは各コーディングシステムに名前を付けています。
多くのコーディングシステムは、1つの言語で使用されるので、
コーディングシステムの名前は、言語の名前で始まります。
いくつかのコーディングシステムは、いくつもの言語で使用されます。
その場合、コーディングシステムの名前は、通常、`iso'で始まります。
印字文字をまったく変換しない特別なコーディングシステム、
`no-conversion'、`raw-text'、`emacs-mule'もあります。

非ASCII文字のさまざまな表現形の変換に加えて、コーディングシステムは行末
変換も行います。Emacsは、ファイル内の行の区切り方として、3つの異なる変
換を扱えます。つまり、改行、復帰改行、復帰です。

`C-h C CODING RET'
     コーディングシステムCODINGを説明する。

`C-h C RET'
     現在使用しているコーディングシステムを説明する。

`M-x list-coding-systems'
     使用可能なすべてのコーディングシステムの一覧を表示する。

コマンド`C-h C'（`describe-coding-system'）は、特定のコーディングシステ
ムについての情報を表示します。引数にコーディングシステム名を指定できま
す。あるいは、引数が空のときには、カレントバッファに対するものとデフォ
ルトの両方について、さまざまな目的のために選択されている現在のコーディ
ングシステムと、コーディングシステムを認識するための優先順位表を説明し
ます。（*Note Recognize Coding::）。

利用可能なすべてのコーディングシステムの一覧を表示するには、`M-x
list-coding-systems'と打ちます。モード行に表示される文字を含めて、各コー
ディングシステムについての情報の一覧を表示します（*Note Mode Line::）。

いかなる種類の変換も行わない`no-conversion'を除いて、この一覧に現れる各
コーディングシステムは印字文字をどのように変換する／しないを指定します。
しかし、行末変換は、各ファイルの内容に基づいて決定されます。たとえば、
ファイルが行区切りに復帰改行を使用しているように思われるときには、その
行末変換を使います。

一覧の各コーディングシステムには、どのように行末変換するかを正確に指定
する3つの変種があります。

`...-unix'
     行末変換を行わない。ファイルでは、行区切りに改行を使用していると仮
     定する。（これは、UNIXとGNUシステムで普通に使用される変換。）

`...-dos'
     ファイルでは、行区切りに復帰改行を使用していると仮定し、適当な変換
     を行う。（これは、Microsoftシステムで普通に使用される変換。 (1)
     (*Note Coding Systems-Footnotes::)）

`...-mac'
     ファイルでは、行区切りに復帰を使用していると仮定し、適当な変換を行
     う。（これは、Machintoshシステムで普通に使用される変換。）

これらのコーディングシステムの変種は、完全に予想できるので
`list-coding-systems'の表示からは簡潔にするために除かれています。たとえ
ば、コーディングシステム`iso-latin-1'には、`iso-latin-1-unix'、
`iso-latin-1-dos'、`iso-latin-1-mac' の変種があります。

コーディングシステム`raw-text'は、主にASCIIテキストのファイルに適してい
ますが、ファイルには、非ASCII文字の符号を意味しない127を越えるバイト値
が含まれるかもしれません。`raw-text'では、Emacsは、それらのバイトが適切
に解釈されるように値を変更しないでコピーし、カレントバッファの
`enable-multibyte-characters'に`nil'を設定します。`raw-text'は、出会っ
たデータに基づく普通の方法で行末変換を処理し、使用する行末変換を指定す
る3つの変種を持ちます。

対照的に、コーディングシステム`no-conversion'は、非ASCIIバイト値と行末
に対して、いかなる文字コード変換も指定しません。これは、バイナリファイ
ル、tarファイル、そのまま処理する必要があるその他のファイルを読み書きす
るのに便利です。これも、`enable-multibyte-characters'に`nil'を設定しま
す。

いかなる種類の変換もしないでファイルを編集するもっとも簡単な方法は、
`M-x find-file-literally'コマンドを使うことです。
このコマンドは、`no-conversion'を使い、
あなたがファイルを見るまえにファイルの内容を
変換するかもしれないEmacsのその他の機能を抑制します。
*Note Visiting::。

コーディングシステム`emacs-mule'は、Emacs内部の符号化のままで格納された
非ASCII文字を含むファイルであることを意味します。これは、出会ったデータ
に基づいて行末変換を扱い、行末変換の種類を指定する通常の3つの変種を持ち
ます。


File: emacs-ja  Node: Coding Systems-Footnotes, Up: Coding Systems

(1) MIMEの「text/*」の本体や、他のネットワーク転送の場面でも指定さ
れる。Emacsが直接には扱えないSGMLの参照構文である
record-start/record-end書式とは異なる。



File: emacs-ja, Node: Recognize Coding, Next: Specify Coding, Prev: Multibyte Conversion, Up: International

コーディングシステムの認識
==========================

一度自分の好みを指定しておけば、ほとんどの場合、Emacsは、与えられたファ
イルに対してどのコーディングシステムを使うか認識できます。

いくつかのコーディングシステムは、データ内にどのようなバイト列が現れた
かで、認識したり区別できます。しかし、区別できないコーディングシステム
やその可能性もないコーディングシステムもあります。たとえば、Latin-1と
Latin-2を区別する方法はありません。これらは同じバイト値を異なる意味で使
用しています。

Emacsは、コーディングシステムの優先順位表を用いてこの事態を処理します。
使用するコーディングシステムを指定しなければ、Emacsはファイルを読むとき
はいつでも、優先順位のもっとも高いものから始めて順に下りながら、データ
に合うコーディングシステムをみつけるまで各コーディングシステムに対して
データを検査します。そして、ファイルはそのコーディングシステムで表現さ
れていると仮定して、ファイルの内容を変換します。

コーディングシステムの優先順位表は、選択されている言語環境に依存します
（*Note Language Environments::）。たとえば、フランス語を使うのなら、た
ぶん、EmacsにはLatin-2よりLatin-1を選んでほしいでしょう。チェコ語を使う
なら、たぶん、Latin-2のほうがよいでしょう。これが、言語環境を指定する理
由の1つです。

しかし、コマンド`M-x prefer-coding-system'を使って、優先順位表の詳細を
変更できます。このコマンドはミニバッファからコーディングシステムの名前
を読み、それを優先順位表の先頭に追加して、他のすべてのものより優先する
ようにします。このコマンドを数回使うと、使用するごとに優先順位表の先頭
に1つの要素が追加されます。

`iso-8859-1-dos'のような行末変換を指定したコーディングシステムを使うと、
`iso-8859-1'を優先して認識し、その場合にはDOSの行末変換を使うことを
Emacsに指示することになります。

ときには、ファイルに対して使用するコーディングシステムをファイル名が示
していることがあります。変数`file-coding-system-alist'は、この対応関係
を指定します。このリストに要素を追加する特別な関数
`modify-coding-system-alist'があります。たとえば、すべての`.txt'の読み
書きに、コーディングシステム`china-iso-8bit'を使用したいなら、つぎの
Lisp式を実行します。

     (modify-coding-system-alist 'file "\\.txt\\'" 'china-iso-8bit)

始めの引数は`file'、第2引数はこれを適用するファイルを決定する正規表現、
第3引数はこれらのファイルに対して使用するコーディングシステムです。

Emacsは、ファイルの内容に基づいて、使用する行末変換の種類を認識します。
復帰のみ、あるいは、復帰改行の列のみであれば、対応する行末変換を選択し
ます。変数`inhibit-eol-conversion'に`nil'以外を設定すると、行末変換の自
動的な使用を禁止できます。

ファイルの先頭の`-*-...-*-'や、ファイルの最後のローカル変数リストを使っ
て、個々のファイルに対してコーディングシステムを指定できます（*Note
File Variables::）。これを行うには、`coding'という名前の『変数』に値を
定義します。Emacsには、変数`coding'は実際にはありません。変数を設定する
かわりに、ファイルに対して指定されたコーディングシステムを使います。た
とえば、`-*-mode: C; coding: latin-1;-*-'は、Cモードを指定するとともに、
Latin-1のコーディングシステムの使用を指定します。ファイルでコーディング
システムを明示的に指定した場合、それは`file-coding-system-alist'に優先
します。

変数`auto-coding-alist'は、特定のパターンのファイル名に対してコーディン
グシステムを指定するもっとも強い方法です。この変数は、ファイル自身の
`-*-coding:-*-'にさえも優先します。Emacsはtarファイルやアーカイブファイ
ルに対してこの機能を使います。アーカイブ内のファイルの中にある
`-*-coding:-*-'で混乱して、ファイル全体にコーディングシステムを適用して
しまうことを防ぐのです。

Emacsがバッファに対するコーディングシステムを一度選択すると、そのコーディ
ングシステムを`buffer-file-coding-system'に入れておき、このバッファから
ファイルに書く操作では、デフォルトでこのコーディングシステムを使います。
これには、コマンド`save-buffer'や`write-region'も含まれます。異なるコー
ディングシステムを用いてこのバッファからファイルに書きたいときには、
`set-buffer-file-coding-system'を使って、そのバッファに対して異なるコー
ディングシステムを指定します（*Note Specify Coding::）。

メイル（mail）モード（*Note Sending Mail::）でメッセージを送るとき、
Emacsには、メッセージテキストの符号化に使うコーディングシステムを決定す
る異なる方法が4つあります。バッファの`buffer-file-coding-system'が
`nil'以外ならば、その値を試します。さもなければ、
`sendmail-coding-system'の値が`nil'以外ならば、その値を使います。3つめ
の方法は、新しいファイルに対するデフォルトのコーディングシステムが
`nil'以外ならば、それを使います。この値は、言語環境の選択で制御されます。
これらの3つの値がすべて`nil'ならば、Emacsは、Latin-1のコーディングシス
テムを使用して送出メイルを符号化します。

rmailで新しいメイルを受けとったとき、各メッセージが別々のファイルである
かのように、各メッセージは自動的にそのメイルが書かれたコーディングシス
テムで変換されます。これには、指定したコーディングシステムの優先順位表
を使います。MIMEメッセージが文字集合を指定するときには、
`rmail-decode-mime-charset'が`nil'でない限り、rmailはその指定に従います。

rmailファイル自身を読んだり保存したりするときには、Emacsは、変数
`rmail-file-coding-system'で指定されたコーディングシステムを使います。
そのデフォルト値は、`nil'です。rmailファイルは変換しないという意味です
（rmailファイルは、Emacsの内部文字コードで読み書きされる。）



File: emacs-ja, Node: Specify Coding, Next: Defining Fontsets, Prev: Recognize Coding, Up: International

コーディングシステムの指定
==========================

Emacsが自動的に正しいコーディングシステムを選択しない場合には、コーディ
ングシステムを指定するつぎのコマンドを使用できます。

`C-x RET f CODING RET'
     カレントバッファに訪問したファイルにコーディングシステムCODINGを使
     う。

`C-x RET c CODING RET'
     このコマンドの直後に続くコマンドに対してコーディングシステム
     CODINGを指定する。

`C-x RET k CODING RET'
     キーボード入力に対してコーディングシステムCODINGを使用する。

`C-x RET t CODING RET'
     端末出力に対してコーディングシステムCODINGを使用する。

`C-x RET p INPUT-CODING RET OUTPUT-CODING RET'
     カレントバッファでのサブプロセスの入力と出力にコーディングシステム
     INPUT-CODINGとOUTPUT-CODINGを使用する。

`C-x RET x CODING RET'
     ウィンドウシステムを介した他のプログラムとのセレクションの交換には、
     コーディングシステムCODINGを使用する。

`C-x RET X CODING RET'
     ウィンドウシステムで*1つ*のセレクションの交換には、コーディングシ
     ステムCODINGを使用する。

コマンド`C-x RET f'（`set-buffer-file-coding-system'）はカレントバッファ
に対してファイルコーディングシステムを指定します。いいかえれば、訪問し
たファイルを保存したりふたたび読む込むときに使うコーディングシステムで
す。コーディングシステムはミニバッファを使って指定します。このコマンド
は、すでに訪問したファイルに作用するので、ファイルを保存するときにしか
影響しません。

ファイルに対するコーディングシステムを指定する別の方法は、
ファイルを訪問するときです。
まずコマンド`C-x RET c'
（`universal-coding-system-argument'）を使います。
このコマンドは、ミニバッファを使ってコーディングシステム名を読みます。
ミニバッファを出たあと、
*直後のコマンド*に対して指定したコーディングシステムが使用されます。

ですから、たとえば、その直後のコマンドが`C-x C-f'ならば、そのコーディン
グシステムを使ってファイルを読みます（そして、ファイルを保存するときの
ためにそのコーディングシステムを記録します）。  あるいは、その直後のコ
マンドが`C-x C-w'ならば、そのコーディングシステムを使ってファイルに書き
ます。コーディングシステムを指定することで、影響される他のファイルコマ
ンドは、`C-x C-i'と`C-x C-v'、および、別のウィンドウを使う`C-x C-f'の変
形です。

`C-x RET c'は、`M-x shell'（*Note Shell::）を含むサブプロセスを開始する
コマンドにも影響します。

しかしながら、その直後のコマンドがコーディングシステムを使用しないなら、
`C-x RET c'は最終的には何の効果もありません。

ファイルを変換しないで訪問するもっとも簡単な方法は、
`M-x find-file-literally'コマンドです。
*Note Visiting::。

 変数`default-buffer-file-coding-system'は、新しいファイルを作成すると
きのコーディングシステムの選択を指定します。この変数は、新規作成のファ
イルを訪問するとき、あるいは、バッファを作成してそれをファイルに保存す
るときに適用されます。言語環境を選択すると、典型的には、言語環境に対し
て最適のデフォルトのコーディングシステムをこの変数に設定します。

コマンド`C-x RET t'（`set-terminal-coding-system'）は端末出力に対するコー
ディングシステムを指定します。端末出力のコーディングシステムを指定する
と、端末へのすべての文字出力はそのコーディングシステムに翻訳されます。

この機能は、特定の言語や文字集合向けに作られたある種の文字端末には便利
です。たとえば、ISO Latin 文字集合の1つを扱えるヨーロッパの端末です。
マルチバイトテキストを使っているときには、Emacsが端末で実際に扱える文字
を知るために、端末コーディングシステムを指定する必要があります。

Emacsがあなたの端末の正しいコーディングシステムを推測できない限り、デフォ
ルトでは、端末出力はまったく変換しません。

コマンド`C-x RET k'（`set-keyboard-coding-system'）はキーボード入力に対
するコーディングシステムを指定します。キーボードから入力した文字コード
の変換は、非ASCII図形文字を送出するキーを有する端末には便利です。たとえ
ば、いくつかの端末は、ISO Latin-1やその部分集合向けに設計されています。

デフォルトでは、キーボード入力はまったく変換しません。

コーディングシステムを使用してキーボード入力を変換することと、入力方式
の使用には似たところがあります。どちらも、1つの文字に変換するキーボード
入力列を定義しています。しかしながら、入力方式は人が対話的に使用するの
に便利なように設計されていて、変換される列は典型的にはASCII印字文字の列
です。コーディングシステムは、典型的には非図形文字の列を変換します。

コマンド`C-x RET x'（`set-selection-coding-system'）は、選択されたテキ
ストをウィンドウシステムへ送るとき、および、他のアプリケーションで作ら
れたセレクションのテキストを受け取るときのコーディングシステムを指定し
ます。このコマンドは、再設定しない限り、以降のすべてのセレクションに作
用します。コマンド`C-x RET X'（`set-next-selection-coding-system'）は、
Emacsが作る／読むつぎのセレクションのコーディングシステムを指定します。

コマンド`C-x RET p'（`set-buffer-process-coding-system'）は、サブプロセ
スの入出力に対するコーディングシステムを指定します。このコマンドはカレ
ントバッファに作用します。通常、各サブプロセスはそれ自身のバッファを持
ちます。ですから、各サブプロセスの入出力の変換を指定するには、対応する
バッファでこのコマンドを使用します。

デフォルトでは、プロセスの入出力はまったく変換しません。

変数`file-name-coding-system'は、ファイル名を符号化するためのコーディン
グシステムを指定します。この変数に（Lispシンボルや文字列で）コーディン
グシステム名を設定すると、Emacsは、すべてのファイル操作に対してそのコー
ディングシステムを使ってファイル名を符号化します。これは、ファイル名に
非ASCII文字を使うことを可能にしています。あるいは、少なくとも、指定した
コーディングシステムで符号化できる非ASCII文字を使えるはずです。

`file-name-coding-system'が`nil'ならば、Emacsは、選択されている言語環境
で決まるデフォルトのコーディングシステムを使います。デフォルトの言語環
境では、ファイル名の中の非ASCII文字は特別に符号化しません。Emacsの内部
表現でファイルシステム上に現れます。

*警告：*` 'Emacsセッションの途中で`file-name-coding-system' （や言語環
境）を変更すると、問題となる場合があります。つまり、それまでのコーディ
ングシステムで符号化された名前のファイルをすでに訪問していて、新しいコー
ディングシステムではその名前を符号化できない（あるいは異なって符号化さ
れる）ときです。そのようなバッファを訪問先ファイル名で保存しようとする
と、まちがった名前のファイルに保存されるか、エラーになります。そのよう
な問題が発生した場合には、 `C-x C-w'を使って、そのバッファに新しいファ
イル名を指定します。



File: emacs-ja, Node: Fontsets, Next: Defining Fontsets, Prev: Specify Coding, Up: International

フォントセット
==============

Xウィンドウシステムのフォントは、典型的には、1つのアルファベットや文字
集合の形を定義しています。したがって、Emacsが扱える文字の範囲全体を表示
するには、たくさんのフォントを集めたものが必要です。Emacsでは、そういっ
たフォントを集めたものを"フォントセット"（fontset）と呼びます。フォント
セットは、ある文字コード範囲を扱うフォントのリストで定義されます。

各フォントセットには、フォントと同様に名前があります。使用可能なXのフォ
ントは、Xサーバーが定義します。しかし、フォントセットはEmacsの中で定義
されます。いったんフォントセットを定義すれば、フォントを使える場面では
どこでも、その名前を指定してEmacs内のフォントセットを使用できます。もち
ろん、Emacsのフォントセットでは、Xサーバーで使えるフォントだけを使えま
す。ある文字が画面で中抜きの箱で表示されたなら、その文字に使用したフォ
ントセットには、その文字に対するフォントがないことを意味します。

Emacsは、"標準フォントセット"と"スタートアップフォントセット"の2つのフォ
ントセットを自動的に作ります。標準フォントセットは、非ASCII文字向けの広
い範囲のフォントをもっとも持ちそうなものです。しかし、これは、Emacsが使
うデフォルトではありません。（デフォルトでは、Emacsはボールドとイタリッ
クの変種のフォントをみつけようとする。）オプション`-fn'やXのリソース
`Font'（*Note Font X::）で使用する標準フォントセットを指定できます。た
とえば、つぎのようにします。

     emacs -fn fontset-standard

フォントセットが、すべての文字コードに対するフォントを指定する必要はあ
りません。フォントセットが、ある文字に対してフォントを指定していない、
あるいは、システムに存在しないフォントを指定している場合には、その文字
を正しく表示できません。そのかわりに、中抜きの箱を表示します。

フォントセットの高さと幅は、ASCII文字で決定されます（つまり、そのフォン
トセット内でASCII文字用に使われるフォント）。フォントセットのあるフォン
トが異なる高さや幅を持つ場合には、そのフォントを割り当てられた文字は、
フォントセットの大きさに切り詰められます。`highlight-wrong-size-font'が
`nil'以外ならば、これらのまちがった大きさの文字は箱で囲まれて表示されま
す。



File: emacs-ja, Node: Defining Fontsets, Next: Single-Byte European Support, Prev: Specify Coding, Up: International

フォントセットの定義方法
========================

Emacsは`standard-fontset-spec'の値に従って、自動的に標準フォントセット
を作ります。フォントセットの名前はつぎのとおりです。

     -*-fixed-medium-r-normal-*-16-*-*-*-*-*-fontset-standard

または、省略して`fontset-standard'です。

標準フォントセットのボールド、イタリック、ボールドイタリックの変種も
自動的に作られます。
それらの名前は、`medium'のかわりに`bold'、
`r'のかわりに`i'、あるいは、両方ともそのようになります。

リソース`Font'やオプション`-fn'で、デフォルトのASCIIフォントを指定する
と、Emacsはそれから自動的にフォントセットを生成します。これが、"スター
トアップフォントセット"で、その名前は`fontset-startup'です。これは、フォ
ント名のフィールド、FOUNDRY、FAMILY、ADD_STYLE、AVERAGE_WIDTHを`*'で、
CHARSET_REGISTRYを`fontset'で、CHARSET_ENCODINGを`startup'で置き換えて
得られた文字列をフォントセットの指定に使用します。

たとえば、Emacsをつぎのように起動します。

     emacs -fn "*courier-medium-r-normal--14-140-*-iso8859-1"

Emacsがつぎのフォントセットを生成して、Xウィンドウの初期フレームに使い
ます。

     -*-*-medium-r-normal-*-14-140-*-*-*-*-fontset-startup

Xのリソース`Emacs.Font'で、フォントセット名を実際のフォント名のように指
定できます。しかし、`Emacs*Font'のようなワイルドカードを使ったリソース
にフォントセット名を指定しないように注意してください。ワイルドカードを
使った指定は、フォントセットを扱えないメニューのような、他のさまざまな
目的にも適用されます。

`Fontset-N'という名前のXのリソースを使って追加フォントセットを指定でき
ます。ただし、Nは0から始まる整数です。リソースの値はつぎのような形式で
なければなりません。

     FONTPATTERN, [CHARSETNAME:FONTNAME]...

FONTPATTERNは、最後の2つのフィールドを除いて、標準のXフォント名の形式で
なければなりません。最後の2つのフィールドは、`fontset-ALIAS'の形式を持
つべきです。

フォントセットには2つの名前、長い名前と短い名前があります。長い名前は
FONTPATTERNです。短い名前は`fontset-ALIAS'です。どちらの名前でもフォン
トセットを参照できます。

`CHARSET:FONT'という構成は、ある文字集合に対して（このフォントセットで
は）どのフォントを使用するかを指定します。ここでCHARSETは、文字集合の名
前で、FONTはその文字集合に使用するフォントです。1つのフォントセットの定
義の中では、この構成を何度でも使用できます。

他の文字集合に対しては、EmacsはFONTPATTERNに基づいて選択します。
これには、文字集合を記述する値で`fontset-ALIAS'を置き換えます。
ASCII文字フォントに対しては、`fontset-ALIAS'を
`ISO8859-1'で置き換えます

これに加えて、いくつか連続したフィールドがワイルドカードであるなら、
Emacsはそれらを1つのワイルドカードにまとめます。これは、自動的に拡大縮
小したフォントの使用を避けるためです。大きめのフォントを縮小したフォン
トは編集には使えません。また、小さめのフォントを拡大したフォントも便利
ではありません。というのは、Emacsがそうするように、もともと小さなフォン
トを使うほうがよいからです。

したがって、FONTPATTERNがつぎのようであると、

     -*-fixed-medium-r-normal-*-24-*-*-*-*-*-fontset-24

ASCII文字に対するフォント指定はつぎのようになります。

     -*-fixed-medium-r-normal-*-24-*-ISO8859-1

また、Chinese GB2312文字に対するフォント指定はつぎのようになります。

     -*-fixed-medium-r-normal-*-24-*-gb2312*-*

上のフォント指定に一致する中国語フォントがないかもしれません。多くのXの
配布には、FAMILYフィールドが`song ti'か`fangsong ti'の中国語フォントだ
けが含まれています。そういった場合、`Fontset-N'をつぎのように指定します。

     Emacs.Fontset-0: -*-fixed-medium-r-normal-*-24-*-*-*-*-*-fontset-24,\
             chinese-gb2312:-*-*-medium-r-normal-*-24-*-gb2312*-*

そうすると、Chinese GB2312の文字を除くフォント指定では
FAMILYフィールドが`fixed'となり、
Chinese GB2312の文字に対するフォント指定では
FAMILYフィールドが`*'となります。

フォントセットのリソース値を処理してフォントセットを作る関数は、
`create-fontset-from-fontset-spec'です。フォントセットを作るために、こ
の関数を明示的に呼ぶこともできます。

Xにおけるフォントの命名法について詳しくは、*Note Font X::。



File: emacs-ja, Node: Single-Byte European Support, Prev: Defining Fontsets, Up: International

1バイトヨーロッパ文字の使い方
=============================

ISO 8859 Latin-N文字集合は、
さまざまなヨーロッパの言語で必要とされるアクセント文字と句読点記号を
扱うために、160から250の範囲の文字コードを定義しています。
マルチバイト文字を使用不可にしても、
Emacsは、一度にはこれらの文字コードの*1つ*を扱えます。
これらのコードの*どれ*を使うかを指定するには、
`M-x set-language-environment'を起動して、
`Latin-N'のような適切な言語環境を指定します。

ユニバイト操作についてより詳しくは、*Note Enabling Multibyte::を参照し
てください。非ASCII文字を含んだ初期化ファイルをユニバイトで読むことを保
証したいときには特に注意してください。

端末や使っているフォントでこれらの文字を扱えるならば、Emacsはこれらの文
字を表示できます。これは自動的に行われます。あるいは、ウィンドウシステ
ムを使っている場合には、現在の言語環境に従ってそれらに対応するマルチバ
イト文字を表示することで、Emacsはフォントセットを介して1バイト文字を表
示できます。これを行うには、変数
`unibyte-display-via-language-environment'に`nil'以外の値を設定します。

もし、端末でLatin-1文字集合を表示できなければ、Emacsは、これらの文字を
その文字が少なくとも何であるかを明確に理解できるようなASCII列として表示
できます。これを行うには、ライブラリ`iso-ascii'をロードします。他の
Latin-N文字集合に対しても似たようなライブラリを実装できますが、まだ行っ
ていません。

（文字128から159の）非ISO 8859文字は、通常、8進表示されます。ライブラリ
`disp-table'の関数`standard-display-8bit'を使えば、この表示を非標準の
「拡張」版のISO 8859文字集合に変更できます。

1バイト非ASCII文字を入力する異なる方法が3つあります。

   * キーボードが、非ASCII文字を表現する128以上の文字コードを生成できる
     ならば、Emacsがそれらを理解できるようにつぎの式を実行する。

          (set-input-mode (car (current-input-mode))
                          (nth 1 (current-input-mode))
                          0)

   * 選択した言語環境の入力方式を使う。*Note Input Methods::。ユニバイ
     トのバッファで入力方式を使うと、入力した非ASCII文字は、ユニバイト
     に変換される。

   * Latin-1に対してだけだが、非ASCIIのLatin-1の印字文字の入力の『合成
     文字』プレフィックスとして`C-x 8'を使える。`C-x 8'は、（ミニバッファ
     や他のバッファでの）挿入、探索、キー列が許される他の文脈などで使え
     る。

     ライブラリ`iso-transl'をロードすることで`C-x 8'は動作する。ライブ
     ラリをロードしておくと、ALT修飾キーがあるならば、`C-x 8'と同じ目的
     で使用できる。後続の文字を修飾するには、アクセント文字と一緒にALT
     を使う。さらに、Latin-1の『専用アクセント文字』キーがあると、
     `iso-transl'をロード後は、それらのキーも後続の文字を合成するように
     定義される。


File: emacs-ja, Node: Major Modes, Next: Indentation, Prev: International, Up: Top

メジャーモード *(2005/03/20)*
*****************************

Emacsには、多数の選択できる"メジャーモード"（major mode）があり、各モー
ドは特定の種類のテキストを編集するためにEmacsをカスタマイズします。メ
ジャーモードは相互に排他的で、各バッファはいつでも1つのメジャーモードだ
けを持ちます。モード行は、通常、現行のメジャーモードの名前を括弧の中に
表示します（*Note Mode Line::）。

もっとも特殊化されていないメジャーモードは、"基本（fundamental）モード
と呼ばれます。このモードには、モード独自の再定義や変数設定がなく、各
Emacsコマンドはもっとも一般的なふるまいをして、各オプションはデフォルト
の状態になっています。Lispや英文のように、Emacsが知っている特定の種類の
テキストを編集するには、Lispモードや、テキスト（text）モードのような適
切なメジャーモードに切り替えるべきです。

メジャーモードを選択することは、
編集対象の言語により明確に適応するようにキーの意味を多少変更することです。
よく変更されるキーはTAB、DEL、`C-j'です。
プレフィックスキー`C-c'は、モード特有のコマンドを含みます。
さらに、コメントを扱うコマンドは、
モードを使ってコメントの区切り方を決定します。
多くのメジャーモードでは、
バッファ内に現れる文字の構文上の属性を再定義しています。
*Note Syntax::。

メジャーモードは3つのグループに分けられます。最初のグループはプレインか
文字装飾があるかに関わらず，通常のテキストのためのものです．これには，
テキストモード(Text mode)，HTML モード, SGML モード, TeX モードやアウト
ラインモードなどがあります．2番目のグループはプログラミング言語特有のモー
ドです．これには，Lispモード(いくつかの変種を有する)、Cモード、Fortran
モードなどがあります．残りのメジャーモードは、ユーザーのファイルに使う
ためのものではありません。Emacsが特別の目的のために作るバッファで使われ
ます。dired（*Note Dired::）が作るバッファ向けのdiredモード（*Note
Dired::）、`C-x m'で作られるバッファ向けのメイル（mail）モード（*Note
Sending Mail::）、下位のシェルプロセスとの通信用のバッファ向けのシェル
（shell）モード（*Note Interactive Shell::）などです。

ほとんどのプログラム言語用のメジャーモードでは、段落の区切りは空行だけ
です。これは、段落コマンドを役立つようにするためです。（*Note
Paragraphs::。）また、これらのモードでは、自動詰め込み（auto-fill）モー
ドにおいて、新たに作った行を字下げするようにTABを定義します。というのは、
プログラム中のほとんどの行は通常字下げされるからです（*Note
Indentation::）．

* Menu:

* Choosing Modes::     How major modes are specified or chosen.



File: emacs-ja, Node: Choosing Modes

メジャーモードの選択方式 *(2005/03/20)*
=======================================

カレントバッファに対して明示的にメジャーモードを選択することもできます。
しかし、たいていは、ファイル名やファイル内の特別のテキストに基づいて
Emacsはどのモードを使うかを決定します。

明示的に新しいメジャーモードを選択するには、`M-x'コマンドで行います。メ
ジャーモードの名前に`-mode'を付け加えると、そのモードを選ぶコマンド名に
なります。したがって、Lispモードに入るには`M-x lisp-mode'を実行します。

ファイルを訪問すると、Emacsは通常ファイル名に基づいて正しいメジャーモー
ドを選択します。たとえば、`.c'で終る名前のファイルは、Cモードで編集され
ます。ファイル名とメジャーモードとの対応は、変数`auto-mode-alist'で制御
します。その値は、要素がつぎのような形式のリストです。

     (REGEXP . MODE-FUNCTION)

または、つぎの形式です。

     (REGEXP MODE-FUNCTION FLAG)

たとえば、このリストに通常ある要素は、`("\\.c\\'". c-mode)'です。これは、
`.c'で終る名前のファイルにはCモードを選びます。(Lispの構文では、`\'を含
めるには`\\'が必要。また、`\'は、正規表現の`.'の特別な意味を抑制するた
めに使われなければならない。) リストの要素が`(REGEXP MODE-FUNCTION
FLAG)'の形式でFLAGが`nil'以外ならば、MODE-FUNCTIONを呼んだあとにREGEXP
に一致する接尾辞を捨てて、リストで他に一致するものをふたたび探します。

ファイルの空行でない最初の行の特別な種類のテキストによって、そのファイ
ルを編集するためにどのメジャーモードを使うかを指定できます。モード名は、
その行に`-*-'で囲まれて現れます。他のテキストがその行にあってもかまいま
せん。たとえば、

     ;-*-Lisp-*-

は、EmacsにLispモードを使うように指示します。このような明示的な指定は、
ファイル名に基づいたメジャーモードに優先します。この行がLispのコメント
になるようにセミコロンを使っていることに注意してください。

モードを指定する別の書式は、つぎのとおりです。

     -*- mode: MODENAME;-*-

これは、同様にローカル変数も指定できて、つぎのように書きます。

     -*- mode: MODENAME; VAR: VALUE; ... -*-

より詳しくは、*Note File Variables::。

ファイルの内容が`#!'で始まるときは、ファイルの1行目で指定したコマンドイ
ンタープリタを実行することで、実行可能なシェルコマンドとして働きます。
ファイルの残りの部分は、インタープリタへの入力として使われます。

Emacsでそのようなファイルを訪問したとき、ファイルの名前がメジャーモード
を指定しないときには、Emacsはモードを選択するために1行目のインタープリ
タの名前を使います。1行目が、`perl'や`tcl'のような認識されるインタープ
リタプログラムの名前ならば、Emacsはインタープリタのプログラムにとって適
切なモードを使用します。変数`interpreter-mode-alist'は、インタープリタ
プログラム名とメジャーモードとの対応を指定します。

1行目が`#!'で始まるときには、
インタープリタを実行するときにシステムが混乱するため、
1行目では`-*-'の機能を使えません。
そのため、そのようなファイルでは、Emacsは1行目に加えて2行目でも
`-*-'を探します。

使用するメジャーモードを指定しないファイルを訪問したとき、あるいは、
`C-x b'で新たにバッファを作るときには、変数`default-major-mode'が、使用
するモードを指定します。通常、その値は、基本（fundamental）モードを指定
するシンボル`fundamental-mode'です。`default-major-mode'が`nil'なら、メ
ジャーモードはまえに現在のバッファのモードと同じものとなります。

バッファのメジャーモードを変更しても、Emacsが自動的に選択するメジャーモー
ドに戻れます。それには、コマンド`M-x normal-mode'を使います。このコマン
ドは、メジャーモードを選択するために`find-file'が呼び出す関数と同じ関数
です。この関数は、ファイル中にローカル変数リストが(もしあれば)それも処
理します。

コマンド`C-x C-w'と`set-visited-file-name'は、新しいファイル名がモード
を示すものであるなら、新しいメジャーモードに変更します（*Note
Saving::）。しかし、バッファの内容がメジャーモードを指定していて、かつ、
ある『特別な』メジャーモードがそのモードの変更を許さないなら、メジャー
モードは変更されません。`change-major-mode-with-file-name'を`nil'に設定
すると、このモード変更機能をオフにできます。



File: emacs-ja, Node: Indentation, Next: Text, Prev: Major Modes, Up: Top

字下げ
******

本章では、字下げ（indentation）を付加／削除／調整するEmacsコマンドにつ
いて説明します。

`TAB'
     モードに固有の方法で、現在行を『適切に』字下げする。
``C-j''
     RETに続けてTABを実行する（`newline-and-indent'）。
`M-^'
     2つの行を連結して1つにする（`delete-indentation'）。
     `C-j'の効果を取り消す。
`C-M-o'
     ポイント位置で行を分割する。つまり、行内のポイント以降のテキストは
     新たな行になり、かつ、ポイント位置まで字下げする（`split-line'）。
`M-m'
     現在行の空白でない最初の文字までポイントを（行末か行頭へ向かって）
     移動する（`back-to-indentation'）。
`C-M-\'
     複数の行を同じ桁に字下げする（`indent-region'）。
`C-x TAB'
     複数の行の塊を（右か左に）同じ量だけきっちり移動する
     （`indent-rigidly'）。
`M-i'
     ポイント位置からあらかじめ設定したつぎのタブストップ位置まで字下げ
     する（`tab-to-tab-stop'）。
`M-x indent-relative'
     ポイント位置からまえの行の字下げ位置まで字下げする。

ほとんどのプログラム言語には、字下げの慣習があります。Lispコードでは、
括弧の入れ子の深さに従って行を字下げします。細部はかなり異なりますが、
概念的にはCコードでも同様の考え方で字下げします。

どんな言語であっても、行を字下げするにはTABコマンドを使います。各メジャー
モードでは、特定の言語に適した字下げを行うように、このコマンドを定義し
ます。Lispモードでは、TABは括弧の深さに応じて行を整列します。行のどこで
TABを打鍵しても、その行全体を整列します。Cモードでは、TABは、Cの構文上
のさまざまな側面を考慮した巧みで洗練された字下げスタイルを実現していま
す。

テキスト（text）モードでは、TABは`tab-to-tab-stop'コマンドを実行します。
これは、つぎのタブストップ位置まで字下げを行います。タブストップ位置は
`M-x edit-tab-stops'で設定できます。

* Menu:

* Indentation Commands::  Various commands and techniques for indentation.
* Tab Stops::             You can set arbitrary "tab stops" and then
                            indent to the next tab stop when you want to.
* Just Spaces::           You can request indentation using just spaces.



File: emacs-ja, Node: Indentation Commands, Next: Tab Stops, Prev: Indentation, Up: Indentation

字下げコマンドとその技巧
========================

行の字下げを飛び越えるには、`M-m'（`back-to-indentation'）を使います。
行のどこで実行しても、その行の空白でない最初の文字位置にポイントを移動
します。

現在行のまえに字下げした行を挿入するには、`C-a C-o TAB'を使います。現在
行のあとに字下げした行を挿入するには、`C-e C-j'を使います。

単にタブ文字を挿入するには、`C-q TAB'と打ちます。

`C-M-o'（`split-line'）は、ポイントから行末までのテキストを垂直に下ろし
ます。その結果、現在行は2つの行に分割されます。`C-M-o'は、まず、ポイン
トの直後に空白やタブがある限りポイントを進めます。そして、ポイントの直
後に、改行とポイント位置の桁までに必要な字下げを挿入します。ポイント自
身は挿入した改行の直前に留まります。この点では、`C-M-o'は`C-o'に似てい
ます。

2つの行を連結するには、コマンド`M-^'（`delete-indentation'）を使います。
このコマンドは、現在行の行頭の字下げと行区切り（改行文字）を削除して空
白1個に置き換えます。ただし、この空白1個を省いてしまう（Lispコードには
便利な）特別な場合があります。2つの行を繋げた結果、開き括弧や閉じ括弧が
連続する場合、あるいは、さらに改行が続く場合です。現在行の字下げだけを
削除するには、行頭に移動してから`M-\'（`delete-horizontal-space'）を使
います。このコマンドは、カーソル（ポイント）の周りの空白とタブをすべて
削除します。

詰め込み接頭辞がある場合、`M-^'は、
削除される改行の直後に現れる詰め込み接頭辞を削除します。
*Note Fill Prefix::。

一度に複数の行の字下げを変更するコマンドもあります。
`C-M-\'（`indent-region'）は、リージョン内で始まるすべての行に作用しま
す。このコマンドは、行頭でTABを打鍵したかのように『普通の』方法で各行を
字下げします。数引数は字下げする桁位置を指定します。つまり、最初の空白
でない文字がその桁位置にくるように行全体を右か左に水平移動します。`C-x
TAB'（`indent-rigidly'）は、リージョン内のすべての行を、引数で指定した
分だけ右に移動します（引数が負であれば左に移動）。複数の行全部をきちっ
と揃えて（rigidly）横に移動することから、コマンドにはこのような名前が付
いています。

`M-x indent-relative'は、先行する行（実際には空行でないいちばん近くの行）
に基づいてポイント位置を字下げします。ポイント位置に空白を挿入してポイ
ントを進めて、ポイントが先行する行の字下げ位置の真下にくるようにします。
字下げ位置とは連続した白文字の末尾か行末のことです。ポイントが先行する
行のどの字下げ位置よりも右にある場合には、ポイントのまえの白文字を削除
してから、先行する行の適用可能な最初の字下げ位置まで字下げします。適用
可能な字下げ位置がない場合には、`indent-relative'は`tab-to-tab-stop'を
実行します（*Note Tab Stops::）。

字下げテキスト（indented text）モードでは、
TABは`indent-relative'と定義されます。
*Note Text::。

テキストの一部を字下げする別の方法については*Note Format Indentation::。



File: emacs-ja, Node: Tab Stops, Next: Just Spaces, Prev: Indentation Commands, Up: Indentation

タブストップ
============

表を入力するには、テキスト（textモード）におけるTABの定義、
`tab-to-tab-stop'を利用できます。このコマンドは、ポイントがつぎのタブス
トップ位置に達するまでポイントのまえに字下げを挿入します。テキスト
（text）モードでなくても、`M-i'でこのコマンドを実行できます。

`M-i'が使用するタブストップは任意に設定できます。
この設定は、昇順に並べた桁番号のリストとして
`tab-stop-list'と呼ばれる変数に格納されます。

タブストップを設定する便利な方法は、`M-x edit-tab-stops'を使うことです。
このコマンドは、タブストップの設定を記述したバッファを作成して選択しま
す。このバッファを編集して今までとは異なるタブストップを指定し、`C-c
C-c'と打ってその新たな設定を有効にします。`edit-tab-stops'は、呼ばれた
ときのカレントバッファをあらかじめ記録しておくので、そのバッファに新た
なタブストップを設定します。通常、全バッファで同じタブストップを共有し
ているので、1つのバッファでタブストップを変更すると、すべてのバッファに
影響をします。しかし、あるバッファで`tab-stop-list'をローカルにしておく
と、そのバッファで`edit-tab-stops'を実行するとローカルな設定を編集しま
す。

一般的に使われる8桁ごとに設定されたタブストップの場合、設定用バッファの
内容はつぎのようになります。

             :       :       :       :       :       :
     0         1         2         3         4
     0123456789012345678901234567890123456789012345678
     To install changes, type C-c C-c

1行目は、各タブストップ位置をコロンで表します。残りの行は、タブストップ
位置を読み取りやすくためや使い方です。

`tab-to-tab-stop'を制御するタブストップと、バッファ内でのタブ文字の表示
とは、関係がないことに注意してください。詳細については*Note Display
Vars::。



File: emacs-ja, Node: Just Spaces, Prev: Tab Stops, Up: Indentation

タブと空白
==========

Emacsでは、通常、行の字下げにはタブと空白の両方を使用します。
しかし、空白だけを用いて字下げを行うことも可能です。
そうするには、変数`indent-tabs-mode'に`nil'を設定します。
この変数はバッファごとの変数です。
変数を変更してもカレントバッファだけに影響しますが、
デフォルト値を変更することもできます。
*Note Locals::。

空白以外のテキストの桁を保存したまま、タブを空白（あるいはその逆）に変
換するコマンドもあります。`M-x tabify'は、リージョン内の連続する空白を
探して、字下げを変えることがなければ少なくとも連続する3個の空白をタブに
変換します。`M-x untabify'は、リージョン内のすべてのタブを適切な個数の
空白に変換します。


File: emacs-ja, Node: Text, Next: Programs, Prev: Indentation, Up: Top

自然言語用のコマンド
********************

コンピュータの分野では、"テキスト"（text）という用語には2つの大きな意味
があります。1つは、文字の列から成るデータのことです。この意味からすれば、
Emacsで編集するどんなファイルもテキストです。もう1つの意味はより限定さ
れていて、人間が読む自然言語の（テキスト整形処理後の場合もあるが）文字
の列のことで、プログラムやプログラムに与えるコマンドと対比されます。

自然言語には、エディタコマンドで支援したり利用したりできる構文的／様式
的な約束事があります。たとえば、単語、文、段落、大文字といったものです。
本章では、これらを扱うEmacsコマンドについて述べます。また、"詰め込み
（filling）、つまり、段落の各行がほぼ同じ長さになるように再配置し直すコ
マンドについてもふれます。単語、文、段落を横断してポイントを移動したり、
それらをキルするコマンドは、自然言語テキストの編集を意図したものですが、
プログラムの編集にも役立ちます。

Emacsには、自然言語テキストの編集用のメジャーモードがいくつかあります。
扱うテキストが純粋にテキストだけで単純なものであれば、テキスト（text）
モードを使いましょう。これは、自然言語テキストの構文上の約束事を扱える
ように、Emacsを少しだけカスタマイズしてあります。アウトライン（outline）
モードには、アウトライン構造を持つテキストを操作する特別なコマンドがあ
ります。

テキスト整形コマンドを埋め込んだテキストに対しては、特定のテキスト清書
系ごとに別のメジャーモードが用意してあります。たとえば、TeX用にはTeX モー
ドがあります。nroff用にはnroffモードがあります。

テキスト清書系を使うかわりにエンリッチ（enriched）モードを使用すれば、
WYSIWYG（what you see is what you get、『見たとおりを得る』）スタイルで
整形済みテキストを編集することもできます。つまり、Emacsの画面上で整形結
果を見ながら編集できるわけです。

* Menu:

* Words::	        Moving over and killing words.
* Sentences::	        Moving over and killing sentences.
* Paragraphs::	        Moving over paragraphs.
* Pages::	        Moving over pages.
* Filling::	        Filling or justifying text.
* Case::	        Changing the case of text.
* Text Mode::	        The major modes for editing text files.
* Outline Mode::        Editing outlines.
* TeX Mode::	        Editing input to the formatter TeX.
* Nroff Mode::	        Editing input to the formatter nroff.
* Formatted Text::      Editing formatted text directly in WYSIWYG fashion.



File: emacs-ja, Node: Words, Next: Sentences, Prev: Text, Up: Text

単語
====

Emacsには、単語を横断してポイントを移動したり、単語を操作対象とするコマ
ンドがあります。慣例として、これらのコマンドのキーはメタ文字です。

`M-f'
     単語を横断してポイントを前向きに移動する（`forward-word'）。
`M-b'
     単語を横断してポイントを後向きに移動する（`backward-word'）。
`M-d'
     ポイント位置から単語の末尾までをキルする（`kill-word'）。
`M-DEL'
     ポイント位置から単語の先頭までを後向きにキルする
     （`backward-kill-word'）。
`M-@'
     つぎの単語の末尾にマークを設定する（`mark-word'）。
`M-t'
     隣接した2つの単語を入れ替える。あるいは、単語を複数の単語を飛び越
     して移す。（`transpose-words'）。

これらのキーは、文字単位の操作コマンド、`C-f'、`C-b'、
`C-d'、DEL、`C-t'に対応していることに注目してください。
`M-@'も、`C-SPC'の別名である`C-@'に対応しています。

コマンド`M-f'（`forward-word'）と`M-b'（`backward-word'）は、単語を横断
してポイントを前向きに（末尾に向かって）あるいは後向きに（先頭に向かっ
て）移動します。これらのメタ文字は、文字単位でポイントを前後に移動する
コントロール文字`C-f'や`C-b'に類似しています。この類似性は、数引数を反
復回数として扱うことにもおよびます。負の引数を指定すると、`M-f'は後向き
に移動し、`M-b'は前向きに移動します。前向き移動では単語の最後の文字の直
後に、後向き移動では最初の文字の直前に、ポイントを移動します。 (1)
(*Note Words-Footnotes::)

`M-d'（`kill-word'）はポイントの直後の単語をキルします。
正確にいえば、ポイント位置から`M-f'による移動位置までの全文字をキルします。
ポイントが単語の途中にあれば、ポイントよりあとの部分だけをキルします。
また、ポイントとつぎの単語のあいだに句読点があれば、
単語と一緒にそれらもキルします。
（つぎの単語だけをキルしてそのまえにある句読点を残したければ、
`M-f'でつぎの単語の末尾に移動してから、
`M-DEL'でその単語を後向きにキルする。）
`M-d'は、引数を`M-f'と同様に解釈します。

`M-DEL'（`backward-kill-word'）は、
ポイントの直前の単語をキルします。
ポイント位置から`M-b'による移動位置までの全文字をキルします。
ポイントが`FOO, BAR'の空白の直後にあるとすれば、
`FOO, 'をキルします。
（`FOO'だけをキルしてコンマと空白を残したければ、
`M-DEL'のかわりに`M-b M-d'を使う。）

`M-t'（`transpose-words'）は、
ポイントの直前にある単語あるいはポイントを含む単語と、
後続の単語とを入れ替えます。
単語のあいだにある区切り文字は動きせん。
たとえば、`FOO, BAR'を入れ替えると、
`BAR FOO,'ではなく`BAR, FOO'となります。
入れ替えや入れ替えコマンドの引数については、
*Note Transpose::。

ポイントとマークのあいだに適用される操作を後続のN個の単語に適用する方法
は、2つあります。ポイント位置にマークを設定してから、単語を横断してポイ
ントを移動します。あるいは、コマンド`M-@'（`mark-word'）を使います。こ
のコマンドは、ポイントを移動せずに、`M-f'による移動位置にマークを設定し
ます。`M-@'には、何単語先にマークを設定するかを数引数で指定できます。暫
定マーク（transient-mark）モードでは、このコマンドはマークを活性にしま
す。

単語操作コマンドが理解する構文は、すべて構文テーブルで制御されます。
たとえば、任意の文字を単語の区切り文字として宣言できます。
*Note Syntax::。


File: emacs-ja  Node: Words-Footnotes, Up: Words

(1) 【訳注】なお、移動方向に単語構成文字がない場合には、それらを飛び越
えてポイントを移動します。



File: emacs-ja, Node: Sentences, Next: Paragraphs, Prev: Words, Up: Text

文
==

Emacsの文／段落操作コマンドは、単語操作コマンドと同じく、ほとんどメタキー
です。

`M-a'
     文の先頭にポイントを後向きに移動する（`backward-sentence'）。
`M-e'
     文の末尾にポイントを前向きに移動する（`forward-sentence'）。
`M-k'
     ポイント位置から文末までを前向きにキルする（`kill-sentence'）。
`C-x DEL'
     ポイント位置から文頭までを後向きにキルする
     （`backward-kill-sentence'）。

コマンド`M-a'と`M-e' （`backward-sentence'と`forward-sentence'）は、そ
れぞれ、ポイントを含む文の先頭あるいは末尾にポイントを移動します。これ
らは、行頭や行末にポイントを移動するコマンド`C-a'と`C-e'に類似するよう
に選ばれました。ただし、`M-a'や`M-e'を反復して使ったり数引数を指定する
と、ポイントは連続した文を横断して移動する点が違います。

（文頭に向かって）後向きに移動するときは、文の先頭の文字の直前にポイン
トを置きます。（文末に向かって）前向きに移動するときは、文を終える句読
点の直後に置きます。どちらのコマンドも、文と文の境界にある白文字にポイ
ントを移動することはありません。

`C-a'と`C-e'には調和したキルコマンド`C-k'があるように、`M-a'と`M-e'にも
コマンド`M-k'（`kill-sentence'）があります。これはポイントから文末まで
をキルします。引数に-1を指定すると、文頭までを後向きにキルします。これ
より大きな引数は反復回数になります。また、ポイント位置から文頭までを後
向きにキルするコマンドとして`C-x DEL'（`backward-kill-sentence'）もあり
ます。このコマンドは、文の作成途中で考えが変わったときに便利です。

文操作コマンドでは、文末に空白を2個打つという米国のタイピストの習慣を踏
襲しているものと仮定します。つまり、`.'、`?'、`!'の直後が行末であるか空
白が2個続けば、その箇所を文末とみなします。ただし、`.'、`?'、`!'の直後
には、`)'、`]'、`''、`"'がいくつあってもかまいません。また、段落の先頭
と末尾も、それぞれ、文の先頭と末尾になります。

変数`sentence-end'で、文末の識別方法を制御します。この値は、文末の数個
の文字とそれらに続く白文字に一致する正規表現です。通常の値はつぎのとお
りです。 (1) (*Note Sentences-Footnotes::)

     "[.?!][]\"')]*\\($\\|\t\\|  \\)[ \t\n]*"

この例は、正規表現の節で説明しました。
*Note Regexps::。

文のあいだには空白を1個だけとしたければ、
`sentence-end'にはつぎの値を設定します。

     "[.?!][]\"')]*\\($\\|\t\\| \\)[ \t\n]*"

同時に、変数`sentence-end-double-space'には`nil'を設定して、詰め込みコ
マンドにも、文末には空白が1個だけあり、また、文末には空白を1個だけ追加
することを指示します。ただし、このように設定すると、文末のピリオドと省
略のピリオドとを区別できなくなることに注意してください。


File: emacs-ja  Node: Sentences-Footnotes, Up: Sentences

(1) 【訳注】言語環境を`Japanese'にすると、変数`sentence-end' は
     "[.?!][]\"')]*\\($\\|\t\\| \\)[ \t\n]*\\|[。？！]"
となっている。追加部分は、日本語の文末に対応する文字集合。



File: emacs-ja, Node: Paragraphs, Next: Pages, Prev: Sentences, Up: Text

段落
====

段落を操作するEmacsコマンドもメタキーです。

`M-{'
     まえの段落の先頭にポイントを後向きに移動する
     （`backward-paragraph'）。
`M-}'
     つぎの段落の末尾にポイントを前向きに移動する
     （`forward-paragraph'）。
`M-h'
     ポイントを含む段落かつぎの段落の周りにポイントとマークを置く
     （`mark-paragraph'）。

`M-{'は、ポイントを含む段落の先頭か、まえの段落の先頭にポイントを移動し
ます。一方、`M-}'は、ポイントを含む段落の末尾か、つぎの段落の末尾にポイ
ントを移動します。段落は、空行やテキスト整形コマンドの行で区切られます
が、それらの行自体は段落には属しません。基本（fundamental）モードでは、
字下げした行も新たな段落の始まりとみなしますが、テキスト（text）モード
ではそうしません。（段落の直前に空行があれば、これらのコマンドはそれら
を段落の先頭として扱う。）

プログラム用のメジャーモードでは、段落は空行で始まり空行で終ります。こ
うしておけば、本来段落を持たないプログラムでも段落操作コマンドが役立ち
ます。

詰め込み接頭辞がある場合には、接頭辞で始まらない行が段落の区切りとなります。
*Note Filling::。

段落を対象に操作したいときには、コマンド`M-h'（`mark-paragraph'）を使っ
て段落を囲むようなリージョンを設定します。したがって、たとえば、`M-h
C-w'とすると、ポイントを含むか直後の段落を削除します。`M-h'コマンドは、
ポイントを含む段落の先頭にポイントを置き、末尾にマークを設定します。暫
定マーク（transient-mark）モードでは、このマークを活性にします。ポイン
トが段落のあいだ（空行や境界）にある場合は、ポイントの直後にある段落の
周りにポイントとマークを設定します。段落の1行目のまえに空行があれば、直
前の空行1行も`M-h'が設定するリージョンに含まれます。

正確な段落の境界は、変数`paragraph-separate'と
`paragraph-start'で定義されます。
`paragraph-start'の値は、
段落を始めたり区切ったりする行に一致する正規表現です。
`paragraph-separate'の値も別の正規表現ですが、
どの段落にも属さない段落を分割する行（たとえば空行）だけに一致するものです。
新たな段落を始めてその段落に属す行は、`paragraph-start'だけに一致して、
`paragraph-separate'に一致してはいけません。
たとえば、基本（fundamental）モードでは、
`paragraph-start'は`"[ \t\n\f]"'であり、
`paragraph-separate'は`"[ \t\f]*$"'です。

通常、ページ境界でも段落が区切られるのが望ましいです。これらの変数のデ
フォルト値は、ページの一般的な区切り文字も認識します。



File: emacs-ja, Node: Pages, Next: Filling, Prev: Paragraphs, Up: Text

ページ
======

ファイルを"ページ送り"文字（ASCIIコードのコントロールL、8進コードの014）
で区切った"ページ"の集まりとして捉えることがよくあります。ファイルを印
刷すると、この文字は改ページを行います。そのため、ファイル内の各ページ
は別々の用紙に印刷されます。ほとんどのEmacsコマンドは、ページを区切る文
字を他の文字と同様に扱いますから、`C-q C-l'でページ送り文字を挿入したり、
DELで削除できます。つまり、ファイルをページに区切るのも区切らないのも自
由です。しかし、ページはファイルを分割する意味ある単位なので、Emacsには、
ページ間の移動やページを対象とするコマンドがあります。

`C-x ['
     まえのページ境界にポイントを移動する（`backward-page'）。
`C-x ]'
     つぎのページ境界にポイントを移動する（`forward-page'）。
`C-x C-p'
     このページ（か別のページ）の周りに、ポイントとマークを置く
     （`mark-page'）。
`C-x l'
     このページの行数を数える（`count-lines-page'）。

`C-x ['（`backward-page'）コマンドは、まえのページ区切り文字の直後にポ
イントを移動します。ポイントがすでにページ区切りの直後にあれば、さらに
まえのページ区切り文字の直後に移動します。数引数は反復回数として扱われ
ます。`C-x ]'（`forward-page'）コマンドは、つぎのページ区切り文字の直後
にポイントを移動します。

`C-x C-p'コマンド（`mark-page'）は、ページの先頭にポイントを置き、末尾
にマークを設定します。末尾にあるページ区切り文字は含まれます（マークは
ページ区切り文字の直後にある）。先頭にあるページ区切り文字は除外されま
す（ポイントはページ区切り文字の直後にある）。`C-x C-p C-w'は、ページ全
体をキルして別の場所に移動するのに便利な方法です。`C-x ['や`C-x ]'で別
のページ区切り位置に移動してからキルしたページをヤンクすれば、すべての
ページが適切に区切られた状態が維持されます。`C-x C-p'が末尾のページ区切
り文字だけを含める理由は、これを保証するためです。

`C-x C-p'への数引数は、現在のページを基準にしてポイントの移動先のページ
を指定します。0は現在のページを意味します。1はつぎのページ、-1はまえの
ページを意味します。

`C-x l'コマンド（`count-lines-page'）は、ページをどこで2つに分割するか
を決めるのに便利です。現在のページについて、総行数、現在行のまえにある
行数とうしろにある行数をつぎのようにエコー領域に表示します。

     Page has 96 lines (72+25)

この例で、総行数が1だけ少ないことに注意してください。ポイントが行頭にな
いとつねにこうなります。

変数`page-delimiter'はページの始まりを制御します。この変数の値は、ペー
ジを区切る行の先頭に一致する正規表現です。この変数の通常の値は`"^\f"'で、
行頭のページ送り文字に一致します。



File: emacs-ja, Node: Filling, Next: Case, Prev: Pages, Up: Text

テキストの詰め込み
==================

テキストの"詰め込み"（filling）とは、指定した幅に納まるようにテキストを
行に分割することです。Emacsには、詰め込む方法が2つあります。自動詰め込
み（auto-fill）モードでは、自己挿入文字でテキストを挿入すると同時に詰め
込みを行います。あるいは、詰め込まずにテキストを編集しているときには、
陽に詰め込みコマンドを使います。整形済みテキストを編集しているときは、
テキストの各部分ごとに詰め込みのスタイルを指定できます（*Note
Formatted Text::）。

* Menu:

* Auto Fill::	        Auto Fill mode breaks long lines automatically.
* Fill Commands::       Commands to refill paragraphs and center lines.
* Fill Prefix::	        Filling paragraphs that are indented
                          or in a comment, etc.
* Adaptive Fill::       How Emacs can determine the fill prefix automatically.



File: emacs-ja, Node: Auto Fill, Next: Fill Commands, Prev: Filling, Up: Filling

自動詰め込みモード（auto-fillモード）
-------------------------------------

"自動詰め込み"（auto-fill）モードはマイナモードで、
行が長くなりすぎると自動的に分割します。
SPCやRETを打鍵したときだけ、行を分割します。

`M-x auto-fill-mode'
     自動詰め込み（auto-fill）モードをオンにしたりオフにする。
`SPC'
`RET'
     自動詰め込み（auto-fill）モードでは、適切な場合には行を分割する。

`M-x auto-fill-mode'は、
自動詰め込み（auto-fill）モードがオフならばオンにし、
オンならばオフにします。
正の数引数を指定すると自動詰め込み（auto-fill）モードをつねにオンにしますが、
負の引数を指定するとつねにオフにします。
モード行の括弧の中に`Fill'と表示されていれば、
このモードはオンになっています。
自動詰め込み（auto-fill）モードは、
各バッファごとにオン／オフできるマイナモードです。
*Note Minor Modes::。

自動詰め込み（auto-fill）モードでは、
行が決められた幅より長くなると、自動的に空白の位置で行を分割します。
行の分割と再配置は、SPCかRETを打鍵したときだけ行われます。
行を分割せずに空白や改行を挿入するには、
`C-q SPC'や`C-q C-j'と打鍵します
（改行はまさにコントロールJであることを思い出してほしい）。
`C-o'も行を分割せずに改行を挿入します。

自動詰め込み（auto-fill）モードは、TABで新たな行を字下げするので、プロ
グラム言語用のモードと組み合わせてもうまく動作します。コメントで終わる
行が長くなりすぎた場合には、コメント内のテキストを2つのコメント行に分割
します。始めの行の末尾とつぎの行の行頭に新たにコメントの区切り文字列を
挿入して、2つの独立したコメント行にすることもできます。この付加機能は、
変数`comment-multi-line'で制御します（*Note Comments::）。

適応型詰め込み（後述）は、明示した詰め込みコマンドのみならず、自動詰め
込みに対しても有効に働きます。これは、段落の先頭行あるいは第2行目から、
自動的に詰め込み接頭辞を切り出します。

自動詰め込み（auto-fill）モードは、段落全体を詰め直すことはしません。行
を分割できても、併合はできません。そのため、段落の途中を編集すると、必
ずしも段落を正しく詰め込めません。段落をふたたび適切に詰め込まれた状態
にするもっとも簡単な方法は、明示的に詰め込みコマンドを使用することです。
*Note Fill Commands::。

多くのユーザーは自動詰め込み（auto-fill）モードを好み、
あらゆるテキストファイルの編集に使用しようとします。
初期化ファイルの節では、こうする方法を説明します。
*Note Init File::。



File: emacs-ja, Node: Fill Commands, Next: Fill Prefix, Prev: Auto Fill, Up: Filling

明示的な詰め込みコマンド
------------------------

`M-q'
     現在の段落を詰め込む（`fill-paragraph'）。
`C-x f'
     詰め込み桁を設定する（`set-fill-column'）。
`M-x fill-region'
     リージョン内の各段落を詰め込む（`fill-region'）。
`M-x fill-region-as-paragraph'
     リージョン全体を1つの段落とみなして詰め込む。
`M-s'
     行を中央に揃える。

段落を詰め直すには、コマンド`M-q'（`fill-paragraph'）を使います。ポイン
トを含む段落、あるいは、ポイントが段落のあいだにある場合には直後の段落
を操作します。改行をすべて取り除いてから、必要な箇所に新たに改行を挿入
することで段落を詰め直します。

いくつもの段落を詰め直すには、`M-x fill-region'を使います。これは、リー
ジョンを段落に分けてから、各段落を詰め込みます。

`M-q'と`fill-region'は、`M-h'と同じ基準で段落の境界を探します（*Note
Paragraphs::）。段落の大きさを制御するには、`M-x
fill-region-as-paragraph'を使います。これは、ポイントとマークのあいだに
あるものすべてを詰め直します。このコマンドはリージョン内の空行をすべて
削除して、分かれていたテキストの塊を1つの塊にまとめ上げます。

`M-q'に数引数を指定すると、テキストの詰め込みだけでなく、テキストの"幅
揃え"（justify）も行います。つまり、余分に空白を挿入して、行の右端が詰
め込み桁に一致するようにします。余分な空白を取り除くには、引数を指定し
ないで`M-q'を使います。（`fill-region'も同様。）幅揃えを制御して別の詰
め込みスタイルを選択する別の方法は、テキスト属性`justification'を使うこ
とです。これに関しては、*Note Format Justification::を参照してください。

コマンド`M-s'（`center-line'）は、詰め込み桁までの範囲内で現在行を中央
に揃えます。引数Nを指定すると、現在行を含めN行をそれぞれ独立に中央に揃
えてから、揃えた行のつぎにポイントを移動します。

詰め込むときの行の最大幅は、変数`fill-column'に入っています。
`fill-column'の値を変更すると、カレントバッファにローカルな変数になりま
す。それまではデフォルト値が有効です。デフォルト値は始めは70です。
*Note Locals::。`fill-column'を設定するもっとも簡単な方法は、コマンド
`C-x f'（`set-fill-column'）を使うことです。このコマンドに数引数を指定
すると、その値を新たな詰め込み桁として使います。`C-u'だけを引数に指定す
ると、ポイントの現在の水平位置を`fill-column'に設定します。

Emacsコマンドは通常、ピリオドの直後に空白が2個あるか改行があれば文末と
して扱います。ピリオドの直後に空白が1個だけでは、文末ではなく省略とみな
します。ピリオドのこれら2つの用法の違いを保存するために、ピリオドの直後
に空白が1個だけの箇所では詰め込みコマンドは行を分割しません。

変数`sentence-end-double-space'が`nil'ならば、
詰め込みコマンドは、文末には空白が1個だけあると仮定し、かつ、
文末には空白を1個だけ残します。
普通、この変数の値は`t'なので、
上述のように空白が2個ある場合だけを文末として扱います。
*Note Sentences::。

`colon-double-space'が`nil'以外ならば、詰め込みコマンドはコロンのうしろ
に空白を2個置きます。



File: emacs-ja, Node: Fill Prefix, Next: Adaptive Fill, Prev: Fill Commands, Up: Filling

詰め込み接頭辞
--------------

各行が（段落を字下げする数個の空白などの）特別の印で始まっている段落を
詰め込むには、"詰め込み接頭辞"（fill prefix）の機能を使えます。詰め込み
接頭辞は文字列であり、Emacsはすべての行がその文字列で始まると仮定します
が、詰め込み接頭辞自体は詰め込みの対象ではありません。明示的に詰め込み
接頭辞を指定できますが、Emacsが詰め込み接頭辞を自動的に推測することもで
きます（*Note Adaptive Fill::）。

`C-x .'
     詰め込み接頭辞を設定する（`set-fill-prefix'）。
`M-q'
     現在の詰め込み接頭辞を使って、段落を詰め込む（`fill-paragraph'）。
`M-x fill-individual-paragraphs'
     字下げ幅の変化を新たな段落の始まりとみなして、リージョン内を詰め込
     む。
`M-x fill-nonuniform-paragraphs'
     段落を分割する行だけを新たな段落の始まりとみなして、リージョン内を
     詰め込む。

詰め込み接頭辞を指定するには、
目的の接頭辞で始まっている行に移動して接頭辞の直後にポイントを置いてから、
コマンド`C-x .'（`set-fill-prefix'）を実行します。
`C-x'のあとはピリオドです。
詰め込み接頭辞の使用をやめるには、空の接頭辞を設定します。
つまり、行頭にポイントを置いてから`C-x .'と打ちます。

詰め込み接頭辞が設定されている場合、詰め込みコマンドは処理に先だって各
行から詰め込み接頭辞を取り除き、詰め込みを行ったあとに各行に挿入します。
自動詰め込み（auto-fill）モードでも、新たに行を作成するときに自動的に詰
め込み接頭辞を挿入します。行頭で`C-o'コマンド（*Note Blank Lines::）を
使用すると、新たに作成する行にも詰め込み接頭辞を挿入します。逆に、コマ
ンド`M-^'は、削除する改行の直後に詰め込み接頭辞があると接頭辞も削除しま
す（*Note Indentation::）。

たとえば、`fill-column'が40で詰め込み接頭辞が`;; 'のときに、つぎのテキ
ストで`M-q'を実行します。

     ;; This is an
     ;; example of a paragraph
     ;; inside a Lisp-style comment.

結果はつぎのようになります。

     ;; This is an example of a paragraph
     ;; inside a Lisp-style comment.

`M-q'および段落コマンドは、詰め込み接頭辞で始まらない行を段落の始まりと
みなします。これにより、ぶら下がり字下げ（先頭行を除いてすべての行が字
下げ）された段落も正しく詰め込みます。空行や接頭辞を取りさると字下げし
た行になる行も、段落の区切りや始まりとみなします。これによって、各行に
コメント区切りがある複数段落のコメントを書いているときにも、望みどおり
の結果を得られます。

各段落に対して自動的に詰め込み接頭辞を設定するには、`M-x
fill-individual-paragraphs'を使います。このコマンドは、字下げ幅の変化を
新たな段落の始まりとみなして、リージョンを段落に分割したあと、各段落を
詰め込みます。つまり、1つの『段落』内の行はどれも同じ字下げ幅です。字下
げ幅が、段落に対する詰め込み接頭辞として働きます。

`M-x fill-nonuniform-paragraphs'も同様なコマンドですが、リージョンを段
落に分割する方法が異なります。このコマンドは、（変数
`paragraph-separate'で定義される）段落区切り行だけを新たな段落の始まり
とみなします。つまり、各段落の行はさまざまに字下げされているかもしれな
いので、その中の最少の字下げを詰め込み接頭辞として使用するわけです。段
落の最初の行の字下げが残りの行に比べて多くても少なくても、正しい詰め込
み結果を得られます。

詰め込み接頭辞は変数`fill-prefix'に格納されます。
この値は文字列であるか、詰め込み接頭辞が設定されていなければ`nil'です。
この変数を変更してもカレントバッファだけに影響しますが、
デフォルト値を変更することもできます。
*Note Locals::。

テキスト属性`indentation'は、
段落に与える字下げ幅を調整する別の方法です。
*Note Format Indentation::。



File: emacs-ja, Node: Adaptive Fill, Prev: Fill Prefix, Up: Filling

適応型詰め込み
--------------

詰め込みコマンド自身が、段落に対する適切な詰め込み接頭辞を推測できる状
況もあります。段落のすべての行の先頭に白文字やある種の句読点文字が使わ
れている場合です。

段落が2行以上から成る場合、段落の2行目から詰め込み接頭辞を切り出します
が、1行目にもそれが現れるときに限ります。

段落が1行だけの場合には、その行から詰め込み接頭辞を切り出す*かもしれま
せん* (1) (*Note Adaptive Fill-Footnotes::)。こういった状況では、つぎの
ような3つの合理的な挙動が考えられるので、接頭辞の決定は複雑です。


   * 最初の行の接頭辞を段落のすべての行に用いる。

   * 1行目の接頭辞に続くテキストの直下に並ぶように後続の行を白文字で字
     下げするが、1行目から接頭辞をコピーしない。

   * 2行目以降には何も特別なことは行わない。

これら3つの整形スタイルは、いずれも一般的に使用されます。そこで、詰め込
みコマンドは、現れた接頭辞とそのときのメジャーモードに基づいて、ユーザー
が望むスタイルを決定しようとします。判断基準はつぎのとおりです。

1行目でみつけた接頭辞が`adaptive-fill-first-line-regexp'に一致するか、
（メジャーモードに依存する）コメント開始文字列のようであれば、みつけた
接頭辞を段落の詰め込みに用います。ただし、その接頭辞が後続の行に対して
段落の始まりにならない場合に限ります。

さもなければ、みつけた接頭辞を相当分の空白に変換して、それらの空白を段
落の2行目以降の詰め込み接頭辞として使います。ただし、それらの空白が後続
の行に対して段落の始まりにならない場合に限ります。

テキスト（text）モード、および、空行やページ区切りだけが段落を区切るモー
ドでは、適応型詰め込みによって選ばれた接頭辞が段落の始まりになることは
けっしてありませんから、その接頭辞を段落の詰め込みに使用することができ
ます。

変数`adaptive-fill-regexp'で、行頭のどんな文字列を詰め込み接頭辞として
使えるかを決定します。この変数の正規表現に一致する行頭の文字列を接頭辞
とします。変数`adaptive-fill-mode'に`nil'を設定すると、詰め込み接頭辞を
自動的には切り出しません。

変数`adaptive-fill-function'に関数を設定すると、詰め込み接頭辞を自動的
に切り出すためのより複雑な方法を指定できます。この関数は行の左端の直後
にポイントを置いて呼び出されます。その行から類推される適切な詰め込み接
頭辞を返さなくてはいけません。その行に詰め込み接頭辞がなさそうであれば
`nil'を返します。


File: emacs-ja  Node: Adaptive Fill-Footnotes, Up: Adaptive Fill

(1) 【訳注】段落に1行しかなければ、詰め込み接頭辞を切り出す必要はないと
思うかもしれないが、たとえば、その行が詰め込み桁より長かったり、新たな
入力によって複数行の段落になったときのことを考えてみてほしい。



File: emacs-ja, Node: Case, Next: Text Mode, Prev: Filling, Up: Text

大文字小文字変換コマンド
========================

Emacsには、単語や任意の長さのテキストを大文字あるいは小文字に変換するコ
マンドがあります。

`M-l'
     後続の単語を小文字に変換する（`downcase-word'）。
`M-u'
     後続の単語を大文字に変換する（`upcase-word'）。
`M-c'
     後続の単語の1文字目だけを大文字にする（`capitalize-word'）。
`C-x C-l'
     リージョン内のテキストを小文字に変換する（`downcase-region'）。
`C-x C-u'
     リージョン内のテキストを大文字に変換する（`upcase-region'）。

単語変換コマンドはたいへん便利です。`M-l'（`downcase-word'）はポイント
の直後の単語を小文字に変換し、単語の末尾にポイントを移動します。したがっ
て、`M-l'を繰り返すと、連続した単語を変換できます。
`M-u'（`upcase-word'）は単語を大文字に変換し、`M-c'（`capitalize-word'）
は単語の1文字目を大文字して残りを小文字に変換します。これらのコマンドに
引数を指定すると、一度に数単語を変換できます。これらのコマンドは、大文
字だけの大量のテキストを大文字小文字が混在するように変換するときに、特
に威力を発揮します。というのは、必要に応じて`M-l'、`M-u'、`M-c'を使い分
けて移動したり、`M-f'で変換せずに単語を飛び越えられるからです。

負の引数を指定すると、ポイントの直前にある数個の単語を変換しますが、ポ
イントは移動しません。これは、大文字小文字をまちがえて単語を入力した直
後には便利です。大文字小文字変換コマンドを打ってからすぐに入力を再開で
きます。

単語の途中で大文字小文字変換コマンドを実行すると、ポイントのうしろにあ
る部分だけを変換します。これは`M-d'（`kill-word'）のふるまいと同じです。
また、負の引数を指定すると、ポイントよりまえの部分を変換します。

他の大文字小文字変換コマンドは、`C-x C-u'（`upcase-region'）と`C-x
C-l'（`downcase-region'）です。これらは、リージョン内のテキストを指定ど
おりに変換します。ポイントもマークも移動しません。

リージョンに対する大文字小文字変換コマンドである
`upcase-region'と`downcase-region'は、
通常、使用禁止になっています。
つまり、これらのコマンドを使おうとすると、最初に確認を求めてきます。
確認するときにコマンドを使用可にしておけば、つぎからは確認を求めてきません。
*Note Disabling::。



File: emacs-ja, Node: Text Mode, Next: Outline Mode, Prev: Case, Up: Text

テキストモード（textモード）
============================

自然言語テキストのファイルを編集するときには、基本（fundamental）モード
ではなくテキスト（text）モードを使ったほうが便利です。テキスト（text）
モードに入るには`M-x text-mode'と打ちます。

テキスト（text）モードでは、空行とページ区切りだけが段落の区切りです。
その結果、段落を字下げできて、
適応型詰め込みでは段落の詰め込みに使用する字下げを決定できます。
*Note Adaptive Fill::。

テキスト（text）モードでは、TABは`indent-relative'（*Note
Indentation::）を実行するように定義してあるので、先行する行と同じように
字下げするのに便利です。先行する行が字下げされてなければ、
`indent-relative'は`tab-to-tab-stop'を実行します。これは、ユーザーが設
定したEmacsのタブストップを使います（*Note Tab Stops::）。

テキスト（text）モードでは、コメントに関する機能は、陽に起動した場合を
除いてオフです。ピリオドは単語の一部ではなく、一方、アポストロフ、バッ
クスペース、下線は単語の一部である、となるように構文テーブルを変更しま
す。

段落の最初の行を字下げするのであれば、テキスト（text）モードではなく段
落字下げ型テキスト（paragraph-indent-text）モードを使うべきです。このモー
ドでは、段落のあいだに空行を設ける必要はありません。というのは、最初の
行の字下げで、段落の始まりがわかるからです。ただし、すべての行が字下げ
されている段落は扱えません。このモードに入るには、`M-x
paragraph-indent-text-mode'を使います。

テキスト（text）モード、および、
テキスト（text）モードに基づくすべてのモードでは、
`M-TAB'をコマンド`ispell-complete-word'として定義します。
このコマンドは、ポイントの直前の部分的な単語を綴り辞書を用いて補完します。
*Note Spelling::。

テキスト（text）モードに入ると、フック`text-mode-hook'を実行します。
テキスト（text）モードに関連する他のモードも、このフックに続けて
各モード専用のフックを実行します。
つまり、段落字下げ型テキスト（paragraph-indent-text）モード、
nroffモード、TeXモード、アウトライン（outline）モード、
メイル（mail）モードがそうです。
`text-mode-hook'に登録されたフック関数では、
`major-mode'の値を調べれば実際にどのモードに入ったかわかります。
*Note Hooks::。

Emacsには、綺麗な印刷出力を得るためにテキスト清書系に渡すテキストを編集
するためのモードが他に2つあります。nroff入力の編集については、*Note
Nroff Mode::。TeX入力の変数については、*Note TeX Mode::。

別のモードは、アウトラインの編集に使います。
このモードは、さまざまなレベルの詳しさでテキストを眺めることができます。
アウトラインの見出しだけを見たり、見出しとテキストを同時に見たりできます。
低いレベルの見出しの一部を隠して、
より高いレベルの構造を際だたせることもできます。
*Note Outline Mode::。



File: emacs-ja, Node: Outline Mode, Next: TeX Mode, Prev: Text Mode, Up: Text

アウトラインモード（outlineモード）
===================================

アウトライン（outline）モードはテキスト（text）モードにたいへんよく似た
メジャーモードですが、アウトライン構造を持つテキストの編集用です。アウ
トライン構造を把握できるようにテキストの一部を一時的に不可視にできます。
カレントバッファのメジャーモードをアウトライン（outline）モードに切り替
えるには、`M-x outline-mode'と打ちます。

アウトライン（outline）モードで行を不可視にすると、その行は画面上に表示
されません。画面上では、不可視にした行が削除されたかのように見えますが、
それに先行する可視な行の末尾に省略記号（ピリオドが3つ...）が表示されま
す（何行不可視にしていても、省略記号は1つだけ）。

`C-n'や`C-p'のような行を対象とした編集コマンドは、不可視にした行のテキ
ストを、先行する可視な行の一部であるかのように扱います。改行も含めて可
視な行全体をキルすると、後続の不可視な行も一緒にキルします。

アウトラインマイナ（outline-minor）モードは、メジャーモードであるアウト
ライン（outline）モードと同じコマンドを提供しますが、他のメジャーモード
と一緒に使用できます。カレントバッファでアウトラインマイナ
（outline-minor）モードをオンにするには、`M-x outline-minor-mode'と打ち
ます。`mode: outline-minor'といった形のファイルにローカルな変数で、テキ
ストファイルにアウトラインマイナ（outline-minor）モードを指定することも
できます（*Note File Variables::）。

メジャーモードであるアウトライン（outline）モードでは、プレフィックス
`C-c'に特別なキーバインディングを設定しています。アウトラインマイナ
（outline-minor）モードでは、`C-c @'をプレフィックスとして同様のバイン
ディングがあります。これは、一緒に用いるメジャーモードの特別なコマンド
との衝突を減らすための措置です。（変数`outline-minor-mode-prefix'で、実
際に使用するプレフィックスを制御する。）

アウトライン（outline）モードに入ると、フック`text-mode-hook'に続けてフッ
ク`outline-mode-hook'を実行します（*Note Hooks::）。

* Menu:

* Format: Outline Format.	   What the text of an outline looks like.
* Motion: Outline Motion.	   Special commands for moving through
                                     outlines.
* Visibility: Outline Visibility.  Commands to control what is visible.
* Views: Outline Views.            Outlines and multiple views.



File: emacs-ja, Node: Outline Format, Next: Outline Motion, Prev: Outline Mode, Up: Outline Mode

アウトラインの形式
------------------

アウトライン（outline）モードは、バッファの中には2種類の行、つまり、"見
出し行"（heading lines）、"本体行"（body lines）があると仮定します。見
出し行は、アウトラインのトピックを表していて、1つ以上の星印で始まります。
星印の個数は、アウトライン構造における見出しの深さを表します。つまり、
星印1つの見出し行は主要なトピックを表します。この行とつぎの星印1個の行
のあいだにある星印2個の見出し行は、この行の下位トピックです。星印がいく
つであってもこのような関係が成り立ちます。見出し行以外は本体行です。こ
れらは直前の見出し行に属します。以下に例を示します。

     * Food
     This is the body,
     which says something about the topic of food.

     ** Delicious Food
     This is the body of the second-level header.

     ** Distasteful Food
     This could have
     a body too, with
     several lines.

     *** Dormitory Food

     * Shelter
     Another first-level topic with its header line.

見出し行とそれに続く本体行をまとめて"項目"（entry）と呼びます。また、見
出し行と、それに続くさらに深いレベルの見出し行とそれらの本体行をまとめ
て"部分木"（subtree）と呼びます。

変数`outline-regexp'に値を設定して、見出し行を判定する基準をカスタマイ
ズできます。この正規表現に行頭が一致する行を見出し行とみなします。（左
端からではなく）行の途中で一致するものは、無視します。一致したテキスト
の長さによって、見出しのレベルを決定します。一致したテキストが長いほど
レベルが深くなります。したがって、たとえば、清書系に章や節を分ける
`@chapter'、`@section'、`@subsection'といったコマンドがある場合、これら
の行を見出しとして扱えばよいのですが、それには`outline-regexp'に
`"@chap\\|@\\(sub\\)*section"'と設定します。これには、ちょっとしたトリッ
クがあります。2つの単語、`chapter'と`section'は同じ長さですが、正規表現
では、`chap'だけに一致するように定義することで、章見出しに一致するテキ
ストの長さのほうを短くできます。これによって、アウトライン（outline）モー
ドは、章（chapter）の中に節（section）が含まれるとわかるのです。他のコ
マンドが`@chap'で始まらない限り、この設定は有効です。

変数`outline-level'を設定すると、見出し行のレベル計算方法を変更できます。
`outline-level'の値は、引数を取らない、現在の見出しのレベルを返す関数で
ある必要があります。Cモード、nroffモード、Emacs Lispモードといったメ
ジャーモードのいくつかでは、アウトラインマイナ（outline-minor）モードが
有効に働くように、この変数を設定します。



File: emacs-ja, Node: Outline Motion, Next: Outline Visibility, Prev: Outline Format, Up: Outline Mode

アウトライン上での移動コマンド
------------------------------

アウトライン（outline）モードには、前後の見出し行に移動する特別なコマン
ドがあります。

`C-c C-n'
     つぎの可視な見出し行にポイントを移動する
     （`outline-next-visible-heading'）。
`C-c C-p'
     まえの可視な見出し行にポイントを移動する
     （`outline-previous-visible-heading'）。
`C-c C-f'
     ポイント位置と同じレベルのつぎの可視な見出し行にポイントを移動する
     （`outline-forward-same-level'）。
`C-c C-b'
     ポイント位置と同じレベルのまえの可視な見出し行にポイントを移動する
     （`outline-backward-same-level'）。
`C-c C-u'
     より浅い（より多くの項目を含む）レベルで、可視な見出し行にポイント
     を移動する（`outline-up-heading'）。

`C-c C-n'（`outline-next-visible-heading'）は、つぎの見出し行にポイント
を移動します。`C-c C-p'（`outline-previous-visible-heading'）も同様です
が、逆向きにポイントを移動します。どちらのコマンドも、数引数を反復回数
として受け取ります。コマンドの名前は、不可視な見出し行を飛び越えること
を強調していますが、これは何も特別な機能ではありません。行を探すような
すべての編集コマンドは、不可視な行を自動的に無視します。

もっと強力な移動コマンドは、見出しのレベル構造を把握して移動を行うもの
です。`C-c C-f'（`outline-forward-same-level'）と`C-c
C-b'（`outline-backward-same-level'）は、アウトライン構造中で同じレベル
にある別の見出し行にポイントを移動します。`C-c
C-u'（`outline-up-heading'）は、より浅いレベルの見出し行へ戻るようにポ
イントを移動します。



File: emacs-ja, Node: Outline Visibility, Next: Outline Views, Prev: Outline Motion, Up: Outline Mode

アウトラインの可視／不可視制御コマンド
--------------------------------------

アウトライン（outline）モードの特別なコマンドとして、行を可視／不可視に
するものもあります。これらのコマンドの名前は、すべて`hide'あるいは
`show'で始まります。これらのほとんどは、逆の機能のコマンドと対になって
います。これらのコマンドはアンドゥ可能ではありませんが、実行直後ならば
戻すことはできます。行を可視／不可視にするのは、アンドゥ機構に単純に記
録するのではありません。

`C-c C-t'
     バッファ中の本体行をすべて不可視にする（`hide-body'）。
`C-c C-a'
     バッファ中のすべての行を可視にする（`show-all'）。
`C-c C-d'
     ポイント位置の見出し行を除いて、その下位レベルのすべてを不可視にす
     る（`hide-subtree'）。
`C-c C-s'
     ポイント位置の見出し行、本体、下位の見出し／本体、すべてを可視にす
     る（`show-subtree'）。
`C-c C-l'
     ポイント位置の見出し行の本体と下位の見出し行のすべての本体を不可視
     にする（`hide-leaves'）。
`C-c C-k'
     ポイント位置の見出し行の下位の見出し行をすべて可視にする
     （`show-branches'）。
`C-c C-i'
     ポイント位置の見出し行の直下（1レベル深い）の下位見出しを可視にす
     る（`show-children'）。
`C-c C-c'
     ポイント位置の見出し行の本体を不可視にする（`hide-entry'）。
`C-c C-e'
     ポイント位置の見出し行の本体を可視にする（`show-entry'）。
`C-c C-q'
     最上位のNレベルまでを除き、すべてを不可視にする
     （`hide-sublevels'）。
`C-c C-o'
     ポイント位置の見出し行や本体、および、そこから最上位レベルに至るま
     でに通過する見出し行を除き、すべて不可視にする（`hide-other'）。

`C-c C-c'（`hide-entry'）と`C-c C-e'（`show-entry'）の2つのコマンドは、
正反対の機能を持っています。これらは、見出し行にポイントがある場合 (1)
(*Note Outline Visibility-Footnotes::) に、その本体のみに作用します。下
位見出しとその本体は影響を受けません。

もっと強力で機能が正反対のコマンドは、`C-c C-d'（`hide-subtree'）と
`C-c C-s'（`show-subtree'）です。どちらも見出し行にポイントがあるとき
(2) (*Note Outline Visibility-Footnotes::) に使い、見出しの"部分木"内の
すべての行つまり、本体、直接／間接に関わらずあらゆる下位の見出しとその
本体、に作用します。つまり、部分木には、その見出し行に続くつぎの同レベ
ルか上位レベルの見出し行の直前までが含まれます。

可視な部分木と、すべて不可視な部分木の中間的な状態には、
本体は不可視で下位の見出し行はすべて可視といったものも存在します。
この状態を作り出すコマンドは2つあり、
本体を不可視にするか、下位見出しを可視にするかです。
これらは、`C-c C-l'（`hide-leaves'）と
`C-c C-k'（`show-branches'）です。

`C-c C-i'（`show-children'）は、`show-branches'より少し弱いコマンドです。
これは、直下の、つまり1レベル深い見出し行だけを可視にします。より深いレ
ベルの見出しは不可視ならば不可視のままです。

ファイル全体に効果がおよぶ2つのコマンドがあります。`C-c
C-t'（`hide-entry'）は本体行をすべて不可視にするので、アウトライン構造
だけを眺めることができます。`C-c C-a'（`show-all'）は、すべての行を可視
にします。`C-c C-a'は本体行以外にも作用しますが、これらのコマンドは正反
対の機能の対と考えることができます。

コマンド`C-c C-q'（`hide-sublevels'）は、最上位レベルの見出し以外をすべ
て不可視にします。数引数Nを指定すると、最上位からNレベルまでの見出し行
を除いたすべてを不可視にします。

コマンド`C-c C-o'（`hide-other'）は、ポイント位置の見出しあるいは本体、
その親（アウトライン構造においてポイント位置から最上位レベルまで至る見
出し）を除いたすべてを不可視にします。

変数`selective-display-ellipses'に`nil'を設定すると、可視な行の末尾に現
れる省略記号を消せます。そうすると、不可視な行の存在を示すものは何もな
くなります。

インクリメンタルサーチでアウトライン（outline）モードが不可視にしている
テキストを探しだすと、バッファのその部分は可視になります。その箇所で探
索から抜けると、テキストは可視のまま (3) (*Note Outline
Visibility-Footnotes::)になります。


