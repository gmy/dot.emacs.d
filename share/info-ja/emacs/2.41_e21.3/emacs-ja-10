Info file: emacs-ja,    -*-Text-*-
produced by `texinfo-format-buffer'
from file `emacs.texi'
using `texinfmt.el' version 2.41 of  1 Mar 2005.

INFO-DIR-SECTION Emacs
START-INFO-DIR-ENTRY
* Emacs-ja: (emacs-ja).	            Emacs21.3日本語マニュアル.
END-INFO-DIR-ENTRY








File: emacs-ja, Node: Maintaining, Next: Abbrevs, Prev: Building, Up: Top

Maintaining Programs
********************

  This chapter describes Emacs features for maintaining programs.  The
version control features (*Note Version Control::) are also
particularly useful for this purpose.

* Menu:

* Change Log::                  Maintaining a change history for your program.
* Authors::
* Tags::                        Go direct to any function in your program in one
			  command.  Tags remembers which file it is in.
* Emerge::                      A convenient way of merging two versions of a program.



File: emacs-ja, Node: Change Log, Next: Tags, Prev: Maintaining, Up: Maintaining

変更記録
========

コマンド`C-x 4 a'は、編集中のファイルに対する新たな項目を変更記録ファイ
ルに追加します（`add-change-log-entry-other-window'）。

変更記録ファイルは、プログラムを変更した日付やその理由を時間順に記録し
たもので、個々の変更を記述した項目の並びから成ります。通常は、編集して
いるファイルと同じディレクトリ、あるいは、その親ディレクトリに置いた
`ChangeLog'と呼ばれるファイルに保存されています。1つの`ChangeLog'ファイ
ルで、このファイルを置いたディレクトリやそのサブディレクトリに置いた全
ファイルの変更を記録できます。

変更記録項目は、名前、（`user-mail-address'から得られた）電子メイルアド
レス、現在の日付と時刻から成るヘッダ行で始まります。変更記録内の各行は
ヘッダ行を除いて、つねに空白かタブで始まります。1つの項目は"小項目"から
構成され、各小項目は空白と星印で始まる行で始まります。以下は、1993年5月
付けの2つの項目で、それぞれに2つの小項目があります。

     1993-05-25  Richard Stallman  <rms@gnu.org>

             * man.el: Rename symbols `man-*' to `Man-*'.
             (manual-entry): Make prompt string clearer.

             * simple.el (blink-matching-paren-distance):
             Change default to 12,000.

     1993-05-24  Richard Stallman  <rms@gnu.org>

             * vc.el (minor-mode-map-alist): Don't use it if it's void.
             (vc-cancel-version): Doc fix.

（Emacsの以前の版では、日付の形式が異なる。）

1つの項目で複数の変更を記述できます。各変更について、それぞれの小項目を
用意しなくてはいけません。通常、小項目のあいだには空行がなくてはいけま
せん。小項目が関連している（場所は異なるが同じ変更の一部分の）場合には、
それらのあいだには空行を入れずに一塊にしておきます。上記の2番目の項目に
は、このようにしてまとめた2つの小項目が含まれています。

`C-x 4 a'は、変更記録ファイルを訪問して、最新の項目が今日の日付で当人の
名前のものでなければ、新たに項目を作成します。また、現在のファイルに対
する新たな小項目も作成します。多くの言語に対して、変更された関数名やそ
の他のオブジェクトを推測することもできます。

変更記録ファイルは、変更記録（change-log）モードで訪問します。このメ
ジャーモードでは、（空行で区切らない）ひとまとまりの小項目群を段落とし
て扱い、各項目をページとして扱います。これにより項目の編集が容易になり
ます。`C-j'や自動詰め込みにより、新たな行は直前の行と同様に字下げされま
す。これは項目内容を入力するのに便利です。

プログラムの変更を掌握し、変更記録を維持する他の手段としては、
版管理（バージョンコントロール）システムがあります。
*Note Log Buffer::。



File: emacs-ja, Node: Tags, Next: Emerge, Prev: Change Log, Up: Maintaining

タグテーブル
============

"タグテーブル"とは、複数のファイルで構成されるプログラムが、
どのように各ファイルに分割されているのか記述したものです。
これは、プログラムを構成するファイル名、
そのファイルに入っている関数の名前（または、名前の付いた別の単位）や
ファイル内の位置の一覧です。
こうして関連するファイルをまとめておけば、
全ファイルを対象とした探索や置換をコマンド1つで行えます。
また、関数名とその位置を記録してあるので、
関数がどのファイルに入っているか調べて関数定義をみつけだす
`M-.'のようなコマンドを実現できます。

タグテーブルは、"タグテーブルファイル"と呼ばれるファイルに格納されます。
このファイルの慣習的な名前は`TAGS'です。

タグテーブルの各項目は、タグ名、タグが（暗黙に）定義されているファイル
の名前、そして、ファイル中でタグが定義されている位置を記録しています。

もとのプログラムファイルから、どんな名前がタグテーブルに記録されるかは、
プログラム言語によって異なります。一般的には、すべての関数やサブルーチ
ンを含み、大域変数、データ型、あると便利なその他の情報などを含むことも
あります。記録された個々の名前を"タグ"と呼びます。

* Menu:

* Tag Syntax::		Tag syntax for various types of code and text files.
* Create Tags Table::	Creating a tags table with `etags'.
* Select Tags Table::	How to visit a tags table.
* Find Tag::		Commands to find the definition of a specific tag.
* Tags Search::		Using a tags table for searching and replacing.
* List Tags::		Listing and finding tags defined in a file.



File: emacs-ja, Node: Tag Syntax, Next: Create Tags Table, Prev: Tags, Up: Tags

ソースファイルのタグ構文
------------------------

ここでは、広く一般に使われている言語に対するタグ構文の定義を紹介します。

   * Cのコードでは、関数やtypedefで定義される型はタグであり、`struct'、
     `union'、`enum'の定義もやはりタグである。また、タグテーブルを作成
     するときにオプション`--no-defines'を指定しなければ、`#define'によ
     るマクロ定義や`enum'の定数もタグとして扱う。同様に、大域変数も
     `--no-globals'を指定しない限りタグになる。`--no-globals'と
     `--no-defines'を指定すると、タグテーブルファイルはかなり小さくなる。

   * C++のコードでは、Cのコードのタグ構成要素に加えて、メンバ関数もタグ
     として認識される。`--members'オプションを指定すれば、メンバ変数も
     タグになる。クラス内の変数と関数に対するタグには、それぞれ、
     `CLASS::VARIABLE'、`CLASS::FUNCTION'と名前が付く。

   * Javaのコードでは、C++のタグ構成要素に加えて、
     `extends'と`implements'に現れる名前もタグとして含む。
     クラス内の変数と関数に対するタグには、それぞれ、
     `CLASS.VARIABLE'、
     `CLASS.FUNCTION'と名前が付く。

   * LaTeXのテキストでは、`\chapter'、`\section'、`\subsection'、
     `\subsubsection'、`\eqno'、`\label'、`\ref'、
     `\cite'、`\bibitem'、`\part'、`\appendix'、
     `\entry'、`\index'のコマンドの引数がタグになる。

     その他のLaTeXコマンドでも、`etags'を起動するまえに、環境変数
     `TEXTAGS'にそれらのコマンドを指定しておけばタグの対象になる。この
     環境変数の値は、コマンド名をコロンで区切った並び。たとえば、
     （bourneシェルでは）

          TEXTAGS="def:newcommand:newenvironment"
          export TEXTAGS

     とすると、`\def'、`\newcommand'、`\newenvironment'のコマンドの引数
     もタグの対象になる。

   * Lispコードでは、`defun'で定義した関数、`defvar'や`defconst'で定義
     した変数、および、一般に0桁目から`(def'で始まる任意の式の最初の引
     数がタグ。

   * Schemeコードでは、`def'で定義されるものと、名前が`def'で始まるもの
     がタグに含まれる。また、ファイル内のトップレベルで`set!'を使って値
     が設定される変数もタグ。

他にも以下の言語で使えます。

   * アセンブリコードでは、行の先頭から始まりコロンが続くラベルはタグ。

   * BisonやYaccの入力ファイルでは、各構文規則で定義する非終端記号をタ
     グとする。ファイル内のCコードの部分に対しては、Cのコードとしてタグ
     の解析を行う。

   * Cobolでは、段落名、すなわち、8桁目から始まりピリオドが続く任意の単
     語がタグ。

   * Erlangコードでは、ファイル内で定義された関数、レコード、マクロがタ
     グ。

   * Fortranコードでは、関数、サブルーチン、ブロックデータがタグ。

   * Objective-Cコードでは、クラス、クラスカテゴリ、メソッド、プロトコ
     ルの定義がタグ。

   * Pascalコードでは、関数と手続きがタグ。

   * Perlコードでは、キーワード`sub'で定義される手続きがタグ。

   * Postscriptコードでは、関数（演算子）がタグ。

   * Prologコードでは、左端に現れる名前がタグ。

正規表現に基づいてタグを生成する方法（*Note Create Tags Table::）もある
ので、上記以外の形式や言語を扱うこともできます。



File: emacs-ja, Node: Create Tags Table, Next: Select Tags Table, Prev: Tag Syntax, Up: Tags

タグテーブルの作成
------------------

タグテーブルファイルを作成するには、`etags'プログラムを使います。
`etags'は、数種類の言語について、構文を解析しタグを取り出すことができま
す。*Note Tag Syntax::。つぎのように実行します。

     etags INPUTFILES...

`etags'は指定されたファイルを読み、カレント作業ディレクトリの`TAGS'とい
う名前のファイルにタグテーブルを書き出します。`etags'は、ファイル名とそ
の内容から自動的に使用言語を識別します。後述の`--language=NAME'オプショ
ンで、言語を明示することもできます。

ファイルを変更するなどしてタグテーブルの内容が古くなった場合、テーブル
を更新するには、最初にタグテーブルを作成した手順を繰り返します。頻繁に
更新する必要はありません。

タグテーブルに記録できなかったり、誤ったファイルを記録してしまった場合、
Emacsはタグの定義をみつけることはできません。しかし、（タグの定義を含ん
だファイルを多少編集するなどしたために）タグテーブルに記録された位置が
多少ズレている程度ならば、タグをみつけるのに通常より少し時間がかかるだ
けです。記録された位置が大幅に狂っていたとしても、Emacsはタグをみつける
ことができますが、そのためにファイル全体を調べなくてはなりません。

ですから、新しいタグを定義したとき、タグの定義を別のファイルに移動した
とき、ファイルを相当変更したときには、タグテーブルの更新が必要です。し
かし、ファイルを編集するつどタグテーブルを更新する必要はありませんし、
毎日更新する必要すらないでしょう。

タグテーブルに別のタグテーブルを取り込むこともできます。取り込むタグファ
イル名をオプション`--include=FILE'で指定してタグファイルを作成します。
このように作成したタグファイルには、指定したソースファイルに加えて、取
り込んだタグファイルに記録されていたファイルも含まれます。

`etags'を実行するときに相対ファイル名でソースファイルを指定すると、タグ
ファイルには、タグファイルを書き出したときのディレクトリを基準にしたファ
イル名が記録されます。こうした場合、タグファイルとソースファイルを含ん
だディレクトリ木構造全体を移動することができ、しかも、タグファイルはソー
スファイルを正しく指し続けます。

`etags'の引数として絶対ファイル名を指定すると、タグファイルには絶対ファ
イル名が記録されます。こうした場合、ソースファイルが同じ場所にある限り、
タグファイルを移動してもタグファイルは同じファイルを指し続けます。絶対
ファイル名は、`/'、あるいは、MS-DOSとMS-Windowsでは`DEVICE:/'で始まりま
す。

非常に多数のファイルからタグテーブルを作成する場合、
コマンド行の長さを制限しているシステムもあるので、
ファイル名をコマンドラインで指定するときに問題が起こる可能性があります。
この制限を回避するもっとも単純な方法は、
つぎのように、ファイル名を指定する位置にダッシュを打って、
`etags'に標準入力からファイル名を読み込ませることです。

     find . -name "*.[chCH]" -print | etags -

オプション`--language=NAME'を使えば、
言語を明示的に指定できます。
このオプションはファイル名と混ぜていくつでも使用できます。
それぞれ、あとに続くファイル名に適用されます。
`--language=auto'を指定すると、
`etags'はファイル名とその内容からふたたび使用言語を推測します。
`--language=none'を指定すれば、
言語に依存した処理をいっさい行わないようになります。
すると、`etags'は正規表現による一致だけに
基づいてタグを認識します。
`etags'が知っている言語と、言語を推測するファイル名規則を表示するには、
`etags --help'を指定します。

`--regex'オプションは、正規表現による一致に基づいてタグを認識させる一般
的な方法です。このオプションとファイル名を自由に混ぜて使用できます。各
`--regex'オプションは、それ以前に指定した正規表現に追加され、オプション
のあとにあるファイルに適用されます。オプションの構文はつぎのとおりです。

     --regex=/TAGREGEXP[/NAMEREGEXP]/

ここで、TAGREGEXPは、行に一致させてタグを取り出すために使われます。これ
はつねに位置が固定されています。つまり、`^'が前置されているかのように扱
われます。字下げ分を考慮したければ、正規表現を`[ \t]*'で始めて、行頭の
任意個の空白に一致するようにします。正規表現においては、`\'は直後の文字
をクォートし、`\t'はタブ文字を表します。`etags'では、これら以外にはCで
使われるエスケープシーケンスを扱えないことに注意してください。

`etags'の正規表現の構文は、Emacsのものと同じで、"反復回数演算子
（interval operator）が拡張されています。この演算子は、`grep'や`ed'で使
えるものと同じ動作をします。反復回数演算子の構文は`\{M,N\}'であり、直前
の正規表現のM回以上N回以下の繰り返しに一致します。

TAGREGEXPがタグとして認識したい部分よりも長く一致するようにはしないでく
ださい。TAGREGEXPに一致する部分が必要以上に長くなるのが避けられないなら
ば、タグの範囲を狭めるためにNAMEREGEXPを追加するとよいかもしれません。
正規表現を利用した例をいくつか紹介しましょう。

`-R'オプションは、それまでに`--regex'オプションで定義したすべての正規表
現を削除します。つぎの使用例からもわかるように、オプションのあとに続く
ファイルに適用されます。

     etags --regex=/REG1/ voo.doo --regex=/REG2/ \
         bar.ber -R --lang=lisp los.er

この例では、`etags'は、`voo.doo'と`bar.ber'に対しては、その内容から使用
言語を推定します。さらに、`voo.doo'から余分にタグを認識するためにREG1を
使い、`bar.ber'から余分にタグを認識するためにはREG1とREG2の両方を使いま
す。`los.er'からタグを認識するには、Lispのタグ構文規則だけを使い、正規
表現による一致はいっさい使いません。

別の例を示しましょう。ここでは、シェルが解釈しないように正規表現をクォー
トします。

   * Emacsのソースファイルに含まれる`DEFVAR'マクロをタグとする。

          --regex='/[ \t]*DEFVAR_[A-Z_ \t(]+"\([^"]+\)"/'

   * VHDLファイルからタグを取り出す（この例は本来は単一の長い行だが、印
     刷の関係で分割してある）。

          --language=none
          --regex='/[ \t]*\(ARCHITECTURE\|CONFIGURATION\) +[^ ]* +OF/'
          --regex='/[ \t]*\(ATTRIBUTE\|ENTITY\|FUNCTION\|PACKAGE\
          \( BODY\)?\|PROCEDURE\|PROCESS\|TYPE\)[ \t]+\([^ \t(]+\)/\3/'

   * Tclファイルからタグを取り出す（この例はNAMEREGEXPの使用例でもあ
     る）。

          --lang=none --regex='/proc[ \t]+\([^ \t]+\)/\1/'

他のオプション一覧を表示するには、
`etags --help'を実行してください。



File: emacs-ja, Node: Select Tags Table, Next: Find Tag, Prev: Create Tags Table, Up: Tags

タグテーブルの選択
------------------

Emacsでは、いつでも1つの"選択された"タグテーブルがあり、タグテーブルを
使って動作するコマンドは選択されたタグテーブルを使用します。タグテーブ
ルを選択するには、`M-x visit-tags-table'と打ちます。すると、タグテーブ
ルファイル名を聞いてきます。デフォルトのファイル名は、デフォルトディレ
クトリの`TAGS'です。

このコマンドは、ファイル名を変数`tags-file-name'に格納するだけです。タ
グテーブルを使おうとしない限り、Emacsは実際にはタグテーブルの内容を読み
込みません。`visit-tags-table'を使わずに、自分自身でこの変数にファイル
名を設定してもかまいません。この変数の初期値は`nil'です。これは、タグテー
ブルを使うすべてのコマンドに、使用するタグテーブルファイルを尋ねさせる
ことになります。

すでにタグテーブルを読み込んであるときに`visit-tags-table'を使うと、2つ
の選択肢があります。現在のタグテーブルリストに新たにタグテーブルを追加
するか、タグテーブルリストを新規に始めるかです。タグコマンドは、現在の
リストにあるすべてのタグテーブルを使用します。新たなタグテーブルリスト
を始めると、他のタグテーブルの*かわり*に新たなタグテーブルが使われます。
現在のリストに新たなタグテーブルを追加すると、他のタグテーブルと*ともに
*新たなものも使われます。タグコマンドがタグテーブルリストを走査するとき
には、つねにリストの先頭から始めるわけではありません。現在のファイルを
記録しているタグテーブルがあれば、まずそれから始めてリストの末尾まで進
みます。そして、リストの先頭からリストに含まれるすべてのタグテーブルを
調べ終るまで走査を続けます。

変数`tags-table-list'に文字列のリストを設定すれば、タグテーブルの正確な
リストをあらかじめ指定できます。たとえば、つぎのようにします。

     (setq tags-table-list
           '("~/emacs" "/usr/local/lib/emacs/src"))

この設定例では、タグコマンドは、個人の`~/emacs'ディレクトリと
`/usr/local/lib/emacs/src'ディレクトリの（2つの）`TAGS'ファイルを見にい
きます。上で述べたように、タグファイルを使う順番は、対象としているファ
イルやそのファイルを記述しているタグテーブルに依存します。

`tags-file-name'と`tags-table-list'の両方に値を設定してはいけません。



File: emacs-ja, Node: Find Tag, Next: Tags Search, Prev: Select Tags Table, Up: Tags

タグの探索
----------

タグテーブルで実現されるもっとも重要な機能は、指定したタグの定義を探し
出すことです。

`M-. TAG RET'
     タグTAGの最初の定義を探す（`find-tag'）。
`C-u M-.'
     最後に指定したタグのつぎの定義を探す。
`C-u - M-.'
     まえにみつかったタグに戻る。
`C-M-. PATTERN RET'
     名前がPATTERNに一致するタグを探す（`find-tag-regexp'）。
`C-u C-M-.'
     最後に使用したパターンに一致するつぎのタグを探する。
`C-x 4 . TAG RET'
     タグTAGの最初の定義を探し、別のウィンドウに表示する
     （`find-tag-other-window'）。
`C-x 5 . TAG RET'
     タグTAGの最初の定義を探し、バッファを選択するための新たなフレーム
     を作る。（`find-tag-other-frame'）。
`M-*'
     まえに`M-.'を起動した場所へ戻る。

`M-.'（`find-tag'）は、指定したタグの定義を探すコマンドです。まず、タグ
テーブルの中で文字列としてタグ名を探し、タグテーブルの情報を用いて、定
義されているファイルの名前とファイル内でのおおよその文字位置を求めます。
続いて、`find-tag'はそのソースファイルを訪れて、ポイントをおおよその文
字位置に移動してから、範囲を広げながらタグの定義を探します。

（単にRETと打って）引数を指定しないと、ポイントの直前または周辺にあるS
式をTAG引数として使います。S式に関しては、*Note Lists::。

コマンド`M-.'にタグの名前を完全に与える必要はありません。
その一部分で十分です。
というのは、`M-.'は、部分文字列としてTAGを含む
タグをタグテーブルで探すからです。
もちろん、部分一致よりも全一致のほうが望ましいです。
同じ部分文字列に一致する別のタグを探すには、
`C-u M-.'のように`find-tag'に数引数を指定します。
こうするとタグ名を聞いてきませんが、
最後に使ったものと同じ部分文字列を含む別のタグを
タグテーブルから探します。
もし本物のMETAキーが使えるのであれば、
`C-u M-.'のかわりに`M-0 M-.'と打つほうが簡単でしょう。

バッファの切り替えを伴う他のコマンドと同様に、`find-tag'にも新たなバッ
ファを別のウィンドウに表示したり、新規作成したフレームに表示する変種が
あります。前者は`C-x 4 .'であり、コマンド`find-tag-other-window'を起動
します。後者は`C-x 5 .'であり、`find-tag-other-frame'を起動します。

最近にみつけたタグ位置に戻るには、`C-u - M-.'を使います。より一般的には、
`M-.'に負の数引数を指定します。このコマンドは、別のバッファへも移動しま
す。`C-x 4 .'に負の数引数を指定すると、別のウィンドウでまえのタグ位置に
戻ります。

最近にみつけたタグ位置に戻るだけでなく、
タグを*探したとき*の場所へ戻ることもできます。
それには、コマンド`pop-tag-mark'を起動する`M-*'を使います。
典型的な使い方では、`M-.'で何かの定義を調べてから、
`M-*'でもとの場所に戻ります。

`C-u - M-.'と`M-*'のどちらも、変数`find-tag-marker-ring-length'で指定さ
れる深さまで、辿った経路を引き返せます。

コマンド`C-M-.'（`find-tag-regexp'）は、
指定した正規表現に一致するタグを訪れます。
部分文字列ではなく正規表現に一致するものであることを除けば、
`M-.'と同じです。



File: emacs-ja, Node: Tags Search, Next: List Tags, Prev: Find Tag, Up: Tags

タグテーブルを用いた探索と置換
------------------------------

ここで紹介するコマンドは、選択されたタグテーブルに記録されているすべて
のファイルを1つ1つ訪れては探索を行います。これらのコマンドに対しては、
タグテーブルは探索対象となる一連のファイルを指定するだけです。

`M-x tags-search RET REGEXP RET'
     選択されたタグテーブル内の各ファイルから指定された正規表現を探索す
     る。
`M-x tags-query-replace RET REGEXP RET REPLACEMENT RET'
     選択されたタグテーブル内の各ファイルに対して、
     `query-replace-regexp'を実行する。
`M-,'
     ポイント位置から上記のコマンドのいずれかを再実行する
     （`tags-loop-continue'）。

`M-x tags-search'は、ミニバッファで正規表現を読み取り、選択されたタグテー
ブル内のすべてのファイル1つ1つについて、正規表現に一致する部分を探しま
す。このコマンドは探索しているファイル名を表示するので、進行状況がわか
ります。正規表現に一致する部分がみつかると、`tags-search'はすぐに戻りま
す。

一致する部分をみつけたあとに、残りも探したくなるでしょう。つぎの一致を
探すには、`M-,'（`tags-loop-continue'）と打って、`tags-search'を再開し
ます。これは、カレントバッファの残りを探索してから、タグテーブルの残り
のファイルについても探索します。

`M-x tags-query-replace'は、タグテーブル内のすべてのファイルを対象に、
`query-replace-regexp'を実行します。このコマンドは、通常の`M-x
query-replace-regexp' （問い合わせ型置換）と同じく、探索すべき正規表現
と置換文字列を読み取ります。そして、`M-x tags-search'のように探索を行い、
利用者の入力に応じて一致部分を処理することを繰り返します。問い合わせ型
置換について詳しくは、*Note Replace::。

`M-x tags-query-replace'を一度起動するだけで、タグテーブル内の全ファイ
ルの置換を行うことができます。しかし、一時的に置換作業から抜け出して、
問い合わせ型置換とは関係ないことを行えると便利です。`M-,'と打てば、問い
合わせ型置換を再開できます。このコマンドは、最後に行ったタグの探索コマ
ンドか置換コマンドを再開します。

ここで紹介したコマンドは、`find-tag'系列のコマンドよりも、幅広い探索を
実行します。`find-tag'コマンドは、指定した部分文字列や正規表現に一致す
るタグの定義だけをみつけます。コマンド`tags-search'と
`tags-query-replace'は、通常の探索コマンドや置換コマンドがカレントバッ
ファで行うように、正規表現に一致するあらゆる部分を探し出します。

これらのコマンドは、（Emacsバッファにまだ訪れていないものに対しては）探
索すべきファイル用に一時的なバッファを作成します。一致部分がみつからな
ければバッファはただちに消されますが、みつかれば存続します。

`tags-search'は、`grep'プログラムにたいへんよく似ていると
思われたかもしれません。
Emacsの下位プロセスとして`grep'を実行して、
Emacsに一致した行を1つずつ表示させることもできます。
これは、コンパイルを実行するのと同じように動作します。
`grep'が一致を検出したソース箇所を探すことは、
コンパイルエラーを探すのと同様に動作します。
*Note Compilation::。



File: emacs-ja, Node: List Tags, Prev: Tags Search, Up: Tags

タグテーブルの照会
------------------

`M-x list-tags RET FILE RET'
     プログラムファイルFILEで定義されているタグの一覧を表示する。
`M-x tags-apropos RET REGEXP RET'
     REGEXPに一致するすべてのタグを表示する。

`M-x list-tags'は、選択されたタグテーブルに記載されているファイルのどれ
か1つのファイル名を読み取り、そのファイルで定義されているすべてのタグを
表示します。引数の『ファイル名』は、タグテーブルに記録されたファイル名
と単純に文字列として比較されます。ファイル名というよりは、文字列として
読まれます。したがって、補完やデフォルトはありませんし、タグテーブルに
格納されているとおりに正確にファイル名を入力する必要があります。タグテー
ブル内のファイル名にディレクトリが含まれない限り、ファイル名にもディレ
クトリを含めてはいけません。

`M-x tags-appropos'は、タグに対する`apropos'にあたります （*Note
Apropos::）。このコマンドは、正規表現を読み取り、選択されたタグテーブル
の中から正規表現に一致する項目のタグをすべてみつけだし、そのタグ名を表
示します。

現在のタグテーブルに含まれるタグ名を名前空間として、
バッファ内で補完を行うこともできます。
*Note Symbol Completion::。



File: emacs-ja, Node: Emerge, Prev: Tags, Up: Maintaining

emergeを用いたファイルの併合
============================

ちょっとしたミスで、1つのプログラムから2つの別の版を
作ってしまうこともあります。
この混乱した状態を収拾するには、それらを併合する必要があります。
emergeを使うと、併合作業が容易になります。
手動で比較するコマンドについては、*Note Comparing Files::と
*Note Emerge: (ediff)Emergeを参照してください。

* Menu:

* Overview of Emerge::	How to start Emerge.  Basic concepts.
* Submodes of Emerge::	Fast mode vs. Edit mode.
			  Skip Prefers mode and Auto Advance mode.
* State of Difference::	You do the merge by specifying state A or B
			  for each difference.
* Merge Commands::	Commands for selecting a difference,
			  changing states of differences, etc.
* Exiting Emerge::	What to do when you've finished the merge.
* Combining in Emerge::	    How to keep both alternatives for a difference.
* Fine Points of Emerge::   Misc.



File: emacs-ja, Node: Overview of Emerge, Next: Submodes of Emerge, Prev: Emerge, Up: Emerge

emergeの概要
------------

以下の4つのコマンドのいずれかでemergeを実行します。

`M-x emerge-files'
     指定した2つのファイルを併合する。

`M-x emerge-files-with-ancestor'
     共通の祖先を参照しながら、指定した2つのファイルを併合する。

`M-x emerge-buffers'
     2つのバッファを併合する。

`M-x emerge-buffers-with-ancestor'
     3番目のバッファに入っている共通の祖先を参照しながら、2つのバッファ
     を併合する。

emergeコマンドは、2つのファイル、あるいは、2つのバッファを比較して、比
較結果を3つのバッファ、つまり、各入力テキストに1つずつ（"Aバッファ"と
Bバッファ"）と、併合を実施するバッファ（"併合バッファ"）に表示します。
併合バッファには、比較によって得られる差分だけでなく、併合したテキスト
全体が表示されます。2つの入力テキストが相違している箇所については、どち
らのテキストを併合バッファに含めるか選択できます。

既存のバッファを入力源とするemergeコマンドでは、入力バッファがナロイン
グされていると、バッファの参照可能な部分だけを使います（*Note
Narrowing::）。

併合したい2つのテキストのもとである共通の祖先にあたる版を利用できるとき
には、emergeはそれを使ってどちらの選択肢が正しいのか推測します。一方の
入力と祖先との一致部分がどこかにあれば、もう一方の入力には併合結果に残
すべき意図的な変更がなされていると推測します。共通の祖先のテキストを指
定するには、名前に`with-ancestor'の付いたコマンドを使ってください。これ
らのコマンドは、A版、B版、共通の祖先に対応する3つのファイル名かバッファ
名を読み取ります。

入力を比較してバッファの準備を終えると、つぎは対話的な併合作業が始まり
ます。併合バッファで特別な"併合コマンド"を打って併合作業を制御します。
併合バッファには、単なる差分ではなく併合したテキスト全体が表示されます。
入力テキストの各相違箇所に対して、どちら側を残すか選択したり、両者をも
とにして編集できます。

併合バッファでは、emergeモードと呼ばれる特別なメジャーモードが使われ、
これらを選択するコマンドがあります。もちろん、通常のEmacsコマンドでバッ
ファを編集することもできます。

emergeの注意は、いつでも"注目"相違箇所と呼ばれる相違箇所に向けられてい
ます。3つのバッファ内では、注目相違点はつぎのように印が付けられます。

     vvvvvvvvvvvvvvvvvvvv
     TEXT THAT DIFFERS
     ^^^^^^^^^^^^^^^^^^^^

emergeはすべての相違箇所に順に番号をふります。さらに、モード行にはつね
に注目相違箇所の番号が表示されます。

通常、併合バッファはA版の内容で始まります。しかし、A版の内容が共通の祖
先の内容と一致するときには、併合バッファはB版の内容で始まります。

emergeを終えると、併合バッファにはその時点の併合済みテキストが残ります。
emerge終了時には、`C-x C-w'でファイルに保存できます。`emerge-files'や
`emerge-files-with-ancestor'に数引数を指定すると、ミニバッファで出力ファ
イル名を読み取ります。（どちらの場合でも、これがいちばん最後に聞かれる
ファイル名。）すると、emerge終了時には、併合済みのテキストがその出力ファ
イルに保存されます。

emergeを終えると、通常、emergeコマンドが併合バッファをファイルに保存し
ます。emergeを`C-]'でアボートするとemergeコマンドは併合バッファを保存し
ませんが、必要ならばユーザー自身で保存できます。



File: emacs-ja, Node: Submodes of Emerge, Next: State of Difference, Prev: Overview of Emerge, Up: Emerge

emergeのサブモード
------------------

併合コマンドを指示するためのモードが2つ、つまり、高速モード（Fast mode）
と編集モード（Edit mode）があり、どちらかを選べます。高速モードでは、基
本的な併合コマンドは1文字で表され、通常のEmacsコマンドは禁止されていま
す。併合コマンドだけを使用するのであれば、高速モードが便利です。編集モー
ドでは、すべての併合コマンドはプレフィックス`C-c C-c'で始まり、通常の
Emacsコマンドも使えます。このモードでは、併合バッファを編集できますが、
emergeの処理は遅くなります。

編集モードに切り替えるには`e'を使い、高速モードに切り替えるには`C-c
C-c f'を使います。モード行には、編集モードは`E'、高速モードは`F'と表示
されます。

emergeには、特定の併合コマンドの動作に影響を与えるサブモードがさらに2つ
あります。自動前進（auto-advance）モードと優先箇所スキップ
（skip-prefers）モードです。

自動前進モードがオンであると、コマンド`a'と`b'は、自動的につぎの相違箇
所にポイントを進めます。このモードでは、どちらかの入力だけを選ぶ状況で
ある限り、高速に併合を行えます。モード行には`A'と表示され、自動前進モー
ドであるを示します。

優先箇所スキップモードがオンであると、コマンド`n'と`p'は、A優先／B優先
の状態にある相違箇所をスキップします（*Note State of Difference::）。つ
まり、どちらの版も『正しい』と推定されない相違箇所だけを調べことになり
ます。モード行には`S'と表示され、優先箇所スキップモードであることを示し
ます。

自動前進モードをオン／オフするには、コマンド`s
a'（`emerge-auto-advance-mode'）を使います。優先箇所スキップモードをオ
ン／オフするには、コマンド`s s'（`emerge-skip-prefers-mode'）を使います。
どちらのコマンドも、正の数引数を指定するとオンにし、負あるいは0の数引数
を指定するとオフにし、引数を指定しないとトグル（切り替え）します。



File: emacs-ja, Node: State of Difference, Next: Merge Commands, Prev: Submodes of Emerge, Up: Emerge

相違箇所の状態
--------------

併合バッファ内では、相違箇所は`v'と`^'の文字だけの行に挟まれて示されま
す。各相違箇所は、つぎの7つのいずれかの状態になっています。

状態A
     この相違箇所はA版の内容である。`a'コマンドは必ずこの状態にする。モー
     ド行には`A'と表示される。

状態B
     この相違箇所はB版の内容である。`b'コマンドは必ずこの状態にする。モー
     ド行には`B'と表示される。

デフォルトA
デフォルトB
     まだ決心していないので、『デフォルト』で、相違箇所は状態A（A版の内
     容）か状態B（B版の内容）である。どちらかの選択肢が『優先される』
     （下記参照）場合を除いて、相違箇所はすべてデフォルトAで始まる（つ
     まり、併合バッファの内容はAバッファのコピー）。

     相違箇所を選択すると、その状態は、デフォルトAやデフォルトBから状態
     Aや状態Bに遷移する。つまり、一度でも選択した相違箇所は、デフォルト
     AやデフォルトBの状態であることはなく、これらの状態はけっしてモード
     行には表示されない。

     デフォルトの状態として、コマンド`d a'はデフォルトAを選び、`d b'デ
     フォルトBを選ぶ。これらのコマンドで選んだデフォルトの状態は、一度
     も選択してなく、かつ、どちらの版も優先されない相違箇所に適用される。
     併合作業を先頭から順に行っている場合、最後に選択した相違箇所に続く
     相違箇所群が一度も選択されていないものである。したがって、先頭から
     順に進めるのであれば、`d a'と`d b'を使い分けて、併合バッファのある
     部分ではA版をデフォルトとし、別の部分ではB版をデフォルトとすること
     ができる。

優先A
優先B
     どちらかが"優先され"ているので、相違箇所は状態A（A版の内容）か状態
     B（B版の内容）である。つまり、明示的にはまだ選択していないが、当該
     箇所では、一方の版が共通の祖先に一致するため、他方の版のほうが正し
     く思われるのである。したがって、Aバッファが共通の祖先と一致する箇
     所では、実際に変更されたほうが正しいものである可能性があるので、B
     版が優先される。

     これらの2つの状態は、モード行では`A*'や`B*'と表示される。

混合状態
     `x c'や`x C'コマンドの結果、相違箇所は、状態A（A版の内容）と状態B
     （B版の内容）の混合状態になっている。

     相違箇所がいったんこの状態になると、コマンド`a'や`b'に数引数を指定
     しない限り、何もしない。

     この状態は、モード行では`comb'と表示される。



File: emacs-ja, Node: Merge Commands, Next: Exiting Emerge, Prev: State of Difference, Up: Emerge

併合コマンド
------------

ここでは、高速モードの併合操作コマンドを示します。編集モードでは、これ
らのコマンドのまえに`C-c C-c'を付けます。

`p'
     まえの相違箇所を選択する。

`n'
     つぎの相違箇所を選択する。

`a'
     この相違箇所をA版にする（状態A）。

`b'
     この相違箇所をB版にする（状態B）。

`C-u N j'
     番号Nの相違箇所を選択する。

`.'
     ポイントを含む相違箇所を選択する。このコマンドは、併合バッファ、A
     バッファ、Bバッファのいずれでも使える。

`q'
     終了する。併合作業を完了。

`C-]'
     アボートする。併合作業をやめ、併合結果も保存しない。

`f'
     高速モードに移行する。（編集モードでは、実際には`C-c C-c f'コマン
     ド。）

`e'
     編集モードに移行する。

`l'
     3つのウィンドウすべてを（`C-l'のように）再表示する。

`-'
     数引数の一部を指定する。

`DIGIT'
     これも、数引数の一部を指定する。

`d a'
     併合バッファのこれ以降では、A版を選ぶ（デフォルトA）。

`d b'
     併合バッファのこれ以降では、B版を選ぶ（デフォルトB）。

`c a'
     この相違箇所のA版のテキストをキルリングにコピーする。

`c b'
     この相違箇所のB版のテキストをキルリングにコピーする。

`i a'
     この相違箇所のA版のテキストをポイント位置に挿入する。

`i b'
     この相違箇所のB版のテキストをポイント位置に挿入する。

`m'
     相違箇所の周りにポイントとマークを設定する。

`^'
     3つのウィンドウすべてを（`M-v'のように）下にスクロールする。

`v'
     3つのウィンドウすべてを（`C-v'のように）上にスクロールする。

`<'
     3つのウィンドウすべてを（`C-x <'のように）左にスクロールする。

`>'
     3つのウィンドウすべてを（`C-x >'のように）右にスクロールする。

`|'
     3つのウィンドウすべてで、水平方向のスクロール分をリセットする。

`x 1'
     併合バッファを表示しているウィンドウの高さを1行に縮小する。（フル
     サイズに戻すには`C-u l'を使う。）

`x c'
     この相違箇所の2つの版を混合する（*Note Combining in Emerge::）。

`x f'
     emergeで作業しているファイル／バッファの名前を、ヘルプ用ウィンドウ
     に表示する。（ウィンドウをもとの状態に戻すには`C-u l'を使う。）

`x j'
     この相違箇所を、つぎの相違箇所と結合する。（`C-u x j'では、まえの
     相違箇所と結合する。）

`x s'
     この相違箇所を2つに分割する。このコマンドを使うまえに、3つのバッファ
     それぞれで、相違箇所を分割したい位置にポイントを移動しておく。

`x t'
     相違箇所の先頭や末尾にある同じ行を取り去る。このような行が現れるの
     は、A版とB版は一致しているが、共通の祖先とは一致しない場合。



File: emacs-ja, Node: Exiting Emerge, Next: Combining in Emerge, Prev: Merge Commands, Up: Emerge

emergeの終了
------------

`q'コマンド（`emerge-quit'）は、併合を終了し、出力ファイルを指定してあ
れば、そこに結果を保存します。AバッファとBバッファは正しい内容に復元さ
れますが、emergeがAバッファとBバッファを作成して、かつ、編集されていな
ければ、それらをキルします。さらに、併合バッファでのemergeコマンドを使
用禁止にします。というのは、これ以降に併合コマンドを実行するとさまざま
なバッファが悪影響を受ける可能性があるからです。

`C-]'は、併合作業をアボートします。つまり、出力ファイルに書き出さずに終
ります。出力ファイルを指定していなければ、併合作業をアボートしようが終
了しようが、何の違いもありません。

他のLispプログラムからemergeコマンドが呼び出された場合、正しく終了する
と`t'、アボートしたときは`nil'が返されます。



File: emacs-ja, Node: Combining in Emerge, Next: Fine Points of Emerge, Prev: Exiting Emerge, Up: Emerge

2つの版の混合
-------------

相違箇所によっては、*両方*の版を残したいこともあるでしょう。そのような
場合には、`x c'を使います。すると、併合バッファはつぎのようになります。

     #ifdef NEW
     VERSION FROM A BUFFER
     #else /* not NEW */
     VERSION FROM B BUFFER
     #endif /* not NEW */

この例では、2つの版をCのプリプロセッサの条件節で分けていますが、変数
`emerge-combine-versions-template'に好みの文字列を設定すれば、このコマ
ンドで使用する文字列を指定できます。この文字列内では、A版のテキストを置
く箇所には`%a'を、B版のを置く箇所には`%b'を指定します。上に示した結果を
生じるデフォルトの設定はつぎのとおりです。

     "#ifdef NEW\n%a#else /* not NEW */\n%b#endif /* not NEW */\n"



File: emacs-ja, Node: Fine Points of Emerge, Prev: Combining in Emerge, Up: Emerge

細かな注意点
------------

併合作業中には、AバッファやBバッファを勝手に編集してはいけません。
emergeは一時的にこれらのバッファの内容を変更しますが、最終的にはもとの
状態に戻します。

複数の併合処理を同時に進めることもできますが、別の併合処理の入力に同じ
バッファを使用してはいけません。というのは、一時的にせよ、互いに異なる
複数の変更が1つのバッファに加えられてしまうからです。

入力ファイル全体を比較する必要があるため、emergeの開始にはしばらく時間
がかかる場合もあります。また、`diff'コマンドが完了するまで、emergeは何
もできません。たぶん、そのうち誰かがemergeを変更して、入力ファイルが大
きいときにはバックグラウンドで比較を行うようにするでしょう。そうすれば、
emergeがコマンドを受け付けるようになるまで、Emacsで他の作業を続けられま
す。

フック`emerge-startup-hook'（*Note Hooks::）が、併合処理の設定の最後に
実行されます。


File: emacs-ja, Node: Abbrevs, Next: Picture, Prev: Maintaining, Up: Top

略語の利用法 *(2004/01/12)*
***************************

定義済みの略語（abbrev）とは、挿入時に別のテキストに展開される単語のこ
とです。略語を定義するときに、それをどう展開するか指定します。たとえば、
`foo'を略語として、`find outer otter'に展開すると定義したとします。する
と、`f o o SPC'と打鍵すればバッファには`find outer otter ' (1) (*Note
Abbrevs-Footnotes::) が挿入されます。

略語の別な形に、"動的略語展開"（dynamic abbrev expansion）があります。
動的略語展開とは、バッファ中のポイントのまえにある文字列を
バッファ内にあるその文字列で始まる既存の単語に展開することで、
陽にコマンドを実行して行います。
*Note Dynamic Abbrevs::。

『Hippie』 による展開は略称展開を汎用化したものです．Features for
Automatic Typing
(http://www.bookshelf.jp/texi/emacs-man/21-3/jp/autotype.html) を参照．

* Menu:

* Abbrev Concepts::             Fundamentals of defined abbrevs.
* Defining Abbrevs::            Defining an abbrev, so it will expand when typed.
* Expanding Abbrevs::           Controlling expansion: prefixes, canceling expansion.
* Editing Abbrevs::             Viewing or editing the entire list of defined abbrevs.
* Saving Abbrevs::              Saving the entire list of abbrevs for another session.
* Dynamic Abbrevs::             Abbreviations for words already in the buffer.
* Dabbrev Customization::       What is a word, for dynamic abbrevs.  Case handling.


File: emacs-ja  Node: Abbrevs-Footnotes, Up: Abbrevs

(1) 【訳注】展開を引き起こしたSPCも挿入されることに注意。



File: emacs-ja, Node: Abbrev Concepts, Next: Defining Abbrevs, Prev: Abbrevs, Up: Abbrevs

略語の考え方
============

略語とは、あらかじめどう"展開"するか定義された単語のことです。
略語に続けて、空白、タブ、ピリオドなどの単語の区切り文字を入力すると、
略語は展開されて展開形に置き換わります。
たとえば、略語`foo'を展開形`find outer otter'に展開するように
定義しておけば、`f o o .'と打鍵すると
`find outer otter.'をバッファに挿入できます。

略語は、略語（abbrev）モード（マイナモード）がオンのときにだけ展開され
ます。略語（abbrev）モードをオフにしても定義した略語が消えてしまうわけ
ではなく、つぎにオンにしたときに同じ定義をふたたび使えます。コマンド
`M-x abbrev-mode'でこのモードのオン／オフをトグル（切り替えが）できます。
また、数引数を指定した場合、引数が正のときには略語（abbrev）モードはオ
ンになり、それ以外のときにはオフになります。*Note Minor Modes::。
`abbrev-mode'は変数でもあります。この変数が`nil'以外のときには略語
（abbrev）モードはオンです。この変数に値を設定すると、自動的にカレント
バッファにローカルな変数になります。

略語定義は"モードに固有"にできます。つまり、あるメジャーモードのときに
だけ働くように定義できます。略語は"グローバル"にも定義でき、そのときは
すべてのメジャーモードで使えます。同じ略語に、グローバルな定義と、さま
ざまなメジャーモードに固有な定義とを持たせることができます。あるメジャー
モードに固有な定義は、グローバルな定義に優先します。

略語は、編集作業中に対話的に定義できます。略語の定義一覧を、あとで使う
ためにファイルに保存することもできます。大量の略語定義をセッションごと
にロードする人もいます。



File: emacs-ja, Node: Defining Abbrevs, Next: Expanding Abbrevs, Prev: Abbrev Concepts, Up: Abbrevs

略語の定義方法 *(2004/01/12)*
=============================

`C-x a g'
     ポイントのまえの単語を展開形として、略語を定義する。
     （`add-global-abbrev'）。
`C-x a l'
     上と同様。ただし、現在のメジャーモードに固有な略語を定義する。
     （`add-mode-abbrev'）。
`C-x a i g'
     バッファ中の1単語を略語として定義する。
     （`inverse-add-global-abbrev'）。
`C-x a i l'
     バッファ中の1単語をモードに固有な略語として定義する。
     （`inverse-add-mode-abbrev'）。
`M-x define-global-abbrev RET ABBREV RET EXP RET'
     ABBREV を EXPの略称として定義する (全モードで有効)
`M-x define-mode-abbrev RET ABBREV RET EXP RET'
     ABBREV を現在のモードのみで有効な EXPの略称として定義する．
`M-x kill-all-abbrevs'
     このコマンドは現在有効なすべての略語定義を抹消し空にする。

略語を定義する普通の方法は、まず、略語に置き換わってほしい展開形のテキ
ストを入力し、つぎにその直後にポイントをもっていき、`C-x a
g'（`add-global-abbrev'）と打鍵します。すると、ミニバッファを用いて略語
を読み取り、ポイントの直前の単語（群）に対する略語として登録します。展
開形として用いる単語の個数は、数引数で指定します。たとえば、略語`foo'を
まえのように定義するには、テキスト`find outer otter'を挿入し、続いて
`C-u 3 C-x a g f o o RET'と打鍵します。

`C-x a g'に数引数として0を指定すると、展開形はリージョンの内容になりま
す。

コマンド`C-x a l'（`add-mode-abbrev'）も同様ですが、特定のモードに固有
な定義になります。モードに固有な略語は、特定のメジャーモードの中だけで
有効です。`C-x a l'は、`C-x a l'と打鍵したときのメジャーモードに対する
略語を定義します。引数の意味は`C-x a g'と同じです。

すでにバッファ内にあるテキストを略語として使いたい場合には、`C-x a g'の
かわりにコマンド`C-x a i g' （`inverse-add-global-abbrev'）、あるいは、
`C-x a l'のかわりにコマンド`C-x a i l' （`inverse-add-mode-abbrev'）を
使います。これらは『逆さ』（inverse）コマンドと呼ばれます。というのは、
これらのコマンドで使う（バッファにあるものとミニバッファから読むものの）
2つの文字列の用途が逆さだからです。

`define-global-abbrev' を使うと，バッファに略称や展開される文字を入力せ
ずに略称を定義できます．このコマンドを実行すると略称と展開される文字を
引数として取ります(コメント：M-x で呼ぶと略称と展開される文字をミニバッ
ファで入力することができます)．この略称はすべてのモードで有効になります
が，`define-mode-abbrev' は現在のモードでのみ有効な略称を定義します．

略語の定義を変更するには、単に新たに定義してください。略語がすでに定義
されていると、略語定義コマンドは置き換える前によいかどうかを確認してき
ます。

略語の定義を削除するには、略語定義コマンドに負の数引数を指定します。
`C-u - C-x a g'や`C-u - C-x a l'のようにします。前者はグローバルな定義
を、後者はモードに固有な定義を削除します。

`M-x kill-all-abbrevs' は、グローバルとローカルのすべての略語定義を削除
します。



File: emacs-ja, Node: Expanding Abbrevs, Next: Editing Abbrevs, Prev: Defining Abbrevs, Up: Abbrevs

略語展開の制御
==============

ポイントの直前に略語があるときに白文字や区切り文字（SPC、コンマなど）を
打鍵すると、略語はつねに展開されます。より正確には、英単語の構成文字以
外のどんな文字でも略語展開は起こり、英単語の構成文字の任意の組み合わせ
を略語に使用できます。略語の通常の使い方は、略語を入力してから区切り文
字を入力して展開を行わせるという方法です。

略語展開では大文字小文字を保存します。
したがって、
`foo'は`find outer otter'に、
`Foo'は`Find outer otter'に展開されます。
また、変数`abbrev-all-caps'に応じて、`FOO'は
（変数の値が`nil'以外のときは）
`FIND OUTER OTTER'、あるいは、`Find Outer Otter'に展開されます

以下は略語展開を制御するために使うコマンドです。

`M-''
     これまで入力した部分をこれから入力する略語から分離する。
`C-x a e'
     ポイントの直前の略語を展開する（`expand-abbrev'）。このコマンドは
     略語（abbrev）モードがオンでなくても働く。
`M-x expand-region-abbrevs'
     リージョン中のいくつかの、あるいはすべての略語を展開する。

接頭辞が付いた略語を展開したい場合もあるでしょう。略語`cnst'は
`construction'に展開されるとして、`reconstruction'と入力するためにこの
略語を使いたいとします。`recnst'と打鍵してもだめです。というのは、
`recnst'は定義済みの略語ではないからです。ではどうすればよいかというと、
接頭辞`re'と略語`cnst'のあいだでコマンド`M-'' （`abbrev-prefix-mark'）
を使うのです。まず`re'と打ち込みます。続いて`M-''と打鍵します。するとバッ
ファにハイフン（`-'）が挿入され、切れ目が入ったことを示します。それから
略語`cnst'を入力します。バッファには`re-cnst'と入っています。ここで単語
構成文字以外の文字を打ち込めば、略語`cnst'が`construction'に展開されま
す。展開時には`M-''が挿入したハイフン（`-'）は削除されます。結果は、望
みどおりの`reconstruction'です。

もし、略語を展開しないでそのまま残しておきたい場合には、`C-q'に続けて区
切り文字を入れます。つまり、`foo C-q ,'とすると、バッファには`foo,'のま
ま残ります。

まちがって略語を展開してしまった場合には、`C-_'（*Note Undo::）と打鍵す
れば、展開をアンドゥし略語に戻せます。このとき略語展開を引き起こした区
切り文字も削除されます。略語を展開せずに区切り文字とともに入力したいな
らば、区切り文字を`C-q'でクォートして挿入します。区切り文字を削除せずに
直前に展開したものを略語に戻すには、コマンド`M-x unexpand-abbrev'を使う
こともできます。

`M-x expand-region-abbrevs' は、リージョン全体にわたって定義済みの略語
を探し、みつかったそれぞれについてそれを展開するかを聞いてきます。この
コマンドは、略語（abbrev）モードをオンにし忘れて略語を用いたテキストを
入力してしまったときに便利です。あるいは、特別な略語定義一式を用いて一
度に全体を置き換えるときにも便利です。このコマンドは略語（abbrev）モー
ドがオンでなくても使えます。

略語を展開するときには、フック`pre-abbrev-expand-hook' （*Note Hooks::）
が実行されます。



File: emacs-ja, Node: Editing Abbrevs, Next: Saving Abbrevs, Prev: Expanding Abbrevs, Up: Abbrevs

略語の表示と編集 *(2004/01/12)*
===============================

`M-x list-abbrevs'
     すべての略語定義を表示する。数引数があれば，現在のモードのローカル
     略称のみを表示する．
`M-x edit-abbrevs'
     略語の一覧を編集する。定義を追加、変更、削除できる。

`M-x list-abbrevs'の出力はつぎのようになります。

     (lisp-mode-abbrev-table)
     "dk"	       0    "define-key"
     (global-abbrev-table)
     "dfn"	       0    "definition"

（空行には意味はない。また、いくつかのモードの略語表は省略した。）

括弧で括られた名前から成る行は、特定モードの略語表のヘッダです。
`global-abbrev-table'には、グローバルな略語定義が入っています。また、メ
ジャーモード名からとったそれ以外の名前の略語表には、モードに固有な略語
が入っています。

各略語表では、空でない各行が1つの略語を定義します。行の先頭の単語は略語
です。つぎに続く数字はこの略語を展開した回数です。Emacsは、略語が実際に
どれだけ使われているか数えていて、あまり使わない定義を削除できるように
しています。行の最後の文字列が展開形です。

`M-x edit-abbrevs'により、Emacsバッファ内の略語一覧を編集することで略語
定義の追加、変更、削除を行えます。一覧の形式は上で述べたものと同じです。
このバッファは`*Abbrevs*'と呼ばれ、略語編集（edit-abbrevs）モードになっ
ています。このバッファで`C-c C-c'と打鍵すると、バッファで指定したように
略語定義が登録され、バッファにない略語定義は削除されます。

コマンド`edit-abbrevs'は実際には`list-abbrevs'と同ですが、前者はバッファ
`*Abbrevs*'を選択するのに対し、後者はバッファを別のウィンドウに表示する
だけです。



File: emacs-ja, Node: Saving Abbrevs, Next: Dynamic Abbrevs, Prev: Editing Abbrevs, Up: Abbrevs

略語の保存
==========

以下のコマンドは、編集セッション間で略語定義を保存するためのものです。

`M-x write-abbrev-file RET FILE RET'
     ファイルFILEにすべての略語定義を書き出す。
`M-x read-abbrev-file RET FILE RET'
     ファイルFILEから略語定義を読み込み、その指定どおりに定義する。
`M-x quietly-read-abbrev-file RET FILE RET'
     上と同様だが、処理経過を表示しない。
`M-x define-abbrevs'
     カレントバッファ内の定義で略語を定義する。
`M-x insert-abbrevs'
     すべての略語とその展開形をカレントバッファに挿入する。

`M-x write-abbrev-file'は、ミニバッファからファイル名を読み取り、そのファ
イルにすべての略語定義情報を書き出します。このコマンドは、以後のセッショ
ンで使うために略語定義を保存するために使います。ファイルに保存されるテ
キストは一連のLisp式であり、これらの式を実行すると、現状と同じ略語が定
義されます。

`M-x read-abbrev-file'は、ミニバッファからファイル名を読み取り、そのファ
イルを読み込んでファイルの内容に従って略語を定義します。`M-x
quietly-read-abbrev-file'も似ていますが、現在何が進行しているかをエコー
領域に表示しませんし，M-x で呼ぶこともできません．このコマンドは、
`.emacs'ファイルで使うことに主眼があります。どちらのコマンドも、引数と
しに`nil'を指定すると変数`abbrev-file-name'に指定したファイル名を使いま
す。この変数のデフォルトは`"~/.abbrev_defs"'です。そのファイルは略称を
定義するファイルであり，Emacsは起動時にそのファイルを自動的に読み込みま
す．

Emacsは、略語定義を変更してあると自動的に略語定義を保存するかどうか、
（`C-x s'や`C-x C-c'などで）すべてのファイルを保存するかどうか問い合わ
せるときに同時に聞いてきます。これは`abbrev-file-name'で決められたファ
イルに略語定義を保存します．この機能は、変数`save-abbrevs'の値を`nil'に
すると禁止できます。

コマンド`M-x insert-abbrevs'と`M-x define-abbrevs'は、上で述べたコマン
ドと同様ですが、Emacsバッファ内のテキストに作用します。`M-x
insert-abbrevs'は、カレントバッファのポイントの後にすべての略語定義を記
述したテキストを挿入します。`M-x define-abbrevs'は、カレントバッファ全
体を解析し、その内容に従って略語を定義します。



File: emacs-ja, Node: Dynamic Abbrevs, Next: Dabbrev Customization, Prev: Saving Abbrevs, Up: Abbrevs

動的略語展開
============

これまでに述べてきた略語の機能は、テキストを挿入するときに自動的に働き
ますが、すべての略語を陽に登録しておく必要があります。一方、"動的略語"
（dynamic abbrevs）は、バッファの内容に基づいて略語の展開形を自動的に決
定することができます。ただし、陽に指示したときだけ、動的略語展開を行い
ます。

`M-/'
     バッファのポイントの直前の単語を"動的略語"（dynamic abbrev）として、
     その略語で始まる単語をバッファ内から探索し展開する
     （`dabbrev-expand'）。

`C-M-/'
     ポイントの直前の単語を動的略語として補完する
     （`dabbrev-completion'）。

たとえば、バッファ内に`does this follow 'があるときに`f o M-/'と打鍵す
ると、バッファ内で`fo'で始まる近くにある単語が`follow'なので`follow'が
挿入されます。`M-/'に数引数を指定すると、ポイントから先頭に向かって探し
て、2番目のもの、3番目のものというように異なる展開形に展開できます。
`M-/'を繰り返すことにより、次々にさらに先頭へ向かって探して別の候補に展
開します。ポイントよりまえのすべてのテキストを探し終えた場合には、ポイ
ントよりうしろのテキストを探します。変数`dabbrev-limit'が`nil'以外 (1)
(*Note Dynamic Abbrevs-Footnotes::) ならば、バッファ内のどの範囲まで展
開候補を探すかを指定します。

カレントバッファを探し終ると、
変数`dabbrev-check-all-buffers'を`nil'に設定していない限り、
`M-/'は他のバッファも探します。

変数 `dabbrev-ignored-buffer-regexps' はどのバッファを探すかを制御しま
す．値は正規表現のリストです．もしバッファ名がこの変数の正規表現リスト
の1個に一致すれば，動的略語展開はそのバッファから探しません．

`C-u - M-/'のように`M-/'に負の数引数を指定すると、まずポイントのうしろ
から展開候補を探し、それから他のバッファを探します．ポイントのまえにつ
いては最後の手段としてだけ展開候補を探します。`M-/'を繰り返して別の展開
候補を探す場合には、引数を指定しません。これにより、ポイントよりうしろ
のすべての展開候補を試してから、つぎにポイントよりまえのすべての展開候
補を試せます。

動的略語を展開したあとでは、展開形のもともとの場所でつぎに続く単語（群）
をコピーすることができます。コピーしたい単語ごとに単に`SPC M-/'と打鍵し
ます。単語のあいだの空白や句読点も単語とともにコピーされます。

コマンド`C-M-/'（`dabbrev-completion'）は、
動的略語の補完を行います。
展開候補を1つずつ試すかわりに、すべての候補を全部探して
それらに共通するテキストを挿入します。
それらに共通部分がなければ、`C-M-/'は候補一覧を表示するので
普通の方法でその中から1つ選びます。
*Note Completion::。

動的略語展開は略語（abbrev）モードと完全に独立しています。`M-/'による単
語の展開は、略語（abbrev）モードで定義済みかどうかとは完全に独立してい
ます。


File: emacs-ja  Node: Dynamic Abbrevs-Footnotes, Up: Dynamic Abbrevs

(1) 【訳注】文字数を指定する。



File: emacs-ja, Node: Dabbrev Customization, Prev: Dynamic Abbrevs, Up: Abbrevs

動的略語のカスタマイズ方法
==========================

通常、動的略語展開では大文字小文字を区別しないで候補を探します。つまり、
展開候補と略語の大文字小文字が一致する必要はありません。

この機能は変数`dabbrev-case-fold-search'で制御できます。値が`t'のときは、
候補を探すときに大文字小文字を区別しません。値が`nil'のときは、候補と略
語の大文字小文字が一致する必要があります。変数
`dabbrev-case-fold-search'の値は、デフォルトでは真である
`case-fold-search'です。したがって、変数`case-fold-search'が展開候補を
探すときの大文字小文字の区別を制御します。

通常、動的略語展開は*打ち込んだ略語の*大文字小文字のパターンを保存しま
す。つまり、略語の大文字小文字のパターンに合うように展開形の大文字小文
字を変換します。

変数`dabbrev-case-replace'は、略語の大文字小文字のパターンを保存するか
どうかを制御します。値が`t'のときは、たいていの場合、パターンを保存しま
す。`nil'のときは、つねに展開形をそのままコピーします。
`dabbrev-case-replace'の値は、デフォルトでは真である`case-replace'です。
したがって、変数`case-replace'が展開形をそのままコピーするかどうかを制
御します。

しかしながら、展開形の大文字小文字のパターンが複雑であるとき、略語の始
めから終りまでがそのパターンに一致する場合、これらの変数に関わらず展開
形をそのままコピーします。たとえば、バッファに
`variableWithSillyCasePattern'とあって`v a M-/'と打鍵すると、大文字小文
字のパターンを含め展開形をそのままコピーします。

変数`dabbrev-abbrev-char-regexp'が`nil'以外の場合、動的展開においてどん
な文字を単語構成文字とみなすかを制御します。これに指定する正規表現は1文
字のみに一致するものである必要があり、2文字以上に一致してはいけません。
同じ正規表現は、どの文字が展開形を構成するかも指定します。値として
`nil'を指定すると特別な意味があり、略語は単語の構成文字だけから成り、展
開形は単語と記号文字から成るという意味になります。

シェルスクリプトやmakefileなどでは、変数名には接頭辞`$'があったりなかっ
たりします。これらのテキスト用のメジャーモードでは、変数
`dabbrev-abbrev-skip-leading-regexp'を設定して余分な接頭辞を扱えるよう
に動的展開をカスタマイズできます。この変数には、動的略語展開で無視すべ
き余分な接頭辞に一致する正規表現を指定します。



File: emacs-ja, Node: Picture, Next: Sending Mail, Prev: Abbrevs, Up: Top

絵の編集 *(2004/03/27)*
***********************

テキスト文字で書いた絵（たとえば、プログラムのコメントとしてレジスタを
フィールドに分割した絵）を編集するには、コマンド`M-x edit-picture'を使っ
てピクチャー（picture）モードに入ります。

ピクチャー（picture）モードでは、"1/4平面"モデル（quarter-plane）に基づ
いて編集を行います。つまり、右側と下側に無限に続く領域にテキスト文字が
散在するのです。このモデルでは行末は存在しません。行中で空白でない文字
が最後に現れる場所がわかるだけです。

もちろん、Emacsはつねにテキストを文字の列としてとらえ、実際には行に終り
があります。しかし、ピクチャー（picture）モードでは、よく使われるコマン
ドの大部分を1/4平面モデルに従って動作するように置き換えています。空白を
挿入したりタブを空白に置き換えることで、そのようにします。

Emacsの基本的な編集コマンドの大部分は、
ピクチャー（picture）モードでは
1/4平面モデルにおいて本質的には同じ動作をするように再定義されています。
さらに、ピクチャー（picture）モードでは、
`C-c'で始まるキー列を絵の編集用の特別なコマンドとして定義します。

これらのキーの1つである`C-c C-c'は非常に重要です。絵が、普通は別のメ
ジャーモードで編集される大きなファイルの一部であることがしばしばありま
す。`M-x edit-picture'は直前のメジャーモードを記録しておき、あとで`C-c
C-c'コマンド（`picture-mode-exit'）でそのモードに戻れるようにします。ま
た、数引数を指定しなければ、`C-c C-c'は行末の空白を削除します。

ピクチャー（picture）モードのすべての特別なコマンドは、（`picture'ライ
ブラリがロードされていれば）他のモードでも使えますが、ピクチャー
（picture）モード以外ではキーにバインドされていません。以下では『1桁』
移動などと説明しますが、ピクチャー（picture）モードのすべてのコマンドは、
それに対応する通常のコマンドと同じように数引数を扱えます。

ピクチャー（picture）モードに入るときにフック`picture-mode-hook'を実行
します（*Note Hooks::）。

* Menu:

* Basic Picture::         Basic concepts and simple commands of Picture Mode.
* Insert in Picture::     Controlling direction of cursor motion
                            after "self-inserting" characters.
* Tabs in Picture::       Various features for tab stops and indentation.
* Rectangles in Picture:: Clearing and superimposing rectangles.



File: emacs-ja, Node: Basic Picture, Next: Insert in Picture, Prev: Picture, Up: Picture

ピクチャーモードの基本編集
==========================


ピクチャー（picture）モードでも、ほとんどのキーは通常と同じ動作をします
が、1/4平面流の動作です。たとえば、`C-f'は、`picture-forward-column'を
実行するように再定義してあります。このコマンドはポイントを1桁右に動かし、
必要なら空白を挿入して、行末がないかのようにふるまいます。`C-b'は、
`picture-backward-column'を実行するように再定義してあります。このコマン
ドはポイントを1桁左に動かし、必要に応じてタブを複数の空白に変換します。
`C-n'と`C-p'は、それぞれ`picture-move-down'と`picture-move-up'を実行す
るように再定義してあります。これらのコマンドは、必要に応じて空白を挿入
したりタブを変換して、ポイントが同じ桁位置に留まるように移動します。
`C-e'は`picture-end-of-line'を実行します。このコマンドは、行の最後の白
文字以外の文字の直後に移動します。画面モデルは行頭には影響しないので、
`C-a'を変更する必要はありません。

テキストの挿入は、上書き（overwrite）モードを用いて1/4平面モデルに対応
させてあります（*Note Minor Modes::）。自己挿入文字は、既存のテキストを
右側へ押しやるのではなく、既存のテキストを桁ごとに置き換えます。RETは
`picture-newline'を実行します。このコマンドは、つぎの行の先頭に移動し、
その行が新たなテキストで置き換わるようにします。

ピクチャー（picture）モードでは、テキストの削除やキルのかわりに消去しま
す。DEL（`picture-backward-clear-column'）は、直前の文字を削除するので
はなく空白で置き換え、また、ポイントを1つまえに戻します。
`C-d'（`picture-clear-column'）は直後の1つ以上の文字を空白で置き換えま
すが、ポイントは動かしません。（文字を空白で置き換えて、かつ、ポイント
を先へ進めるには、SPCを使う。）`C-k'（`picture-clear-line'）は行の内容
を実際にキルしますが、バッファから改行を削除しません。

実際に挿入を行うには、特別なコマンドを使う必要があります。
`C-o'（`picture-open-line'）は、現在行のつぎに空行を作りますが、行を分
割しません。`C-M-o'（`split-line'）はピクチャー（picture）モードでも意
味があるので変更してありません。`C-j'（`picture-duplicate-line'）は現在
行の下に現在行と同じ内容の行を挿入します。

ピクチャー（picture）モードで実際に削除を行うには、`C-w'か（他のモード
での`C-d'と同じ`delete-char'に定義されている）`C-c C-d'、あるいは、絵の
矩形領域コマンドの1つを使います（*Note Rectangles in Picture::）。



File: emacs-ja, Node: Insert in Picture, Next: Tabs in Picture, Prev: Basic Picture, Up: Picture

挿入後のポイント移動制御
========================

ピクチャー（picture）モードでは『自己挿入』文字は上書きしてポイントを動
かしますから、ポイントをどのように動かすかについて本質的な制限はありま
せん。通常ポイントは右に動きますが、『自己挿入』文字のあとで上下左右斜
めの8方向のいずれの方向へ移動するか指定できます。これは、バッファに直線
を引くときに役立ちます。

`C-c <'
     挿入後、左へ移動（`picture-movement-left'）。
`C-c >'
     挿入後、右へ移動（`picture-movement-right'）。
`C-c ^'
     挿入後、上へ移動（`picture-movement-up'）。
`C-c .'
     挿入後、下へ移動（`picture-movement-down'）。
`C-c `'
     挿入後、左上（『北西』）へ移動（`picture-movement-nw'）。
`C-c ''
     挿入後、右上（『北東』）へ移動（`picture-movement-ne'）。
`C-c /'
     挿入後、左下（『南西』）へ移動（`picture-movement-sw'）。
`C-c \'
     挿入後、右下（『南東』）へ移動（`picture-movement-se'）。

2つの移動コマンドは、現在指定されている挿入後の移動方向に基づいて動作します。
コマンド`C-c C-f'（`picture-motion'）は、
現在指定されている『挿入』後の移動方向と同じ方向へ移動しますが、
`C-c C-b'（`picture-motion-reverse'）は反対方向へ移動します。



File: emacs-ja, Node: Tabs in Picture, Next: Rectangles in Picture, Prev: Insert in Picture, Up: Picture

ピクチャーモードのタブ
======================

ピクチャー（picture）モードにはタブ相当の動作が2種類あります。文脈に基
づくタブを行うには`M-TAB' （`picture-tab-search'）を使います。引数を指
定しないと、先行する空行でない行において白文字に続く『興味ある』つぎの
文字の下方に移動します。ここで『つぎ』とは『開始位置より水平位置が1より
大きい』という意味です。`C-u M-TAB'のように引数を指定すると、現在行にお
いて『興味ある』文字に移動します。`M-TAB'はテキストを変更せずにポイント
を移動するだけです。『興味ある』文字は、変数`picture-tab-chars'で定義さ
れますが、文字集合を定義する必要があります。この変数の構文は正規表現で
使われる`[...]'の構文に似ていますが、`['と`]'で囲みません。この変数のデ
フォルト値は`"!-~"'です。

TABそれ自身は、`picture-tab'を実行します。このコマンドは、現在のタブス
トップの設定に基づいて動作します。これは他のモードの`tab-to-tab-stop'に
相当します。通常これはポイントを動かすだけですが、数引数を指定すると移
動先までのテキストをクリアします。

文脈に基づくタブとタブストップに基づくタブは、コマンド`C-c
TAB'（`picture-set-tab-stops'）で結び付けることができます。このコマンド
は、現在行において`M-TAB'が重要と考える位置にタブストップを設定します。
TABとともにこのコマンドを使えば、文脈に基づくタブと同じ効果を得られます。
しかし、`M-TAB'で十分ならばそのほうが便利でしょう。

本当のタブ文字を絵に使わないように抑制したほうが便利な場合があります。
たとえば、`C-x TAB'で絵をめちゃくちゃにしてしまうことを防止できます。
タブ文字の使用を抑制するには、
変数`indent-tabs-mode'に`nil'を設定します。
*Note Just Spaces::。



File: emacs-ja, Node: Rectangles in Picture, Prev: Tabs in Picture, Up: Picture

ピクチャーモードの矩形領域コマンド *(2004/03/27)*
=================================================

ピクチャー（picture）モードでは、1/4平面モデルに適合するように、テキス
トの矩形領域に作用するコマンドを定義します。標準的な矩形領域コマンドも
役立つでしょう（*Note Rectangles::）。

`C-c C-k'
     矩形領域を空白でクリアする（`picture-clear-rectangle'）。数引数を
     指定するとテキストを削除する。
`C-c C-w R'
     同様だが、まず矩形領域の内容をレジスタRに保存する
     （`picture-clear-rectangle-to-register'）。
`C-c C-y'
     ポイント位置を左上隅として最後にキルした矩形領域をバッファに上書き
     する（`picture-yank-rectangle'）。数引数を指定すると挿入する。
`C-c C-x R'
     同様だが、レジスタRの矩形領域を使う
     （`picture-yank-rectangle-from-register'）。

絵の矩形領域コマンド、`C-c C-k'（`picture-clear-rectangle'）と`C-c
C-w'（`picture-clear-rectangle-to-register'）は、標準の矩形領域コマンド
が矩形領域を削除するのに対しクリアする点で異なります。これは、ピクチャー
（picture）モードでの`C-d'の意味の変更方法に類似したものです。

しかし、ピクチャー（picture）モードでも矩形領域の削除は便利なので、
数引数を与えるとこれらのコマンドは矩形領域を削除します。
引数を指定してもしなくても`C-c C-k'は
`C-c C-y'のために矩形領域を（レジスタに）保存します。

ピクチャー（picture）モードのヤンクコマンドは標準のそれとは、挿入のかわ
りに上書きする点で異なります。これはピクチャー（picture）モードでのテキ
ストの挿入が他のモードでのそれと異なっているのと同じです。`C-c
C-y'（`picture-yank-rectangle'）は、もっとも最近にキルした矩形領域を
（上書きで）挿入しますが、`C-c
C-x'（`picture-yank-rectangle-from-register'）は同様のことを指定された
レジスタ内の矩形領域で行います。



File: emacs-ja, Node: Sending Mail, Next: Rmail, Prev: Picture, Up: Top

メイルの送信
************

Emacsでメッセージを送信するには、まずコマンド（`C-x m'）を打って
`*mail*'バッファを選択して初期化します。続いて、このバッファでテキスト
とヘッダを編集し、最後に別のコマンド（`C-c C-s'か`C-c C-c'）を打ってメッ
セージを送信します。

`C-x m'
     送信メッセージを作成する（`compose-mail'）。
`C-x 4 m'
     同様だが、別のウィンドウにメッセージを表示する
     （`compose-mail-other-window'）。
`C-x 5 m'
     同様だが、新たにフレームを作る（`compose-mail-other-frame'）。
`C-c C-s'
     メイル（mail）モードでは、メッセージを送信する（`mail-send'）。
`C-c C-c'
     メッセージを送信しメイルバッファを閉じる（`mail-send-and-exit'）。

コマンド`C-x m'（`compose-mail'）は、`*mail*'という名前のバッファを選択
し、そのバッファ内に送信するメッセージの雛型を作ります。`C-x 4
m'（`compose-mail-other-window'）は、別のウィンドウで`*mail*'バッファを
選択し、直前のカレントバッファは見えるようにしておきます。`C-x 5
m'（`compose-mail-other-frame'）は、新たにフレームを作って`*mail*'バッ
ファを選択します。

メイル作成バッファはEmacsの普通のバッファなので、メイルを書いている途中
で別のバッファに切り替えてあとで戻ってくる（あるいは戻らない）ことがで
きます。メッセージを書きかけのまま送信していないのに再度`C-x m'コマンド
を使うと、Emacsは古いメッセージを消してよいかどうか聞いてきます。`n'と
答えると、書きかけの古い内容の`*mail*'バッファが選択されるので、古いメッ
セージを書き終えて送信できます。`C-u C-x m'でもこのようにできます。メッ
セージを送信すると`*mail*'バッファは『変更なし』と印が付けられ、つぎに
`C-x m'を使っても確認を求めないようにします。

`*mail*'バッファに書きかけのメッセージを残したまま別のメッセージを送信
したい場合には、`M-x rename-uniquely'を使って`*mail*'バッファを別の名前
に変更してください（*Note Misc Buffer::）。そして、`C-x m'コマンドや他
のコマンドで新しい`*mail*'バッファを作ります。こうすれば個々のメイルバッ
ファを独立に編集できます。

* Menu:

* Format: Mail Format.	     Format of the mail being composed.
* Headers: Mail Headers.     Details of permitted mail header fields.
* Aliases: Mail Aliases.     Abbreviating and grouping mail addresses.
* Mode: Mail Mode.	     Special commands for editing mail being composed.
* Spook: Distracting NSA.    How to distract the NSA's attention.
* Mail Methods::             Using alternative mail-composition methods.



File: emacs-ja, Node: Mail Format, Next: Mail Headers, Prev: Sending Mail, Up: Sending Mail

メイルバッファの形式
====================

メッセージにはテキスト、つまり、本文以外にも、誰が、いつ、誰に、なぜ送っ
たかなどを示す"ヘッダフィールド"があります。`Date'（日付）や
`Sender'（送り手）などのヘッダフィールドは、メッセージを送信するときに
自動的に作成されます。受け手（宛先）などの他のヘッダフィールドは、メッ
セージがきちんと送信されるようにあなた自身が指定する必要があります。

メイル（mail）モードには、ヘッダフィールドを編集するためのコマンド群が
あり、一部のヘッダフィールドはバッファ内で自動的に初期化されます。通常
の編集コマンドを使ってヘッダフィールドに挿入したり編集したりできます。

バッファ内のつぎの行は、ヘッダとテキストを分ける特別な区切り行です。

     --text follows this line--

この行のあとに続くものはすべてメッセージのテキストになります。このまえ
にあるものはヘッダです。実際に送信されるメッセージには、この区切り行自
身は含まれません。区切り行として使うテキストは変数
`mail-header-separator'で制御します。

以下は、メイルバッファ内のヘッダとテキストの例です。

     To: gnu@gnu.org
     CC: lungfish@spam.org, byob@spam.org
     Subject: The Emacs Manual
     --Text follows this line--
     Please ignore this message.



File: emacs-ja, Node: Mail Headers, Next: Mail Aliases, Prev: Mail Format, Up: Sending Mail

メイルヘッダフィールド
======================

メイルバッファ内のヘッダフィールドは、行頭のフィールド名で始まり、コロ
ン`:'で区切られます。フィールド名（およびメイルアドレス）では、大文字小
文字の区別はありません。コロンと省いてもよい白文字のあとにフィールドの
内容を書きます。

ヘッダフィールドには好き勝手にどんな名前でも使えますが、一般にはきちん
と意味のある標準的なフィールド名だけを使います。以下は送信メッセージで
一般的に使われるフィールドの一覧です。

`To'
     このフィールドには、メッセージの送付先であるメイルアドレスを書く。
     1つより多くのアドレスを書く場合には、空白ではなくコンマで区切る。

`Subject'
     `Subject'フィールドの内容としては、メッセージが何についてのものか
     を書く。`Subject'フィールドが有効な理由は、大部分のメイル閲覧プロ
     グラムが、各メッセージの本文ではなく`Subject'を使ってメイル一覧を
     表示するため。

`CC'
     このフィールドには`To'フィールドと同様にメッセージ送付先の追加メイ
     ルアドレスを書く。ただし、これらのアドレスにあげられた人達は、自分
     宛てのメッセージだとは思わないように。

`BCC'
     このフィールドにはメッセージ送付先の追加アドレスを書くが、実際に送
     付されるメッセージのヘッダにはこのフィールドは含まれない。このよう
     にして送信したコピーを"ブラインドカーボンコピー" （blind carbon
     copies）と呼ぶ。

     すべての送信メッセージのブラインドカーボンコピーを自分自身に送るに
     は、変数`mail-self-blind'に`t'を設定する。

`FCC'
     このフィールドには、メッセージを送信するたびにEmacsがそのコピーを
     追加していくファイルの名前を指定する。ファイルがrmail形式であれば、
     Emacsはメッセージをrmail形式で書き込む。それ以外の場合、Emacsはシ
     ステムメイルファイル形式で書き込む。

     送信メッセージを編集するたびに毎回決まったファイル名を`FCC'フィー
     ルドに指定するには、変数`mail-archive-file-name'にそのファイル名を
     設定する。送信メッセージから`FCC'フィールドを削除しない限り、メッ
     セージを送信するたびにこのファイルにメッセージが書き込まれる。

`From'
     `From'フィールドは、メイル送信時に使っているアカウントが自分のもの
     でない場合に、送信者が本当は誰なのかを示すために用いる。返信には通
     常このフィールドが使われるので、`From'フィールドの内容は正しいメイ
     ルアドレスであること。自分で`From'フィールドを指定しなければ、
     Emacsはデフォルトで変数`user-mail-address'の値を使う。

`Reply-to'
     返信を別のアドレスに送ってほしい場合にこのフィールドを使う。
     （rmailを含む）大部分のメイル閲覧プログラムは、
     `From'のアドレスより`Reply-to'のアドレスを優先して
     自動的に返信を送る。
     `Reply-to'フィールドをヘッダに加えておけば、
     `From'のアドレスが返信時に引き起こすであろうどんな問題でも回避できる。

     すべての送信メッセージの`Reply-to'フィールドに決まったアドレスを指
     定するには、変数`mail-default-reply-to'に（文字列で）そのアドレス
     を設定する。こうすると、`mail'は指定された`Reply-to'フィールドを付
     けてメッセージを初期化する。メッセージを送信するまえに、必要なら、
     このフィールドを削除したり変更したりできる。Emacsが動き始めたとき
     に環境変数`REPLYTO'が設定されていれば、その環境変数の値で変数
     `mail-default-reply-to'を初期化する。

`In-reply-to'
     このフィールドは返信しようとしているメッセージについての情報を書く。
     メイルシステムによっては、この情報を使ってメイルを互いに関連付ける。
     rmailでメッセージに返信するときには、rmailが自動的にこのフィールド
     を埋めるので、気にする必要はない（*Note Rmail::）。

`References'
     このフィールドには、関連する以前のメッセージのメッセージID一覧を書
     く。rmailでメッセージに返信するときには、rmailが自動的にこのフィー
     ルドを埋める。

ヘッダフィールド、`To'、`CC'、`BCC'、`FCC'は、いくつあってもよく、しか
も、これらの各フィールドにはコンマで区切って複数のアドレスを書けます。
こうすれば、メッセージの送付先をいくつでも指定できます。`To'、`CC'、
`BCC'フィールドでは継続行を使えます。これらのフィールドに続く白文字で始
まる行は、すべてフィールドの一部であると見なします。以下は継続行を用い
た`To'フィールドの例です。

     To: foo@here.net, this@there.net,
       me@gnu.cambridge.mass.usa.earth.spiral3281

メッセージを送信するときに、`From'フィールドを書いてないと、Emacsがかわっ
てこの項目を補います。変数`mail-from-style'でその書式を（以下のように）
制御します。

`nil'
     `king@grassland.com'のように電子メイルアドレスだけを補う。
`parens'
     `king@grassland.com (Elvis Parsley)'のように、電子メイルアドレスと
     氏名を補う。
`angles'
     `Elvis Parsley <king@grassland.com>'のように、氏名と電子メイルアド
     レスを補う。
`system-default'
     システムに`From'フィールドを埋めさせる。



File: emacs-ja, Node: Mail Aliases, Next: Mail Mode, Prev: Mail Headers, Up: Sending Mail

メイルの別名
============

`~/.mailrc'という名前のファイルで"メイルの別名" （mail alias）を定義で
きます。メイルの別名とは、複数のメイルアドレスやそれらのグループに付け
た覚えやすい短い名前のことです。他の多くのメイルプログラムと同様に、
`To'、`From'、`CC'、`BCC'、`Reply-to'のフィールドに別名が現れるとEmacs
は別名を展開し、当該フィールドの先頭に`Resent-'を付加します。

`~/.mailrc'ファイルで別名を定義するには、以下のような形式の行を書きます。

     alias SHORTADDRESS FULLADDRESSES

FULLADDRESSESは1つ以上のメイルアドレスであり、SHORTADDRESSをそれらのア
ドレスに展開します。複数のアドレスを書く場合は、空白で区切ります。アド
レスに空白が含まれる場合は、アドレス全体をダブルクォート`"'で括ります。

たとえば、`gnu@gnu.org'とあなたのローカルアドレスに対する別名を
`maingnu'とするには、つぎのように書きます。

     alias maingnu gnu@gnu.org local-gnu

また、Emacsは`.mailrc'ファイル内の「取り込み」コマンドも認識します。つ
ぎのように書きます。

     source FILENAME

ファイル`~/.mailrc'は主に他のメイル閲覧プログラムが使用するものです。こ
のファイルには、他にもさまざまなコマンドを指定できます。Emacsは、このファ
イル内の別名定義（`alias'）と取り込みコマンド（`source'）以外はすべて無
視します。

Emacsの中だけでメイルの別名を定義する別の方法は、`define-mail-alias'コ
マンドを使うことです。このコマンドは、別名と完全なアドレスを順次尋ねて
きます。これを使えば、つぎのようにして個人の`.emacs'ファイルで別名を定
義できます。

     (define-mail-alias "maingnu" "gnu@gnu.org")

 `define-mail-alias'は、`mail-aliases'という変数に別名を追加記録します。
Lispのリスト操作に慣れているなら、`mail-aliases'に直接設定してもかまい
ません。変数`mail-alias'の初期値は`t'となっていて、Emacsは`.mailrc'から
別名定義を読み込むという指定です。

`~/.mailrc'のかわりに使う別のファイルの名前は、変数
`mail-personal-alias-file'に設定します。

 通常、Emacsはメッセージ送信時に別名を展開します。送信に先だってみずか
らメイルアドレスを展開する必要はありませんが、メイルが実際にどこへ送信
されるか確認したければ別名を展開することもできます。そうするには、コマ
ンド`M-x expand-mail-aliases'を使います。アドレスを保持するメイルヘッダ
に書かれているすべてのメイルの別名を展開します。

もし好みに合うなら、メイルの別名を打ち込んだらただちに略語展開すること
もできます（*Note Abbrevs::）。この機能を使うにはつぎのようにします。

     (add-hook 'mail-setup-hook 'mail-abbrevs-setup)

これを個人の`.emacs'ファイルに入れてもかまいません。*Note Hooks::。この
機能を使う場合には、`define-mail-alias'のかわりに`define-mail-abbrev'を
使う必要があります。前者は、このパッケージでは動作しません。メイル用略
語パッケージでは、`mail-aliases'のかわりに変数`mail-abbrevs'を使い、さ
らに、すべての別名は小文字に変換されます。

メイル用略語パッケージには、`C-c C-a'
（`mail-interactive-insert-alias'）コマンドもあって、別名を（補完を使っ
て）読み取り、その定義をポイント位置に挿入します。この機能は、Emacsが別
名を通常展開しない本文や`Subject'フィールドなどを編集しているときに便利
です。

単語の区切り文字を挿入したあとで略語が展開されることに注意してください。
しかし、`C-n'と`M->'を再定義して展開が行われるように設定することもでき
ます。つぎのようにします。

     (add-hook 'mail-setup-hook
               '(lambda ()
                  (substitute-key-definition
                    'next-line 'mail-abbrev-next-line
                    mail-mode-map global-map)
                  (substitute-key-definition
                    'end-of-buffer 'mail-abbrev-end-of-buffer
                    mail-mode-map global-map)))



File: emacs-ja, Node: Mail Mode, Next: Distracting NSA, Prev: Mail Aliases, Up: Sending Mail

メイルモード
============

メイルバッファで使われるメジャーモードはメイル（mail）モードです。テキ
スト（text）モードに似ていますが、プレフィックス`C-c'で始まる多くの特別
なコマンドがあります。これらのコマンドはすべてメッセージの編集や送信に
関するものです。さらに、メイル（mail）モードでは、文字`%'を単語の切れ目
と定義しています。これは、単語コマンドを使ってメイルアドレスを編集する
ときに便利です。

`mail'コマンドやそれに関連するコマンドが自動的に設定するバッファでは、
普通、メイル（mail）モードを使います。しかし、ファイルを訪問しているバッ
ファをメイル（mail）モードに切り替えることもできます。これは、メッセー
ジの草稿をファイルに保存してあるときなどに便利です。

* Menu:

* Mail Sending::        Commands to send the message.
* Header Editing::      Commands to move to header fields and edit them.
* Citing Mail::         Copying all or part of a message you are replying to.
* Mail Mode Misc::      Spell checking, signatures, etc.



File: emacs-ja, Node: Mail Sending, Next: Header Editing, Prev: Mail Mode, Up: Mail Mode

メイルの送信
------------

メイル（mail）モードには、編集したメッセージを送信するコマンドが2つあり
ます。

`C-c C-s'
     メッセージを送信し、メイルバッファは選択したままにする
     （`mail-send'）。
`C-c C-c'
     メッセージを送信し、別のバッファを選択する（`mail-send-and-exit'）。

`C-c C-s'（`mail-send'）はメッセージを送信してメイルバッファに『変更な
し』の印を付けます（変更フラグをクリアする）。しかし、メッセージバッファ
は選択したままですから、メッセージを修正して（新たな受け手に）再度送信
できます。`C-c C-c'（`mail-send-and-exit'）はメッセージを送信してから、
ウィンドウを削除するか別のバッファに切り替えます。メイルバッファは使い
終えたので、デフォルトではその選択優先度は最低になります。普通はこのコ
マンドでメッセージを送信します。

ファイルを訪問しているバッファでは、メッセージ送信後でも変更フラグをク
リアしません。ファイルを保存した場合にだけ変更フラグをクリアすべきだか
らです。この結果、同一メッセージを2回送信しようとしても警告は出ません。

非ASCII文字を含むメッセージを送信するときには、それらをコーディングシス
テム（*Note Coding Systems::）で符号化する必要があります。通常、コーディ
ングシステムは、選択した言語環境（*Note Language Environments::）によっ
て自動的に指定されます。変数`sendmail-coding-system'を設定すると、送信
メイルのコーディングシステムを明示できます。

このように決めたコーディングシステムが、メッセージ内の文字を扱えない場
合には、Emacsは、可能なコーディングシステムの一覧を表示して、使用するコー
ディングシステムを問い合わせます。



File: emacs-ja, Node: Header Editing, Next: Citing Mail, Prev: Mail Sending, Up: Mail Mode

メイルヘッダの編集
------------------

メイル（mail）モードには、特定のヘッダフィールドへ移動したりヘッダのア
ドレスを補完する特別なコマンドがあります。

`C-c C-f C-t'
     ヘッダフィールド`To'へ移動する。フィールドがなければ作成する
     （`mail-to'）。
`C-c C-f C-s'
     ヘッダフィールド`Subject'へ移動する。フィールドがなければ作成する
     （`mail-subject'）。
`C-c C-f C-c'
     ヘッダフィールドへ`CC'移動する。フィールドがなければ作成する
     （`mail-cc'）。
`C-c C-f C-b'
     ヘッダフィールド`BCC'へ移動する。フィールドがなければ作成する
     （`mail-bcc'）。
`C-c C-f C-f'
     ヘッダフィールド`FCC'へ移動する。フィールドがなければ作成する
     （`mail-fcc'）。
`M-TAB'
     メイルアドレスを補完する（`mail-complete'）。

ポイントを特定のヘッダフィールドに移動するコマンドは5つあって、すべてプ
レフィックス`C-c C-f'で始まります（`C-f'は『フィールド』（fields）のf）。
これらは上に示してあります。当該フィールドが存在しなければ、これらのコ
マンドはそのフィールドを作成します。これらの特定のフィールドに移動する
コマンドを用意したのは、これらのフィールドを編集する可能性が高いからで
す。

`To:'、`CC:'、`BCC:'などのメイルアドレスを含むヘッダフィールドを編集中
には、`M-TAB'（`mail-complete'）と打てばメイルアドレスを補完できます。
完全な名前が決定できるならば、アドレスに対応する完全な名前を挿入します。
変数`mail-from-style'と同様に、変数`mail-complete-style'は、完全な名前
を挿入するのか、どのスタイルを使うのかを制御します（*Note Mail
Headers::）。

補完のため使う正しいメイルアドレスは、ローカルのユーザー名一覧と個人の
メイルの別名からとられます。正しいメイルアドレスの情報源を追加すること
もできます。これに関するオプションを調べるには、カスタマイズバッファを
使ってください。

メッセージの本文で`M-TAB'と打つと、テキスト（text）モードと同様に
`ispell-complete-word'を起動します。



