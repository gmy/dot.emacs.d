Info file: emacs-ja,    -*-Text-*-
produced by `texinfo-format-buffer'
from file `emacs.texi'
using `texinfmt.el' version 2.41 of  1 Mar 2005.

INFO-DIR-SECTION Emacs
START-INFO-DIR-ENTRY
* Emacs-ja: (emacs-ja).	            Emacs21.3日本語マニュアル.
END-INFO-DIR-ENTRY








File: emacs-ja, Node: Library Keywords, Next: Language Help, Prev: Apropos, Up: Help

Lispライブラリに対するキーワード探索
====================================

`C-h p'コマンドで、標準Emacs Lispライブラリをトピックのキーワードで検索
できます。利用可能なキーワードの一部を以下に示します。

     abbrev -- 略語操作、短縮入力、マクロ。
     bib -- 参考、参照プロセッサ支援`bib'。
     c -- C言語あるいはC++支援。
     calendar -- 日付および時間管理支援。
     comm -- 通信、ネットワーク、ファイルのリモートアクセス。
     data -- データファイルの編集支援。
     docs -- Emacsドキュメントに関する支援。
     emulations -- 他のエディタのエミュレーション。
     extensions -- Emacs Lisp言語の拡張。
     faces -- フェイス（フォントや表示色、*Note Faces::）に関する支援。
     frames -- Emacsフレームやウィンドウシステムに対する支援。
     games -- ゲーム、ジョーク、娯楽。
     hardware -- 外部ハードウェアとのインターフェイス支援。
     help -- オンラインヘルプシステム支援。
     hypermedia -- テキストあるいは他メディア内でのリンク支援。
     i18n -- 国際化、代替文字集合支援。
     internal -- Emacs内部コード、構築手順、デフォルト。
     languages -- プログラム言語編集用の特殊モード。
     lisp -- Lisp利用支援（Emacs Lispも含む）。
     local -- サイトにローカルなライブラリ。
     maint -- Emacs開発グループ向けの管理用。
     mail -- 電子メイル操作用のモード。
     matching -- 探索、一致。
     news -- ネットニュースの購読、投稿支援。
     non-text -- 非テキストファイル編集支援。
     oop -- オブジェクト指向プログラミング支援。
     outlines -- 階層アウトライン。
     processes -- プロセス、サブシェル、コンパイル、ジョブ制御支援。
     terminals -- 端末タイプ支援。
     tex -- TeXによる文書整形支援。
     tools -- プログラミングツール。
     unix -- UNIX機能のフロントエンド／アシスタントあるいはエミュレーション。
     vms -- VMS支援コード。
     wp -- ワープロ。



File: emacs-ja, Node: Language Help, Next: Help Mode, Prev: Library Keywords, Up: Help

多言語支援に関するヘルプ
========================

コマンド`C-h L'（`describe-language-environment'）を使うと、特定の言語
環境向けに、どのような支援があるかを把握できます。*Note Language
Environments::。このコマンドは、今の言語環境がどの言語向けなのかを示し、
一緒に使われる文字集合、コーディングシステム、入力方式も表示します。ま
た、字体を例示するためのサンプルテキストもいくつか表示します。

コマンド`C-h h'（`view-hello-file'）は、ファイル`etc/HELLO'を表示します。
このファイルには、いろいろな国の言葉で書いた『hello』を収めてあります。

コマンド`C-h I'（`describe-input-method'）は、
指定した入力方式、あるいは、デフォルトとして
今使っている入力方式についての情報を表示します。
*Note Input Methods::。

コマンド`C-h C'（`describe-coding-system'）は、
指定したコーディングシステム、あるいは、デフォルトとして
今使っているコーディングシステムについての情報を表示します。
*Note Coding Systems::。



File: emacs-ja, Node: Help Mode, Next: Misc Help, Prev: Language Help, Up: Help

ヘルプモードのコマンド
======================

ヘルプバッファには、閲覧（view）モード（*Note Misc File Ops::）のコマン
ドに加えて、独自の特別なコマンドもいくつかあります。

`SPC'
     前向きにスクロールする。
`DEL'
     後向きにスクロールする。
`RET'
     ポイント位置の相互参照を辿る。
`TAB'
     つぎの相互参照へ進む。
`S-TAB'
     まえの相互参照へ戻る。
`Mouse-2'
     クリックした相互参照を辿る。

説明文に現れるコマンド名（*Note M-x::）や変数名（*Note Variables::）は
通常、引用符（`''）で囲まれています。その名前を`Mouse-2'でクリックした
り、あるいは、そこへポイントを移動してRETを打つと、そのコマンドや変数の
説明文字列を表示できます。もとの場所に戻るには`C-c C-b'を使います。

ヘルプテキスト内の相互参照にポイントを移動する便利なコマンドがあります。
TAB（`help-next-ref'）は、
ポイントをつぎの相互参照箇所へ進めます。
ポイントをまえの相互参照箇所へ戻すには
`S-TAB'（`help-previous-ref'）を使います。



File: emacs-ja, Node: Misc Help, Prev: Help Mode, Up: Help

その他のヘルプコマンド
======================

`C-h i'（`info'）はinfoプログラムを実行します。infoは構造化されたドキュ
メントファイルを閲覧するプログラムです。Emacsの完全なマニュアルもinfoで
読むことができます。将来的には、GNUシステムのすべてのドキュメントが読め
るようになるでしょう。infoの使い方についてのチュートリアルを起動するに
は、infoに入ってから`h'と打ちます。

数引数を指定すると、`C-h i'はドキュメントファイルの名前を聞いてきます。
こうすれば、トップレベルのinfoメニューに記載されていないファイルでも閲
覧できます。

infoを介してEmacsドキュメントを参照するための
特別なヘルプコマンドが2つあります。
`C-h C-f FUNCTION RET'は、
infoに入ってただちにEmacsの関数FUNCTIONのドキュメントに移動します。
`C-h C-k KEY'は、
infoに入ってただちにキーKEYのドキュメントに移動します。
これら2つのキーは、それぞれ、
`Info-goto-emacs-command-node'、
`Info-goto-emacs-key-command-node'を実行します。

プログラム言語のinfo版のマニュアルがあれば、プログラムの編集中にコマン
ド`C-h C-i'を使って、マニュアルドキュメントのシンボル（キーワード、関数、
変数）に関する箇所を参照できます。コマンドの細かい動作は、メジャーモー
ドに依存します。

予期しなかったことが起きたり、入力したコマンドがわからなくなってしまっ
たときは、`C-h l'（`view-lossage'）を使ってください。`C-h l'は、それま
でに打鍵した最後の100個のコマンド文字を表示します。知らないコマンドが表
示されたら、`C-h c'でその機能を知ることができます。

Emacsには数多くのメジャーモードがあり、各メジャーモードでは、いくつかの
キーを再定義し、編集動作も少々変更しています。`C-h m'（`describe-mode'）
は、使用中のメジャーモードについての説明文を表示します。これには、通常、
モード内で変更してあるすべてのコマンドについての記述があります。

`C-h b'（`describe-bindings'）と`C-h s'（`describe-syntax'）は、Emacsの
現在のモードに関するその他の情報を与えてくれます。`C-h b'は、現在有効な
すべてのキーバインドの一覧を表示します。マイナモードで定義されているロー
カルバインディングから始めて、現在のメジャーモードで定義されているロー
カルバインディング、最後にグローバルバインディングを表示します（*Note
Key Bindings::）。`C-h s'は、各文字の構文の説明を付けて構文テーブルの内
容を表示します（*Note Syntax::）。

プレフィックスキーに続けて`C-h'を打てば、特定のプレフィックスキーについ
て同様な一覧を表示できます。（この方法では表示できないプレフィックスキー
も存在する。それらのキーでは、`C-h'に対しては独自のバインディングがある。
ESCは、そのようなものの1つ。`ESC C-h'は、実際には`C-M-h'であり、関数定
義（defun）をマークする。）

`C-h'の他のオプションは、有益な情報を収めたさまざまなファイルを表示しま
す。`C-h C-w'は、GNU Emacsがまったく無保証であることに関する全詳細を表
示します。`C-h n'（`view-emacs-news'）は、ファイル`emacs/etc/NEWS'を表
示します。このファイルには、Emacsの変更に関する記述を時間順に収めてあり
ます。`C-h F'（`view-emacs-FAQ'）は、Emacsの「よくある質問集」を表示し
ます。`C-h t'（`help-with-tutorial'）は、「操作しながらEmacsを学ぶ」
チュートリアルを表示します。`C-h C-c'（`describe-copying'）は、ファイル
`emacs/etc/COPYING'を表示します。このファイルには、Emacsを配布する場合
に従うべき条件を記述してあります。`C-h C-d'（`describe-distribution'）
は、ファイル`emacs/etc/DISTRIB'を表示します。このファイルには、Emacsの
最新版の注文方法を述べてあります。`C-h C-p'（`describe-project'）は、
GNUプロジェクトに関する一般情報を表示します。


File: emacs-ja, Node: Mark, Next: Killing, Prev: Help, Up: Top

マークとリージョン *(2005/03/20)*
*********************************

Emacsの数多くのコマンドは、カレントバッファの任意の連続領域を操作します。
このようなコマンドに操作対象となるテキストを指定するには、その一方の端
に"マーク"（mark）を置き、もう一方の端にポイントを移動します。ポイント
とマークに挟まれたテキストを"リージョン"（region）と呼びます。暫定マー
ク（transient-mark）モードをオンにすると、リージョンが存在すればEmacsは
つねにそのリージョンを強調表示します（*Note Transient Mark::）。

ある種の Emacs コマンドはマークを設定します．他の編集コマンドはマークに
影響を及ぼしませんから，マークは最後につけた位置のまま残ります．Emacs
のバッファはそれぞれ個々にマークを保存しています．そして，あるバッファ
でマークを行っても，他のバッファのマークには影響しません．以前に選択し
ていたあるバッファに戻ると，以前と同じ場所のままの位置にマークはありま
す．

リージョンの終わりはいつもポイントとマークです．どちらが先に置かれたか
やどちらがテキストの先頭近くにあるかは問題ではありません――リージョン
は(どちらが先であろうと)ポイントかマークで始まり，(どちらが後にこよう
と)ポイントかマークで終わるのです．ポイントを動かすかマークを新しい場所
につけると，リージョンが変わります．

`C-y'（`yank'）や`M-x insert-buffer'などのテキストを挿入するコマンドの
多くは、挿入したテキストの両端にポイントとマークを置いて、挿入したテキ
ストがリージョンに含まれるようにします。

リージョンの境界を定めること以外に、
あとで戻る可能性のある箇所を覚えておくためにもマークを使えます。
この機能をより使いやすくするために、
各バッファでは、それまでに設定した16個のマーク位置を
"マークリング"（mark ring）に記録しています。

* Menu:

* Setting Mark::	Commands to set the mark.
* Transient Mark::	How to make Emacs highlight the region--
			  when there is one.
* Momentary Mark::      Enabling Transient Mark mode momentarily.
* Using Region::	Summary of ways to operate on contents of the region.
* Marking Objects::	Commands to put region around textual units.
* Mark Ring::	Previous mark positions saved so you can go back there.
* Global Mark Ring::    Previous mark positions in various buffers.



File: emacs-ja, Node: Setting Mark, Next: Transient Mark, Prev: Mark, Up: Mark

マークを設定する *(2005/03/20)*
===============================

マークを設定するコマンドはつぎのとおりです。

`C-SPC'
     ポイント位置にマークを置く（`set-mark-command'）。
`C-@'
     上と同様。
`C-x C-x'
     マークとポイントを入れ換える（`exchange-point-and-mark'）。
`Drag-Mouse-1'
     ドラッグしたテキストの周囲にポイントとマークを設定する。
`Mouse-3'
     ポイント位置にマークを設定し、クリックした箇所にポイントを移動する
     （`mouse-save-then-kill'）。

たとえば、コマンド`C-x C-u'（`upcase-region'）を使って、バッファのある
部分をすべて大文字に変換したいとしましょう。このコマンドは、リージョン
中のテキストに作用します。まず、大文字に変換したいテキストの先頭に移動
し、`C-SPC'と打ってマークを設定します。続いてテキストの終端に移動して
`C-x C-u'と打ちます。あるいは、先にテキストの終端にマークを設定して、テ
キストの始点に移動してから`C-x C-u'と打ちます。

マークを設定するもっとも一般的な方法は、`C-SPC'コマンド
（`set-mark-command'）を使うことです。このコマンドは、ポイント位置にマー
クを設定します。そうすれば、マークを置いたままで、ポイントを移動できま
す。

マウスを使ったマークの設定方法は2つあります。
テキストのある範囲でマウスボタン1をドラッグします。
マウスボタンを離した位置にポイントが置かれ、
ドラッグを開始した箇所にマークが設定されます。
あるいは、マウスボタン3をクリックします。
これは（`C-SPC'と同様に）ポイント位置にマークを設定してから、
ポイントを（`Mouse-1'のように）移動します。
両者は、マークを設定するだけでなく、リージョンをキルリングにコピーします。
これは、他のウィンドウアプリケーションの動作と一貫性を持たせるためです。
キルリングを変更したくなければ、
キーボードコマンドを使ってマークを設定する必要があります。
*Note Mouse Commands::。

普通の端末にはカーソルは1つしかありませんから、Emacsにはマークを置いた
位置を表示する術はありません。ユーザーがその位置を覚えておく必要があり
ます。この問題に対する通常の解決方法は、マークを設定したら、忘れてしま
うまえにただちにそれを利用することです。あるいは、`C-x
C-x'（`exchange-point-and-mark'）コマンドを使って、マーク位置を確認しま
す。このコマンドは、ポイント位置にマークを置き、マークのあった位置にポ
イントを置きます。リージョンの範囲は変わらずに、カーソルとポイントは以
前マークのあった箇所に移動します。暫定マーク（transient-mark）モードで
は、このコマンドはマークを再度活性にもします。

ポイント位置を変えずに、リージョンのもう一方の端（マークの位置）を移動
させたい場合にも、`C-x C-x'は便利な方法です。まず、`C-x C-x'でポイント
をリージョンの一方の端に移して、その端を移動します。必要ならば、2回
`C-x C-x'を使って新しい位置にマークを置き、ポイントをもとの位置に戻しま
す。

以前につけたマークへ行けるようにする機能については，*Note Mark Ring::
を参照してください．

  There is no such character as `C-SPC' in ASCII; when you type SPC
while holding down CTRL, what you get on most ordinary terminals is
the character `C-@'.  This key is actually bound to
`set-mark-command'.  But unless you are unlucky enough to have a
terminal where typing `C-SPC' does not produce `C-@', you might as
well think of this character as `C-SPC'.  Under X, `C-SPC' is actually
a distinct character, but its binding is still `set-mark-command'.
ASCII には、`C-SPC'という文字は存在しません。CTRLを押し下げながらSPCを
打つと、ほとんどの普通の端末では文字`C-@'になります。このキーは、実際に
`set-mark-command'にバインドしてあります。ただし、幸運にも`C-SPC'で
`C-@'を送出する端末を使っているのであれば、`C-@'を`C-SPC'とみなしてかま
いません。Xウィンドウシステムでは、`C-SPC'は実際には別の文字として認識
されますが、そのバインドはやはり`set-mark-command'です。



File: emacs-ja, Node: Transient Mark, Next: Momentary Mark, Prev: Setting Mark, Up: Mark

暫定マークモード（transient-markモード） *(2005/03/20)*
=======================================================

カラー表示が可能な端末では，Emacsはカレントリージョンを強調表示できます。
ただし、通常はリージョンを強調表示しません。なぜでしょうか？

あるバッファで，いったんマークを設定してしまうと、そのバッファ内には*つ
ねに*リージョンが存在することになります．これは，すべてのコマンドはマー
クを設定し，リージョンをアクティブにするが，リージョンを無効にするもの
は何もないからです．リージョンを強調表示し続けても迷惑なだけでしょう．
だから，通常，Emacs はマウスで選択した直後しかリージョンを強調表示しま
せん．

もしリージョンの強調表示を望むのであれば，暫定マーク（transient-mark）
モードをオンにすることで可能になります．暫定マーク（transient-mark）モー
ドは、リージョンがいつもそれを使うまでの一時的にしか『存続』しない、通
常よりきびしい操作モードです。ユーザーは、リージョンを使うコマンドごと
に明示的にリージョンを設定する必要があります。暫定マーク
（transient-mark）モードでは、ほとんどの期間、リージョンは存在しません。
それゆえ、リージョンが存在するときにリージョンを強調表示しても役立ちま
すし，邪魔になりません。暫定モードが有効の時，Emacs はリージョンがあれ
ばいつもリージョンを強調表示します．

暫定マーク（transient-mark）モードをオンにするには、`M-x
transient-mark-mode'と打ちます。このコマンドはモードのオン／オフを切り
替えますから、モードをオフにしたいときには同じコマンドを使うことができ
ます．

暫定マーク（transient-mark）モードの詳細を以下に示します。

   * マークを設定するには、`C-SPC'（`set-mark-command'）と打つ。この操
     作はマークを活性にし，リージョンの強調表示を開始します．ポイントを
     移動するたびに、強調表示されたリージョンが広がったり狭まったりしま
     す。

   * マークを設定するマウスコマンドも、マークを活性にする。`M-@'、
     `C-M-@'、`M-h'、`C-M-h'、`C-x C-p'、`C-x h'などのリージョンを設定
     するためのキーボードコマンドもマークを活性にする。

   * 強調表示されているため，マークがアクティブであると分かります．

   * マークが活性ならば、キル、字下げ、ファイルへの書き出しなどのリージョ
     ンを操作するコマンドを実行できる。

   * 文字の挿入や削除といったバッファに対する変更は、マークを不活性にす
     る。つまり、これ以降にリージョンを操作するコマンドを実行するとエラー
     となり、実行は拒否される。リージョンを再度活性にするには、`C-x
     C-x'と打つ。

   * `C-g' による中止でマークをアクティブではなくすことができます．

   * `M->'や`C-s'のような、本来の目的を達成したあとに『マークを残す』
     種類のコマンドは、新しいマークを活性にしない。
     このような新しいリージョンを活性にするには、
     `C-x C-x'（`exchange-point-and-mark'）を実行する。

   * マークが活性であるときには、`C-s'はマークを変更しない。

   * いくつかのコマンドはリージョンが活性であれば，リージョンに対して処
     理を行います．例えば，暫定マークモードでリージョンがある時に，
     `C-x u' とすると，リージョンに対しての操作になります (暫定マークモー
     ド以外で，リージョンに対して操作を行いたい時には，`C-u C-x u' とし
     なければなりません)．*Note Undo::．この方法で実行する他のコマンド
     については，ドキュメントを参照してください．

リージョンの強調表示には、`region'フェイスを使います。このフェイスを変
更すれば、リージョンの強調表示方法をカスタマイズできます。

複数のウィンドウで同じバッファを表示しているときには、それぞれのウィン
ドウで別の部分を表示できます。というのは、（マーク位置は共有されるが）
各ウィンドウごとに別々にポイントの値があるからです。通常、選択されたウィ
ンドウでのみ、リージョンを強調表示します（*Note Windows::）。しかし、変
数`highlight-nonselected-windows'に`nil'以外を設定すると、（暫定マーク
（transient-mark）モードがオンであり、かつ、ウィンドウのバッファのマー
クが活性である場合に限り）各ウィンドウでそれぞれのリージョンを強調表示
します。

暫定マーク（transient-mark）モードにおいて、変数
`mark-even-if-inactive'が`nil'以外であると、マークが不活性であってもコ
マンドはマークやリージョンを利用できます。通常の暫定マーク
（transient-mark）モードと同様に、リージョンが強調表示されたりされなかっ
たりしますが、強調表示されていなくてもマークが本当になくなることはあり
ません。だから，今でもリージョンに対するコマンドを実行できるのです．

暫定マーク（transient-mark）モードは『zmacsモード』としても知られていま
す。というのも、MITのLispマシン上で動作していたZmacsエディタが同じよう
にマークを扱っていたからです。



File: emacs-ja, Node: Momentary Mark, Next: Using Region, Prev: Transient Mark, Up: Mark

暫定マークモードをちょっとの間のみ使う *(2005/03/20)*
=====================================================

暫定マークモードを通常は使いたくないが，ちょっとの間だけ使いたいかもし
れない．これを実現するためには，`C-SPC C-SPC' や `C-u C-x C-x' と入力し
ます．これらのコマンドでマークを設定したり，有効にすると，マークが不活
性になるまで暫定マークモードが有効になります．

`C-SPC C-SPC'
     ポイントの位置にマークを設定します (通常の `C-SPC' のように)．そし
     て，マークが不活性になるまで，暫定マークモードを有効にします．(実
     際には，これらは別のコマンドではありません．`C-SPC' を2度使ってい
     るのです)

`C-u C-x C-x'
     マークを変更せずに活性にし，マークが不活性になるまで，暫定マークモー
     ドを有効にします (これは `C-x C-x' (`exchange-point-and-mark') を
     数引数付きで実行したものです)．

暫定マークモードの第二の機能は，リージョンが活性な時，いくつかの操作が
リージョンに対して実行されるのです．もし暫定マークモードを使わないので
あれば，一度設定したリージョンは決して不活性にはなりません．だから，こ
れらのコマンドがリージョンに対して操作を変える区別を付ける方法がないの
です．暫定マークモードを一時的に有効にさせることで，リージョンのみを対
象に操作を行うことができるのです．

こうして，一時的に暫定マークモードを有効にすることで，リージョンがある
間，強調表示できます．



File: emacs-ja, Node: Using Region, Next: Marking Objects, Prev: Momentary Mark, Up: Mark

リージョンに対する操作 *(2005/03/20)*
=====================================

いったんリージョンを設定しマークを活性にすれば、以下のようにリージョン
を操作できます。

   * `C-w'コマンドでキルする（*Note Killing::）。
   * `C-x r s'でレジスタに保存する（*Note Registers::）。
   * バッファやファイルに保存する（*Note Accumulating Text::）。
   * `C-x C-l'や`C-x C-u'で大文字小文字を変換する（*Note Case::）。
   * `C-x TAB'や`C-M-\'で字下げする（*Note Indentation::）。
   * `M-x fill-region'でテキストを詰め込む（*Note Filling::）。
   * `M-x print-region'でハードコピーを印刷する（*Note Hardcopy::）。
   * `M-x eval-region'でLispコードとして評価する（*Note Lisp Eval::）。

リージョン内のテキストを操作するコマンドの多くは、その名前に`region'と
いう単語を含みます。



File: emacs-ja, Node: Marking Objects, Next: Mark Ring, Prev: Using Region, Up: Mark

テキストオブジェクトをマークするコマンド *(2005/03/20)*
=======================================================

単語、リスト、段落、ページといったテキストのまとまりにポイントやマーク
を置くコマンドがあります。

`M-@'
     つぎの語の末尾にマークを設定する（`mark-word'）。このコマンドとつ
     ぎのコマンドはポイントを移動しない。
`C-M-@'
     つぎのバランスした式の末尾にマークを設定する（`mark-sexp'）．
`M-h'
     現在の段落を囲むリージョンを設定する（`mark-paragraph'）。
`C-M-h'
     現在の関数定義（defun）を囲むリージョンを設定する（`mark-defun'）。
`C-x h'
     バッファ全体をリージョンとする（`mark-whole-buffer'）。
`C-x C-p'
     現在のページを囲むリージョンを設定する（`mark-page'）。

`M-@'（`mark-word'）がつぎの語の末尾にマークを設定するのに対し、
`C-M-@'（`mark-sexp'）はつぎのバランスした式の末尾にマークを設定します。
これらのコマンドは、`M-f'や`C-M-f'と同様に引数を扱います。もし，これらの
コマンドを繰り返すとリージョンが拡張されます．例えば，`C-u 2 M-@' か
`M-@ M-@' と入力すると，2単語がマークされます．

その他のコマンドは、ポイントとマークの両方を設定して、バッファ内で対象物を区切り
ます。たとえば、`M-h'（`mark-paragraph'）は、ポイントを囲むあるいはポイ
ントに続く段落の先頭にポイントを移動し、その段落の末尾にマークを置きます
（*Note Paragraphs::）。このようにリージョンを設定するので、段落全体を字下げした
り、大文字小文字を変換したり、キルしたりできます。正の数引数付きで実行すると，
`M-h' は続くパラグラフを指定した数だけマークします．-N の数引数
を付けると，`M-h' はカーソル位置から N 段落逆昇っただけの段落がマーク
されます．最後の場合には，ポイントは段落の最後に移動します．`M-h' は
`M-@' や `C-M-@' と同様にリージョンの拡張も行います．

`C-M-h'（`mark-defun'）も同様に、現在の(あるいは，後続の)トップレベル定
義や関数定義の先頭にポイントを置き、その末尾にマークを置きます (*Note
Moving by Defuns::)．(現在では，1つの式だけをマークしますが，繰り返すこ
とで `M-@' のように，より多くの式をマークすることができます)．`C-x
C-p'（`mark-page'）は、現在のページの先頭にポイントを置き、その末尾にマー
クを置きます（`mark-page'）。マークはページ区切りの直後に設定され（リー
ジョンに含まれる）、一方、ポイントはページ区切りの直後に置かれます（リー
ジョンに含まれない）。数引数で、現在のページのかわりに（正ならば）後続
のページや、（負ならば）先行するページを指定できます。

最後に紹介する`C-x h'（`mark-whole-buffer'）は、バッファ全体にリージョ
ンを設定します。つまり、ポイントをバッファの先頭に置き、マークをバッファ
の末尾に置きます。

暫定マーク（transient-mark）モードでは、これらのコマンドはすべて、マー
クを活性にします。



File: emacs-ja, Node: Mark Ring, Next: Global Mark Ring, Prev: Marking Objects, Up: Mark

マークリング *(2005/03/20)*
===========================

マークには、リージョンを区切る以外にも、あとで戻る可能性のある箇所を記
録するという便利な使い方があります。この機能をより便利にするために、各
バッファでは以前の16箇所のマーク位置を"マークリング"（mark ring）に記録
しています。マークを設定するコマンドは、古いマークをこのマークリングに
入れます。マークを設定していた箇所に戻るには、`C-u C-SPC'（または`C-u
C-@'）を使います。これは、`set-mark-command'コマンドに数引数を指定した
ものです。このコマンドは、マークがあった箇所にポイントを移動し、それ以
前のマークを収めたマークリングからマークを復元します。

`C-u C-SPC' に続けて `C-SPC' を繰り返すと，マークリング上にある過去のマー
クのすべてを1つ1つ遡って移動できます。このように辿ったマーク位置は、マー
クリングのうしろに付け加えられるので、なくなってしまうことはありません。

各バッファには独自のマークリングがあります。すべての編集コマンドは、カ
レントバッファのマークリングを使います。特に、`C-u C-SPC'は、つねに同じ
バッファに留まります。

`M-<'（`beginning-of-buffer'）のような長距離を移動するコマンドの多くは、
まずマークを設定して、古いマークをマークリングに保存してから動作を開始
します。このようにして、あとで簡単に戻れるようにしておきます。探索コマ
ンドは、ポイントを移動するときにはマークを設定します。コマンドがマーク
を設定したかどうかは、エコー領域に`Mark set'と表示されるのでわかります。

何度も同じ場所に戻りたい場合には、マークリングでは不十分でしょう。この
ような場合には、あとで使うために位置情報をレジスタに記録できます
（*Note Saving Positions in Registers: RegPos.）。

変数`mark-ring-max'は、マークリングに保存する最大項目数を指定します。す
でに多くの項目が存在していて、さらにもう1つ押し込むときには、リスト内の
最も初期の項目を捨てます。`C-u C-SPC'を繰り返し実行すると、いまマークリ
ングに入っている位置を巡回することになります。

変数`mark-ring'は、最新のマーカオブジェクトを先頭にして、マーカオブジェ
クトのリストとしてマークリングを保持します。この変数は各バッファにロー
カルです。



File: emacs-ja, Node: Global Mark Ring, Prev: Mark Ring, Up: Mark

グローバルマークリング *(2005/03/20)*
=====================================

個々のバッファごとの普通のマークリングに加えて、Emacsには"グローバルマー
クリング"（global mark ring）が1つあります。グローバルマークリングは、
最近マークを設定したバッファの系列を記録しますから、それらのバッファに
戻ることができます。

マークを設定すると、つねにカレントバッファのマークリングに項目を作りま
す。マークを設定した以降にバッファを切り替えていると、新しくマークを設
定するとグローバルマークリングにも項目を作成します。その結果、グローバ
ルマークリングには訪れていたバッファの系列が記録され、各バッファではマー
クを設定した箇所が記録されます。

コマンド`C-x C-SPC'（`pop-global-mark'）は、グローバルマークリングの最
新の項目が示すバッファの位置に移動します。グローバルマークリングも巡回
されるので、`C-x C-SPC'を繰り返し使用すると、1つずつまえのバッファに移
動できます。




File: emacs-ja, Node: Killing, Next: Yanking, Prev: Mark, Up: Top

削除とキル *(2005/03/20)*
=========================

バッファからテキストを消しさるコマンドのほとんどは、
そのテキストをキルリングにコピーしておくので、
バッファの他の部分にそのテキストを移動したりコピーしたりできます。
これらのコマンドを、"キル"（kill）コマンドと呼びます。
それ以外の『テキストを消すコマンド』は、
テキストをキルリングに保存しません。
これらを"削除"（delete）コマンドと呼びます。
（両者を区別するのは、バッファ内のテキストを消す場合だけ。）
キルコマンドや削除コマンドを誤って実行してしまった場合には、
`C-x u'（`undo'）コマンドを使って、もとに戻すことができます。

読み込み専用のテキストは変更ができませんので，キルすることはできません．
しかし，実際には変更しないで，読み込み専用のテキストをコピーするために
キルコマンドを使いたいこともあるでしょう．変数 `kill-read-only-ok' を非
n-`nil' にしておくと，キルコマンドは読み込み専用のバッファで特別な働き
をします：つまり，テキストを移動して，それをキルリングへコピーするので
す．バッファから実際にテキストを削除することはしません．この処理が実行
されると，エコー領域にそのことが表示されます．

削除コマンドには、一度に1つの文字だけを削除する
`C-d'（`delete-char'）やDEL（`delete-backward-char'）、
空白や改行だけを削除するコマンドがあります。
単純ではないデータをかなりの分量で破壊する可能性のあるコマンドは、
一般にキルを変わりに行います。
コマンド名や個々の説明では、そのコマンドがどちらの働きをするかによって、
`キル'（kill）と`削除'（delete）を使い分けています。

ウィンドウシステムでは，他のプログラムでコピーした時よりも新しければ，
Emacs です直前にコピーしたテキストが1番に選択されます．つまり，他のソフ
トで貼り付けを行うと，Emacsでキルしたテキストが貼り付けられるのです．

多くのウィンドウシステムでは，テキストが選択されている時に文字を入力す
ると選択されたテクストが削除されるという習わしがあります．`M-x
delete-selection-mode' かカスタムで Delete Selection mode を有効にする
ことで， Emacs でもこのようなことを実現できます．このモードを有効にする
と，テキストを選択した状態で DEL や`C-d'，他のキーを押すと選択範囲全体
が消去されます．このモードは Transient Mark mode (*Note Transient
Mark::) も有効にします．

* Menu:

* Deletion::            Commands for deleting small amounts of text and
                          blank areas.
* Killing by Lines::    How to kill entire lines of text at one time.
* Other Kill Commands:: Commands to kill large regions of text and
                          syntactic units such as words and sentences.



File: emacs-ja, Node: Deletion, Next: Killing by Lines, Prev: Killing, Up: Killing

削除 *(2005/03/20)*
-------------------

削除とはキルリングに保存することなくテキストを消すことです．ほとんどの
場合，Emacs のコマンドは1文字だけや空白のみを削除します．

`C-d'
`Delete'
     つぎの文字を削除する（`delete-char'）。もし，キーボードに Delete キー
     (大抵は編集用キーパッドにあります) があれば，Emacs はそのキーを
     `delete-char' に割り当てます．
`DEL'
`BS'
     まえの文字を削除する（`delete-backward-char'）。いくつかのキーボー
     ドではこのキーを"backspace key"と書かれ，左矢印が描かれています．
`M-\'
     ポイントの周りの空白とタブを削除する（`delete-horizontal-space'）。
`M-SPC'
     ポイントの周りの空白とタブを削除し、空白を1個だけ残す
     （`just-one-space'）。
`C-x C-o'
     現在行の周りの空行を削除する（`delete-blank-lines'）。
`M-^'
     行間の改行とそれに続く字下げを削除して2行を繋げる
     （`delete-indentation'）。

もっとも基本的な削除コマンドは、`C-d'（`delete-char'）と
DEL（`delete-backward-char'）です。`C-d'はポイントの直後の文字、つまり、
カーソルが重なっている文字を削除します。このコマンドでは、ポイントは動
きません。DELはカーソルの直前の文字を削除して、ポイントを1つまえに移動
します。バッファ内の他の文字と同様に、改行も削除できます。改行を削除す
ると、2つの行が繋がります。実際には、`C-d'とDELがつねに削除コマンドであ
るわけではありません。引数を指定するとキルコマンドとなり、同じ方法で2文
字以上を消すことができます。

すべてのキーボードは DEL や BACKSPACE，BS，DELETE などと印刷されたキー
があります．これらのキーは RET や ENTER キー上の近くにあり，大抵入力し
た文字を削除するのに使われます．実際の名前やキーによらず，Emacs ではど
ちらのキーも DEL と同じになるか，そうあるべきなのです．

多くのキーボード (標準的な PC のキーボードを含む) では BACKSPACE キー が
RET や ENTER キーのすぐ上にあります．そして，DELETE キーがまた
別のところにあります．その場合，BACKSPACE キーは DEL として働き，
DELETE キーは `C-d' と同じであるか，，そうあるべきなのです．

なぜ"そうあるべきなのです"と書いているのか？ ウィンドウシステムで
Emacs を起動すると，どのキーが DEL と等価であるかを自動的に決定します．
普通，結果としてBACKSPACEと(か) DELETE をそのように決定します．しかし，
うまくいかない場合には Emacs はシステムから誤った情報を受け取ります．も
し，これらのキーがすべき機能を果たしていなければ，どのキーを DEL として
使うべきか設定する必要があります．*Note DEL Does Not Delete:: を参照し
てください．


大抵のテキスト端末では，Emacsは実際にどのキーがあるか判断できません．だ
から，あなたのキーボードに合うかどうかに関わらず，標準的な設定が使われ
ます．標準的な設定とは，ASCII DEL キーは文字を削除し，ASCII BS
(backspace) キーはヘルプ (`C-h'と同じ) になります．もし，ヘルプを表示す
る代わりに前方へ削除すべきキーがあるといったように，あなたのキーボード
で正しく動作していなければ，*Note DEL Does Not Delete:: を参照してくだ
さい．

他の削除コマンドは、空白、タブ、改行といった白文字だけを削除します。
`M-\'（`delete-horizontal-space'）は、ポイントの前後にあるすべての空白
とタブ文字を削除します。`M-SPC'（`just-one-space'）も同様に削除しますが、
今ある空白の個数に関係なく（たとえ無かったとしても）、ポイントの直後に
空白を1個だけ残します。

`C-x C-o'（`delete-blank-lines'）は、現在行に続くすべての空行を削除しま
す。現在行が空行である場合には、（空行である現在行だけを残して）先行す
る空行も同様にすべて削除します。

`M-^'（`delete-indentation'）は、
改行とその周りの空白を削除して、
通常は空白を1個残して現在行と先行する行を繋げます。
*Note M-^: Indentation。



File: emacs-ja, Node: Killing by Lines, Next: Other Kill Commands, Prev: Deletion, Up: Killing

行単位のキル *(2005/03/20)*
---------------------------

`C-k'
     行の残りの部分、あるいは、行全体を1行以上キルする（`kill-line'）。

もっとも単純なキルコマンドは`C-k'です。行の先頭で使うと、その行のすべて
のテキストをキルして、空行にします。空行で使うと、改行を含めてその行を
完全にキルします。空行でない行を完全にキルするには、行頭で`C-k'を2回打
ちます。

一般に、`C-k'は、行末でなければ、
ポイントからその行の末尾までをキルします。
行末では、ポイントのうしろの改行をキルするので、
現在行と後続の行が繋がります。
どちらの動作をするか決めるときには、
行末にあって見にくい空白やタブを無視しますから、
ポイントが行末にあるように見えていれば、
`C-k'で改行がキルされると考えてください。

`C-k'に正の引数を指定すると、その個数の行とそれらに続く改行をキルします
（ただし、現在行のポイントよりまえのテキストはキルされない）。負の引
数-Nを指定すると、`C-k'は現在行に先行するN行（と現在行のポイント位置よ
りまえのテキストを含めて）を削除します。つまり、ポイントが行頭にある状
態で`C-u - 2 C-k'とすれば、先行する2行をキルします。

`C-k'に引数0を指定すると、現在行のポイントよりまえのテキストをキルしま
す。

変数`kill-whole-line'が`nil'以外の場合、行頭で`C-k'を使うと、行末の改行
も含めて行全体をキルします。この変数は、通常、`nil'です。



File: emacs-ja, Node: Other Kill Commands, Prev: Killing by Lines, Up: Killing

他のキルコマンド *(2005/03/20)*
-------------------------------

`C-w'
     リージョン（ポイントからマークまで）をキルする（`kill-region'）。
`M-d'
     単語をキルする（`kill-word'）。
     *Note Words::。
`M-DEL'
     単語を後向きにキルする（`backward-kill-word'）。
`C-x DEL'
     文の先頭までを後向きにキルする（`backward-kill-sentence'）。
     *Note Sentences::。
`M-k'
     文の末尾までをキルする（`kill-sentence'）。
`C-M-k'
     括弧でバランスした式をキルキルする(`kill-sexp')． *Note Expressions::．
     *Note Lists::。
`M-z CHAR'
     つぎにCHARが現れる箇所までをキルする（`zap-to-char'）。

汎用的なキルコマンドといえば`C-w'（`kill-region'）です。このコマンドは、
あらかじめ連続領域をポイントとマークで囲んでおけば、どんな連続領域でも
キルできます。

探索と組み合わせた便利なキルの仕方もあります。`M-z'（`zap-to-char'）は
1文字を読み取り、ポイントからバッファ内でその文字がつぎに現れる箇所まで
を（その文字も含めて）キルします。数引数を指定した場合は、反復回数を意
味します。負の引数の場合は、ポイント位置から逆方向に探索し、ポイントの
直前までをキルします。

他の構文単位でもキルできます。
`M-DEL'や`M-d'（*Note Words::）で単語を、
`C-M-k'（*Note Expressions::）で括弧で囲まれた式を、
`C-x DEL'や`M-k'（*Note Sentences::）で文をキルできます。

読み出し専用のバッファでもキルできます。実際にはバッファに変更を加える
ことはありませんし、ベルを鳴らしてその旨警告を発しますが、キルしようと
したテキストはキルリングにコピーされます。ですから、別のバッファにその
テキストをヤンクできます。ほとんどのキルコマンドは、このようにコピーす
るテキストを越えてポイントを進めますから、連続してキルコマンドを実行し
てもキルリングに入る項目は通常どおり1個だけです。



File: emacs-ja, Node: Yanking, Next: Accumulating Text, Prev: Killing

ヤンク *(2005/03/20)*
=====================

"ヤンク"（yank）とは、以前にキルしたテキストをバッファにふたたび挿入す
ることです。他のシステムでは『ペースト』と呼ぶこともあります。テキスト
を移動したりコピーしたりする普通の方法は、そのテキストをいったんキルし
てから、別の場所に（1回以上）ヤンクすることです。

`C-y'
     最後にキルしたテキストをヤンクする（`yank'）。
`M-y'
     たった今ヤンクしたテキストをそれより以前にキルした一塊のテキストで
     置き換える（`yank-pop'）。
`M-w'
     リージョンを実際にはキルせずに、最後にキルしたテキストとして保存す
     る（`kill-ring-save'）。
`C-M-w'
     つぎのキルを、最後にキルした一塊のテキストに付け加える
     （`append-next-kill'）。

ウィンドウシステムでは，Emacs でテキストをキルした時よりも後に，他のソ
フトでコピーしたテキストがあると，`C-y' はEmacs でキルされたテキストの
代わりに，他のソフトでコピーしたテキストを貼り付けます．

* Menu:

* Kill Ring::		Where killed text is stored.  Basic yanking.
* Appending Kills::	Several kills in a row all yank together.
* Earlier Kills::	Yanking something killed some time ago.



File: emacs-ja, Node: Kill Ring, Next: Appending Kills, Prev: Yanking, Up: Yanking

キルリング *(2005/03/20)*
-------------------------

すべてのキルされたテキストは、キルされたテキストの塊をリストとする"キル
リング"（kill ring）に記録されています。キルリングはたった1つしかなくて、
すべてのバッファで共有しています。ですから、あるバッファでキルしたテキ
ストは、別のバッファでヤンクできます。普通、このようにして、あるファイ
ルから別のファイルへテキストを移動します。（別の方法については、*Note
Accumulating Text::。）

コマンド`C-y'（`yank'）は、
最後にキルしたテキストをふたたび挿入します。
カーソルは挿入したテキストの末尾に置かれます。
マークは挿入したテキストの先頭に置かれます。
*Note Mark::。

`C-u C-y'は、テキストのまえにカーソルを置き、うしろにマークを置きます。
引数として`C-u'だけを指定した場合に限り、こうなります。`C-u'と数字を含
めた他の引数を指定すると、いくつまえのキル内容をヤンクするかを意味しま
す（*Note Earlier Kills::）。

ヤンクすると，ヤンクされたテキストからある種のテキストプロパティは削除
されます．このことは，混乱を起こすかもしれません．例えば，マウスやある
種のキーに反応するテキストプロパティが無効になるなど．変数
`yank-excluded-properties' は削除すべきプロパティを決定します．レジスタ
や矩形領域のヤンクでもこれらの削除が起こります．

一塊のテキストをコピーする場合は、
`M-w'（`kill-ring-save'）を使うとよいでしょう。
このコマンドは、バッファからリージョンをキルせずに、
リージョンをキルリングにコピーします。
このコマンドは、`C-w'に続けて`C-x u'を実行するのとほぼ同等ですが、
`M-w'はアンドゥ履歴を変更しませんし、一時的にせよ画面表示も変わりません。



File: emacs-ja, Node: Appending Kills, Next: Earlier Kills, Prev: Kill Ring, Up: Yanking

キルしたテキストの追加 *(2005/03/20)*
-------------------------------------

通常、各キルコマンドは、キルリングに新たな項目を押し込みます。しかし、
連続したキルコマンドでは、それぞれでキルしたテキストを1つの項目にまとめ
ます。そのため、1回の`C-y'で、キルするまえの状態に、それらのテキストを
ひとまとめにヤンクできます。

したがって、テキストを一塊でヤンクしたい場合でも、1つのコマンドでそれら
をキルする必要はありません。すべてをキルするまで、1行ずつ、あるいは、1
単語ずつキルしていっても、一括してもとに戻すことができます。

ポイント位置から前向きにキルするコマンドでは、
直前にキルしたテキストの末尾に付け加えます。
ポイント位置から後向きにキルするコマンドでは、
テキストの先頭に付け加えます。
このように、前向き／後向きの両方のキルコマンドをどのように混ぜて実行しても、
キルしたテキストの順番を崩すことなく
1つの項目としてキルリングに記録されます。
数引数を指定しても、このような追加系列が途切れることはありません。
たとえば、バッファにつぎのテキストが入っていて、
-!-の位置にポイントがあるとしましょう。

     This is a line -!-of sample text.

`M-d M-DEL M-d M-DEL'と打って、前向き／後向きと交互にキルしても、キルリ
ングには1つの項目として`a line of sample'が入り、バッファには`This is
text.'が残ります。（空白が`is' と`text' の間に2個残っていることに注意。
これらは`M-SPC'や`M-q'で一掃できる。）

同じようにテキストをキルするもう1つの方法は、`M-b M-b'で後向きに2語移動
してから、`C-u M-d'で前向きに4語キルします。こうしても、バッファとキル
リングの中身は、先の例とまったく同じ結果になります。`M-f M-f C-u
M-DEL'としても、後向きに同じテキストをキルします。これでもやはり同じ結
果が得られます。キルリングの項目内のテキストの順序は、キルするまえのバッ
ファ内での順序と同じです。

キルコマンドと最後のキルコマンドのあいだに（単なる数引数ではない）他の
コマンドが入ると、キルリングには新たな項目が作られます。しかし、キルコ
マンドを打つ直前にコマンド`C-M-w'（`append-next-kill'）を打っておけば、
既存の項目へ追加するように強制できます。`C-M-w'は、つぎがキルコマンドで
あれば、新たな項目を作成するかわりにキルしたテキストを以前にキルしたテ
キストに付け加えるよう指示します。`C-M-w'を使うことで、まとめて1か所に
ヤンクできるように、離れた場所にあるいくつかのテキスト断片をキルして集
めておけます。

`M-w'に続くキルコマンドでは、
`M-w'がキルリングにコピーしたテキストには付け加えません。



File: emacs-ja, Node: Earlier Kills, Prev: Appending Kills, Up: Yanking

以前にキルしたテキストのヤンク *(2005/03/20)*
---------------------------------------------

直前にキルしたものではないテキストを取り出すには、
`M-y'コマンド（`yank-pop'）を使います。
`M-y'は、直前にヤンクしたテキストを
それ以前にキルしたテキストで置き換えます。
たとえば、最後から2つめのキルテキストを取り出すには、
まず`C-y'で最後にキルしたテキストをヤンクしてから、
`M-y'で1つまえのものに置き換えます。
`M-y'は`C-y'や他の`M-y'の直後でしか使えません。

キルリング内の項目を指す『最終ヤンク』ポインタを考えると、`M-y'の動作を
理解しやすいでしょう。キルするたびに、『最終ヤンク』ポインタは、リング
の先頭に新たに作られた項目を指します。`C-y'は、『最終ヤンク』ポインタが
指す項目をヤンクします。`M-y'は、『最終ヤンク』ポインタを別の項目へ移動
し、それに合わせてバッファのテキストを変更します。`M-y'コマンドを繰り返
せばリング内のどの項目へもポインタを移動できるので、どの項目でもバッファ
に取り込めます。ポインタがリングの最後に達すると、つぎの`M-y'はポインタ
をふたたびリングの先頭の項目に戻します。

`M-y'は、リング内で『最終ヤンク』ポインタを移動しますが、リング内の項目
の順番を変えることはありません。つねに、最後にキルしたものが先頭にあり、
記録に残っている最古のものが最後尾にあります。

`M-y'には数引数を指定できて、『最終ヤンク』ポインタをいくつ進めるかを指
定します。負の引数では、ポインタをリングの先頭に向けて移動します。リン
グの先頭からは最後の項目へ移動し、そこから先頭に向けて移動します。

目的のテキストがバッファに入ったならば、`M-y'コマンドの繰り返しを止めれ
ば、みつけたテキストが残ります。そのテキストはキルリングの項目のコピー
なので、バッファ内で編集してもリング内の項目は変わりません。新たにキル
しない限り、『最終ヤンク』ポインタはキルリング内の同じ場所を指していま
すから、`C-y'を繰り返すと、直前に取り込んだものと同じキル内容のコピーを
ヤンクできます。

目的のテキストを引き出すのに`M-y'コマンドを何回使えばよいのかわかってい
る場合には、数引数を指定して`C-y'を使えば、一発で目的のテキストをヤンク
できます。`C-y'に数引数を指定すると、最も最近のものを1として，そこから
キルリング内で遡って数えた項目のテキストを取り込みます。たとえば、`C-u
2 C-y'は最後から2番目にキルしたテキストを取り込みます。つまり、`C-y
M-y'とするのと等価です。数引数を指定した`C-y'は、『最終ヤンク』ポインタ
の場所から数え始め、ヤンクする項目にポイントを移動します。

キルリングの長さは、変数`kill-ring-max'で制御します。この個数以上のキル
テキストは保存しません。

キルリングの実際の内容は、`kill-ring'という名前の変数に入っています。キ
ルリングの全内容は、コマンド`C-h v kill-ring'で見ることができます。



File: emacs-ja, Node: Accumulating Text, Next: Rectangles, Prev: Yanking

テキストの蓄積 *(2005/03/20)*
=============================

通常、テキストをコピーしたり移動したりするにはキルとヤンクで行います。
しかし、一塊のテキストを何か所にもコピーしたり、多くの箇所に分散したテ
キストを1か所にコピーしたりするのに便利な方法が他にもあります。一塊のテ
キストを何か所にもコピーするには、そのテキストをレジスタに保存します
（*Note Registers::）。ここでは、何か所かに分散したテキストをバッファや
ファイルに蓄積するためのコマンドを説明します。

`M-x append-to-buffer'
     リージョンを指定したバッファの内容の末尾に付加する。
`M-x prepend-to-buffer'
     リージョンを指定したバッファの内容の先頭に付加する。
`M-x copy-to-buffer'
     リージョンを指定したバッファにコピーするが、そのバッファの古い内容
     は削除する。
`M-x insert-buffer'
     指定したバッファの内容をカレントバッファのポイント位置に挿入する。
`M-x append-to-file'
     リージョンを指定したファイルの内容の末尾に付加する。

テキストをバッファに蓄積するには、`M-x append-to-buffer'を使います。こ
れは、バッファ名を読み取り、リージョンのコピーを指定したバッファに挿入
します。存在しないバッファを指定した場合、`append-to-buffer'はバッファ
を作成します。テキストは、そのバッファ内のポイント位置に挿入されます。
バッファを編集用に使っている場合には、そのバッファ内のテキストのあいだ、
その瞬間にあったポイント位置にコピーしたテキストを挿入します。

コピー先のバッファ内では、ポイントはコピーされたテキストの末尾に置かれ
ます。したがって、連続して`append-to-buffer'を使うと、コピーした順序で
バッファにテキストが蓄積されます。厳密には、`append-to-buffer'は、バッ
ファ内の既存のテキストに追加するとは限りません。そのバッファの末尾にポ
イントがある場合に限り、追加します。しかし、バッファを変更するコマンド
が`append-to-buffer'だけならば、ポイントはつねに末尾に置かれています。

`M-x prepend-to-buffer'は`append-to-buffer'にとてもよく似ていますが、コ
ピー先のバッファ内のポイントは、コピーしたテキストの直前に置かれる点が
異なります。つまり、続けてこのコマンドを使うと、テキストは逆順に追加さ
れていきます。`M-x copy-to-buffer'も同様ですが、指定したバッファ内の既
存のテキストを削除します。したがって、バッファには新たにコピーしたテキ
ストだけが残ります。

別のバッファに蓄積したテキストを取り出すには、コマンド`M-x
insert-buffer'を使います。このコマンドも引数としてBUFFERNAMEを必要とし
ます。バッファBUFFERNAME内の全テキストのコピーを現在バッファのポイント
位置に挿入し，挿入されたテキストの後にマークを置きます．あるいは、その
バッファを選択して編集し、場合によってはキルしてそのバッファからテキス
トを移動することもできます。バッファに関する背景情報は、*Note
Buffers::。

テキストをEmacsのバッファに蓄積するかわりに、`M-x append-to-file'を使っ
て、テキストを直接ファイルに追加できます。このコマンドは引数として
FILENAMEを必要とします。リージョンのテキストを指定したファイルの末尾に
追加します。ファイルはディスク上でただちに更新されます。

このコマンドに指定するファイルは、Emacsで訪問して*いない*ファイルだけに
限るべきです。Emacsで編集中のファイルを指定すると、Emacsに隠れてファイ
ルを変更することになり、編集内容の一部を失うことにもなりかねません。



File: emacs-ja, Node: Rectangles, Prev: Accumulating Text

矩形領域 *(2005/03/20)*
=======================

矩形領域コマンドはテキストの矩形領域を操作します。矩形領域のテキストと
は、2つの行の範囲内にある2つの桁位置のあいだにある文字すべてを指します。
矩形領域をキルする、キルした矩形領域をヤンクする、矩形領域をクリアする、
矩形領域を空白やテキストで充填する、矩形領域を削除する、といったコマン
ドがあります。矩形領域コマンドは、複数段に組んだテキストを操作したり、
テキストをそのように組んだり戻したりする場合に便利です。

コマンドで操作する矩形領域を指定するには、一方の隅にマークを設定し、そ
の対角にポイントを置きます。このように設定した矩形領域を"矩形リージョン
（region-rectangle）と呼びます。というのも、リージョンの制御と似た方法
で矩形領域を制御できるからです。しかし、ポイントとマークの組は、それを
使うコマンドに依存して、リージョンとして解釈される、あるいは、矩形領域
として解釈されることに注意してください。

ポイントとマークが同じ桁位置にある場合、それらが切り分ける矩形領域は空
です。同じ行上にある場合は、矩形領域の高さは1行です。桁と行の扱い方が非
対称であるのは、ポイント（同様にマーク）は2つの桁のあいだにあるのに対し、
行ではその中にあるからです。

`C-x r k'
     矩形リージョンのテキストをキルし、その内容を『最後にキルした矩形領
     域』として保存する（`kill-rectangle'）。
`C-x r d'
     矩形リージョンのテキストを削除する（`delete-rectangle'）。
`C-x r y'
     最後にキルした矩形領域をポイント位置を左上隅としてヤンクする
     （`yank-rectangle'）。
`C-x r o'
     空白で埋めた矩形リージョンを挿入する（`open-rectangle'）。矩形リー
     ジョンの直前の内容は右に押しやられる。
`C-x r c'
`M-x clear-rectangle'
     矩形リージョンのすべてのテキストを空白で置き換えて、内容をクリアす
     る (`clear-rectangle')。
`M-x delete-whitespace-rectangle'
     指定した矩形領域の各行において、矩形領域の左端から白文字を削除する。
`C-x r t STRING RET'
     指定した矩形領域の各行の内容を STRING で置き換える
     （`string-rectangle'）。
`M-x string-insert-rectangle RET STRING RET'
     矩形領域の各行に STRING を挿入する

矩形操作は2種類に分類できます。矩形領域を削除したり挿入したりするコマン
ドと、空白の矩形領域を扱うコマンドです。

矩形領域内のテキストを消すには、2つの方法があります。テキストを捨てる
（削除する）か、『最後にキルした』矩形領域として保存するかです。これら
の機能を実現するコマンドは、`C-x r d'（`delete-rectangle'）と`C-x r k'
（`kill-rectangle'）です。どちらも、矩形領域の内側にある各行の部分を削
除し、それより(もしいくらかでも)右側にテキストがあれば、隙間を埋めるよ
うにそれらを左へ移動します。

矩形領域の『キル』は普通の意味でのキルではない、ということに注意してく
ださい。矩形領域はキルリングには保存されませんが、最後にキルした矩形領
域を1つだけ記録できる特別な場所に保存されます。というのは、矩形領域をヤ
ンクすることは、線形のテキストのヤンクとは大きく異なり、特別なヤンクコ
マンドが必要だったり、ヤンクしたテキストの入れ換え操作が意味をなさなかっ
たりするからです。

最後にキルした矩形領域をヤンクするには、`C-x r y'（`yank-rectangle'）と
打ちます。矩形領域のヤンクは矩形領域のキルの逆です。ポイントは矩形領域
の左上隅の位置を指定します。その場所には矩形領域の1行目が挿入され、矩形
領域の2行目はそのつぎの行で同じ列だが1行下がった場所に挿入されるといっ
た具合です．影響される行数は、保存されている矩形領域の高さで決まります。

矩形領域のキルとヤンクを使うと、1段組みの一覧表を2段組の一覧表に変換で
きます。一覧表の後半を矩形領域としてキルして、一覧表の第1行の隣にヤンク
すればよいのです。

また、`C-x r r R'や`C-x r i R'を使えば、
矩形領域をレジスタにコピーしたり、レジスタから矩形領域をコピーしたりできます。
*Note Rectangle Registers: RegRect。

空白の矩形領域を作るコマンドは2つあります。`C-x r c' (`M-x
clear-rectangle') は既存のテキストを空白で置き換え、`C-x r
o'（`open-rectangle'）は空白の矩形領域を挿入します。矩形領域をクリアす
ることは、矩形領域を削除してから同じ大きさの空白の矩形領域を挿入するの
と同じことです。

コマンド`M-x delete-whitespace-rectangle'は、特定の桁位置から始まる横に
並んだ白文字を削除します。矩形領域内の各行に作用し、桁位置は矩形領域の
左端です。矩形領域の右端はこのコマンドには関係ありません。

コマンド`C-x r t'（`string-rectangle'）は、矩形領域を指定した文字列で置
き換えます。文字列の幅は、矩形領域の幅と同じである必要はありません。文
字列の幅が足りなければ、矩形領域の右側にあるテキストは左へ移動します。
文字列の幅が広ければ、矩形領域の右側にあるテキストは右へ移動します。

`M-x string-insert-rectangle' は `string-rectangle' と似ていますが，元
のテキストを右にシフトしてから，各行に文字を挿入します．



File: emacs-ja, Node: Registers, Next: Display, Prev: Rectangles, Up: Top

レジスタ
********

Emacsの"レジスタ"（registers）は、あとで使うためにテキストやポイント位
置を保存するための場所です。テキストや矩形領域をレジスタにいったん保存
すれば、何度でもバッファにコピーできます。また、レジスタに保存した位置
には何度でもポイントを移動できます。

各レジスタには1文字の名前が付いています。
レジスタには、テキストの一部、矩形領域、位置、
ウィンドウの構成情報、ファイル名を保存できますが、
1度にはそのうちの1つしか保存できません。
レジスタに保存した内容は、そのレジスタに他のものを保存するまでは
保持され続けます。
レジスタRに何が入っているか調べるには、
`M-x view-register'を使います。

`M-x view-register RET R'
     レジスタRの内容を表示する。

* Menu:

* Position: RegPos.           Saving positions in registers.
* Text: RegText.              Saving text in registers.
* Rectangle: RegRect.         Saving rectangles in registers.
* Configurations: RegConfig.  Saving window configurations in registers.
* Files: RegFiles.            File names in registers.
* Numbers: RegNumbers.        Numbers in registers.
* Bookmarks::                 Bookmarks are like registers, but persistent.



File: emacs-ja, Node: RegPos, Next: RegText, Prev: Registers, Up: Registers

レジスタに位置を保存する
========================

位置を保存するとは、あとで戻ってこられるようにバッファ中の位置を記録す
ることです。保存した位置に移動すると、そのバッファに切り替えてからポイ
ントをその位置に移動します。

`C-x r SPC R'
     ポイント位置をレジスタRに保存する（`point-to-register'）。
`C-x r j R'
     レジスタRに保存した位置に移動する（`jump-to-register'）。

ポイントの現在位置をレジスタに保存するには、名前Rを選んでから、`C-x r
SPC R'と打ちます。他のものを保存するまで、レジスタRはこうして保存した位
置を保持し続けます。

コマンド`C-x r j R'は、レジスタRに記録した位置にポイントを移動します。
レジスタは変わらず、同じ位置を記録し続けます。何度でも保存した位置に移
動できます。

`C-x r j'を使って保存位置に移動しようとしたとき、その対象となるバッファ
がすでに消去されていた場合には、`C-x r j'は同じファイルを訪問するバッファ
を作成し直そうとします。もちろん、これはファイルを訪問したバッファに対
してのみ働きます。



File: emacs-ja, Node: RegText, Next: RegRect, Prev: RegPos, Up: Registers

レジスタにテキストを保存する
============================

テキストの同じ部分のコピーを頻繁に挿入する場合、キルリングからヤンクす
るのは便利ではないでしょう。というのは、キルするごとに、必要な部分がリ
ングの下方に徐々に移動してしまうからです。別の手段としては、レジスタに
テキストを保存しておき、レジスタから取り込むという方法があります。

`C-x r s R'
     レジスタRにリージョンをコピーする（`copy-to-register'）。
`C-x r i R'
     レジスタRからテキストを挿入する（`insert-register'）。

`C-x r s R'は、リージョンのテキストのコピーをRという名前のレジスタに保
存します。`C-x r s R'に数引数を指定すると、保存すると同時にバッファから
テキストを削除します。

`C-x r i R'はレジスタRからテキストをバッファに挿入します。通常、テキス
トの直前にポイントを置き、直後にマークを置きます。しかし、数引数
（`C-u'）を指定すると、テキストの直後にポイントを置き、直前にマークを置
きます。



File: emacs-ja, Node: RegRect, Next: RegConfig, Prev: RegText, Up: Registers

レジスタに矩形領域を保存する
============================

レジスタには、連続したテキスト以外にも、矩形領域を保持できます。
矩形領域は、文字列のリストとして表されます。
バッファ内での矩形領域の指定方法に関する基礎情報については、
*Note Rectangles::。

`C-x r r R'
     矩形領域をレジスタRにコピーする（`copy-rectangle-to-register'）。
     数引数を指定すると、コピー後に矩形領域を削除する。
`C-x r i R'
     レジスタRに保存した矩形領域（が存在すればそれ）を挿入する
     （`insert-register'）。

`C-x r i R'コマンドは、レジスタにテキストが入っていれば、そのテキストの
文字列を挿入しますし、矩形領域があれば矩形領域を挿入します。

コマンド`sort-columns'も参照してください。
このコマンドは矩形領域をソートすると考えられます。
*Note Sorting::。



File: emacs-ja, Node: RegConfig, Next: RegNumbers, Prev: RegRect, Up: Registers

レジスタにウィンドウ構成を保存する
==================================

選択したフレームのウィンドウ構成をレジスタに保存したり、すべてのフレー
ムのすべてのウィンドウ構成を保存したりできて、しかも、あとでその構成に
戻せます。

`C-x r w R'
     選択したフレームのウィンドウの状態をレジスタRに保存する
     （`window-configuration-to-register'）。
`C-x r f R'
     全フレームの状態を、各フレームのすべてのウィンドウを含めて、レジス
     タRに保存する（`frame-configuration-to-register'）。

ウィンドウやフレームの構成をもとに戻すには、`C-x r j R'を使います。これ
は、カーソル位置を復元するコマンドと同じです。フレームの構成を復元する
と、構成情報に含まれていない既存のフレームは隠れた状態になります。これ
らのフレームを削除したければ、`C-u C-x r j R'を使います。



File: emacs-ja, Node: RegNumbers, Next: RegFiles, Prev: RegConfig, Up: Registers

レジスタに数値を保持する
========================

レジスタに数値を保存しておき、数値を10進数でバッファに挿入してから数値
を増やすコマンドがあります。これらのコマンドは、キーボードマクロで役立
ちます（*Note Keyboard Macros::）。

`C-u NUMBER C-x r n REG'
     数値NUMBERをレジスタREGに保存する（`number-to-register'）。
`C-u NUMBER C-x r + REG'
     レジスタREG内の数値をNUMBERだけ増やす（`increment-register'）。
`C-x r g REG'
     レジスタREGの数値をバッファに挿入する。

`C-x r g'は、レジスタの数値以外の内容をバッファに挿入するために使うコマ
ンドと同じです。



File: emacs-ja, Node: RegFiles, Next: Bookmarks, Prev: RegNumbers, Up: Registers

レジスタにファイル名を保持する
==============================

特定のファイル名を頻繁に訪問する場合には、これらの名前をレジスタに置い
ておくと、より簡単にファイルを訪問できます。ファイル名をレジスタに置く
Lispコードをつぎに示します。

     (set-register ?R '(file . NAME))

たとえば、

     (set-register ?z '(file . "/gd/gnu/emacs/19.0/src/ChangeLog"))

とすると、上に示したファイル名をレジスタ`z'に保存します。

レジスタRに入れた名前のファイルを訪問するには、`C-x r j R'と打ちます。
（このコマンドは、保存位置に移動したりフレーム構成を復元するために使う
コマンドと同じ。）



File: emacs-ja, Node: Bookmarks, Prev: RegFiles, Up: Registers

ブックマーク
============

"ブックマーク"（bookmarks）とは、移動先の位置を記録しておくためのレジス
タのようなものです。レジスタと違って、長い名前を付けることができて、自
動的につぎのEmacsセッションに引き継がれます。ブックマークの典型的な使い
方は、各ファイルの『どこを読んでいるか』を記録しておくことです。

`C-x r m RET'
     訪問先のファイルのポイント位置にブックマークを設定する。

`C-x r m BOOKMARK RET'
     ポイント位置に、BOOKMARKという名前のブックマークを設定する
     （`bookmark-set'）。

`C-x r b BOOKMARK RET'
     名前がBOOKMARKであるブックマークに移動する（`bookmark-jump'）。

`C-x r l'
     すべてのブックマークを一覧表示する（`list-bookmarks'）。

`M-x bookmark-save'
     現在のすべてのブックマークの値をデフォルトのブックマークファイルに
     保存する。

ブックマークの典型的な使い方は、各ファイルごとに現在のポイント位置を保
存しておくことです。ブックマークを設定するコマンド`C-x r m'は、訪問先の
ファイルの名前をブックマーク名のデフォルトとして使います。ブックマーク
が指すファイルをもとにブックマークの名前を付ければ、`C-x r b'で任意のファ
イルを再訪問して、同時にブックマーク位置に移動するという操作を楽に行え
ます。

設定したすべてのブックマークの一覧を別のバッファに表示するには、`C-x r
l'（`list-bookmarks'）と打ちます。そのバッファに切り替えれば、ブックマー
クの定義を編集したり、ブックマークに注記を付けたりできます。このバッファ
で使える特別な編集コマンドについての情報を得るには、このバッファで`C-h
m'と打ちます。

内容を変更したブックマークがある場合、Emacsを終了する時点で、Emacsはブッ
クマークの値をデフォルトのブックマークファイル`~/.emacs.bmk'に保存する
かどうか聞いてきます。`M-x bookmark-save'コマンドを使っても、変更したブッ
クマークをいつでも保存できます。ブックマークコマンドは、個人のデフォル
トのブックマークファイルを自動的に読み込みます。これらの保存と読み込み
によって、ブックマークの内容をつぎのEmacsセッションに引き継げるのです。

変数`bookmark-save-flag'に1を設定しておくと、ブックマークを設定する各コ
マンドは、ブックマークの保存も行います。こうしておけば、Emacsがクラッシュ
した場合でも、ブックマークデータを失わなくてすみます。（この変数の値が
数値であれば、ブックマークを何回変更したら保存するという意味。）

ブックマークの位置情報は、その周辺の文脈情報と一緒に保存されるので、ファ
イルが少し変更されていたとしても、`bookmark-jump'は正しい位置をみつけだ
せます。変数`bookmark-search-size'で、ブックマーク位置の前後何文字分の
内容を保存するかを指定します。

ブックマークを用いるコマンドには、以下のものもあります。

`M-x bookmark-load RET FILENAME RET'
     ブックマークデータのリストを収めたFILENAMEという名前のファイルをロー
     ドする。デフォルトのブックマークファイル以外のブックマークデータを
     収めたファイルに対しても、コマンド`bookmark-write'と同じく、このコ
     マンドを使える。

`M-x bookmark-write RET FILENAME RET'
     現在設定されているブックマークデータをファイルFILENAMEに保存する。

`M-x bookmark-delete RET BOOKMARK RET'
     BOOKMARKという名前のブックマークを削除する。

`M-x bookmark-insert-location RET BOOKMARK RET'
     ブックマークBOOKMARKが指しているファイルの名前をバッファに挿入する。

`M-x bookmark-insert RET BOOKMARK RET'
     ブックマークBOOKMARKが指すファイルの*内容*をバッファに挿入する。


File: emacs-ja, Node: Display, Next: Search, Prev: Registers, Up: Top

画面の制御
**********

大きなバッファの一部しかウィンドウには収まりませんから、Emacsは必要そう
な部分を表示しようとします。画面制御コマンドを使って、テキストのどの部
分を表示したいのか、また、どのように表示するか指定できます。

* Menu:

* Scrolling::	           Moving text up and down in a window.
* Horizontal Scrolling::   Moving text left and right in a window.
* Follow Mode::            Follow mode lets two windows scroll as one.
* Selective Display::      Hiding lines with lots of indentation.
* Optional Mode Line::     Optional mode line display features.
* Text Display::           How text characters are normally displayed.
* Display Vars::           Information on variables for customizing display.



File: emacs-ja, Node: Scrolling, Next: Horizontal Scrolling, Prev: Display, Up: Display

スクロール
==========

バッファを表示しているウィンドウに全部を表示するには大きすぎるテキスト
が入っているバッファでは、Emacsはテキストの連続する一部分を表示します。
表示する部分にはつねにポイントが入っています。

"スクロール"（scroll）とは、ウィンドウ内でテキストを上下に動かして、テ
キストの異なる部分を表示することです。前向きのスクロールでは、テキスト
を上へ移動して、新たなテキストがウィンドウの最下端から現れます。後向き
のスクロールでは、テキストを下に移動して、新たなテキストがウィンドウの
最上端から現れます。

ポイントをウィンドウの下端や上端を超えて移動すると、自動的にスクロール
します。本節で紹介するコマンドを使って、明示的にスクロールすることもで
きます。

`C-l'
     画面をクリアして再表示し、選択されたウィンドウではポイントが縦方向
     の中央に位置するようにスクロールする（`recenter'）
`C-v'
     （ウィンドウ1面分か指定した行数だけ）前向きにスクロールする
     （`scroll-up'）。
`NEXT'
     同様に前向きにスクロールする。
`M-v'
     後向きにスクロールする（`scroll-down'）。
`PRIOR'
     同じく後向きにスクロールする。
`ARG C-l'
     ポイントがARG行目にくるようにスクロールする（`recenter'）。
`C-M-l'
     有益な情報が画面上にくるように発見的方法でスクロールする
     （`reposition-window'）。

もっとも基本的なスクロールコマンドは、引数を指定しない
`C-l'（`recenter'）です。このコマンドは、画面全体をクリアして、すべての
ウィンドウを再表示します。さらに、ポイントがウィンドウの中央の行に位置
するように、選択されているウィンドウをスクロールします。

スクロールコマンド`C-v'と`M-v'は、
ウィンドウ内の全テキストを上下に何行か移動します。
`C-v'（`scroll-up'）に引数を指定すると、
`C-l'と同じようにテキストとポイントを一緒に上へ移動して、
追加分（引数分）の行をウィンドウの下部に表示します。
`C-v'に負の引数を指定した場合は、
ウィンドウの上端に追加分の行を表示します。
`M-v'（`scroll-down'）は`C-v'に似ていますが、
スクロール方向が逆です。
ファンクションキーのNEXTとPRIORは、
`C-v'と`M-v'に等価です。

スクロールコマンドの名前は、
ウィンドウ内でテキストを動かす向きに基づいています。
したがって、前向きにスクロールするコマンドは、
画面上ではテキストを上へ移動するため、
`scroll-up'と呼ばれます。

一度にウィンドウ1面分のバッファを読んでいくには、引数を指定せずに`C-v'
を使います。ウィンドウの下端2行を上端に持っていき、それに続けてこれまで
表示されていなかったほぼウィンドウ1面分の行を表示します。ポイントがウィ
ンドウの上端より上に出てしまう場合には、ポイントはウィンドウの新たな上
端の行に移動します。引数を指定しない`M-v'も同様に、テキストを重複させな
がら、後向きに移動します。`C-v'や`M-v'で重複させる行数は、変数
`next-screen-context-lines'で制御します。デフォルトでは2です。

画面上でのポイント位置を保ったまま1画面分のスクロールを行うコマンドを好
むユーザーもいます。このようにするには、変数
`scroll-preserve-screen-position'に`nil'以外を設定します。このモードは、
1画面分ずつスクロールしながらファイルを閲覧するような場合に便利です。ス
クロールを始めた画面に戻ると、ポイントは開始時の行位置に戻ります。しか
し、つぎの画面に移動して、そこに表示されているテキストにポイントを移動
するような使い方にはむいていません。

スクロールのもう1つの方法は、数引数を指定した`C-l'を使うことです。引数
を指定すると、`C-l'は画面をクリアしません。選択されているウィンドウだけ
をスクロールします。正の引数Nを指定すると、ポイント位置が上端からN行目
にくるように、テキストの位置を変更します。引数として0を指定すると、ポイ
ント位置は最上端の行になります。ポイントがテキストに対して動くわけでは
なくて、テキストとポイントは一緒に画面上を動きます。`C-l'に負の引数を指
定すると、ポイントはウィンドウの下端から指定行数にきます。たとえば、
`C-u - 1 C-l'とするとポイントは最下行になり、`C-u - 5 C-l'とすれば下か
ら5行目にポイントがきます。`C-u C-l'のように`C-u'だけを引数に指定すると、
ポイントが画面中央にくるようにスクロールします。

`C-M-l'コマンド（`reposition-window'）は、有益な情報を画面上に持ってく
るようにように設計された発見的手法で、カレントウィンドウをスクロールし
ます。たとえば、Lispファイルでは、このコマンドは、可能であれば現在の関
数定義（defun）全体を画面上にもってこようとします。

表示の際、ポイントがテキストの表示部分から飛び出してしまうと、自動的に
スクロールします。通常、この自動スクロールでは、ポイントがウィンドウ縦
方向の中央に位置するように画面を移動します。しかし、
`scroll-conservatively'に小さな数Nを設定しておくと、ポイントが画面から
少しだけ（N行未満）はみだすと、Emacsはポイントを画面内に戻すのに必要な
分だけスクロールします。デフォルトでは、`scroll-conservatively'は0です。

変数`scroll-margin'は、ポイントをウィンドウの上端や下端にどれだけ近づけ
られるかを制限します。その値は画面上での行数です。ポイントがウィンドウ
の上端や下端からその行数以内にくると、Emacsはウィンドウを中央に位置付け
し直します。デフォルトでは、`scroll-margin'は0です。



File: emacs-ja, Node: Horizontal Scrolling, Next: Follow Mode, Prev: Scrolling, Up: Display

水平スクロール
==============

"水平スクロール"（horizontal scrolling）とは、すべての行をウィンドウ内
で横方向に動かすことです。これにより、左端近くのテキストは表示されなく
なります。

`C-x <'
     カレントウィンドウのテキストを左にスクロールする（`scroll-left'）。
`C-x >'
     右にスクロールする（`scroll-right'）。

ウィンドウが水平方向にスクロールされているときには、テキスト行を継続
（*Note Continuation Lines::）しないで切り捨てます。テキストの左側を切
り捨てているときは最初の桁に`$'を表示し、右側を切り捨てているときには最
後の桁に`$'を表示します。

コマンド`C-x <'（`scroll-left'）は、選択されたウィンドウを引数Nの桁数だ
け左にスクロールします。各行の最初の部分はウィンドウの左端から出てしま
います。引数を指定しないと、ほぼウィンドウ幅（正確には2桁少ない桁数）だ
けスクロールします。

`C-x >'（`scroll-right'）は、同様に右にスクロールします。
ウィンドウが（各行がウィンドウの左端から始まっている）通常の表示をしていると、
それ以上はスクロールできません。
スクロールさせようとしても何も起こりません。
つまり、`C-x >'に与える引数を正確に計算する必要はないのです。
十分に大きな引数を指定すれば、通常の表示に戻せます。

水平スクロール（hscroll）モードをオンにすると、自動的に水平スクロールを
行います。このモードがオンであると、ポイントが左右端から離れすぎない場
所に見えるようにEmacsが水平方向にウィンドウをスクロールします。このモー
ドのオン／オフを切り替えるコマンドは、`M-x hscroll-mode'です。



File: emacs-ja, Node: Follow Mode, Next: Selective Display, Prev: Horizontal Scrolling, Up: Display

追従モード
==========

"追従（follow）モード"は、同じバッファを表示している2つのウィンドウを、
1つの『仮想ウィンドウ』としてスクロールするマイナモードです。追従
（follow）モードを使うには、ウィンドウが1つだけのフレームに移動して、
`C-x 3'を使って左右に並んだ2つのウィンドウに分割してから、`M-x
follow-mode'と打ちます。これ以後、いずれのウィンドウのバッファでも編集
できますし、どちらをスクロールしてもかまいません。もう一方のウィンドウ
は他方に追従します。

追従（follow）モードをオフにするには、もう一度`M-x follow-mode'を打ちま
す。



File: emacs-ja, Node: Selective Display, Next: Optional Mode Line, Prev: Follow Mode, Up: Display

選択的な表示
============

Emacsには、（指定した）桁数以上字下げしてある行を隠す機能があります。プ
ログラムの一部を概観するのにこの機能を使えます。

行を隠すには、数引数Nを指定して`C-x $' （`set-selective-display'）と打
ちます。これにより、N桁以上字下げしてある行は画面から消えます。1行以上
の不可視行に先行する可視行の末尾には、3つのドット（`...'）を表示します。
この印が不可視行の存在を示す唯一のものです。

コマンド`C-n'や`C-p'は、不可視行が存在しないかのように不可視行を飛び越
えて移動します。

不可視行は依然としてバッファ内に存在しています。たいていの編集コマンド
はそれらを通常と同じように扱うので、隠蔽されたテキスト内にポイントを移
動してしまうことも起こりえます。このような場合、カーソルは先行する行の
末尾の3つのドットの直後に表示されます。ポイントが可視行の行末の改行文字
の直前にあるときには、3つのドットの直前にカーソルが現れます。

すべての行をふたたび表示するには、引数を指定せずに`C-x $'を打ちます。

変数`selective-display-ellipses'に`nil'を設定すると、不可視行に先行する
可視行の末尾には3つのドットを表示しなくなります。すると、不可視行の存在
を示すものは何もありません。この変数を設定すると、自動的にローカルにな
ります。



File: emacs-ja, Node: Optional Mode Line, Next: Text Display, Prev: Selective Display, Up: Display

モード行の付加機能
==================

行番号（line-number）モードがオンであると、
ポイントの現在の行番号をモード行に表示します。
このモードのオン／オフを切り替えるには、
コマンド`M-x line-number-mode'を使います。
通常はオンです。
行番号は、バッファの百分率を示すPOSのまえに、
行番号であること示す文字`L'とともに表示されます。
マイナモードやこのコマンドの使用方法について詳しくは、
*Note Minor Modes::。

バッファが非常に大きい（`line-number-display-limit'の値以上に大きい）場
合には、この行番号を表示しません。計算が非常に遅くなるので、バッファが
大きい場合にはEmacsは行番号を計算しません。バッファをナロイング（*Note
Narrowing::）してある場合、表示される行番号はバッファの参照可能な部分に
対するものです。

桁番号（column-number）モードをオンにすると、現在の桁番号も表示できます。
このモードでは、`C'に続けて現在の桁番号を表示します。
このモードのオン／オフを切り替えるには、
`M-x column-number-mode'と打ちます。

Emcasでは、すべてのモード行に、時刻とシステムの負荷状況を表示できます。
この機能をオンにするには、`M-x display-time'と打ちます。このときモード
行に追加される情報は、通常は、バッファ名のあと、括弧で囲まれたモード名
のまえに表示されます。その表示はつぎのようになります。

     HH:MMpm L.LL

ここで、HHとMMは、時分を表し、つねに`am'か`pm'が続きます。L.LLは、シス
テム全体で実行中のプロセスの個数の最近の平均数です。（オペレーティング
システムが情報を提供しなければ、いくつかの内容が消えていることもある。）
時刻を24時間表示したければ、変数`display-time-24hr-format'に`t'を設定し
ます。

負荷レベル表示に続く語`Mail'は、未読のメイルがある場合に表示されます。



File: emacs-ja, Node: Text Display, Next: Display Vars, Prev: Optional Mode Line, Up: Display

テキストの表示方法
==================

Emacsバッファ内のASCII印字文字（8進コードで040から0176）は、それぞれの
図形で表示されます。非ASCIIのマルチバイトの印字文字（8進コード0400以上）
も同様です。

ASCIIコントロール文字の中には、特別な方法で表示されるものもあります。改
行文字（8進コード012）は、新たな行を始めるという形で表示されます。タブ
文字（8進コード011）は、つぎのタブストップ位置（通常は8桁ごと）まで移動
するという形で表示されます。

その他のASCIIコントロール文字は、通常、カレット（`^'）に続けてコントロー
ル変種でない文字で表示されます。つまり、control-Aは`^A'のように表示され
ます。

0200から0377までの非ASCII文字は、8進のエスケープシーケンスで表示されます。
たとえば、文字コード0243（8進）は、`\243'と表示されます。
しかし、ヨーロッパ向けの表示をオンにしていると、
これらのたいていの文字は非ASCII印字文字として扱われ、
（端末がこれらの文字を表示できると仮定して）それぞれの図形で表示されます。
*Note Single-Byte European Support::。



File: emacs-ja, Node: Display Vars, Prev: Text Display, Up: Display

表示を制御する変数
==================

本節は、カスタマイズに関する情報のみです。初心者の方は読み飛ばしてくだ
さい。

変数`mode-line-inverse-video'は、
（端末が反転表示を扱えると仮定して）
モード行を反転表示するかどうかを制御します。
`nil'は反転表示しないことを意味します。
*Note Mode Line::。
`modeline'フェイスに前景色を指定していて、しかも、
`mode-line-inverse-video'が`nil'以外であれば、
`modeline'フェイスのデフォルトの背景色は通常の前景色です。
*Note Faces::。

変数`inverse-video'が`nil'以外である場合、Emacsは画面上のすべての行を通
常の状態から反転表示します。

変数`visible-bell'が`nil'以外の場合、Emacsは、通常は端末のベルを鳴らす
場面では、画面全体を点滅します。端末に画面を点滅する機能がなければ、こ
の変数は何の効果もありません。

Emacsを休止したあとで再開した場合、通常Emacsは画面をクリアし、画面全体
を再表示します。ページメモリを複数個備えた端末では、termcapの定義を変更
して、（それぞれ、Emacsを起動するときと抜けるときに端末に出力される）文
字列`ti'と`te'でページメモリを切り替えて、1ページをEmacs用に使い、もう
1ページを他の出力用に使うようにできます。そして、変数
`no-redraw-on-reenter'に`nil'以外を設定します。こうすると、Emacsは、再
開時には最後に出力した内容が画面ページに入っているものと仮定します。

変数`echo-keystrokes'は、複数個の文字キーのエコーを制御します。
設定する値は、エコーを開始するまでの待機時間の秒数です。
ゼロを指定するとエコーしません。
*Note Echo Area::。

変数`ctl-arrow'に`nil'を設定すると、改行とタブを除いて、バッファ内のコ
ントロール文字を8進のエスケープシーケンスで表示します。変数`ctl-arrow'
の値を変更すると、この変数はカレントバッファにローカルになります。それ
までは、デフォルトの値が使われます。デフォルトの初期値は`t'です。*Note
表示テーブル: (elisp)Display Tables。

通常、バッファ内のタブ文字は、つぎのタブストップ位置までの空白として表
示され、タブストップは8個分の空白と同じ間隔です。タブ1個あたりの空白の
文字数は、変数`tab-width'で制御します。この変数も`ctl-arrow'と同様に、
変更するとバッファにローカルになります。バッファ内のタブ文字をどのよう
に表示するかと、コマンドとしてのTABの定義とは無関係であることに注意して
ください。変数`tab-width'の値は1以上1000以下の整数である必要があります。

変数`truncate-lines'に`nil'以外を設定すると、テキストの各行は表示上は画
面の1行を占有します。テキスト行が長すぎる場合は、画面に収まる範囲だけを
表示します。一方、`truncate-lines'に`nil'を設定すると、長いテキスト行は、
画面上では2行以上にわたってテキスト行の表示に必要なだけの行数で表示され
ます。*Note Continuation Lines::。変数`truncate-lines'の値を変更すると、
カレントバッファにローカルになります。それまでは、デフォルトが使われま
す。デフォルトの初期値は`nil'です。

変数`truncate-partial-width-windows'に`nil'以外を設定すると、画面やフレー
ムの幅に満たないウィンドウでは、テキストの表示方法は`truncate-lines'の
値とは無関係に、継続行ではなく切り捨てて表示します。左右に並べたウィン
ドウに関しては、*Note Split Window::。*Note Emacsの画面表示:
(elisp)Displayも参照してください。

変数`baud-rate'は、Emacsにとっての端末の出力速度を保持します。この変数
の値を設定したとしても、実際のデータ転送速度を変更できるわけではなく、
この値はパディングの計算などに用いられます。さらに、ウィンドウシステム
を使用している場合であっても、画面の一部をスクロールするのか、再表示す
るのかの決定にも影響します。（ウィンドウシステムには正しい『出力速度』
がないにしても、スクロール／再表示を調整できるようにこのように設計して
ある。）

どんな文字コードの表示方法も、表示テーブルを用いてカスタマイズできます。
*Note 表示テーブル: (elisp)Display Tables。


File: emacs-ja, Node: Search, Next: Fixit, Prev: Display, Up: Top

探索と置換 *(2004/03/27)*
*************************

他のエディタと同様に、Emacsにも文字列を探索するコマンドがあります。主な
探索コマンドが"インクリメンタル"（incremental）であるという点で、普通と
は違います。探索したい文字列全体を入力し終えなくても、探索を始めます。
他のエディタの探索コマンドのように、インクリメンタルでない探索コマンド
もあります。

指定した文字列の出現すべてを探し出して別の文字列に置換する、普通の置換
コマンド`replace-string'に加えて、Emacsにはより柔軟な、出現箇所をみつけ
るたびに置換するかどうか対話的に尋ねる問い合わせ型置換コマンド
`query-replace'もあります。

* Menu:

* Incremental Search::		Search happens as you type the string.
* Nonincremental Search::	Specify entire string and then search.
* Word Search::			Search for sequence of words.
* Regexp Search::		Search for match for a regexp.
* Regexps::			Syntax of regular expressions.
* Search Case::			To ignore case while searching, or not.
* Configuring Scrolling::	Scrolling within incremental search.
* Replace::			Search, and replace some or all matches.
* Other Repeating Search::	Operating on all matches for some regexp.



File: emacs-ja, Node: Incremental Search, Next: Nonincremental Search, Prev: Search, Up: Search

インクリメンタルサーチ *(2004/03/26)*
=====================================

インクリメンタルサーチでは、
探索文字列の最初の文字を打つとただちに探索を開始します。
探索文字列を入力するたびに、
Emacsは（それまでに入力した）文字列がどこでみつかるか表示します。
目的の箇所を特定するのに十分なだけの文字を打ってしまえば、
そこで終りにできます。
つぎに何をするかにもよりますが、
RETで探索を陽に終了する必要がある場合もあります。

`C-s'
     前向きにインクリメンタルサーチする（`isearch-forward'）。
`C-r'
     後向きにインクリメンタルサーチする（`isearch-backward'）。

`C-s'は順方向へのインクリメンタルサーチを始めます。`C-s'はキーボードか
ら文字を読み取り、打った文字が最初に現れる位置までカーソルを移動します。
たとえば、`C-s'に続けて`F'を打つと、カーソルは最初に現れる`F'の直後に移
動します(順方向への検索なので続く文字の開始点になります)。さらに`O'を打
つと、カーソルは最初に現れる`FO'の直後に移動します(`FO' の `F' は最初の
`F'かもしれないし，違うかもしれない)。さらに`O'を打つと、探索を開始した
場所以降で最初に現れる`FOO'の直後にカーソルが移動します。各段階において、
反転表示できる端末では、探索文字列に一致するバッファ内のテキストを強調
表示します。また、各段階において、エコー領域には現在の探索文字列がいつ
も表示されます。

探索する文字列を打ちまちがえたときには、DELで取り消せます。DELを1回押す
ごとに、探索文字列の最後の文字を取り消していきます。ただし、Emacsがつぎ
の入力文字を受け付け可能になるまで、この取り消し操作は実行できません。
つまり、取り消そうと思っている文字をみつけるか、もしくはみつけられなかっ
たことが確定する必要があります。それまで待てないなら、以下に説明するよ
うに`C-g'を使ってください。

目的の箇所まで移動できたら、RETを打ちます。
すると、探索を終了しカーソルはその箇所に留まります。
また、探索に関係ないコマンドを打っても、
探索を終了し、そのコマンドを実行します。
したがって、`C-a'と打てば、探索を終了し、カーソルを行頭に移動します。
RETが必要な場面は、
つぎに入力したいコマンドが、印字文字、DEL、RET、および、
探索で特別な意味を持つその他の各種コントロール文字
（`C-q'、`C-w'、`C-r'、`C-s'、
`C-y'、`M-y'、`M-r'、`M-s'）やいくつかのメタ文字である場合だけです。

`FOO'を探してそれがみつかった場合でも、予期していた`FOO'ではないことも
あるでしょう。最初の`FOO'以降に、2つめの`FOO'があることを忘れていたよう
な場合です。このようなときには、さらに`C-s'を打てば、探索文字列のつぎの
出現箇所に移動できます。この操作は何度でも繰り返せます。行き過ぎてしまっ
たときには、DELで`C-s'の操作を取り消せます。

探索を終了したあとでも、単に`C-s C-s'と打てば、ふたたび同じ文字列を探索
できます。つまり、最初の`C-s'がインクリメンタルサーチを起動して、つぎの
`C-s'が『再探索』を意味します。

以前に探索した文字列を再利用するには、"探索リング"（search ring）を使い
ます。コマンド`M-p'と`M-n'でリング内を移動して、再利用する文字列を取り
出します。これらのコマンドは、探索リング内の選択した要素をミニバッファ
に置きますから、編集することも可能です。`C-s'や`C-r'を打てば、文字列の
編集を終了して探索を開始できます。

探している文字列がまったくみつからなかった場合には、エコー領域に
`Failing I-Search'と表示されます。カーソルは、指定した文字列に可能な限
り一致する箇所の直後にあります。たとえば、`FOOT'を探索しようとしたのに
`FOOT'がなければ、カーソルは`FOOL'の`FOO'の直後にあります。この時点でで
きることはいくつかあります。文字列を打ちまちがえたのならば、それを消去
して訂正します。その箇所でよいのなら、その場所に留まるために、RETか他の
Emacsコマンドを打ちます。あるいは、`C-g'を打てば、探索文字列からみつけ
られなかった文字（`FOOT'中の`T'）を取り除き、みつけた文字列（`FOOT'中の
`FOO'）はそのままにしておくこともできます。ここで、さらに`C-g'を打つと、
探索全体を取り止めて、探索を開始した位置に戻ります。

探索文字列に大文字を指定すると、
大文字小文字を区別（case-sensitive）して探索します。
探索文字列から大文字を削除すると、この効果は消えます。
*Note Search Case::。

改行を探索するには、`C-j'を打ちます。
コントロールSや改行などのコントロール文字を探索するには、
まず`C-q'を打ってクォートする必要があります。
`C-q'のこの機能は、挿入時の利用法に似ています
（*Note Inserting Text::）。
このコマンドは、あとに続く文字を、
同じ文脈における『普通の』文字と同様に扱うようにします。
文字を8進コードで指定することもできて、
`C-q'に続けて8進数字列を入力します。

非ASCII文字を探索するためには，入力メソッド (*Note Input Methods::) を
使わなければなりません．探索を始める時に入力メソッドがオンになっている
と，探索する時にも入力メソッドを利用できます．この時Emacs はプロンプト
に以下のように入力メソッドの略称を表示します．

     I-search [IM]:

IMは入力メソッドの略称です．検索中に `C-\'
(`isearch-toggle-input-method') を入力することで，入力メソッドをトグル
(有効か無効かを切り替え)できます．`C-^'
(`isearch-toggle-specified-input-method') である(デフォルトでない)入力
メソッドを有効にし，プロンプトに入力メソッド名を表示します．検索中に有
効にした入力メソッドは検索を終了しカレントバッファに戻っても有効な状態
のまま保たれます．

探索に失敗したときに、さらに`C-s'を打って探索の続行を指示すると、バッファ
の先頭からもう一度探索し始めます。後向きの探索に失敗したときに再度
`C-r'を打つと、バッファの末尾から探索を再開します。これらの操作は"巻き
直し"（wrapping around）と呼ばれます。巻き直しが起こると、探索のプロン
プトには`Wrapped'が表示されます。もともとの探索開始位置を通過してなお探
索を続けると、表示が`Overwrapped'に変わります。これは、探索文字列にすで
に一度一致した箇所を再度探索していることを意味します。

『中断』文字`C-g'は、探索中には特別な意味があり、その機能は探索の状態に
依存します。指定したものがみつかり入力待ちの状態にあると、`C-g'は探索全
体を取り消します。カーソルは探索開始位置に戻ります。Emacsが探索中であっ
たり探索に失敗したために、探索文字列内に未発見の文字がある場合に`C-g'を
打つと、探索文字列から未発見の文字を消去します。そうすると、これで探索
が成功したことになるので、入力待ちになります。続けて`C-g'を打つと、探索
全体を取り消します。

改行を探索するには、`C-j'を打ちます。
コントロールSや改行などのコントロール文字を探索するには、
まず`C-q'を打ってクォートする必要があります。
`C-q'のこの機能は、挿入時の利用法に似ています
（*Note Inserting Text::）。
このコマンドは、あとに続く文字を、
同じ文脈における『普通の』文字と同様に扱うようにします。
文字を8進コードで指定することもできて、
`C-q'に続けて8進数字列を入力します。

`C-r'を使えば、後向き探索に変更できます。ファイルのうしろのほうで探索し
始めたために探索に失敗したのであれば、これを試してください。`C-r'を繰り
返し打つと、後向きにさらに探索を続けます。`C-s'は、ふたたび前向き探索を
再開します。探索中の`C-r'はDELで取り消せます。

始めから後向きで探索するのであれば、`C-s'のかわりに`C-r'を使って探索を
始めます。`C-r'は、後向きに探索するコマンド`isearch-backward'を起動しま
す。前向き探索が開始位置よりうしろにある一致箇所をみつけるのと同様に、
後向き探索は開始位置よりまえにある一致箇所をみつけだします。

インクリメンタルサーチ中には、文字`C-y'と`C-w'を使って、バッファから探
索文字列へテキストを取り込むことができます。この機能は、ポイント位置に
あるテキストの出現箇所を探すときに便利です。`C-w'は、ポイント以降の文字
や単語を探索文字列の一部としてコピーし、ポイントをその単語の末尾に進め
ます(文字か単語かは状況によって変わります)。探索を繰り返す意味で`C-s'を
打つと、その文字や単語を含んだ文字列を探索します。`C-y'も`C-w'に似てい
ますが、現在行の残りの部分をすべて探索文字列にコピーします。大文字小文
字を区別しない探索では、`C-y'と`C-w'はともに、コピーするテキストを小文
字だけに変換します。

`Mouse-2' in the echo area does the same.
*Note Yanking::.
文字`M-y'は、キルリングから探索文字列にテキストをコピーします。
これには、ヤンクコマンド`C-y'がヤンクするのと
同じテキストを用います。エコー領域で `Mouse-2' としても同様のことができます．
*Note Yanking::。

インクリメンタルサーチを終了すると、探索開始前にポイントが*あった*位置
にマークを置きます。これにより容易にその位置に戻れます。暫定マーク
（transient-mark）モードでは、マークが不活性のときに限って、インクリメ
ンタルサーチが設定するマークも不活性です。

インクリメンタルサーチ中に少し中断すると，一致するすべての候補が強調表
示されます．これにより，次に `C-s' や `C-r' をした時にどこに移動するか
が分かります．強調表示するまでに多少遅れがありますので，現在の一致箇所
もすぐに分かります．このような遅れが無い方がいい場合には
`isearch-lazy-highlight' を `nil' に設定します．

通常の一致箇所のフェイスは `isearch'，その他のすべての一致箇所に使われ
るフェイスは `isearch-lazy-highlight-face' でカスタマイズできます．

インクリメンタルサーチ中に用いる特別な文字をカスタマイズするには、
キーマップ`isearch-mode-map'中のバインディングを変更します。
バインディング一覧は、`C-h f isearch-mode RET'を使って
`isearch-mode'に関する説明文を参照してください。


インクリメンタルサーチ中のスクロール *(2004/03/25)*
---------------------------------------------------

`isearch-allow-scroll' を non-nil に設定することでインクリメンタルサー
チ中にスクロールできるようになります．

検索中に縦方向のスクロールバーや `PRIOR' (`scroll-down') や`NEXT'
(`scroll-up')，`C-l' (`recenter') といった一部のキーバインドを利用でき
るようになります．これにより，現在の一致箇所付近でもっと広い箇所を見る
ことができます．ただし，検索を中断させないためにはこれらのキーバインド
を使わないといけません．M-x COMAND-NAME を使うと必ず検索を中断します．

通常の方法で前置引数を与えることができます．現在の一致箇所がウィンドウ
外になるようなスクロールはできません．

`C-x 2' (`split-window-vertically') や `C-x ^' (`enlarge-window') のよ
うなコマンドはウィンドウはスクロールさせません．しかし，検索中に利用で
きると便利なため，これらのコマンドも検索中に利用できます．

デフォルトでスクロールさせるコマンド(検索中に利用できるコマンド)として
設定されているものの一覧や他のコマンドを設定する方法は *Note
Configuring Scrolling:: を参照ください．


低速端末でのインクリメンタルサーチ *(2004/03/26)*
-------------------------------------------------

速度の遅い端末でのインクリメンタルサーチでは、表示時間が少なくてすむよ
うに設計された表示形式を使います。みつけた箇所でバッファを再表示するか
わりに、新たに1行分のウィンドウを作ってそこにみつけた行を表示します。こ
の1行分のウィンドウは、探索することでポイントが画面に表示中のテキストか
ら飛び出た時点で使われます。

探索を終了すると、この1行分のウィンドウは消えます。そして、Emacsは探索
を完了したウィンドウを再表示して、新たなポイント位置を示します。


低速向けの表示形式を使うのは、端末のボーレートが変数
`search-slow-speed'の値以下である場合で、その初期値は1200です。*Note
Display Custom:: の `baud-rate' を参照ください．

低速向けの表示形式に使う表示用ウィンドウの行数は、変数
`search-slow-window-lines'で制御します。通常の値は1です。



