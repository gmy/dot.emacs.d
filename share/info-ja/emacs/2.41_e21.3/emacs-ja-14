Info file: emacs-ja,    -*-Text-*-
produced by `texinfo-format-buffer'
from file `emacs.texi'
using `texinfmt.el' version 2.41 of  1 Mar 2005.

INFO-DIR-SECTION Emacs
START-INFO-DIR-ENTRY
* Emacs-ja: (emacs-ja).	            Emacs21.3日本語マニュアル.
END-INFO-DIR-ENTRY








File: emacs-ja, Node: Specific Customization, Prev: Face Customization, Up: Easy Customization

特定項目のカスタマイズ
......................

グループ構造を1段ずつ降りていって目指すオプションを探すかわりに、カスタ
マイズしたいオプション／フェイス／グループの名前を直接に指定することも
できます。

`M-x customize-option RET OPTION RET'
     指定したオプションOPTIONだけを含むカスタマイズバッファを開く。
`M-x customize-face RET FACE RET'
     指定したフェイスFACEだけを含むカスタマイズバッファを開く。
`M-x customize-group RET GROUP RET'
     指定したグループGROUPだけを含むカスタマイズバッファを開く。
`M-x customize-apropos RET REGEXP RET'
     指定した正規表現REGEXPに一致するすべてのオプション／フェイス／グルー
     プを含むカスタマイズバッファを開く。
`M-x customize-changed-options RET VERSION RET'
     EmacsのバージョンVERSION以降に意味が変更されたすべてのオプション／
     フェイス／グループを含むカスタマイズバッファを開く。
`M-x customize-saved'
     カスタマイズバッファで保存したすべてのオプションとフェイスを含むカ
     スタマイズバッファを開く。
`M-x customize-customized'
     カスタマイズしたが、まだ保存していないすべてのオプションとフェイス
     を含むカスタマイズバッファを開く。

名前のわかっているオプション変数をカスタマイズバッファで変更したい場合
は、コマンド`M-x customize-option'で直接名前を指定します。これにより、
そのオプションだけを含むカスタマイズバッファが現れます。編集／設定／保
存はこれまで説明したとおりに行いますが、設定の対象になるのは指定したオ
プションだけです。

同様にして、`M-x customize-face'ではフェイス名を指定して変更できます。

同様に、`M-x customize-group'ではグループ名を指定してカスタマイズバッファ
を開くことができます。そのカスタマイズバッファには、指定したグループに
直接含まれているオプション、フェイス、他の（下位の）グループが現れます。
ただし、サブグループの内容は最初は隠されています。それらを表示したい場
合は、通常どおり`[Show]'を起動します。

`M-x customize-apropos'を使うと、カスタマイズするものをもっと細かく制御
できます。このコマンドでは引数として正規表現を指定し、それに一致するす
べてのオプション／フェイス／グループを含んだカスタマイズバッファが現れ
ます。空の正規表現を指定すると、*すべての*オプション／フェイス／グルー
プを含むカスタマイズバッファができます（ただしすごく時間がかかる）。

Emacsの新版へ更新したときには、新しいオプション、意味やデフォルト値が変
更されたオプションをカスタマイズしたいはずです。それには、`M-x
customize-changed-options'を使い、ミニバッファで以前の版のEmacsのバージョ
ン番号を指定します。すると、指定したバージョン以降に定義が変更されたす
べてのオプション（とグループ）を含んだカスタマイズバッファを作ります。

オプションを変更したあとでまちがったと気づいたときは、
変更したものを再検討するために2つのコマンドが使えます。
保存してしまったオプションについては`customize-saved'を、
変更したけれどまだ保存していないオプションについては
`M-x customize-customized'を使います。



File: emacs-ja, Node: Hooks, Next: Locals, Prev: Easy Customization

フック
------

"フック"とはある特定の状況で既存のプログラムから呼び出される関数／関数
群を格納しておく変数をいいます。Emacsには、カスタマイズ用のフックが数多
くあります。

Emacs中のほとんどのフックは"ノーマルフック"です。これらの変数は、引数な
しで呼び出される関数のリストを保持します。ほとんどのフックがノーマルフッ
クなのは、それらを統一的に扱えるからです。Emacsでは、`-hook'で終わる名
前の変数はすべてノーマルフックです。

ほとんどのメジャーモードは初期設定の最終段階でフックを実行します。モー
ドが設定したローカル変数をフックで変更すればよいので、モードのふるまい
をユーザーがカスタマイズすることが容易になります。しかし、フックはそれ
以外の場面でも使われます。たとえば、`suspend-hook'は、Emacsが休止する直
前に実行されます（*Note Exiting::）。

ノーマルフックにフック関数を追加するお勧めのやり方は、`add-hook'を呼ぶ
ことです。フック関数としては任意のLisp関数を使えます。たとえば、テキス
ト（text）モードやテキスト（text）モードを基にしているモードにおいて、
自動的に自動詰め込み（auto-fill）モードをオンにするにはつぎのようにしま
す

     (add-hook 'text-mode-hook 'turn-on-auto-fill)

つぎの例は、Cコードの字下げをカスタマイズするのにフックを使う方法を示し
ます。（誰でも字下げには独自の好みがある）。ここでは、フック関数は名前
のないラムダ式です。

     (setq my-c-style
       '((c-comment-only-line-offset . 4)
         (c-cleanup-list . (scope-operator
		       empty-defun-braces
		       defun-close-semi))
         (c-offsets-alist . ((arglist-close . c-lineup-arglist)
			(substatement-open . 0)))))

     (add-hook 'c-mode-common-hook
       (function (lambda ()
         (c-add-style "my-style" my-c-style t))))

どの順番で実行されても大丈夫なようにフック関数を設計するのが最良です。
実行順序に依存するのは、『事故を呼び込む』ようなものです。しかし、順番
は予測できます。もっとも最近に追加したフック関数ほど先に実行されます。



File: emacs-ja, Node: Locals, Next: File Variables, Prev: Hooks

ローカル変数
------------

`M-x make-local-variable RET VAR RET'
     変数VARがカレントバッファでローカルに値を持つようにする。
`M-x kill-local-variable RET VAR RET'
     変数VARがカレントバッファではグローバル値を使うようにする。
`M-x make-variable-buffer-local RET VAR RET'
     変数VARを、値を設定したときにその時点のカレントバッファでローカル
     に値を持つようにする。

ほとんどの変数はEmacsバッファに対して"ローカル"にできます。つまり、その
変数のバッファ中での値は他のバッファでの値とは独立になります。いくつか
の変数はつねにすべてのバッファにおいてローカルです。それ以外の変数はす
べて、"グローバル"な値、つまりその変数をローカルにしていないすべてのバッ
ファにおいて共有される値を持ちます。

`M-x make-local-variable'は変数名を受け取り、その変数をカレントバッファ
においてローカルにします。それ以降、このバッファ内でその変数を変更して
も他のバッファには影響しませんし、その変数のグローバルな値を変更しても
このバッファ内での値には影響しません。

`M-x make-variable-buffer-local'は、変数名を受け取り、値が設定されると
その変数が自動的にローカルになるようにします。もっと正確にいえば、この
ように特別な印を変数に付けておくと、通常の方法で変数に値を設定するとき
にはつねにまず`make-local-variable'が実行されるようになるのです。このよ
うな変数を"バッファごとの変数"と呼びます。

メジャーモード（*Note Major Modes::）では、変数を設定するまえにつねにロー
カルにします。このため、あるバッファでメジャーモードを変更しても他のバッ
ファには影響が及びません。マイナモード（*Note Minor Modes::）も同様で、
通常、マイナモードごとにオン／オフを制御する変数があり、その変数が
`nil'以外のときにそのマイナモードはオンになります。ほとんどのマイナモー
ドでは、その制御用変数はバッファごとの変数です。

Emacsには、つねにバッファごとの変数であるような変数が数多くあります。
`abbrev-mode'、`auto-fill-function'、`case-fold-search'、
`comment-column'、`ctl-arrow'、`fill-column'、`fill-prefix'、
`indent-tabs-mode'、`left-margin'、`mode-line-format'、
`overwrite-mode'、`selective-display-ellipses'、`selective-display'、
`tab-width'、`truncate-lines'がそのような変数です。これ以外にもつねに各
バッファでローカルな変数はありますが、それらは内部作業用の変数です。

いくつかの変数はディスプレイに対してローカルになっているため、バッファ
に対してローカルにはできません（*Note Multiple Displays::）。これらの変
数をバッファにローカルにしようとすると、エラーメッセージが表示されます。

`M-x kill-local-variable'は、変数名を受け取り、その変数をカレントバッファ
に対してローカルでなくします。それ以降そのバッファでは、その変数のグロー
バルな値が使われます。メジャーモードを設定すると、"つねにローカル"と印
が付いた少数の特別な変数を除いて、そのバッファにローカルなすべての変数
をローカルでなくします。

ある変数がカレントバッファでローカルか否かに係わらずその変数のグローバ
ルな値を設定したければ、`setq-default'を使います。これは`setq'のように
使われますが、（たとえローカルな値があったとしても）つねにグローバルな
値のほうを設定します。その変数がローカルな値を持っている場合、新たに設
定したグローバルな値は別のバッファに切り替えるまでは参照できません。以
下に例をあげます。

     (setq-default fill-column 75)

`setq-default'は、`make-variable-buffer-local'で印を付けた変数のグロー
バルな値を設定する唯一の方法です。

Lispプログラム中では、変数のデフォルト値を参照するためには
`default-value'を使えます。この関数はシンボルを引数とし、その変数のデフォ
ルト値を返します。引数は評価されるので、普通は引数をクォートします。た
とえば、`fill-column'のデフォルト値を取得するにはつぎのようにします。

     (default-value 'fill-column)



File: emacs-ja, Node: File Variables, Prev: Locals

ファイルにローカルな変数
------------------------

Emacsでファイルを編集する際に、そのファイルに対応したローカル変数とその
値を指定することができます。Emacsはファイルを訪問すると、ローカル変数指
定の有無を検査し、あれば指定された変数を自動的にバッファにローカルにし
て、その値をファイルで指定された値に設定します。

ローカル変数とその値を設定するには2つの方法があります。1つはファイルの
先頭行に書くことで、もう1つはローカル変数リストを書くことです。先頭行に
書く場合は、たとえばつぎのようにします。

     -*- mode: MODENAME; VAR: VALUE; ... -*-

変数とその値を「:」で区切った対を「;」で区切って並べ、いくつでも指定で
きます。`mode: MODENAME;'はメジャーモードを指定するもので、行の最初にあ
る必要があります。VALUEは評価されずに書かれているとおりのまま使われます。
以下は、Lispモードで2つの変数に数値を設定する例です。

     ;; -*-mode: Lisp; fill-column: 75; comment-column: 50; -*-

この方法では、ファイルのコーディングシステムも指定できます。
つまり、`coding'という名前の『変数』に値を指定すればよいのです。
『値』は、Emacsが認識できるコーディングシステム名である必要があります。
*Note Coding Systems::。

一方、"ローカル変数リスト"はファイルの末尾（最後のページ）に置きます。
（最後のページにはローカル変数リストだけを置くというのを勧めます。）ロー
カル変数リストは`Local Variables:'という内容を含む行で始まり、`End:'と
いう内容を含む行で終ります。これらの行のあいだに、1つの変数につき1行ず
つ、`VARIABLE: VALUE'という形で変数の名前と値を指定します。VALUEは評価
されずにファイルに書かれたとおりにそのまま使われます。ファイルにローカ
ル変数リストと`-*-'の行が両方含まれていた場合には、Emacsはまず`-*-'の行
を*すべて*処理してから、続いてローカル変数リストの内容を*すべて*処理し
ます。

以下にローカル変数リストの例を示します：

     ;;; Local Variables: ***
     ;;; mode:lisp ***
     ;;; comment-column:0 ***
     ;;; comment-start: ";;; "  ***
     ;;; comment-end:"***" ***
     ;;; End: ***

上の例では、各行は`;;;'で始まり`***'で終っています。Emacsはこれらの接頭
辞と接尾辞をリストの最初の内容に基づいて認識します。つまり、特別な文字
列`Local Variables:'の前後の文字列を、それぞれ、接頭辞、接尾辞とみなし、
それ以降の行についてはこの接頭辞と接尾辞を無視します。

接頭辞と接尾辞を使う主な理由は、ローカル変数リストをコメントの中に入れ
ることで、そのファイルを読み込む他のプログラムを困惑させないようにする
ことです。上の例では、コメントが`;;;'で始まり`***'で終るような言語を想
定しています。変数`comment-start'と`comment-end'のローカルな値で、この
ような変な構文に対処するようにEmacsをカスタマイズするのです。必要ないの
であれば、接頭辞（と接尾辞）は使わないでください。

ローカル変数リストにおいては、2つの変数名が特別な意味を持ちます。変数
`mode'に対する値は、実際にはメジャーモードを設定します。変数`eval'に対
する値は、式として評価されますが、その結果は捨てられます。`mode'と
`eval'は本当の変数ではなく、他の状況でこれらの名前の変数に値を設定して
もなんら特別な意味を持ちません。メジャーモードを設定するために`mode'を
指定する場合は、ローカル変数リストの先頭に書く必要があります。

仮想的な『変数』`mode'は、メジャーモードだけでなくマイナモードを設定す
るのにも使えます。実は、この指定は2回以上使うことができて、最初はメジャー
モードを設定し、それ以降は（それぞれ）マイナモードを設定します。しかし、
マイナモードはユーザーの好みに応じて選ぶものですから、普通はファイルで
マイナモードを指定するべきではないでしょう。

たとえば、ローカル変数リストで自動詰め込み（auto-fill）モードをオンにし
たいと思うかもしれませんが、それはまちがいです。自動詰め込みにするかど
うかは、個人の好みの問題であり、ファイルの中身によって決まるものではな
いからです。ある種別のファイルでいつも自動詰め込みにしたければ、個人の
`.emacs'ファイルで（状況に応じて）自動詰め込み（auto-fill）モードをオン
にするようなメジャーモードのフックを設定してください（*Note Init
File::）。ローカル変数リストで他人に好みを押し付けてはいけません。

ローカル変数リストは、ファイルの末尾から3000文字以内にある必要があり、
ファイルがページに分かれている場合には最後のページにある必要があります。
これらが守られていないと、Emacsはローカル変数リストがあることを認識しま
せん。これらの規則の目的は、最後ではないページに偶然`Local Variables:'
があってもEmacsが誤認しないようにすることと、全体が1ページでローカル変
数リストを持たない長いファイルを訪問するときでもファイル全体を探さなく
てもすむようにするためです。

バッファのローカル変数やメジャーモードを、
ローカル変数リストがあるときにはそれによる指定も含めて、
ファイル名とファイルの内容に基づいたものにリセットしたければ、
`normal-mode'コマンドを使ってください。
*Note Choosing Modes::。

変数`enable-local-variables'は、ファイル中のローカル変数指定を処理する
か否かを制御します。つまり、ローカル変数指定を無視するようにもできます。
デフォルトは`t'で、ファイル中のローカル変数指定を処理します。値を`nil'
にすると、ファイル中のローカル変数指定を無視します。これら以外の値の場
合は、ファイル中にローカル変数指定があると、その内容を表示して処理する
かどうか問い合わせます。

仮想的な『変数』`eval'といくつかの（実在する）変数に対する指定は、ある
種の危険性をもたらします。他人のファイルを訪問したとき、そこに書かれて
いるローカル変数指定によってあなたが使っているEmacsのふるまいがどのよう
にでも変更できるからです。このため、オプション`enable-local-eval'により、
変数`eval'、さらに、`-hook'、`-hooks'、`-function'、`-functions'という
名前で終る変数、および、他のいくつかの変数に対するローカル変数指定を処
理するかどうか制御できるようになっています。`enable-local-variables'と
同じように指定できる値は3種類あって、`t'、`nil'、これら以外です。デフォ
ルトは`maybe'で、これは`t'でも`nil'でもありませんから、Emacsはこれらの
ローカル変数指定があるときは確認を求めてきます。



File: emacs-ja, Node: Key Bindings, Next: Keyboard Translations

キーバインディングのカスタマイズ
================================

本節では、コマンドをキーに対応付ける"キーバインディング"と、キーバイン
ディングを記録する"キーマップ"について説明します。また、キーバインディ
ングをカスタマイズする方法についても説明します。

コマンドとは、対話利用向けに定義されたLisp関数であることを思い出してく
ださい。コマンドには、他のLisp関数と同様、通常、英小文字とハイフンから
成る関数名前が付いています。

* Menu:

* Keymaps::             Generalities.  The global keymap.
* Prefix Keymaps::      Keymaps for prefix keys.
* Local Keymaps::       Major and minor modes have their own keymaps.
* Minibuffer Maps::     The minibuffer uses its own local keymaps.
* Rebinding::           How to redefine one key's meaning conveniently.
* Init Rebinding::      Rebinding keys with your init file, `.emacs'.
* Function Keys::       Rebinding terminal function keys.
* Named ASCII Chars::   Distinguishing TAB from `C-i', and so on.
* Non-ASCII Rebinding:: Rebinding non-ASCII characters such as Latin-1.
* Mouse Buttons::       Rebinding mouse buttons in Emacs.
* Disabling::           Disabling a command means confirmation is required
                          before it can be executed.  This is done to protect
                          beginners from surprises.



File: emacs-ja, Node: Keymaps, Next: Prefix Keymaps, Prev: Key Bindings, Up: Key Bindings

キーマップ
----------

キー列とコマンド関数との対応は"キーマップ"と呼ばれるデータ構造に保持さ
れています。Emacsには数多くのキーマップがあり、それぞれが特定の場面で使
われます。

"キー列"（または単に"キー"）とは、ひとまとまりの意味を持つ"入力イベント
の並びをいいます。入力イベントは、文字、ファンクションキー、マウスボタ
ン、つまり、端末から計算機に送ることができるすべての入力から成ります。
キー列の意味付けは、どのコマンドを実行するかを表す"バインディング"によっ
て決まります。キーマップの役割は、これらのバインディングを保持すること
です。

"グローバル"キーマップはもっとも重要なキーマップですが、それはグローバ
ルキーマップがつねに有効だからです。グローバルキーマップは基本
（fundamental）モードのキーを定義します。つまり、そこに含まれる定義の大
部分は、ほとんどまたはすべてのメジャーモードに共通のものです。各メ
ジャー／マイナモードは、グローバルキーマップの定義の一部を置き換えるよ
うな独自のキーマップを持つことができます。

たとえば、`g'のような自己挿入文字を打つとその文字がバッファに挿入される
のは、グローバルキーマップでこれらのキーが`self-insert-command'に対応付
けられているからです。また、`C-a'のような標準の編集コマンドも、その意味
付けはグローバルキーマップに書かれています。`M-x global-set-key'のよう
なバインディングを変更するコマンド群は、グローバルキーマップの適切な箇
所に新しいバインディングを書き込みます。

メタ文字はやや違った動作になります。Emacsでは、メタ文字はESCで始まる文
字列に変換されます。ですから、`M-a'という入力はつねにEmacsの中では`ESC
a'に置き換えられて処理されます。つまり、メタ文字は単一の入力イベントで
すが、キーバインディングの観点では2つのイベントとして扱われます。こうなっ
ている理由は歴史的なもので、将来は変わる可能性もあります。

最近のほとんどのキーボードには、文字キーの他にファンクションキーがあり
ます。ファンクションキーは文字キーと同様に入力イベントを送出し、キーマッ
プはそれに対応するバインディングを保持することができます。

多くの端末では、ファンクションキーを打つとコンピュータには一連の文字列
が送られます。具体的にどのファンクションキーがどんな文字列を送るかは端
末によってまちまちです。（多くの場合、文字列は`ESC ['で始まる。）Emacs
が使用中の端末種別を正しく認識していれば、キー列（の先頭でだけでなく）
に現れるファンクションキーに対応した文字列を正しく判別できます。ですか
ら、多くの場合、ファンクションキーの打鍵も1つの入力イベントとして直接
Emacsに送られているとみなして、文字列としての表現形式は無視してかまいま
せん。

マウスボタンも入力イベントを発生させます。これらのイベントには、追加デー
タ、つまり、ボタンを押したり放したりしたときのウィンドウとその中での位
置、時刻が付属しています。ただし、キーバインディングに関しては、どのボ
タンが使われたかだけが問題となります。残りの情報は、コマンドがこれらの
情報を参照する場合だけ意味を持ちます。（通常、マウスから起動できるコマ
ンドは、これらの情報を参照する。）

キーマップは1つのイベントに対する定義のみを保持します。複数キーの列から
成る複数のイベントの解釈には、キーマップの連鎖が使われます。最初のキー
マップが最初のイベントの定義を保持し、その定義がつぎのキーマップになっ
ていて、2番目のイベントの定義を保持し、というようになっています。

キー列にはファンクションキーと文字キーとが混ざっていてもかまいません。
たとえば、`C-x SELECT'というのも許されます。SELECTをプレフィックスキー
として定義しておけば、`SELECT C-n'というのも許されます。マウスイベント
とキーボードイベントを混ぜることさえ可能ですが、そうすると打ち込むのが
面倒ですからお勧めしません。

ユーザーはどんなキー列でも再定義して利用できますが、`C-c'に続けて1文字
というキー列だけを使うのが最善です。このキー列は『ユーザー定義のために
予約』されていて、正しく設計されたEmacsの各種拡張とは衝突しないようになっ
ているからです。F5からF9までのファンクションキーもユーザー定義のために
予約してあります。これ以外のキー列を再定義すると、同じキーを再定義する
拡張やメジャーモードによってあなたの定義が上書きされてしまう可能性があ
ります。



File: emacs-ja, Node: Prefix Keymaps, Next: Local Keymaps, Prev: Keymaps, Up: Key Bindings

プレフィックスキーマップ
------------------------

`C-x'やESCのようなプレフィックスキーはそれぞれ専用のキーマップを持って
いて、そこにはそのプレフィックスキーに続くイベントの定義が保持されてい
ます。

プレフィックスキーの定義は、通常、それに続くイベントの定義を検索するた
めのキーマップです。あるいは、プレフィックスキーの定義がLispシンボルで
あって、その関数の定義がキーマップというのもあります。どちらでも効果は
同じですが、後者では、プレフィックスキーにコマンド名を与えてその用途を
示すことができます。このため、`C-x'にバインドされているのはシンボル
`Ctl-X-Prefix'であり、その関数定義は`C-x'コマンド群に対応するキーマップ
です。`C-c'、`C-x'、`C-h'、ESCはグローバルマップでプレフィックスキーと
して定義されていますから、これらはつねにプレフィックスキーとして使用で
きます。

通常のプレフィックスキーに加えて、メニューバーを表す『仮想的なプレフィッ
クスキー』があります。メニューバーのキーバインディングに関する特別な点
については*Note メニューバー: (elisp)Menu Barを参照してください。ポップ
アップメニューを表示させるマウスボタンイベントもまた、プレフィックスキー
です。こちらの詳細については*Note メニューキーマップ: (elisp)Menu
Keymapsを参照してください。

決まった変数に格納されているプレフィックスキーマップもあります。

   * `ctl-x-map'は`C-x'に続くキーを探すためのマップを納めた変数名。
   * `help-map'は`C-h'に続くキーを探すためのマップを納めた変数名。
   * `esc-map'はESCに続くキーを探すためのマップを納めた変数名。つまり、
     すべてのメタ文字は実際にはこのマップで定義されている。
   * `ctl-x-4-map'は`C-x 4'に続くキーを探すためのマップを納めた変数名。
   * `mode-specific-map'は`C-c'に続くキーを探すためのマップを納めた変数名。



File: emacs-ja, Node: Local Keymaps, Next: Minibuffer Maps, Prev: Prefix Keymaps, Up: Key Bindings

ローカルキーマップ
------------------

これまではグローバルキーマップの諸側面について説明しました。メジャーモー
ド固有のキーバインディングを"ローカルキーマップ"に定義することで、各メ
ジャーモードはEmacsの動作を変更します。たとえば、Cモードでは、TABをCの
コードの現在行を字下げする機能に差し替えます。バッファ内の一部のテキス
トで、そのバッファのメジャーモードのかわりとなる固有のキーマップを指定
することもできます。

マイナモードもローカルキーマップを持てます。その場合、マイナモードが生
きているときには、そのキーマップがメジャーモードのローカルキーマップや
グローバルキーマップに優先します。

Lispモードおよびその他のいくつかのメジャーモードのローカルキーマップは、
そのモードを使っていないときでもつねに存在します。これらのキーマップは、
`lisp-mode-map'などの変数に格納されています。さほど頻繁に使われないメ
ジャーモードの場合は、そのモードがセッションの中で初めて起動されたとき
にローカルキーマップが作られます。これは、メモリを節約するためです。こ
のようなモードのキーマップを変更したい場合には、当該メジャーモードの"モー
ドフック"を使う必要があります（以下を参照）。

すべてのマイナモードのキーマップは、あらかじめ作られています。マイナモー
ドのキーマップ作成をそのマイナモードが最初に起動されるまで遅延させる方
法はありません。

ローカルキーマップでは、その中のあるキーの定義をプレフィックスキーマッ
プとすることで、そのキーをローカルなプレフィックスキーとして再定義でき
ます。そのキーがグローバルにもプレフィックスキーであると定義されている
なら、ローカルキーマップとグローバルキーマップの内容は実質的に統合され、
プレフィックスキーに続くイベントは両方のキーマップで検索されます。した
がって、あるモードのローカルキーマップが`C-c'を別のキーマップとして定義
し、そのキーマップでは`C-z'をコマンドとして定義すると、これらによって
`C-c C-z'のローカルな意味が与えられます。しかし、これは`C-c'で始まる他
のキー列には影響しません。あるキー列が独自のローカルなバインディングを
持たなければ、グローバルなバインディングが意味を持つからです。

いいかえれば、Emacsが複数イベントから成るキー列を扱う方法は、複数のキー
マップから1つずつ、キー列全体に一致するバインディングを探すのです。まず、
マイナモードが生きていればそのキーマップを検索し、つぎにメジャーモード
のキーマップを検索し、最後にグローバルキーマップを検索します。これは厳
密にはキーの検索動作とは違いますが、通常の状況でどうなるか理解するには
十分です。

メジャーモードのローカルバインディングを変更するには、そのモードのロー
カルキーマップを変更する必要があります。通常、そのためにはそのモードが
最初に使われるまで待つ必要があります。というのは、ほどんどのメジャーモー
ドは使われるまでキーマップを作成しないからです。ですから、個人の
`~/.emacs'ファイルでメジャーモードのバインディングを変更したければ、そ
のモードのモードフックを使ってそのモードが最初に使われるまで（変更を）
遅らせる必要があります。

たとえば、texinfoモードを選択する`texinfo-mode'コマンドはフック
`texinfo-mode-hook'を実行します。このフックを使って`C-c n'と`C-c p'に対
する（有益ではないですが）ローカルバインディングをtexinfoモードに追加す
るには、つぎのようにします。

     (add-hook 'texinfo-mode-hook
               '(lambda ()
                  (define-key texinfo-mode-map
                              "\C-cp"
                              'backward-paragraph)
                  (define-key texinfo-mode-map
                              "\C-cn"
                              'forward-paragraph)
                  ))

*Note Hooks::。



File: emacs-ja, Node: Minibuffer Maps, Next: Rebinding, Prev: Local Keymaps, Up: Key Bindings

ミニバッファのキーマップ
------------------------

ミニバッファも一群の専用ローカルキーマップを持っています。それらには各
種の補完や脱出コマンドが定義されています。

   * `minibuffer-local-map'は通常の入力に使われる（補完なし）。
   * `minibuffer-local-ns-map'も同様。ただし、SPCは、RETと同様に、脱出
     動作である。これは主にMocklispとの互換性のために使われる。
   * `minibuffer-local-completion-map'は弱い補完に使われる。
   * `minibuffer-local-must-match-map'は強い補完と慎重な補完に使われる。



File: emacs-ja, Node: Rebinding, Next: Init Rebinding, Prev: Minibuffer Maps, Up: Key Bindings

キーバインディングの対話的な変更
--------------------------------

Emacsのキーを再定義するには、キーマップの対応する項目を変更すればよいの
です。グローバルキーマップを変更すると、その変更は（同じキーに対して独
自のローカルな定義をしているメジャーモードを除く）すべてのメジャーモー
ドに影響します。あるいは、カレントバッファのローカルマップを変更すると、
同じメジャーモードを使っているすべてバッファに影響が及びます。

`M-x global-set-key RET KEY CMD RET'
     CMDを実行するようにKEYをグローバルに定義する。
`M-x local-set-key RET KEY CMD RET'
     CMDを実行するようにKEYを（現在のメジャーモードで）ローカルに定義す
     る。
`M-x global-unset-key RET KEY'
     KEYをグローバルマップで未定義にする。
`M-x local-unset-key RET KEY'
     KEYを（現在のメジャーモードで）ローカルに未定義にする。

たとえば、Emacsを休止してログインシェルでコマンドを実行するかわりに、
Emacsバッファ内のサブシェルでコマンドを実行したいとします。通常、（Xウィ
ンドウシステムを使っていない場合）`C-z'は関数`suspend-emacs'にバインド
されていますが、つぎのようにこのキーを`shell'にバインドすれば、このキー
でEmacs内の対話的サブシェルを起動するように変更できます。

     M-x global-set-key RET C-z shell RET

`global-set-key'はキー列に続けてコマンド名を読み取ります。使いたいキー
を打鍵すると、どのキーをバインドしたいのかを確認するつぎのようなメッセー
ジが表示されます。

     Set key C-z to command:

同じ手順で、ファンクションキーやマウスイベントを再定義できます。バイン
ドすべきキーを指定するときに、キーのかわりにファンクションキーを押した
りマウスボタンをクリックしてください。

複数イベントから成るキーも単一イベントのキーと同様にして再定義できます。
Emacsは再定義すべきキー列が完成するまで（つまりプレフィックスキーではな
いキーが出てくるまで）イベントを読み続けます。たとえば、KEYとして`C-f'
を打てばそれで終りですから、ミニバッファはただちにCMDを読む状態になりま
す。一方、`C-x'を打つとさらにその先のキーを読みます。そこで`4'を打つと、
さらにその先のキーが読まれる、というようになります。たとえば、

     M-x global-set-key RET C-x 4 $ spell-other-window RET

では、`C-x 4 $'を（実在しない）コマンド`spell-other-window'にバインドし
ます。

`C-c'に続けて英字という2文字のキー列は、ユーザーのカスタマイズ用に予約
されています。Lispプログラムはこれらのキー列を定義しないことになってい
ますから、これらのキー列のバインディングはどのメジャーモードでも使え、
いかなる機能とも干渉しないはずです。

`global-unset-key'でキーのグローバルな定義を取り除けます。そのキーは"未
定義"になります。未定義のキーを打つと、Emacsはベルを鳴らします。同様に、
`local-unset-key'は現在のメジャーモードでキーを未定義にしますから、グロー
バルな定義（あるいはグローバルでの未定義状態）が現在のメジャーモードで
ふたたび有効になります。

キーを再定義（または未定義に）して、あとでもとに戻したいと思った場合、
キーを未定義にしてももとには戻りません。キーの標準定義を設定し直す必要
があります。キーの標準定義を調べるには、基本（fundamental）モードのバッ
ファにいって`C-h c'を使います。本書のキーの説明にもコマンド名を掲載して
あります。

まちがって、あるコマンドを実行することを防ぎたければ、キーを未定義にす
るのでなく、コマンドを使用禁止にするのがよいでしょう。必要になったとき
に使用禁止コマンドを起動するのは造作もありません。



File: emacs-ja, Node: Init Rebinding, Next: Function Keys, Prev: Rebinding, Up: Key Bindings

初期化ファイルでのキーの変更
----------------------------

いつでもあるキーバインディングを設定しておきたければ、その指定を個人の
`.emacs'ファイルにLispのコードとして書いておきます。

これを行うもっとも簡単な方法は、ASCII文字とメタ修飾付きのASCII文字に対
してのみ使えます。たとえば、`C-z'を`shell'にバインドするにはつぎのよう
にします。

     (global-set-key "\C-z" 'shell)

この例では1つの文字`C-z'から成る文字列定数を指定しています。コマンド名
`shell'のまえのクォート「'」は、`shell'を変数ではなく定数シンボルとして
扱う印です。クォートがないと、Emacsは`shell'を変数としてその値をただち
に評価しようとします。すると、望んでいることではなく、エラーになります。

つぎは、2文字のキー列をバインドする例です。

     (global-set-key "\C-xl" 'make-symbolic-link)

キー列にファンクションキーやマウスボタンイベントが含まれていたり、
`C-='や`H-a'などの非ASCII文字が含まれているなら、文字列よりもっと一般的
な指定方法であるベクタを使った指定を使う必要があります。

Emacs Lispでのベクタの書き方は、その要素を中括弧（`[...]'）で囲みます。
要素は空白で区切ります。要素がシンボルであれば、単にその名前だけを書け
ばよく、区切り記号などは不要です。要素が文字であれば、Lispの文字定数と
して、つまり`?'に続けてその文字が文字列中に現れるのと同じ書き方で、書い
てください。

ベクタを使って`C-='（ASCIIの範囲にないコントロール文字）、`H-a'（ハイパー
文字。ASCIIにはハイパー文字は含まれない）、F7（ファンクションキー）、
`C-Mouse-1'（キーボード修飾付きのマウスボタン）をバインドする例を示しま
す。

     (global-set-key [?\C-=] 'make-symbolic-link)
     (global-set-key [?\H-a] 'make-symbolic-link)
     (global-set-key [f7] 'make-symbolic-link)
     (global-set-key [C-mouse-1] 'make-symbolic-link)

単純な（文字列ですむ）場合にベクタを使ってもかまいません。先の2つの例を
ベクタを使うように書き直すとつぎのようになります。

     (global-set-key [?\C-z] 'shell)

     (global-set-key [?\C-x ?l] 'make-symbolic-link)



File: emacs-ja, Node: Function Keys, Next: Named ASCII Chars, Prev: Init Rebinding, Up: Key Bindings

ファンクションキーの再定義
--------------------------

キー列には通常の文字以外にもファンクションキーを含めることができます。
キーボードの文字がLispの文字（実は整数です）で表されるのに対し、ファン
クションキーはLispシンボルで表されます。ファンクションキーに単語のラベ
ルが付いているなら、その単語が対応するLispシンボルの名前になります。た
とえば普通に見られるファンクションキーとLispシンボルの対応はつぎのとお
りです。

`left', `up', `right', `down'
     カーソル矢印キー。

`begin', `end', `home', `next', `prior'
     その他のカーソル移動キー。

`select', `print', `execute', `backtab'
`insert', `undo', `redo', `clearline'
`insertline', `deleteline', `insertchar', `deletechar'
     その他のファンクションキー。

`f1', `f2', ... `f35'
     （キーボードの上端に並んでいる）番号の付いたファンクションキー。

`kp-add', `kp-subtract', `kp-multiply', `kp-divide'
`kp-backtab', `kp-space', `kp-tab', `kp-enter'
`kp-separator', `kp-decimal', `kp-equal'
     （普通のキーボードの右側にまとまっている）キーパッドのキーで、名前
     や句読点が印字されているもの。

`kp-0', `kp-1', ... `kp-9'
     キーパッドの数字キー

`kp-f1', `kp-f2', `kp-f3', `kp-f4'
     キーパッドのPFキー。

これらの名前は習慣的なものですが、システムによっては
（とりわけXウィンドウシステムを使っている場合は）、
別の名前になっている場合があります。
あるファンクションキーにどのシンボルが対応しているか調べるには、
`C-h c'に続いてそのキーを打鍵してください。

ファンクションキーのシンボルを含むキー列（あるいは、ASCII以外の文字を含
むもの）は文字列ではなくベクタで指定してください。ベクタの構文では要素
と要素のあいだは空白で区切り、全体を中括弧``[...]''で囲みます。たとえば、
ファンクションキー`f1'をコマンド`rmail'にバインドするには、つぎのように
します。

     (global-set-key [f1] 'rmail)

右矢印キーをコマンド`fowared-char'にバインドするには、つぎのようにしま
す。

     (global-set-key [right] 'forward-char)

これは、シンボル`right'を要素とするベクタのLisp構文です。（このバインディ
ングはEmacsのデフォルト設定に入っている。）

ベクタを用いたキーの再定義ついてより詳しくは、*Note Init Rebinding::。

キー列の中でファンクションキーと文字を混ぜることができます。
以下の例は、
`C-x NEXT'をコマンド`forward-page'にバインドしています。

     (global-set-key [?\C-x next] 'forward-page)

ここで、`?\C-x'はLispの文字定数で、文字`C-x'を表します。ベクタのもう1つ
の要素である`next'は、シンボルですから`?'は不要です。

ファンクションキーに対して、修飾キーCTRL、META、HYPER、SUPER、ALT、
SHIFTを指定できます。これらの修飾キーを指定するには、シンボル名のまえに
`C-'、`M-'、`H-'、`s-'、`A-'、`S-'を付けてください。たとえば、
`Hyper-Meta-RIGHT'で1語先へ移動するにはつぎのように指定します。

     (global-set-key [H-M-right] 'forward-word)



File: emacs-ja, Node: Named ASCII Chars, Next: Non-ASCII Rebinding, Prev: Function Keys, Up: Key Bindings

名前の付いたASCIIコントロール文字
---------------------------------

TAB、RET、BS、LFD、ESC、DELはもともとASCIIの特定のコントロール文字に対
応していたのですが、よく使われるため別にそれ専用のキーを持つようになり
ました。のちに人々はEmacsでこれらのキーとそれらと『同じ』文字をCTRLキー
と組み合わせて打鍵した場合とを区別できると便利だと気がつきました。

EmacsではXウィンドウシステムを使っている場合、これら2種類の入力を区別し
ます。つまり、キーボード上の特殊キーの方は`tab'、`return'、`backspace'、
`linefeed'、`escape'、`delete'という名前のファンクションキーとして扱う
のです。これらのファンクションキーは、*もし*それ固有のバインディングが
指定されていなければ、自動的に対応するASCII文字に変換されます。その結果、
特にこの2種類を区別したいと思わない限りは、ユーザーもLispプログラムもこ
れらの区分について気にする必要はありません。

（たとえば）TABと`C-i'を区別したくないなら、ASCII文字TAB（8進コード011）
に対応するバインディング1つだけを指定してください。区別したいのなら、こ
のASCII文字に対するバインディングに加えて、『ファンクションキー』`tab'
に対するバインディングも指定します。

通常のASCII端末では、TABと`C-i' （および上記の対応する組のそれぞれ）を
区別する方法はありません。というのは、端末はどちらが押されても同じ文字
を送出するからです。



File: emacs-ja, Node: Non-ASCII Rebinding, Next: Mouse Buttons, Prev: Named ASCII Chars, Up: Key Bindings

キーボード上の非ASCII文字
-------------------------

アクセント付き文字などの非ASCII文字を送出するキーがあるキーボードでは、
それらのキーの再定義には、少々トリックが必要です。2つの解決方法がありま
す。1つめは、`set-keyboard-coding-system'（*Note Specify Coding::）を使っ
て、キーボードのコーディングシステムを指定することです。そうすれば、つ
ぎのように書いて、通常の方法でそれらのキーを再定義できます。

     (global-set-key [?CHAR] 'some-function)

ただし、CHARを挿入するには、定義したいキーを打ちます。

キーボードのコーディングシステムを指定しないと、上のようにはできません。
そのかわりに、端末が実際に送出するコードを調べる必要があります。Emacsで
これを簡単に行うには、`C-x b temp RET'で空バッファを作成し、`M-x
toggle-enable-multibyte-characters RET'でユニバイトにしてから、このバッ
ファに文字を挿入するキーを打ちます。

文字のまえにポイントを移動して、`C-b C-x ='と打ちます。8進数、10進数、
16進数の3通りで表した文字コードを括弧で括ったメッセージがミニバッファに
表示されます。定義するには、3つの数字の2番目、つまり、10進数をベクタの
中に書きます。

     (global-set-key [DECIMAL-CODE] 'some-function)



File: emacs-ja, Node: Mouse Buttons, Next: Disabling, Prev: Non-ASCII Rebinding, Up: Key Bindings

マウスボタンの再定義
--------------------

Emacsではマウスボタンを表すのにもLispシンボルを使います。Emacsのもっと
も一般的なマウスイベントは"クリック"（click）イベントです。これはマウス
ボタンを押して、マウスを移動せずにボタンを放したときに発生します。ボタ
ンを押した状態でマウスを移動すると"ドラッグ"（drag）イベントになります。
そして最後にマウスボタンを放したときにも、やはり"ドラッグ"イベントが発
生します。

基本的なクリックイベントに対応するシンボルは、左ボタンに対しては
`mouse-1'、左から2番目のボタンに対しては`mouse-2'、などとなっています。
2番目のボタンをクリックしたときカレントウィンドウを分割するには、つぎの
ように設定します。

     (global-set-key [mouse-2] 'split-window-vertically)

ドラッグイベントについても同様ですが、
イベント名の`mouse'のまえに`drag-'が付きます。
たとえば、第1ボタンを押したままドラッグすると
`drag-mouse-1'イベントが発生します。

マウスボタンが押されたときに発生するイベントに対してバインディングを指
定することもできます。これらのイベントは`drag-'のかわりに`down-'で始ま
ります。これらのイベントはキーバインディングが定義されているときだけ生
成されます。`down-'イベントのあとには、必ず、対応するクリック／ドラグッ
イベントが発生します。

必要ならば、シングルクリック／ダブルクリック／トリプルクリックを区別す
ることもできます。ダブルクリックとは、ほぼ同じ位置でマウスボタンを2回ク
リックすることです。最初のクリックで通常のクリックイベントが発生します。
最初のクリックから十分短い時間内に2回目のクリックが起こると、クリックイ
ベントではなくダブルクリックイベントが発生します。ダブルクリックイベン
トは、`double-'で始まります。たとえば、`double-mouse-3'です。

つまり、同じ場所で2回クリックがあったとき、2回目のクリックに特別な意味
を与えることはできますが、ただし最初のクリックで発生する通常のシングル
クリックに対して定義された動作も実行されることを前提としなければなりま
せん。

このような制限のため、ダブルクリックで行えることが制約されますが、ユー
ザーインターフェイスデザイナは、よいユーザーインターフェイスがつねにそ
のような制約に従うべきだとの考えを述べています。つまり、ダブルクリック
はシングルクリックと類似した動作をすべきであり、『それよりいくらか多く』
の動作をするのがよい、ということです。そして、ダブルクリックイベントに
対応するコマンドがその「いくらか多く」のぶんの動作を行うべきだというこ
とです。

ダブルクリックイベントに対してバインディングが定義されていなければ、ダ
ブルクリックは2つのシングルクリックとして扱われます。その結果、シングル
クリックに対応するコマンドが2回実行されることになります。

Emacsではさらにトリプルクリックイベントも使えます（その場合、名前は
`triple-'で始まる）。しかし4重クリックをイベントタイプとして区別しませ
ん。ですから、3回目以降の連続したクリックは、すべてトリプルクリックイベ
ントとして報告されます。ただし、連続したクリックの回数はイベントリスト
に記録されていますから、本当に4重以上のクリックを区別したければそうする
こともできます。4重以上のクリックに特別な意味を与えるのはお勧めできませ
んが、4回だと1回と同じ、5回だと2回と同じというように3つの選択肢のあいだ
で巡回できるようにするのは場合によっては有効かもしれません。

Emacsはまた、ドラッグやボタンイベントでも複数回の押し下げを記録します。
たとえば、ボタンを2回押してからそのままマウスを移動した場合、Emacsは
`double-drag-'で始まるイベントを生成します。ドラッグでなくボタンを押し
下げただけの場合は同様に、`double-down-'で始まるイベントを生成します
（ただし、他のボタンイベントと同様に、そのイベントに対するバインディン
グがなければ無視される）。

変数`double-click-time'は、どれくらいの時間間隔内であれば2つの隣接する
クリックをダブルクリックとみなすかを指定します。単位はミリ秒です。値が
`nil'であれば、ダブルクリックを検出しません。値が`t'であれば、時間間隔
の上限はないものとして扱います。

マウスイベントに対応するシンボルにはさらに、`C-'、`M-'、`H-'、`s-'、
`A-'、`S-'の各プレフィックスで、修飾キーの情報も組み込めます。順番は、
プレフィックスに続いて`double-'や`triple-'があり、そのあとが`drag-'や
`down-'ということになります。

フレームには、モード行やスクロールバーなどの
バッファ中のテキストを表示する以外の部分もあります。
マウスイベントがこれらの特別な部分で発生したものかどうかを調べるために、
ダミーの「プレフィックスキー」があります。
たとえば、マウスがモード行でクリックされた場合、
まず`mode-line'というプレフィックスキーが送られ、
続いて通常のマウスボタンに対応したイベントが送られます。
ですから、モード行で第1ボタンがクリックされたときに
`scroll-up'を実行するにはつぎのようにします。

     (global-set-key [mode-line mouse-1] 'scroll-up)

ダミーのプレフィックスキーとその意味はつぎのとおりです。

`mode-line'
     マウスがウィンドウのモード行にある。
`vertical-line'
     マウスが横に隣接するウィンドウ間の境界線上にある。（スクロールバー
     を表示させると、境界線のかわりにスクロールバーが現れる。）
`vertical-scroll-bar'
     マウスが縦スクロールバー上にある。（Emacsで使えるスクロールバーは、
     現在のところ縦スクロールバーのみ。）

1つのキー列の中に2つ以上のマウスボタンイベントを含めることもできますが、
普通はあまりしないでしょう。



File: emacs-ja, Node: Disabling, Prev: Mouse Buttons, Up: Key Bindings

使用禁止コマンド
----------------

コマンドを使用禁止にすると、コマンドの実行にはユーザーの確認が必要にな
ります。コマンドを使用禁止にする目的は、初心者がそのコマンドをまちがっ
て実行してしまい、混乱するのを防ぐためです。

Emacs上で使用禁止コマンドを対話的に実行しようとすると、コマンド名、説明
文、とりあえずどうすべきかの指示を表示したウィンドウが現れます。つぎに
Emacsはコマンドを実行するか、使用禁止を解除してから実行するか、実行を取
り消すかを問い合わせてきます。コマンドの使用禁止を解除することを選ぶと、
Emacsさらに、以後恒久的にそうするのか、または現在のセッション内だけそう
するのかも問い合わせてきます。恒久的に使えるようにすると、自動的に個人
の`.emacs'ファイルを編集します。

コマンドを使用禁止にする機構は、コマンドに対応するLispシンボルの属性
`disabled'に`nil'以外の値を設定することです。これを行うLispプログラムは
つぎのようになります。

     (put 'delete-region 'disabled t)

属性`disabled'の値が文字列であれば、コマンドを使用しようとしたときに表
示されるメッセージにその文字列も含まれるようになります。

     (put 'delete-region 'disabled
          "It's better to use `kill-region' instead.\n")

コマンドを使用禁止にするには、`.emacs'ファイルを直接編集するか、
かわってこのファイルを編集するコマンド`M-x disable-command'を使います。
同様に、コマンド`M-x enable-command'は、
`.emacs'ファイルを編集してコマンドを恒久的に使える状態にします。
*Note Init File::。

コマンドが使用禁止であるかどうかは、そのコマンドを起動するキー列には無
関係です。したがって、`M-x'でそのコマンドを起動してもEmacsはその可否を
問い合わせてきます。Lispプログラムからコマンドを関数として呼び出す場合
には使用禁止にしても何の効果もありません。



File: emacs-ja, Node: Keyboard Translations, Next: Syntax, Prev: Key Bindings

キーボード変換
==============

キーボードの機種によっては、Emacsが使用するすべての特殊文字を送ってくれ
ないものがあります。もっともよくある問題は、DEL文字に関するものです。い
くつかのキーボードでは、このきわめて重要な文字を簡単に打ち込む手段があ
りません。それは、削除には`C-h'を使うことを前提としているからです。その
ようなキーボードで削除のためのキーを打つと、Emacsはそれをプレフィックス
文字`C-h'として解釈し、どのヘルプ機能を使うか問い合わせてきてしまいます。
それはユーザーがしたかったことではありません。

Emacs内でこの問題を回避するには、`C-h'をDELに、DELを`C-h'に変換するキー
ボード変換を以下のように設定することで回避できます。

     ;; C-hをDELに変換する。
     (keyboard-translate ?\C-h ?\C-?)

     ;; DELをC-hに変換する。
     (keyboard-translate ?\C-? ?\C-h)

キーボード変換はキーマップによるキーバインディング（*Note Keymaps::）と
同じではありません。Emacsには状況ごとに使い分けられる多数のキーマップが
あるのに対し、キーボード変換は一式だけしかなく、Emacsが端末から読むすべ
ての文字に対してその変換が適用されます。キーボード変換は入力処理のいち
ばん下位のレベルで行われ、キーマップ上の検索はキーボード変換を施した結
果に対して行われます。

XウィンドウシステムではDELETEというキーはファンクションキーであり、
ASCII文字DELとは別ものです。*Note Named ASCII Chars::。キーボード変換は
ASCII文字入力だけに適用され、ファンクションキーとは無関係ですから、Xウィ
ンドウシステムでは上の例はDELETEキーに対して効果をもたらしません。しか
し、Xウィンドウシステムでは上のようなキーボード変換そのものが不要です。
というのは、EmacsはXウィンドウシステムではBACKSPACEキーと`C-h'も区別で
き、通常、BAKSPACEをDELとして扱うからです。

キーボード変換の使い方に関する詳しい情報は、*Note 入力イベントの変換:
(elisp)Translating Inputを参照してください。



File: emacs-ja, Node: Syntax, Next: Init File, Prev: Keyboard Translations

構文テーブル
============

単語や対応した括弧の対を認識するEmacsコマンドはすべて、"構文テーブル
（syntax table）によって制御されます。構文テーブルは、どの文字が開き括
弧で、どの文字が単語の中身で、どの文字がシングルクォートかといったこと
を記述しています。各メジャーモードにはそれぞれ専用の構文テーブルがあり
（ただし、互いに関係のあるメジャーモードが1つの構文テーブルを共用するこ
とはある）、各バッファごとにそのときのメジャーモードの構文テーブルが使
われます。カレントバッファに設定されている構文テーブルはすべてのコマン
ドが使うので、以下ではこれを『現在の』構文テーブルと呼びます。構文テー
ブルは文字テーブル（char-table）型のLispオブジェクトであり、その要素は
数値です。

現在の構文テーブルの内容に関する記述を表示するには、`C-h
s'（`descirbe-syntax'）を使います。記述の表示には各文字ごとに、その文字
の現在の構文を設定するために`modify-syntax-entry'に渡すべき文字列、およ
び、その文字列の英語での説明が含まれます。

構文テーブルに関する詳しい情報については、*Note 構文テーブル:
(elisp)Syntax Tablesを参照してください。



File: emacs-ja, Node: Init File, Prev: Syntax

初期化ファイル`~/.emacs'
========================

Emacsが実行を開始するとき、通常はユーザーのホームディレクトリにあるファ
イル`.emacs'や`.emacs.el'からLispプログラムをロードします。このファイル
がEmacsの初期化の仕方を指定するので、このファイルのことを"初期化ファイ
ル"（init file）と呼びます。コマンド行オプション`-q'で、Emacsに初期化ファ
イルを読まないことを指示したり、`-u'（あるいは`--user'）で、別のユーザー
の初期化ファイルを指定できます（*Note Entering Emacs::）。

"デフォルトの初期化ファイル"もあります。
これは`default.el'という名前のライブラリファイルで、
Emacsはライブラリ探索パスをとおしてその場所を探します。
Emacsの配布には`default.el'は含まれていません。
ローカルなカスタマイズのためにサイトで`default.el'を
用意することもあります。
このファイルがあれば（`-q'を指定したときを除いて）
Emacsを開始するときつねにロードされます。
しかし、あるならば個人の初期化ファイルが最初にロードされます。
その中で`inhibit-default-init'に`nil'以外の値を設定すると、
`default.el'はロードされません。

各サイトには"サイトスタートアップファイル"があるかもしれません。あるな
らば、このファイルの名前は`site-start.el'です。Emacsはユーザーの初期化
ファイルを読むまえにこのファイルもロードします。このファイルのロードを
抑止するには、オプション`-no-site-file'を指定します。

`.emacs'に大量のコードがある場合には、`~/.emacs.el'と改名してバイトコン
パイルしておくべきです。Emacs Lispプログラムのコンパイルについてより詳
しくは、*Note バイトコンパイル: (elisp)Byte Compilation。

単なるカスタマイズを超えるような実際のEmacsプログラムを書くのであれば、
`The Emacs Lisp Reference Manual' (1) (*Note Init File-Footnotes::)を読
むべきです。
*Note Emacs Lisp: (elisp)Top。

* Menu:

* Init Syntax::	        Syntax of constants in Emacs Lisp.
* Init Examples::       How to do some things with an init file.
* Terminal Init::       Each terminal type can have an init file.
* Find Init::	        How Emacs finds the init file.


File: emacs-ja  Node: Init File-Footnotes, Up: Init File

(1) 【訳注】日本語訳：『Emacs Lispリファレンスマニュアル』、アスキー出
版局、ISBN4-7561-3414-9



File: emacs-ja, Node: Init Syntax, Next: Init Examples, Prev: Init File, Up: Init File

初期化ファイルの構文
--------------------

ファイル`.emacs'にはLispの関数呼び出し式を書きます。関数呼び出しは、関
数名に続けて引数リストを並べ、全体を括弧で囲みます。たとえば、`(setq
fill-column 60)'は、関数`setq'によって、変数`fill-column'（*Note
Filling::）に60を設定します。

`setq'の2番目の引数は変数の新しい値を表す式です。これは、定数でも、変数
でも、関数呼び出し式でもかまいません。`.emacs'ファイルでは定数を使うこ
とがもっとも多いでしょう。定数にはつぎのものがあります。

数値：
     数値は10進表記し、先頭にマイナス符号があってもよい。

文字列：
     Lispの文字列の構文はCの文字列の構文とほぼ同じだが、多少違うところ
     もある。文字列定数の始まりと終りにはダブルクォートを使う。

     文字列の中には、改行や特殊文字をそのまま入れることができる。しかし、
     バックスラッシュで始まる形式、つまり、改行は`\n'、バックスペースは
     `\b'、復帰は`\r'、タブは`\t'、ページ送りは`\f'（コントロールL）、
     エスケープは`\e'、バックスラッシュは`\\'、ダブルクォートは`\"'、8
     進コードOOOの文字は`\OOO'で表すことができ、そのほうが読みやすい。
     バックスラッシュとダブルクォートの2つだけは、文字列に含めるのに必
     ずこのような形で書き表す必要がある。

     `\C-'はコントロール文字を表すプレフィックスとして使用できる。
     たとえば、`\C-s'でASCIIのコントロールSを表す。
     同様に、`\M-'はメタ文字を表すプレフィックスとして使用できる。
     たとえば、`\M-a'で`Meta-A'、
     `\M-\C-a'で`Control-Meta-A'を表す。

文字：
     Lispの文字定数は、`?'に続けて文字または`\'で始まるエスケープシーケ
     ンスを書いたもの。たとえば、`?x'、`?\n'、`?\)'などは文字定数。
     Lispでは文字と文字列は別ものなので注意すること。ある場面では文字列
     が必要であり、別の場面では文字が必要である。

真：
     `t'は「真」を表す。

偽：
     `nil'は「偽」を表す。

その他のLispオブジェクト：
     シングルクォートに続けてそのLispオブジェクトを書く。



File: emacs-ja, Node: Init Examples, Next: Terminal Init, Prev: Init Syntax, Up: Init File

初期化ファイルの例
------------------

以下にはよく使われるLispの式の例をあげておきます。

   * Cモードにおいて、行の途中でTABが押されたときにはタブ文字を挿入する
     ように設定する。

          (setq c-tab-always-indent nil)

     変数の値を「真」にするには`t'を設定し、逆に「偽」にするには`nil'を
     設定する。

   * 探索をデフォルトで大文字小文字を区別するように設定する（ただし、違
     う設定に変更しているバッファは除く）。

          (setq-default case-fold-search nil)

     ここでは`setq-default'で変数のデフォルト値を設定し、その変数に対し
     てローカルな値を設定していないすべてのバッファで有効である。
     `setq'で`case-fold-search'に値を設定すると、カレントバッファのロー
     カルな値だけに影響し、初期化ファイルで記述したいこととは異なるだろ
     う。

   * Emacsが自動的にメイルアドレスを割り出せない場合に備え、この変数に
     自分のメイルアドレスを指定する。

          (setq user-mail-address "coon@yoyodyne.com")

     メイルアドレスを必要とする多くのEmacsパッケージは、
     `user-mail-address'の値を使う。

   * 新たに作ったバッファのデフォルトのモードをテキストモードにする。

          (setq default-major-mode 'text-mode)

     `text-mode'を指定しているのは、これがテキストモードに入るためのコ
     マンドだから。コマンド名のまえのシングルクォートは、シンボルを定数
     として扱うため。さもないと`text-mode'という変数を参照することになっ
     てしまう。

   * 西ヨーロッパのほとんどの言語を扱えるLatin-1文字集合をデフォルトと
     する (1) (*Note Init Examples-Footnotes::)。

          (set-language-environment "Latin-1")

   * テキストモードやそれに関連するモードでは、自動詰め込みモードをオン
     にする。

          (add-hook 'text-mode-hook
            '(lambda () (auto-fill-mode 1)))

     これはノーマルフック変数（*Note Hooks::）にフック関数を追加する例。
     ここでは関数として`lambda'で始まるリストを指定し、シングルクォート
     を前置して式ではなく定数として扱わせる。

     Lispの関数について説明するのは本書の範囲外だが、この例を理解するに
     は、テキストモードに入るときに`(auto-fill-mode 1)'が実行されるのだ
     と考えておけば十分。この式を別の式に変えたり、式を複数並べてもかま
     わない。

     Emacsには`turn-on-auto-fill'という関数が用意されており、その定義は
     `(lambda () (auto-fill-mode 1))'になっている。したがって、上の例を
     もっと簡単に書くとつぎのようになる。

          (add-hook 'text-mode-hook 'turn-on-auto-fill)

   * あらかじめ用意してあるLispライブラリ`foo' （実際には標準Emacsディ
     レクトリに置かれたファイル`foo.elc' または`foo.el'）をロードする。

          (load "foo")

     `load'に渡す引数が相対ファイル名、つまり、`/'や`~'で始まらない場合
     には、`load'は`load-path'（*Note Lisp Libraries::）のディレクトリ
     群を順に探索する。

   * 自分のホームディレクトリにあるコンパイル済みのLispファイル
     `foo.elc'をロードする。

          (load "~/foo.elc")

     ここでは絶対ファイル名が使われているので、探索は行わない。

   * キー`C-x l'で関数`make-symbolic-link'が実行されるようにバインディ
     ングを設定する。

          (global-set-key "\C-xl" 'make-symbolic-link)

     または

          (define-key global-map "\C-xl" 'make-symbolic-link)

     ここでもシンボル`make-symbolic-link'を変数としての値ではなく定数と
     するためにシングルクォートが使われていることに注意。

   * 上と同じだが、Lispモードの中だけでのバインディングを設定する。

          (define-key lisp-mode-map "\C-xl" 'make-symbolic-link)

   * 基本（fundamental）モードで`next-line'を実行するようになっているす
     べてのキーを、かわりに`forward-line'を実行するように直す。

          (substitute-key-definition 'next-line 'forward-line
                                     global-map)

   * `C-x C-v'を未定義にする。

          (global-unset-key "\C-x\C-v")

     キーを未定義にする必要のある場合の1つとして、そのキーをプレフィッ
     クスにしたい場合がある。たとえば、`C-x C-v ANYTHING'を定義すると、
     `C-x C-v'は自動的プレフィックスになるが、しかしそのまえに`C-x
     C-v'の通常の（プレフィックスではない）定義を未定義に戻しておく必要
     がある。

   * `$'をテキスト（text）モードでの区切り文字にする。
     `$'を文字定数として指定していることに注意。

          (modify-syntax-entry ?\$ "." text-mode-syntax-table)

   * コマンド`narrow-to-region'を確認なしに使えるようにする。

          (put 'narrow-to-region 'disabled nil)


File: emacs-ja  Node: Init Examples-Footnotes, Up: Init Examples

(1) 【訳注】日本語環境を設定するには、
     (set-language-environment "Japanese")
とする。



File: emacs-ja, Node: Terminal Init, Next: Find Init, Prev: Init Examples, Up: Init File

端末に固有の初期化
------------------

各端末種別ごとに、Emacsがその端末で動くときにロードするライブラリを指定
できます。つまり、TERMTYPEという名前の端末でEmacsを起動するときには、
`term/TERMTYPE'というライブラリがロードされます。ライブラリの探索は通常
どおり`load-path'の各ディレクトリに対して行われ、ファイルの拡張子は
`.elc'か`.el'です。通常、これらのライブラリはほとんどのEmacsライブラリ
を収めたディレクトリの下の`term'というサブディレクトリに置かれます。

端末固有のライブラリの普通の用途は、端末のファンクションキーによって送
出されるエスケープシーケンスを`function-key-map'を使って意味のある名前
に対応付けることです。このような設定を行うファイルの例として、たとえば
ファイル`term/kl201.el'を見てみてください。多くのファンクションキーは
termcapデータベースの情報に基づいて自動的に対応付けがなされます。端末固
有ライブラリでは、termcapで指定されていないファンクションキーだけを対応
付ければよいのです。

端末種別にハイフンが含まれている場合は、ライブラリ名の選択には最初のハ
イフンよりまえの部分だけが使われます。つまり、端末種別`aaa-48'と
`aaa-30-rv'では、どちらも`term/aaa'をロードします。ライブラリ中のコード
では`(getenv "TERM")'を使って必要なら完全な端末種別名を取得できます。

端末ライブラリの名前は、変数`term-file-prefix'と端末種別とを
連結して作られます。
ファイル`.emacs'中で`term-file-prefix'を
`nil'に設定すると端末ライブラリのロードを抑止できます。

Emacsは`.emacs'と端末ライブラリを読んだあと、
初期化の最後にフック`term-setup-hook'を実行します。
端末ライブラリによる指定を一部変更したり、
端末ライブラリがない端末の初期設定を行いたければ、
このフックにフック関数を追加してください。
*Note Hooks::。



File: emacs-ja, Node: Find Init, Prev: Terminal Init, Up: Init File

個人の初期化ファイルの探し方
----------------------------

通常、Emacsは環境変数`HOME'に基づいて`.emacs'を探し、ファイル名の`~'の
意味を定めます。しかし、`su'を実行したあとでは、Emacsは（su実行前の）も
とのユーザーの`.emacs'を読もうとし、suした先のユーザーのではありません。
これは、たとえスーパーユーザーになっているとしても、本来のユーザー独自
のエディタのカスタマイズを使うべきだと考えるからです。

より正確には、Emacsはまずどのユーザーの初期化ファイルを使うかを決めます。
それにはまず環境変数`LOGNAME'および`USER'からユーザー名を取得します。こ
れらの環境変数がみつからなければ、Emacsは実効ユーザーIDを参照します。ユー
ザー名と実ユーザーIDが一致すれば、Emacsは`HOME'を利用します。一致しない
場合は、システムのユーザーデータベースからそのユーザー名に対応するホー
ムディレクトリを探して使用します。



File: emacs-ja, Node: Quitting, Next: Lossage, Prev: Customization, Up: Top

中断とアボート *(2004/03/29)*
=============================

`C-g'
`C-BREAK (MS-DOS のみ)'
     Quit: cancel running or partially typed command.  中断する。動作中
     のコマンドや打鍵途中のコマンドを取り消す。
`C-]'
     アボートする。いちばん内側の再帰編集レベルを強制的に終了し、その再
     帰編集レベルを起動したコマンドを取り消す（`abort-recursive-edit'）。
`ESC ESC ESC'
     中断かアボートのいずれか意味のあるほうを実行する
     （`keyboard-escape-quit'）。
`M-x top-level'
     現在実行中のすべての再帰編集レベルを強制的に終了する。
`C-x u'
     バッファの内容に対して行った直前の変更を取り消す（`undo'）。

実行を完了していないコマンドを取り消すには、2つの方法があります。  1つ
は`C-g'で"中断"すること、もう1つは`C-]'や`M-x top-level'で"アボート"す
ることです。中断とは、打鍵途中のコマンドや動作中のコマンドを取り消すこ
とをいいます。アボートとは、再帰編集レベルから抜け出し、かつ、その再帰
編集レベルを起動したコマンドを取り消すことをいいます（*Note Recursive
Edit::）。

`C-g'での中断は、打鍵途中のコマンドや不要な数引数を打ってしまったときに
とりやめるのに使います。また、実行途中のコマンドを比較的安全な方法で止
めますから、長時間かかるコマンドをうっかり始めてしまったときにも使えま
す。特に、キル操作を中断しても安全です。テキストは、まだ*すべて*バッファ
内にあるか、または、*すべて*キルリングに入っている（あるいは、その両方
に入っている）からです。なお、インクリメンタルサーチを中断する場合には、
文字列探索のところで説明してあるように、特別な動作を行います。一般には、
サーチから抜け出すには`C-g'を2回連打する必要があります（*Note
Incremental Search::）。

MS-DOSでは、`C-BREAK'は`C-g'と同様に中断として働きます。
MS-DOSでは、コマンドの実行中にユーザーとのやりとりを行う状態にないときには、
`C-g'を検出できないからです。
これに対して、`C-BREAK'はつねに認識*でき*ます。
*Note MS-DOS Input::。

`C-g'はつぎのように動作します。
`C-g'が打鍵されると変数`quit-flag'に`t'が設定されます。
Emacs Lispはこの変数を頻繁に調べ、値が`nil'以外だと中断処理を行います。
`C-g'が実際にコマンドとして実行されるのは、
Emacsが入力待ち状態にあるときに`C-g'を打った場合だけです。この場合，
`keyboard-quit' が実行されます．

最初の`C-g'が認識されないうちに2つめの`C-g'を打って中断すると、
『緊急脱出』機能を発動したことになりシェルに戻ります。
*Note Emergency Escape::。

中断できない場合もありえます。Emacsがオペレーティングシステムに何かを頼
んで待っているときには、待ち状態を起こしたシステムコールを使ったEmacs側
で特別な手当てをしない限り中断できません。Emacsでは、ユーザーが中断しそ
うなシステムコールには手当てを施してありますが、手当てしていない場所を
叩く可能性はあります。よくあるのは、NFS経由の入出力を待っているときです。
Emacs側ではこれを中断する方法はわかっているのですが、多くのNFSの実装で
は、NFSサーバーが固まったときにユーザープログラムがNFSの待ちを中断する
ことを許していないのです。

`C-]'によるアボート（`abort-recursive-edit'）は、
再帰編集レベルから脱出し、かつ、その再帰編集レベルを
起動したコマンドを取り消すのに使います。
`C-g'による中断はこのような目的には使えませんし、
このようなことはできません。
というのは、`C-g'は、ある再帰編集レベルの*中で*
打ちかけたコマンドを取り消すのに使うからです。
どちらの操作も必要なものです。
たとえば、再帰編集中に数引数を入力しようとして`C-u 8'と打鍵した場合、
`C-g'で数引数を取り消しても再帰編集に留まったままです。

コマンド`ESC ESC ESC' （`keyboard-escape-quit'）は、中断かアボートのい
ずれかを行います。このキーを使うのは、多くのPCのソフトでESCが『抜け出す』
の意味に使われているからです。`C-g'と同様に、数引数を取り消したり、選択
したリージョンをクリアしたり、問い合わせ型置換操作から抜け出します。
`C-]'と同様に、ミニバッファや再帰編集から抜け出します。また、`C-x 1'の
ように、フレームを複数ウィンドウに分割しているのをやめることもできます。
しかしながら、実行中のコマンドを止めることはできません。なぜなら、この
コマンドは普通のコマンドとして実行されるので、Emacsがコマンドを読み込む
状態にならないとこのコマンドを認識しないからです。

コマンド`M-x top-level'は、現在入っているすべての再帰編集レベルから
抜け出すのに『十分な』数の`C-]'と同等です。
`C-]'は一度に1レベルだけ抜け出すのに対し、
`M-x top-level'はすべてのレベルを一気に抜け出します。
`C-]'も`M-x top-level'も他のコマンドと同様の普通のコマンドですから、
`C-g'とは違って、Emacsがコマンドを受け付ける状態のときだけ動作します。
`C-]'は普通のキーであり、キーマップにそのバインディングがあるので
そのように動作するのです。
*Note Recursive Edit::。

`C-x u'（`undo'）は、正確にいえばコマンドを取り消すわけではありませんが、
動作を完了してしまったコマンドを取り消すものと考えることができます。詳
しくは *Note Undo:: を参照してください。



File: emacs-ja, Node: Lossage, Next: Bugs

Emacsのトラブルに対する対処 *(2004/03/29)*
==========================================

本節では、Emacsが正常に動作し損なうさまざまな条件と、それらの見分け方、
直し方について説明します。発生しうる問題についてはEmacsに付属している
*Note Bugs and problems: (efaq)Bugs and problems やファイル
`etc/PROBLEMS' を参照してください．FAQは`C-h F'，`PROBLEMS'ファイルは
`C-h P' で読むことができます．

* Menu:

* DEL Does Not Delete::   What to do if DEL doesn't delete.
* Stuck Recursive::       `[...]' in mode line around the parentheses.
* Screen Garbled::        Garbage on the screen.
* Text Garbled::          Garbage in the text.
* Unasked-for Search::    Spontaneous entry to incremental search.
* Memory Full::           How to cope when you run out of memory.
* After a Crash::         Recovering editing in an Emacs session that crashed.
* Emergency Escape::      Emergency escape---
                            What to do if Emacs stops responding.
* Total Frustration::     When you are at your wits' end.



File: emacs-ja, Node: DEL Does Not Delete, Next: Stuck Recursive, Prev: Lossage, Up: Lossage

DELで削除できない *(2004/03/29)*
--------------------------------

大抵のキーボードにはEmacs外で最後に入力した文字を消すためのキーとして
RET や ENTER キーの上あたりにあるキーがあります．このキーを本書では "通
常削除キー"(the usual erasure key) と呼びます．端末上のEmacsはそのキー
をDEL キーと同じものとみなし，DELに変換します．

Emacs が起動する時にウィンドウシステムを利用していると，自動的にDELとし
て扱うべきキーを決定します．しかし，ある環境ではシステムから誤った情報
を受け取ってしまいます．通常削除キーが後ではなく前の文字を消すようであ
れば，DELETE キーを DEL として扱うように設定しなければなりません．

ウィンドウシステムでは通常削除キーはBACKSPACEと印字されており，他に
DELETEキーもあります．しかし，DELETEキーは前ではなく後の文字を削除し
ます．もし逆の動作になっているようであれば，Emacsが判断を誤っています．
BACKSPACE キーを DELキーとして扱うようにしなければなりません．

テキスト端末で，通常削除キーが文字を削除するかわりに，`Control-h'のよう
にヘルプを表示するようであれば，そのキーは実際にはBSを送っていることに
なります．つまり，EmacsはBSをDELとして扱うべきなのです．

こういった場合，当面の問題は同じです．そのため，`M-x
normal-erase-is-backspace-mode' が利用できます．このコマンドは2つのモー
ドを切り替えることができます．もしEmacsが誤ったモードで起動していれば，
DELを扱うモードにすることで，正しいモードに切り替えることができます．テ
キスト端末で，BS が DEL として扱われているかどうかを確認したければ，
F1 (`C-?' も動作するかもしれません)を利用して，127 になっていることを確
認します．sends character code 127.

Emacsを起動時に自動的に問題を修正するためには，以下の行を `.emacs'ファ
イル(*Note Init File::) に追加します．最初の例ではDELETEが後ではなく前
の文字を消す場合にDELETE を DEL として扱うようにします (Emacs20以前と同
じ動作になります)．

     (normal-erase-is-backspace-mode 0)

他の2例では，BACKSPACEをDELとして扱うべきなため，以下を利用します．

     (normal-erase-is-backspace-mode 1)

Emacsを起動時に問題を修正する他の方法として，変数
`normal-erase-is-backspace' をカスタマイズする方法があります．`t' であ
れば，BS や BACKSPACE を DELとみなし， `nil' であれば逆になります．
*Note Easy Customization::．

ウィンドウシステムではBACKSPACEと印字されたキーが通常削除キーであり，他
にDELETE キーも存在し，両方ともが前の文字を削除するということも起こりま
す．これがおそらく誰(何)かが BACKSPACE キーを DELETE としちぇ再定義した
ためです．Xウィンドウシステムではサーバを起動したりログインしたりすると，
`xmodmap' によってなされます．この現象を引き起こしているのは古いバージョ
ンのEmacsをサポートすることです．だから，古いバージョンは削除することを
お勧めします．



File: emacs-ja, Node: Stuck Recursive, Next: Screen Garbled, Prev: DEL Does Not Delete, Up: Lossage

再帰編集レベル
--------------

再帰編集レベルはEmacsの重要で有用な機能ですが、それについて理解していな
い人にとっては、誤動作に見える可能性があります。

モード行のメジャー／マイナモード名を囲む丸括弧の周囲に中括弧
`[...]'が表示されているときは、再帰編集レベルに入っています。
意図してそうしたのでなかったり、
再帰編集レベルの意味を理解していないのであれば、
再帰編集レベルから抜け出すべきです。
それには`M-x top-level'と打ちます。
これをトップレベルへの抜け出しと呼びます。
*Note Recursive Edit::。



File: emacs-ja, Node: Screen Garbled, Next: Text Garbled, Prev: Stuck Recursive, Up: Lossage

画面上のゴミ *(2004/03/29)*
---------------------------

画面上のデータがまちがっているように見えたら、まず最初にすべきことは、
テキストが本当にまちがっているのかどうか調べることです。`C-l'と打って画
面全体を再描画します。これで画面が正しそうになるのなら、問題は画面更新
にあったのです。（そうでない場合は、後の章を参照してください）。

画面更新の問題は、使っている端末に対応するtermcapの定義がまちがっている
場合が多いです。Emacsの配布に含まれるファイル`etc/TERMS'には、この種の
問題で既知のものに対する修正が入っています。ファイル`INSTALL'には、この
種の問題に対する一般的なアドバイスの節があります。いちばんありがちなの
は、ある種の画面操作に対するパディング (1) (*Note Screen
Garbled-Footnotes::) が不足している場合です。この種の問題があるかどうか
調べるには、他のメーカ製の別の端末でEmacsを動かしてみてください。ある機
種の端末では頻繁に問題が起きるのに別の機種の端末では問題がないなら、
termcapの定義がまちがっている可能性があります。しかし、ある種の機能を有
するか欠如している端末で現れるEmacsのバグである可能性もあります。



File: emacs-ja  Node: Screen Garbled-Footnotes, Up: Screen Garbled

(1) 【訳注】端末にとっては無意味で無害な文字を、（動作が完了するまでの）
時間稼ぎのために送出すること。



File: emacs-ja, Node: Text Garbled, Next: Unasked-for Search, Prev: Screen Garbled, Up: Lossage

テキスト内のゴミ
----------------

`C-l'を実行してもテキストが変ならば、
正しいと思われる状態になるまで、
`C-x u'を使って変更をもとに戻してみてください。
また、どのコマンドで変になったのか調べるために、
`C-h l'を試してみてください。

バッファの先頭や末尾で大量のテキストが失われているようなら、
モード行に単語`Narrow'が表示されていないか確認してください。
もしそうなら、おそらくテキストは失われているのではなく、
一時的に見えなくなっているのでしょう。
見えるようにするには、`C-x n w'と打ってください。
*Note Narrowing::。



File: emacs-ja, Node: Unasked-for Search, Next: After a Crash, Prev: Text Garbled, Up: Lossage

自発的なインクリメンタルサーチの開始
------------------------------------

Emacsが画面の最下行に自発的に`I-search:'と表示するようなら、劣悪な
xon/xoffの『フロー制御プロトコル』に従って端末が`C-s'と`C-q'を送ってい
るためでしょう。

もしこの状態が起きたら、もっともよいのは端末をフロー制御なしに設定する
か、または、パディングを十分に増やして端末がけっして`C-s'を送らないよう
にすることです。（パディングを増やす1つの方法は、より大きい値を変数
`baud-rate'に設定すること。この値はボーという単位で表した端末の出力速
度。）

フロー制御を止められない場合の次善の策は、Emacsにフロー制御を処理させる
ことです。それには、関数`enable-flow-control'を呼び出してください。

典型的な場合、ある種の端末タイプに限ってフロー制御を使う必要があります。
`enable-flow-control-on'を使って、そのような種類の端末に限ってフロー制
御を行うようにできます。たとえば、VT-100端末とH19端末にはフロー制御を行
う必要があるのなら、ファイル`.emacs'につぎのものを入れます。

     (enable-flow-control-on "vt100" "h19")

フロー制御を使っている場合には、`C-s'のかわりに`C-\'、
`C-q'のかわりに`C-^'を使う必要があります。
（これらの割り当てはキーボード変換によって行われる。
*Note Keyboard Translations::。）



File: emacs-ja, Node: Memory Full, Next: After a Crash, Prev: Unasked-for Search, Up: Lossage

メモリ不足 *(2004/03/29)*
-------------------------

`Virtual memory exceeded'というエラーメッセージが出たら、
変更したバッファを`C-x s'で保存してください。
この方法で保存する場合、必要なメモリは最小限ですみます。
Emacsは上記のエラーが起きたときでも使える予備のメモリを確保していますから、
`C-x s'を完了するのには十分なはずです。

変更済みのバッファを保存したら、Emacsを終了して別のEmacsを起動してもよ
いですし、`M-x kill-some-buffer'を使って現在動いているEmacsのメモリを解
放してもよいです。大量のテキストが入っているバッファを消せば、安全に編
集を続行できます。空きメモリが十分な量になると予備のメモリを自動的に確
保し直し、再度メモリ不足になったときに備えます。

メモリ不足になったときには、`M-x buffer-menu'を使ってバッファを保存した
り消したりしないでください。このコマンドはけっこうメモリを必要とするの
で、確保した予備のメモリだけでは十分でない可能性があるからです。



File: emacs-ja, Node: After a Crash, Next: Emergency Escape, Prev: Unasked-for Search, Up: Lossage

クラッシュからの回復
--------------------

Emacsやコンピュータがクラッシュしても、クラッシュ時に編集していたファイ
ルは自動保存ファイルから回復できます。それには、Emacsを再度起動してから、
コマンド`M-x recover-session'を入力してください。

このコマンドは、まず、中断されたセッションファイルの一覧を日付とともに
バッファに表示します。その中からどのセッションを回復するか選んでくださ
い。通常は、最新のセッションを選べばよいでしょう。望みのセッションの行
にポイントを動かして、`C-c C-c'と打ちます。

すると、`recover-session'は、そのセッションで編集中だった各ファイルにつ
いて回復するかどうか問い合わせてきます。`y'と答えると、そのファイルと自
動保存ファイルの日付を表示してから、回復するかどうか再度問い合わせてき
ます。再問い合わせに対しては`yes'で答える必要があります。そうすると、
Emacsはそのファイルを訪れますが、テキストは自動保存ファイルから持ってき
ます。

`recover-session'が完了すると、回復を指定したファイルはEmacsバッファに
入っています。そうしたらこれらのバッファを保存してください。保存して始
めてもとのファイルが更新されます。



File: emacs-ja, Node: Emergency Escape, Next: Total Frustration, Prev: After a Crash, Up: Lossage

緊急脱出
--------

バグのために、Emacsが`quit-flag'を検査しないループに入ってしまうことも
ありえます。このため、このフラグが設定されている状態で再度`C-g'が打たれ
るとただちに実行を休止する特別な機能がEmacsにはあり、いつでもGNU Emacs
から抜け出すことができます。通常、Emacsはすみやかに`quit-flag'を認識し
（中断し）ますから、この特別な機能が使われることはまずありません。
（MS-DOSや互換システムでは、`C-BREAK'を2回連打する。）

`C-g'の連打によって休止したEmacsを再開すると、Emacsは休止直前に実行して
いた動作に戻るまえに、つぎの2つの質問をしてきます。

     Auto-save? (y or n)
     Abort (and dump core)? (y or n)

それぞれの質問に対し、`y'か`n'に続けてRETで答えてください。

`Auto-save?'に`y'と答えると、自動保存を行う設定になっている変更されたバッ
ファすべてに対してただちに自動保存を実行します。

`Abort (and dump core)?'に`y'と答えると、Emacsは不正命令を実行してコア
ダンプを作ります。コアダンプがあると、Emacsが中断できなかった理由をウィ
ザード (1) (*Note Emergency Escape-Footnotes::) が追究できます。コアダ
ンプを作り終えるとEmacsの実行は終了します。`n'と答えると実行は継続しま
す。運がよければ、Emacsが最終的には`quit-flag'を検査して正常に中断でき
るでしょう。運が悪ければ、またループに入ったままになりますから、再度
`C-g'を打ってEmacsをまた休止します。

本当はEmacsが固まったのではなく単に遅いだけの場合には、意図せずに`C-g'
を連打してしまうことがあります。その場合には、再開して2つの質問に`n'と
答えればもとの状態に戻れます。中断要求はすぐに受け付けられるでしょう。

XウィンドウシステムのもとでEmacsが動作している場合には、`C-g'連打の機能
は切ってあります。というのは、ウィンドウマネージャを使ってEmacsを終了さ
せたり、別のウィンドウを開いて別のプログラムを動かせるからです。

MS-DOSや互換システムでは、
（MS-DOSやBIOSの）システムコールが固まっている場合や
Emacsが非常にきつい（Lispコードでは*なく*Cのコードで）
無限ループに入っている場合には、
`C-BREAK'を2回打っても緊急脱出の機能を使えない場合があります。


File: emacs-ja  Node: Emergency Escape-Footnotes, Up: Emergency Escape

(1) 【訳注】「名人、熟練者、魔術師」の意味だが、特定のコンピュータや
（特に）ソフトウェアに精通した人を指す。



File: emacs-ja, Node: Total Frustration, Prev: Emergency Escape, Up: Lossage

いらいらしたら…
----------------

Emacsを使うこと（や、その他のこと）がきわめて不愉快になったり、ここまで
にあげたどの方法でも問題が解決しない場合でも、Emacsはまだ手助けができま
す。

まず、Emacsがコマンドに応答しないようなら、`C-g C-g'と打ってEmacsから抜
け出し、新たに別のEmacsを起動してください。

つぎに、`M-x doctor RET'と打ってください。

doctorプログラムがあなたのいらいらを鎮めてくれるでしょう。doctorに何か
を話すときには、RET RETと打っていい終える必要があります。こうすると、
doctorは患者が話し終えたことを認識します。



File: emacs-ja, Node: Bugs, Next: Contributing, Prev: Lossage

バグの報告 *(2004/03/29)*
=========================

Emacsのバグに出会うこともあるでしょう。バグを修正する／できるとは約束で
きませんし、そもそもバグだと認めないかもしれませんが、読者が遭遇した問
題については知らせてほしいと考えています。たしかにそれをバグだと認めて
修正しようということになる場合も多いのです。

バグを修正するには、まず、報告してもらう必要があります。効果的に報告し
てもらうためには、報告の仕方を知っていただく必要があります。

バグを報告する前にすでに報告されているかを確認することはいい考えです．
Emacs に付属している `etc/PROBLEMS'ファイルに既知のバグのリストがありま
す．これは，`C-h P' で読むことができます．ユーザレベルでのバグの追加情
報は *Note Bugs and problems: (efaq)Bugs and problemsにあります．この2
つの文書でバグを調べれば，解決策が見つかるかもしれません．あるいは関連
問題の情報が得られるかもしれません．

* Menu:

* Criteria:  Bug Criteria.	 Have you really found a bug?
* Understanding Bug Reporting::	 How to report a bug effectively.
* Checklist::			 Steps to follow for a good bug report.
* Sending Patches::		 How to send a patch for GNU Emacs.



File: emacs-ja, Node: Bug Criteria, Next: Understanding Bug Reporting, Prev: Bugs, Up: Bugs

バグの発生時期 *(2004/03/29)*
-----------------------------

Emacsが不正命令を実行したり、（『ディスクが満杯』などの外部の問題ではな
く）プログラムに問題があるというオペレーティングシステムのメッセージを
表示して止まった場合には、たしかにバグがあるといえます。

Emacsの画面の更新結果がバッファの内容に対応していないなら、それもたしか
にバグです。コマンドの実行が思わしくなくても`C-l'で再表示させると正しく
なる場合には、画面更新がまちがっているのです。

あるコマンドを実行するのに無限に時間がかかるというのはバグの可能性があ
りますが、たしかにEmacsの責任かどうかを確認する必要があります。コマンド
によってはとても時間がかかるものもあります。`C-g'（MS-DOSでは`C-BREAK'）
を打ってから`C-h l'を打つことで、Emacsが受け付けた入力がたしかに読者が
意図したものだったかどうか確認できます。すぐに処理されるコマンドだとい
う*確信*があるなら、バグを報告してください。そのコマンドがすごく時間の
かかるものかどうかわからないなら、マニュアルで調べるか知っている人に聞
いてください。

よく知っているコマンドであって、普通なら問題なく結果が得られるはずなの
に、かわりにEmacsがエラーメッセージを出すようなら、恐らくそれはバグでしょ
う。

コマンドが正しくない動作をするのなら、それはバグです。ただし、コマンド
が本当は何をするのが正しいか確認してください。そのコマンドに馴染みがな
いとか、そのコマンドがどう動作するはずなのか確信が持てない場合は、コマ
ンドは実際には正しく動作しているのかもしれません。バグという結論に飛び
つくまえに、よく知っている人に見てもらってください。

最後に、コマンドの意図された定義が編集操作に対して最良でない可能性があ
ります。これは重要な問題ではありますが、ユーザーがどう判断するかの問題
でもあります。既存の機能について無知なために、まちがっていると結論を出
してしまうのも簡単です。まずドキュメントをひととおり調べて、十分に納得
し、それでもなお自分にとって必要な機能がない、と断言できるまでは、コマ
ンドの定義が悪いなどとはいわないほうがよいでしょう。マニュアルを熟読し
てもコマンドが何をするのかよくわからなければ、索引や用語集を活用してよ
くわからない単語について調べましょう。

十分熟読しても、なおコマンドが何をするのかわからないなら、それは「マニュ
アルのバグ」として報告すべきでしょう。マニュアルは、読者を含めて、
Emacsの専門家でない人が読んでもすべてのことが明らかになるようなものであ
るべきです。ドキュメントのバグを報告することも、プログラムのバグを報告
することと同じくらい重要なことです。

関数や変数のオンラインの説明文がマニュアルと一致しない場合は、どちらか
がまちがっていますから、これもバグです。



File: emacs-ja, Node: Understanding Bug Reporting, Next: Checklist, Prev: Bug Criteria, Up: Bugs

バグの報告とは
--------------

バグがあると確信したら、それを報告すること、しかも、役立つ形で報告する
ことが重要です。もっとも有用なのは、どのようなコマンドを打ち込んだかを、
Emacsを起動するシェルのコマンドから始めて問題が起きるところまですべて正
確に記述することです。

バグを報告するときもっとも重要なことは*事実*を報告することです。仮説や
口頭説明は、詳細な生データのかわりにはなりません。事実を報告することは
単純なはずなのに、多くの人はかわりに説明をでっちあげてそれを報告したが
ります。その説明がEmacsの実装方式の想像に基づいたものであるならば、その
説明はまったく役に立たないでしょう。事実が欠けていたらバグに関する真の
情報を得られません。

たとえば、ユーザーがとても大きなファイルを訪れるために`C-x C-f
/glorp/baz.ugh RET'と打ち込んだら、Emacsが`I feel pretty today'と表示し
たとしましょう。もっともよいバグレポートは、まさにこの文のように報告す
ることです。すべての事実だけを報告できるからです。

問題はファイルの大きさにあると仮定して、「大きなファイルを訪問したら、
Emacsが`I feel pretty today'と表示した」などと書いてはいけません。これ
が『説明をでっちあげた』報告です。問題はファイル名に`z'が含まれていたた
めに生じたのかもしれないのです。もしそうだとしたら、報告に基づいて適当
な「大きなファイル」を訪問してみても、そのファイル名に`z'が含まれていな
ければ何も悪いところがみつからないでしょう。報告の文面からは、名前に
`z'を含んだファイルを試しに訪問してみるべきだとはわかりません。

あるいは、ファイルがちょうど25個の空白文字で始まっているために問題が起
きたのかもしれません。ですから、報告に際しては、そのバグを再現させるの
に必要なファイルがあれば、それらのファイルの正確な内容も教えてください。
その問題は、たまたま、`C-x C-a'と打った直後にのみ発生するのだとしたらど
うでしょう？` ' ですから、Emacsを起動してから問題に遭遇するまでに打ち込
んだものすべてを教えてほしいのです。

どの訪問コマンドを使っても同じように問題が発生すると*知っている* のでな
い限り、`C-x C-f'と打ったと報告するかわりに「ファイルを訪問した」という
のさえいけません。同様に、「1行に3文字入っているとき」ではなく、「`RET
A B C RET C-p'と打ち込んだあとで」のように、あなたがテキストを入れたや
り方そのものを報告してください。

このように、バグを報告するときには、いかなる説明も推測しないでください。
問題を実際に*デバッグ*して憶測ではない説明を報告してもらえるなら、それ
は有益ですが、事実も含めてください。



