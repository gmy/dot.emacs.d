Info file: emacs-ja,    -*-Text-*-
produced by `texinfo-format-buffer'
from file `emacs.texi'
using `texinfmt.el' version 2.41 of  1 Mar 2005.

INFO-DIR-SECTION Emacs
START-INFO-DIR-ENTRY
* Emacs-ja: (emacs-ja).	            Emacs21.3日本語マニュアル.
END-INFO-DIR-ENTRY








File: emacs-ja, Node: User Input, Next: Keys, Prev: Screen, Up: Top

ユーザー入力の種類
==================

GNU Emacsは、キーボード入力に対しては拡張ASCII文字集合を使います。また、
ファンクションキーやマウスボタン操作のような文字以外の入力イベントも受
け付けます。

ASCIIは、128の文字コードから成ります。これらのコードの中には、`a'や`='
のような図形記号に割り当てられているものもあります。それ以外は、
`Control-a'のようなコントロール文字です（通常、`C-a'と略記）。`C-a'の名
前は、CTRLキーを押し下げたまま`a'を押すことからきています。

ASCIIコントロール文字の中には、特別な名前が付いたものもあります。多くの
端末では、コントロール文字を打つための特別なキーを備えています。たとえ
ば、RET、TAB、DEL、ESCがそうです。空白文字は、以下では普通SPCと表記しま
す。厳密にいえば、表示した図形が空白である図形文字です。`C-j'に対する別
名である『linefeed』（ラインフィード） (1) (*Note User
Input-Footnotes::)というラベルが付いたキーを備えたキーボードもあります。


Emacsでは、数千の印字文字（*Note International::）、追加のコントロール
文字、任意の文字と組み合わせ可能な修飾子を導入して、ASCII文字集合を拡張
しています。

ASCII端末では、利用可能なコントロール文字は32個しかありません。これらは、
英字と`@[]\^_'のコントロール変種です。さらに、コントロール文字では、シ
フトキーは意味を持ちません。つまり、`C-a'と`C-A'は同じ文字であり、
Emacsは区別できません。

しかし、Emacsの文字集合自体には、すべての印字文字にコントロール変種を用
意する余地があり、`C-a'と`C-A'を区別できます。Xウィンドウシステムでは、
これらすべての文字を入力できます。たとえば、`C--'（コントロールマイナス）
と`C-5'は、Xウィンドウシステム上では意味を持つEmacsコマンドです。

Emacsの文字集合に対するもう1つの拡張は、修飾ビットの追加です。通常は1ビッ
トの修飾ビットだけを使い、このビットをメタ（Meta）と呼びます。すべての
文字にはメタ変種があります。たとえば、`Meta-a'（通常は`M-a'と略記）や
`M-A'（`M-a'とは異なる文字だが、Emacsでは通常、同じ意味）、`M-RET'、
`M-C-a'です。伝統的な理由で、通常、`M-C-a'よりむしろ`C-M-a'と書きます。
論理的には、2つの修飾キーCTRLとMETAの順序は関係ありません。

端末の中にはMETAキーを備えたものもあり、このキーを押し下げることでメタ
文字を打てます。たとえば、`Meta-a'は、METAを押し下げたまま`a'を押して入
力します。METAキーはSHIFTキーと同じように働きます。しかし、このようなキー
のラベルがつねにMETAであるとは限りません。というのは、この機能は、別の
主目的を持つキーとするための特別なオプションであることがままあるからで
す。

METAキーがなくても、ESCで始まる2文字列を使って
メタ文字を入力できます。
つまり、`M-a'を入力するには、
`ESC a'と打ちます。
`C-M-a'を入力するには、`ESC C-a'と打ちます。
この方法に慣れているのであれば、
METAがある端末でも、ESCを使ってかまいません。

Xウィンドウシステムには、他にもいくつかの修飾キーがあり、すべての入力文
字に適用できます。これらは、SUPER、HYPER、ALTと呼ばれます。文字にこれら
の修飾子が付いていることを示す意味で、`s-'、`H-'、`A-'と書きます。つま
り、`s-H-C-x'は、`Super-Hyper-Control-x'を省略したものです。すべてのX端
末に、実際にこれらの修飾子用のキーがあるわけではありません。実際、ALTと
ラベルされているにも関わらず、実はMETAとして機能するキーを持つ端末が多
くあります。Emacsの標準キーバインディングには、これらの修飾子が付いた文
字はありません。しかし、Emacsをカスタマイズして、それらに独自の意味を割
り当てることができます。

キーボード入力には、ファンクションキーや矢印キーのような文字以外のキー
も含まれます。マウスボタンも文字の範囲には入りません。これらのイベント
も、修飾キーCTRL、META、SUPER、HYPER、ALTを使って、キーボード文字と同じ
ように修飾できます。

文字入力と非文字入力の両者を合わせて、
"入力イベント"（input events）と呼びます。
より詳しくは、
*Note 入力イベント: (elisp)Input Events。
Lispのプログラミング抜きに、
文字イベントや非文字イベントの意味を再定義したい場合には、
*Note Customization::を参照してください。

ASCII端末では、ASCII文字だけしかコンピュータに送れません。これらの端末
では、文字の並びを使って各ファンクションキーを表現します。ただし、キー
ボード入力ルーチンがこれらの特別な文字の並びを認識して、Emacsの他の部分
に渡すまえにファンクションキーイベントに変換してしまうので、これらの文
字の並びがEmacsユーザーの目にふれることはありません。


File: emacs-ja  Node: User Input-Footnotes, Up: User Input

(1) 【訳注】同じ意味で、改行（newline）も使う。



File: emacs-ja, Node: Keys, Next: Commands, Prev: User Input

キー
====

"キー列"（key sequence）（"キー"と略記）は、一塊で『1つのコマンド』とし
ての意味を持つ入力イベントの列です。Emacsのコマンド列の中には、1文字の
み、つまり、1イベントのみであるものもあります。たとえば、`C-f'はポイン
トを1文字先へ進めます。しかし、なかには、起動に2つ以上のイベントを必要
とするコマンドもあります。

あるイベント列が1つのコマンドを起動するのに十分である場合、それらを"完
結キー"（complete key）と呼びます。完結キーの例としては、`C-a'、`X'、
RET、NEXT（ファンクションキーの1つ）、DOWN（矢印キー）、`C-x C-f'、
`C-x 4 C-f'があります。完結するほど十分に長くないイベント列を、"プレ
フィックスキー"（prefix key）と呼びます。上の例では、`C-x'や`C-x 4'が、
プレフィックスキーです。すべてのキー入力列は、完結キーかプレフィックス
キーのどちらかです。

Emacs標準のコマンド割り当てでは、ほとんどの1文字は完結キーです。残りの
少数はプレフィックスキーです。プレフィックスキーは、後続の入力イベント
と結び付いて、それ自体が完結キーやプレフィックスキーとなる、さらに長い
キーの列を作ります。たとえば、`C-x'はプレフィックスキーなので、`C-x'に
続く入力イベントと結び付いて2文字のキー列を作ります。`C-x C-f'や`C-x
b'を含めて、これらのキー列のほとんどは完結キーになります。`C-x 4'や
`C-x r'のように、いくつかのキー列はそれ自体がプレフィックスキーとなり、
3文字のキー列を作ります。キー列の長さに制限はありませんが、実用上は4文
字を超える長さのキー列を使うことはめったにありません。

これに対して、完結キーには入力イベントを付け加えることができません。
たとえば、2文字の列`C-f C-k'はキーではありません。
というのは、`C-f'がそれ自体で完結キーだからです。
`C-f C-k'にコマンドとしての独立した意味付けをすることは不可能です。
`C-f C-k'は、2つのキー列であって、1つのキー列ではありません。

Emacsのプレフィックスキーは、`C-c'、`C-h'、`C-x'、
`C-x RET'、`C-x @'、`C-x a'、`C-x n'、
`C-x r'、`C-x v'、`C-x 4'、`C-x 5'、
`C-x 6'、ESC、`M-g'、`M-j'です。
しかし、これらは固定されているわけではなく、
Emacsのキー割り当ての標準設定となっているだけです。
Emacsをカスタマイズすれば、新しいプレフィックスキーを設定したり、
これらを解除したりできます。
*Note Key Bindings::。

プレフィックスキーを設定したり解除したりすると、可能なキー列の集合を変
えることになります。たとえば、`C-f'をプレフィックスキーとして再定義する
と、`C-f C-k'は自動的に（これをさらにプレフィックスとして定義しない限り
完結した）キーになります。逆に、`C-x 4'をプレフィックスでなくすると、
`C-x 4 f' （または`C-x 4 ANYTHING'）は、もはやキーではなくなります。

プレフィックスキーのあとにヘルプ文字（`C-h'やF1）を打つと、そのプレフィッ
クスで始まるコマンド一覧を表示できます。歴史的な背景から、`C-h'が機能し
ないプレフィックス文字も存在します。これらの文字では、`C-h'が別の意味に
割り当てられていて、容易には変更できないのです。しかし、F1はすべてのプ
レフィックスに対して使えるはずです。



File: emacs-ja, Node: Commands, Next: Text Characters, Prev: Keys

キーとコマンド
==============

本書は、特定のキーの機能を詳しく説明したページばかりです。しかし、
Emacsは直接キーに意味を与えてはいません。そのかわりに、Emacsは名前を付
けた"コマンド"（commands）に意味を持たせ、キーとコマンドを"バインディン
グ"（binding、結び付ける）することによって、キーに意味を与えています。

すべてのコマンドには、プログラマが選んだ名前が付いています。その名前は、
たいていダッシュで区切った数語の英単語です。たとえば、`next-line'や
`forward-word'がそうです。コマンドは、Lispプログラムである"関数定義"
（function definition、defun）を持ちます。これが、コマンドが行うべきこ
とを行えるようにしています。Emacs Lispでは、コマンドは実際には特別な種
類の関数です。つまり、引数の読み取り方や対話的な呼び出し方が規定された
Lisp関数です。コマンドと関数に関してより詳しくは、*Note 関数とは何か:
(elisp)What Is a Functionを参照してください。（本書での定義は少々簡易化
してある。）

キーとコマンドのバインディングは、
"キーマップ"（keymaps）という表に記録されています。
*Note Keymaps::。

『`C-n'は垂直方向に1行下がる』という表現では、Emacsのカスタマイズ方法を
理解するうえでは非常に重要であっても、普段の使い方では意味のない「区別」
をあえて無視しています。下がるようにプログラムされているのは
`next-line'というコマンドです。`C-n'がそのコマンドにバインドされている
ので、そのような効果を発揮するのです。`C-n'をコマンド`forward-word'にバ
インドし直すと、`C-n'は、かわりに1単語ずつ先へ進むようになります。キー
の再バインディングは、カスタマイズの一般的な方法です。

本書では、今後、話を単純にするために、普段はこの違いを無視することにし
ます。カスタマイズに必要な情報を示す場合、コマンドを実行するキーを記し
たあとに、実際にその動作を行うコマンドの名前を括弧に括って示します。た
とえば、『コマンド`C-n'（`next-line'）は、ポイントを下向きに移動する』
という表現では、下向きに移動するコマンドは`next-line'であり、標準ではキー
`C-n'にバインドされていることを意味します。

これまでカスタマイズに関して述べてきましたので、
"変数"についてふれておく時期でしょう。
コマンドの説明では、
『これを変更するには、変数`mumble-foo'を設定する』と
記述することがあります。
変数とは、値を記憶しておくために使う名前のことです。
本書に記載された変数の大部分は、カスタマイズのために使われます。
いくつかのコマンドやEmacsの他の部分では、
変数を調べて設定された値に従ってそのふるまいを変えていきます。
カスタマイズに興味が出てくるまでは、
変数に関する記述は無視してかまいません。
カスタマイズしてみたいと思ったら、
変数に関する基礎を読んでください。
そうすれば、個々の変数に関する情報を理解できるでしょう。
*Note Variables::。



File: emacs-ja, Node: Text Characters, Prev: Commands

テキスト用の文字集合
====================

Emacsバッファ内のテキストは、1バイト8ビットのバイトの列です。各バイトで、
1つのASCII文字を表現できます。ASCIIコントロール文字（8進数000〜037、
0177）とASCII印字文字（8進数040〜0176）の両方を使えます。しかし、非
ASCIIコントロール文字はバッファには現れません。メタのようなキーボード入
力で用いられるその他の修飾フラグもバッファ内では許されません。

いくつかのASCIIコントロール文字は、
テキスト中では特別な目的のために用いられていて、特別な名前が付いています。
たとえば、改行文字（8進数012）は、バッファ内の1行の終りに使われます。
また、タブ文字（8進数011）は、つぎのタブストップ位置（通常8桁ごと）まで
テキストを字下げするために使われます。
*Note Text Display::。

非ASCII印字文字もバッファ内に存在できます。
マルチバイト文字を使用可にしてあれば、
Emacsが扱える任意の非ASCII印字文字を使えます。
それらの文字の文字コードは256（8進で0400）から始まり、
各文字は2バイト、あるいはそれ以上のバイト列として表現されます。
*Note International::。

マルチバイト文字を使用不可にしている場合、
非ASCII文字のうちの1種類のアルファベットだけを使えますが、
それらはすべて1バイトに収まるものです。
文字コードは0200から0377を使います。
*Note Single-Byte European Support::。


File: emacs-ja, Node: Entering Emacs, Next: Exiting, Prev: Text Characters, Up: Top

Emacsの起動と終了
*****************

Emacsを起動する普通の方法は、シェルコマンドの`emacs'です。Emacsは、画面
をクリアし、初期ヘルプメッセージとコピーライトを表示します。オペレーティ
ングシステムによっては、Emacsが起動するまでに先打ちした入力をすべて破棄
してしまうことがあります。Emacs側ではこれを防ぐことはできません。したがっ
て、編集コマンドを打ち始めるまえに、Emacsが画面をクリアするまで待つよう
に推奨します。

Xウィンドウシステム上のシェルウィンドウからEmacsを起動するのであれば、
`emacs&'のようにバックグラウンドで実行するようにしましょう。こうすれば、
Emacsがシェルウィンドウを拘束することがないので、Emacsが専用のXのウィン
ドウで動作中でも、別のシェルコマンドを実行できます。キーボード入力を
Emacsのフレームに向ければ、ただちにEmacsコマンドを打ち始められます。

Emacsが動き始めると、`*scratch*'という名前のバッファを作ります。
ユーザーはこのバッファから始めます。
バッファ`*scratch*'は、Lisp対話（lisp-interaction）モードですから、
Lisp式を打ち込んでそれを評価できますし、あるいは、
この機能を無視して単なる落書用として使ってもかまいません。
（個人の初期化ファイル中で変数`initial-major-mode'を設定すれば、
このバッファに別のメジャーモードを指定できる。
*Note Init File::。）

シェルのコマンド行でEmacsに引数を与えて、訪問するファイル、ロードする
Lispファイル、呼び出す関数を指定できます。*Note Command Arguments::。た
だし、これはお勧めしません。この機能は、主に、他のエディタとの互換性の
ためにあるのです。

他のエディタの多くは、編集を行うたびに新たに起動するように設計されてい
ます。1つのファイルを編集し終えると、エディタを終了します。つぎに別のファ
イルや同じファイルを編集したければ、再度、エディタを起動する必要があり
ます。これらのエディタでは、コマンド行の引数で編集するファイルを指定す
る意味があります。

しかし、別のファイルを編集するたびに新たにEmacsを起動するのはナンセンス
です。1つには、起動はじれったいほど遅いでしょう。また、このようにすると、
1つの編集セッションで複数のファイルを扱えるEmacsの利点を活かせません。
さらに、レジスタやアンドゥ履歴、マークリングといった、それまでに蓄積し
た内容も失ってしまいます。

GNU Emacsの推奨される使い方は、ログイン後に1度だけEmacsを起動して、すべ
ての編集を同じEmacsセッションで行うことです。別のファイルを編集するには、
既存のEmacsでそのファイルを訪問します。そうすると、ついには、多くのファ
イルをすぐに編集できる状態で保持することになります。通常、ログアウトす
るまで、Emacsを終了する必要はありません。複数のファイルを訪問することに
関して詳しくは、*Note Files::。



File: emacs-ja, Node: Exiting, Prev: Entering Emacs, Up: Entering Emacs

Emacsの終了
===========

Emacsの抜け方には、"休止"（suspending）する、"終了"（killing）するの2種
類があるので、Emacsを抜けるコマンドも2つあります。

"休止"（suspending）は、一時的にEmacsを止めて、親プロセス（通常はシェル）
に制御を戻します。こうすると、同じバッファ、同じキルリング、同じアンドゥ
履歴を保持したままの同じEmacsジョブをあとで再開できます。これが通常の抜
け方 (1) (*Note Exiting-Footnotes::)です。

"終了"（killing）は、Emacsジョブの破壊を意味します。あとでまたEmacsを起
動できますが、新たなEmacs環境です。終了したあとでは、同じ編集セッション
を再開する方法はありません。

`C-z'
     Emacsを休止する、あるいは、フレームをアイコン化する
     （`iconify-or-deiconify-frame'）。
`C-x C-c'
     Emacsを終了する（`save-buffers-kill-emacs'）。

Emacsを休止するには、`C-z'（`suspend-emacs'）と打ちます。すると、Emacs
を起動したシェルに戻ります。ほとんどの一般的なシェルでは、シェルコマン
ド`%emacs'でEmacsを再開できます。

プログラムを休止できないシステムでは、`C-z'は、端末と直接やりとりする下
位シェルを起動します。Emacsは、ユーザーがこのサブシェルから抜け出るまで
待ちます。（普通、`C-d'や`exit'でサブシェルを終了するはずだが、使ってい
るシェルに依存する。）このようなシステムでは、Emacsを起動したシェルに
（たとえばログアウトのために）戻るには、Emacsを終了する以外に方法はあり
ません。

プログラムを休止できるシステムであっても、プログラムを休止できないシェ
ル上で実行しているEmacsは休止できません。このような場合、変数
`cannot-suspend'に`nil'以外の値を設定して、`C-z'に下位シェルの実行を強
制できます。（適切なジョブ制御をできないEmacsの親シェルを『下位』と呼ぶ
こともできるが、これは好みの問題。）

EmacsがXサーバーと直接通信して専用のXのウィンドウを作っている場合には、
`C-z'は別の意味になります。専用のXのウィンドウを持つアプリケーションを
休止しても、あまり意味がありませんし、便利なわけでもありません。そのか
わり、`C-z'は、選択されているEmacsフレーム（*Note Frames::）を一時的に
閉じるコマンド`iconify-or-deiconify-frame'を実行します。シェルウィンド
ウに戻るには、ウィンドウマネージャの機能を使います。

Emacsを終了するには、`C-x C-c' （`save-buffers-kill-emacs'）と打ちます。
これを2文字のキーにしてあるのは、少々打ちづらく (2) (*Note
Exiting-Footnotes::)するためです。このコマンドは、まず、変更したバッファ
を保存するかどうか聞いてきます。未保存のものがあるとそれらを永久に失う
ことになるので、Emacsを終了するまえに`yes'での再確認を求めてきます。
Emacsを終了するとサブプロセスもただちに終了されられてしまうため、サブプ
ロセスが走っている場合にも、それらに関して確認を求めてきます。

一度Emacsを終了してしまうと、Emacsセッションを再開する方法はありません。
しかしながら、終了時に訪問していたファイルなどの
特定のセッション情報を記録するようにEmacsに指示しておけば、
つぎにEmacsを起動し直したときに、
同じファイルを訪問するなどを試みるようになります。
*Note Saving Emacs Sessions::。

オペレーティングシステムは、通常、実行中のプログラムを終了させたり休止
させたりする特定の特殊文字を監視しています。Emacsを使っているときには、
オペレーティングシステムのこの機能はオフになっています (3) (*Note
Exiting-Footnotes::) 。Emacsのキーとしての`C-z'や`C-x C-c'の意味は、い
くつかのオペレーティングシステムでプログラムを休止させたり終了させたり
するために用いる文字、`C-z'と`C-c'にヒントを得たものですが、オペレーティ
ングシステムとの関係はそれだけです。これらのキーで好きなコマンドを実行
するようにカスタマイズできます（*Note Keymaps::）。



File: emacs-ja  Node: Exiting-Footnotes, Up: Exiting

(1) 【訳注】これは、画面端末を使っている場合の話。

(2) 【訳注】簡単に終了してしまっては、困るので。

(3) 【訳注】Emacsが専用のXのウィンドウを使っている場合は関係ない。


File: emacs-ja, Node: Basic, Next: Minibuffer, Prev: Exiting, Up: Top

基本編集コマンド *(2004/03/28)*
*******************************

テキストの入力、修正、ファイルへの保存といった基本操作について説明しま
す。これらに接するのが初めてという読者は、手を動かしながら学ぶチュート
リアルを実行したほうが、もっと簡単に習得できる思います。チュートリアル
を利用するには、Emacsを起動して`Control-h t'と打ちます。 (1) (*Note
Basic-Footnotes::)

画面をクリアして再表示するには、`C-l'（`recenter'）と打ちます。

* Menu:

* Inserting Text::              Inserting text by simply typing it.
* Moving Point::                How to move the cursor to the place where you want to
			  change something.
* Erasing::                     Deleting and killing text.
* Undo::                        Undoing recent changes in the text.
* Files: Basic Files.           Visiting, creating, and saving files.
* Help: Basic Help.             Asking what a character does.
* Blank Lines::                 Commands to make or delete blank lines.
* Continuation Lines::          Lines too wide for the screen.
* Position Info::               What page, line, row, or column is point on?
* Arguments::                   Numeric arguments for repeating a command.
* Repeating::                   A short-cut for repeating the previous command.


File: emacs-ja  Node: Basic-Footnotes, Up: Basic

(1) 【訳注】Emacsのインストールの仕方によっては、きちんと日本語のチュー
トリアルが表示される。そうでなければ、`M-x
set-language-environment RET Japanese RET'（あるいは、
`C-x RET l Japanese RET'）と打ってから、改めて
`Control-h t'と打つ。日本語以外にもいくつかの言語のチュートリアルが
ある。



File: emacs-ja, Node: Inserting Text, Next: Moving Point, Prev: Basic, Up: Basic

テキストを挿入する *(2004/03/28)*
=================================

編集中のテキストに印字文字を挿入するには、
単にその文字を打ちます。
こうすると、打鍵した文字がバッファのカーソル位置
（すなわち"ポイント"位置。*Note Point::）に挿入されます。
カーソルは右（前向き）に移動して、
それにあわせてカーソル以降のすべてのテキストも右（前向き）に移動します。
バッファ内のテキストが`FOOBAR'であって、
カーソルが`B'に重なっているとすると、
`XX'と打つとカーソルは`B'に重なったままで、
`FOOXXBAR'となります。

挿入したばかりのテキストを"削除"（delete）するには、DEL やBACKSPACE，
DELETEと書かれたキーを使います。これらのキーはRET や ENTERキーの近くに
あります．これはEmacs以外では普通入力した文字を削除するキーとして使われ
ます．Emacsでは印刷されている文字に関わらずDELとして扱います．そして，
このマニュアルではこれらのキーをDELと呼ぶことにします．

DELキーは*カーソルのまえ*の文字を削除します．結果として，カーソルとカー
ソル以降のすべてのテキストは左（後向き）に移動します。つまり、図形文字
を1つ打った直後にDELを打つと、挿入を取り消したことになります。

ほとんどのコンピュータではEmacsはDELであるべきキーを自動的に認識し，機
能を割り当てます．しかし，テキスト端末だけのコンピュータなどではDELキー
として扱うためのキーを設定する必要があります．RET や ENTER の近くにある
キーで削除できないようであれば，設定が必要になります．設定方法は *Note
DEL Does Not Delete:: を参照してください．

ほとんどのPCでは RET や ENTER キーの近くに DELETE キーの他に BACKSPACE
キーもあります．これらのキーボードでは BACKSPACE キーが前向きに削除する
慣習に習います．一方，DEL は`C-d'(以下を参照)のように逆方向に削除します．



行を終えて新たな行を打ち始めるには、RETを打ちます。これにより、バッファ
に改行文字が挿入されます。ポイントが行の途中にある場合、RETは行を分割し
ます。カーソルが行頭にあるときにDELを打つと、直前の改行文字が削除されて
直前の行と連結されます。

"自動詰め込み"（auto-fill）モードと呼ばれる特別なマイナモードをオンにし
ておくと、行が長くなりすぎたときにEmacsが自動的に行を分割します。自動詰
め込み（auto-fill）モードの使い方は、*Note Filling::。

既存のテキストを右に押しやるのではなく、
テキストを順次置き換える（上書きする）のが好みならば、
マイナモードの1つである上書き（overwrite）モードをオンにします。
*Note Minor Modes::。

印字文字とSPCは直接挿入できますが、それ以外の文字は編集コマンドとして機
能して、それ自体を挿入しません。コントロール文字や8進で0200を超える文字
コードの文字を挿入したい場合には、まず`Control-q'（`quoted-insert'）と
打って、それらの文字を"クォート"（quote） (1) (*Note Inserting
Text-Footnotes::) する必要があります。（`Control-q'は、通常、
`C-q'と略す。）`C-q'の使い方には、つぎの2つがあります。

   * `C-q'に続く非図形文字（`C-g'でさえも）を挿入する。

   * `C-q'に続く8進数字列は、8進数字列で指定されるコードの文字を挿入す
     る。8進数字の桁数はいくつでもかまわず、8進数字以外で数字列は終る。
     終端の文字がRETであれば、単に数字列を終らせるだけ。それ以外の非数
     字は、数字列を終らせ，通常の入力として扱われます．結果，`C-q 1 0
     1 B' は `AB'を入力することになります．

     普通の上書き（overwrite）モードでは、上書きのかわりに挿入を簡単に
     行う手段としているため、この8進数字列は使えない。

マルチバイト文字が使用可で，8進コードの0200から0377であるとEmacsが判断
すると．`C-q'はISO 8859-N文字集合の利用を意図しているとみなして、指定し
たコードを対応するEmacs文字コードに変換します。*Note Enabling
Multibyte::。言語環境の選択（*Note Language Environments::）を介して、
ISO 8859 文字集合を1つ選びます。

8進数のかわりに10進数や16進数を使うには、変数`read-quoted-char-radix'に
10や16を設定します。基数が10を超える場合には、`a'から始まるいくつかの英
字は文字コードの一部として数字の桁と同じように扱われます。

`C-q'に数引数を指定すると、クォートした文字を何個挿入するかを指定します
（*Note Arguments::）。

カスタマイズ情報：` '
ほとんどのモードでは、
DELはコマンド`delete-backward-char'を実行します。
RETはコマンド`newline'を実行します。
自己挿入の図形文字はコマンド`self-insert'を実行します。
`self-insert'は、これを起動した文字が何であってもその文字を挿入します。
いくつかのメジャーモードでは、
DELを別のコマンドにバインドし直しています。


File: emacs-ja  Node: Inserting Text-Footnotes, Up: Inserting Text

(1) 【訳注】なんらの解釈もせずに、単なる文字として扱う。



File: emacs-ja, Node: Moving Point, Next: Erasing, Prev: Inserting Text, Up: Basic

ポイント位置を移動する *(2004/03/28)*
=====================================

文字の挿入以外のことを行うには、ポイント（*Note Point::）の移動方法を知っ
ておく必要があります。もっとも簡単な方法は、矢印キーを使うか、移動先の
箇所でマウスの左ボタンをクリックします。

カーソル移動のためのコントロール文字やメタ文字もあります。一部は矢印キー
と同等です（これらは、矢印キーを備えた端末が現れるまえからあった。矢印
キーがない端末では便利）。他のものは、こったことをします。

`C-a'
     行頭に移動する（`beginning-of-line'）。
`C-e'
     行末に移動する（`end-of-line'）。
`C-f'
     前向き（右）に1文字移動する（`forward-char'）。右矢印キーも同じこ
     とを行います．
`C-b'
     後向き（左）に1文字移動する（`backward-char'）。左矢印キーも同じこ
     とを行います．
`M-f'
     前向きに1語移動する（`forward-word'）。
`M-b'
     後向きに1語移動する（`backward-word'）。
`C-n'
     垂直に1行下へ移動する（`next-line'）。このコマンドは行内での横方向
     の位置を保とうとする。したがって、行の途中で使うと、つぎの行の途中
     に移動する。下矢印キーも同じことを行います．
`C-p'
     垂直に1行上へ移動する（`previous-line'）。上矢印キーも同じことを行
     います．
`M-r'
     ポイントをウィンドウの縦方向の中央位置で左端に移動する
     （`move-to-window-line'）。テキストは画面上を移動しない。

     数引数は、画面上の何行目にポイントを移動するかを指定する。行数は、
     ウィンドウ上端（0行目）から下向きに数える。負の引数では、ウィンド
     ウの下端（-1行）から数える。
`M-<'
     バッファの先頭に移動する（`beginning-of-buffer'）。数引数Nを指定す
     ると、先頭から全体のN/10の行にポイントを移動する。数引数の詳細につ
     いては、*Note Arguments::。
`M->'
     バッファの末尾に移動する（`end-of-buffer'）。

`C-v'
     順方向にスクロールし，必要があればポイントを移動します
     (`scroll-up')．いつもポイントを移動するわけではありません．
     PAGEDOWN キーがあれば，このキーも同じ機能になります．

     スクロール関連のコマンドの詳細は *Note Scrolling:: にあります．
`M-v'
     逆方向にスクロールし，必要があればポイントを移動します
     (`scroll-down')．いつもポイントを移動するわけではありません．
     PAGEUP キーがあれば，このキーも同じ機能になります．

`M-x goto-char'
     数値Nを読み取り、バッファのN番目の文字にポイントを移動する。バッファ
     の先頭が位置1。
`M-x goto-line'
     数値Nを読み取り、N行目にポイントを移動する。バッファの先頭が第1行。
`C-x C-n'
     現在ポイントがある桁を`C-n'や`C-p'の"半恒久的な目標桁"として設定す
     る。このあと、これらのコマンドは、移動先の各行でこの桁位置に、ある
     いは、行の内容によっては可能な限りこの桁に近い位置にポイントを移動
     する。この目標桁は取り消すまで有効。
`C-u C-x C-n'
     目標桁を取り消す。これ以後、`C-n'や`C-p' は、通常のように横方向の
     位置を保とうとする。

変数`track-eol'に`nil'以外を設定すると、
行末にポイントがある場合の`C-n'や`C-p'は、
移動先の行でも行末にポイントを移動します。
通常、`track-eol'は`nil'です。
`track-eol'のような変数の設定方法については、*Note Variables::。

通常、バッファの最終行での`C-n' を実行するとエラーになります(バッファの
先頭で `C-p' を実行しても同じです)．しかし，`next-line-add-newlines' を
非`nil' に設定すると，`C-n' はエラーにならず，新しい行を追加し，そこに
カーソルを移動します．



File: emacs-ja, Node: Erasing, Next: Undo, Prev: Moving Point, Up: Basic

テキストの消去 *(2004/03/28)*
=============================

`DEL'
     ポイントの直前の文字を削除する（`delete-backward-char'）。
`C-d'
     ポイントの直後の文字を削除する（`delete-char'）。

`DELETE'
`BACKSPACE'
     RET や ENTER キーの上にあるこれらのキーはDELのようにポイントの
     前にある文字を削除します．もしBACKSPACEとDELETEの両方があれば
     DELETE は `C-d'のようにポイントの後ろにある文字を削除します．

`C-k'
     行末までをキルする（`kill-line'）。
`M-d'
     つぎの語の末尾までを前向きにキルする（`kill-word'）。
`M-DEL'
     まえの語の先頭までを後向きにキルする（`backward-kill-word'）。

ポイントの直前（つまり、カーソルの直前）の文字を削除するDELキーについて
はすでに知っていますね。`Control-d'（`C-d'と略記）は、ポイントの直後の
文字（つまり、カーソルが重なっている文字）を削除します。すると、残りの
テキストは左に移動します。行末で`C-d'を打つと、その行とつぎの行が連結さ
れます。

大量のテキストを消去するには、`C-k'を使います。`C-k'は1行を一度にキルし
ます。行頭や行の途中で`C-k'を打つと、行末までのすべてのテキストをキルし
ます。行末で`C-k'を打つと、その行とつぎの行を連結します。

より柔軟なテキストのキルについての詳細は、*Note Killing::。



File: emacs-ja, Node: Undo, Next: Basic Files, Prev: Erasing, Up: Basic

変更をアンドゥする（もとに戻す） *(2004/03/28)*
===============================================

バッファのテキストに対する変更は、ある時点まで遡って、すべてアンドゥ
（もとに戻すことが）できます。各バッファでは個々の変更をそれぞれ記録し
ていて、アンドゥコマンドは、つねにカレントバッファに作用します。通常、
各編集コマンドはアンドゥ記録に別々の項目を作成しますが、
`query-replace'のようなコマンドは一度に多くの項目を作りますし、自己挿入
文字のように非常に単純なコマンドは、もとに戻すのを単純にするために、ま
とめられます。

`C-x u'
     一塊の変更をもとに戻す。普通、1つのコマンドに相当する（`undo'）。
`C-_'
     同じ。
`C-u C-x u'
     リージョン内で、一塊の変更をもとに戻す。

変更をもとに戻すには、コマンド、`C-x u'や`C-_'を使います。始めにこのコ
マンドを実行すると、直前の変更をもとに戻します。ポイントは、もとに戻さ
れたコマンドを実行するまえの位置に戻ります。

`C-_'や`C-x u'を連続して実行すると、アンドゥ情報の限界に達するまで、次々
に以前の変更をもとに戻していきます。記録されているすべての変更をもとに
戻してしまうと、アンドゥコマンドはその旨エラーメッセージを表示します。

アンドゥコマンド以外の他のコマンドを実行すると、アンドゥコマンドの連続
実行系列が断ち切られます。これ以後、これよりまえのアンドゥコマンドの実
行自体が、もとに戻すことが可能な一般の変更として扱われます。したがって、
もとに戻してしまった変更をやはりそのとおりに変更しておきたい場合には、
`C-f'と打つか、あるいは、無害なコマンドを実行してアンドゥの連続実行系列
を断ち切ってから、さらにアンドゥコマンドを打ちます。

普通のアンドゥは、カレントバッファにおけるすべての変更に作用します。カ
レントリージョン内に制限した"選択的なアンドゥ"（selective undo）を行う
こともできます。これには、リージョンを設定してから、数引数（値は関係な
い）を指定して`undo'コマンドを、つまり、`C-u C-x u'や`C-u C-_'を実行し
ます。これにより、リージョン内のもっとも最近の変更がもとに戻ります。同
じリージョン内の変更をさらにもとに戻すには、`undo'コマンドを繰り返しま
す（これには数引数は必要ない）。暫定マーク（transient-mark）モードでは、
リージョンが活性のときに`undo'を使うと選択的なアンドゥを行います。つま
り、数引数は必要ありません。

バッファを誤って変更してしまった場合、もとに戻すもっとも簡単な方法は、
モード行の先頭部分から星印が消えるまで`C-_'を繰り返し打つことです。そう
すれば、すべての修正を取り消したことになります。アンドゥコマンドにより
モード行から星印が消えた場合はつねに、バッファの内容がファイルを訪問し
たときと同じであるか、最後に保存したときと同じであることを意味します。

意図してバッファを変更したかどうかあやふやなときは、一度だけ`C-_'を打ち
ます。もとに戻すことで最後の変更箇所がわかりますから、それが意図した変
更かどうか判断できるでしょう。意図した変更でなければ、もとに戻したまま
にしておきます。意図した変更であったなら、上記の方法で変更し直します。

すべてのバッファでアンドゥ情報を記録するわけではありません。空白で始ま
る名前のバッファでは記録しません。これらのバッファは、Emacsやその拡張部
分が内部的に使用するもので、ユーザーが通常見たり編集したりしないテキス
トを保持しています。

単なるカーソル移動はアンドゥできません。バッファの内容を変更したときだ
けアンドゥ情報が保存されます。ただし、いくつかのカーソル移動コマンドは
マークを設定しますから、これらのコマンドをときどき使えば、マークリング
（*Note Mark Ring::）から取り出しながら、通ってきたそれぞれの箇所へ戻る
ことができます。

バッファに関するアンドゥ情報が大きくなると、Emacsはもっとも古いアンドゥ
情報から順に（ガベッジコレクション中に）破棄していきます。保持すべきア
ンドゥ情報の量を指定するには、2つの変数`undo-limit'と
`undo-strong-limit'を設定します。これらの変数の値は、保存領域のバイト数
です。

変数`undo-limit'は緩い限界（soft limit）を設定します。Emacsは、このサイ
ズに達するまでのコマンド分のアンドゥデータを保持します。データ量がこの
サイズを超える場合もありますが、このデータ量を超えるような古いコマンド
分のデータは保持しません。デフォルトは、20000です。変数
`undo-strong-limit'は、厳密な限界（stricter limit）を設定します。この量
を超えるデータに対応するコマンドのデータは破棄します。初期値は30000です。

これらの変数の値に関わらず、最新の変更を破棄することはありませんので、
意図しない大きな変更を加えてしまった直後にガベッジコレクションが発生し
ても、その変更をアンドゥできないというようなことはありません。

アンドゥコマンドを実行するキーが`C-x u'と`C-_'と2つある理由は、
1文字キーにするほど重要なのですが、どうやって`C-_'を打つか自明でない
キーボードもあるからです。
`C-x u'は、どの端末でも素直に打てる代替手段なのです。



File: emacs-ja, Node: Basic Files, Next: Basic Help, Prev: Undo, Up: Basic

ファイル
========

Emacsバッファ内でテキストを作成したり変更したりするには、これまでに説明
したコマンドで十分なはずです。より高度なEmacsコマンドといっても、これら
の操作を容易にするだけです。しかし、テキストを恒久的なものとするには、
ファイル"（file）に保存する必要があります。ファイルとは、オペレーティン
グシステムが保存するために名前を付けたテキストの一塊であり、あとでその
名前で取り出せます。Emacsでファイルを編集する場合を含めて、ファイルの内
容を眺めたり利用したりするには、ファイル名を指定する必要があります。

`/usr/rms/foo.c'という名前のファイルがあるとしましょう。このファイルを
編集し始めるには、Emacsではつぎのように打ちます。

     C-x C-f /usr/rms/foo.c RET

ここで、ファイル名は、コマンド`C-x C-f'（`find-file'）に対する"引数
（argument）として与えます。このコマンドは引数を読むために"ミニバッファ
を使います。引数の入力を終えるには、RETを打ちます（*Note Minibuffer::）。

Emacsはコマンドに従い、ファイルを"訪問"（visiting）します。つまり、バッ
ファを作成し、ファイルの内容をそのバッファにコピーし、ユーザーが編集で
きるようにそのバッファを表示します。テキストを変更したら、`C-x
C-s'（`save-buffer'）と打てば、新しいテキストをファイルに"保存"（save）
できます。これにより、バッファの変更した内容をファイル`/usr/rms/foo.c'
にコピーし戻したので、変更は恒久的になります。ユーザーが保存するまでは、
変更はEmacs内部のみに存在するだけで、ファイル`foo.c'自体は未変更のまま
です。

ファイルを作成するには、そのファイルが既存であるかのように、`C-x C-f'で
ファイルを訪問するだけです。これにより、空のバッファが作られ、ファイル
に収めたいテキストを挿入できるようになります。`C-x C-s'でバッファを保存
したときに、ファイルが実際に作成されます。

もちろん、ファイルについてはもっと知っておく必要があります。
*Note Files::。



File: emacs-ja, Node: Basic Help, Next: Blank Lines, Prev: Basic Files, Up: Basic

ヘルプ
======

キーの機能を忘れてしまった場合には、
ヘルプ文字`C-h'（あるいは`C-h'の別名であるF1）を使って、
調べられます。
`C-h k'と打ってから、調べたいキーを続けて打ちます。
たとえば、`C-h k C-n'は、`C-n'が何をするか教えてくれます。
`C-h'はプレフィックスキーです。
`C-h k'は、`C-h'の1つのサブコマンド
（コマンド`describe-key'）です。
`C-h'には他にもサブコマンドがあり、
それぞれ異なる種類のヘルプを表示します。
`C-h'を2回打てば、ヘルプ機能自体の説明を見ることができます。
*Note Help::。



File: emacs-ja, Node: Blank Lines, Next: Continuation Lines, Prev: Basic Help, Up: Basic

空行 *(2004/03/28)*
===================

空行の挿入と削除に関する特別なコマンドや技法を紹介します。

`C-o'
     カーソルの直後に1行以上の空行を挿入する（`open-line'）。
`C-x C-o'
     連続する空行を1行だけ残してすべて削除する（`delete-blank-lines'）。

既存の行のまえに新たに1行を挿入するには、
新しい行のテキストを打ってからRETを打つこともできます。
しかし、まず空行を作ってから、
そこに希望のテキストを挿入するほうが何をしているのかがわかりやすいでしょう。
キー`C-o'（`open-line'）を使えば簡単です。
これはポイントの直後に改行を挿入して、
ポイントは改行の直前に置かれたままとなります。
`C-o'に続けて、新しい行のテキストを打ちます。
`C-o F O O'は、ポイントの最終的な位置を除けば、
`F O O RET'と同じ効果を持ちます。

複数の空行を作るには、`C-o'を数回打つか、
作りたい空行の個数を指定する数引数を指定します。
数引数の指定方法は、*Note Arguments::。
詰め込み接頭辞を設定してある場合、
行の先頭で`C-o'コマンドを使うと、
このコマンドは新しい行に詰め込み接頭辞を挿入します。
*Note Fill Prefix::。

余分な空行を削除するには、コマンド`C-x C-o'（`delete-blank-lines'）を使
います。連続する複数の空行の中で`C-x C-o'を実行すると、1行を残してすべ
ての空行を削除します。空行が1行だけの場合、その空行自体を削除します。空
行でない行にポイントがある場合、その行に続くすべての空行を削除します。



File: emacs-ja, Node: Continuation Lines, Next: Position Info, Prev: Blank Lines, Up: Basic

継続行 *(2004/03/28)*
=====================

RETで分割せずに1行に文字を加え続けると、その行は画面上で2行以上を占める
ようになります。グラフィック端末ではEmacsはフリンジ(，ウィンドウの左や
右にある領域，fringe)に矢印を表示します．テキスト端末では行の最後の行を
除くすべての行の右端に、`\'を表示します。この`\'は、画面上の後続の行は
テキスト内の独立した行ではなく、画面に収まりきらない長い行が"継続
（continuation）していることを意味します。この継続を、"折り返し
（wrapping）とも呼びます。

1行がウィンドウ幅よりも長くなる時には右端で折り返され，文字の前に"空白
が挿入されることがあります．この場合，Emacsは 追加の`\'を表示し，`\'の
前の文字は継続を表します．

行が長くなりすぎたときにEmacsが自動的に改行を挿入すると便利なことがあり
ます。画面上での継続は、このようには機能しません。自動的に改行するよう
にするには、自動詰め込み（auto-fill）モード（*Note Filling::）を使いま
す。

継続のかわりの方法として、Emacsは長い行を"切り捨て"（truncation）て表示
することもできます。つまり、画面やウィンドウの幅に収まりきらない文字は
表示しません。もちろん、一時的に見えないだけで、バッファ内には存在して
います。端末で表示できず切り捨てられていることを示すために、`$'を右端に
表示します．ウィンドウシステムでは切り捨てられていることを表すために小
さなまっすぐの矢印を表示します．

水平スクロールを使っていたり、ウィンドウを左右に並べていると、継続のか
わりに切り捨て表示します（*Note Windows::）。`M-x
toggle-truncate-lines'を実行すると，そのバッファを切り捨て表示にするか
どうかを切り替えることができます．

テキストの表示方法に影響する変数については、*Note Display Custom::。



File: emacs-ja, Node: Position Info, Next: Arguments, Prev: Continuation Lines, Up: Basic

カーソル位置の情報 *(2004/03/27)*
=================================

バッファのある部分の大きさや位置に関する情報を得るコマンドや行を数える
コマンドを紹介します。

`M-x what-page'
     ポイントがあるページの番号とそのページ内での行番号を表示する。
`M-x what-line'
     ポイントがある行のバッファ内での行番号を表示する。
`M-x line-number-mode'
`M-x column-number-mode'
     現在行の自動行番号や桁表示をオン／オフする(*Note Optional Mode
     Line::)。
`M-='
     カレントリージョンの行数を表示する（`count-lines-region'）。リージョ
     ンに関しては、*Note Mark::。
`C-x ='
     ポイントの直後にある印字文字の文字コード、ポイントの文字位置、ポイ
     ントの桁位置を表示する（`what-cursor-position'）。

`M-x hl-line-mode'
     現在行を強調表示するかどうかを切り替えることができます(*Note
     Cursor Display::)．
`M-x size-indication-mode'
     バッファサイズを自動的に表示するかどうかを切り替えることができます．
     *Note Optional Mode Line::.

行番号に関するコマンドは2つあります。`M-x what-line'は現在行の行番号を
計算して、エコー領域に表示します。指定した行番号の行へ移動するには、
`M-x goto-line'を使います。このコマンドは、行番号を聞いてきます。これら
の行番号は、バッファの先頭を1行目と数えます。

モード行で現在行の行番号を知ることもできます(*Note Mode Line::)。バッファ
をナロイングしてある場合、モード行中の行番号は参照可能な範囲内での相対
的なものになります（*Note Narrowing::）。対照的に、`what-line'は、ナロ
イングされた範囲内での行番号と、バッファ全体での行番号の両方を表示しま
す。

`M-x what-page'は、ファイルの先頭からページを数え、
さらにページ内での行番号も数えて、両方をエコー領域に表示します。
*Note Pages::。

この話題に関連して、`M-='（`count-lines-region'）も説明しておきましょう。
これは、リージョンの行数を数えて表示します（*Note Mark::）。カレントペー
ジの行数を数えるコマンド`C-x l'については、*Note Pages::。

コマンド`C-x ='（`what-cursor-position'）は、カーソルがある箇所の桁位置
を求めたり、ポイントやその後にある文字に関するその他の種々の情報を得る
ために使います。エコー領域につぎのように表示します。

     Char: c (0143, 99, 0x63)  point=21044 of 26883(78%)  column 53

（これは、例の中の`column'のまえにポイントがあるときの実際の出力。）

`Char:'のあとの4つの値は、ポイントの直後の文字を表していて、文字そのも
の、続いて、文字コードの8進表示、10進表示、16進表示です。非ASCIIのマル
チバイト文字に対しては、バッファのコーディングシステムにおいて当該文字
をまちがいなく、かつ、単一バイトで符号化できる場合には、`ext'とバッファ
のコーディングシステムで表した文字コードの16進表示が続きます（*Note
Coding Systems::）。文字の符号が1バイトより長い場合には、Emacsは
`ext ...'を表示します。

`point='のあとは、ポイント位置を文字単位に数えたものです。バッファの先
頭を位置1、つぎの1文字を2、というように数えます。つぎの大きな数字はバッ
ファ内の総文字数です。続く括弧の中は、ポイント位置の全サイズに対する百
分率です。

`column'に続くものは、ウィンドウの左端からの桁数で表したポイントの水平
位置です。

バッファをナロイングしていて、バッファの先頭と末尾のテキストの一部が表
示されていない場合、`C-x ='は、現在参照可能な範囲に関する情報も表示しま
す。たとえばつぎのようになります。

     Char: C (0103, 67, 0x43)  point=252 of 889(28%) <231 - 599>  column 0

ここで、新たに追加された2つの数字が、
ポイントを設定できる文字位置の下限と上限を示します。
これら2つの位置のあいだの文字が参照可能な文字です。
*Note Narrowing::。

ポイントがバッファの末尾（あるいは参照可能な部分の末尾）にある場合、
`C-x ='は、ポイントの直後の文字に関する情報は表示しません。
出力はつぎのようになります。

     point=26957 of 26956(100%)  column 0

`C-u C-x ='は、文字に関する追加情報、つまり、
文字集合名とその文字集合内でその文字を識別するコードを表示します。
ASCII文字は、文字集合`ASCII'に属するものと識別します。このコマン
ドは文字の構文やカテゴリ，バッファ内と保存時の文字コードも表示します．さらに，テキストプ
ロパティ(*Note Text Properties: (elisp)Text Properties.)やオーバーレイ(*Note Overlays: (elisp)Overlays.)も表示します．

コーディングシステムが `iso-2022-7bit' であるバッファ内にあるLatin-1の
アクサングレーブ付きの文字Aの例を示します。終端コードは`iso-latin-1'
(端末では実際 ``A' のように表示されます)であろ，font-lock-mode (*Note
Font Lock::) が有効になります．

         character: `A (04300, 2240, 0x8c0)
           charset: latin-iso8859-1
	       (Right-Hand Part of Latin Alphabet 1...
        code point: 64
            syntax: w	which means: word
          category: l:Latin
       buffer code: 0x81 0xC0
         file code: ESC 2C 41 40 (encoded by coding system iso-2022-7bit)
     terminal code: C0

     Text properties
       font-lock-face: font-lock-variable-name-face
       fontified: t



File: emacs-ja, Node: Arguments, Next: Repeating, Prev: Position Info, Up: Basic

数引数 *(2004/03/27)*
=====================

数学や計算機の用語では、"引数"（argument）という単語は『関数や操作に与
えるデータ』を意味します。Emacsのすべてのコマンドには、"数引数
（numeric argument）（"前置引数"（prefix argument）とも呼ぶ）を指定でき
ます。コマンドによっては、引数を反復回数として解釈します。たとえば、引
数10を`C-f'に指定すると、カーソルを通常の1文字ではなく、10文字分前向き
に移動します。これらのコマンドでは、引数を指定しないと引数1を指定したの
と同等になります。この種のコマンドの多くでは、負の引数を指定すると、逆
向きの移動や逆の操作を指示することになります。

端末のキーボードにMETAキーがある場合、数引数を入力するもっとも簡単な方
法は、METAキーを押し下げたままで、数字やマイナス記号を打ちます。たとえ
ば、
     M-5 C-n

は、カーソルを5行下に移動します。`Meta-1'、`Meta-2'、`Meta--'などの文字
がこのように動作するのは、これらのキーが、後続のコマンドに引数を与える
ように定義されたコマンド（`digit-argument'と`negative-argument'）にバイ
ンドされているからです。数字なしで `Meta--' とすると普通 -1を意味します．
コントロールやコントロールとメタで修飾した数字と`-'も、同様に数引数を指
定します。

引数を指定する別の方法は、`C-u'（`universal-argument'）コマンドに続けて
引数の数字を入力することです。`C-u'では、修飾キーを押し下げ続けることな
く引数の数字を打てます。`C-u'はすべての端末で使えます。負の引数を指定す
るには、`C-u'のあとにまずマイナス記号を打ちます。マイナス記号だけだ
と-1を意味します。

`C-u'のあとに数字でもマイナス記号でもない文字を打つと、
『4倍する』という特別な意味になります。
つまり、後続のコマンドに渡す引数を4倍します。
`C-u'を2回打つと、引数を16倍します。
したがって、`C-u C-u C-f'は、カーソルを前向きに16文字分移動します。
16文字は通常の画面で約1/5行に相当するので、
カーソルを『速く』移動させたい場合に便利な方法です。
便利な他の組み合せは、
`C-u C-n'や`C-u C-u C-n'（画面の下方への移動に便利）、
`C-u C-u C-o'（『数多く』の空行を作る）、
`C-u C-k'（4行キルする）です。

コマンドによっては、引数の値ではなく、引数の有無だけを問題にします。
たとえば、コマンド`M-q'（`fill-paragraph'）に引数を指定しないと
テキストの詰め込みのみを行います。
引数を指定すると、さらに幅揃えも行います。
（`M-q'に関する詳細は、*Note Filling::。）
`C-u'だけを使えば、このようなコマンドに簡単に引数を指定できます。

引数の値を反復回数として使うにも関わらず、引数がないと特別な動作をする
コマンドもあります。たとえば、`C-k'（`kill-line'）に引数Nを指定すると、
行区切りの改行も含めてN行をキルします。これに対し、引数を指定しない場合
は特別な動作となります。つまり、つぎの改行文字までのテキストをキルする
か、行末にポイントがある場合は改行そのものをキルします。したがって、引
数を指定せずに`C-k'を2回実行すると、引数1を指定した`C-k'と同様に、空行
でない1行をキルします。（`C-k'の詳細については、*Note Killing::。）

いくつかのコマンドは、`C-u'だけの引数を通常の引数とは異なるものとして扱
います。また、マイナス記号のみの引数を-1と区別するコマンドもあります。
これらの例外については、必要になったときに説明します。これらの例外は、
それぞれのコマンドを使いやすくするためにあります。

数引数を使って、文字のコピーを複数個挿入することもできます。この操作は、
数字以外の文字ならば簡単です。たとえば、`C-u 6 4 a'で、文字`a'を64個挿
入できます。しかし、数字では機能しません。`C-u 6 4 1'は、引数が641であ
ることを意味し、何も挿入しません。引数と挿入したい数字を区切るには、も
う1つ`C-u'を打ちます。たとえば、`C-u 6 4 C-u 1'で、数字`1'を64個挿入で
きます。

コマンドのまえに引数を打つということを強調するために、また、コマンドの
あとのミニバッファ引数と区別するために、『数引数』と同様に用語『前置引
数』を使います。



File: emacs-ja, Node: Repeating, Prev: Arguments, Up: Basic

コマンドを繰り返す *(2004/03/27)*
=================================

単純なキーや `M-x COMMAND-NAME RET' で実行できるような多くのコマンドは
数引数で繰り返し回数(*Note Arguments::)を与えることでその回数だけ繰り返
すことができます．しかし，いくらかの入力が必要なコマンドや引数を必要と
するコマンドでは数引数で繰り返し回数を与えることには問題があります．

コマンド`C-x z'（`repeat'）は、Emacsコマンドを何回も反復する別の方法で
す。このコマンドは、直前のEmacsコマンドが何であっても、それを繰り返しま
す。繰り返されるコマンドは、まえと同じ引数を使います。毎回、新たに引数
を読むことはしません。

コマンドを2回以上繰り返すには、`z'を追加して打ちます。1つの`z'で、コマ
ンドを1回繰り返します。`z'以外の文字を打つか、マウスボタンを押すと、繰
り返しを終了します。

たとえば、20文字削除するために`C-u 2 0 C-d'と打ったとしましょう。`C-x
z z z'と打てば、（引数を含めて）削除コマンドをさらに3回繰り返し、全部で
80文字削除できます。始めの`C-x z'でコマンドを1回繰り返し、そのあとのそ
れぞれの`z'で1回ずつ繰り返します。



File: emacs-ja, Node: Minibuffer, Next: M-x, Prev: Basic, Up: Top

ミニバッファ *(2005/05/02)*
***************************

"ミニバッファ"は、単純な数よりも複雑な引数をEmacsコマンドが読み取るため
に用いる機構です。ミニバッファ引数は、ファイル名、バッファ名、Lisp関数
名、Emacsコマンド名、Lisp式など、引数を読み取るコマンドに応じて多種多様
です。ミニバッファでは、通常のバッファと同様の編集機能を用いて引数のテ
キストを編集できます。

ミニバッファが使われているときには、ミニバッファはエコー領域に表示され
て、端末のカーソルもエコー領域に移動します。ミニバッファの行の先頭には
プロンプト"（prompt）が表示されます。プロンプトにより、何を入力しそれが
どのように使われるかを知ることができます。プロンプトは、引数を要求して
いるコマンドの名前から導かれることが多いです。プロンプトは通常コロンで
終ります。

コロンのあとの括弧の中に"デフォルト引数"（default argument）が表示され
ることもあります。これもプロンプトの一部です。（たとえば、RETだけを打っ
て）空の引数を入力したときには、デフォルトが引数として使われます。たと
えば、バッファ名を読み取るコマンドは、つねに、デフォルトを表示しますが、
それはRETだけを打ったときに使われるバッファ名です。

ミニバッファ引数を入力するもっとも簡単な方法は、目的のテキストを入力し
てから、ミニバッファから抜けるRETで終えることです。`C-g'を打てば、引数
を必要とするコマンドを取り消して、ミニバッファを抜けることができます。

ミニバッファは画面のエコー領域を使うため、習慣的にエコー領域を使用する
Emacsの機能と衝突する可能性があります。Emacsは、そのような衝突を以下の
ように扱います。

   * ミニバッファを使用中にコマンドがエラーを起こしても、ミニバッファを
     取り消すことはない。しかしながら、エラーメッセージを表示するために
     エコー領域が必要なので、しばらくのあいだミニバッファを隠す。数秒経
     過するか、何かを打つと、ただちにミニバッファを表示する。

   * `C-x ='のように、エコー領域にメッセージを表示するコマンドをミニバッ
     ファで実行すると、メッセージはしばらくのあいだミニバッファを隠す。
     数秒経過するか、何かを打つと、ただちにミニバッファを表示する。

   * ミニバッファを使用中は、キー入力をエコーしない。

* Menu:

* File: Minibuffer File.  Entering file names with the minibuffer.
* Edit: Minibuffer Edit.  How to edit in the minibuffer.
* Completion::		  An abbreviation facility for minibuffer input.
* Minibuffer History::    Reusing recent minibuffer arguments.
* Repetition::		  Re-executing commands that used the minibuffer.



File: emacs-ja, Node: Minibuffer File, Next: Minibuffer Edit, Prev: Minibuffer, Up: Minibuffer

ファイル名入力用のミニバッファ *(2005/03/24)*
=============================================

最初からテキストを伴って始まるミニバッファもあります。たとえば、ファイ
ル名を指定しなければならない場合、ミニバッファはスラッシュで終る"デフォ
ルトディレクトリ" （default directory）を含んでいます。これにより、ディ
レクトリを指定しなくても、どのディレクトリからファイルを探すかわかりま
す。

たとえば、ミニバッファがつぎのような内容で始まったとしましょう。

     Find File: /u2/emacs/src/

ここで、`Find File: 'がプロンプトです。
`buffer.c' と打てば、
ファイル`/u2/emacs/src/buffer.c'を指定したことになります。
付近のディレクトリのファイルを指定するには、`..'を使います。
したがって、`../lisp/simple.el'と打てば、
`/u2/emacs/lisp/simple.el'という名前のファイルになります。
あるいは、不要なディレクトリ名であれば、
`M-DEL'でキルできます（*Note Words::）。

デフォルトディレクトリをまったく使いたくない場合は、`C-a C-k'と打ってキ
ルできます。しかし、デフォルトをキルする必要はありません。単に無視すれ
ばよいのです。スラッシュやティルダで始まる絶対ファイル名を挿入します。
たとえば、ファイル`/etc/termcap'を指定するには、そのファイル名を挿入し
て、ミニバッファがつぎの内容になるようにします。

     Find File: /u2/emacs/src//etc/termcap

GNU Emacsでは、（普通は意味のある書き方ではない）
連続した2個のスラッシュに特別な意味を与えています。
『2番目のスラッシュよりまえの文字はすべて無視する』という意味になります。
したがって、先の例では、`/u2/emacs/src/'は無視され、
`/etc/termcap'というファイル名になります。

`insert-default-directory'に`nil'を設定すると、ミニバッファにはデフォル
トディレクトリを挿入しません。つまり、ミニバッファは空で始まります。し
かし、入力したファイル名が相対的なものであれば、同じデフォルトディレク
トリ相対に解釈されます。



File: emacs-ja, Node: Minibuffer Edit, Next: Completion, Prev: Minibuffer File, Up: Minibuffer

ミニバッファでの編集 *(2005/03/24)*
===================================

ミニバッファは（少々特殊だが）普通のEmacsバッファなので、通常のEmacsコ
マンドを使って、入力中の引数のテキストを編集できます。

ミニバッファでは、RETはミニバッファから抜けるように定義されているので、
ミニバッファで改行を挿入するためにRETを使うことはできません。改行を挿入
するには、`C-o'や`C-q C-j'とします。（改行とは実は文字「コントロール
J」。）

ミニバッファには独自のウィンドウがあり、
そのウィンドウは画面上の場所を占有しています。
しかし、ミニバッファが使われていないときには、
あたかも何もないかのようにふるまいます。
ミニバッファが使われているときは、
そのウィンドウは他のウィンドウと同様になります。
ミニバッファで引数を入力し終えるまでは、
`C-x o'で他のウィンドウに切り替えて、
そこでテキストを編集したり他のファイルを訪問したりもできます。
他のウィンドウでテキストをキルしてから、
ミニバッファウィンドウに戻ってそのテキストを
ヤンクして引数として使うこともできます。
*Note Windows::。

しかし、ミニバッファウィンドウの使用にはいくつかの制限があります。ミニ
バッファウィンドウではバッファを切り替えられません。ミニバッファとその
ウィンドウは恒久的に結び付いています。また、ミニバッファウィンドウを分
割したり消去したりすることもできません。しかし、`C-x ^'を使う通常の方法
で、ウィンドウの高さを大きくすることは可能です。

もし `resize-mini-windows' が非-`nil' であれば，ミニバッファに入力した
テキストを表示するのに必要なだけ、ミニバッファウィンドウは縦に広がりま
す。`resize-mini-windows' が `t' であれば，ミニバッファウィンドウは表示
するテキストのサイズに合わせて，常に調節されます．
`resize-mini-windows' が`grow-only' であれば，ミニバッファに表示するテ
キストが増えた時だけ広がり，不活性になった時にだけ縮みます(通常のサイズ
に戻ります)．

変数 `max-mini-window-height' でミニバッファの最大高さを制御できます．
小数点で指定すると，フレームの高さに対するミニバッファの高さの比になり
ます．整数で指定すると，最大の行数になります．`nil' では，自動的にミニ
バッファを調整しないことを意味します．デフォルトは 0.25 です

ミニバッファの中で別のウィンドウにある種のヘルプテキストを
表示するようなコマンドを実行したときには、
`C-M-v'を使って
ミニバッファの中からヘルプテキストをスクロールできます。
これは、ミニバッファを抜けるまで有効です。
この機能は、補完をしているミニバッファが、
補完候補を別のウィンドウに表示するような場合に特に便利です。
*Note Other Window::。

Emacsでは、通常、ミニバッファを使っている最中には、ミニバッファを用いる
コマンドの多くを実行できないようにしています。これは、再帰的なミニバッ
ファの使用で初心者が混乱するのを避けるためです。このようなコマンドをミ
ニバッファから利用できるようにするには、変数
`enable-recursive-minibuffers'に`nil'以外を設定します。



File: emacs-ja, Node: Completion, Next: Minibuffer History, Prev: Minibuffer Edit, Up: Minibuffer

補完 *(2005/03/24)*
===================

ある種の引数では、引数の値の入力に"補完"（completion）を利用できます。
補完とは、引数の一部分を打つと、Emacsがその残りの部分をすべて、あるいは
既存の入力部分から決定可能な限り残りの部分を補う機能です。

補完を使えるときには、TAB、RET、SPCの各キーは、
ミニバッファ内のテキストをそれを含むより長い文字列に
ポイントの前に補完するように再定義してあります。
補完は、引数を読み取るコマンドが用意した
"補完候補"群（completion alternatives）に対して
入力されたテキストとの一致をとることで行われます。
`?'キーは、入力から補完可能な候補一覧を表示するように定義してあります。

たとえば、`M-x'がコマンド名を読み取るためにミニバッファを使っている場合、
`M-x'は、補完に備えて、
使用可能なすべてのEmacsコマンド名の一覧を用意します。
補完キーは、ミニバッファのテキストをすべてのコマンド名に照らし合わせて、
ミニバッファの既存の名前から導かれる名前の追加文字列を探し出して、
その文字列をそれまでに入力してあるテキストに付け加えます。
これにより、`M-x insert-buffer RET'と打つかわりに、
`M-x ins SPC b RET'と打つことが可能になるのです。

補完では、大文字小文字を区別します。というのは、補完対象となる名前（バッ
ファ名、ファイル名、コマンド名）のほとんどでは、大文字小文字を区別して
いるからです。したがって、`fo'を、`Foo'とは補完しません。大文字小文字を
区別しない引数に対しては、補完も両者を区別しません。

* Menu:

* Example: Completion Example.
* Commands: Completion Commands.
* Strict Completion::
* Options: Completion Options.



File: emacs-ja, Node: Completion Example, Next: Completion Commands, Prev: Completion, Up: Completion

補完の例
--------

具体的な例で考えてみましょう。`M-x au TAB'と打つと、TABは`au'で始まる候
補（この場合はコマンド名）を探します。`au'で始まるものには、
`auto-fill-mode'と`auto-save-mode'を含めていくつかありますが、どれも少
なくとも`auto-'までは同じです。そこで、ミニバッファ内の`au'は`auto-'に
変わります。

ここでただちにTABをもう一度打っても、つぎにくる文字の候補が複数、つまり、
`cfilrs'のどれかなので、さらに文字が追加されることはありません。そのか
わり、TABは補完候補の一覧を別のウィンドウに表示します。

続けて`f TAB'と打つと、今度のTABは文字列`auto-f'を探します。`auto-f'か
ら始まるコマンド名は`auto-fill-mode'だけなので、補完は残りの部分を補い
ます。これで、`au TAB f TAB'と打つだけで、ミニバッファには
`auto-fill-mode'が入ります。TABキーがこのような効果を持つのは、このキー
がミニバッファ内ではコマンド`minibuffer-complete'にバインドしてあるから
だということに注意してください。



File: emacs-ja, Node: Completion Commands, Next: Strict Completion, Prev: Completion Example, Up: Completion

補完コマンド *(2005/03/24)*
---------------------------

補完を使えるミニバッファでは、つぎのような補完コマンドを定義してありま
す。

`TAB'
     ミニバッファのテキストを可能な限りポイントの前に補完する
     （`minibuffer-complete'）。
`SPC'
     ミニバッファのテキストを1語だけポイントの前に補完する
     （`minibuffer-complete-word'）。
`RET'
     可能な限り補完したあと、ミニバッファのテキストを引数として渡す
     （`minibuffer-complete-and-exit'）。
`?'
     ミニバッファのテキストから補完可能な候補の一覧を表示する
     （`minibuffer-list-completions'）。

SPCはTABとほぼ同じように補完しますが、つぎのハイフンや空白を超えて補完
することはありません。ミニバッファの文字が`auto-f'であるとしましょう。
ここでSPCを打つと、SPCは`auto-fill-mode'に補完できることを探しだします
が、`fill-'までで補完を止めます。その結果、`auto-fill-'となります。ここ
でもう一度SPCを打つと、今度は`auto-fill-mode'まで完全に補完します。この
ような振舞いをするコマンドは `minibuffer-complete-word' を実行していま
す。

補完候補一覧を表示しているウィンドウから補完を選ぶには、つぎのコマンド
を使えます。

`Mouse-2'
     補完候補一覧の候補上でマウスボタン2をクリックすると、その補完を選
     択する（`mouse-choose-completion'）。通常は、ポイントがミニバッファ
     内にあるときにこのコマンドを使うだろうが、ミニバッファではなく候補
     一覧でクリックする必要がある。

`PRIOR'
`M-v'
     ミニバッファで、PRIOR、PAGE-UP、`M-v'のいずれかを打つと、補完候補
     一覧のバッファを表示しているウィンドウを選択できる
     （`switch-to-completions'）。この機能は、以下のコマンドの利用を簡
     単にする。（通常の方法でもそのウィンドウを選択できるが、この方法の
     ほうが便利であろう。）

`RET'
     *補完候補一覧のバッファで*RETを打つと、ポイント位置にある補完かポ
     イントに続く補完を選択する（`choose-completion'）。このコマンドを
     使う場合、補完候補一覧を表示しているウィンドウにまず移動する必要が
     ある。

`RIGHT'
     *補完候補一覧のバッファで*右向き矢印キーRIGHTを打つと、ポイントは
     つぎの補完候補に移動する（`next-completion'）。

`LEFT'
     *補完候補一覧のバッファで*左向き矢印キーLEFTを打つと、ポイントはま
     えの補完候補に移動する（`previous-completion'）。



File: emacs-ja, Node: Strict Completion, Next: Completion Options, Prev: Completion Commands, Up: Completion

強い補完
--------

ミニバッファでの補完において、
RETは引数の使われ方に依存して3種類の異なる動作を示します。

   * "強い"補完（strict completion）は、既知の補完候補以外を引数に与え
     ると意味がない場合に使われる。たとえば、`C-x k'が削除するバッファ
     名を読み取るとき、既存のバッファ名以外を与えても意味がない。強い補
     完では、ミニバッファのテキストを補完して候補の1つに完全に一致しな
     いとRETで終了できない。

   * "慎重な"補完（cautious completion）は、強い補完に似ているが、テキ
     ストがすでに完全に一致していて補完の必要がない場合にのみ、RETで終
     了できる点が異なる。テキストが完全に一致していない場合は、RETは終
     了せずにテキストを補完する。完全に一致すれば、2度目のRETで終了でき
     る。

     慎重な補完は、既存でなければならないファイルの名前を読み取るような
     場合に使われる。

   * "弱い"補完（permissive completion）は、どんな文字列でも意味を持つ
     ような場合に使われ、補完候補一覧は単なる目安でしかない。たとえば、
     `C-x C-f'が訪問するファイル名を読み取るとき、新規作成ならばどんな
     ファイル名でも許される。弱い補完では、RETはミニバッファのテキスト
     を補完することなく、そのまま受理する。

補完コマンドは、つぎにくる文字として複数の可能性がある場合、
補完可能な全候補一覧をウィンドウに表示します。
また、`?'と打てば、このような一覧を表示できます。
補完候補一覧が長いときには、
`C-M-v'でスクロールできます（*Note Other Window::）。



File: emacs-ja, Node: Completion Options, Prev: Strict Completion, Up: Completion

補完のオプション *(2005/03/24)*
-------------------------------

ファイル名の補完を行う場面では、ある種のファイル名を通常無視します。変
数`completion-ignored-extensions'は、文字列のリストを保持します。これら
の文字列の1つで終る名前のファイルは、補完候補としては無視します。この変
数の標準値には、`".o"'、`".elc"'、`".dvi"'、`"~"'が含まれます。この効果
は、たとえば、`foo'は、`foo.o'が存在したとしても、`foo.c'に補完されます。
ただし、補完候補の*すべて*が無視すべき文字列で終るものである場合には、
これらの候補を無視しません。無視した拡張子を持つものが補完候補一覧に入
ることはありません。一覧にはつねに補完可能な候補のすべてを表示します。

もし `completion-ignored-extensions' のリストの要素がスラッシュ `/' で
終わっていれば，名前を補完する時にサブディレクトリが無視されるべきであ
るという意味になります(スラッシュで終わっていない
`completion-ignored-extensions' の要素は，補完候補がディレクトリである
時には考慮されない．したがって，たとえリストに`".elc"' という要素があっ
ても，`.elc' で終わる名前を持つディレクトリが補完候補に入ることになりま
す)．

通常、補完コマンドは、次の1文字を決定できない場合には、自動的にすべての
補完候補一覧を表示します。変数`completion-auto-help'に`nil'が設定されて
いると、補完候補の自動表示はされません。このため，補完候補を表示するた
めに、`?'を打つ必要があります．

分割補完(Partial Completion)は、平行して複数の単語を補完できる、より強
力な補完機能を提供します。たとえば、`p-b'と省略されたコマンド名を
`print-buffer'と補完できます。というのは、頭文字が`p'と`b'である2つの単
語で始まるコマンドが他にはないからです。

ディレクトリの分割補完では補完する場所を示すために， `*' を使います．例えば，
`/u*/b*/f*' は `/usr/bin/foo' のように補完されるかもしれません．

このモードを有効にするためには，コマンド `M-x partial-completion-mode'
を使うか，変数 `partial-completion-mode' をカスタマイズします．すると，
TAB，SPC，RET，`?' を分割補完機能に割り当てます．通常の補完は `M-TAB'，
`M-SPC'，`M-RET'，`M-?'で利用できます．

分割補完モードの他の機能は `find-file' を拡張することです．それにより，
`<INCLUDE>' は `PC-include-file-path' で設定されたディレクトリにある
INCLUDE という名前のファイルを表します．もし`PC-disable-includes' を
非-`nil'に設定していれば，この機能は無効になります．

補完示唆（icomplete）モードでは、それまでに入力したテキストから補完でき
るものを常時更新して表示します。このマイナモードをオン／オフするコマン
ドは`M-x icomplete-mode'です。



File: emacs-ja, Node: Minibuffer History, Next: Repetition, Prev: Completion, Up: Minibuffer

ミニバッファ履歴 *(2005/05/02)*
===============================

ミニバッファで入力した引数はすべて"ミニバッファ履歴リスト"
（minibuffer history list）に保存され、あとで別の引数中で使うことができ
ます。特別のコマンドで、以前に使った引数のテキストをミニバッファに入れ
ます。これらは、ミニバッファの古い内容を破棄するので、過去の引数の履歴
の中を動き廻っていると考えることができます。

`UP'
`M-p'
     ミニバッファ履歴中の1つまえ（古い）の引数文字列に移動する
     （`previous-history-element'）。
`DOWN'
`M-n'
     ミニバッファ履歴中の1つつぎ（新しい）の引数文字列に移動する
     （`next-history-element'）。
`M-r REGEXP RET'
     ミニバッファ履歴中の引数文字列を古いほうへ遡ってREGEXPに一致するも
     のに移動する（`previous-matching-history-element'）。
`M-s REGEXP RET'
     ミニバッファ履歴中の引数文字列を新しいほうへ辿ってREGEXPに一致する
     ものに移動する（`next-matching-history-element'）。

履歴リストに保存されている引数を再利用するもっとも簡単な方法は、
履歴リストの中を1つ1つ移動していくことです。
ミニバッファの中では、1つまえ（古い）のミニバッファの入力内容に
『移動する』には`M-p'（`previous-history-element'）を、
1つあと（新しい）の入力内容に移動するには
`M-n'（`next-history-element'）を打ちます。

ミニバッファの内容は、履歴から持ってきた以前の入力内容で完全に置き換え
られます。この内容を引数として使うには、通常と同じようにRETでミニバッファ
を抜けます。引数として再使用するまえに、テキストを編集してもかまいませ
ん。編集してもミニバッファに『持ってきた』履歴のもともとの要素は変更さ
れません。ただし、当然、新しい引数は履歴リストの最後に追加されます。

多くのミニバッファ引数には、デフォルト値があります。ミニバッファ履歴操
作コマンドが、これらのデフォルト値を知っている場合もあります。その場合、
`M-n'で履歴中の『未来』へ移動する (1) (*Note Minibuffer
History-Footnotes::) ことで、このデフォルト値をテキストとしてミニバッファ
に挿入できます。将来的には、ミニバッファにデフォルト値がある場合には、
つねにこの機能を利用できるようにしたいと考えています。

履歴の中を前向きや後向きに探索するコマンドもあります。これらのコマンド
は、ミニバッファで指定した正規表現に一致する履歴要素を探索します。
`M-r'（`previous-matching-history-element'）は、履歴のより古い要素を探
します。一方、`M-s'（`next-matching-history-element'）は、より新しい要
素を探します。特例なのですが、これらのコマンドは、コマンドを呼び出す時
点ですでにミニバッファに入っているにも関わらず、ミニバッファから引数を
読み取ります。インクリメンタルサーチの場合と同様に、正規表現に大文字を
使うと、大文字小文字を区別して探索します（*Note Search Case::）。


ミニバッファを使えば入力は必ず履歴リストに記録されますが、引数の種類ご
とに別々の履歴リストがあります。たとえば、ファイル名に関する履歴リスト
は、ファイル名を読み取るすべてのコマンドで使われます。（特別な機能とし
て、この履歴リストには、絶対ファイル名を入力しなくても絶対ファイル名が
記録される。）

特定目的用の履歴リストがいくつかあります。`M-x'が読むコマンド名用、バッ
ファ名用、`query-replace'のようなコマンドの引数用、`compile'が読むコン
パイルコマンド用などです。さらに、ほとんどのミニバッファ引数が利用する
『その他』の履歴リストも1つあります。

変数`history-length'は、ミニバッファ履歴リストの最大長を指定します。履
歴リストが設定された長さに達すると、そのあとは、新しい要素を追加するた
びに最古の要素を削除します。ただし、変数`history-length'の値が`t'である
と、長さの制限はなくなり要素を削除しません。


File: emacs-ja  Node: Minibuffer History-Footnotes, Up: Minibuffer History

(1) 【訳注】履歴として残っている文字列データの最後尾よりさらに先に移動
すること。



File: emacs-ja, Node: Repetition, Prev: Minibuffer History, Up: Minibuffer

ミニバッファコマンドの繰り返し *(2005/05/02)*
=============================================

ミニバッファを少なくとも1回使ったコマンドは、その引数の値とともにすべて
特別な履歴リストに記録されますから、コマンド全体を繰り返すことができま
す。特に、`M-x'はコマンド名を読み取るためにミニバッファを使うので、必ず
履歴に記録されます。

`C-x ESC ESC'
     最近のミニバッファコマンドを再実行する（`repeat-complex-command'）。
`M-x list-command-history'
     `C-x ESC ESC'で繰り返せるすべてのコマンドを新しいものから順に並べ
     たコマンド履歴全体を表示する。

`C-x ESC ESC'は、ミニバッファを利用した最近のコマンドを再度実行します。
引数を指定しなければ、そのような最後のコマンドを繰り返します。数引数は、
どのコマンドを繰り返すかを指定します。1は最後のコマンドを指し、大きい数
ほどより以前のコマンドを指します。

`C-x ESC ESC'は、過去のコマンドをLisp式に変換し、その式のテキストで初期
化したミニバッファに入ります。RETだけを打てば、コマンドは以前とまったく
同様に繰り返されます。Lisp式を編集してコマンドを変更してもかまいません。
最終的な式が何であれ、その式を実行します。繰り返したコマンドは、履歴リ
スト内に既存の最後に実行したコマンドと同一でない限り、コマンド履歴の先
頭に追加されます。

Lisp構文が理解できないとしても、繰り返しのためにどのコマンドが表示され
たか、たぶんわかるでしょう。テキストを変更しなければ、以前とまったく同
じに繰り返されます。

`C-x ESC ESC'でいったんミニバッファに入ってしまえば、ミニバッファ履歴リ
ストコマンド（`M-p'、`M-n'、`M-r'、`M-s'、*Note Minibuffer History::）
を使って、保存されたすべてのコマンドの履歴リストの中を動き廻れます。目
的のコマンドを捜しあてたら、通常の方法でその式を編集できますし、これも
通常と同じようにRETを打てば実行できます。

インクリメンタルサーチは，厳密に言うと，ミニバッファを使いません．しかし，大抵は
複合されたコマンドとして使われるので，似たような動作をします．そして，そのコマン
ドは `C-x ESC ESC' で利用できる履歴に追加されます．
`isearch-resume-enabled' を `nil' にすることで，これを無効化できます．

ミニバッファを使った過去のコマンド一覧は、
Lispのリストとして変数`command-history'に格納されます。
各要素はそれぞれ1つのコマンドとその引数を表すLisp式です。
Lispプログラムからは、
`command-history'の要素を引数として
`eval'を呼べばコマンドを再実行できます。



File: emacs-ja, Node: M-x, Next: Help, Prev: Minibuffer, Up: Top

名前でコマンドを実行する方法 *(2004/01/15)*
*******************************************

Emacs のコマンドにはすべて名前があります。そして、使用頻度の高いコマン
ドや素早い打鍵が必要なEmacsコマンドは、使い勝手をよくするために、キー
（文字の短い列）にもバインドしてあります。もちろん、キーバインドを思い
出せなければ名前を打つことで起動できます。素早い打鍵が必要でないその他
のEmacsコマンドはキーにバインドしてありません。したがって、これらのコマ
ンドを実行する唯一の方法は、コマンド名を使うことです。キーに割り当てる
場合には *Note Key Bindings:: を参照してください。

慣習として、コマンド名は1単語かハイフンで区切った2語以上の単語からでき
ています。たとえば、`auto-fill-mode'や`manual-entry'です。たとえ打鍵文
字数が多くなったとしても、（意図が）不明瞭な文字数個をキーとして使うよ
りも、英単語をコマンド名として使うほうが覚えやすいのです。

コマンドをその名前で実行するには、`M-x'で始めて、コマンド名を打ち込み、
RETで終えます。`M-x'は、コマンド名を読むためにミニバッファを使います。
RETキーはミニバッファを抜けてコマンドを実行します。このとき、"プロンプ
ト"として文字列`M-x'をミニバッファの先頭に表示して、実行するコマンド名
を入力しなければならないことをユーザーに示します。ミニバッファの詳細に
ついては、*Note Minibuffer::。

コマンド名の入力には、補完を使えます。たとえば、つぎのように打って、コ
マンド`forward-char'を起動できます。

     M-x forward-char RET

あるいは、

     M-x forw TAB c RET

とします。
ここで、`forward-char'は、
`C-f'キーで起動されるコマンドと同じです。
コマンドがキーにバインドしてあるかどうかに関わらず、
`M-x'ですべてのEmacsコマンドを名前で起動できます。

コマンド名を入力中に`C-g'を打つと、`M-x'コマンドを取り消してミニバッファ
から抜け出し、最終的にはトップレベルに戻ります。

`M-x'で起動するコマンドに数引数を渡すには、`M-x'を打つまえに、数引数を
指定します。`M-x'は、実行する関数に引数を渡します。引数の値は、コマンド
名を読み込んでいるあいだ、プロンプトに表示されます。

入力したコマンドに専用のキーバインドがある場合には、Emacsはその旨エコー
領域に表示します。この表示は、コマンドの実行が終了したあと、2秒間表示さ
れます（すぐに何かを打てば、この限りではない）。たとえば、コマンド`M-x
forward-word'を入力した場合、`M-f'と打ったほうが簡単に同じコマンドを実
行できるという意味のメッセージが表示されます。`suggest-key-bindings'に
`nil'を設定すれば、これらのメッセージ表示をオフにできます。

本書では、名前で実行するコマンドの説明において、
名前を終えるために必要なRETを省略します。
つまり、`M-x auto-fill-mode RET'ではなく、
`M-x auto-fill-mode'とします。
コマンド名に続く引数も示す場合のように、
RETが必要なことを強調する場合にのみ、
RETを書きます。

`M-x'は、`execute-extended-command'を実行することで動作します。
`execute-extended-command'は、他のコマンドの名前を読み取って、それを実
行する役割を担うコマンドです。



File: emacs-ja, Node: Help, Next: Mark, Prev: M-x, Up: Top

ヘルプ機能
**********

Emacsには、`C-h'のたった1文字で呼び出せる高度なヘルプ機能があります。
`C-h'は、説明文表示コマンドのためだけに使われるプレフィックスキーです。
`C-h'のあとに打つ文字（列）を"ヘルプオプション"（help options）と呼びま
す。`C-h'もヘルプオプションの1つであって、`C-h'の使い方を調べることがで
きます。途中で取り消すには、`C-g'を打ちます。ファンクションキーF1は、
`C-h'と等価です。

`C-h C-h'（`help-for-help'）は、
利用可能なヘルプオプションの一覧を簡素な説明とともに表示します。
ヘルプオプションを打つまでは、
SPCやDELで一覧をスクロールできます。

`C-h'やF1は、他のさまざまな状況でも『ヘルプ』を意味します。たとえば、
`query-replace'の実行中には、今一致している文字列に対して適用可能な操作
を説明します。プレフィックスキーに続けて`C-h'やF1を打つと、そのプレフィッ
クスキーに続けることができるキーの一覧を表示します。（`C-h'に独自の意味
を定義しているプレフィックスキーもあり、そのような場合には`C-h'を使えな
い。しかし、F1はすべてのプレフィックスキーで使える。）

ほとんどのヘルプバッファでは、特別なメジャーモードである
ヘルプ（help）モードを使います。
ヘルプ（help）モードでは、
SPCとDELで画面を簡単にスクロールできます。

* Menu:

* Help Summary::	Brief list of all Help commands.
* Key Help::		Asking what a key does in Emacs.
* Name Help::		Asking about a command, variable or function name.
* Apropos::		Asking what pertains to a given topic.
* Library Keywords::	Finding Lisp libraries by keywords (topics).
* Language Help::       Help relating to international language support.
* Help Mode::           Special features of Help mode and Help buffers.
* Misc Help::		Other help commands.



File: emacs-ja, Node: Help Summary, Next: Key Help, Prev: Help, Up: Help

ヘルプのまとめ
==============

定義されているヘルプコマンドを以下にまとめておきます。

`C-h a REGEXP RET'
     正規表現REGEXPに一致する名前を持つコマンドの一覧を表示する
     （`apropos-command'）。
`C-h b'
     現在有効なすべてのキーバインドの一覧を、マイナモードのバインディン
     グ、メジャーモードのバインディング、グローバルバインディングの順に
     表示する（`describe-bindings'）。
`C-h c KEY'
     KEYが実行するコマンドの名前を表示する（`describe-key-briefly'）。
     ここで、`c'は『character』（文字）のcのこと。
     KEYのさらに詳しい情報を得るには、`C-h k'を使う。
`C-h f FUNCTION RET'
     Lisp関数FUNCTIONの説明文を表示する（`describe-function'）。コマン
     ドはLisp関数なので、コマンド名も使える。
`C-h h'
     さまざまな文字集合の例文を例示する`hello'ファイルを表示する。
`C-h i'
     ドキュメントファイルを閲覧するプログラム、infoを起動する（`info'）。
     infoでは、完全なEmacsマニュアルをオンラインで見ることができる。
`C-h k KEY'
     KEYが実行するコマンドの名前と説明文を表示する（`describe-key'）。
`C-h l'
     これまでに打鍵した最後の100文字を表示する（`view-lossage'）。
`C-h m'
     現在のメジャーモードの説明文を表示する（`describe-mode'）。
`C-h n'
     Emacsの変更点に関する説明を最新のものから順に表示する
     （`view-emacs-news'）。
`C-h p'
     トピックのキーワードで、一致するパッケージを探す
     （`finder-by-keyword'）。
`C-h s'
     現在の構文テーブルとその意味の説明を表示する
     （`describe-syntax'）。
     *Note Syntax::。
`C-h t'
     Emacsの対話型のチュートリアルに入る（`help-with-tutorial'）。
`C-h v VAR RET'
     Lisp変数VARの説明文を表示する（`describe-variable'）。
`C-h w COMMAND RET'
     コマンドCOMMANDを実行するキーを表示する（`where-is'）。
`C-h C CODING RET'
     コーディングシステムCODINGを説明する（`describe-coding-system'）。
`C-h C RET'
     現在使用中のコーディングシステムを説明する。
`C-h I METHOD RET'
     入力方式を説明する（`describe-input-method'）。
`C-h L LANGUAGE-ENV RET'
     言語環境LANGUAGE-ENVにおいて使われる、文字集合、コーディングシステ
     ム、入力方式を説明する（`describe-language-environment'）。
`C-h C-c'
     GNU Emacsのコピーライトを表示する。
`C-h C-d'
     GNU Emacsの新版の入手方法に関する情報を表示する。
`C-h C-f FUNCTION RET'
     infoに入って、Emacsの関数FUNCTIONを説明しているノードに移動する
     （`Info-goto-emacs-command-node'）。
`C-h C-k KEY'
     infoに入って、キー列KEYを説明しているノードに移動する
     （`Info-goto-emacs-key-command-node'）。
`C-h C-p'
     GNUプロジェクトに関する情報を表示する。
`C-h TAB SYMBOL RET'
     編集中のプログラム言語に応じて、シンボルSYMBOLに関するinfoドキュメ
     ントを表示する（`info-lookup-symbol'）。



File: emacs-ja, Node: Key Help, Next: Name Help, Prev: Help Summary, Up: Help

キーに関する説明
================

`C-h'のもっとも基本的なオプションは、
`C-h c'（`describe-key-briefly'）と
`C-h k'（`describe-key'）です。
`C-h c KEY'は、
KEYにバインドしてあるコマンド名をエコー領域に表示します。
たとえば、`C-h c C-f'と打てば`forward-char'と表示されます。
コマンド名はそのコマンドが何をするかを表すように選んでありますから、
キーKEYが何をするかをちょっと調べたい場合に、よい方法です。

`C-h k KEY'も同様ですが、より多くの情報を表示します。つまり、コマンドの
名前だけでなく、説明文も表示します。その内容はエコー領域に表示するには
多すぎるため、ウィンドウに表示します。

`C-h c'や`C-h k'は、ファンクションキーやマウスイベントも含めた、あらゆ
るキー列に適用できます。



File: emacs-ja, Node: Name Help, Next: Apropos, Prev: Key Help, Up: Help

コマンド名や変数名によるヘルプ表示
==================================

`C-h f'（`describe-function'）は、ミニバッファでLisp関数の名前を読み取
り、その関数の説明文字列をウィンドウに表示します。コマンドはLisp関数で
すから、名前を知っているコマンドであれば、その説明文を得ることができま
す。たとえば、

     C-h f auto-fill-mode RET

とすると、`auto-fill-mode'の説明文字列を表示できます。どのキーにもバイ
ンドしていない（つまり、通常`M-x'で起動する）コマンドの説明文字列を見る
には、この方法しかありません。

`C-h f'はまた、Lispプログラムの中で使おうと考えているLisp関数に対しても
有益です。たとえば、式`(make-vector len)'を書いたとしましょう。
`make-vector'を正しく使っているかどうか調べたいときには、`C-h f
make-vector RET'と打ちます。`C-h f'は、コマンド名だけでなく、すべての関
数名に適用できるので、普段`M-x'で使えている省略形が`C-h f'では使えない
かもしれません。ある省略形がコマンド名としては一意であったとしても、他
の関数名を含めてみると一意ではない場合もあります。

ミニバッファでRETだけを打ってミニバッファが空の場合、`C-h f'に与えられ
る関数名にはデフォルト値があります。デフォルト値は、バッファ内のポイン
ト周辺でもっとも内側のLisp式で呼び出される関数ですが、それが定義された
正しいLisp関数の名前である場合に*限ります*。たとえば、`(make-vector
(car x)'というテキストの直後にポイントがあると、ポイントを含むもっとも
内側のリストは`(make-vector'から始まる部分なので、デフォルトは関数
`make-vector'です。

`C-h f'は、関数名の綴りが正しことを
単に確認するためだけにも役立ちます。
`C-h f'がバッファ内の名前をデフォルトとして表示すれば、
その名前はLisp関数として定義されているはずです。
これだけを確認したいのであれば、
`C-g'を打って`C-h f'コマンドを取り消して、編集を続けます。

`C-h w COMMAND RET'は、
どのキーをCOMMANDにバインドしてあるかを表示します。
キーの一覧をエコー領域に表示します。
どのキーにも割り当てられていないと表示された場合は、
そのコマンドは`M-x'で起動する必要があります。
`C-h w'はコマンド`where-is'を実行します。

`C-h v'（`describe-variable'）は`C-h f'に似ていますが、
Lisp関数ではなくLisp変数を説明する点が異なります。
デフォルトはポイント周辺またはポイントの直前のLispシンボルですが、
既知のLisp変数に限ります。
*Note Variables::。



File: emacs-ja, Node: Apropos, Next: Library Keywords, Prev: Name Help, Up: Help

アプロポス
==========

より洗練された質問方法としては、『ファイルを扱うコマンドは？』というの
があります。このように質問するには、`C-h a file RET'と打ちます。すると、
`copy-file'や`find-file'といった、`file'を名前に含むすべてのコマンドの
一覧が表示されます。各コマンドには、使い方の簡単な説明やそのコマンドを
起動するキーが表示されます。たとえば、`find-file'を起動するには`C-x
C-f'と打つ、といった具合です。`C-h a'の`a'は「Apropos」（「適切な」の意
味）を表していて、`C-h a'はコマンド`apropos-command'を実行します。この
コマンドは、通常、コマンド（対話的な関数）のみを調べます。前置引数を指
定すれば、非対話的な関数も調べます。

`C-h a'は指定した文字列を名前に含む関数しか調べませんので、文字列の指定
には工夫が必要です。後向きに文字をキルするコマンドを探そうとして、`C-h
a kill-backwards RET'で何も表示されなくてもあきらめないでください。
`kill'のみ、あるいは`backwards'のみ、もしくは`back'のみを試して、続けて
ください。柔軟性を増すために、引数として正規表現も使えます（*Note
Regexps::）。

以下に、`C-h a'に指定する引数のうち、Emacsコマンドの多くの種類を網羅す
るものをあげておきます。というのは、Emacsコマンドの標準の命名法には強い
慣行があるからです。命名法の慣行を理解してもらえば、適切な（`apropos'）
文字列を拾い出す技法の向上の手助けにもなるでしょう。

     char、line、word、sentence、paragraph、region、page、sexp、list、
     defun、rect、buffer、frame、window、face、file、dir、register、
     mode、beginning、end、forward、backward、next、previous、up、down、
     search、goto、kill、delete、mark、insert、yank、fill、indent、
     case、change、set、what、list、find、view、describe、default。

正規表現に一致するすべてのユーザー変数を表示するには、コマンド`M-x
apropos-variable'を使います。このコマンドは、デフォルトでは、ユーザー変
数とカスタマイズオプションだけを表示します。すべての変数を調べるには、
前置引数を指定します。

コマンドとして定義されているものだけでなく、正規表現に一致するすべての
Lispシンボルを表示するには、`C-h a'のかわりに`M-x apropos'を使います。
このコマンドは、デフォルトでは、キーバインドを調べません。キーバインド
を調べるには、前置引数を指定します。

`apropos-documentation'コマンドは`apropos'に似ていますが、指定した正規
表現に一致するシンボル名だけでなく、説明文字列も探索する点が異なります。

`apropos-value'コマンドは`apropos'に似ていますが、指定した正規表現に一
致するシンボルの値を探す点が異なります。このコマンドは、デフォルトでは、
関数定義や属性リストを調べません。それらも調べるには、前置引数を指定し
ます。

変数`apropos-do-all'が`nil'以外ならば、上に述べたコマンドはすべて、前置
引数を指定したものとして動作します。

アプロポス（apropos）バッファに表示された関数定義、変数、属性リストにつ
いて詳しく知りたいときには、`Mouse-2'ボタンでクリックするか、その箇所へ
移動してRETを打ちます。



