Info file: emacs-ja,    -*-Text-*-
produced by `texinfo-format-buffer'
from file `emacs.texi'
using `texinfmt.el' version 2.41 of  1 Mar 2005.

INFO-DIR-SECTION Emacs
START-INFO-DIR-ENTRY
* Emacs-ja: (emacs-ja).	            Emacs21.3日本語マニュアル.
END-INFO-DIR-ENTRY








File: emacs-ja, Node: History References, Prev: Shell History Copying, Up: Shell History

シェル履歴の参照 *(2005/05/07)*
...............................

cshやbashをはじめ多くのシェルは、`!'や`^'で始まる"履歴参照"の機能を提供
しています。シェル（shell）モードでもこれらの指定を認識して、履歴置換を
行えます。

履歴参照を入力してTABを打つと、履歴リストから一致するシェルコマンドを探
し、必要なら置換を行い、履歴参照をその結果で置き換えます。たとえば、
`mv'で始まるいちばん最近のシェルコマンドを持ってくるには`! m v TAB'と打
ちます。必要ならシェルコマンドを編集し、RETと打ってシェルへ送ります。

シェル（shell）モードでは、シェルに送る際にバッファ内で履歴参照を
展開するようにも指定できます。
それには、変数`compint-input-autoexpand'に`input'を設定します。
SPCをコマンド`comint-magic-space'にバインドすれば、
SPCで履歴展開が行えるようになります。

テキストがプロンプトの後にあれば，シェルモードはそれを履歴として認識し
ます．通常，入力の前にあるプログラムによって出力されたテキストはすべて
プロンプトとして認識されます．しかし，変数
`comint-use-prompt-regexp-instead-of-fields' が非-`nil' であると，プロ
ンプトを識別するために正規表現が使われます．普通，
`comint-prompt-regexp' で正規表現を指定します．シェルモードでは，変数
`shell-prompt-pattern' を `comint-prompt-regexp' に設定して使っています．



File: emacs-ja, Node: Directory Tracking, Next: Shell Options, Prev: Shell History

ディレクトリ追跡機能 *(2005/05/07)*
-----------------------------------

シェルモードは `cd' や `pushd'，`popd' コマンドで移動したことを記録しま
す．これにより，`*shell*' バッファのデフォルトディレクトリはシェルの作
業ディレクトリと同じになります．これらのコマンドは入力された行を調べて
認識しています．

こういったコマンドのエイリアスを用いているのであれば，Emacs にそのエイ
リアスも認識させることができます．例えば，シェルコマンドが変数
`shell-pushd-regexp' の値に一致すれば，その行は `pushd' コマンドとして
認識されます．`pushd' のエイリアスを追加する時に，この変数も変更すれば
いいのです．同様に，`shell-popd-regexp' と `shell-cd-regexp' は `popd'
と `cd' の意味を持つコマンドとして認識させるために使います．これらのコ
マンドはコマンド行の最初にある時だけ認識されます．


サブシェルのカレントディレクトリに変更したことで混乱したら，現在のカレ
ントディレクトリを確認するために，コマンド `M-x dirs' を使います．この
コマンドは一般的なシェルであれば動作します．しかし，普通でないシェルで
は動作しないかもしれません．

`M-x dirtrack-mode' で有効 (あるいは，無効)にすることができます．無効に
して，代わりの，より積極的なカレントディレクトリ追跡機能を使うこともで
きるでしょう．



File: emacs-ja, Node: Shell Options, Next: Terminal emulator, Prev: Directory Tracking

シェルモードのオプション *(2005/05/07)*
---------------------------------------

変数`comint-scroll-to-bottom-on-input'が`nil'以外の場合には、挿入および
ヤンクコマンドは、選択されているウィンドウを末尾までスクロールしてから
挿入します。

`comint-scroll-show-maximum-output' が `nil' 以外の場合、ポイントが最後
にある時，出力で、最後の行ができるだけウィンドウのいちばん下にくるよう
にし、なるべく多くの有用なテキストが見えるようにします（これは多くの端
末のスクロール動作の真似）。デフォルトは`nil'です。

`comint-move-point-for-output'を設定すると、ポイントがどこにあろうと、
出力が到着するたびにバッファの末尾へポイントがジャンプするように設定で
きます。この変数の値が`this'であれば、ポイントは選択されたウィンドウで
ジャンプします。値が`all'であれば、Comintバッファを表示している各ウィン
ドウでポイントはジャンプします。値が`other'であれば、カレントバッファを
表示しているすべての選択されていないウィンドウでポイントはジャンプしま
す。デフォルトは`nil'ですから、ポイントはジャンプしません。

変数`comint-input-ignoredups'は、連続する同一の入力を履歴に格納するかど
うかを制御します。値が`nil'以外のときは、直前の入力と同じ入力は履歴に格
納しません。デフォルトは`nil'ですから、直前と同じ入力でもすべて履歴に格
納します。

3つの変数でファイル名の補完をカスタマイズします。変数
`comint-completion-addsuffix'は、ファイル名やディレクトリ名を補完すると
き、名前を完全に補完できたことを示すために末尾に空白やスラッシュを挿入
するかどうかを指定します（`nil'以外のとき、空白やスラッシュを挿入）。
`comint-completion-recexact'は、その値が`nil'以外の場合、Emacsの通常の
補完アルゴリズムで1文字も追加できないときにはTABで可能なもっとも短い補
完文字列を挿入するようにします。`comint-completion-autolist'は、その値
が`nil'以外の場合、補完が完全でないときに可能な補完候補の一覧を表示する
ことを指定します。

  Command completion normally considers only executable files.  If you
set `shell-completion-execonly' to `nil', it considers nonexecutable
files as well.  コマンド補完は、通常、実行可能なファイルだけを対象とし
ます。`shell-completion-execonly' を `nil' にすると、実行可能でないファ
イルも対象となります。

`pushd'の動作をカスタマイズできます。引数が与えられないと`cd'と同様にふ
るまう（`shell-pushd-tohome'）、数引数を指定すると`pop'ではなく巡回する
（`shell-pushd-dextract'）、ディレクトリスタックにないディレクトリだけ
をディレクトリスタックに加える（`shell-pushd-dunique'）を制御できます。
これらの値は当然、使っているシェルの動作と一致するように設定すべきです。

もしシェルモードにスエルコマンドからのカラー出力を処理するようにさせた
ければ，ANSI カラーモードを利用できます．以下のように設定します．

     (add-hook 'shell-mode-hook 'ansi-color-for-comint-mode-on)



File: emacs-ja, Node: Terminal emulator, Next: Term Mode, Prev: Shell Options

Emacs ターミナルエミュレータ *(2005/05/07)*
-------------------------------------------

`M-x term' を実行することで，ターミナルエミュレータ上でサブシェルを起動
し，Emacs バッファに文字を表示させることができます．このコマンドは
`*terminal*' のような名前のバッファを作成 (あるいは，再利用)します．そ
して，サブシェルを走らせ，キーボードからの入力とバッファへの出力を表示
させるのです．

ターミナルエミュレータは 2つの入力モードを持つ Term モードを使います．
line mode(行モード)では，端末は基本的にシェルモードのように動作します．
*Note Shell Mode:: を参照ください．

char mode(文字モード)では，それぞれの文字が"端末の入力"として直接下位の
シェルに送られます．入力に対する"エコーバック"もサブシェルの責務になり
ます．唯一の例外は端末のエスケープ文字で，デフォルトでは `C-c' (*Note
Term Mode::) です．サブシェルからの端末出力はバッファのポイントの前に表
示されます．

いくつかのプログラム(例えば Emacs 自身) は端末上での外観を細かく制御す
る必要があります．このために，特別なコードを送っています．この時必要と
なるコードは端末によって異なりますが，最近では大抵の端末やターミナルエ
ミュレータ (`xterm' を含む) は ANSI 標準 (VT100-スタイル) のエスケープ
シーケンスを理解します．Term モードはこれらのエスケープシーケンスを認識
し，それぞれを適切に処理し，ウィンドウの外観が本当の端末であるべき姿に
なるようにバッファを変更するのです．これにより，Emacs Term ウィンドウの
中で Emacs を起動することができるのです．

サブシェルを読み込むために使われるファイル名はシェルモードと同じように
決定されます．複数のターミナルエミュレータを使うためには，バッファ
`*terminal*' をシェルモードの時と同じように `M-x rename-uniquely' を実
行して何か別の物に変更します．

シェルモードとは違い，Term モードは入力を調べることでカレントディレクト
リを追跡することはしません．しかし，いくつかのシェルは Term にカレンド
ディレクトリがどこか教えることができます．これは，`bash' バージョン
1.15 以降であれば自動的に行われます．



File: emacs-ja, Node: Term Mode, Next: Paging in Term, Prev: Terminal emulator

Term モード *(2005/05/07)*
--------------------------

ターミナルエミュレータは2つの入力モードを持つ Term モードを使います．行
モードでは，基本的にシェルモードのように動作します．*Note Shell Mode::
を参照ください．文字モードでは，それぞれの文字が下位のシェルに直接送ら
れますが，端末のエスケープキャラクタ (通常は `C-c') は例外です．

行モードと文字モードを切り替えるためには，以下のコマンドを使います．

`C-c C-j'
     行モードに切り替える．すでに行モードであれば何もしない．

`C-c C-k'
     文字モードに切り替える．すでに文字モードであれば何もしない．

以下のコマンドは文字モードの時だけ利用できます．

`C-c C-c'
     シェルに文字 C-c を送る．

`C-c C-x'
     プレフィックスを付けることで，C-x コマンドに便利にアクセスできる．
     例えば，`C-c C-x o' で `C-x o' にバインドされた機能，通常は
     `other-window' を利用できる．



File: emacs-ja, Node: Paging in Term, Next: Remote Host, Prev: Term Mode

ページ出力 *(2005/05/07)*
-------------------------

Term モードはページ出力機能を持っています．この機能を有効にすると，画面
の終わりまでくると，出力を停止します．

`C-c C-q'
     ページ出力機能をトグルします．このコマンドは行モード，文字モードの
     どちらでも動作します．ページ出力機能が有効であれば，モードラインに
     `page' という単語が表示されます．

ページ出力機能が有効であれば，端末が画面よりも多くのテキストを受け取る
と，出力を停止し，モードラインに `**MORE**' と表示します．次のテキスト
を表示するためには SPC を入力します．`?' を入力すると，他のオプションを
見ることができます．このインターフェイスはプログラム `more' と似たもの
です．



File: emacs-ja, Node: Remote Host, Prev: Paging in Term

リモートホストのシェル *(2005/05/07)*
-------------------------------------

通常の端末から入力するどんなコマンドでも(例えば，`telnet' や `rlogin'
コマンド) 端末ウィンドウからリモートコンピュータにログインできます．

通常パスワードを求めるプログラムではパスワードは隠される．そのため，バッ
ファにもパスワードは表示されません．この機能はバッファが文字モードであ
れば，本当の端末を使っているのと同じようになります．行モードであれば，
パスワードは一時的に表示されますが，リターンを入力した時に消されます(こ
の機能は自動的に機能します．特別なパスワードの処理機能はありません)．

別のマシンにログインする時には，使っている端末を指定する必要があります．
端末のタイプ `ansi' か `vt100' は大抵のマシンで機能するでしょう．






File: emacs-ja, Node: Emacs Server, Next: Invoking emacsclient

Emacsをサーバーとして使う *(2005/05/07)*
========================================

`mail'を始めとする多くのプログラムは、送信メッセージなどのテキストを編
集するためにユーザーが指定したエディタを起動します。これらのプログラム
は、習慣として、環境変数`EDITOR'で指定されたエディタを起動します。
`EDITOR'に`emacs'を設定しておけばEmacsが起動しますが、新たに別のEmacsプ
ロセスが開始されるので不便です。というのは、新しいEmacsプロセスは既存の
どんな Emacsプロセスもバッファを共有しないからです。

EmacsクライアントとEmacsサーバーを用いて、`mail'などのプログラムが既存
のEmacsプロセスをエディタとして使うようにできます。以下のようにします。

まずは準備です。Emacsの中で関数`server-start'を呼び出します。（個人のファ
イル`.emacs'に式`(server-start)'を書いておけば、これを自動的に行える。）
つぎに、Emacsの外で環境変数 `EDITOR' に `emacsclient' を設定します。
（プログラムによっては別の環境変数を使う。たとえば、TeX に
`emacsclient' を使わせるには、環境変数 `TEXEDIT' に `emacsclient +%d
%s' と設定する。）

こうすると、どのプログラムが `EDITOR'に指定されたプログラムをエディタと
して起動しても、結果としては、訪れるべきファイルを伝えるメッセージが現
在動いているEmacsに送られます。（これが`emacsclient'の役割。）Emacsはた
だちにバッファを表示し、ユーザーはすぐに編集を開始できます。

そのバッファの編集が終ったら、`C-x #'と打ちます（`server-edit'）。これ
により、ファイルが保存され、終了せよとのメッセージを`emacslient'に送り
返します。`EDITOR' を参照したプログラムは『エディタ』（実際には
`emacsclient'）が終了するのを待ちます。`C-x #'は複数のファイルに対する
外部からの編集要求で他に残っているものがないかどうかも検査し、もしあれ
ばつぎのファイルを訪問します。

望むなら手でサーバーバッファに切り替えてもかまいません。必ず`C-x #'を使
わなければならないということはありません。ただし、`C-x #'はサーバーバッ
ファの編集が終ったということを告げる方法です。

サーババッファを終えると，サーバに接続前に Emacs に既に存在したのでなけ
れば，バッファもキルされます．しかし，`server-kill-new-buffers' を
`nil' に設定していると，別の動作が行われます．サーババッファを終えると，
ファイル名の正規表現が `server-temp-file-regexp' に一致していれば，その
バッファがキルされます．これはある種の一時ファイルを識別するための仕組
みです．

変数`server-window'にウィンドウやフレームを設定してあれば、
`C-x #'はサーバーバッファをそのウィンドウやフレームに表示します。

`mail'やその他のアプリケーションが`emacsclient'の終了を待っているあいだ、
`emacsclient'は端末入力を読みません。したがって、`mail'が使っている端末
は、そのあいだ実質的にブロックされた状態にあります。サーバーとして使う
Emacsで編集をするためには、その（ブロックしている）端末を使わずに行う必
要があります。それには3つの方法があります。

   * ウィンドウシステムを使い、`mail'とEmacsとを別のウィンドウで動かす。
     `mail'が`emacsclient'を待っているあいだ、`mail'が動いてるウィンド
     ウはブロックされるが、他のウィンドウに切り替えればEmacsを使える。

   * 仮想端末を使い，仮想端末で `mail' を起動したり，他の端末で Emacs
     を動かす．

   * Emacsのシェル（shell）モードや Term モードを使って`mail'などのプロ
     グラムを動かす。こうすれば、`emacsclient'はEmacsの下で動いているサ
     ブシェルのみをブロックするので、Emacsを使ってファイルを編集するの
     は通常どおり行える。

オプション `--no-wait' を指定して `emacsclient' を起動すると、Emacs上で
バッファを編集し終るのを待たずにただちに終了します。サーババッファをこ
の方法で作ると，それを終えた時に自動的にキルされます．

* Menu:

* Invoking emacsclient::



File: emacs-ja, Node: Invoking emacsclient, Next: PostScript, Prev: Emacs Server

`emacsclient' の起動 *(2005/05/07)*
===================================

プログラム `emacsclient' を起動する時には，引数としてファイル名や行数な
どが利用されます．例えば，以下のようになります．

     emacsclient {[+LINE[COLUMN]] FILENAME}...

この行は Emacs に指定されたファイルを開き，個々のファイルで行数の指定が
あれば，その行へ移動することを意味しています．もし，桁数も指定されてい
れば，Emacs は指定された行の指定された桁へポイントを移動します．

普通，`emacsclient' は個々のバッファでコマンド `C-x #' を実行するまで，
返ることはありません．このため，Emacs は `emacsclient' にそのことを伝え
ます．

しかし，もし `emacsclient' を起動する時に，オプション `-n' や
`--no-wait' を使っていれば，すぐに返ります (Emacs でファイルを編集した
いだけの時間を取ることができる)．

オプション `--alternate-editor=COMMAND' は `emacsclient' をスクリプトで
起動する時に便利です．`emacsclient' が Emacs に接続するのを失敗した時に
起動すべきコマンドを特定します．例えば，以下のように環境変数 EDITOR を
設定しておけば，例え Emacs が起動しなくても，いつも何らかのエディタを利
用できるでしょう．

     EDITOR="emacsclient --alternate-editor vi +%d %s"

環境変数 ALTERNATE_EDITOR も同じ効果を持ちますが，
`--alternate-editor' で指定した値が優先されます．

代わりに，ファイル `etc/emacs.bash' は Emacs サーバを起動する方法や失敗
した時に起動すべきものを定義します．

もし複数のディスプレイがあれば，オプション `--display=DISPLAY' を使うこ
とで，個々のディスプレイで指定したファイルを開くことができます．この機
能はよく作業場にあるマシンで動作している Emacs サーバに家から接続する時
に使われます．

オプション `--eval' を使うことで，`emacsclient' に Emacs Lisp コードの
一片を実行させることもできます．このオプションが与えられると，残りの引
数が開くべきファイルとしては処理されず，評価すべき式のリストとして処理
されます．



File: emacs-ja, Node: Hardcopy, Next: PostScript, Prev: Invoking emacsclient

印刷用のEmacsコマンドには、バッファ全体ないしその一部を、ページヘッダ付
き／なしのどちらででも出力する機能があります。dired（*Note Misc File
Ops::）とdiary（*Note Diary Commands::）の印刷機能についても参照してく
ださい。

`M-x print-buffer'
     カレントバッファの内容を、ファイル名とページ番号を記したページヘッ
     ダ付きで印刷する。
`M-x lpr-buffer'
     カレントバッファの内容を、ページヘッダなしで印刷する。
`M-x print-region'
     `print-buffer'と同様だが、現在のリージョンのみを印刷する。
`M-x lpr-region'
     `lpr-buffer'と同様だが、現在のリージョンのみを印刷。

（Postscriptコマンドを除く）印刷コマンドは、
`lpr-switches'の値をもとに追加オプションを`lpr'に渡します。
この変数の値は文字列のリストであり、
各文字列は`-'で始まるオプションである必要があります。
たとえば、Emacsから行う印刷で1行を80文字に設定するには、
`lpr-switches'をつぎのように設定します。

     (setq lpr-switches '("-w80"))

変数`printer-name'を設定すれば、使うプリンタを指定できます。

変数`lpr-command'は、実行すべきプリンタプログラムを指定します。デフォル
トの値はオペレーティングシステムに依存します。多くのシステムでは、デフォ
ルトは`"lpr"'です。変数`lpr-headers-switches'も同様に、ページヘッダを作
るための追加オプションを指定します。変数`lpr-add-switches'は、プリンタ
プログラムに（`lpr'には適した）オプション`-T'とオプション`-J'を指定する
かどうか制御します。この変数の値が`nil'ならこれらのオプションを指定しま
せん。プリンタプログラムが`lpr'と互換性がないなら、変数
`lpr-add-switches'は`nil'にすべきです。



File: emacs-ja, Node: PostScript, Next: PostScript Variables, Prev: Invoking emacsclient

PostScriptの印刷 *(2005/05/07)*
===============================

これらのコマンドは、バッファの内容をPostScriptに変換し、プリンタへ送る
か他のEmacsバッファに入れます。

`M-x ps-print-buffer'
     カレントバッファをPostScript形式で印刷する。
`M-x ps-print-region'
     現在のリージョンをPostScript形式で印刷する。
`M-x ps-print-buffer-with-faces'
     カレントバッファをPostScript形式で印刷するが、テキストで用いている
     フェイスをPostScriptの機能で表示する。
`M-x ps-print-region-with-faces'
     現在のリージョンをPostScript形式で印刷するが、テキストで用いている
     フェイスも表示する。
`M-x ps-spool-buffer'
     カレントバッファのテキストをPostScriptに変換する。
`M-x ps-spool-region'
     現在のリージョンをPostScriptに変換する。カレントバッファを
     PostScriptに変換するが、使われているフェイスも表示する。
`M-x ps-spool-region-with-faces'
     現在のリージョンをPostScriptに変換するが、使われているフェイスも表
     示する。
`M-x handwrite'
     カレントバッファを手書きのようなPostScriptに変換/印刷する

PostScriptコマンド`ps-print-buffer'および`ps-print-region'はバッファの
内容をPostScript形式で出力します。前者はバッファ全体を出力しますが、後
者はリージョンのみです。これらに対応した`-with-faces'コマンドである
`ps-print-buffer-with-faces'および`ps-print-region-with-faces'は、出力
するテキストのテキスト属性のフェイス（フォントと表示色）をPostScriptの
機能を用いて再現します。

カラーディスプレイを使っている場合、
バッファでフォントロック（font-lock）モードを使って色付けしたプログラムコードを
`ps-print-buffer-with-faces'で（そのまま）印刷できます。

コマンド名が`print'のかわりに`spool'であるものは、変換したPostscript出
力をプリンタに送るかわりにEmacsバッファに置きます。

`M-x handwrite' はもっとお遊び的な機能です．このコマンドはカレントバッ
ファを手書きのドキュメントのように演出した PostScript を生成します．グ
ループ`handwrite' でカスタマイズできます．この関数は ISO 8859-1 の文字
だけをサポートしています．

つぎの節では、これらのコマンドをカスタマイズする変数について説明します。



File: emacs-ja, Node: PostScript Variables, Next: Sorting, Prev: PostScript

Postscriptの印刷を制御する変数 *(2005/05/08)*
=============================================

すべてのPostScriptの印刷コマンドは、出力をどのように印刷するかを
変数`ps-lpr-command'と`ps-lpr-switches'で指定できます。
`ps-lpr-command'には印刷のため実行するシェルコマンド、
`ps-lpr-switches'にはそのシェルコマンドに指定するオプション、
`ps-printer-name'にはプリンタを指定します。
始めの2つの変数を設定しなかった場合は、
`lpr-command'と`lpr-switches'に基づいて初期値が設定されます。
`ps-printer-name'が`nil'だと`printer-name'を使います。

変数 `ps-print-header' はこれらのコマンドが各ページにヘッダを追加するか
どうかを制御します．ヘッダをオフにしたい時には `nil' にします．

もしプリンタがカラー印刷をサポートしていなければ，`ps-print-color-p' を
`nil' に設定することでカラー処理を無効にすべきです．デフォルトでは，ディ
スプレイがカラーをサポートしていれば，Emacs はカラーでの印刷をサポート
します．白黒プリンタでは，カラーはグレースケールで印刷されます．これに
より，画面でグレイの陰を使っていても，読みにくい出力になるかもしれませ
ん．

デフォルトでは，`ps-use-face-background' が 非 `nil' でなければ，
PostScript は背景を無視します．これは，背景の画像やテキストが縞々になっ
て望まない干渉が出ることを避けるためです．

変数`ps-paper-type'は、印刷用紙サイズを指定します。指定できる値は、
`a4'、`a3'、`a4small'、`b4'、`b5'、`executive'、`ledger'、`legal'、
`letter'、`letter-small'、`statement'、`tabloid'です。デフォルトは
`letter'です。変数`ps-page-dimensions-database'を変更すれば別の用紙サイ
ズを定義できます。

変数`ps-landscape-mode'は用紙の向きを指定します。
デフォルトは`nil'で、『縦づかい』（ポートレート）です。
`nil'以外の値を指定すると『横づかい』（ランドスケープ）です。

変数`ps-number-of-columns'は段数を指定します。縦づかいでも横づかいでも
有効で、デフォルトは1です。

変数`ps-font-family'は、通常のテキストの印刷に使うフォントファミリを指
定します。指定できる値は、`Courier'、`Helvetica'、`NewCenturySchlbk'、
`Palatino'、`Times'です。変数`ps-font-size'は、通常のテキスト印刷に使う
フォントのサイズを指定します。デフォルトは8.5ポイント (1) (*Note
PostScript Variables-Footnotes::)です。

Emacs は典型的な PostScript プリンタよりも多くのスクリプトや文字をサポー
トします．バッファにあるいくつかの文字はプリンタに組込まれたフォントで
は印刷できないかもしれません．プリンタに組込まれたフォントに GNU
Intlfonts パッケージからのフォントを組み込むことで増強したり，
Intlfonts を使うように指示することができます．変数
`ps-multibyte-buffer' はこの機能を制御しています．デフォルトは `nil' で，
ASCII や Latin-1 の文字を印刷するのに最適です．`non-latin-printer' の値
は ASCII や Latin-1，日本語，韓国語のフォントを持つプリンタです．
`bdf-font' の値は Intlfonts パッケージから *すべての*文字を使えるように
するために必要となります．最後に`bdf-font-except-latin' の値は組込まれ
た ASCII と Latin-1 を使い，残りには Intlfonts BDF フォントを使うように
指示します．


BDF フォントを使うことができるようにするために，Emacs はどこにフォントがあるか知
る必要があります．変数 `bdf-directory-list' は Emacs がフォントを探すべきディ
レクトリのリストになります．デフォルト値は1つのディレクトリ
`/usr/local/share/emacs/fonts/bdf' を持ちます．

これらのコマンドには他にも多くのカスタマイズ可能な変数があり、それらは
Lispファイル`ps-print.el' や `ps-mule.el' で定義されています。


File: emacs-ja  Node: PostScript Variables-Footnotes, Up: PostScript Variables

(1) 【訳注】印刷機の長さの単位。1ポイントは約1/72インチ（0.35mm）



File: emacs-ja, Node: Sorting, Next: Narrowing, Prev: PostScript Variables

テキストのソート *(2005/05/07)*
===============================

Emacsには、バッファ中のテキストをソートするコマンドがいくつかあります。
すべてはリージョン（ポイントとマークのあいだのテキスト）に働きます。こ
れらのコマンドは、リージョン中のテキストを多数の"ソートレコード"にわけ、
各レコードについて"ソートキー"を識別し、一連のレコードをソートキーによっ
て定まる順序に並べ替えます。レコードはキーのアルファベット（辞書）順に
も、また数値に基づく数値順にも並べられます。アルファベット順の場合は、
ASCII 文字の順序に基づいてすべての大文字「A」〜「Z」は小文字「a」よりま
えにきます。

各種のソートコマンドの違いは、テキストをソートレコードに分ける方法と、
各レコードのどの部分をソートキーに使うかです。ほとんどのコマンドは各行
をソートレコードとして扱いますが、段落やページをソートレコードとして扱
うコマンドもあります。ほとんどのソートコマンドは各ソートレコード全体を
それ自身のソートキーとして扱いますが、ソートレコードの一部分だけをソー
トキーとして扱うコマンドもあります。

`M-x sort-lines'
     リージョンを行の並びとみなし、行全体のテキストを比較して（昇順に）
     ソートする。数引数を指定すると降順にソートする。

`M-x sort-paragraphs'
     リージョンを段落の並びとみなし、（先頭の空行を除く）段落全体のテキ
     ストを比較して（昇順に）ソートする。数引数を指定すると降順にソート
     する。

`M-x sort-pages'
     リージョンをページの並びとみなし、（先頭の空行を除く）ページ全体の
     テキストを比較して（昇順に）ソートする。数引数を指定すると降順にソー
     トする。

`M-x sort-fields'
     リージョンを行の並びとみなし、行の1つの欄を比較して（昇順に）ソー
     トする。欄は白文字で区切られる。つまり、行の始めにある白文字でない
     文字の並びが第1欄、そのつぎの空白でない文字の並びが第2欄、というよ
     うになる。

     どの欄をキーとしてソートするかは、1を指定すれば第1欄、というように
     数引数で指定する。負の値を指定したときは左からでなく右から欄を数え
     る。つまり、-1は最後の欄でソートする。複数の行において欄の値が同一
     の場合、バッファ上のもとの順序が保存される。

`M-x sort-numeric-fields'
     `M-x sort-fields' と同様だが、指定した欄を行ごとに数値に変換し、そ
     の数値同士を比較する。`10'はアルファベット順では`2'よりまえにくる
     が、数値として見れば`2'よりあとにくる。デフォルトでは，数は
     `sort-numeric-base' によって解釈されますが，`0x' か `0' で始まる数
     であればそれぞれ16進数や8進数として解釈されます．

`M-x sort-columns'
     `M-x sort-fields'と同様だが、行の比較に使うテキストは固定文字位置
     からとる。以下の説明を参照のこと。

`M-x reverse-region'
     リージョン内の行の順番を逆にする。欄や文字位置でソートするコマンド
     は降順にはソートできないので、昇順にソートしたあと降順に並べ替える
     のに役立つ。

たとえば、バッファにつぎのような内容が入っていたとします。

     On systems where clash detection (locking of files being edited) is
     implemented, Emacs also checks the first time you modify a buffer
     whether the file has changed on disk since it was last visited or
     saved.  If it has, you are asked to confirm that you want to change
     the buffer.

バッファ全体に`M-x sort-lines'を適用すると、つぎのようになります。

     On systems where clash detection (locking of files being edited) is
     implemented, Emacs also checks the first time you modify a buffer
     saved.  If it has, you are asked to confirm that you want to change
     the buffer.
     whether the file has changed on disk since it was last visited or

ここで、`O'は大文字なのですべての小文字よりまえにきます。上記のかわりに
`C-u 2 M-x sort-filelds'を使ったとすると、結果はつぎのようになります。

     implemented, Emacs also checks the first time you modify a buffer
     saved.  If it has, you are asked to confirm that you want to change
     the buffer.
     On systems where clash detection (locking of files being edited) is
     whether the file has changed on disk since it was last visited or

この例ではソートキーは、`Emacs'、`If'、`buffer'、
`systems'、`the'だったわけです。

`M-x sort-columns'には少々説明が必要です。文字位置の範囲を指定するには、
ポイントを文字位置の一方に、マークを他方の文字位置に置きます。このため、
ポイントやマークをソートしたい最初の行の先頭に置くことができませんから、
このコマンドでは変わった「リージョン」の定義を用います。ポイントがある
行全体はリージョンに含まれ、同様に、マークがある行全体もリージョンに含
まれ、この2つの行のあいだにある行はすべてリージョンに含まれるとみなすの
です。

たとえば、ある表を10文字目から15文字目までの情報をもとにソートする場合、
表の最初の行の10文字目にマークを置き、表の最後の行の15文字目にポイント
を置き、そして`sort-column'を実行します。あるいは、マークを最初の行の
15文字目、ポイントを最後の行の10文字目に置いても同じことです。

これは、ポイントとマークで指定された矩形領域をソートするものと考えられ
ます。ただし、矩形領域の右側や左側にある各行のテキストも一緒に移動しま
す。

`sort-fold-case'が`nil'以外の場合、ソートコマンドのほとんどは比較に際し
て大文字小文字を区別しません。



File: emacs-ja, Node: Narrowing, Next: Two-Column, Prev: Sorting

ナロイング *(2005/05/07)*
=========================

"ナロイング"（narrowing）とは、バッファのある部分だけに焦点を当て、
残りの部分を一時的に参照できなくすることです。
扱える部分のことを"参照可能範囲"と呼びます。
ナロイングを取り消して、バッファ全体を参照できるように戻すことを
"ワイドニング"（widening）と呼びます。

ナロイングすると、他の部分に煩わされることなく、1つのサブルーチンや段落
などに集中できます。また、置換コマンドやキーボードマクロの適用範囲を制
限するのにも利用できます。

`C-x n n'
     ポイントとマークのあいだにナロイングする（`narrow-to-region'）。
`C-x n w'
     再度バッファ全体を参照可能にする（`widen'）。
`C-x n p'
     現在のページにナロイングする（`narrow-to-page'）。
`C-x n d'
     現在の関数定義にナロイングする（`narrow-to-defun'）。

バッファの一部分へナロイングすると、その部分だけしかないように見えます。
残りの部分は見えませんし、そこへポイントを移動することもできません（移
動コマンドは参照可能範囲から外へ出られない）し、見えない部分はどのよう
にしても変更できません。しかし、その部分がなくなったわけではないので、
ファイルに保存すれば参照できないテキストも保存されます。ナロイングして
いるあいだは、モード行に`Narrow'と表示されます。

主要なナロイングコマンドは`C-x n n'（`narrow-to-region'）です。現在のリー
ジョンだけが参照可能で、その前後のテキストは参照できないようにカレント
バッファに制限を課します。ポイントとマークは変化しません。

別のやり方として、`C-x n p'（`narrow-to-page'）は現在のページだけが見え
るようにナロイングします。ページの定義については、*Note Pages::。`C-x
n d'（`narrow-to-defun'）はポイントを含む関数定義の範囲にナロイングしま
す（*Note Defuns::）。

ナロイングを取り消すには、`C-x n w'でワイドニングします。これによってバッ
ファ中の全テキストが再度参照可能になります。

バッファ中のどの部分にナロイングしているかは、
コマンド`C-x ='で調べることができます。
*Note Position Info::。

ナロイングは、それについて知らないユーザーを簡単に混乱させますので、
`narrow-to-region'は、通常、使用禁止コマンドになっています。
このコマンドを使おうとすると、Emacsは確認を求めてきて、
コマンドを使えるようにするかどうか問い合わせてきます。
コマンドを利用可能にすると、それ以後は確認は必要なくなります。
*Note Disabling::。



File: emacs-ja, Node: Two-Column, Next: Editing Binary Files, Prev: Narrowing

2段組み編集 *(2005/05/07)*
==========================

2段組み（two-column）モードは、左右の段に分けたテキストを編集するのに便
利です。このモードでは、左右に並んだ2つのウィンドウを使用し、それぞれに
別のバッファを表示します。

2段組み（two-column）モードに入るには、3つの方法があります。

`F2 2' または `C-x 6 2'
     カレントバッファを左側に、カレントバッファの名前に基づいた名前のバッ
     ファを右側にして2段組み（two-column）モードに入る
     （`2C-two-columns'）。右側のバッファがまだ存在しなければ空のバッファ
     で始まり、カレントバッファの内容は変化しない。

     このコマンドはカレントバッファが空か、または1段目の内容だけを持っ
     ていて、これから2段目を作成しようとするときに使う。

`F2 s' または `C-x 6 s'
     2段組みテキストを含んでいるカレントバッファの内容を2つのバッファに
     分割し、それらを左右に並べて表示する（`2C-split'）。カレントバッファ
     は左側のバッファになるが、右側の段の内容は右側のバッファに移される。
     分割位置はポイントのある文字位置で指定する。現在行からバッファの末
     尾を分割する。

     このコマンドはバッファにすでに2段組みのテキストが入っていて、一時
     的に左右の段を分けて編集したいときに用いる。

`F2 b BUFFER RET'
`C-x 6 b BUFFER RET'
     カレントバッファを左側のバッファ、BUFFERを右側のバッファとして2段
     組み（two-column）モードに入る（`2C-associate-buffer'）。

`F2 s'と`C-x 6 s'は、各行を2つの段に分ける文字列である「段区切り文字列」
を探します。段区切り文字列の文字数は、`F2 s'への数引数で指定できます。
ポイントの直前のその文字数分の文字列が段区切り文字列になります。デフォ
ルトでは幅は1ですから、ポイントの直前の文字が段区切り文字列になります。

各行の正しい位置に段区切り文字列があれば、`F2 s'は各行の段区切り文字列
のうしろの文字列を右側のバッファに移し、段区切り文字列を削除します。段
区切り文字列が正しい位置にない行は分割されずに左側のバッファに残り、対
応する右側のバッファの内容は空行になります。（これは、『2段組み
（two-column）モードで両側の段にまたがった行』の書き方。つまり、左側の
バッファにそのような行を書き、右側のバッファは空行にしておく）。

コマンド`C-x 6 RET'や`F2 RET' （`2C-newline'）は、左右の2つのバッファの
対応する位置に改行を挿入します。バッファを分割して編集しているときに2段
組みテキストに新しい行を追加するにはこれがもっとも簡単な方法です。

左右のバッファを望むように編集し終えたら、それらを`F2 1'または`C-x 6
1'（`2C-merge'）で再度併合します。右側バッファの内容を左側バッファに第
2段目としてコピーします。再度2段組み編集に戻るには、`F2 s'を使います。

2つのバッファ間の関連を解消するには、`F2 d'または`C-x 6
d'（`2C-dissociate'）を使います。コマンドを入力したときにカレントバッファ
でない側のバッファが空であれば、そのバッファは削除します。



File: emacs-ja, Node: Editing Binary Files, Next: Saving Emacs Sessions, Prev: Two-Column

バイナリファイルの編集 *(2005/05/07)*
=====================================

バイナリファイルを編集するための特別なメジャーモード、hexlモードがあり
ます。このモードを使うには、ファイルを訪問する`C-x C-f'のかわりに`M-x
hexl-find-file'を使います。このコマンドはファイルの内容を16進数表現に変
換し、変換したものを編集するようにします。ファイルを保存すると自動的に
バイナリに戻されます。

`M-x hexl-mode'を使えば、既存のバッファを16進数表現に変換できます。普通
にファイルを訪問してみたら、実はバイナリファイルだとわかった場合に便利
です。

hexlモードでは通常のテキスト文字は上書きします。これはファイル中のデー
タの配置をまちがって壊してしまう危険を減らすためです。特別な挿入コマン
ドがあります。以下は、hexlモードで使えるコマンドの一覧です。

`C-M-d'
     10数進で入力したコードのバイトを挿入する。

`C-M-o'
     8数進で入力したコードのバイトを挿入する。

`C-M-x'
     16数進で入力したコードのバイトを挿入する。

`C-x ['
     1kバイト単位の『ページ』の先頭へ移動する。

`C-x ]'
     1kバイト単位の『ページ』の末尾へ移動する。

`M-g'
     16進数で指定したアドレス位置へ移動する。

`M-j'
     10進数で指定したアドレス位置へ移動する。

`C-c C-c'
     hexlモードを抜け、
     `hexl-mode'実行前のこのバッファのメジャーモードに戻る。

他の Hexl コマンドはバイナリバイトの文字 (文字列) を挿入し，`short' や
`int' での移動を可能にします．`C-h a hexl-RET' を参照ください．



File: emacs-ja, Node: Saving Emacs Sessions, Next: Recursive Edit, Prev: Editing Binary Files

セッションの保存 *(2005/05/07)*
===============================

あるセッションから他のセッションへ Emacs の状態を保存するためにはデスク
トップライブラリを使います．一旦 Emacs の"デスクトップ(desktop)"―バッ
ファ，個々のファイル名，メジャーモード，バッファ位置など―を保存してお
けば，別の Emacs セッションで保存されたデスクトップを読み込むことができ
るのです．

コマンド `M-x desktop-save' で手動でデスクロップを保存できます．Emacs を終了
する時に自動的にデスクトップを保存することもできます．そのためには，カスタマイズ
 (*Note Easy Customization::を参照) を使って `desktop-save-mode' を
 `t' に設定するか，`~/.emacs' に以下を追加します．

     (desktop-save-mode 1)

Emacs が起動された時，現在のディレクトリに保存されたデスクトップが無い
か探します．こうして，別々のディレクトリに別々のデスクトップを保存する
ことができます．そして，開始ディレクトリを変えることで，どのデスクトッ
プを読み込むべきか指定できます．`M-x desktop-change-dir' を実行すること
で，現在のディスクトップを保存し，別のディレクトリに保存されたデスクトッ
プを読み込ませることができます．`M-x desktop-revert' を入力することで，
前に読み込まれたデスクトップに戻ることができます．

コマンドでオプション `--no-desktop' を指定することで，保存されたデスク
トップを読み込ませないようにできます．

`M-x desktop-clear' を入力することで Emacs のデスクストップを空にするこ
とができます．このコマンドは内部で用いられているもの以外のバッファをす
べてキルし，`desktop-globals-to-clear' にリストされているグローバル変数
をすべて初期化します．もしあるバッファを残したければ，変数
`desktop-clear-preserve-buffers-regexp' をカスタマイズします．この変数
の値はキルしないバッファ名に一致する正規表現になります．



File: emacs-ja, Node: Recursive Edit, Next: Emulation, Prev: Saving Emacs Sessions

再帰編集レベル *(2005/05/07)*
=============================

"再帰編集"とは、あるEmacsコマンドの実行途中で任意のEmacsコマンドを使っ
て編集を行う状況をいいます。たとえば、`query-replace'の途中で`C-r'を打
つと、再帰編集に入りカレントバッファを自由に変更できます。再帰編集から
抜けると、`query-replace'の続きに戻ります。

再帰編集から"脱出"するとは、実行途中のコマンドに戻ってその続きを行うこ
とを意味します。脱出のためのコマンドは`C-M-c'（`exit-recursive-edit'）
です。

再帰編集を"アボート"することもできます。
これは脱出と似ていますが、実行途中だったコマンドも一緒に中断します。
アボートするには、
`C-]'（`abort-recursive-edit'）を使います。
*Note Quitting::。

再帰編集中は、モード行のメジャー／マイナモード名を囲む丸括弧の外側に中
括弧`[...]'が表示されます。各ウィンドウのモード行すべてにこのように表示
されます。というのは、特定のウィンドウやバッファではなくEmacs全体が再帰
編集に入っているからです。

再帰編集中にさらに再帰編集に入ることもできます。たとえば、
`query-replace'の途中で`C-r'を打ってからデバッガを起動するコマンドを打っ
たとします。すると、`C-r'による再帰編集の中でさらにデバッガのための再帰
編集に入ることになります。モード行には、現在の再帰編集レベルの数だけ中
括弧の対が表示されます。

内側の再帰編集を（たとえばデバッガのコマンド`c'で）脱出すると、1つ上の
レベルでのコマンドが再開されます。そのコマンドが終わったところで
`C-M-c'を使うとそのレベルの再帰編集を脱出する、というようにして再帰編集
を終わらせていくことができます。脱出はつねにもっとも内側のレベルに対し
て起こります。また、アボートも1つのレベルの再帰編集から脱出し、1つまえ
の再帰編集のコマンドレベルに戻ります。必要ならそこでつぎの再帰編集レベ
ルをアボートする、というように続けることができます。

あるいは、コマンド`M-x top-level'ですべてのレベルの再帰編集をアボートし、
ただちにトップレベルのコマンド入力に戻ることができます。

再帰編集の中で編集しているテキストはトップレベルで編集しているテキスト
と同じであるとは限りません。再帰編集の目的によって変わってきます。再帰
編集を起動するコマンドがまず別のバッファに切り替えるものなら、そのバッ
ファを再帰的に編集することになるでしょう。いずれにせよ、再帰編集の内側
でも（バッファを切り替えるキーが再定義されていない限り）通常どおりバッ
ファを切り替えることができます。残りの編集作業をすべて再帰編集の内側で
やってしまい、別のファイルを訪問したりもできます。しかしそのようなこと
をすると、ときどき（スタックオーバーフローなどの）痛い目に合う可能性が
あります。ですから、再帰編集が不要になったら忘れずに脱出かアボートして
ください。

一般に、GNU Emacsでは再帰編集レベルを最小限に抑えるように努めています。
というのは、再帰編集では特定の順、つまり、最内側レベルからトップレベル
に向かう順で戻るように強いられるからです。このため、別の作業は別のバッ
ファでするようにして、ユーザーがそれらの間を自由に行き来できるようにし
ています。たとえば、あるコマンドは新しいメジャーモードに切り替えますが、
もとのモードに戻るコマンドを用意しておきます。このようにしたほうが、や
りかけの作業に戻る順番を自由に選べ、柔軟性を提供できます。



File: emacs-ja, Node: Emulation, Next: Hyperlinking, Prev: Recursive Edit

エミュレーション *(2005/05/07)*
===============================

GNU Emacsは、他のほとんどのエディタの（程度の差はありますが）エミュレー
ト（真似を）するようにプログラムできます。標準の機能では、以下のものを
エミュレートできます。

CRiSP/Brief (PC editor)
     `M-x crisp-mode' を入力することで CRiSP/Brief エディタをエミュレートしたキー
     バインドを有効にできます．この機能は `M-x' を Emacs を終了させるキーにバイン
     ドします．このバインドを無効にするためには `crisp-override-meta-x' を変更し
     ます．CRiSP のscroll-all 機能(すべてのウィンドウを一緒にスクロールさせる機能)を
     実現するためには，コマンド `M-x scroll-all-mode' を実行したり，ユーザオプション
     `crisp-load-scroll-all' を設定します．

EDT（DECのVMSエディタ）
     `M-x edt-emulation-on'でEDTエミュレーションに入る。
     `M-x edt-emulation-off'で通常のEmacsのバインディングに戻る。

     EDTエミュレーションコマンドの大部分はキーパッドのキーであり、大部
     分のEmacsのキーバインディングはそのまま使える。EDTエミュレーション
     のバインディング変更はグローバルキーマップに対して行われ、EDTエミュ
     レーションの状態でバッファやメジャーモードを切り替えても問題ない。

"PC" bindings
     コマンド `M-x pc-bindings-mode' は "PC で一般的な"キーバインドに設
     定します．"PC で一般的な"とは，`Delete' とその変種で後ろではなく前
     にあるテキストを削除し，`C-Backspace' で前の単語をキルし (通常は
     `C-Delete' のように)，`M-Backspace' でアンドゥし， `Home' と
     `End' で行の先頭や末尾に移動し，`C-Home' と `C-End' でバッファの先
     頭や末尾へ移動し，`C-Escape' で `list-buffers' を実行することです．

PC Selection mode
     コマンド `M-x pc-selection-mode' は ―CUA として知られるインターフェ
     イスのように―他の様々なシステムにあるマーク，コピー，カットアンド
     ペーストコマンドをエミュレートするグローバルマイナーモードをトグル
     します．この機能はPCモードのキーバインドを有効にし，カーソルキーと
     `next' や `prior'， `home'，`end' キーも変更します．このコマンドは
     CUA キーバインドのすべてを実現するわけではありません．基本的な
     Emacs のキーである `C-c' や `C-v'，`C-x' は変更しません．

     PC 選択モード (PC selection モード)では移動するための標準的なキー
     (移動キーである `right'，`left'，`up'，`down'，`home'，`end'，
     `prior'，`next') はマークを無効にします．しかし，移動キーと一緒に
     `Shift' を使うと，移動した領域をリージョンにできます．コピーやカッ
     ト，ペーストはそれぞれ `C-insert'，`S-delete'，`S-insert' で利用で
     きます．

     `pc-selection-mode' をオフにすると，古いキーバインドを再現します．

     `s-region' パッケージは似た機能ですが，より機能の少ないものです．

TPU (DEC VMS editor)
     `M-x tpu-edt-on' は EDT をエミュレートした TPU エディターをエミュ
     レーションを有効にします．

vi （バークレー エディタ）
     viperは最新のviエミュレータである。
     viperでは複数レベルのエミュレーションを実装している。
     レベル1がもっともviに近く、レベル5はviといくらか違うところもあるが、
     そのかわりEmacsの機能も活かせるようになっている。
     viperを起動するには、`M-x viper-mode'と打つ。
     すると、使い方のガイドを表示し、
     どのレベルのエミュレーションにするかを尋ねてくる。
     *Note Viper: (viper)Top。

vi （もう1つのエミュレータ）
     `M-x vi-mode'はそれまでのメジャーモードにかわってviメジャーモード
     に入る。viの『入力』モードに入るコマンドはすべて、それまでのメジャー
     モードに戻る動作になっている。つまり、viの『入力』モードとして普通
     のEmacsが使えるのである。

     viエミュレーションはメジャーモードとして動くので、エミュレーション
     中にバッファを切り替えることはできない。バッファを切り替えたければ、
     まず通常のEmacsに戻る。

     viエミュレーションを多用するつもりなら、
     `vi-mode'コマンドにキーをバインドしたほうがよいだろう。

vi （また別のエミュレータ）
     `M-x vip-mode'は、`M-x vi-mode'よりもっとviに酷似しているといわれ
     る別のviエミュレータを起動する。このエミュレータでは『入力』モード
     も通常のEmacsとは変わっていて、ESCでviコマンドモードに戻る。viコマ
     ンドモードのエミュレーションから通常のEmacsに戻るには`C-z'と打つ。

     このエミュレータはメジャーモードとして動くのではないので、
     エミュレータを動かしたままさまざまな方法でバッファを切り替えることができる。
     `vi-mode'のようにコマンド`vi-mode'で
     入力モードを終了するのではないので、
     `vip-mode'にキーを割り当てる必要はない。

     より詳しくは*Note VIP: (vip)Top。

WordStar (old wordprocessor)
     `M-x wordstar-mode' は WordStar のようなキーバインドを持つメジャーモードです．



File: emacs-ja, Node: Hyperlinking, Next: Dissociated Press, Prev: Emulation

ハイパーリンクとナビゲーション機能 *(2005/05/08)*
=================================================

ドキュメントのモードによってはハイパーテキスト機能を持ちます．大抵リン
クの上で`Mouse-2' をクリックしたり，リンク上にポイントがある時に RET を
入力することで，リンクを辿ることができます．Info モードや Help モード，
Dired のようなモードがこの例になります．タグ機能はソースファイルで利用
方法とその定義をリンクします．*Note Tags:: を参照ください．Imenu は現在
のバッファで収集されたアイテムの間を移動する機能です．*Note Imenu::を参
照ください．Info-lookup は モードに特有な検索機能です．*Note
Documentation:: を参照ください．Speedbar はファイルやファイルのある位置
にリンクしたフレームが表示されます．*Note Speedbar:: を参照ください．

この章で紹介する他のモードに特有でない機能は現在のバッファからある種の
テキストを用いたリンクを実現します．

* Menu:

* Browse-URL::                  Following URLs.
* Goto-address::                Activating URLs.
* FFAP::                        Finding files etc. at point.
* Find-func::                   Finding function and variable definitions.



File: emacs-ja, Node: Browse-URL, Next: Goto-address, Prev: Hyperlinking, Up: Hyperlinking

URL を辿る *(2005/05/08)*
-------------------------

`M-x browse-url RET URL RET'
     URL をブラウザで開く

Browse-URL パッケージを使うと，WWW の URL を開く機能を実現できます．こ
の機能は大抵ブラウザを起動しますが，例えば，`mailto:' に対して
`compose-mail' を起動することもできます．

この機能を使う一般的な方法は `M-x browse-url' を入力し，URLを入力するこ
とです．もし，ポイントが URL らしき文字列上にあれば，その URL がデフォ
ルトとして使われます．`browse-url-at-point' や `browse-url-at-mouse' の
ようなコマンドはキーに割り当てるのに利用できるでしょう．

`browse-url' のカスタマイズグループを使って，さまざまなオプション，特に
`browse-url-browser-function' を設定することで Browse-URL の動作を変え
ることができます．`browse-url-browser-function' で連想リストとして定義
しておくと，URL に依存した関数を起動できます．`C-h p' で見ることのでき
るパッケージのコメントにはもっと多くの情報があります．URL を辿る機能を
持つパッケージはBrowse-URL を使うべきです．そうすれば，Browse-URL のオ
プションをカスタマイズすることで，Emacs でURL を辿るすべての動作を変更
できるのです．



File: emacs-ja, Node: Goto-address, Next: FFAP, Prev: Browse-URL, Up: Hyperlinking

URL を活性化 *(2005/05/08)*
---------------------------

`M-x goto-address'
     現在バッファのURLとメールアドレスを活性化する．

`M-x goto-address' で現在バッファのURLを活性化できます．このコマンドは
バッファですべてのURLを探し，それらのリンクに `Mouse-2' と `C-c RET' の
キーバインドを付けます．活性化後，URL 上で `Mouse-2' をクリックしたり，
URL へポイントを動かして `C-c RET' を入力すると，URL を開きそのページが
表示されます．`mailto' URL の場合には，指定されたメール作成方法 (*Note
Mail Methods::) を使って，メールを送ります．

`goto-address' をモードのフックや受け取ったメッセージを表示するフックに
追加しておくと便利でしょう．Rmail のフックであれば
`rmail-show-message-hook'，MH-E であれば `mh-show-mode-hook'が適切でしょ
う．Gnus では似た機能を独自に持っていますので，必要ありません．



File: emacs-ja, Node: FFAP, Next: Find-func, Prev: Goto-address, Up: Hyperlinking

ポイントのファイルや URL を開く *(2005/05/08)*
----------------------------------------------

FFAP mode は `C-x C-f' を含めたファイルを開くキーバインドをより敏感なも
のに置き換えます．このコマンドは数引数を与えると普通のものと同じように
振舞います．さもなければ，ポイント周辺からデフォルトのファイル名や URL
を得ます．もしバッファで見付かったものがファイル名ではなく URL であった
ら，`browse-url' を使って表示します．

この機能はメールやニュースバッファ，`README' ファイル，`MANIFEST' ファ
イルなどで出典を辿るのに役立ちます．`C-h p' を使うことで，`ffap' パッケー
ジのコメントを見ることができます．また，カスタマイズグループ `ffap' も
あります．

FFAP マイナーモードを有効にすると，以下のキーバインドを割り当て，
`ffap' をRmail，Gnus，VM の記事バッファで有効にするフックを設定します．

`C-x C-f FILENAME RET'
     FILENAME を探す．ポイント周辺のテキストがデフォルトになる
`C-x 4 f'
     `ffap-other-window'．`find-file-other-window' と同じ．
`C-x 5 f'
     `ffap-other-frame'． `find-file-other-frame' と同じ．
`M-x ffap-next'
     次のファイル名や URL を探し，そのファイルや URL を開く．
`C-x d DIRECTORY RET'
     DIRECTORY で Dired を起動する．ポイント付近のディレクトリ名がデフォ
     ルトになる (`ffap-dired-at-point')．
`S-Mouse-3'
     `ffap-at-mouse' はマウスをクリックした位置付近のテキストからファイ
     ル名を探し開きます．
`C-S-Mouse-3'
     現在バッファにあるファイル名や URL のメニューを表示します．そして，
     選択したものを開きます (`ffap-menu')．



File: emacs-ja, Node: Find-func, Prev: FFAP, Up: Hyperlinking

関数や変数の定義を探す *(2005/05/08)*
-------------------------------------

`M-x find-function RET FUNCTION RET'
     ソースファイルで FUNCTION の定義を探す
`M-x find-variable RET VARIABLE RET'
     ソースファイルで VARIABLE の定義を探す
`M-x find-function-on-key RET KEY'
     KEY を入力した時に起動される関数の定義を探す．

これらのコマンドを使うと簡単に Emacs Lisp の関数や変数の定義を探すこと
ができます．目的としては， Tags 機能 (*Note Tags::を参照) と似ています
が，これはタグテーブルを必要としません．また，Emacs にすでに読み込まれ
た関数や変数の定義だけに有効です．

関数の定義を探すためには `M-x find-function' を使います．`M-x
find-variable' は指定された変数の定義を探します．`M-x
find-function-on-key' は指定されたキーに割り当てられた関数の定義を探し
ます．

これらのコマンドを使うためには，コンパイルされたファイル (`.elc') と一
緒にLisp のソースファイル (`.el') が `load-path' に無ければいけません．
Auto Compression モードが有効であれば，圧縮されたソースファイルを使うこ
とができます．Lisp で書かれたコマンドだけを扱い，C で書かれた初歩的な関
数や変数は扱いません．



File: emacs-ja, Node: Dissociated Press, Next: Amusements, Prev: Hyperlinking

まぜこぜ新聞（Dissociated Press）
=================================

`M-x dissociated-press'はテキストを、単語単位、または、文字単位で混ぜ合
わせるコマンドです。普通の英語をバッファに入れた状態でこれを実行すると、
きわめておもしろい結果が生成されます。入力はカレントバッファから取り、
出力は`*Dissociation*'というバッファに書き込みます（およそ2、3行生成す
るごとにバッファが再表示されるので、生成内容を順次読めます）。

`M-x dissociated-press'は定期的にもっと出力を続けるかどうか聞いてきます。
`n'と答えると生成をやめます。また、`C-g'を打てばいつでも止められます。
出力はバッファ`*Dissociation*'に残っていますから、必要ならどこへでもコ
ピーできます。

`M-x dissociated-press'はバッファ中のある箇所からランダムに別の箇所にジャ
ンプすることを繰り返していきます。ただのゴミではなくおもしろい出力が得
られるように、ある一連の単語列からつぎの一連の単語列に移る際に、それら
のあいだに一定の重複があるようにします。つまり、たとえばpresidentと出力
したところで別の場所にジャンプすることに決めたら、最後にあったentと同じ
文字列のある単語、たとえばpentagonのところに飛んでそこから続けるので、
結果としてpregidentagon (1) (*Note Dissociated Press-Footnotes::) とい
うのが生成されるわけです。元テキストが長いとたいへんおもしろい結果を得
られます。

`M-x dissociated-press'に正の数引数を渡すと文字単位で動作し、その数値は
重複する文字数を指定します。また、負の数引数を渡すと単語単位で動作し、
その数値（の絶対値）で重複する単語数を指定します。引数を指定しないと
「2」を指定したのと同じになります。繰り返しますが、出力はつねにバッファ
`*Dissociation*'に現れます。もとのバッファは変更されません。

`M-x dissociated-press'は、入力テキストから頻度表を作ってマルコフ連鎖を
適用したのに近い結果をもたらしますが、それ自体はきわめてオリジナルな発
明です。というのは、マルコフ連鎖では単に乱数に基づいて文字や語を選ぶだ
けなのに対し、このコマンドでは乱数に基づいて連続した文字や語をコピーし
てくるからです。このため、より高速な実行が可能ですし、読んでおもしろい
結果が得られます。

`M-x dissociated-press'の使いすぎは仕事に差し支え、場合によっては重大な
障碍となりますから注意しましょう。また、ユーザーに受け入れてもらうため
にも、マニュアルにこのコマンドの出力を利用するのはやめたほうがよいです。
でも、せいぜい楽しんで、よかったらバグの提案もよろしく。 (2) (*Note
Dissociated Press-Footnotes::)


File: emacs-ja  Node: Dissociated Press-Footnotes, Up: Dissociated Press

(1) この合成語は、ベトナム戦争中にまさにそれにぴったりの意味で実際に使
われたことがある。

(2) 【訳注】 この段落自体、`M-x dissociated-press'で生成したような
ものなので、原文を掲載しておく。
 It is a mustatement that too much
use of Dissociated Press can be a developediment to your real work.
Sometimes to the point of outragedy.  And keep dissociwords out of
your documentation, if you want it to be well userenced and
properbose.  Have fun.  Your buggestions are welcome.



File: emacs-ja, Node: Amusements, Prev: Dissociated Press

その他の娯楽 *(2005/05/08)*
===========================

退屈なときは、`M-x hanoi'を試してください。ひどく退屈なら、数引数を指定
してください。ものすごく、ひどく退屈なら、「9」を指定するとよいでしょう。
まあやってみてください。

もう少し積極的に何かしたいなら、`M-x gomoku'を試してください。これは五
目並べのプログラムです。

  `M-x blackbox', `M-x mpuz' and `M-x 5x5' are kinds of puzzles.
`blackbox' challenges you to determine the location of objects inside
a box by tomography.  `mpuz' displays a multiplication puzzle with
letters standing for digits in a code that you must guess--to guess a
value, type a letter and then the digit you think it stands for.  The
aim of `5x5' is to fill in all the squares.  `M-x blackbox'と`M-x
mpuz'，`M-x 5x5' はパズルゲームです。`blackbox'は箱の中の物の位置を当て
るゲームです。`mpuz'は掛け算の覆面算で、英字に対応している数字を当てる
ゲームです。英字を打ってからその英字に対応していると思う数字を打ち込み
ます。 `5x5' は四角のすべてを埋めることです．

`M-x decipher' は単純なアルファベット置換で暗号化されたバッファを解読す
るのに役立ちます．

`M-x dunnet'はアドベンチャー風の探検ゲームで、大きなパズルだと思えばよ
いでしょう。

`M-x lm' は見るだけのゲームです．ロボットがウィンドウの中心にある木に向
かって4つの方向からの嗅覚の指示だけで動こうとするものです．

`M-x life' は Conway の人工生命シミュレーションを実行します．

`M-x morse-region' はリージョンのテキストをモールス信号にコンバートします．
`M-x unmorse-region' で解読します．No cause for remorse.

`M-x pong' はボールを対向したバットでバウンドさせるゲームです．

`M-x solitaire' は solitaire で遊べます．これは他のコマを飛び越して，コ
マをジャンプさせ，間のコマを消していくものです．

`M-x studlify-region' は以下のように一部を大文字にすることで，リージョ
ンをかっこよくします．

     M-x stUdlIfY-RegioN stUdlIfY-CaSeS thE region.

`M-x tetris' はテトリスとしてよく知られたゲームを実現します．同様に
`M-x snake' は Snake を実現します．

いらいらするときは、有名なElizaプログラムを試してみてください。`M-x
doctor'と打つだけです。1つの入力の終りにはRETを2回打ちます。

奇妙な感じがするときは、`M-x yow'と打ってみてください。

`M-x zone' は Emacs が待機状態の時に表示させるゲームです．



File: emacs-ja, Node: Customization, Next: Quitting, Prev: Amusements, Up: Top

カスタマイズ
************

本章では、Emacsの動作を（あまり大幅でなく）カスタマイズする方法に
ついて説明します。
もっと大幅な変更を行いたい場合には
`The Emacs Lisp Reference Manual'を参照してください。

カスタマイズは、Emacsの1つのセッションの中だけで効果を持ちます。
Emacsを終了するとカスタマイズの効果は失われますし、
同時にあるいはあとで別のEmacsを立ち上げた場合にも何の影響も及ぼしません。
あるEmacsのセッションがセッションを超えて影響するためには、
ファイルに書くしかありません。
特に、カスタマイズを『恒久化』したい場合には、
個人の`.emacs'ファイルや
その他の関連するファイルに適切な内容を書き込んでおき、
セッションごとにカスタマイズが行われるようにします。
*Note Init File::。

* Menu:

* Minor Modes::		Each minor mode is one feature you can turn on
			  independently of any others.
* Variables::		Many Emacs commands examine Emacs variables
			  to decide what to do; by setting variables,
			  you can control their functioning.
* Keyboard Macros::	A keyboard macro records a sequence of
			  keystrokes to be replayed with a single
			  command.
* Key Bindings::	The keymaps say what command each key runs.
			  By changing them, you can "redefine keys".
* Keyboard Translations::
                        If your keyboard passes an undesired code
			   for a key, you can tell Emacs to
			   substitute another code.
* Syntax::		The syntax table controls how words and
			   expressions are parsed.
* Init File::		How to write common customizations in the
			  `.emacs' file.



File: emacs-ja, Node: Minor Modes, Next: Key Bindings

マイナモード（minor mode）
==========================

マイナモードは、個別にオン／オフ可能な機能です。たとえば、マイナモード
である自動詰め込み（auto-fill）モードをオンにすると、SPCで自動的に（単
語の切れ目で）行分けします。すべてのマイナモードは互いに独立ですし、ど
のメジャーモードとも独立です。ほとんどのマイナモードは、それがオンであ
ることをモード行に表示します。たとえば、モード行に`Fill'と表示されてい
れば、自動詰め込み（auto-fill）モードがオンであることを意味します。

マイナモード名のうしろに`-mode'を付け加えると、そのモードをオン／オフす
るコマンド関数の名前になります。したがって、自動詰め込み（auto-fill）モー
ドをオン／オフするコマンドは`M-x auto-fill-mode'ということになります。
これらのコマンドは通常`M-x'を使って起動しますが、どれかのキーにバインド
することもできます。引数を指定しないと、これらのコマンドはモードがオフ
のときはオンに、オンのときはオフに切り替えます。これを"トグルする"と呼
びます。これに対し、正の引数を指定するとつねにモードをオンにしますし、
明示的に0の引数を指定するか、または負の引数を指定するとつねにモードをオ
フにします。

いくつかのマイナモードのオン／オフは、カレントバッファに対してのみ適用
され、他のバッファには影響しません。つまり、あるバッファであるモードを
オンにし、別のバッファではそのモードをオフにできるわけです。このような、
バッファごとにオン／オフできるマイナモードとしては、略語（abbrev）モー
ド、自動詰め込み（auto-fill）モード、自動保存（auto-save）モード、フォ
ントロック（font-lock）モード、ISOアクセント（iso-sccents）モード、アウ
トライン（outline）マイナモード、上書き（overwrite）モード、バイナリ上
書き（binary-overwrite）モードがあります。

略語（abbrev）モードでは、略語を打ち込むと自動的に展開されるような略語
を定義できます。たとえば、`amd'を`abbrev mode'と展開させます。詳しくは、
*Note Abbrevs::。

自動詰め込み（auto-fill）モードでは、いちいち改行で行分けしなくても
テキストを詰め込んで入力できます。
行が長くなりすぎないようにEmacsが適宜改行を挿入します。
*Note Filling::。

自動保存（auto-save）モードはバッファの内容を定期的に保存することで、
システムクラッシュが起きたとき紛失してしまう作業の量を少なくします。
*Note Auto Save::。

エンリッチ（enriched）モードは、整形済みテキストの編集を可能にします。
*Note Formatted Text::。

フライスペル（flyspell）モードは、綴りに誤りのある単語を自動的に強調表
示します。

フォントロック（font-lock）モードは、コメント、文字列、定義中の関数名などの
プログラム中の決まった単位を自動的に強調表示します。
これには、複数のフォントを表示できるウィンドウシステムが必要です。
*Note Faces::。

水平スクロール（hscroll）モードは、ポイントが画面内に留まるように、
自動的に水平スクロールを行います。
*Note Horizontal Scrolling::。

ISOアクセント（iso-accents）モードは、``'、`''、 `"'、
`^'、`/'、`~'とこれらに続くつぎの文字を結合して、
ISO Latin-1文字集合のアクセント付き文字を作り出します。
*Note Single-Byte European Support::。

アウトラインマイナ（outline-minor）モードは、メジャーモードである
アウトライン（outline）モードと同じ機能を提供します。
しかし、マイナモードなので任意のメジャーモードと一緒に使えます。
*Note Outline Mode::。

上書き（overwrite）モードでは、入力された図形文字は既存の文字を右に押し
やるかわりにその文字を置き換えます。たとえば、ポイントが`FOOBAR'の`B'の
まえにあるときに`G'を打つと`FOOGAR'となります。通常のモードであれば
`FOOGBAR'となります。上書き（overwrite）モードでコマンド`C-q'を打つと、
そのつぎの文字が何であっても（数字であっても）その文字を挿入します。つ
まり、上書き（overwrite）モードの中で文字を挿入するにはこの方法を使いま
す。

バイナリ上書き（binary-overwrite）モードは上書き（overwrite）モードの変
形で、バイナリファイル編集用です。このモードでは、改行やタブも他の文字
と同じに扱われるので、他の文字をこれらの文字で上書きすることも、これら
の文字を他の文字で上書きすることもできます。

以下で説明するマイナモードは、すべてのバッファに一斉に適用されます。
ただし、これらは変数の値に応じてオン／オフされますから、
その変数をバッファにローカルな変数にすれば、
バッファごとに独立にオン／オフすることも可能です。
*Note Locals::。

補完示唆（icomplete）モードは、ミニバッファで入力中に補完機能が働いているとき、
どのような補完候補があるかを表示します。
*Note Completion Options::。

行番号（line-number）モードは、
ポイントのある行の行番号を絶えずモード行に表示します。
*Note Mode Line::。

ミニバッファリサイズ（resize-minibuffer）モードは、
打ち込んだテキスト量に応じて自動的にミニバッファを広げます。
*Note Minibuffer Edit::。

スクロールバー（scroll-bar）モードは、各ウィンドウにスクロールバーを付
けます（*Note Scroll Bars::）。メニューバー（menu-bar）モードは、各フレー
ムにメニューバーを付けます（*Note Menu Bars::）。どちらのモードも、Xウィ
ンドウシステムを使っているときはデフォルトでオンになっています。

暫定マーク（transient-mark）モードでは、
バッファの内容を変更するとマークは『不活性』になるので、
そのあとでリージョンを対象とするコマンドを使うとエラーになります。
つまり、リージョンを対象とするコマンドを使うまえに、
改めてマークを設定するか、不活性になったマークを『再度活性』にします。
暫定マーク（transient-mark）モードの利点は、
（今のところXウィンドウシステムを使っているときのみ）
Emacsがリージョンを強調表示することです。
*Note Setting Mark::。

ほとんどのマイナモードには、コマンド名と同じ名前の変数があり、
その変数でモードを直接制御しています。
つまり、その変数の値が`nil'以外ならモードはオンであり、
各マイナモードコマンドは変数の値を設定する動作をします。
たとえば、コマンド`outline-minor-mode'は、
変数`outline-minor-mode'の値を設定する動作を行います。
つまり、この変数が、直接、上書き（overwrite）モードをオン／オフしているのです。
あるマイナモードがこのように動作するかどうかは、
`C-h v'を使ってその変数の説明文字列を参照してください。

これらのマイナモード変数は、Lispプログラムからモードをオン／オフするの
に有用です。また、ファイルのローカル変数リストとして指定するのも便利で
す。ただし、ローカル変数リストで設定する場合には、よく考えてください。
というのは、ほとんどのマイナモードはユーザーの好みの問題であり、同じファ
イルを編集する別のユーザーは好みが違うかもしれません。



File: emacs-ja, Node: Variables, Next: Key Bindings

変数
====

"変数"は値を持つLispシンボル（記号）です。そのシンボルの名前のことを、
変数名とも呼びます。変数名はファイルに入れられるどのような文字でも含む
ことができますが、習慣的には、変数名は英単語をハイフンでつなげたもので
す。変数には、その変数がどのような値を持ち、どのように使われるかを記述
した説明文字列を持たせることができます。

Lispではどの変数にどのような値でも格納できますが、Emacsの中ではほとんど
の変数はどのような値を持つかが決まっています。たとえば、ある変数はつね
に文字列である、別の変数は数値であるといった具合です。また、「これこれ
の機能はこの変数が`nil'以外のときにオンになる」といういい方もします。そ
の場合は、その変数に`nil'が格納されているときはその機能はオフですが、そ
れ以外の*どんな*値が格納されているときでもその機能はオンになります。で
すが、ある機能をオンにするために使う値として何か選ばなければなりません
から、`t'という値を使うのが習慣です。

Emacsは一般のLispプログラムと同様、内部で情報を保持するために数多くの変
数を使いますが、ユーザーにとって特に興味深い変数というのは、もっぱらカ
スタマイズ向けに用意された変数だといえます。Emacsは（通常は）そのような
変数の値を変更しません。かわりに、ユーザーが値を設定すると、その値に応
じてさまざまなEmacsコマンドのふるまいを変更したり制御したりできるのです。
これらの変数のことを"ユーザーオプション"といいます。ほとんどのユーザー
オプションはこのマニュアルに記載してありますし、変数索引（*Note
Variable Index::）にも記載してあります。

ユーザーオプションであるような変数の例として`fill-column'があります。こ
の変数は、詰め込みコマンド（*Note Filling::）が使う右端の桁位置を（左端
から何文字右かを表す数値として）保持します。

* Menu:

* Examining::	        Examining or setting one variable's value.
* Easy Customization::
                        Convenient and easy customization of variables.
* Hooks::	        Hook variables let you specify programs for parts
		          of Emacs to run on particular occasions.
* Locals::	        Per-buffer values of variables.
* File Variables::      How files can specify variable values.



File: emacs-ja, Node: Examining, Next: Easy Customization

変数の設定と参照
----------------

`C-h v VAR RET'
     変数VARの値と説明文字列を表示する（`describe-variable'）。
`M-x set-variable RET VAR RET VALUE RET'
     変数VARの値をVALUEに変更する。

特定の変数の値を見るには、`C-h v'（`describe-variables'）を使います。こ
のコマンドは、ミニバッファで補完機能付きで変数名を読み取ります。変数の
値と説明文字列の双方を表示します。たとえば、

     C-h v fill-column RET

とすると、つぎのように表示されます。

     fill-column's value is 75

     Documentation:
     *Column beyond which automatic line-wrapping should happen.
     Automatically becomes buffer-local when set in any fashion.

説明文の先頭にある`*'は、
この変数がユーザーオプションであることを示します。
`C-h v'は、ユーザーオプションに限らず任意の変数を扱えます。

ユーザーオプションを設定するいちばん簡単な方法は`M-x set-variable'を使
うことです。このコマンドは、まずミニバッファで（補完機能付きで）変数名
を読み取り、つぎにミニバッファで変数に設定するLisp式を読み取ります。た
とえば、

     M-x set-variable RET fill-column RET 75 RET

とすると、`fill-column'に75を設定します。

`M-x set-variable'はユーザーオプションに対してだけ使えます。これに対し、
`setq'を使えばどの変数にでも値が設定できます。たとえば、`setq'を使って
`fill-column'に設定するにはつぎのようにします。

     (setq fill-column 75)

このような式を実行するには、`*scratch*'バッファにいき、
式を打ち込んでから`C-j'を打ちます。
*Note Lisp Interaction::。

変数を設定することは、特記していない限り、他のカスタマイズ方法と同様に、
現在のEmacsセッションだけに影響します。



File: emacs-ja, Node: Easy Customization, Next: Hooks

簡便なカスタマイズ方法
----------------------

変更したいユーザーオプション変数をみつけて値を変更する便利な方法は、
`M-x customize'を使うことです。このコマンドは"カスタマイズバッファ"を作
成し、そのバッファ内では論理的な順序に並べたEmacsのユーザーオプションを
眺めてまわることができますし、さらに値を編集して設定できます。また、カ
スタマイズバッファを使えば設定を恒久的なものとして保存もできます。（ま
だこの機能で扱えないユーザーオプションもあるが、それらも扱えるように現
在作業中。）

* Menu:

* Groups: Customization Groups.
                             How options are classified in a structure.
* Changing an Option::       How to edit a value and set an option.
* Face Customization::       How to edit the attributes of a face.
* Specific Customization::   Making a customization buffer for specific
                                options, faces, or groups.



File: emacs-ja, Node: Customization Groups, Next: Changing an Option, Prev: Easy Customization, Up: Easy Customization

カスタマイズグループ
....................

カスタマイズのために、ユーザーオプションを"グループ"に
まとめてみつけやすくしてあります。
グループはさらに大きなグループにまとめられていて、
いちばん大きな（すべてのグループを含む）グループは
`Emacs'という名前です。

`M-x customize'は、トップレベルの`Emacs'グループおよびその直下の（第2レ
ベルの）グループを表示したカスタマイズバッファを作成します。その表示は
つぎのようになります。

     /- Emacs group: ---------------------------------------------------\
           [State]: visible group members are all at standard settings.
        Customization of the One True Editor.
        See also [Manual].

     Editing group: [Go to Group]
     Basic text editing facilities.

     External group: [Go to Group]
     Interfacing to external utilities.

     MORE SECOND-LEVEL GROUPS

     \- Emacs group end ------------------------------------------------/


この表示の先頭部分は、このバッファが`Emacs'グループの内容を表示している
ことを記しています。残りのグループが表示されるのは、それらが`Emacs'グルー
プに含まれているからです。ただし、それらは字下げや「-」なしで表示されて
いて、表示にはそれらのグループの内容が含まれては*いない*ことを示してい
ます。各グループの表示には1行の説明文字列が付随しています。また、
`Emacs'グループについては`[State]'行が付随しています。

カスタマイズバッファ内のテキストのほとんどは変更できませんが、一部分は
編集可能フィールド"になっていて、変更できます。また、"アクティブフィー
ルド"という、その場所を"起動"するとなんらかの動作を行うような場所もあり
ます。アクティブフィールドを起動するには、`Mouse-1'でそこをクリックする
か、またはそこにポイントを持っていってRETを打ちます。

たとえば、第2レベルグループ中の`[Go to Group]'と記された部分はアクティ
ブフィールドです。`[Go to Group]'のフィールドを起動すると、そのグループ
とそのグループの内容を表示する新しいカスタマイズバッファが作られ、その
グループと中身が表示されます。このフィールドは他のグループへのハイパー
テキストリンクの一種です。

`Emacs'グループそのものはユーザーオプションを1つも含んでいませんが、他
のグループにはあります。さまざまなグループを眺めてみると、興味を持って
カスタマイズしてみようと思うような機能に属するオプションやフェイスをみ
つけることができるでしょう。

カスタマイズグループ群の構造を概観するには、`M-x customize-browse'を使
います。このコマンドは、グループ名（とオプションやフェイス）とそれらの
構造だけを表示する特別なカスタマイズバッファを作ります。

このバッファ中では、グループの中身を見るには`[+]'のところを起動します。
グループの中身が見えるようになると、このボタンは`[-]'に変わります。これ
を起動すると中身を（もとどおり）隠します。

各グループ、オプション、フェイスにはそれぞれ`[Group]'、`[Option]'、
`[Face]'と記されたアクティブフィールドがあります。それらを起動すると、
そのグループ／オプション／フェイスのみを表示した通常のカスタマイズバッ
ファが作成されます。そのバッファで値を設定します。



File: emacs-ja, Node: Changing an Option, Next: Face Customization, Prev: Easy Customization, Up: Easy Customization

オプションの変更
................

カスタマイズバッファでユーザーオプションがどのように見えるか、例をあげ
ましょう。

     Kill Ring Max: [Hide] 30
        [State]: this option is unchanged from its standard setting.
     Maximum length of kill ring before oldest elements are thrown away.

`[Hide]'に続くテキスト、つまり、`30'がオプションの現在の値を
示しています。
`[Hide]'ではなく`[Show]'と表示されていれば、
値は隠されています。
カスタマイズバッファでは、複数行にわたるような値は最初は隠されていて、
`[Show]'を起動すると表示されます。

オプション名に続く行はオプションの"カスタマイズ状態"を示しています。上
の例では、まだ変更していないと表示されています。行頭の`[State]'のところ
がアクティブフィールドで、ここを`Mouse-1'かRETで起動するとさまざまな操
作を示すメニューが表示されます。これらの操作は変数をカスタマイズするう
えでとても重要です。

`[State]'のつぎの行には、そのオプションの説明文字列の先頭部分が表示され
ます。1行に収まらない場合には、行末に`[More]'と表示されます。これを起動
すると説明文字列全体が表示されます。

`Kill Ring Max'に新しい値を設定するには、ポイントを値の位置へ持っていっ
て直接文字列を変更します。たとえば、`M-d'で現在の値を削除してから、設定
する数値を打ち込めばよいのです。

文字列を変更し始めると、`[State]'行の表示が変わって、値が編集されている
ことを示すようになります。

     [State]: you have edited the value as text, but not set the option.

文字列を変更しただけでは、まだオプション変数の値は設定されません。
値を"設定する"には、`[State]'のところを起動して、
`Set for Current Session'を選択します。

値を設定すると、オプションの状態表示も対応して変わります。

     [State]: you have set this option, but not saved it for future sessions.

正しくない値を設定してしまう心配はありません。というのは、オプションの
設定時には、値の正しさを検査して、正しくない値は設定できないようになっ
ています。

ディレクトリ名、ファイル名、コマンド名である値やフィールドを編集するとき、
および、その他何であれ補完が定義されているものを編集するときは、
`M-TAB'（`widget-complete'）を打てば補完できます。

いくつかのオプションでは、正しい値としては決まった少数のものだけを使え
ます。そのようなオプションは、テキストとしては編集できません。かわりに
`[Value Menu]'というアクティブフィールドが値のまえに現れます。『オンか
オフ』だけの真偽値を持つオプションでは、アクティブフィールドは
`[Toggle]'と表示されていて、そこを起動するたびに値を反転できます。
`[Value Menu]'も`[Toggle]'もバッファを変更するだけです。値が実際に設定
されるのは`Set for Current Session'を起動したときです。

いくつかのオプションは、込み入った構造の値を持ちます。たとえば、
`load-path'は値としてディレクトリのリストを持ちます。これをカスタマイズ
バッファに表示すると、つぎのようになります。

     Load Path:
     [INS] [DEL] [Current dir?]: /usr/local/share/emacs/20.3/site-lisp
     [INS] [DEL] [Current dir?]: /usr/local/share/emacs/site-lisp
     [INS] [DEL] [Current dir?]: /usr/local/share/emacs/20.3/leim
     [INS] [DEL] [Current dir?]: /usr/local/share/emacs/20.3/lisp
     [INS] [DEL] [Current dir?]: /build/emacs/e20/lisp
     [INS] [DEL] [Current dir?]: /build/emacs/e20/lisp/gnus
     [INS]
        [State]: this item has been changed outside the customization buffer.
     List of directories to search for files to load....

リスト中の各ディレクトリがそれぞれ別の行に表示され、各行にはいくつかの
編集可能／アクティブフィールドがあります。

どのディレクトリ名も直接編集できます。リストからディレクトリを削除する
には、その行の`[DEL]'を起動します。リストに新しいディレクトリを追加する
には、挿入したい箇所の`[INS]'を起動します。

`[Current dir?]'を起動すると、パスに特定のディレクトリを含めるのか、ま
たは、`nil'を含めるのかを切り替えられます。（探索パスにおける`nil'は、
『カレントディレクトリを探せ』という意味。）

2つの特別なコマンド、TABと`S-TAB'は、カスタマイズバッファ内での移動に役
立ちます。TAB（`widget-forward'）はつぎのアクティブ／編集可能フィールド
へ移動します。`S-TAB'（`widget-backward'）は、1つまえのアクティブ／編集
可能フィールドへ移動します。

編集可能フィールドでRETを打つと、
TABと同様につぎのフィールドへ進みます。
なぜそうなっているかというと、編集可能フィールドを
編集し終えると最後にRETを打つ人が多いからです。
編集可能フィールドに改行文字を入るには、
`C-o'か`C-q C-j'と打ちます。

オプションを設定すると、その値は現在のEmacsセッションだけに有効です。
その値を"保存"すると、将来のセッションでも有効になります。
保存を行うと、個人の`~/.emacs'ファイルにコードが追加されて、
つぎにEmacsを起動したときにオプション変数の値を設定するようになります。
オプションを保存するには、`[State]'を起動して
`Save for Future Sessions'を選びます。

オプションを標準値に戻したければ、`[State]'を起動して`Reset to
Standard Settings'を選びます。実際にはつぎの3種類のリセット操作がありま
す。

`Reset'
     なんらかの修正を行ったが、まだオプションを設定していなければ、この
     操作により、カスタマイズバッファ上のテキストをオプションの現在値と
     一致させられる。

`Reset to Saved'
     この操作では、オプションの値を最後に保存した値に戻し、カスタマイズ
     バッファ上のテキストもその値に合わせる。

`Reset to Standard Settings'
     この操作では、オプションを標準値に設定し、カスタマイズバッファ上の
     テキストもその値に合わせる。さらに、以前にそのオプションについて保
     存した値もすべてもとに戻されるので、将来のEmacsセッションでもすべ
     て標準値が使われるようになる。

グループの`[State]'はそのグループに属するもののどれかが編集された／設定
された／保存されたことを示します。`Set for Current Session'、`Save for
Future Sessions'、および各種の`Reset'をグループ全体に対して適用できます。
これらの操作はグループおよびそのサブグループに属するすべてのオプション
に対して適用されます。

カスタマイズバッファの先頭付近には、いくつかのアクティブフィールドを含
んだつぎのような行があります。

      [Set for Current Session] [Save for Future Sessions]
      [Reset] [Reset to Saved] [Reset to Standard]   [Bury Buffer]

`[Bury Buffer]'を起動すると、カスタマイズバッファを消します。他のフィー
ルドは、そのバッファに含まれている項目それぞれについてそれぞれ、設定、
保存、リセットを（それらの操作が適用可能なら）実行します。



File: emacs-ja, Node: Face Customization, Next: Specific Customization, Prev: Changing an Option, Up: Easy Customization

フェイスのカスタマイズ
......................

いくつかのカスタマイズグループは、ユーザーオプションに加えてフェイスも
含みます。グループの内容を表示したとき、オプションとフェイスの両方がカ
スタマイズバッファに現れます。フェイスの見え方は、たとえばつぎのように
なります。

     Custom Changed Face: (sample)
        [State]: this face is unchanged from its standard setting.
     Face used when the customize item has been changed.
     Attributes: [ ] Bold: [toggle] off
                 [X] Italic: [toggle] on
                 [ ] Underline: [toggle] off
                 [ ] Inverse-Video: [toggle] on
                 [ ] Foreground: black (sample)
                 [ ] Background: white (sample)
                 [ ] Stipple:

フェイスの各属性はそれぞれが1行を占めます。属性のまえの`[X]'というフィー
ルドは、その属性が"オンになっている"かどうかを表示しています。`X'が表示
されていればオンになっています。そのフィールドを起動することでオン／オ
フを反転できます。属性がオンになっている場合は、その属性の値をオプショ
ンと同様にして変更できす。

白黒ディスプレイでは、背景に設定可能な表示色は`black'、`white'、`gray'、
`gray1'、`gray3'のいずれかです。Emacsは表示色のかわりにドットパターンで
灰色の階調を表します。

フェイスを設定／保存／リセットするのは、オプションと同様にしてできます
（*Note Changing an Option::）。

フェイスでは、ディスプレイの種別ごとに異なる見え方を指定できます。
たとえば、あるフェイスをカラーディスプレイでは赤で表示し、
白黒ディスプレイではかわりにボールド体で表示するようにできます。
あるフェイスに複数の見え方を指定するには、
`[State]'メニューを表示させて`Show Display Types'を選びます。

フェイスの属性を設定するもっと基本的な方法は、`M-x modify-face'を使うこ
とです。このコマンドは、まずフェイスの名前を聞いてきて、続いて属性を1つ
ずつ順に聞いてきます。表示色やパターンの属性では、その属性の現在の値が
デフォルトになっています。これらを変更したくなければ、単に、RETを打てば
よいのです。属性を空にしたければ`none'と打ちます。



