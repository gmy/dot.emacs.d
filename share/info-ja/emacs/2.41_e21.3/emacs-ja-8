Info file: emacs-ja,    -*-Text-*-
produced by `texinfo-format-buffer'
from file `emacs.texi'
using `texinfmt.el' version 2.41 of  1 Mar 2005.

INFO-DIR-SECTION Emacs
START-INFO-DIR-ENTRY
* Emacs-ja: (emacs-ja).	            Emacs21.3日本語マニュアル.
END-INFO-DIR-ENTRY








File: emacs-ja  Node: Outline Visibility-Footnotes, Up: Outline Visibility

(1) 【訳注】ポイントが本体行にあっても動作する。

(2) 【訳注】ポイントが本体行にあっても動作し、結果も同じ。

(3) 【訳注】抜けると、また不可視にもどってしまう。



File: emacs-ja, Node: Outline Views, Prev: Outline Visibility, Up: Outline Mode

複数の視点からアウトラインを眺める
----------------------------------
1つのアウトライン構造を同時に2つの視点から別々のウィンドウに表示して
眺めることができます。
それには、`M-x make-indirect-buffer'を使って
間接バッファを作成する必要があります。
このコマンドの最初の引数は、既存のアウトライン用バッファの名前で、
2番目の引数は新たに作成する間接バッファの名前です。
*Note Indirect Buffers::。

間接バッファがあるならば、`C-x 4 b'や他のEmacsコマンドで普通にそのバッ
ファをウィンドウに表示できます。テキストの一部を可視／不可視にするアウ
トライン（outline）モードのコマンドは、各バッファで独立に働きます。その
結果、各バッファごとに独自の視点を持たせることが可能です。同じアウトラ
インに対して3つ以上の視点が必要ならば、間接バッファをさらに作成してくだ
さい。



File: emacs-ja, Node: TeX Mode, Next: Nroff Mode, Prev: Outline Mode, Up: Text

TeXモード
=========

TeXは、Donald Knuthが作成した強力な清書系です。しかも、GNU Emacsと同じ
くフリーです。LaTeXは、TeXの入力形式を単純化したもので、TeXのマクロで実
現されています。これもTeXに付属しています。SliTeXはスライドを作成するた
めにLaTeXを特殊化したものです。

Emacsには、TeXの入力ファイルを編集するための特別なTeXモードがあります。
このモードには、区切りの対応を検査したり、ファイル全体やその一部に対し
てTeXを起動したりする機能があります。

TeXモードには3つの変種があります。それぞれ、プレインTeX（plain-tex）モー
ド、LaTeX（latex）モード、SliTeX（slitex）モードです（これら3つはメジャー
モードですが、差異はわずか）。これらのモードは、異なる3つの入力形式を編
集するように設計されています。コマンド`M-x tex-mode'は、バッファ内の内
容を調べて、LaTeXの入力なのかSliTeXの入力なのか判断します。そのいずれか
であれば、それに適したモードを選択します。ファイルの中身がLaTeXでも
SliTeXでもなさそうであれば、プレインTeX（plain-tex）モードを選択します。
ファイルの内容が判断するに十分でなければ、変数`tex-default-mode'で使用
するモードを制御します。

`M-x tex-mode'が適切なモードを推測できなかった場合には、
コマンド`M-x plain-tex-mode'、`M-x latex-mode'、
`M-x slitex-mode'で明示的にTeXの変種を選択できます。

* Menu:

* Editing: TeX Editing.   Special commands for editing in TeX mode.
* LaTeX: LaTeX Editing.   Additional commands for LaTeX input files.
* Printing: TeX Print.    Commands for printing part of a file with TeX.



File: emacs-ja, Node: TeX Editing, Next: LaTeX Editing, Prev: TeX Mode, Up: TeX Mode

TeX編集コマンド
---------------

ここでは、TeXの入力ファイルのテキストを編集するために
TeXモードに用意してある特別なコマンドについて述べます。

`"'
     文脈に応じて`"'、`"'、`"'を挿入する（`tex-insert-quote'）。
`C-j'
     段落区切り（空行を2つ）を挿入し、まえの段落の中括弧やドル記号の対
     応を検査する（`tex-terminate-paragraph'）。
`M-x tex-validate-region'
     リージョン内の各段落に対して、中括弧やドル記号の対応を検査する。
`C-c {'
     `{}'を挿入して、そのあいだにポイントを移動する
     （`tex-insert-braces'）。
`C-c }'
     対応が取れていないつぎの閉じ中括弧のあとに前向きにポイントを移動す
     る（`up-list'）。

TeXでは、文字`"'はまず使いません。引用を始めるには`"'を、終るには`"'を
使います。こういったテキスト整形上の規則の下で編集作業を楽にするために、
TeXモードでは``'と`''を対で挿入する（`tex-insert-quote'）ようにキー`"'
の意味を変えています。より正確にいえば、このコマンドは白文字や開き中括
弧のあとでは`"'を、バックスラッシュのあとでは`"'を、これ以外の文字のあ
とでは`"'を挿入します。

特別な文脈で`"'文字が必要であれば、`C-q'を使って挿入します。
また、`"'に数引数を指定すると、その個数分の`"'を入力します。
ローカルマップからバインディング（*Note Key Bindings::）を取り除けば、
`"'を展開する機能をオフにできます。

TeXモードでは、`$'にはTeXの数式モードの区切りの対応を確認するための特別
な構文コードが設定されています。数式モード終了を意味する`$'を挿入すると、
それに対応した数式モード開始の`$'を1秒間ほど表示します。これは、閉じ中
括弧を挿入すると、それに対応する開き中括弧を表示する機能と同じです。し
かし、`$'が数式モードを開始するものか終了するものかを知る方法がありませ
ん。したがって、数式モード開始の`$'を挿入しても、たとえ実際には無関係で
あっても、まえにある`$'が対応しているかのように表示されてしまいます。

TeXは、中括弧を必ず対応が取れている区切りとして使います。ユーザーの中に
は、中括弧を別々に入力するよりも、つねに対応が取れている中括弧の入力を
好む人もいます。`C-c {'（`tex-insert-braces'）と打てば中括弧の対を挿入
できます。さらに、ポイントがそれらのあいだに置かれるので、中括弧の内側
にテキストを挿入できます。そのあとに、コマンド`C-c }'（`up-list'）を使っ
て、閉じ中括弧のうしろに移動します。

中括弧の対応を調べるコマンドは2つあります。
`C-j'（`tex-terminate-paragraph'）は、ポイントの直前の段落を検査してか
ら、新たな段落を始める空行を2つ挿入します。対応していない中括弧があれば、
エコー領域にメッセージを表示します。`M-x tex-validate-region'は、リージョ
ンの段落を1つ1つ検査します。エラーはバッファ`*Occur*'に表示されます。こ
のバッファで`C-c C-c'や`Mouse-2'を使えば、特定の非対応箇所へ移動できま
す。

TeXモードでは、Emacsコマンドは中括弧だけでなく、括弧（`()'）や角括弧
（`[]'）も数えています。これは、TeXの構文を検査する目的からいえば、厳密
には正しくありません。しかし、括弧や角括弧はテキスト内で対応する区切り
としてよく使われますし、各種の移動コマンドや対応関係を自動表示するコマ
ンドがそれらを扱えると便利です。



File: emacs-ja, Node: LaTeX Editing, Next: TeX Print, Prev: TeX Editing, Up: TeX Mode

LaTeX編集コマンド
-----------------

LaTeXモードと、その変種のSliTeX モードには、プレインTeX（plain-tex）で
は利用できない特別な機能がいくつかあります。

`C-c C-o'
     LaTeXのブロックを表す`\begin'と`\end'を挿入し、それらのあいだにポ
     イントを置く（`tex-latex-block'）。
`C-c C-e'
     まだ閉じていないもっとも内側のLaTeXのブロックを閉じる
     （`tex-close-latex-block'）。

LaTeXの入力では、`\begin'と`\end'がテキストのブロックをグループ化するた
めに使われます。`\begin'と対応する`\end'を（`\begin'のつぎの新しい行に）
挿入するには、`C-c C-o'（`tex-latex-block'）を使います。それらのあいだ
には空行が挿入されてポイントもそこに置かれます。ブロックの種類を入力す
るときには、補完を使えます。標準のリストに含まれないブロック名を使う場
合には、変数`latex-block-names'に設定します。つぎの例は、`theorem'、
`corollary'、`proof'を追加するものです。

     (setq latex-block-names '("theorem" "corollary" "proof"))

LaTeXの入力では、`\begin'と`\end'は対応が取れている必要があります。
`C-c C-e'（`tex-close-latex-block'）を使うと、対応が取れていない最後の
`\begin'に対応する`\end'を自動的に挿入できます。また、対応する`\begin'
と同じ字下げを`\end'にも施します。ポイントが行頭にあったときには、
`\end'のうしろで改行します。



File: emacs-ja, Node: TeX Print, Prev: LaTeX Editing, Up: TeX Mode

TeX印刷コマンド
---------------

バッファ全体あるいは一部のテキストに対して、Emacsの下位プロセスとして
TeXを起動できます。特定の章だけに対してこのようにTeXを実行するのは、ファ
イル全体の清書に時間を費すことなく、変更部分の見え方を確認するよい方法
です。

`C-c C-r'
     バッファのヘッダとともに、カレントリージョンに対してTeXを起動する
     （`tex-region'）。
`C-c C-b'
     カレントバッファ全体に対してTeXを起動する（`tex-buffer'）。
`C-c TAB'
     現在のファイルに対してBibTeXを起動する（`tex-bibtex-file'）。
`C-c C-f'
     現在のファイルに対してTeXを起動する（`tex-file'）。
`C-c C-l'
     下位プロセスであるTeXの出力を表示したウィンドウをスクロールして、
     出力行の最後が見えるようにする（`tex-recenter-output-buffer'）。
`C-c C-k'
     TeXのサブプロセスを終了させる（`tex-kill-job'）。
`C-c C-p'
     最後に実行した`C-c C-r'、`C-c C-b'、`C-c C-f'の出力を印刷する。
     （`tex-print'）。
`C-c C-v'
     最後に実行した`C-c C-r'、`C-c C-b'、`C-c C-f'の出力をプレビューす
     る（`tex-view'）。
`C-c C-q'
     プリンタキューを表示する（`tex-show-print-queue'）。

`C-c C-b'（`tex-buffer'）を使えば、
カレントバッファの内容を下位のTeXに渡すことができます。
清書結果は一時ファイルに出力されます。
それを印刷するには、`C-c C-p'（`tex-print'）と打ちます。
そのあとで、印刷の進捗状況を確認するには
`C-c C-q'（`tex-show-print-queue'）を利用できます。
TeXの出力ファイルを表示する機能を持った端末があれば、
`C-c C-v'（`tex-view'）でプレビューできます。

TeXが実行時に使うディレクトリを指定するには、変数`tex-directory'に設定
します。デフォルトの値は`"."'です。環境変数`TEXINPUTS'に相対的なディレ
クトリ名が入っていたり、TeXの`\input'コマンドに相対的なファイル名を指定
してある場合には、`tex-directory'は`"."'である*必要*があります。さもな
いと、誤った結果になるでしょう。そういった状況でなければ、`"/tmp"'のよ
うな、他のディレクトリを設定しても安全です。

下位のTeXを起動するために使うコマンドを指定したければ、変数
`tex-run-command'、`latex-run-command'、`slitex-run-command'、
`tex-dvi-print-command'、`tex-dvi-view-command'、
`tex-show-queue-command'にそれぞれ値を設定します。
`tex-dvi-view-command'にはデフォルト値がないので、使用する端末にあわせ
た値を設定する*必要*があります。これ以外の変数には、使用するシステムに
適切と思われる（そうでないかもしれないが）デフォルト値が設定されていま
す。

通常は、これらのコマンドに与えるファイル名はコマンド文字列の最後にきま
す。たとえば、`latex FILENAME'です。しかし、ときにはコマンドの途中にファ
イル名を埋め込む必要があります。たとえば、パイプを介して出力を他のコマ
ンドに渡すようなコマンドの引数にファイル名を指定する場合です。ファイル
名を置く箇所は、コマンド文字列中の`*'で指定できます。たとえば、以下のよ
うに設定します。

     (setq tex-dvi-print-command "dvips -f * | lpr")

エラーメッセージを含めたTeXからの端末出力は、`*tex-shell*'と呼ばれるバッ
ファにすべて現れます。TeXがエラーを報告した場合には、このバッファに切り
替えれば適切な入力を与えることができます（これはシェル（shell）モードと
同様に動作する。*Note Interactive Shell::）。このバッファに切り替えなく
ても`C-c C-l'と打てば、バッファの最後の行が表示されるようにスクロールで
きます。

TeXの出力が不要となったら、TeXプロセスを終了させるために`C-c
C-k'（`tex-kill-job'）と打ちます。`C-c C-b'や`C-c C-r'を使っても、動作
中のTeXプロセスを終了できます。

`C-c C-r'（`tex-region'）と打てば、任意のリージョンを下位のTeXに渡せま
す。しかし、これには少々巧妙な手口を必要とします。というのは、たいてい
の場合、TeXの入力ファイルの先頭部分にはパラメータの設定やマクロ定義があ
り、それらがないと残りの部分を正しく清書できないからです。この問題を解
決するために、`C-c C-r'ではファイルの中で必須の整形コマンドを含んでいる
部分を指定できます。リージョンのまえにその部分を加えてTeXへの入力としま
す。ファイル中の必須であると指定された部分を"ヘッダ"と呼びます。

プレインTeX（plain-tex）モードでヘッダの境界を示すには、
ファイルに2つの特別な文字列を挿入します。
ヘッダの直前に`%**start of header'を、
ヘッダの直後に`%**end of header'を挿入します。
どちらの文字列も2行にまたがってはいけませんが、
前後に別のテキストがあってもかまいません。
これらの文字列を持つ行もヘッダに含まれます。
バッファの先頭から100行以内に`%**start of header'が現れなければ、
`C-c C-r'はヘッダがないと仮定します。

LaTeXモードでは、`\documentstyle'で始まり`\begin{document}'で終わる部分
がヘッダです。これらは、いかなる場合でもLaTeXが要求するコマンドなので、
ヘッダを認識するために特別なことをする必要はありません。

コマンド`tex-buffer'と`tex-region'は、一時的なディレクトリ上ですべての
作業を行うので、相互参照のためにTeXが必要とする補助ファイルを使用できま
せん。一般に、これらのコマンドは、相互参照がすべて正しい必要がある最終
的な原稿の作成には適していません。

相互参照のための補助ファイルを必要とする場合には、
カレントバッファのファイルを入力として、そのファイルを置いたディレクトリで
TeXを実行する`C-c C-f'（`tex-file'）を使います。
TeXを実行するまえに、変更したすべてのバッファを保存するか尋ねてきます。
一般には、正しい相互参照を得るためには、
`tex-file'を2度実行する必要があります。

変数`tex-start-options-string'の値は、
TeXの実行のオプションを指定します。
デフォルト値は、TeXをバッチモードで実行します。
TeXを対話的に実行するには、変数に`""'を設定します。

巨大なTeX文書は、複数のファイル、つまり、1つのメインファイルとサブファ
イルとに分割されることがよくあります。サブファイルに対してTeXを実行して
も、うまくいくことはまずありません。メインファイルに対してTeXを実行する
必要があります。サブファイルを編集する場合でも`tex-file'を使えるように、
メインファイルの名前を変数`tex-main-file'に設定できます。そうすると
`tex-file'はそのファイルに対してTeXを実行します。

`tex-main-file'のもっとも便利な使い方は、
各サブファイルのローカル変数リストで指定することです。
*Note File Variables::。

LaTeX用ファイルであれば、カレントバッファのファイルに対する補助ファイル
を処理するためにBibTeXを使えます。BibTeXは、参考文献をデータベースで調
べて、参考文献の節のための文献リストを準備します。コマンド`C-c
TAB'（`tex-bibtex-file'）は、カレントバッファのファイルに対する`.bbl'ファ
イルを生成するためのシェルコマンド（`tex-bibtex-command'）を実行します。
通常は、まず`.aux'ファイルを作るために`C-c C-f'（`tex-file'）を一度実行
してから、つぎに`C-c TAB'（`tex-bibtex-file'）を実行し、正しい相互参照
を得るために`C-c C-f'（`tex-file'）をさらに2回実行します。

どのTeXモードに入っても、
フック`text-mode-hook'と`tex-mode-hook'を実行します。
そのあとで、
`plain-tex-mode-hook'か`latex-mode-hook'の適切なフックを実行します。
SliTeXファイルに対しては、`slitex-mode-hook'を呼びます。
TeX用のシェルの開始時には、フック`tex-shell-hook'を実行します。
*Note Hooks::。



File: emacs-ja, Node: Nroff Mode, Next: Formatted Text, Prev: TeX Mode, Up: Text

nroffモード
===========

nroffモードはテキスト（text）モードに似ていますが、テキスト中のnroffコ
マンドを扱えるように変更してあります。このモードに入るには、`M-x
nroff-mode'を実行します。テキスト（text）モードとは、2、3の点で異なるだ
けです。nroffコマンドを含んだ行は、すべて段落区切りとみなすので、詰め込
みによってnroffコマンドが本文に混ざってしまうことはありません。ページは
`.bp'コマンドで分割されます。コメントは`.\"'で始まります。また、テキス
ト（text）モードにはない、つぎの3つの特別なコマンドがあります。

`M-n'
     nroffコマンドではないつぎの行の先頭にポイントを移動する
     （`forward-text-line'）。引数は反復回数。
`M-p'
     `M-n'と同様だが、まえの行に移動する（`backward-text-line'）。
`M-?'
     リージョン中のテキスト（nroffコマンド以外）の行数をエコー領域に表
     示する（`count-text-lines'）。

nroffモードの他の機能としては、エレクトリックnroff（electric-nroff）モー
ドがあります。これは`M-x electric-nroff-mode'でオン／オフできるマイナモー
ドです（*Note Minor Modes::）。このモードがオンのとき、グループを始める
nroffコマンドを含む行を終えるためにRET (1) (*Note Nroff
Mode-Footnotes::)を打つたびに、そのグループを終える対応したnroffコマン
ドを自動的につぎの行に挿入します。たとえば、行頭で`. ( b RET'と打つと、
ポイントのうしろに新たな行として対応するnroffコマンド`.)b'を挿入します。

nroffモードと一緒にアウトラインマイナ（outline-minor）モード（*Note
Outline Mode::）を使用すると、見出し行は`.H'のあとに（見出しのレベルに
あたる）数字が続く形になります。

nroffモードに入ると、フック`text-mode-hook'に続いてフック
`nroff-mode-hook'が実行されます（*Note Hooks::）。


File: emacs-ja  Node: Nroff Mode-Footnotes, Up: Nroff Mode

(1) 【訳注】実際には`C-j'。



File: emacs-ja, Node: Formatted Text, Prev: Nroff Mode, Up: Text

整形済みテキストの編集
======================

"エンリッチ（enriched）モード"は、ワープロのようにWYSIWYG方式で、整形済
みテキストを含むファイルの編集を行うためのマイナモードです。現在のとこ
ろ、エンリッチ（enriched）モードの整形済みテキストには、フォント、表示
色、下線、左右端、詰め込みと幅揃えの種類を指定できます。将来的には、そ
の他の整形機能も実装しようと計画しています。

エンリッチ（enriched）モードはマイナモードです（*Note Minor Modes::）。
通常は、テキスト（text）モードと一緒に使います（*Note Text Mode::）。し
かしながら、アウトライン（outline）モードや段落字下げ型テキスト
（paragraph-indent-text）モードのような他のメジャーモードと一緒に使うこ
とも可能です。

Emacsは能力的には整形済みテキストのファイルをさまざまなファイル形式で格
納することができす。現在のところは、1種類の形式のみ、つまり、MIMEプロト
コルで定義された"text/enriched"形式のみを実装してあります。Emacsがどの
ようにファイルの形式を識別し変換するかの詳細に関しては*Note ファイル書
式変換: (elisp)Format Conversion。

Emacsの配布の中には、実例として整形済みテキストファイル
`etc/enriched.doc'があります。このファイルには、本節で説明するすべての
機能の実例が盛り込まれています。また、将来の拡張に関するアイデアも述べ
てあります。

* Menu:

* Requesting Formatted Text::   Entering and exiting Enriched mode.
* Hard and Soft Newlines::      There are two different kinds of newlines.
* Editing Format Info::         How to edit text properties.
* Faces: Format Faces.          Bold, italic, underline, etc.
* Color: Format Colors.         Changing the color of text.
* Indent: Format Indentation.   Changing the left and right margins.
* Justification: Format Justification.
                                Centering, setting text flush with the
                                  left or right margin, etc.
* Other: Format Properties.     The "special" text properties submenu.
* Forcing Enriched Mode::       How to force use of Enriched mode.



File: emacs-ja, Node: Requesting Formatted Text, Next: Hard and Soft Newlines, Prev: Formatted Text, Up: Formatted Text

整形済みテキストの編集
----------------------

text/enriched形式でEmacsが保存したファイルを訪れると、Emacsは自動的にファ
イル中の整形情報をEmacs自身の内部形式（テキスト属性）に変換し、エンリッ
チ（enriched）モードをオンにします。

新たに整形済みテキストファイルを作成するには、まず、存在しないファイル
を訪れてから、テキストを入力するまえに`M-x enriched-mode'と打ちます。こ
のコマンドはエンリッチ（enriched）モードをオンにします。入力されるテキ
ストが正しく扱われることを保証するために、テキストを挿入するまえにエン
リッチ（enriched）モードをオンにしてください。

より一般的にいえば、コマンド`enriched-mode'は、エンリッチ（enriched）モー
ドがオフならオン、オンならオフにします。数引数を指定すると、それが正で
あればエンリッチ（enriched）モードをオンにし、それ以外ではオフにします。

エンリッチ（enriched）モードがオンのときにバッファを保存すると、Emacsは
テキストをファイルに書き出すときに自動的にtext/enriched形式へ変換します。
ふたたびそのファイルを訪問すると、Emacsは自動的にその形式を認識してテキ
ストを変換し、エンリッチ（enriched）モードをオンにします。

通常、text/enriched形式のファイルを訪問すると、Emacsは各段落を指定され
た右端に納まるように詰め込みます。この詰め込みをやめて時間を短縮するた
めに、変数`enriched-fill-after-visiting'に`nil'か`ask'を設定します。

しかし、エンリッチ（enriched）モードで保存したファイルを訪問するときに
は、Emacsは右端の設定をテキストと一緒に保存しているので、テキストを再度
詰め込む必要はありません。

通常はEmacsが保存しないテキスト属性に対する注記（annotation）も保存する
ようにするには、変数`enriched-translations'に追加しておきます。
text/enriched規格では、非標準の注記には、`x-read-only'のように`x-'で始
まる名前が必要なことに注目してください。これによって、あとから追加され
る標準的な注記と名前が衝突しないことが保証されます。



File: emacs-ja, Node: Hard and Soft Newlines, Next: Editing Format Info, Prev: Requesting Formatted Text, Up: Formatted Text

ハード改行とソフト改行
----------------------

Emacsは整形済みテキスト中の改行を、
"ハード"改行と"ソフト"改行の2種類に区別します。

ハード改行は、段落の区切り、リスト内の項目、左右端に関係なく行分割がつ
ねに必要な箇所に用いられます。RETコマンド（`newline'）と
`C-o'（`open-line'）はハード改行を挿入します。

ソフト改行は、テキストを左右端のあいだに納めるために使用されます。自動
詰め込み（auto-fill）モードを含めたすべての詰め込みコマンドはソフト改行
を挿入し、ソフト改行だけを削除します。

ハード改行とソフト改行は見た目は同じですが、違いを理解することは重要です。
詰め込んだ段落の途中で行に分割するときにRETを使ってはいけません。
あとの詰め込みの妨げとなるハード改行を挿入してしまいます。
かわりに、自動詰め込み（auto-fill）モードに行分割を行わせて、
テキストや左右端が変化してもEmacsが適切に再度詰め込めるようにします。
*Note Auto Fill::。

一方、表やリストのように、入力したとおりの行にしておく必要がある場合には、
RETで行を終えます。
これらの行では、幅揃えのスタイルとして`unfilled'を
指定するのもよいかもしれません。
*Note Format Justification::。



File: emacs-ja, Node: Editing Format Info, Next: Format Faces, Prev: Hard and Soft Newlines, Up: Formatted Text

整形情報の編集
--------------

整形済みテキストファイルの整形情報を変更するには、2つの方法があります。
キーボードコマンドを使うか、マウスを使います。

文書に属性を追加するもっとも簡単な方法は、Text Propertiesメニューを使用
することです。このメニューを出すには2つの方法があります。メニューバーの
Editメニューから選択するか、`C-mouse-2'（CTRLキーを押し下げたままマウス
の真中のボタンを押す）です。

Text Propertiesメニューのほとんどの項目には、別のサブメニューがついてい
ます。これらについては後述します。コマンドを直接実行する項目もあります。

`Remove Properties'
     Text Propertiesメニューで扱えるすべてのテキスト属性をリージョンか
     ら取り除く（`facemenu-remove-props'）。

`Remove All'
     *すべて*のテキスト属性をリージョンから取り除く
     （`facemenu-remove-all'）。

`List Properties'
     ポイント直後の文字のすべてのテキスト属性を表示する
     （`list-text-properties-at'）。

`Display Faces'
     定義済みフェイス一覧を表示する。

`Display Colors'
     定義済み表示色一覧を表示する。



File: emacs-ja, Node: Format Faces, Next: Format Colors, Prev: Editing Format Info, Up: Formatted Text

整形済みテキストのフェイス
--------------------------

Facesサブメニューには、`bold'、`italic'、`underline'といったEmacsで使用
できる各種フェイスが並んでいます。その中から1つを選ぶと、リージョンにフェ
イスを追加します。*Note Faces::。以下のキーボードコマンドでフェイスを指
定することもできます。

`M-g d'
     リージョン、あるいは、つぎに挿入する文字のフェイスを`default'にす
     る（`facemenu-set-default'）。
`M-g b'
     リージョン、あるいは、つぎに挿入する文字のフェイスを`bold'にする
     （`facemenu-set-bold'）。
`M-g i'
     リージョン、あるいは、つぎに挿入する文字のフェイスを`italic'にする
     （`facemenu-set-italic'）。
`M-g l'
     リージョン、あるいは、つぎに挿入する文字のフェイスを`bold-italic'
     にする（`facemenu-set-bold-italic'）。
`M-g u'
     リージョン、あるいは、つぎに挿入する文字のフェイスを`underline'に
     する（`facemenu-set-underline'）。
`M-g o FACE RET'
     リージョン、あるいは、つぎに挿入する文字のフェイスをFACEにする
     （`facemenu-set-face'）。

前置引数を指定してこれらのコマンドを使ったり、暫定マーク
（transient-mark）モードでリージョンが選択されていなければ、これらのコ
マンドはつぎに入力する自己挿入文字だけに使うフェイスを指定します。
*Note Transient Mark::。これはキーボードコマンドとメニューコマンドの両
方に通用します。

エンリッチ（enriched）モードには、`excerpt'と`fixed'の2つの追加フェイス
が定義されています。これらのフェイスは、text/enrichedファイル形式で使用
されるコードに対応しています。

`excerpt'フェイスは引用を表すためのものです。カスタマイズしてなければ
`italic'と同じです（*Note Face Customization::）。

`fixed'フェイスは、『この部分のテキストには固定幅フォントを使用する』と
いう意味です。現在、Emacsは固定幅フォントにだけ対応しています。したがっ
て、`fixed'の注記は今のところ必要ありません。しかしながら、将来のEmacs
では可変幅フォントに対応したり、固定幅フォントをデフォルトとしない
text/enriched形式を表示可能な他のシステムを計画しています。ですから、固
定幅フォントをどうしても使いたい箇所には、その部分のテキストに`fixed'を
指定するべきです。

通常、`fixed'フェイスには、デフォルトと異なるフォントを使うように定義さ
れています。ところが、システムごとにさまざまなフォントがありますから、
この定義をカスタマイズする必要があるかもしれません。

異なるフェイスを表示できない端末ではそれらの違いを目にすることはできま
せんが、それでも、さまざまなフェイスを含む文書の編集は行えます。文書に
フェイスや表示色を追加することもできます。それらを表示可能な端末で見た
ときにフェイスや色を目にすることができます。



File: emacs-ja, Node: Format Colors, Next: Format Indentation, Prev: Format Faces, Up: Formatted Text

整形済みテキストの表示色
------------------------

テキストの部分ごとに前景色と背景色を指定できます。前景色を指定するメ
ニューと背景色を指定するメニューがあります。これらのメニューには、その
Emacsセッションのエンリッチ（enriched）モードで使っている表示色一覧が表
示されます。

前置引数とともに表示色を指定したり、暫定マーク（transient-mark）モード
でリージョンが選択されていなければ、つぎに入力する自己挿入文字だけに作
用します。*Note Transient Mark::。そうでなければ、コマンドはリージョン
に作用します。

それぞれの表示色メニューにはもう1つ`Other'という項目があります。この項
目は、メニューに表示されていない表示色を指定するために使います。これは、
ミニバッファで表示色名称を読み取ります。利用可能な表示色と名前の一覧を
表示するには、Text Propertiesメニューの`Display Colors'項目を使います
（*Note Editing Format Info::）。

このようにして指定した表示色や、読み込んだ整形済みテキスト内で使われて
いる表示色は、そのEmacsセッション中は、両方の表示色メニューに追加されま
す。

表示色を指定するためのキーバインディングはありませんが、拡張コマンド
`M-x facemenu-set-foreground'や`M-x facemenu-set-background'を使えばで
きます。どちらのコマンドもミニバッファで表示色名称を読み取ります。



File: emacs-ja, Node: Format Indentation, Next: Format Justification, Prev: Format Colors, Up: Formatted Text

整形済みテキストの字下げ
------------------------

整形済みテキストの編集では、段落全体あるいは段落の一部に異なる左端と右
端の字下げを指定できます。指定した左右端は、自動的に詰め込みコマンド
（*Note Filling::）と行分割コマンドに反映されます

Indentationサブメニューは、これらの属性を指定するための便利なインターフェ
イスです。このサブメニューにはつぎの4つの項目があります。

`Indent More'
     リージョンを4桁分字下げする（`increase-left-margin'）。エンリッチ
     （enriched）モードでは、このコマンドは`C-x TAB'でも実行できる。数
     引数を指定すると、左端に加える桁数として扱う（負の値であれば桁を減
     らす）。

`Indent Less'
     リージョンから4桁分字下げを取り除く。

`Indent Right More'
     右端を4桁分字下げしてテキストの幅を狭める。

`Indent Right Less'
     右端から4桁分字下げを取り除く。

なお、これらのコマンドを繰り返せば、字下げを増やしたり減らしたりできま
す。

これらのコマンドの一般的な使い方は、段落全体の字下げを変更することです。
しかし、それだけではありません。任意の箇所で左右端を変更できます。新た
に設定された値は、行末（右端）やつぎの行の先頭（左端）に影響します。

それにより、"ぶら下がり字下げ"で段落を整形することができます。ぶら下が
り字下げとは、1行目の字下げ幅が2行目以降の字下げ幅より少ないものです。
ぶら下がり字下げするには、段落の最初の単語の直後から始まり段落の末尾ま
で続くリージョンの字下げ幅を増やします。

段落の1行目の字下げはもっと簡単です。段落の本体があるべき位置に段落全体
に対する左右端を設定してから、最初の行に追加の空白やタブを挿入すればよ
いのです。

編集の結果、段落の詰め込みが汚くなってしまうことがあります。たとえば、
段落の一部が左端や右端からはみ出してしまうことです。そうなったときには、
`M-q'（`fill-paragraph'）を使って、段落を詰め込み直します。

変数`standard-indent'は、これらのコマンドで増減する字下げ幅を指定します。
デフォルト値は4です。エンリッチ（Enriched）モード全体に対する右端のデフォ
ルトは、通常どおり変数`fill-column'で制御します。

詰め込み接頭辞があれば、指定した段落の字下げに追加されます。
`C-x .'は、
詰め込み接頭辞として新たに指定された値には、字下げの白文字を含めません。
しかも、詰め込みコマンドは各行の字下げのうしろにある詰め込み接頭辞を探します。
*Note Fill Prefix::。



File: emacs-ja, Node: Format Justification, Next: Format Properties, Prev: Format Indentation, Up: Formatted Text

整形済みテキストの幅揃え
------------------------

整形済みテキストの編集では、段落に対してさまざまなスタイルの揃え方を指
定できます。指定したスタイルは自動的にEmacsの詰め込みコマンドに影響しま
す。

Justificationサブメニューは、スタイルを指定するための便利なインターフェ
イスです。このサブメニューにはつぎの5項目があります。

`Flush Left'
     これは（少なくとも英語では）もっとも一般的な幅揃えスタイル。行は左
     端に揃えられるが、右側は不揃いのまま。

`Flush Right'
     右端に行を揃える。必要に応じて左側に空白やタブを挿入して右側で行を
     揃える。

`Full'
     行ごとに左右両端を揃える。このスタイルで揃えると空白を均等に挿入す
     る。印刷物では見栄えがたいへんよいが、画面上の固定幅フォントではそ
     れほど美しくない。たぶん、将来のEmacsでは行内の空白量を調節できる
     ようになり、エレガントな幅揃えが達成できるであろう。

`Center'
     各行を現在の左右端の中央に揃える。

`None' (1) (*Note Format Justification-Footnotes::)詰め込みをいっさい止める。各行は入力したままになる。つまり、この設
     定をしたテキストでは、詰め込みコマンドも自動詰め込み機能も何の効果
     もない。それでも、左端を字下げすることは可能。詰め込まないリージョ
     ンでは、改行はすべてハード改行として扱う（*Note Hard and Soft
     Newlines::）。

エンリッチ（enriched）モードでは、
`M-j'プレフィックス文字を使ってキーボードで幅揃えを指定することもできます。

`M-j l'
     リージョンを左端揃えにする（`set-justification-left'）。
`M-j r'
     リージョンを右端揃えにする（`set-justification-right'）。
`M-j f'
     リージョンを左右端揃えにする（`set-justification-full'）。
`M-j c'
`M-S'
     リージョンを中央揃えにする（`set-justification-center'）。
`M-j u'
     リージョンでは詰め込まない（`set-justification-none'）。

揃え方のスタイルは段落全体に適用されます。揃え方を変更するコマンドは、
ポイントを含む段落に作用しますが、リージョンが設定されているときにはリー
ジョンと重なる段落すべてが対象になります。

揃え方のスタイルのデフォルトは、変数`default-justification'で指定されま
す。この値は、`left'、`right'、`full'、`center'、`none' (2) (*Note
Format Justification-Footnotes::) のいずれかのシンボルでなくてはいけま
せん。


File: emacs-ja  Node: Format Justification-Footnotes, Up: Format Justification

(1) 【訳注】メニューには`None'ではなく`Unfilled'が表示さ
れる。

(2) 【訳注】詰め込まないことを指定するシンボルは`none'。
`Unfilled'ではない。



File: emacs-ja, Node: Format Properties, Next: Forcing Enriched Mode, Prev: Format Justification, Up: Formatted Text

他のテキスト属性の設定
----------------------

Other Propertiesメニュー (1) (*Note Format Properties-Footnotes::)には、
`read-only'、`invisible'、`intangible'といった有用なテキ
スト属性を追加／削除する項目があります。`intangible'属性はテキスト
内にポイントを移動できなくし、`invisible'属性はテキストを表示しな
いようにし、`read-only'属性はテキストを変更できなくします。

これらの特別な属性には、リージョンに属性を付加するためのメニュー項目が
あります。最後のメニュー項目`Remove Special'は、これらの特別な属性すべ
てをリージョンから取り除きます。

現在のところ、`invisible'属性と`intangible'属性は、text/enriched形式に
保存され*ません*。`read-only'属性は保存されますが、これはtext/enriched
形式の標準的なものではないので、Emacs以外の他のエディタでは使用されない
かもしれません。


File: emacs-ja  Node: Format Properties-Footnotes, Up: Format Properties

(1) 【訳注】`Other Properties'ではなく、`Special Properties'
と表示される。



File: emacs-ja, Node: Forcing Enriched Mode, Prev: Format Properties, Up: Formatted Text

エンリッチ（enriched）モードの強制
----------------------------------

普通は、Emacsは訪問したファイル内にある特別な注記を認識するので、整形済
みテキストを編集中であることがわかります。ところが、ファイルの内容を変
換するために特別な操作をしたり、手動でエンリッチ（enriched）モードをオ
ンにする必要がある状況もあります。

   * 他のエディタで作成したtext/enriched形式のファイルを訪問すると、
     Emacsがそのファイルをtext/enriched形式であると認識しないかもしれない。
     こういった場合、ファイルを訪れると、
     整形済みテキストではなく整形コマンドを目にする。
     `M-x format-decode-buffer'と打って形式を変換する。

   * ファイルを訪問したのではなく、バッファにファイルを*挿入*したとき。
     Emacsは挿入されたテキストに対しては必要な変換を行うが、エンリッチ
     （enriched）モードをオンにしない。オンにしたければ、`M-x
     enriched-mode'と打つ。

コマンド`format-decode-buffer'は、さまざまな形式のテキストをEmacsの内部
形式に変換します。このコマンドは、どの形式からの変換であるのかを尋ねて
きますが、通常は単にRETを打てばEmacsが形式を推測します。

text/enriched形式のファイルをそのままの形、つまり、整形済みテキストでは
なく文字列として見たいのであれば、`M-x find-file-literally'コマンドを使
います。このコマンドは`find-file'のようにファイルを訪問しますが、形式変
換を行いません。文字コード変換（*Note Coding Systems::）と自動展開
（*Note Compressed Files::）も禁止します。形式変換を禁止しても、適宜、
文字コード変換や自動展開を行わせたいのであれば、適当な引数を指定して
`format-find-file'を使います。



File: emacs-ja, Node: Programs, Next: Building, Prev: Text, Up: Top

プログラムの編集
****************

Emacsには、LispやCといったプログラム言語の構文を理解するように設計され
たコマンドが数多くあります。以下のことを行えます。

   * 釣り合った式や"S式"（*Note Lists::）を横断したりそれらをキルする。
   * トップレベルの式、つまり、Lispの"defun"やCの関数（*Note Defuns::）
     を横断したりそれらにマークを設定する。
   * 括弧の対応具合を表示する（*Note Matching::）。
   * コメントの挿入／キル／整列（*Note Comments::）。
   * 使用言語の慣用的な字下げを踏襲する（*Note Program Indent::）。

単語／文／段落を扱うコマンドは、自然言語のテキストを編集するのが本来の
目的ですが、コードを編集する場合にもおおいに役立ちます。なぜなら、たい
ていのシンボルは単語ですし（*Note Words::）、文は文字列やコメントの中に
も含まれるからです（*Note Sentences::）。段落は本質的にはコードの中には
存在しませんが、プログラム言語向けのメジャーモードでは、段落は空行で始
まり空行で終わると定義するので、段落コマンドも役立ちます（*Note
Paragraphs::）。空行をうまく使ってプログラムが整然と見えるようにすると、
段落コマンドもうまく働きます。

選択的表示機能は、関数の全体構成を眺めるのに便利です（*Note Selective
Display::）。この機能は、指定幅以内の字下げ幅の行だけを表示します。

* Menu:

* Program Modes::       Major modes for editing programs.
* Lists::	        Expressions with balanced parentheses.
* List Commands::       The commands for working with list and sexps.
* Defuns::	        Each program is made up of separate functions.
			  There are editing commands to operate on them.
* Program Indent::      Adjusting indentation to show the nesting.
* Matching::	        Insertion of a close-delimiter flashes matching open.
* Comments::	        Inserting, killing, and aligning comments.
* Balanced Editing::    Inserting two matching parentheses at once, etc.
* Symbol Completion::   Completion on symbol names of your program or language.
* Which Function::      Which Function mode shows which function you are in.
* Documentation::       Getting documentation of functions you plan to call.
* Change Log::	        Maintaining a change history for your program.
* Tags::	        Go direct to any function in your program in one
			  command.  Tags remembers which file it is in.
* Emerge::	        A convenient way of merging two versions of a program.
* C Modes::             Special commands of C, C++, Objective-C,
                          Java, and Pike modes.
* Fortran::	        Fortran mode and its special features.
* Asm Mode::	        Asm mode and its special features.



File: emacs-ja, Node: Program Modes, Next: Lists, Prev: Programs, Up: Programs

プログラム言語向けメジャーモード
================================

Emacsには、Lisp、Scheme（Lispの方言の1つ）、Awk、C、C++、Fortran、Icon、
Java、Objective-C、Pascal、Perl、Pike、CORBA IDL、Tclといった各種プログ
ラム言語向けのメジャーモードがあります。makefile用のメジャーモード、
makefileモードもあります。Perl向けの別のモードとして、cperlモードもあり
ます。

理想的には、Emacsで編集する可能性のあるすべてのプログラム言語に対して、
それぞれのメジャーモードを実装すべきです。しかし、ある言語向けのモード
が、構文的に類似した他の言語にも使えることがよくあります。既存の言語モー
ド群は、誰かがわざわざ書こうと決心したものです。

Lispモードにはいくつか変種がありますが、
Lispを実行する際のインターフェイス方法が異なります。
*Note Executing Lisp::。

各プログラム言語向けメジャーモードでは、その言語の慣用的な字下げ方法を
理解し現在行をそのように字下げする関数を実行するようにTABキーを定義しま
す。たとえば、Cモードでは、TABは`c-indent-line'にバインドされています。
また、`C-j'は、RETに続けてTABを実行するように定義されています。つまり、
モードに固有の字下げも行います。

多くのプログラム言語では、行ごとに字下げ量が異なります。
そのため、そのような言語向けのメジャーモードでは、
（コマンド`backward-delete-char-untabify'を使って）
タブ文字を等価な個数の空白と同じに扱うようにDELを再定義しています。
その結果、字下げが空白かタブのどちらで構成されているのか気にせずに、
1度に1桁ずつ消去することが可能となります。
そのようなモードでは、ポイントの直前にあるタブ文字を削除するには
`C-b C-d'を使います。

プログラム言語向けモードでは、段落は空行で分割されると定義するので、段
落コマンドも便利に使えます。プログラム言語向けメジャーモードで自動詰め
込み（auto-fill）モードがオンのときには、新たに行を作ると自動的に字下げ
も行われます。

メジャーモードに入ると、"モードフック"（mode hook）と
呼ばれるノーマルフックが実行されます。
モードフックは、Lisp変数の値です。
各メジャーモードにはモードフックがあり、
フック名はつねにモードに入るためのコマンド名に`-hook'を付加したものです。
たとえば、Cモードに入るとフック`c-mode-hook'が実行され、
Lispモードではフック`lisp-mode-hook'が実行されます。
*Note Hooks::。



File: emacs-ja, Node: Lists, Next: List Commands, Prev: Program Modes, Up: Programs

リストとS式
===========

慣習として、釣り合った式を扱うEmacsのキーは、普通、コントロール・メタ文
字です。これらは、コントロールやメタだけの対応したキーの機能に似せてあ
ります。これらは、プログラム言語の式だけに関係したコマンドだと考えられ
がちですが、ある種の括弧が存在する（自然言語も含めた）任意の言語に対し
ても有益なものです。

これらのコマンドは、2つのグループに分けられます。一方は（括弧でまとめた）
リスト"（list） (1) (*Note Lists-Footnotes::)だけを扱うもので、丸括弧、
角括弧、中括弧（使用言語において対応が取れている必要がある括弧）と、そ
れらをクォートするエスケープ文字だけに注目するコマンド群です。

もう一方は、式あるいは"S式"（sexp）を扱うコマンド群です。「sexp」という
用語は、Lispの式を意味する古くからの用語"s-expression"に由来します。
Emacsでは「S式」の概念をLispに限定しません。プログラムを記述した言語が
何であっても、その式をS式と呼びます。各プログラム言語には独自のメジャー
モードがあり、そこでは、その言語の式をS式とみなすように構文テーブルを調
整してあります。

一般にS式には、丸括弧、角括弧、中括弧に囲まれた部分だけでなく、シンボル、
数値、文字列定数も含まれます。

Cのように前置演算子と中置演算子を使う言語では、
すべての式をS式として扱うことは不可能です。
たとえば、Cモードでは、`foo + bar'はCの式*です*が、
S式としては認識しません。
かわりに、`foo'と`bar'をそれぞれ1つのS式として認識し、
`+'はあいだにある句読点として認識します。
これは根本的に曖昧なのです。
たとえば、ポイントが`f'にあるとき、横断すべきS式としては、
`foo + bar'でも`foo'でも正当な選択肢です。
`(foo + bar)'は、Cモードにおいて単一のS式であることに注意してください。

式の構文が曖昧なために、Emacsが正しく解釈できるようにしようなどとは誰も
思わない言語もあります。


File: emacs-ja  Node: Lists-Footnotes, Up: Lists

(1) 【訳注】ここでは、Lispの「リスト」ではなく、単に括弧で括った一塊の
こと。



File: emacs-ja, Node: List Commands, Next: Defuns, Prev: Lists, Up: Programs

リストとS式に対するコマンド
===========================

`C-M-f'
     S式を横断して前向きに移動する（`forward-sexp'）。
`C-M-b'
     S式を横断して後向きに移動する（`backward-sexp'）。
`C-M-k'
     前向きにS式をキルする（`kill-sexp'）。
`C-M-DEL'
     後向きにS式をキルする（`backward-kill-sexp'）。
`C-M-u'
     リスト構造を1レベル上がって後向きに移動する（`backward-up-list'）。
`C-M-d'
     リスト構造を1レベル下がって前向きに移動する（`down-list'）。
`C-M-n'
     リストを横断して前向きに移動する（`forward-list'）。
`C-M-p'
     リストを横断して後向きに移動する（`backward-list'）。
`C-M-t'
     式を入れ替える（`transpose-sexps'）。
`C-M-@'
     つぎの式の直後にマークを設定する（`mark-sexp'）。

S式を横断して前向きに移動するには、`C-M-f'（`forward-sexp'）を使います。
ポイントに続く最初の意味ある文字が開き区切り（Lisp では`('、Cでは`('や
`['や`{'）であれば、対応する閉じ区切りのうしろに移動します。シンボル、
文字列、数値を始める文字の場合には、それらを横断してその末尾に移動しま
す。

コマンド`C-M-b'（`backward-sexp'）は、S式を横断して後向きに移動します。
移動の詳しい規則は上記の`C-M-f'と同様ですが、方向は逆です。S式のまえに
接頭辞文字（Lispではシングルクォート、バッククォート、コンマ）がある場
合には、それらも横断します。ほとんどのモードでは、S式コマンドはコメント
を空白であるかのように飛び越えます。

`C-M-f'や`C-M-b'に引数を指定すると、指定された回数だけ動作を繰り返しま
す。負の引数では、逆向きに移動します。

1つのS式全体をキルするには、`C-M-k'（`kill-sexp'）や
`C-M-DEL'（`backward-kill-sexp'）で行います。
`C-M-k'は`C-M-f'で横断するだけの文字をキルし、
`C-M-DEL'は`C-M-b'で横断するだけの文字をキルします。

S式コマンドと同様に、"リストコマンド"はリストを横断しますが、リスト以外
のS式（シンボルや文字列など）は飛び越します。これらのコマンドは、
`C-M-n'（`forward-list'）と`C-M-p'（`backward-list'）です。これらのコマ
ンドが便利である主な理由は、（コメントにはリストが何も含まれないのが普
通なので）コメントを無視するからです。

`C-M-n'と`C-M-p'は、可能な限り同じレベルの括弧にとどまります。1つ（ある
いはNだけ）*上の*レベルに移動するには、`C-M-u'（`backward-up-list'）を
使います。`C-M-u'は、対応の取れていない開き区切りのまえへ後向きに移動し
て、1つレベルを上げます。正の引数は反復回数になります。負の引数は、移動
を逆向きにしますが、やはり反復回数です。つまり、前向きに移動して、1つ以
上レベルを上げます。

リスト構造中で*下*のレベルに移動するには、`C-M-d'（`down-list'）を使い
ます。Lispモードでは、`('が唯一の開き区切りなので、このコマンドは`('を
探索するのとほとんど同じです。引数は下がるべき括弧のレベルを指定します。

本当は役に立つのに、何の役に立つのだろうと思われるコマンドが
`C-M-t'（`transpose-sexps'）です。これはポイントのまえにあるS式を、つぎ
にあるS式を越えて移動するコマンドです。引数は反復回数となり、負の引数で
は後向きにS式を移動します（つまり正の引数を指定した`C-M-t'の効果を打ち
消せる）。引数が0の場合は、何もしないのではなくて、ポイントのあとにある
S式とマークのあとにあるS式を入れ替えます。

バッファ内でつぎにあるS式の周りにリージョンを設定するには、
`C-M-@'（`mark-sexp'）を使います。このコマンドは、`C-M-f'による移動先に
マークを設定します。`C-M-@'は、`C-M-f'と同様に引数を取ります。とりわけ、
負の引数は、直前のS式の先頭にマークを設定するのに便利です。

リストおよびS式コマンドが行う構文の解釈は、
構文テーブルに完全に支配されます。
たとえば、任意の文字を開き区切りとして宣言できて、
そうすると開き括弧のようにふるまうようになります。
*Note Syntax::。



File: emacs-ja, Node: Defuns, Next: Program Indent, Prev: List Commands, Up: Programs

関数定義（defun）
=================

Emacsでは、トップレベルの括弧でグループ化したものは"関数定義"（defun）
と呼ばれます。この名前は、Lispファイルではトップレベルにあるリストの大
半がスペシャルフォーム`defun'であるという事実に由来します。しかし、その
中身が何であろうとも、また、使用プログラム言語が何であろうとも、Emacs流
には、トップレベルの括弧でグループ化されたものはすべて関数定義（defun）
です。たとえば、Cの関数定義の本体は関数定義（defun）です。

`C-M-a'
     現在の関数定義、あるいは、直前の関数定義の先頭に移動する
     （`beginning-of-defun'）。
`C-M-e'
     現在の関数定義、あるいは、つぎの関数定義の末尾に移動する
     （`end-of-defun'）。
`C-M-h'
     現在の関数定義、あるいは、つぎの関数定義を囲むリージョンを設定する
     （`mark-defun'）。

現在の関数定義の先頭や末尾に移動するコマンドは、
`C-M-a'（`beginning-of-defun'）と
`C-M-e'（`end-of-defun'）です。

現在の関数定義を操作したいのであれば、
`C-M-h'（`mark-defun'）を使って、
現在の関数定義かつぎの関数定義の先頭にポイントを置き、
その末尾にマークを設定します。
たとえば、関数定義をテキストの別の位置に移動する準備をするには、
このコマンドを使うのがもっとも簡単な方法です。
Cモードでは、`C-M-h'は`c-mark-function'を実行しますが、
`mark-defun'とほとんど同じです。
違いは、引数宣言、関数名、戻り値の型名と遡って、
Cの関数全体をリージョンに含めることです。
*Note Marking Objects::。

Emacsは、もっとも左の桁でみつけた任意の開き括弧を関数定義の始まりである
と仮定します。したがって、*トップレベルのリストの始まりでない限り、
Lispファイルの中では左端に開き括弧を置いてはいけません。また、関数本体
の始まりを表すのでない限り、Cのコードの行頭に開き中括弧や開き区切りを置
いてはいけません。* もっとも起こりやすい場面は、文字列の途中で、行頭に
開き区切りを入れたい場合です。トラブルを避けるために、開き区切りのまえ
にエスケープ文字（CやEmacs Lispでは `\'、その他のLisp方言のいくつかでは
`/'）を入れてください。これで文字列の内容が影響を受けることはありません。

大昔のもともとのEmacsでは、関数定義を探すために、より上位レベルの括弧が
なくなるまで遡っていました。この方法では、たとえ小さな関数であっても、
バッファの先頭まで遡って走査することがつねに必要でした。これを高速化す
るために、左端内の任意の`(' （あるいは、開き区切りと宣言された任意の文
字）が関数定義の始まりであると仮定するように、Emacsを変更しました。この
発見的手法で、ほとんど正しく処理できて、時間のかかる走査を回避できます。
しかし、上述の約束事は必要です。



File: emacs-ja, Node: Program Indent, Next: Matching, Prev: Defuns, Up: Programs

プログラムの字下げ
==================

正しく字下げされた状態にプログラムを保つ最良の方法は、変更したらEmacsに
字下げをやり直させることです。Emacsには、1行の字下げ、指定された行数の
字下げ、あるいは、括弧でグループ化した内部のすべての行の字下げを行うコ
マンドがあります。

* Menu:

* Basic Indent::	Indenting a single line.
* Multi-line Indent::   Commands to reindent many lines at once.
* Lisp Indent::		Specifying how each Lisp function should be indented.
* C Indent::		Extra features for indenting C and related modes.
* Custom C Indent::	Controlling indentation style for C and related modes.

Emacsでは、ライブラリ`pp'にLispのプリティプリンタ (1) (*Note Program
Indent-Footnotes::) もあります。このプログラムは、美しく見えるように字
下げを施してLispオブジェクトを清書するプログラムです。


File: emacs-ja  Node: Program Indent-Footnotes, Up: Program Indent

(1) 【訳注】プログラムのソースコードを美しく清書するプログラムを一般に
プリティプリンタ（pretty-printer）と呼ぶ。



File: emacs-ja, Node: Basic Indent, Next: Multi-line Indent, Prev: Program Indent, Up: Program Indent

プログラムの字下げ基本コマンド
------------------------------

`TAB'
     現在行の字下げを調整する。
`C-j'
     RETに続けてTABと打鍵するのと同じ（`newline-and-indent'）。

基本的な字下げコマンドはTABです。直前の数行から判断した正しい字下げを現
在行に施します。TABが実行する関数は、メジャーモードに依存します。たとえ
ば、Lispモードでは`lisp-indent-line'、Cモードでは`c-indent-line'が実行
されます。これらの関数はそれぞれの言語の構文を解釈しますが、どれも同じ
ことを行うためのものです。プログラム言語向けメジャーモードにおいては、
TABは、現在行のどこにポイントがあっても、現在行の先頭に白文字を挿入した
り削除したりします。ポイントが行頭の白文字の中にあったときは、TABは最後
の白文字のうしろにポイントを置きます。そうでなければ、TABを打ったときの
文字のところに留まります。

ポイント位置にタブを挿入するには、`C-q TAB'を使います。

新たにソースコード行を入力するときには、
`C-j'（`newline-and-indent'）を使ってください。
これは、RETに続けてTABを打鍵することと等価です。
`C-j'は、空行を作ってから、その行で適切な字下げを行います。

括弧でグループにまとめたところでは、TABは、2行目以降の行をそれぞれ直前
の行の真下にくるように字下げします。したがって、ある行を非標準的な字下
げにすると、以降の行もその字下げに従うことになります。TABによる標準的な
字下げが、特定の行では美しくないので無視したい場合には、字下げのこのよ
うなふるまいが便利です。

（字下げ処理を含めて）Emacsは、左端にある、開き丸括弧、開き中括弧、およ
び、その他の開き区切りを関数の始まりと仮定することを覚えておきましょう。
たとえ文字列の中であっても、関数の始まりでない開き区切りをけっして0桁目
に置いてはいけません。この制約は字下げコマンドを高速にするためにきわめ
て重要です。無条件で受け入れてください。これに関してより詳しくは、
*Note Defuns::。



File: emacs-ja, Node: Multi-line Indent, Next: Lisp Indent, Prev: Basic Indent, Up: Program Indent

複数行の字下げ
--------------

変更した複数行や、リスト構造中の異なるレベル箇所へ移した複数の行を字下
げし直すには、いくつかのコマンドを利用できます。

`C-M-q'
     リスト内のすべての行を字下げし直す（`indent-sexp'）。
`C-u TAB'
     リストの最初の行が正しい字下げ位置にくるように、リストのすべての行
     を横にそのまま動かす。
`C-M-\'
     リージョン内のすべての行を字下げし直す（`indent-region'）。

1つのリストの中身を字下げし直すには、リストの始まり位置にポイントを置い
て`C-M-q'（Lispモードでは`indent-sexp'、Cモードでは`c-indent-exp'、他の
モードでは適切なコマンドにバインドされている）と打ちます。S式が始まる行
の字下げは変化しません。つまり、リスト内の相対的な字下げが変化するだけ
で、リストの位置は変わりません。リストの開始位置も直すには、`C-M-q'のま
えにTABを打ってください。

リスト内の相対的な字下げは正しいけれども、リストの開始行の字下げが正し
くない場合には、その行に移動して`C-u TAB'と打ちます。TABに数引数を指定
すると、通常どおり現在行を字下げしてから、その行から始まるリスト内のす
べての行にも同じ量の字下げを加えます。いいかえれば、グループ全体をひと
まとめに字下げし直します。ただし、このコマンドは賢くて、文字列の中の行
は移動しませんし、Cモードではプリプロセッサ行を移動しません。

字下げし直す範囲を指定するには、リージョンを使うこともできます。コマン
ド`C-M-\'（`indent-region'）は、ポイントとマークのあいだに行の先頭文字
が含まれるすべての行についてTABを実行します。



File: emacs-ja, Node: Lisp Indent, Next: C Indent, Prev: Multi-line Indent, Up: Program Indent

Lispの字下げのカスタマイズ
--------------------------

Lisp式に対する字下げの仕方を、その式から呼ばれる関数と関係付けることが
できます。各Lisp関数に対して、あらかじめ定義された字下げパターンの中か
ら選んだり、Lispプログラムで任意のものを定義したりできます。

字下げの標準パターンは、つぎのとおりです。式の開始行に関数呼び出しの引
数がある場合は、最初の引数の直下に2行目がくるように字下げします。それ以
外の場合は、関数名の直下に2行目がくるように字下げします。続く各行は、入
れ子の深さが同じである行の字下げと同じになります。

変数`lisp-indent-offset'が`nil'以外ならば、式の2行目に対する通常の字下
げパターンを無効にして、式の開始桁からつねに`lisp-indent-offset'だけ字
下げします。

標準パターンが使用されない関数もいくつかあります。名前が`def'で始まる関
数に対しては、式を開始する開き括弧の桁位置に`lisp-body-indent'を加えた
桁位置へ2行目がくるように字下げします。

関数名の属性`lisp-indent-function'を変更すれば、各関数ごとに標準パター
ン以外の字下げを施せます。この属性が取りえる値にはつぎの4つがあります。

`nil'
     属性がないのと同じ。標準の字下げパターンを使用する。
`defun'
     名前が`def'で始まる関数に用いる字下げパターンを使用する。
数値 NUMBER
     関数の最初のNUMBER個の引数を"区別された"引数と呼び、残りを式の"本
     体"と呼ぶ。行の最初の引数が区別された引数かどうかによって、各行の
     字下げが異なる。引数が本体の一部ならば、それを含んだ式を開始する開
     き括弧の桁位置に`lisp-body-indent'を加えた桁位置へ字下げする。引数
     が区別された引数で最初か2番目ならば、`lisp-body-indent'の*2倍*を加
     えた桁位置へ字下げする。引数が区別された引数であっても3番目以降な
     らば、標準パターンを適用する。
シンボルSYMBOL
     SYMBOLは関数名であること。この関数は、当該式の字下げ幅を計算する。
     この関数はつぎの2つの引数を受け取る。STATE 当該行の先頭までを解析
     したときの`parse-partial-sexp' （字下げと入れ子の計算を行うLispの
     基本的な関数）の戻り値。POS 字下げ対象の行の開始位置。この関数は、
     当該行に対する字下げ幅の桁数、あるいは、リストのcarがそのような数
     値であるリストを返す必要がある。数値を返した場合は、括弧の入れ子レ
     ベルが同じ行に対しては同じ字下げ幅を意味する。リストを返した場合は、
     後続の行に対しては字下げ幅が異なる可能性を意味する。このような差異
     は、`C-M-q'で字下げを計算するときに現れる。数値が返された場合、
     `C-M-q'は、リストの末尾に達するまでは、字下げの再計算を行う必要が
     ない。



File: emacs-ja, Node: C Indent, Next: Custom C Indent, Prev: Lisp Indent, Up: Program Indent

Cの字下げコマンド
-----------------

ここでは、Cモードとその関連モードにおける字下げコマンドを紹介します。

`C-c C-q'
     現在のトップレベルの関数定義、あるいは、型宣言の集まりを字下げし直
     す（`c-indent-defun'）。

`C-M-q'
     ポイントのうしろにある釣り合った式の中の各行を字下げし直す
     （`c-indent-exp'）。前置引数を指定すると、不正な構文に対する検査を
     せずに、警告メッセージも発しない。

`TAB'
     現在行を字下げし直すか、タブ文字を挿入する（`c-indent-command'）。

     `c-tab-always-indent'が`t'ならば、現在行を字下げし直すだけで、他に
     は何もしない。これがデフォルト。

     この変数が`nil'ならば、ポイントが左端か字下げの余白部分にある場合
     に限り、字下げし直す。さもなければ、タブ（あるいは、
     `indent-tabs-mode'が`nil'ならば、等価な個数の空白）を挿入する。

     上記の（`nil'や`t'）以外の値であれば、通常どおり字下げし直す。ただ
     し、コメント、文字列、プリプロセッサ指令の内側では、タブを挿入する。

`C-u TAB'
     現在行の構文に従って現在行を字下げし直す。
     なお、現在行から始まる式を構成する行も同じ幅だけ字下げし直す。
     *Note Multi-line Indent::。

カレントバッファ全体を字下げし直すには、`C-x h C-M-\'と打ちます。これは、
まず、バッファ全体をリージョンとしてから、そのリージョンを字下げし直し
ます。

カレントブロックを字下げし直すには、`C-M-u C-M-q'と打ちます。これは、ま
ず、ブロックの先頭に移動してから、ブロック全体を字下げし直します。



File: emacs-ja, Node: Custom C Indent, Prev: C Indent, Up: Program Indent

Cの字下げのカスタマイズ
-----------------------

Cモードとその関連モードでは、字下げのカスタマイズには、単純ですが柔軟性
のある機構を用いています。この機構は2段階で動作します。まず、行をその内
容と文脈から構文的に分類します。つぎに、構文構成要素の各種類に、カスタ
マイズ可能な字下げのオフセットを対応させます。

* Menu:

* Syntactic Analysis::
* Indentation Calculation::
* Changing Indent Style::
* Syntactic Symbols::
* Variables for C Indent::
* C Indent Styles::



File: emacs-ja, Node: Syntactic Analysis, Next: Indentation Calculation, Prev: Custom C Indent, Up: Custom C Indent

第1段階−−構文解析
...................

第1段階では、Cの字下げ機構は、字下げしようとしているまえの行を調べて、
その行を構成する構文上の構成要素を決定します。つまり、"構文シンボル"と
バッファ内の相対位置を要素とする構文構成要素のリストを組み立てます。構
文シンボルには、`statement'（文）や`substatement'（部分文）のように文法
要素を記述するものと、`class-open'（クラス開始）や`knr-argdecl'（K&R版
引数宣言）のように文法要素のあいだの位置を記述するものがあります。

概念的には、Cのコード行は、バッファ中でそれよりまえにあるいずれかの行に
対して必ず相対的に字下げされます。これは構文構成要素リストの中にあるバッ
ファ内位置として表現されます。

以下に例を示します。つぎのコードが、C++モードのバッファに入っているとし
ましょう（実際にバッファに行番号が表示されるわけではない）。

     1: void swap (int& a, int& b)
     2: {
     3:   int tmp = a;
     4:   a = b;
     5:   b = tmp;
     6: }

4行目で（`c-show-syntactic-information'を実行する）`C-c C-s'を打つと、
その行に対する字下げ機構の結果が表示されます。

     ((statement . 32))

これは、その行が文であり、バッファ内位置32に対して相対的に字下げされて
いることを示します。バッファ内位置32は、3行目の`int'の`i'にあたります。
カーソルを3行目に動かして`C-c C-s'と打つと、今度はつぎのように表示され
ます。

     ((defun-block-intro . 28))

この結果は、`int'行がブロックの最初の文であり、バッファ内位置28に対して
相対的に字下げされていることを示しています。バッファ内位置28は、関数ヘッ
ダの直後の中括弧にあたります。

別の例を見てみましょう。

     1: int add (int val, int incr, int doit)
     2: {
     3:   if (doit)
     4:     {
     5:       return (val + incr);
     6:     }
     7:   return (val);
     8: }

4行目で`C-c C-s'と打つと、つぎのように表示されます。

     ((substatement-open . 43))

これは、中括弧が部分文のブロックを*始めて*いることを示しています。
ところで、"部分文"とは、`if'、`else'、`while'、
`do'、`switch'、`for'、`try'、`catch'、
`finally'、`synchronized'のあとの行を表します。

Cの字下げコマンドにおいては、字下げのために行を構文解析し終えると、変数
`c-syntactic-context'には解析結果を表すリストが入ります。このリストの各
要素は"構文構成要素"であり、構文シンボルと（省かれるかもしれない）対応
するバッファ内位置のコンスセルです。構文構成要素リストには、複数の要素
が含まれることもあります。また、典型的には、バッファ内位置を持つ要素は
1つだけです。



File: emacs-ja, Node: Indentation Calculation, Next: Changing Indent Style, Prev: Syntactic Analysis, Up: Custom C Indent

第2段階−−字下げ計算
.....................

Cの字下げ機構は、構文解析で得られた構文構成要素リスト
`c-syntactic-context'を使って、現在行の字下げ幅を計算します。このリスト
の各要素は、構文シンボルを含むコンスセルですが、バッファ内位置を含んで
いる場合もあります。

リストの各要素は、最終的な総字下げ量に2つの方法で寄与します。まず、各構
文シンボルに字下げオフセットを対応付ける連想リスト`c-offsets-alist'から
要素を探すために構文シンボルが使われます。各構文構成シンボルのオフセッ
トを総字下げ量に加えます。つぎに、リストの要素にバッファ内位置が含まれ
ていれば、その箇所の桁位置を字下げ量に加えます。これらのオフセットと桁
数をすべて加えることで、総字下げ量が求まります。

以下の例でCの字下げ機構の動作を説明しましょう。

     1: void swap (int& a, int& b)
     2: {
     3:   int tmp = a;
     4:   a = b;
     5:   b = tmp;
     6: }

3行目にポイントがあって、そこでTABと打って字下げし直すとしましょう。上
（*Note Syntactic Analysis::）でも説明しましたが、その行に対する構文構
成要素リストはつぎのようになります。

     ((defun-block-intro . 28))

ここでは、まず、連想リスト`c-offsets-alist'から`defun-block-intro'を探
すことから始めます。その結果が整数値2であったとしましょう。この値を計算
中の合計（0で初期化されている）に加えて、総字下げ量は空白2文字と更新さ
れます。

つぎの段階は、バッファ内位置28の桁位置を求めることです。バッファ内位置
28の中括弧は0桁目にあるので、0を計算中の合計に加えます。3行目には構文要
素が1つしかないので、総字下げ量は空白2文字となります。

     1: int add (int val, int incr, int doit)
     2: {
     3:   if (doit)
     4:     {
     5:       return(val + incr);
     6:     }
     7:   return(val);
     8: }

4行目でTABと打つと、同じ過程を繰り返しますが、異なる値を使って計算され
ます。この行に対する構文構成要素リストはつぎのとおりです。

     ((substatement-open . 43))

まずは、シンボル`substatement-open'を連想リスト`c-offsets-alist'から探
します。このシンボルに対するオフセットが2であったとしましょう。この時点
で計算中の合計は2（0 + 2 = 2）です。つぎに、バッファ内位置43（3行目の
`if'の`i'の位置）の桁位置2を加えます。結果として、空白4文字という総字下
げ量が求まります。

行を解析した結果、`c-offsets-alist'に現れない構文シンボルがみつかった場
合、そのシンボルは無視します。しかし、変数`c-strict-syntax-p'が`nil'以
外の値であれば、エラーを報告します。



File: emacs-ja, Node: Changing Indent Style, Next: Syntactic Symbols, Prev: Indentation Calculation, Up: Custom C Indent

字下げスタイルの変更
....................

C流のモードの字下げをカスタマイズする方法は2つあります。1つは、あらかじ
め定義されているスタイルから選択する方法です。それぞれのスタイルでは、
各構文シンボルに対するオフセットが定められています。もう1つはより柔軟な
方法で、各構文シンボルの扱い方をカスタマイズできます。定義されている構
文シンボルの一覧については、*Note Syntactic Symbols::。

`M-x c-set-style RET STYLE RET'
     あらかじめ定義されている字下げスタイルSTYLEを選択する。STYLEを入力
     する際に`?'と打てば、定義済みのスタイル一覧を見ることができる。ス
     タイルの見栄えを調べるには、そのスタイルを選択して、適当なCのコー
     ドを字下げし直してみる。

`C-c C-o SYMBOL RET OFFSET RET'
     構文シンボルSYMBOLに対する字下げのオフセットを設定する
     （`c-set-offset'）。2番目の引数OFFSETで、字下げのオフセットを指定
     する。

変数`c-offsets-alist'は、各構文シンボルに与える字下げ量を制御します。こ
の変数の値は連想リストであり、各要素は`(SYNTACTIC-SYMBOL . OFFSET)'の形
をしています。さまざまな構文シンボルに対するオフセットを変えることで、
字下げを細かくカスタマイズできます。連想リストを変更するには、
`c-set-offset'を使います（下記参照）。

`c-offsets-alist'内の各オフセットには、
整数、関数名や変数名、あるいは、
変数`c-basic-offset'の値の正負の倍数を表すシンボルである
`+'、`-'、`++'、`--'、`*'、
`/'のいずれかを設定できます。
したがって、基本の字下げ幅を空白2文字から3文字に変更したければ、
`c-basic-offset'に3を設定します。

オフセットに関数を用いると、字下げのカスタマイズに究極の柔軟性を持たせ
られます。この関数は、構文シンボルとバッファ内位置があればそれを`cons'
したものを引数として呼ばれます。戻り値としては、整数値のオフセットを返
す必要があります。

オフセットの値がリストの場合、各要素は、`nil'以外の値がみつかるまで上の
規則にしたがって処理されます。その後、その値は、通常のように、字下げの
総量に加えられます。これは、主に、複数の関数の結果を組み合わせるために
使われます。

対話的に設定するにしてもファイル`~/.emacs'で設定するにしても、オフセッ
トを設定するもっとも簡単な方法は、コマンド`C-c C-o'（`c-set-offset'）を
使うことです。最初の引数は構文シンボル、2番目の引数は希望のオフセットで
す。有効な構文シンボル名とその意味の一覧は、*Note Syntactic Symbols::。



File: emacs-ja, Node: Syntactic Symbols, Next: Variables for C Indent, Prev: Changing Indent Style, Up: Custom C Indent

構文シンボル
............

Cモードや関連するモードの字下げに対して有効な構文シンボルを、
構文上の意味とともに、以下に示します。
これらのほとんどのシンボルには、
`c-offsets-alist'でオフセットが与えられています。

`string'
     複数行におよぶ文字列の内側。

`c'
     複数行におよぶCスタイルのブロックコメントの内側。

`defun-open'
     関数定義を開始する中括弧。

`defun-close'
     関数定義を終了する中括弧。

`defun-block-intro'
     トップレベルの関数定義の最初の行。

`class-open'
     クラス定義を開始する中括弧。

`class-close'
     クラス定義を終了する中括弧。

`inline-open'
     クラス内のインラインメソッドを開始する中括弧。

`inline-close'
     クラス内のインラインメソッドを終了する中括弧。

`extern-lang-open'
     外部言語ブロックを開始する中括弧。

`extern-lang-close'
     外部言語ブロックを終了する中括弧。

`func-decl-cont'
     関数定義の引数リストと関数定義の本体を開始する中括弧のあいだの領域。
     ただし、K&R版の関数定義を除く。Cでは、この部分に空文字やコメント以
     外は置けない。C++やJavaでは、`throws'宣言などを置ける。

`knr-argdecl-intro'
     K&R版Cの引数宣言の最初の行。

`knr-argdecl'
     K&R版Cの引数宣言の2行目以降。

`topmost-intro'
     最上位の言語構成要素の最初の行。

`topmost-intro-cont'
     最上位の言語構成要素の2行目以降。

`member-init-intro'
     （構造体の）メンバ初期化リストの最初の行。

`member-init-cont'
     （構造体の）メンバ初期化リストの2行目以降。

`inher-intro'
     多重継承リストの最初。

`inher-cont'
     多重継承リストの2行目以降。

`block-open'
     文ブロックを開始する中括弧。

`block-close'
     文ブロックを終了する中括弧。

`brace-list-open'
     `enum'のリストや静的配列の初期化リストを開始する中括弧。

`brace-list-close'
     `enum'のリストや静的配列の初期化リストを終了する中括弧。

`brace-list-intro'
     `enum'のリストや静的配列の初期化リストの最初の行。

`brace-list-entry'
     `enum'のリストや静的配列の初期化リストの2行目以降。

`brace-entry-open'
     行が開き中括弧で始まるときの、
     `enum'のリストや静的配列の初期化リストの2行目以降。

`statement'
     通常の文。

`statement-cont'
     文の継続行。

`statement-block-intro'
     新規文ブロックの最初の行。

`statement-case-intro'
     `case'ブロックの最初の行。

`statement-case-open'
     中括弧で始まる`case'ブロックの最初の行。

`inexpr-statement'
     式の内側にある文ブロック。これは、C言語のGNU拡張や、文ブロックを引
     数としてとるPikeの特殊関数に用いる。

`inexpr-class'
     式の内側にあるクラス定義。これは、Javaの無名クラスや無名配列の初期
     化式に用いる。

`substatement'
     `if'、`while'、`for'、
     `do'、`else'の直後の最初の行

`substatement-open'
     substatementのブロックを開始する中括弧。

`case-label'
     `case'または`default'ラベルを表す。

`access-label'
     C++のアクセス指定子`private'、`protected'、`public'を表す。

`label'
     通常のラベル。

`do-while-closure'
     `do'-`while'文の`while'。

`else-clause'
     `if'-`else'文の`else'。

`catch-clause'
     C++やJavaの`try'...`catch'構成の
     `catch'行や`finally'行。

`comment-intro'
     コメントの導入部分だけを含んだ行。

`arglist-intro'
     引数リストの最初の行。

`arglist-cont'
     引数リストを開始する括弧の行に引数がない場合、引数リストの2行目以
     降。

`arglist-cont-nonempty'
     引数リストを開始する括弧の行に少なくとも1つの引数がある場合、引数
     リストの2行目以降。

`arglist-close'
     引数リストを終了する括弧。

`stream-op'
     ストリーム演算子を用いた式が継続する行。

`inclass'
     クラス定義の内側に入れ子になった言語構成要素。字下げは、クラス定義
     の開き中括弧に相対である。

`inextern-lang'
     外部言語ブロックの内側に入れ子になった言語構成要素。

`inexpr-statement'
     式の内側の文ブロックの最初の行。これは、構文`({ ... })'を使うCに対
     するGCC拡張に用いる。文ブロックを引数としてとるPikeの特殊関数にも
     用いる。

`inexpr-class'
     式の内側のクラス定義の最初の行。これは、Javaの無名クラスや無名配列
     の初期化式に用いる。

`cpp-macro'
     cppマクロの開始。

`friend'
     C++の`friend'宣言。

`objc-method-intro'
     Objective-Cのメソッド定義の最初の行。

`objc-method-args-cont'
     Objective-Cのメソッド定義を継続する行。

`objc-method-call-cont'
     Objective-Cのメソッド呼び出しを継続する行。

`inlambda'
     `inclass'と同様だが、ラムダ（つまり、無名）関数の内側に用いる。
     Pikeのみで用いる。

`lambda-intro-cont'
     キーワード`lambda'と関数本体のあいだの、ラムダ関数のヘッダーの継続
     行。Pikeのみで用いる。



File: emacs-ja, Node: Variables for C Indent, Next: C Indent Styles, Prev: Syntactic Symbols, Up: Custom C Indent

Cの字下げのための変数
.....................

本節では、Cモードとその関連モードの字下げ動作を制御する、モードに固有な
変数について説明します。

`c-offsets-alist'
     構文シンボルとその字下げオフセットの連想リスト。このリストに直接に
     値を設定するのではなく、`c-set-offset'を使うこと。詳細については、
     *Note Changing Indent Style::。

`c-style-alist'
     字下げスタイルを定義している変数。下記参照。

`c-basic-offset'
     `c-offsets-alist'の中で、シンボル`+'や`-'が用いるオフセットの基本
     量。

`c-special-indent-hook'
     ユーザー定義の特別な字下げ調整用のフック。このフックは、Cモードや
     その関連モードが行の字下げを終えたあとに呼ばれる。

変数`c-style-alist'は、
あらかじめ定義された字下げスタイルを保持します。
各要素は`(NAME VARIABLE-SETTING...)'の形をしていて、
NAMEはスタイル名です。
また、各VARIABLE-SETTINGは、
`(VARIABLE . VALUE)'の形をしています。
VARIABLEには、Cモードが使用するカスタマイズ用変数の1つを指定します。
VALUEは、選択されたスタイルが使われるときのVARIABLEの値です。

VARIABLEが`c-offsets-alist'である場合は、特殊なケースです。
`c-offsets-alist'の値をVALUEの値で置き換えるのではなく、
`c-offsets-alist'の値の先頭にVALUEを追加します。したがって、VALUEにすべ
ての構文シンボルを設定する必要はありません。デフォルトと異なる構文シン
ボルだけを単に設定すればよいのです。

コメントだけを含んだ行の字下げも、変数`c-comment-only-line-offset'
（*Note Comments in C::）に影響されます。



File: emacs-ja, Node: C Indent Styles, Prev: Variables for C Indent, Up: Custom C Indent

Cの字下げスタイル
.................

"Cスタイル"とは、カスタマイズされた字下げスタイルの集合です。Emacsには、
Cモードや関連するモードのためにあらかじめ定義された、`gnu'、`k&r'、
`bsd'、`stroustrup'、`linux'、`python'、`java'、`whitesmith'、
`ellemtel'、`cc-mode'といった字下げスタイルがあります。デフォルトのスタ
イルは`gnu'です。

望みのスタイルを選択するには、コマンド`M-x c-set-style'を使います。引数
としてスタイル名を指定します（Cスタイル名では大文字小文字は区別しない）。
選択したスタイルは新たに訪問したバッファにだけ影響し、すでに編集中のバッ
ファには影響しません。さまざまなメジャーモードのスタイルを指定するため
に変数`c-default-style'を設定することもできます。その値は連想リストであ
る必要があり、その各要素は、1つのメジャーモードとそのモードで使う字下げ
スタイルを指定します。たとえば、

     (setq c-default-style
           '((java-mode . "java") (other . "gnu")))

は、Javaモードには対しては選択を明示し、他のC流モードには`gnu'をデフォ
ルトとします。

Cの字下げスタイルを新たに定義するには、関数`c-add-style'を呼びます。

     (c-add-style NAME VALUES USE-NOW)

ここで、NAMEは新しいスタイルの名前（文字列）、VALUESは要素が
`(VARIABLE . VALUE)'の形をした連想リストです。VARIABLEには、*Note
Variables for C Indent::に書かれているものを指定してください。

USE-NOWが`nil'以外ならば、新しいスタイルの定義後すぐにそれに切り替えま
す。



File: emacs-ja, Node: Matching, Next: Comments, Prev: Program Indent, Up: Programs

対応している括弧の自動表示
==========================

Emacsの括弧の対応付け機能は、テキスト中でどのように括弧が対応しているか
自動的に表示するよう設計されています。閉じ区切りである自己挿入文字を打
つと、それに対応する開き区切りが画面上にあれば、その箇所にほんのしばら
くカーソルが移動します。画面上になければ、エコー領域にその箇所の近くに
ある文字列を表示します。いずれにしても、1つのまとまりが閉じたことが判り
ます。

Lispでは、括弧だけに対して自動的な対応付けを行います。
Cでは、中括弧や角括弧も対象となります。
Emacsは、メジャーモードが設定する構文テーブルに基づいて、
どの文字が対応関係にある区切りであるか判定します。
*Note Syntax::。

`[x)'のように、開き区切りと閉じ区切りが対応しない場合、エコー領域に警告
メッセージを表示します。正しい対応関係は構文テーブルで指定します。

括弧の対応表示を制御する変数は3つあります。`blink-maching-paren'は、対
応表示機能をオンまたはオフにします。`nil'を設定すると対応表示機能はオフ
になりますが、デフォルトは`t'であり、対応表示を行います。
`blink-matching-delay'は、対応表示のために待つ秒数を指定します。デフォ
ルトは1秒ですが、システムによっては何分の1秒のほうが便利かもしれません。
`blink-matching-paren-distance'は、対応している開き区切りをみつけるため
に、何文字分まで戻って探索するか指定します。その範囲内で対応するものが
みつからなければ、走査をやめて何も表示しません。これは、存在しもしない
対応する区切りを探すことに時間を浪費するのを防ぐためです。デフォルトは
12,000です。

Xウィンドウシステムを使用している場合、対応括弧表示（show-paren）モード
にすれば、より強力な括弧の対応表示を利用できます。このモードは、通常の
対応表示をオフにするかわりに、対応する括弧同士を示すために強調表示を行
います。ポイントが閉じ括弧の直後にあるときには、閉じ括弧とそれに対応す
る開き括弧の両方を強調表示します。ポイントが開き括弧の直前にあるときに
は、対応する閉じ括弧を強調表示します。（ポイントの直後に開き括弧がある
ときには、カーソルが開き括弧に重ねて表示されるので、開き括弧を強調表示
する必要はない。）このモードをオン／オフするには、コマンド`M-x
show-paren-mode'を使います。



File: emacs-ja, Node: Comments, Next: Balanced Editing, Prev: Matching, Up: Programs

コメントの操作
==============

コメントはプログラミングの重要な部分なので、Emacsにはコメントの編集や挿
入を行うための特別なコマンドがあります。

* Menu:

* Comment Commands::
* Multi-Line Comments::
* Options for Comments::



File: emacs-ja, Node: Comment Commands, Next: Multi-Line Comments, Prev: Comments, Up: Comments

コメント用コマンド
------------------


コメント用コマンドはコメントの挿入、削除、および位置揃えを行います。

`M-;'
     コメントの挿入／位置揃えを行う（`indent-for-comment'）。
`C-x ;'
     コメントの桁位置を設定する（`set-comment-column'）。
`C-u - C-x ;'
     現在行のコメントをキルする（`kill-comment'）。
`C-M-j'
     RETに続けて、コメントの挿入／位置揃えを行う
     （`indent-new-comment-line'）。
`M-x comment-region'
     リージョン内の各行に対して、コメント区切りを追加／削除する。

コメントを挿入するコマンドは`M-;'（`indent-for-comment'）です。行にコメ
ントがなければ、新規にコメントを作成して、"コメント桁位置"と呼ばれる特
定の桁に置きます。コメントを作成する際には、Emacsが正しいと信じるコメン
ト開始文字列（`comment-start'の値。下記参照）を挿入します。ポイントはそ
の文字列の直後に置かれます。コードのテキストがコメント桁位置を越えてい
るときには、適当な境界に字下げします（通常は少なくとも空白1文字）。メ
ジャーモードでコメント終了文字列が指定されていれば、構文を正しく保つた
めに、ポイントの直後にその文字列を挿入します。

`M-;'は、既存のコメントを位置揃えするためにも使えます。行にコメント開始
文字列がすでに含まれていれば、その文字列の直後にポイントを移動してから、
適切な位置に字下げします。例外として、0桁目から始まるコメントは動かしま
せん。

特定の文脈における、ある種のコメントの字下げには特殊な規則を持つメジャー
モードもあります。たとえば、Lispのコードでは、セミコロン2つで始まるコメ
ントは、コメント桁位置に揃えるのでなく、コードであるかのように字下げさ
れます。また、セミコロン3つで始まるコメントは左端に置くと仮定されます。
Emacsはこれらの慣習を理解していて、セミコロン2つのコメントはTABで字下げ
し、セミコロン3つのコメントは字下げをまったく変更しません。

     ;; This function is just an example
     ;;; Here either two or three semicolons are appropriate.
     (defun foo (x)
     ;;; And now, the first part of the function:
       ;; The following line adds one.
       (1+ x))           ; This line adds one.

Cのコードでは、コメントのまえに白文字しかない場合には、そのコメントをコー
ドのように字下げします。

既存のコメントの位置が適切に揃えられている場合でも、コメント開始直後の
位置にすぐに移動するには`M-;'が便利です。

`C-u - C-x ;'（`kill-comment'）は、
現在行にコメントがあれば、それをキルします。
コメント開始文字列のまえにある字下げもキルします。
コメントと思われるものが何もなければ、何もしません。
他の行にコメントを再挿入するには、
その行の末尾に移動してから`C-y'と打って、
さらに、位置を再調整するために`M-;'と打ちます。
`C-u - C-x ;'はひとまとまりのキーではなく、
負の引数を指定した`C-x ;'（`set-comment-column'）で
あることに注意しましょう。
このコマンドは、負の引数を受け取ると、
`kill-comment'を呼ぶようにプログラムされています。
`kill-comment'は、望むならばキーに直接バインドできる通常のコマンドです。



File: emacs-ja, Node: Multi-Line Comments, Next: Options for Comments, Prev: Comment Commands, Up: Comments

複数行にわたるコメント
----------------------

コメントを入力していて別の行に継続したければ、コマンド
`C-M-j'（`indent-new-comment-line'）を利用できます。このコマンドは、入
力中のコメントを終了して、そのつぎに空行を作り、直前のコメントの直下に
くるように字下げして新たなコメントを始めます。自動詰め込み（auto-fill）
モードがオンならば、コメントを入力中に詰め込み桁を越えると、同様にコメ
ントはつぎの行に継続されます。`C-M-j'を打ったときにポイントが行末になけ
れば、ポイント位置から行末までのテキストは新たなコメントの一部になりま
す。

既存の行をコメントにするには、コマンド`M-x comment-region'を使います。
このコマンドは、リージョン内で始まる各行にコメント区切り文字列を加えて
コメントにします。負の引数を指定すると逆の操作、つまり、コメント区切り
文字列を削除します。

正の引数を指定すると、`comment-region'は、追加するコメント開始文字列の
最後の文字を重複させます。つまり、引数は、その文字を何回重複させるかを
示します。たとえば、Lispモードで`C-u 2 M-x commment-region'とすると、各
行に`;;'を付加します。コメント区切り文字を重複させるのは、コメントに注
意を引き付けるためです。また、コメントの字下げにも影響します。Lispでは、
適切な字下げになるように、関数定義（defun）のあいだでは引数として3を、
関数定義の内側では引数として2を指定すべきです。

変数`comment-padding'は、`comment-region'がコメント区切りと各行のもとの
テキストとのあいだに挿入する空白の個数を指定します。デフォルトは1です。



File: emacs-ja, Node: Options for Comments, Prev: Multi-Line Comments, Up: Comments

コメントを制御するオプション
----------------------------

コメント桁位置は、変数`comment-column'に入っています。この変数には明示
的に値を設定できます。あるいは、コマンド `C-x ;'（`set-comment-column'）
を使って、ポイント位置の桁をコメント桁位置として設定できます。`C-u C-x
;'は、バッファ内で現在行よりまえにある最後のコメントの桁位置をコメント
桁位置としてから、`M-;'を行って現在行のコメントをまえのコメントの直下に
くるように位置を揃えます。`C-u - C-x ;'は、前述のように関数
`kill-comment'を実行することに注意してください。

変数`comment-column'は、バッファごとの変数です。つまり、通常の方法で設
定すると、カレントバッファだけに影響しますが、`setq-default'でデフォル
ト値を変更できます。*Note Locals::。多くのメジャーモードでは、この変数
をカレントバッファ用に初期化します。

コメント用コマンドは、変数`comment-start-skip'の正規表現に基づいて
コメントを認識します。
この正規表現が空文字列には一致しないようにしてください。
厳密にはコメント開始文字列よりも長く一致するかもしれません。
たとえば、Cモードではこの変数の値は`"/\\*+ *"'ですが、
これは `/*'のうしろの余分なアスタリスクと空白に一致します。
（Lispの構文では、文字列中に`\'を含めるために`\\'とする必要がある。
この`\'は、最初のアスタリスクの正規表現における特別な
意味を抑制するために必要。
*Note Regexps::。）

コメント用コマンドで新たなコメントを作ると、
コメントを始めるために`comment-start'の値を挿入します。
また、ポイントの直後には`comment-end'の値が挿入されて、
これから入力するテキストのあとに続くことになります。
Cモードでは、`comment-start'の値は`"/* "'、
`comment-end'の値は`" */"'です。

変数`comment-multi-line'は、`C-M-j'（`indent-new-comment-line'）がコメ
ントの内側で使われたときの動作を制御します。`comment-multi-line'が
`nil'（通常の設定）ならば、現在行のコメントを終了し、新たなコメントをつ
ぎの行から始めます。`comment-multi-line'が`nil'以外ならば、現在行と同じ
コメントが継続されます。つまり、現在行のコメントを終えず、新たな行にも
開始文字列を挿入しません。複数行にわたるコメントを許す言語では、この変
数に設定する値は好みの問題です。

変数`comment-indent-function'には、新たに挿入したコメントの字下げや既存
のコメントに桁を揃えるための字下げを計算する関数を設定する必要がありま
す。この変数には、メジャーモードごとに異なった関数が設定されます。この
関数は引数なしで呼ばれますが、コメントがあるときにはその開始位置にポイ
ントを置いて、新規コメントの挿入時には行末にポイントを置いて呼ばれます。
戻り値は、コメントを始めるべき桁位置です。たとえば、Lispモードでは、こ
の字下げ用フック関数は、既存のコメントのセミコロンの個数とまえの行のコー
ドに基づいて計算を行います。



