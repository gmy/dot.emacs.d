Info file: emacs-ja,    -*-Text-*-
produced by `texinfo-format-buffer'
from file `emacs.texi'
using `texinfmt.el' version 2.41 of  1 Mar 2005.

INFO-DIR-SECTION Emacs
START-INFO-DIR-ENTRY
* Emacs-ja: (emacs-ja).	            Emacs21.3日本語マニュアル.
END-INFO-DIR-ENTRY








File: emacs-ja, Node: Balanced Editing, Next: Symbol Completion, Prev: Comments, Up: Programs

括弧の対応を保った編集
======================

`M-('
     つぎの（1つ以上の）S式を括弧で囲む（`insert-parentheses'）。
`M-)'
     つぎの閉じ括弧のうしろへ移動してから字下げし直す
     （`move-past-close-and-reindent'）。

コマンド`M-('（`insert-parenthesis'）と
`M-)'（`move-past-close-and-reindent'）は、括弧の対応をつねに保ったまま
編集するために設計されました。`M-('は一対の括弧を挿入します。引数がなけ
れば`()'を挿入しますが、引数を指定すると、つぎのその個数分のS式を括弧で
囲みます。ポイントは開き括弧の直後に置かれます。コマンド`M-)'は、閉じ括
弧のまえにある字下げを削除しながら閉じ括弧のうしろにポイントを移動し、
そのあと、`C-j'で字下げします。

たとえば、`( F O O )'と打つかわりに`M-( F O O'と打てば、カーソルが閉じ
括弧のまえにくることを除けば同じ効果を得られます。

`M-('は、直前の文字の構文クラスによっては、
開き括弧のまえに空白を1個挿入することがあります。
これを禁止したければ、
`parens-require-spaces'に`nil'を設定してください。



File: emacs-ja, Node: Symbol Completion, Next: Which Function, Prev: Balanced Editing, Up: Programs

シンボル名の補完
================

通常、補完はミニバッファで行われます。しかし、ある種の補完は任意のバッ
ファで利用できます。それはシンボル名に対する補完です。

`M-TAB'は、ポイント直前の部分的なシンボルを、意味のあるシンボル名の集合
から補完するコマンドを実行します。部分的な名前から補完された追加文字は
ポイント位置に挿入されます。

バッファ内の部分的な名前に対して、複数個の補完候補があり、しかも、追加
できる共通部分がない場合には、補完候補一覧を別のウィンドウに表示します。

ほとんどのプログラム言語向けメジャーモードでは、`M-TAB'はコマンド
`complete-symbol'を実行します。この関数には、2種類の補完機能があります。
通常、このコマンドはタグテーブル（*Note Tags::）に基づいて補完を行いま
す。  数引数（値は無関係）を指定すると、当該言語のinfoファイルの索引に
並べられた名前を対象として補完を行います。すなわち、プログラム中で定義
されたシンボル名を補完するには引数なしで`M-TAB'を使い、標準ライブラリ関
数の名前を補完するには`C-u M-TAB'を使います。もちろん、infoに基づいた補
完は、使用言語の標準ライブラリ関数に対するinfoファイルがあり、かつ、そ
れがインストールされている場合にだけ動作します。

Emacs Lispモードでは、補完対象の名前空間は、関数定義、値や属性を持つ
Emacs中の特殊なシンボルから成ります。しかし、部分的なシンボルの直前に開
き括弧があれば、関数定義を持つシンボルだけを補完対象とします。これを実
現するコマンドは`lisp-complete-symbol'です。

テキスト（text）モードとその関連モードでは、
`M-TAB'はスペルチェッカの辞書に基づいた補完を行います。
*Note Spelling::。



File: emacs-ja, Node: Which Function, Next: Documentation, Prev: Symbol Completion, Up: Programs

関数名表示モード（which-functionモード）
========================================

関数名表示（which-function）モードは、バッファ内を動き廻るに従って現在
の関数名をモード行に表示するマイナモードです。

関数名表示（which-function）モードをオン（あるいはオフ）にするには、コ
マンド`M-x which-function-mode'を使います。このコマンドはグローバルです。
つまり、既存のバッファでもこれから作るバッファでも、すべてのバッファに
通用します。しかし、`which-func-modes'の値で指定された特定のメジャーモー
ドでのみ効果があります。（`which-func-modes'のデフォルト値は`t'であり、
関数名表示（which-function）モードの支援方法を知っているすべてのメジャー
モードに適用されることを意味する。具体的には、imenuを使えるメジャーモー
ド。）



File: emacs-ja, Node: Documentation, Next: C Modes, Prev: Which Function, Up: Programs

説明文書用コマンド
==================

Emacsで実行するLispコードを編集するときには、関数や変数の説明文字列を表
示するコマンド、`C-h f'（`describe-function'）や`C-h
v'（`describe-variable'）を利用できます。これらのコマンドは、説明文字列
を表示したい関数や変数の名前をミニバッファから読み取り、ウィンドウに説
明文字列を表示します。

たいへん便利なことに、これらのコマンドはポイント近傍のコードから、デフォ
ルトの引数を選択します。`C-h f'は、ポイントを含むもっとも内側のリストで
呼ばれる関数をデフォルトとします。`C-h v'は、ポイントの周辺にあるか隣接
するシンボル名をデフォルトとします。

Emacs Lispコードに対しては、eldocモードも使えます。このマイナモードは、
ポイント位置で呼び出されている関数の引数リストを、たえずエコー領域に表
示します。（いいかえれば、ポイントを含む関数呼び出しを探し、その関数の
引数リストを表示する。）eldocマイナモードは、Emacs LispモードとLisp対話
（lisp-interaction）モードだけに適用できます。この機能をオン／オフする
には、コマンド`M-x eldoc-mode'を使います。

C、Lisp、その他言語のシンボルのinfo文書を見るには
`C-h C-i'（`info-lookup-symbol'）を使います。
ミニバッファでシンボルを指定します。
デフォルトは、バッファ中のポイント位置にあるシンボルです。
シンボルに対する説明文書を探す場所、つまり、
どのinfoファイルのどの索引を探せばよいかは、
メジャーモードが決定します。
また、ファイル名に対する説明文書を探すには
`M-x info-lookup-file'を使います。

`M-x manual-entry'コマンドを使って、
オペレーティングシステムのコマンド、ライブラリ関数、システムコールの
『マニュアルページ』を読むことができます。
このコマンドは、マニュアルページを清書するために
`man'プログラムを実行します。
システムが許せば非同期に実行するので、
マニュアルページが清書されるまで、編集を継続できます
（MS-DOSやMS-Windows 3.xでは、非同期的なサブプロセスを実行できない。
このため、これらのシステムでは`man'の終了をEmacsが待つあいだは
編集できない）。
結果は、`*Man TOPIC*'という名前のバッファに入ります。
これらのバッファではマン（man）モードと呼ばれる特別な
メジャーモードが使われ、
スクロールや他のマニュアルページの調査を容易に行えます。
より詳しくは、マニュアルページ用のバッファで、
`C-h m'と打ってください。

長いマニュアルページでは、適切なフェイスを設定するにはとても時間がかか
ります。さまざまなフォントや表示色を表示できる環境であれば、デフォルト
でマニュアルページにフェイスを用いるようになっています。変数
`Man-fontify-manpage-flag'に`nil'を設定すれば、マニュアルページにおける
フェイスの使用をオフにできます。

他の方法でマニュアルページのテキストをEmacsバッファに挿入した場合、
`M-x manual-entry'と同じ変換を施すには、そこで`M-x
Man-fontify-manpage'コマンドを実行します。

GNUプロジェクトでは最終的に、ほとんどのマニュアルページをinfoで閲覧可能
なよりよく構成されたマニュアルに置き換えることを望んでいます。*Note
Misc Help::。この作業は、ほんの一部が完了しただけなので、まだマニュアル
ページを読めることは有益です。



File: emacs-ja, Node: C Modes, Next: Fortran, Prev: Documentation, Up: Programs

Cモードと関連するモード
=======================

本節では、C、C++、Objective-C、Java、CORBA IDL、Pike用の各モードで利用
可能な特別な機能について述べます。『Cモードと関連するモード』と書いたと
きには、これらのモードを意味します。

* Menu:

* Motion in C::
* Electric C::
* Hungry Delete::
* Other C Commands::
* Comments in C::



File: emacs-ja, Node: Motion in C, Next: Electric C, Prev: C Modes, Up: C Modes

Cモードの移動コマンド
---------------------

本節では、Cモードとその関連モードでポイントを移動するコマンドについて述
べます。

`C-c C-u'
     マークをポイント位置に設定し、ポイントを含むプリプロセッサの条件節
     の先頭に後向きにポイントを戻す。数引数は反復回数として働く。負の引
     数を指定すると、条件節の末尾に前向きにポイントを移動する。後向きに
     戻る場合、`#elif'は、`#if'が続く`#else'のように扱われる。前向きに
     進む場合、`#elif'は無視される (1) (*Note Motion in C-Footnotes::)。

`C-c C-p'
     マークをポイント位置に設定し、プリプロセッサの条件節を横断して後向
     きにポイントを移動する。数引数は反復回数として働く。負の引数を指定
     すると、前向きに移動する。

`C-c C-n'
     マークをポイント位置に設定し、プリプロセッサの条件節を横断して前向
     きにポイントを移動する。数引数は反復回数として働く。負の引数を指定
     すると、後向きに移動する。

`M-a'
     もっとも内側のCの文の先頭にポイントを移動する
     （`c-beginning-of-statement'）。すでに文の先頭にポイントがある場合、
     直前の文の先頭に移動する。数引数Nを指定すると、N-1だけまえの文に移
     動する。

     ポイントが、文字列やコメントの内側、あるいは、コメントのうしろ（コ
     メントのあいだに白文字がある場合のみ）にある場合、Cの文ではなく自
     然言語の文単位で移動する。

     プログラムから呼ばれるときには、この関数は、3つの引数、つまり、反
     復回数、（これよりも後向きには戻らない）移動限界、ポイントがコメン
     トの内側にある場合に自然言語の文単位の移動をするかどうか、を取るが、
     これらは省略できる。

`M-e'
     もっとも内側のCの文の末尾にポイントを移動する。
     `M-a'と同じだが、移動方向が逆（`c-end-of-statement'）。

`M-x c-backward-into-nomenclature'
     C++の命名語法の部分や単語の先頭に後向きにポイントを移動する。数引
     数Nを指定すると、N回移動する。Nが負ならば、前向きに移動する。C++の
     命名語法とは、NamingSymbolsWithMixedCaseAndNoUnderlinesのような形
     のシンボル名のこと（つまり、大文字で始めた単語を連結したもの）。各
     大文字が部分や単語の先頭となる。

     GNUプロジェクトでは、CやC++の識別子は、大文字小文字で区別するので
     はなく、単語を下線で区切ることを推奨する。

`M-x c-forward-into-nomenclature'
     C++の命名語法の部分や単語の末尾に前向きにポイントを移動する。数引
     数Nを指定すると、N回移動する。


File: emacs-ja  Node: Motion in C-Footnotes, Up: Motion in C

(1) 【訳注】`#elif'のところで止まってしまう。



File: emacs-ja, Node: Electric C, Next: Hungry Delete, Prev: Motion in C, Up: C Modes

エレクトリックC文字
-------------------

Cモードとその関連モードでは、ある種の印字文字は『エレクトリック』です。
つまり、その文字自身を挿入することに加えて、
現在行を字下げし直したり、改行も挿入することさえあります。
この機能は、変数`c-auto-newline'で制御されます。
『エレクトリック』文字は、`{'、`}'、`:'、`#'、
`;'、`,'、`<'、`>'、`/'、`*'、`('、`)'です。

"自動改行"（auto-newline）機能がオン（モード行のモード名のあとに`/a'と
表示される）の場合に限り、エレクトリック文字は改行を挿入します。この機
能は、変数`c-auto-newline'で制御されます。コマンド`C-c C-a'でこの機能を
オン／オフできます。

`C-c C-a'
     自動改行機能をオン／オフする（`c-toggle-auto-state'）。数引数を指
     定した場合、正ならば自動改行機能をオンにし、負ならばオフにする。

コロン`:'はエレクトリックです。
なぜなら、単独のコロンの入力の解釈としてはそれが適切だからです。
しかし、C++で2つの連続するコロンを挿入する場合、
コロンのエレクトリックな動作は不便です。
`C-c :'と打てば、字下げも改行の挿入も行わずにコロンを2つ挿入できます。

`C-c :'
     行の字下げも改行の挿入もせずに、スコープ演算子を表すコロン2つをポ
     イント位置に挿入する（`c-scope-operator'）。

エレクトリックキー`#'は、
プリプロセッサ指令の始まりと思われる位置では、行を字下げし直します。
変数`c-electric-pound-behavior'の値が`(alignleft)'のときには、
このようになります。
この機能をオフにするには、
`c-electric-pound-behavior'に`nil'を設定します。

変数`c-hanging-braces-alist'は、挿入された中括弧の前／後への改行の挿入
を制御します。これは、`(SYNTACTIC-SYMBOL . NL-LIST)'の形の要素から成る
連想リストです。`c-offsets-alist'に現れるほとんどの構文シンボルは、ここ
でも意味を持ちます。

リストNL-LISTは、シンボル`before'か`after'のいずれか、あるいはその両方、
もしくは`nil'を含みます。中括弧が挿入されるときには、その中括弧が定義す
る構文上の文脈を`c-hanging-braces-alist'から探します。みつかれば、
NL-LISTを使って中括弧の前／後／前後のどこに改行を挿入するか決定します。
みつからなければ、デフォルトとして中括弧の前後に改行を挿入します。

変数`c-hanging-colons-alist'は、挿入されたコロンの前／後への改行の挿入
を制御します。これは、`(SYNTACTIC-SYMBOL . NL-LIST)'の形の要素から成る
連想リストです。リストNL-LISTは、シンボル`before'か`after'のいずれか、
あるいはその両方、もしくは`nil'を含みます。

コロンが挿入されるときには、そのコロンが定義する構文シンボルをこの連想
リストから探します。みつかれば、NL-LISTを使ってコロンの前／後のどこに改
行を挿入するか決定します。みつからなければ、改行を挿入しません。

自動改行機能がオンのときには、エレクトリック文字は自動的に改行を削除し
ます。この機能により、改行が不要だと思われるもっとも一般的な場面で改行
を削除するので、自動改行機能をユーザーにより受け入れやすくしています。
Emacsは改行を削除することが望ましいいくつかの場面を認識できますが、変数
`c-cleanup-list'を設定すれば、*どの*場面で行うか指定できます。この変数
の値はシンボルのリストです。各要素は、改行を削除してよい場面を1つ指定し
ます。以下に指定できるシンボルとその意味を示します。

`brace-catch-brace'
     `} catch (CONDITION) {'の構造全体を1行に再配置する。
     `catch'やCONDITION以外に中括弧のあいだになにもないときに
     `{'を打つと再配置する。

`brace-else-brace'
     `} else {'の構造全体を1行に再配置する。`else'に続けて`{'を打ったと
     きに再配置するが、中括弧と`else'のあいだに空白以外の文字がない場合
     に限る。

`brace-elseif-brace'
     `} else if (...) {'の構造全体を1行に配置する。
     `{'を打ったときに再配置するが、
     キーワードと`if'の条件式を除いて、
     `}'と`{'のあいだに空白以外の文字がない場合に限る。

`empty-defun-braces'
     空の関数定義の中括弧、`{'と`}'を同じ行に再配置する。閉じ中括弧`}'
     を打ったときに再配置する。

`defun-close-semi'
     `struct'や同様の型宣言のあとのセミコロンを閉じ中括弧と同じ行に再配
     置する。セミコロンを打ったときに再配置する。

`list-close-comma'
     配列／合成体の初期化式の中の閉じ中括弧とそれに続くコンマを同じ行に
     再配置する。コンマを打ったときに再配置する。

`scope-operator'
     C++のスコープ演算子を表している可能性がある2つのコロンを一緒にする。
     2つめのコロンを打ったときに一緒にするが、コロンのあいだに白文字以
     外の文字がない場合に限る。



File: emacs-ja, Node: Hungry Delete, Next: Other C Commands, Prev: Electric C, Up: C Modes

Cの欲張りな削除機能
-------------------

"欲張りな削除"機能をオン（モード行のモード名のあとに`/h'か`/ah'で表示さ
れる）にすると、1つのDELコマンドで、直前の空白1つだけでなく、白文字すべ
てを削除します。この機能をオン／オフにするには、`C-c C-d'を使います。

`C-c C-d'
     欲張り削除機能（`c-toggle-hungry-state'）をオン／オフする。数引数
     を指定した場合、正ならば欲張り削除機能をオンにし、負ならばオフにす
     る。

`C-c C-t'
     自動改行機能と欲張り削除機能を同時にオン／オフする
     （`c-toggle-auto-hungry-state'）。

変数`c-hungry-delete-key'は、欲張り削除機能がオンかオフかを制御します。



File: emacs-ja, Node: Other C Commands, Next: Comments in C, Prev: Hungry Delete, Up: C Modes

Cモードのその他のコマンド
-------------------------

`C-M-h'
     関数定義の末尾にマークを設定し、先頭にポイントを置く
     （`c-mark-function'）。

`M-q'
     CやC++のコメントを考慮して、段落を詰め込む（`c-fill-paragraph'）。
     現在行にコメントがあったり、現在行がコメントの内側なら、コメントの
     字下げとコメント区切りを保存したまま、ポイント位置のコメントや段落
     を詰め込む。

`C-c C-e'
     リージョン内のテキストに対してCプリプロセッサを実行し、マクロ呼び
     出しを展開した結果を表示する（`c-macro-expand'）。リージョンのまえ
     にあるテキストにマクロ定義があることもあるので、それらもプリプロセッ
     サに渡されるが、その部分の出力は表示しない。

     マクロを用いたCのコードをデバッグするとき、どのようにマクロが展開
     されるか正確に理解するのが難しいことがある。このコマンドを使えば、
     マクロ展開のことを考える必要はない。展開結果を目にすることができる。

`C-c C-\'
     リージョン内の行末に`\'文字を挿入したり、行末の`\'の位置揃えを行う
     （`c-backslash-region'）。Cのマクロ定義を書いたり編集したあとに便
     利なコマンド。

     行末がすでに`\'で終っているなら、そのまえに置く白文字の個数を調整
     する。そうでなければ、新たに`\'を挿入する。ただし、リージョン内の
     最後の行は特別扱いする。その行に`\'を挿入することはなく、また、
     `\'がある場合には削除する。

`M-x cpp-highlight-buffer'
     プリプロセッサ指令の条件節に従って、テキストの一部を強調表示する。
     このコマンドは`*CPP Edit*'という名前のバッファを表示する。このバッ
     ファは、特定のプリプロセッサ条件とその内容をどのように表示するかを
     選択するグラフィックメニュー。さまざま設定を変更したあとで、
     `[A]pply these settings'をクリックする（あるいは、そのバッファへ移
     動して`a'と打つ）と、設定に応じてCモードのバッファを強調表示し直す。

`C-c C-s'
     現在のソース行に関する構文上の情報を表示する
     （`c-show-syntactic-information'）。この情報は行の字下げを指示する。



File: emacs-ja, Node: Comments in C, Prev: Other C Commands, Up: C Modes

Cモードのコメント
-----------------

Cモードとその関連モードでは、コメントの整形にいくつかの変数を使います。

`c-comment-only-line-offset'
     コメント開始部分だけを含んだ行に与える余分のオフセット。この変数の
     値は整数、あるいは`(NON-ANCHORED-OFFSET . ANCHORED-OFFSET)'の形の
     コンスセルのどちらでもかまわない。ここで、NON-ANCHORED-OFFSETは、
     1桁目以降から始まるコメントに与えるオフセット。ANCHORED-OFFSETは、
     0桁目から始まるコメントに与えるオフセット。整数値だけの場合は、
     `(VAL . 0)'と等価。

`c-comment-start-regexp'
     コメント開始の識別方法を指定するバッファにローカルな変数。

`c-hanging-comment-ender-p'
     この変数が`nil'であると、`c-fill-paragraph'は、ブロックコメントの
     コメント終了区切りだけの行を作る。デフォルト値は`t'で、コメント終
     了区切り`*/'をコメントの最後の行の末尾に置く。

`c-hanging-comment-starter-p'
     この変数が`nil'であると、`c-fill-paragraph'は、ブロックコメントの
     コメント開始区切りだけの行を作る。デフォルト値は`t'で、コメント開
     始区切り`/*'をコメントの最初の行の先頭に置く。



File: emacs-ja, Node: Fortran, Next: Asm Mode, Prev: C Modes, Up: Programs

Fortranモード
=============

Fortranモードには、Fortranの文と副プログラム向けの特別な移動コマンド、
Fortranの入れ子、行番号と継続文の約束事に従う字下げコマンドがあります。
Fortranモードには、長い行を適切なFortranの継続行に分ける専用の自動詰め
込み（fortran-auto-fill）モードがあります。

Fortranのコメントは他の言語のコメントとは異なっているので、コメントに対
する特別なコマンドもあります。Fortranのキーワードを入力するときの打鍵量
を減らせる、組み込みの略語もあります。

Fortran用のメジャーモードに切り替えるには、`M-x fortran-mode'を使います。
このコマンドは、フック`fortran-mode-hook'を実行します（*Note Hooks::）。

* Menu:

* Motion: Fortran Motion.	 Moving point by statements or subprograms.
* Indent: Fortran Indent.	 Indentation commands for Fortran.
* Comments: Fortran Comments.	 Inserting and aligning comments.
* Autofill: Fortran Autofill.	 Auto fill minor mode for Fortran.
* Columns: Fortran Columns.	 Measuring columns for valid Fortran.
* Abbrev: Fortran Abbrev.	 Built-in abbrevs for Fortran keywords.
* Misc: Fortran Misc.            Other Fortran mode features.



File: emacs-ja, Node: Fortran Motion, Next: Fortran Indent, Prev: Fortran, Up: Fortran

移動コマンド
------------

Fortran モードには、副プログラム（関数やサブルーチン）や文を単位とて移
動するための特別なコマンドがあります。また、副プログラムを囲むリージョ
ンを設定するコマンドもあり、副プログラムをキルしたり移動したりするのに
便利です。


`C-M-a'
     副プログラムの先頭に移動する（`beginning-of-fortran-subprogram'）。
`C-M-e'
     副プログラムの末尾に移動する（`end-of-fortran-subprogram'）。
`C-M-h'
     副プログラムの先頭にポイントを置き、末尾にマークを設定する
     （`mark-fortran-subprogram'）。
`C-c C-n'
     現在の文かつぎの文の先頭に移動する（`fortran-next-statement'）。
`C-c C-p'
     現在の文かまえの文の先頭に移動する（`fortran-previous-statement'）。



File: emacs-ja, Node: Fortran Indent, Next: Fortran Comments, Prev: Fortran Motion, Up: Fortran

Fortranの字下げ
---------------

Fortranのコードでは、構文上の各種要素（行番号、コメント行指示子、継続マー
ク）は標準Fortranが要求する桁に現れるようにしなくてはいけないので、字下
げに関する特別なコマンドと機能が必要です。

* Menu:

* Commands: ForIndent Commands.  Commands for indenting Fortran.
* Contline: ForIndent Cont.      How continuation lines indent.
* Numbers:  ForIndent Num.       How line numbers auto-indent.
* Conv:     ForIndent Conv.      Conventions you must obey to avoid trouble.
* Vars:     ForIndent Vars.      Variables controlling Fortran indent style.



File: emacs-ja, Node: ForIndent Commands, Next: ForIndent Cont, Prev: Fortran Indent, Up: Fortran Indent

Fortranの字下げコマンド
.......................

`TAB'
     現在行を字下げする（`fortran-indent-line'）。
`C-j'
     現在行を字下げしてから、字下げした新たな行を始める
     （`fortran-indent-new-line'）。
`C-M-j'
     ポイント位置で現在行を分割し、継続行を設定する。
`M-^'
     現在行と直前の行を繋げる。
`C-M-q'
     ポイントを含む副プログラムの行をすべて字下げする
     （`fortran-indent-subprogram'）。

Fortranモードでは、Fortranの行を字下げするようにTABを再定義します
（`fortran-indent-line'）。このコマンドは、行番号と継続マークを要求され
る桁位置に字下げしたうえ、それとは独立にプログラム中の入れ子に基づいて
文本体を字下げします。

キー`C-j'は`fortran-indent-new-line'を実行します。これは、現在行を字下
げしてから、新たな行を作成して字下げします。新たな行を始めるまえに、
`do'ループやその他のブロックを閉じる文を字下げし直すのに便利です。

キー`C-M-q'は、ポイントを含むFortranの副プログラム（関数やサブルーチン）
の行すべてを字下げするコマンド`fortran-indent-subprogram'を実行します。

キー`C-M-j'は、適切な方法でFortranの行を分割するコマンド
`fortran-split-line'を実行します。コメント行でなければ、後半部を継続行
にし、それに応じて字下げします。コメント行ならば、前後半部分とも独立し
たコメント行になります。

`M-^'は、`fortran-split-line'の逆操作を行うコマンド`fortran-join-line'
を実行します。現在行と直前の行を、Fortranコードとして適切に繋げます。



File: emacs-ja, Node: ForIndent Cont, Next: ForIndent Num, Prev: ForIndent Commands, Up: Fortran Indent

継続行
......

近代的なほとんどのFortranコンパイラには、継続行の記述方法が2つ用意され
ています。ある行の空白でない最初の文字が5桁目にあれば、先行する行の継続
行です。このスタイルを"固定フォーマット"と呼びます。（GNU Emacsでは、桁
位置はつねに0から数える。）変数`fortran-continuation-string'は、5桁目に
置く文字を指定します。タブ文字で始まり`0'以外の数字が続く行も継続行です。
このスタイルを"タブフォーマット"と呼びます。

Fortranモードではどちらのスタイルの継続行も利用できますが、希望するほう
を指定する必要があります。変数`indent-tabs-mode'の値で希望を指定します。
`nil'ならば固定フォーマット、`nil'以外ならばタブフォーマットになります。
モード行に文字列`Tab'があるかどうかで、現在使用しているスタイルがわかり
ます。

Fortranモードでは、テキストが慣用的なFortranの継続マーク`$'で始まる、あ
るいは、5桁目から白文字以外の文字で始まる場合には、その行を継続行として
扱います。TABで継続行を字下げすると、選択されている継続行のスタイルに変
換します。`C-M-j'でFortranの文を分割すると、継続行のスタイルに応じて新
たな行には継続マークを付けます。

継続行のスタイルは、Fortranモードでの編集に関わるその他の側面にも影響し
ます。固定フォーマットでは、文本体を置く最小桁位置は6になります。
Fortranのブロックの内側にある行を7桁目以降に字下げするときには、白文字
には空白文字を使います。一方、タブフォーマットでは、文本体を置く最小桁
位置は8で、8桁目よりまえの白文字はつねにタブ文字です。

既存のファイルに対してFortranモードに入ると、
その内容から自動的に適切な継続行のスタイルを推測しようとします。
タブ文字か空白6個で始まる最初の行でスタイルを判断します。
変数`fortran-analyze-depth'で、
（ファイルの先頭から）何行分をスタイル判断に使用するか指定します。
この範囲内にスタイルを示すような行がみつからなければ、
変数`fortran-tab-mode-default'がスタイルを指定します。
`nil'なら固定フォーマット、`nil'以外ならタブフォーマットです。



File: emacs-ja, Node: ForIndent Num, Next: ForIndent Conv, Prev: ForIndent Cont, Up: Fortran Indent

行番号
......

ある行の白文字以外の最初の文字が数字であれば、Fortranの字下げではそれを
行番号とみなして0桁目から4桁目のあいだに移動します。（GNU Emacsでは、桁
位置はつねに0から始まる。）

通常、4桁以下の行番号は空白1個で字下げします。変数
`fortran-line-number-indent'でこの字下げ幅を制御します。この変数の値は、
行番号の最大字下げ幅を表します。最大字下げ幅まで字下げできなくなると、
行番号の最後の桁が4桁目になるように右揃えで字下げします。この変数のデフォ
ルト値は1です。

これらの規則に従って行番号を字下げするには、行番号を挿入するだけで十分
です。行番号の各桁が挿入されるたびに、字下げ幅を再計算します。この機能
をオフにするには、変数`fortran-electric-line-number'に`nil'を設定します。
こうすると、行番号の挿入はその他の文字の挿入と同様に行われます。



File: emacs-ja, Node: ForIndent Conv, Next: ForIndent Vars, Prev: ForIndent Num, Up: Fortran Indent

構文上の規約
............

Fortranモードでは、適切な字下げをするためのFortranプログラムの解釈を簡
単にするために、以下の規約に従っているものと仮定します。

   * 2つの入れ子になった`do'ループは、けっして`continue'文を共有しない。

   * `if'、`else'、`then'、`do'といったFortranのキーワードは、あいだに
     空白があったり、途中で行分けされない。

     一般にFortranコンパイラは文字列定数の外側にある空白を無視するが、
     Fortranモードは途中に空白が入っているキーワードを認識しない。
     `else if'や`end do'のような書き方は許されるが、2つの単語を同じ行に
     置いた場合に限る。継続行に分かれていると認識しない。

以上の規約に従っていない場合には、行を美しく字下げできないこともありま
す。しかしながら、たとえ規約に従っていなくても、正しいFortranプログラム
であれば字下げによって意味が変わることはありません。



File: emacs-ja, Node: ForIndent Vars, Prev: ForIndent Conv, Up: Fortran Indent

Fortranの字下げのための変数
...........................

Fortranの字下げ動作に影響する変数がいくつかあります。

`fortran-do-indent'
     `do'文の各レベルごとに追加する字下げ幅（デフォルトは3）。

`fortran-if-indent'
     `if'文の各レベルごとに追加する字下げ幅（デフォルトは3）。この値は、
     Fortran 90の`where'文の字下げにも使われる。

`fortran-structure-indent'
     `structure'、`union'、`map'の各文の各レベルごとに追加する字下げ幅
     （デフォルトは3）。

`fortran-continuation-indent'
     継続行の文本体に追加する字下げ幅（デフォルトは5）。

`fortran-check-all-num-for-matching-do'
     この変数が`nil'なら、字下げ処理では、`do'文は`continue'文で終って
     いると仮定する。こうすると、`continue'以外の文の字下げを計算すると
     きに、当該文が`do'文を終えるかどうか検査しなくてよいので、時間を節
     約できる。この変数が`nil'以外であれば、行番号が付いた文の字下げを
     計算するときには、当該文が`do'文を終えるかどうか検査する必要がある。
     デフォルト値は`nil'。

`fortran-blink-matching-if'
     この変数が`t'なら、`endif'文の字下げを行うときに、対応する`if'文を
     示すために一時的にカーソルを移動する。デフォルト値は`nil'。

`fortran-minimum-statement-indent-fixed'
     固定フォーマットの継続行スタイルを採用したときの、文に対する最小字
     下げ幅。文本体の字下げ幅がこの値より小さくなることはない。デフォル
     ト値は6。

`fortran-minimum-statement-indent-tab'
     タブフォーマットの継続行スタイルを採用したときの、文に対する最小字
     下げ幅。文本体の字下げ幅がこの値より小さくなることはない。デフォル
     ト値は8。



File: emacs-ja, Node: Fortran Comments, Next: Fortran Autofill, Prev: Fortran Indent, Up: Fortran

Fortranのコメント
-----------------

Emacsの通常のコメント用コマンドは、コメントをコードのあとにも置けると仮
定します。Fortranでは、標準的なコメントの構文は、1つの行全体を必要とし
ます。そのため、Fortranモードでは、Emacsの通常のコメント用コマンドを置
き換え、新たな変数をいくつか定義しています。

Fortranモードでは、文字`!'で始まり他のテキストのあとにも置ける非標準的
なコメントの構文も扱えます。しかし、この構文を受け付けるFortranコンパイ
ラは限られるため、まえもって指定しておかない限り、Fortranモードは非標準
のコメントを使いません。このスタイルのコメントを使うには、変数
`comment-start'に`"!"'を設定します（*Note Variables::）。

`M-;'
     コメントの位置を揃えたり、新たなコメントを挿入する
     （`fortran-indent-comment'）。

`C-x ;'
     非標準の`!'コメントだけに作用する。

`C-c ;'
     リージョン内のすべての行をコメントにする。あるいは、（引数を指定す
     ると）コメントをコードに戻す（`fortran-comment-region'）。

Fortranモードの`M-;'は、コマンド`fortran-indent-comment'に再定義されて
います。通常の`M-;'と同じく、既存のコメントを認識して、そのテキストの桁
位置を揃えます。コメントがなければ、コメントを挿入して桁位置を揃えます。
しかし、Fortranモードのコメントの挿入と揃え方は、他のモードと同じではあ
りません。

新たにコメントを挿入する場合、現在行が空行のときは（1行全体を占める）行
コメントを挿入します。空行でないとき、非標準のコメントを使うように指定
してあれば非標準の`!'コメントを挿入します。いずれでもないときには、現在
行のまえに行コメントを挿入します。

非標準の`!'コメントは他の言語のコメントと同じように揃えられますが、行コ
メントの場合はようすが異なります。標準の行コメントでは、コメント区切り
はつねに0桁目にある必要があります。コメント内部のテキストだけを揃えます。
`fortran-comment-indent-style'を設定して、3種類の揃え方を選べます。

`fixed'
     `fortran-comment-line-extra-indent'と文に対する最小字下げ幅を合計
     した桁位置にテキストを揃える。デフォルトはこれ。

     文の最小字下げ幅は、固定フォーマットの継続行スタイルの場合には
     `fortran-minimum-statement-indent-fixed'の値、タブフォーマットの場
     合には`fortran-minimum-statement-indent-tab'の値。

`relative'
     コード行であるかのように揃えるが、
     `fortran-comment-line-extra-indent'だけ余計に桁をずらす。

`nil'
     行コメントのテキストを勝手に動かさない。

また、行コメントの字下げ文字を変更したければ、変数
`fortran-comment-indent-char'に好みの1文字を設定してください。

Fortranモードには、`comment-line-start'と`comment-line-start-skip'の2つ
の変数が新たに導入されています。これらは、コードのあとに置く通常のコメ
ントに対する`comment-start'と`comment-start-skip'と同様の役割を、行コメ
ントに対して果たします。どちらもFortranモードが適切に設定するので、変更
する必要はありません。

Emacsの通常のコメント用コマンド`C-x ;'は、再定義されていません。このコ
マンドは`!'コメントを扱えます。`!'コメントを使っていない場合には、この
コマンドはFortranモードでは役に立ちません。

コマンド`C-c ;'（`fortran-comment-region'）は、リージョン内のすべての行
の先頭に`C$$$'を挿入してコメントに変えます。数引数を指定すると、行の先
頭から`C$$$'を削除して、リージョンを生きたコードに戻します。これらのコ
メントに使う文字列は、変数`fortran-comment-region'の設定で制御できます。
ところで、ここではコマンドと変数に同じ名前が使われています。Lispや
Emacsにおいては、使用される文脈からコマンドと変数をつねに区別できるので、
このような名前の使い方が問題を起こすことはありません。



File: emacs-ja, Node: Fortran Autofill, Next: Fortran Columns, Prev: Fortran Comments, Up: Fortran

Fortran専用自動詰め込み（fortran-auto-fill）モード
--------------------------------------------------

Fortran専用自動詰め込み（fortran-auto-fill）モードは、挿入したFortranの
文が長くなりすぎると自動的に文を分割するマイナモードです。文を分割する
には、`fortran-continuation-string'（*Note ForIndent Cont::）を用いて継
続行を作ります。SPC、RET、TABを打ったときや、字下げコマンドを使ったとき
に分割されます。

`M-x fortran-auto-fill-mode'は、
Fortran専用自動詰め込み（fortran-auto-fill）モードがオンならばオフにし、
オフならばオンにします。
このコマンドは、通常の自動詰め込み（auto-fill）モード
（*Note Filling::）である`M-x auto-fill-mode'が行うのと
同じように働きます。
正の数引数を指定すると、
Fortran専用自動詰め込み（fortran-auto-fill）モードをオンにし、
負であればオフにします。
このモードのオン／オフは、モード行の括弧の中に`Fill'が
あるかどうかで判断できます。
Fortran専用自動詰め込み（fortran-auto-fill）モードはマイナモードなので、
各バッファごとに独立にオン／オフにできます。
*Note Minor Modes::。

Fortran専用自動詰め込み（fortran-auto-fill）モードは、行の長さが規定の
幅（`fill-column'の値）を越えると、空白や区切りの位置で行を分割します。
Fortran専用自動詰め込み（fortran-auto-fill）が分割する区切りは、`,'、
`''、`+'、`-'、`/'、`*'、`='、`)'です。変数
`fortran-break-before-delimiters'が`nil'の場合には、区切りのうしろで分
割します。それ以外（デフォルトでもある）では、区切りのまえで分割します。

デフォルトではFortran専用自動詰め込み（fortran-auto-fill）モードはオフです。
この機能を恒常的に使いたければ、
`(fortran-auto-fill-mode 1)'を実行するフック関数を
`fortran-mode-hook'に追加してください。
*Note Hooks::。



File: emacs-ja, Node: Fortran Columns, Next: Fortran Abbrev, Prev: Fortran Autofill, Up: Fortran

桁位置の確認
------------

`C-c C-r'
     現在行の上にしばらくのあいだ『桁定規』を表示する
     （`fortran-column-ruler'）。
`C-c C-w'
     現在のウィンドウを一時的に分割して幅を72桁にする。一部のFortranコ
     ンパイラは1行を72文字以内に制限しているので、このコマンドを使用す
     れば1行が長くなりすぎることを防げる
     （`fortran-window-create-momentarily'）。

コマンド`C-c C-r'（`fortran-column-ruler'）は、桁定規をしばらくのあいだ、
現在行の上に表示します。桁定規は、Fortranプログラムにおいて特別な意味を
もつ桁位置を表す2行のテキストです。2行目の角括弧と中括弧で、それぞれ、
行番号と文の本体の範囲を表します。桁番号は（それらの上の）1行目に表示さ
れます。

GNU Emacsでは桁番号をつねに0から数えることに注意してください。その結果、
桁定規に示される桁番号は、慣れ親しんだものより1だけ小さくなります。しか
し、それらが表す位置はFortranの標準に従ったものです。

桁定規の表示に用いるテキストは、変数`indent-tabs-mode'の値に依存します。
この変数の値が`nil'ならば、変数`fortran-column-ruler-fixed'の値を桁定規
の表示に使います。`nil'以外であれば、変数`fortran-column-ruler-tab'の内
容を表示に使います。これらの変数の内容を変更すれば、桁定規の表示を変更
できます。

さらに桁合わせを支援するために、`C-c C-w'（`fortran-window-create'）は、
現在のウィンドウを幅が72桁になるように横位置で分割します。このウィンド
ウで編集すれば、正しいFortranのプログラムとしては長すぎる行を即座に発見
できます。



File: emacs-ja, Node: Fortran Abbrev, Next: Fortran Misc, Prev: Fortran Columns, Up: Fortran

Fortranのキーワードの略語
-------------------------

Fortranモードには、一般的なキーワードや宣言に対する
数多くの組み込み略語があります。
これらは、ユーザー自身が定義できる略語と同じ種類のものです。
それらを使うには、略語（abbrev）モードをオンにします。
*Note Abbrevs::。

組み込み略語は他の略語と1つの点で変わっています。すべてセミコロンで始ま
ります。通常は略語にはセミコロンを使えませんが、Fortranモードでは、セミ
コロンの構文上の意味を『単語を構成する文字』に変更することで、これを可
能にしています。

たとえば、`continue'に対する組み込みFortran略語は`;c'です。
略語（abbrev）モードがオンのときに、
`;c'を挿入してから空白や改行といった句読点文字を挿入すると、
`;c'は自動的に`continue'と展開されます。

組み込みFortran略語とその展開形の一覧を表示するには、
`;?'あるいは`;C-h'と打ちます。



File: emacs-ja, Node: Fortran Misc, Prev: Fortran Abbrev, Up: Fortran

Fortranモードのその他のコマンド
-------------------------------

`C-x n d'
     現在のFortranの副プログラムにナロイングする。

Fortranモードでは、キー`C-x n d'はコマンド
`fortran-narrow-to-subprogram'を実行するように再定義しています。このコ
マンドは、キーの通常の定義をFrotran風にしたものです。バッファをポイント
を含む副プログラムにナロイングします。



File: emacs-ja, Node: Asm Mode, Prev: Fortran, Up: Programs

asmモード
=========

asmモードは、アセンブリコードのファイルを編集するためのメジャーモードで
す。つぎのコマンドが定義されています。

`TAB'
     `tab-to-tab-stop'。
`C-j'
     改行を挿入し、`tab-to-tab-stop'で字下げする。
`:'
     コロンを挿入し、コロンに先行するラベルのまえの字下げを取り除く。そ
     して、`tab-to-tab-stop'を行う。
`;'
     コメントの挿入／位置揃えを行う。

変数`asm-comment-char'は、アセンブラ構文でコメントを開始する文字を指定
します。


File: emacs-ja, Node: Building, Next: Maintaining, Prev: Programs, Up: Top

プログラムのコンパイルとテスト *(2004/09/07)*
*********************************************

前章ではプログラムの変更に便利なEmacsコマンドを説明しました．本章ではプ
ログラムの大規模な開発や保守を助けるコマンドを説明します．

* Menu:

* Compilation::         Compiling programs in languages other
                          than Lisp (C, Pascal, etc.).
* Grep Searching::      Running grep as if it were a compiler.
* Compilation Mode::    The mode for visiting compiler errors.
* Compilation Shell::   Customizing your shell properly
                          for use in the compilation buffer.
* Debuggers::	        Running symbolic debuggers for non-Lisp programs.
* Executing Lisp::      Various modes for editing Lisp programs,
                          with different facilities for running
                          the Lisp programs.
* Libraries: Lisp Libraries.      Creating Lisp programs to run in Emacs.
* Interaction: Lisp Interaction.  Executing Lisp in an Emacs buffer.
* Eval: Lisp Eval.      Executing a single Lisp expression in Emacs.
* External Lisp::         Communicating through Emacs with a separate Lisp.



File: emacs-ja, Node: Compilation, Next: Grep Searching, Prev: Building, Up: Building

Emacs下でのコンパイラの実行 *(2004/08/16)*
==========================================

EmacsはCやFortranのような非対話的な言語のコンパイラを下位プロセスとして
実行でき，そのエラーログをEmacsバッファに取り込めます．また，エラーメッ
セージを解析して，コンパイルエラーを起こしたソース行を提示することもで
きます．

`M-x compile'
     Emacs下でコンパイラを非同期に実行し，エラーメッセージを
     `*compilation*'バッファに取り込む．
`M-x recompile'
     `M-x compile' で最後に実行したものと同じコマンドでコンパイラを実行します．
`M-x grep'
     Emacs下で`grep'を非同期に実行し，一致した行を`*grep*'バッファに取
     り込む．
`M-x grep-find'
     指定した引数で`find'と`grep'を実行し，出力を`*grep*'バッファに取り
     込む．
`M-x kill-compilation'
`M-x kill-grep'
     実行中のコンパイラや`grep'のサブプロセスを停止させる．

`make'や他のコンパイルコマンドを実行するには，`M-x compile'と打ちます．
このコマンドは，ミニバッファでシェルコマンドを読み取り，そのコマンドを
下位シェルで実行し，出力結果を`*compilation*'という名のバッファに取り込
みます．カレントバッファのデフォルトディレクトリをシェルコマンド実行時
の作業ディレクトリとして用います．そのため，通常はこのディレクトリにあ
るものをコンパイルします．

シェルコマンド行を読み取るとき，ミニバッファにはデフォルトのシェルコマ
ンド行が表示されますが，これは前回`M-x compile'を使ったときのコマンドで
す．単にRETだけを打鍵すると，同じシェルコマンド行を再使用します．最初の
`M-x compile'では，デフォルトは`make -k'です．それは，ほとんどの場合，
正しいものです．(*Note Make: (make)Top)．デフォルトのコンパイルコマンド
は変数`compile-command'から取ります．適切なコンパイルコマンドが他にある
場合には，ファイルでこの変数のローカルな値を指定すると便利でしょう
（*Note File Variables::）．

コンパイルが始まると，バッファ`*compilation*'は別のウィンドウに表示され
ますが，選択されるわけではありません．このバッファのモード行では，括弧
の中に単語`run'か`exit'を表示してコンパイルが終了したかどうか示します．
このバッファを見えるようにしておく必要はありません．いずれにしても，コ
ンパイルは継続されます．コンパイル中は，すべてのウィンドウのモード行に
文字列`Compiling'が表示されます．この文字列が消えれば，コンパイルは終了
しています．

コンパイルの進行状況を見たい場合には，`*compilation*'バッファに切り替え
てポイントをバッファの末尾に移動します．ポイントがバッファの末尾にある
と，新らたなコンパイル出力はポイントのまえに挿入されポイントは末尾に留
まります．ポイントがバッファの末尾にないと，コンパイル出力はバッファの
末尾に追加されますがポイントは途中の場所に留まったままです．

変数`compilation-scroll-output'に`nil'以外の値を設定すると，出力が到着
するたびに出力に追従するようにコンパイルバッファをつねにスクロールしま
す．

理由は何であれ，コンパイルプロセスが終了すると，`*compilation*'バッファの
モード行の表示が`run'から`signal'に変わります．
一度に実行可能なコンパイルは1つだけなので，
新しくコンパイルを始めると実行中のコンパイルは停止させられます．
しかし，`M-x compile'は，
実行中のコンパイルを実際に停止させるかどうか聞いてきます．コンパイルプロセスは
`M-x kill-compilation' でも停止できます．

同じコマンドで最後のコンパイルを実行するためには，`M-x recompile' とし
ます．これで，自動的に最後に実行した `M-x compile' のコンパイルコマンド
を再利用してくれます．

Emacs はコンパイルプロセスが非同期のサブプロセスを開始させることを想定
していません．もし非同期のサブプロセスを開始して，メインプロセスが終了
した後にサブプロセスが走っていると，Emacs はサブプロセスを終了させ，出
力が得られないかもしれません．これを避けるために，メインプロセスはサブ
プロセスが終了するまで待つようにする必要があります．shell スクリプトで
は以下のように `$!' と `wait' を使うことで回避できます．

     (sleep 10; echo 2nd)& pid=$!  # サブプロセスの pid を記録
     echo first message
     wait $pid                     # サブプロセスの終了を待つ



File: emacs-ja, Node: Grep Searching, Next: Compilation Mode, Prev: Compilation, Up: Building

Emacs下でのgrepによる探索 *(2004/08/16)*
========================================

Emacsからコンパイラを実行し，コンパイルエラーを起こした行を訪れることが
できるように，`grep'を実行して一致した行を訪れることができます．これは，
`grep'が報告した一致を『エラー』として扱うことで行います．

それには，`M-x grep'と打鍵してから，
`grep'をどのように実行するかを指定するコマンド行を入力します．
普通に`grep'を実行するときに指定する引数と同じものを使います．
つまり，`grep'流の
（普通，シェルの特殊文字をクォートするためにシングルクォートで囲んだ）
正規表現に続けて，ワイルドカードなどを用いたファイル名を指定します．
`grep'の出力は`*grep*'バッファに入ります．
ファイル内の対応する行を探すには，コンパイルエラーの場合と同様に，
`C-x `'とRETを使います．

`M-x grep'に前置引数を指定すると，ポイントの周りから（探すべき）タグを
推測してデフォルトの`grep'コマンドにそれを含めます．

`M-x grep-find'は`M-x grep'コマンドと同様ですが，
シェルコマンドに与える最初のデフォルトが違います．
`find'と`grep'の両方を実行して，
ディレクトリ木構造下の各ファイルを探索します．
*Note Dired and Find::の`find-grep-dired'コマンドも参照してください．



File: emacs-ja, Node: Compilation Mode, Next: Compilation Shell, Prev: Grep Searching, Up: Building

コンパイルモード *(2004/08/16)*
===============================

`*compilation*'バッファは，コンパイル（compilation）モードと呼ばれる特
別なメジャーモードになります．このモードの主な機能は，エラーが起きたソー
ス行を簡単に参照できることです．

もし 変数  `compilation-scroll-output' を非 `nil' にすると，
`*compilation*' バッファはいつも出力を追い掛けるようにスクロールします．

`C-x `'
     つぎのコンパイルエラーや`grep'のつぎの一致に対応する箇所を訪れる．
`RET'
     ポイントが位置するエラーメッセージに対応する箇所を訪れる．このコマ
     ンドは，コンパイルバッファで使う．
`Mouse-2'
     マウスでクリックしたエラーメッセージに対応する箇所を訪れる．

`*compilation*' バッファでエラーメッセージにポイントを持っていって
RET（`compile-goto-error'）を打鍵すれば，そのエラーの原因となったソース
を訪問できます．代わりに，エラーメッセージを`Mouse-2'でクリックできます．
このときは，あらかじめ`*compilation*'バッファに切り替えておく必要はあり
ません．

コンパイラのエラーメッセージを順番に解析するには，`C-x
`'（`next-error'）と打鍵します．`C-x'に続く文字は，シングルクォートでは
なくバッククォート，すなわち，『アクサングレーブ』です．このコマンドは
`*compilation*'だけでなく，すべてのバッファで使用可能です．このコマンド
は，一方のウィンドウの先頭にエラーメッセージを表示し，別のウィンドウに
エラーとなったソースコードを表示します．

コンパイル開始後に最初に`C-x `'を使うと，
最初のエラー箇所に移動します．
続けて`C-x `'を実行すると，次々にエラー箇所に移動していきます．
RETや`Mouse-2'で特定のエラー箇所に移動したあとに
`C-x `'コマンドを実行すると，その場所のつぎのエラー箇所に移動します．
バッファの末尾に到達してもうエラーメッセージがないと，
`C-x `'コマンドは失敗し，エラーを通知します．

`C-u C-x `'は，コンパイルバッファの先頭から解析を始めます．コンパイルを
やり直さずに一連のエラーの解析をもう一度行う方法の1つです．

コンパイラからの出力を解析するために，コンパイルモードでは変数
`compilation-error-regexp-alist' を使います．この変数はエラーメッセージや
出力からソースファイルと行数を得るといったさまざまな書式のリストになっています．
もしコンパイラがサポートされていなければ，要素をリストに追加することでコンパイル
モードをそのコンパイラのために仕立てることができます．よく似た変数である
`grep-regexp-alist' は Emacs が `grep' の結果を解析するために使います．

コンパイル（compilation）モードでは，
SPCキーとDELキーを1画面分のスクロールに，
`M-n'と`M-p'を1つつぎ／まえのエラーメッセージへの移動に再定義します．
また，別のソースファイルのエラーメッセージへの移動には，
`M-{'と`M-}'コマンドを使えます．

コンパイル（compilation）モードの機能は，
コンパイルマイナ（compilation-minor）モードと呼ばれるマイナモードでも
使えます．
これにより，普通のコンパイルバッファだけでなく任意のバッファ内の
エラーメッセージを解析できます．
このマイナモードをオンにするには，
 `M-x compilation-minor-mode'と打鍵します．
すると，メジャーモードのコンパイル（compilation）モードと同様に
RETキーと`Mouse-2'を定義します．

バッファの内容が認識できる形式である限り，コンパイルマイナ
（compilation-minor）モードは任意のバッファで動作します．rloginバッファ
（*Note Remote Host::）では，コンパイルマイナ（compilation-minor）モー
ドはリモートのソースファイルをFTPで自動的に取ってきます（*Note File
Names::）．



File: emacs-ja, Node: Compilation Shell, Next: Debuggers, Prev: Compilation Mode, Up: Building

コンパイルのためのサブシェル *(2004/08/16)*
===========================================

Emacsはシェルを使ってコンパイルコマンドを実行しますが，非対話的なシェル
になるようなオプションを指定します．つまり，シェルはプロンプトを出さず
に実行を開始するはずです．`*compilation*'バッファに通常のシェルプロンプ
トがぶざまに現れる場合は，個人のシェル初期化ファイルでプロンプトを無条
件に設定していることを意味します．（シェル初期化ファイルの名前は，
`.bashrc'，`.profile'，`.cshrc'，`.shrc'などだが，使っているシェルによっ
てさまざまな場合がある．）シェル初期化ファイルでは，プロンプトがすでに
設定されているときだけプロンプトを再設定するべきです．たとえば，`csh'で
は以下のようにします．

     if ($?prompt) set prompt = ...

bashでは以下のようにします．

     if [ "${PS1+set}" = set ]
     then PS1=...
     fi

読者のシェル初期化ファイルには，対話的なシェルに対してだけ本来は設定す
るべきことがまだあるかもしれません．同じ方法を用いて，それらを状況に応
じて設定するようにできます．

MS-DOS『オペレーティングシステム』では，
非同期のサブプロセスを使えません．
対応策として，MS-DOSでは`M-x compile'は
コンパイルコマンドを同期的に実行します．
その結果，Emacs上で他の作業を行うには，
コンパイルコマンドの終了を待つ必要があります．
*Note MS-DOS::．



File: emacs-ja, Node: Debuggers, Next: Executing Lisp, Prev: Compilation Shell, Up: Building

Emacs下でのデバッガの実行 *(2004/09/07)*
========================================

GUD（Grand Unified Debugger，大統一デバッガ）ライブラリは，Emacsからさ
まざまなデバッガへのインターフェイスを提供します．フリーソフトウェアで
あるGDBをお勧めしますが，DBX，SDB，XDBを持っているならばそれらを使うこ
ともできます．GUDは，Perlのデバッグモード，PythonのデバッガPDB，Javaデ
バッガJDBに対するインターフェイスにもなります．Emacs Lisp のデバッグに
関する詳細は *Note The Lisp Debugger: (elisp)Debugging を参照のこと．

* Menu:

* Starting GUD::	How to start a debugger subprocess.
* Debugger Operation::	Connection between the debugger and source buffers.
* Commands of GUD::	Key bindings for common commands.
* GUD Customization::	Defining your own commands for GUD.
* GUD Tooltips::        Showing variable values by pointing with the mouse.
* GDB Graphical Interface::  An enhanced mode that uses GDB features to
                        implement a graphical debugging environment through
                        Emacs.



File: emacs-ja, Node: Starting GUD, Next: Debugger Operation, Prev: Debuggers, Up: Debuggers

GUDの起動 *(2004/08/16)*
------------------------

デバッガを開始するコマンドはいくつかあり，それぞれ，特定のデバッガに対
応しています．

`M-x gdb RET FILE RET'
     EmacsのサブプロセスとしてGDBを実行する．このコマンドは，GDBへの入
     出力用のバッファを新たに作り，そのバッファへ切り替える．GDBバッファ
     が既存の場合は，そのバッファへ切り替えるだけ．

`M-x gdba RET FILE RET'
     EmacsのサブプロセスとしてGDBを実行する．このコマンドはGDBの機能に
     対して Emacs からグラフィカルなインターフェイスで操作できるように
     します．*Note GDB Graphical Interface::．

`M-x dbx RET FILE RET'
     同様に，GDBのかわりにDBXを実行する．

`M-x xdb RET FILE RET'
     同様に，GDBのかわりにXDBを実行する．ソースファイルを探索するディレ
     クトリ群を指定するには，変数`gud-xdb-directories'を使う．

`M-x sdb RET FILE RET'
     同様に，GDBのかわりにSDBを実行する．

     SDBのバージョンによっては，メッセージにソースファイル名を含めない
     ものがある．そのようなSDBを使う場合には，GUDがソースコードから関数
     を探せるように正しいタグテーブル（*Note Tags::）が必要である．タグ
     テーブルを訪問していなかったり，タグテーブルに当該関数がなかったり
     すると，`The sdb support requires a valid tag table to work'という
     メッセージが表示される．このような場合には，作業ディレクトリに正し
     いタグファイルを生成してからやり直す．

`M-x perldb RET FILE RET'
     PerlプログラムFILEをデバッグするためにPerlインタープリタをデバッグ
     モードで実行する．

`M-x jdb RET FILE RET'
     FILEをデバッグするためにJavaデバッガを実行する．

`M-x pdb RET FILE RET'
     FILEをデバッグするためにPythonデバッガを実行する．

これらのコマンドは引数を1つ，つまり，デバッガを起動するコマンド行を取り
ます．もっとも単純な場合は，デバッグしたい実行ファイルの名前を指定しま
す．デバッガに指定できるオプションを使うこともできます．しかし，シェル
のワイルドカードや変数名は使えません．GUDは，`-'で始まらない最初の引数
をデバッグする実行ファイル名であると仮定します．

Emacsはデバッガプロセスを一度に1つだけ実行できます．



File: emacs-ja, Node: Debugger Operation, Next: Commands of GUD, Prev: Starting GUD, Up: Debuggers

デバッガの操作 *(2004/08/16)*
-----------------------------

GUDの下でデバッガを実行すると，デバッガは通常の入出力にEmacsバッファを
使います．このバッファをGUDバッファと呼びます．デバッガはEmacsバッファ
でファイルを訪問して，プログラムのソースファイルを表示します．このよう
なバッファの1つに矢印（`=>'）が表示され，現在実行している行を表示します
(1) (*Note Debugger Operation-Footnotes::)．このバッファでポイントを動
かしても矢印は動きません．

ソースファイルを表示したバッファでは，いつでもソースファイルを編集でき
ます．矢印はファイルのテキストの一部ではなく，画面上に表示されているだ
けです．ソースファイルを変更するとき，行を挿入／削除すると矢印の表示位
置情報が失われることに注意してください．GUDには，変更前のデバッガメッセー
ジから変更後の対応する行番号を知る術はありません．また，デバッガにソー
スの変更を反映するには，プログラムを再コンパイルしてから再実行する必要
があります．

お好みならば，シェル（shell）モードの変形を用いた
デバッガバッファを介して，デバッガプロセスを完全に制御することもできます．
こうすれば，デバッガのすべてのコマンドを利用でき，
シェル（shell）モードの履歴機能を用いて
コマンドを繰り返し実行できます．
*Note Shell Mode::．


File: emacs-ja  Node: Debugger Operation-Footnotes, Up: Debugger Operation

(1) ウィンドウシステム下では，Emacs ウィンドウの左フリンジに矢印を表示
します



File: emacs-ja, Node: Commands of GUD, Next: GUD Customization, Prev: Debugger Operation, Up: Debuggers

GUDのコマンド *(2004/08/16)*
----------------------------

GUD対話バッファはシェル（shell）モードの変形を使うので，シェル（shell）
モードのコマンドを使えます（*Note Shell Mode::）．GUDモードでは，ブレー
クポイントの設定と解除，スタックフレームの選択，プログラムのステップ実
行などのコマンドもあります．これらのコマンドはGUDバッファでもそれ以外で
も使えますが，キーバインドは異なります．また，適切なアイコンをクリック
することで一般的なコマンドを実行できるツールバーも利用できます．この機
能は，gud-next や gud-step，GUDバッファを隠すといったように繰り返し実行
するようなコマンドで特に便利でしょう．

ブレークポイントコマンドは，普通，ソースファイルのバッファで使います．
というのは，ソース上でブレークポイントを設定／解除するのが最も簡単な方
法だからです．以下はブレークポイントを設定するグローバルコマンドです．

`C-x SPC'
     ポイントがあるソース行にブレークポイントを設定する．

以下はその他のGUDモード特有のコマンドです．`C-c'で始まるキー列は，GUD対
話バッファだけで使えます．`C-x C-a'で始まるキー列は，GUD対話バッファと
ソースファイル（のバッファ）の両方で使えます．

`C-c C-l'
`C-x C-a C-l'
     GUDバッファで参照した最後の行を別のウィンドウに表示する（つまり，
     最新の実行位置メッセージが指す行を表示する）．これは，コマンド
     `gud-refresh'を実行する．

`C-c C-s'
`C-x C-a C-s'
     ソースコード1行分を実行する（`gud-step'）．その行に関数呼び出しが
     含まれる場合は，呼び出された関数に入ってから停止する．

`C-c C-n'
`C-x C-a C-n'
     ソースコード1行分を実行し，関数呼び出しでも停止せずにフルスピード
     で実行する（`gud-next'）．

`C-c C-i'
`C-x C-a C-i'
     機械語1命令を実行する（`gud-stepi'）．

`C-c C-r'
`C-x C-a C-r'
     停止位置を指定せずに実行を継続する．プログラムの実行は，ブレークポ
     イントに出会う，プログラムが終了する，デバッガが監視しているシグナ
     ルを受け取るまで実行を継続する．

`C-c C-d'
`C-x C-a C-d'
     現在のソース行にブレークポイントがあるならばそれを削除する
     （`gud-remove'）．GUD対話バッファでこのコマンドを使うと，プログラ
     ムが最後に停止した行に適用される．

`C-c C-t'
`C-x C-a C-t'
     現在のソース行に一時的なブレークポイントを設定する．GUD対話バッファ
     でこのコマンドを使うと，プログラムが最後に停止した行に適用される．

上にあげたコマンドは，（GUDから使える）すべてのデバッガに共通です．GDB
やDBX（のあるバージョン）では，さらに以下のコマンドも使えます．

`C-c <'
`C-x C-a <'
     1つ外側のスタックフレームを選択する（`gud-up'）．これは`up'コマン
     ドと等価．

`C-c >'
`C-x C-a >'
     1つ内側のスタックフレームを選択する（`gud-down'）．これは`down'コ
     マンドと等価．

GDBを使う場合には以下のコマンドも使用できます．

`C-c C-r'
`C-x C-a C-r'
     プログラムの実行を開始する (`gud-run')．

`C-c C-u'
`C-x C-a C-u'
     現在行まで実行を継続する．プログラムの実行は，ブレークポイントに出
     会う，プログラムが終了する，デバッガが監視しているシグナルを受け取
     るか，カーソルが現在ある行まで到達するまで実行を継続する．

`TAB'
     GDBでは，シンボル名を補完する（`gud-gdb-complete-command'）．この
     キーはGUDの対話バッファでだけ使える．また，GDBのバージョンは4.13以
     降であること．

`C-c C-f'
`C-x C-a C-f'
     あらかじめ選択したスタックフレームから戻る（あるいは，他の理由で停
     止する）までプログラムを実行する．

`C-x C-a C-j'
     ソースバッファにいる時に便利なこのコマンド (`gud-jump') は，プ
     ログラムの実行箇所を現在行に変更する．言い換えると，プログラムが次に実行す
     る行が，このコマンドで指定した行になる．もし新しく実行する行が前に実行
     していたものとは別の関数であるなら，GDB は結果がおかしくなる可能性があ
     るので，確認メッセージを表示する．詳細については，GDBマニュアルの
     `jump' を参照してください．

コマンド `gdba' で GDB を開始すると，ソースバッファのある行でクリック
`Mouse-1' でき，その行にブレークポイントが設定され，フリンジに表示され
る．その行にブレークポイントがすでに設定されていれば，削除される
(`gdb-mouse-toggle-breakpoint')．

これらのコマンドは，意味がある場合には数引数を反復回数として解釈します．

TABは，補完コマンドとして働くため，GDBでデバッグしているプログラムへの
タブの入力には使えません．タブを入力するには`C-q TAB'と打鍵します．



File: emacs-ja, Node: GUD Customization, Next: GUD Tooltips, Prev: Commands of GUD, Up: Debuggers

GUDのカスタマイズ *(2004/08/16)*
--------------------------------

GUDが実行を開始すると，
GDBの場合は`gdb-mode-hook'，
DBXの場合は`dbx-mode-hook'，
SDBの場合は`sdb-mode-hook'，
XDBの場合は`xdb-mode-hook'，
Perlのデバッグモードの場合は`perldb-mode-hook'，
PDBの場合は`pdb-mode-hook'，
JDBの場合は`jdb-mode-hook'のフックを実行します．
これらのフックを使って，デバッガの対話バッファ用に
自前のキーバインドを定義できます．
*Note Hooks::．

以下は，特定のコマンド文字列をデバッガに送るコマンドを定義し，かつ，そ
のコマンドに対するキーバインドをデバッガの対話バッファに設定する便利な
方法です．

     (gud-def FUNCTION CMDSTRING BINDING DOCSTRING)

これは，デバッガプロセスにCMDSTRINGを送るFUNCTIONという名前のコマンドを
定義し，そのコマンドの説明文字列をDOCSTRINGとします．そうして，このコマ
ンド FUNCTION は，どのバッファでも使えます．BINDINGが`nil'以外の場合，
`gud-def'はGUDバッファのモードに対してはこのコマンドを`C-c BINDING'にバ
インドし，それ以外に対しては`C-x C-a BINDING'にバインドします．

コマンド文字列CMDSTRINGには，
FUNCTIONが呼び出されたときにデータが埋め込まれる
`%'系列を含めることもできます．

`%f'
     現在のソースファイルの名前．カレントバッファがGUDバッファだった場
     合には，『現在のソースファイル』とはプログラムが停止した箇所に対応
     するソースファイル．

`%l'
     現在のソース行番号．カレントバッファがGUDバッファだった場合には，
     『現在のソース行番号』とはプログラムが停止した箇所に対応するソース
     ファイルの行番号．

`%e'
     ポイント位置あるいはポイントに隣接するCの左辺値か関数呼び出し式．

`%a'
     ポイント位置あるいはポイントに隣接する箇所の16進数表記アドレス．

`%p'
     FUNCTIONを呼ぶときに指定された数引数を10進値表記したもの．数引数な
     しで呼ばれた場合，`%p'は空文字列．

     CMDSTRINGで`%p'を使用しなければ，定義しようとしているFUNCTIONは数
     引数を無視する．



File: emacs-ja, Node: GUD Tooltips, Next: GDB Graphical Interface, Prev: GUD Customization, Up: Debuggers

GUD ツールチップ *(2004/08/16)*
-------------------------------

ツールチップ機能 (*Note Tooltips::) は GUD の補助する．`tooltip' グルー
プをカスタマイズすることでGUD の補助機能を有効にしていれば，GUD バッファ
か `tooltip-gud-modes' で指定したメジャーモードのソースバッファにおいて，
マウスにより指定した変数の値をツールチップで表示できる．



File: emacs-ja, Node: GDB Graphical Interface, Prev: GUD Tooltips, Up: Debuggers

GDB グラフィカルインターフェイス *(2004/09/07)*
-----------------------------------------------

コマンド `gdba' は GDB をグラフィカルインターフェイスで起動する．このイ
ンターフェイスでは，Emacsのウィンドウを使ってプログラムのデータを見たり，
制御したりすることができる．この状態でも，GUD バッファを介して GUD とや
りとりすることができるが，このモードの利点は GDB コマンドを知らなくても
メニューやクリックで様々な操作を行うことができることだ．

* Menu:

* Breakpoints Buffer::   A breakpoint control panel.
* Stack Buffer::         Select a frame from the call stack.
* Watch Expressions::    Monitor variable values in the speedbar.
* Other Buffers::        Input/output, locals, registers and assembler buffers.
* Layout::               Control the number of displayed buffers.



File: emacs-ja, Node: Breakpoints Buffer, Next: Stack Buffer, Prev: GDB Graphical Interface, Up: GDB Graphical Interface

ブレークポイントバッファ *(2004/08/16)*
.......................................

ブレークポイントバッファは既に存在しているブレークポイントやウォッチポ
イント (*Note Breakpoints: (gdb)Breakpoints.) を表示する．このバッファ
は3つの特別な機能を持つ．

`SPC'
     現在行のブレークポイントを有効化/無効化する
     (`gdb-toggle-breakpoint')．グラフィカルインターフェイスでは，ソー
     スバッファで関連行のマージン部分にある弾丸の色を変える．ブレークポイン
     トが有効であれば赤で，無効なら灰色になる．テキストのみの端末では
     `B' か `b' を表示する．

``d''
     現在行のブレークポイントを削除する(`gdb-delete-breakpoint')．

`RET'
     現在行のブレークポイントのあるソースバッファを表示する
     (`gdb-goto-breakpoint')．代わりに，ブレークポイントでクリック
     `Mouse-2' することでも表示できる．



File: emacs-ja, Node: Stack Buffer, Next: Watch Expressions, Prev: Breakpoints Buffer, Up: GDB Graphical Interface

スタックバッファ *(2004/08/16)*
...............................

スタックバッファは，プログラムでアクティブになっている箇所のサブルーチ
ンの呼び出し履歴 ("stack frames") を一覧できる "call stack" を表示する．
*Note info stack: (gdb)Backtraceを参照のこと．

カーソルをスタックのあるフレームに移動させ，RETを入力すると，現在のフレー
ムを選択して (`gdb-frames-select')，ソースバッファの関連するソースを表
示できる．代わりに，クリック `Mouse-2' することで，フレームを選択できる．
もし，ローカルバッファが表示されると，新しいフレームでローカルとなる変
数を表示できるように内容を更新する．



File: emacs-ja, Node: Watch Expressions, Next: Other Buffers, Prev: Stack Buffer, Up: GDB Graphical Interface

式を見る *(2004/09/07)*
.......................

もしプログラムが停止するたびに変数がどのように変化しているか見たい時に
は，カーソルを変数上に置き，ツールバー上のウォッチアイコンをクリックす
る (`gud-watch')．

スピードバーに見ている各式が表示される．配列や構造体，集合のように複雑
なデータはトリーで表示される．そのようなデータタイプを展開/折り畳む場合
には，式の左にあるタグ上で`Mouse-2'をクリックする．

複雑なデータタイプのルート部分にカーソルがある状態で，RET を入力するか
`Mouse-2'をクリックすると，そのデータをスピードバーから削除する
(`gdb-var-delete')．

ある値を持つ単純なデータや複雑なデータの要素上にカーソルがある時に，
RET を入力するか `Mouse-2' をクリックすると，その値を編集する．新しい値
の入力を求めるプロンプトがミニバッファに表示される (`gdb-edit-value')．

If you set the variable `gdb-show-changed-values' to a non-`nil'
value, then Emacs will use font-lock-warning-face to display values
that have recently changed in the speedbar.

If you set the variable `gdb-use-colon-colon-notation' to a non-`nil'
value, then, in C, Emacs will use the FUNCTION::VARIABLE format to
display variables in the speedbar.



File: emacs-ja, Node: Other Buffers, Next: Layout, Prev: Watch Expressions, Up: GDB Graphical Interface

Other Buffers
.............

Input/Output Buffer
     The executable program that is being debugged takes its input and
     displays its output here.  Some of the commands from shell mode
     are available here.  *Note Shell Mode::.

Locals Buffer
     The locals buffer displays the values of local variables of the
     current frame for simple data types (*Note Frame Info: (gdb)Frame
     Info.).

     Arrays and structures display their type only.  You must display
     them separately to examine their values.  *Note Watch
     Expressions::.

Registers Buffer
     The registers buffer displays the values held by the registers
     (*Note Registers: (gdb)Registers.).

Assembler Buffer
     The assembler buffer displays the current frame as machine code.
     An overlay arrow points to the current instruction and you can
     set and remove breakpoints as with the source buffer.
     Breakpoints also appear in the margin.

Threads Buffer

     The threads buffer displays a summary of all threads currently in
     your program.(*Note Threads: (gdb)Threads.).  Move point to any
     thread in the list and type RET to make it become the current
     thread (`gdb-threads-select') and display the associated source
     in the source buffer.  Alternatively, click `Mouse-2' to make the
     selected thread become the current one.




File: emacs-ja, Node: Layout, Prev: Other Buffers, Up: GDB Graphical Interface

Layout
......

If `gdb-many-windows' is `nil' (the default value), then GDB starts
with just two windows: the GUD and the source buffer.  If it is `t',
then six windows with the following layout will appear:

GUD buffer (I/O of GDB)             Locals buffer

Source buffer                       Input/Output (of debuggee) buffer

Stack buffer                        Breakpoints buffer

To toggle this layout, do `M-x gdb-many-windows'.

If you change the window layout, for example, while editing and
re-compiling your program, then you can restore it with
`gdb-restore-windows'.

You may also choose which additional buffers you want to display,
either in the same frame or a different one.  Select GDB-windows or
GDB-Frames from the menu-bar under the heading GUD.  If the menu-bar
is unavailable, type `M-x gdb-display-BUFFERTYPE-buffer' or `M-x
gdb-frame-BUFFERTYPE-buffer' respectively, where BUFFERTYPE is the
relevant buffer type e.g breakpoints.



File: emacs-ja, Node: Executing Lisp, Next: Lisp Libraries, Prev: Debuggers, Up: Building

Lisp式の実行 *(2004/08/16)*
===========================

Emacsには，LispやSchemeのための異なったメジャーモードがいくつかあります．
これらは編集コマンドという意味では同じですが，Lisp式を実行するコマンド
が異なります．各モードには固有の目的があります．

emacs-lispモード
     このモードはEmacs Lispで実行するプログラムのソースファイル編集用．
     このモードでは，現在の関数定義を評価する`C-M-x'を定義する．
     *Note Lisp Libraries::．
lisp対話モード（Lisp Interaction mode）
     このモードはEmacs Lispの対話セッション用．
     ポイントの直前のS式を評価し，その値をバッファに挿入する`C-j'を定義する．
     *Note Lisp Interaction::．
lispモード
     このモードはEmacs Lisp以外のLispで実行するプログラムのソースコード編集用．
     このモードでは，
     現在の関数定義を下位のLispプロセスに送る`C-M-x'を定義する．
     *Note External Lisp::．
下位lispモード（Inferior Lisp mode）
     このモードは下位Lispプロセスとの対話セッション用．このモードは，
     lispモードとシェル（shell）モード（*Note Shell Mode::）の特別な機
     能の組み合わせ．
schemeモード
     lispモードと同様だが，Schemeプログラム編集用．
下位Schemeモード（Inferior Scheme mode）
     このモードは下位のSchemeプロセスとの対話セッション用．

Lispプログラム用の編集コマンドの大部分は事実上どこでも使えます．
*Note Programs::．



File: emacs-ja, Node: Lisp Libraries, Next: Lisp Eval, Prev: Executing Lisp, Up: Building

Emacs用のLispコードのライブラリ *(2004/08/16)*
==============================================

Emacs編集コマンドのLispコードは，習慣的に`.el'で終る名前のファイルに格
納されています．これらの拡張子は，emacs-lispモードで編集するように
Emacsに指示します（*Note Executing Lisp::）．

Emacs Lispコードのファイルを実行するには，`M-x load-file'を使います．こ
のコマンドは，ミニバッファでファイル名を読み取り，そのファイルの内容を
Lispコードとして実行します．あらかじめファイルを訪問しておく必要はあり
ません．いずれにしても，このコマンドはディスク上のファイルを読むのであっ
て，Emacsバッファのテキストを読むのではありません．

LispコードのファイルをEmacs Lispライブラリのディレクトリに置いておけば，
そのファイルは`M-x load-library'でロードできます．プログラムからは，
`load-library'を呼んでロードするか，あるいは，より基本的な類似の関数で
余分な引数も指定できる`load'でロードします．

`M-x load-library'が`M-x load-file'と異なる点は，一連のディレクトリにつ
いて3つのファイル名を順に調べるということです．引数がLIBだとすると，3つ
のファイル名とは，`LIB.elc'，`LIB.el'，そして最後に`LIB'です．
`LIB.elc'というファイルが存在すれば，これは習慣として`LIB.el'をコンパイ
ルしたものです．コンパイル済みのファイルはロードと実行が速いので，こち
らをロードするほうが有利です．

`load-library'が`LIB.elc'よりも新しい`LIB.el'をみつけると，警告を出力し
ます．というのは，`.el'ファイルを変更後に再コンパイルし忘れている可能性
があるからです．

`load-library'の引数は，通常，それ自体では正しいファイル名でないことが
多いため，ファイル名の補完はできません．もちろん，このコマンドを使うと
き，指定すべき正確なファイル名を普通は知らないでしょうが．

`M-x load-library'が探索するディレクトリの順番は，変数`load-path'で指定
します．その値は，ディレクトリ名の文字列から成るリストです．リストのデ
フォルト値には，Emacs自身のLispコードを収めたディレクトリが含まれます．
個人用のLispライブラリがあるならば，それらを1つのディレクトリにまとめ，
そのディレクトリ名を`load-path'に追加してください．リスト内の`nil'はカ
レントデフォルトディレクトリを表しますが，リストに`nil'を加えることはあ
まり勧められません．リストに`nil'が本当に必要だと感じたときには，それに
ついては`M-x load-file'を実行するのではいけないだろうかと考えてみてくだ
さい．

ライブラリの中で定義されているコマンドに対しては，そのライブラリを"自動
的にロード"（autoload）するように設定されているので，ほとんどの場合，ラ
イブラリをロードするコマンドを指定する必要はないでしょう．ライブラリを
ロードするために`load'を呼び出すようなコマンドを1つ試してみてください．
こうすると，「自動的にロードする」という定義がライブラリ内の実際の定義
で置き換わります．

Emacs Lispコードはバイトコードにコンパイルできます．コンパイルすると，
ロードが速くなり，ロードしても必要な記憶容量が少なくなり，実行も速くな
ります．*Note バイトコンパイル: (elisp)Byte Compilation．習慣として，ラ
イブラリのコンパイル済みのコードは，ライブラリのソースファイル名に`c'を
付けた名前の別のファイルに入ります．したがって，`foo.el'のコンパイル済
みのコードは，`foo.elc'に入ります．これが，`load-library'はまず`.elc'と
いうファイルを探す理由です．



File: emacs-ja, Node: Lisp Eval, Next: Lisp Interaction, Prev: Lisp Libraries, Up: Building

Emacs Lisp式の評価
==================

Emacs内で動かすつもりのLispプログラムは，emacs-lispモードで編集しましょ
う．ファイル名が`.el'で終っているファイルを編集すると，自動的にこのモー
ドになります．一方，lispモードは，他のLispシステム向けのLispプログラム
を編集するためのモードです．陽にemacs-lispモードに移るには，コマンド
`M-x emacs-lisp-mode'を使います．

Emacs内で動くプログラムのテストには，Emacsバッファにあるプログラムの一
部を評価すると便利です．たとえば，Lispの関数定義のテキストを変更してか
らその定義を評価すると，それ以降にその関数を呼び出すと使われるようにイ
ンストールされます．Lisp式を評価すると非対話的な（コマンドではない）関
数を起動できるので，どんな種類の編集作業にも便利です．

`M-:'
     ミニバッファで1つのLisp式を読み取り，それを評価し，その値をエコー
     領域に表示する（`eval-expression'）．
`C-x C-e'
     ポイントの直前のLisp式を評価し，その値をエコー領域に表示する
     （`eval-last-sexp'）．
`C-M-x'
     ポイントを含むか直後にある関数定義（defun）を評価し，その値をエコー
     領域に表示する（`eval-defun'）．
`M-x eval-region'
     リージョン内のすべてのLisp式を評価する．
`M-x eval-current-buffer'
     バッファ内のすべてのLisp式を評価する．

`M-:'（`eval-expression'）は，Lisp式を対話的に評価する
もっとも基本的なコマンドです．
これは，ミニバッファで式を1つ読み取りますから，
バッファの内容に関係なくバッファ内でどんな式でも実行できます．
式が評価されたあとは，
`M-:'を打鍵したときのカレントバッファが，ふたたびカレントバッファになります．

emacs-lispモードでは，キー`C-M-x'はコマンド`eval-defun'にバインドされて
います．このコマンドはポイントを含むか直後にある関数定義をLisp式として
解析し評価します．その値はエコー領域に表示されます．このコマンドは，関
数定義のテキストの変更をLisp環境に反映するのに便利です．

`C-M-x'は`defvar'式を特別扱いします．通常，変数にすでに値が定義されてい
る場合には，`defvar'式を評価しても何もしません．しかし，`C-M-x'は，
`defvar'式で指定されている初期値に変数の値を戻します．この特別な機能は，
Lispプログラムをデバッグするときに便利です．

コマンド`C-x C-e'（`eval-last-sexp'）は，ポイントのまえにあるLisp式を評
価しその値をエコー領域に表示します．このコマンドはemacs-lispモードだけ
でなく，すべてのメジャーモードで使えます．このコマンドは，`defvar'を特
別扱いしません．

`C-M-x'，`C-x C-e'，`M-:'に数引数を指定すると，値をエコー領域に表示する
かわりにカレントバッファのポイント位置に挿入します．引数の値は関係あり
ません．

バッファでLisp式を評価するもっとも一般的なコマンドは`eval-region'です．
`M-x eval-region'は，リージョン内の1つ以上のLisp式を解析して，それらを
1つずつ順に評価します．`M-x eval-current-buffer'も同様ですが，バッファ
全体を評価します．これは，テスト準備が整ったLispコードのファイルの内容
を取り込むうまい方法です．個々の関数のバグを発見して修正したら，変更し
た関数それぞれに`C-M-x'を使います．これによって，Lispの環境とソースファ
イルが一致します．



File: emacs-ja, Node: Lisp Interaction, Next: External Lisp, Prev: Lisp Eval, Up: Building

lisp対話バッファ *(2004/08/16)*
===============================

Emacsが動き始めたときに選択されるバッファ`*scratch*'は，Emacs内でLisp式
を対話的に評価するためのものです．

`*scratch*'バッファを使うもっとも簡単な方法は，Lisp式を挿入してから各式
の末尾で`C-j'と打つことです．このコマンドは，ポイントの直前のLisp式を読
み取り，それを評価し，その値を表示形式でポイントのまえに挿入します．こ
の結果は，評価した式とその値の完全なtypescript (1) (*Note Lisp
Interaction-Footnotes::)です．

`*scratch*'バッファのメジャーモードはlisp対話（lisp interaction）モード
であり，`C-j'のバインディングを除けばemacs-lispモードと同じです．

この機能が存在する理由を説明しましょう．Emacsが実行を開始すると何かしら
バッファが必要です．しかし，ファイルを訪問するたびに新たにバッファが作
られるので，このバッファはファイルを編集するのには適しません．最初のバッ
ファをLispインタープリタのtypescriptにするというのが作者が考えついたもっ
ともよい方法でした．`M-x lisp-interaction-mode'と打つと，カレントバッファ
はlisp対話（lisp interaction）モードになります．

Emacs Lisp式を対話的に評価する別の方法は，下位emacs-lispモードを使うこ
とです．このモードは，シェル（shell）モード（*Note Shell Mode::）に似た
インターフェイスでEmacs Lisp式を評価できます．`M-x ielm'と打てば，下位
emacs-lispモードを使う`*ielm*'バッファが作られます．


File: emacs-ja  Node: Lisp Interaction-Footnotes, Up: Lisp Interaction

(1) 【訳注】入力と出力をすべて記録した対話記録



File: emacs-ja, Node: External Lisp, Prev: Lisp Interaction, Up: Building

外部Lispの実行 *(2004/08/16)*
=============================

Emacsには他のLispシステム上でプログラムを実行する機能があります．Lispプ
ロセスをEmacsの下位プロセスとして実行し，それに式を渡して評価させること
ができます．また，Lispプログラムを編集するEmacsバッファの中で変更した関
数定義をそのまま下位のLispプロセスに渡すこともできます．

下位のLispプロセスを実行するには，`M-x run-lisp'と打ちます．このコマン
ドは，シェルコマンドとして`lisp'と入力するのと同じ`lisp'という名前のプ
ログラムを実行し，プログラムの入出力は`*lisp*'という名前のEmacsバッファ
を介してやりとりされます．つまり，Lispからの『端末出力』はバッファに入
りポイントを進め，Lispへの『端末入力』はバッファのテキストから取られま
す．（実行したいLisp実行ファイルの名前を変えるには，変数
`inferior-lisp-program'を設定する．）

Lispに入力を与えるには，バッファの末尾に移動してから入力を打鍵し，最後
にRETを打ちます．`*lisp*'バッファは下位lisp（inferior lisp）モードになっ
ていて，シェル（shell）モード（*Note Shell Mode::）のほとんどの機能に
lispモードの特別な特性を組み合わせています．サブプロセスに1行を送るとい
うRETの定義は，シェル（shell）モードの機能の1つです．

外部Lispで実行するプログラムのソースファイルにはlispモードを使います．
このモードは`M-x lisp-mode'で選択できます．また，ほとんどのLispシステム
で使われる`.l' (1) (*Note External Lisp-Footnotes::) や`.lsp'や`.lisp'
で終る名前のファイルにはこのモードが自動的に使われます．


実行中のLispプログラムの関数を編集しているとき，変更した定義を下位の
Lispプロセスに送るもっとも簡単な方法はキー`C-M-x'です．lispモードでは，
このキーは関数`lisp-eval-defun'を実行します．この関数は，ポイントの周り
や直後の関数定義を探し，それをLispプロセスの入力へ送ります．（Emacsはカ
レントバッファが何であるかに関わりなく，どんな下位プロセスにも入力を送
ることができる．）

`C-M-x'コマンドの
（任意のLispシステムで実行するプログラムの編集用）lispモードでの意味と
（Emacsで実行するLispプログラムの編集用）emacs-lispモードでの意味を
比較してみましょう．
どちらのモードでもポイントを含む関数定義をインストールしますが，
関連するLisp環境がどこにあるかに応じて，その方法は異なります．
*Note Executing Lisp::．


File: emacs-ja  Node: External Lisp-Footnotes, Up: External Lisp

(1) 【訳注】この拡張子はlexやflexのソースファイルにも使われる．


