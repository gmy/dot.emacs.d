\input texinfo    @c -*-texinfo-*-
@setfilename ../info/cl-j
@settitle Common Lisp拡張

@dircategory Editors
@direntry
* CL: (cl-j).           Emacs Lispのための部分的なCommon Lispサポート
@end direntry

@iftex
@finalout
@end iftex

@ifinfo
このファイルはGNU Emacs Common Lispエミュレーションパッケージを文書化する。

Copyright (C) 1993 Free Software Foundation, Inc.

Permission is granted to make and distribute verbatim copies of this
manual provided the copyright notice and this permission notice are
preserved on all copies.

@ignore
Permission is granted to process this file through TeX and print the
results, provided the printed document carries copying permission notice
identical to this one except for the removal of this paragraph (this
paragraph not being relevant to the printed manual).

@end ignore
Permission is granted to copy and distribute modified versions of this
manual under the conditions for verbatim copying, provided also that the
section entitled ``GNU General Public License'' is included exactly as
in the original, and provided that the entire resulting derived work is
distributed under the terms of a permission notice identical to this one.

Permission is granted to copy and distribute translations of this manual
into another language, under the above conditions for modified versions,
except that the section entitled ``GNU General Public License'' may be
included in a translation approved by the author instead of in the
original English.

このファイルは、emacs-21.2/man/cl.texiの日本語訳です。
@end ifinfo

@titlepage
@sp 6
@center @titlefont{Common Lisp拡張}
@sp 4
@center For GNU Emacs Lisp
@sp 1
@center Version 2.02
@sp 5
@center Dave Gillespie
@center daveg@@synaptics.com
@page

@vskip 0pt plus 1filll
Copyright @copyright{} 1993 Free Software Foundation, Inc.

Permission is granted to make and distribute verbatim copies of
this manual provided the copyright notice and this permission notice
are preserved on all copies.

@ignore
Permission is granted to process this file through TeX and print the
results, provided the printed document carries copying permission notice
identical to this one except for the removal of this paragraph (this
paragraph not being relevant to the printed manual).

@end ignore
Permission is granted to copy and distribute modified versions of this
manual under the conditions for verbatim copying, provided also that the
section entitled ``GNU General Public License'' is included exactly as
in the original, and provided that the entire resulting derived work is
distributed under the terms of a permission notice identical to this one.

Permission is granted to copy and distribute translations of this manual
into another language, under the above conditions for modified versions,
except that the section entitled ``GNU General Public License'' may be
included in a translation approved by the author instead of in the
original English.
@end titlepage

@node トップ, 概観,, (dir)
@chapter Common Lisp拡張

@noindent
この文書はCommon Lispから借りたEmacs Lisp機能の集合を記述する。
それらの機能のすべてはここに詳細に記述される。この文書はいかなる
Common Lispの事前知識も仮定しないが、Emacs Lispの基本知識は仮定する。

@menu
* 概観::                 インストール、使用法、その他
* プログラム構造::       引数リスト、`eval-when'、`defalias'
* 述語::                 `typep'と`eql'、`equalp'
* 制御構造::             `setf'、`when'、`do'、`loop'、その他
* マクロ::               分配、`define-compiler-macro'
* 宣言::                 `proclaim'、`declare'、その他
* シンボル::             属性リスト、`gensym'
* 数::                   述語、関数、乱数
* 列::                   マッピング関数、検索、ソート
* リスト::               `cadr'、`sublis'、`member*'、`assoc*'、その他
* ハッシュ表::           `make-hash-table'、`gethash'、その他
* 構造体::               `defstruct'
* アサーション::         `check-type'、`assert'、`ignore-errors'

* 効率の配慮::                  ヒントとテクニック
* Common Lispとの互換性::       すべての既知のSteeleとの相違
* 古いCLとの互換性::            すべての既知の古いcl.elとの相違
* Common Lispの移植::           Common Lispコード移植のためのヒント

* 関数索引::
* 変数索引::
@end menu

@node 概観, プログラム構造, トップ, トップ
@ifinfo
@chapter 概観
@end ifinfo
@iftex
@section 概観
@end iftex

@noindent
Common Lispは巨大な言語であり、Common Lispシステムは大規模できわめて
複雑になりがちである。Emacs Lispは対照的に、プログラマに提供するLisp
機能の選択に関してはむしろ最小主義者である。

Emacs Lispプログラマの数が増えるにつれ、そして彼らの書く
アプリケーションがさらに野心的になるにつれ、Emacs LispはCommon Lispの
多くの便利な機能から利益を得られることが明らかになってきた。

@dfn{CL}パッケージはかなりの数のCommon Lisp関数と制御構造をEmacs Lisp
に加える。100%完全なCommon Lisp処理系ではないが、@dfn{CL}はEmacs Lisp
プログラミングをかなり便利にするために十分な機能を加える。

いくつかのCommon Lisp機能はさまざまな理由でこのパッケージから
省略された:

@itemize @bullet
@item
いくつかの機能はEmacs Lispプログラマにとって、その利益に比べてあまりに
複雑または大き過ぎる。CLOSとCommon Lispストリームはこのグループの
好例である。

@item
他の機能はEmacs Lispインタプリタ自身の変更なしには実装できない;
多値戻し、レキシカルスコープ、大文字小文字の区別のないシンボル、そして
複素数。

@dfn{CL}パッケージは一般的にこれらの機能をエミュレートしようとしない。

@item
いくつかの機能はEmacs Lispに存在するものと衝突する。例えば、Emacsの
@code{assoc}関数はCommon Lispの@code{assoc}と非互換である。このような
場合、このパッケージは通常、Common Lisp版の関数名に接尾辞@samp{*}を
加える(例えば、@code{assoc*})。
@end itemize

ここで記述されているパッケージはDave Gillespie,
@file{daveg@@synaptics.com}によって書かれた。それはCesar Quirozによる
オリジナルの1986 @file{cl.el}パッケージの完全な書き直しである。

Quirozパッケージの多くの機能は保たれている; すべての非互換は下文の
記述に注釈されている。この版では各関数は効率的に、簡潔に、そしてEmacs
環境の残りの部分への影響を最小にするよう注意が払われている。

@menu
* 使用法::               CLパッケージの使い方
* 構成::                 パッケージの5つの構成ファイル
* インストール::         CLのコンパイルとインストール
* 命名規約::             CL関数名に関する記録
@end menu

@node 使用法, 構成, 概観, 概観
@section 使用法

@noindent
@dfn{CL}パッケージの機能を使うLispコードは先頭に下記を含める:

@example
(require 'cl)
@end example

@noindent
@dfn{CL}の新しい(Gillespieの)版が今あるものであることを
確実にしたいのなら、付加的に@code{(require 'cl-19)}の呼び出しを
追加する:

@example
(require 'cl)
(require 'cl-19)
@end example

@noindent
古い@file{cl.el}パッケージを使用中なら、2番目の呼び出しは
(``@file{cl-19.el} not found''となって)失敗する。

@dfn{CL}をロードするように準備することはいつでも安全である、
たとえばあなたの@file{.emacs}ファイルに。しかしそうしているとしても、
コードに@code{(require 'cl)}を可搬性のために入れるのはよい考えである。

@node 構成, インストール, 使用法, 概観
@section 構成

@noindent
Common Lispパッケージは4つのファイルで構成されている:

@table @file
@item cl.el
これは``主要な''ファイルであり、基本的関数とパッケージについての情報を
含む。このファイルは比較的コンパクト---約700行である。

@item cl-extra.el
このファイルはより大きく、より複雑または通常ではない関数を含む。
@code{cadr}関数のようなCommon Lispの基礎だけを使いたいパッケージがより
高度な関数のロードのオーバーヘッドを払わなくてよいように
切り離されている。

@item cl-seq.el
このファイルは、@code{delete-if}や@code{assoc*}のように列やリストに
作用する高度な関数の多くを含む。

@item cl-macs.el
このファイルは関数ではなくマクロに関するパッケージの機能を含む。
マクロは実行時ではなく呼び出される側がコンパイルされるときに
展開するので、マクロは一般的にバイトコンパイラ実行時
(または@file{.emacs}ファイルのようにコンパイルされていないコード中で
使われるとき)のみ必要である。このパッケージのマクロの多くは、
コンパイルしない限りメモリを使わないように@file{cl-macs.el}に
分離されている。
@end table

@file{cl.el}ファイルはその他の3つのファイルの関数とマクロに
必要なすべての@code{autoload}コマンドを含む。
やらなければいけないことは、@code{(require 'cl)}と書き、@file{cl.el}が
必要なときにその他のファイルを引っ張れるようにすることだけである。

別のファイル@file{cl-compat.el}があり、それは新しい
パッケージにはもうない古い@file{cl.el}のいくつかのルーチンを
定義している。これは@code{setelt}や@code{zip-lists}のような内部
ルーチン、@code{defkeyword} のような非難された機能、そして古い
スタイルの多値機能のエミュレーションを含む。@xref{古いCLとの互換性}.

@node インストール, 命名規約, 構成, 概観
@section インストール

@noindent
@dfn{CL}パッケージのインストールは単純である: 単に
バイトコンパイルされたファイル@file{cl.elc}、@file{cl-extra.elc}、
@file{cl-seq.elc}、@file{cl-macs.elc}、そして @file{cl-compat.elc}を
@code{load-path}上のディレクトリに置くだけである。

このパッケージをコンパイルするための特殊な必要条件はない: ファイルは
コンパイルされる前にロードされる必要はなく、ある特別の順序で
コンパイルされる必要もない。

あなたの主要な@file{lisp/}ディレクトリにそのファイルを置いて、
そこにあるオリジナルの@file{cl.el}を置き換えてもよいし、古い
@file{cl.el}が実質的に隠されるように、@code{load-path}の@file{lisp/}の
前に来るディレクトリにファイルを置いてもよい。

また@file{cl.texinfo}ファイルをフォーマットして、生じたInfoファイルを
@file{info/}ディレクトリか別の適切な場所に置いてもよい。

その代わりに専用のディレクトリにこのパッケージの構成要素をすべて置いて、
そのディレクトリを@code{load-path}と(Emacs 19以降のみ)
@code{Info-directory-list}に加えてもよい。古い@dfn{CL}パッケージとその
文書が隠されるように、そのディレクトリをリストの先頭に加えること。

@node 命名規約, , インストール, 概観
@section 命名規約

@noindent
注釈がある場合を除いて、このパッケージが定義するすべての関数はCommon
Lispの相対物と同じ名前と呼び出し規約を持つ。

下記は、通常はEmacsとの衝突を避けるためCommon Lispから名前を変えた関数
の完全なリストである。それぞれ、Emacs名を得るためにCommon Lisp名に
@samp{*}を付加している。

@example
defun*        defsubst*     defmacro*     function*
member*       assoc*        rassoc*       get*
remove*       delete*       mapcar*       sort*
floor*        ceiling*      truncate*     round*
mod*          rem*          random*       last*
@end example

パッケージの内部関数と変数名は接頭辞@code{cl-}がついている。Common
Lispからとられていない、接頭辞@code{cl-}が@emph{ついていない}関数の
完全なリストは以下の通り:

@example
member        delete        remove        remq
rassoc        floatp-safe   lexical-let   lexical-let*
callf         callf2        letf          letf*
defsubst*     defalias      add-hook      eval-when-compile
@end example

@noindent
(これらの多くはEmacs 18ユーザへ提供されるEmacs 19機能か、@code{remq}の
ように類似の機能との対称の理由で導入されるものである)

下記の単純関数とマクロは@file{cl.el}に定義されている; これらは
@file{cl-extra}のような他の構成要素のロードを引き起こさない。

@example
eql           floatp-safe   abs           endp
evenp         oddp          plusp         minusp
butlast       nbutlast                    caar .. cddddr
list*         ldiff         rest          first .. tenth
member [1]    copy-list     subst         mapcar* [2]
adjoin [3]    acons         pairlis       when
unless        pop [4]       push [4]      pushnew [3,4]
incf [4]      decf [4]      proclaim      declaim
add-hook
@end example

@noindent
[1] これはEmacs 19互換関数であり、@code{member*}ではない。

@noindent
[2] 1個の列引数か2個のリスト引数のみ。

@noindent
[3] @code{:test}が@code{eq}、@code{equal}、または指定されていない場合
で、@code{:key}が使われていない場合のみ。

@noindent
[4] @var{place}が単に変数名である場合のみ。

@iftex
@chapno=4
@end iftex

@node プログラム構造, 述語, 概観, トップ
@chapter プログラム構造

@noindent
この節は、プログラム全体に関係する@dfn{CL}パッケージの機能を記述する:
関数の高度な引数リスト、そして@code{eval-when}構文要素。

@menu
* 引数リスト::           `&key'、`&aux'、`defun*'、`defmacro*'
* 評価の時間::           `eval-when'構文要素
* 関数別名::             `defalias'関数
@end menu

@iftex
@secno=1
@end iftex

@node 引数リスト, 評価の時間, プログラム構造, プログラム構造
@section 引数リスト

@noindent
Emacs Lispの関数の引数リストの表記法はCommon Lisp表記法のサブセットで
ある。よく知られた@code{&optional}と@code{&rest}マーカと同様に、Common
Lispは付加引数に既定値を指定でき、追加のマーカ@code{&key}と@code{&aux}
を提供する。

引数の構文解析はEmacsに組み込まれているため、このパッケージがCommon
Lispの引数リストをシームレスに実装する方法はない。その代わりに、この
パッケージはCommon Lisp引数リストが必要なら
使わなければならないいくつかのLispフォームの代替を定義する。

@defspec defun* name arglist body...
このフォームは、@var{arglist}が完全なCommon Lisp引数リストであることを
許されていることを除いて正規の@code{defun}フォームと同一である。また、
関数本体は@var{name}と呼ばれる暗黙のブロックに囲まれている;
@pxref{ブロックと脱出}
@end defspec

@defspec defsubst* name arglist body...
これは定義される関数が自動的に@code{inline}とグローバルに
宣言されることを除いて、ちょうど@code{defun*}と似ている、
すなわちそれへの呼び出しはバイトコンパイラでインラインコードへ
展開されるかもしれない。これはEmacs 19の@code{defsubst}フォームと
似ている; @code{defsubst*}はすべてのEmacsの版で動作し、幾分効率的な
インライン展開を生成する別の方法(コンパイラマクロ)を使う。特に、
@code{defsubst*}は可能ならばいつでもコンパイル時にキーワード引数、
既定値、その他を処理できるように準備する。
@end defspec

@defspec defmacro* name arglist body...
これは、@var{arglist}が完全な Common Lisp引数リストであることを
許されていることを除いて正規の@code{defmacro}フォームと同一である。
@code{&environment}キーワードはSteeleに記述されているように
サポートされている。@code{&whole}キーワードは分配リスト内のみで
サポートされている(下記参照); トップレベルの@code{&whole}は現在の
Emacs Lispインタプリタでは実装できない。マクロエクスパンダ本体は
@var{name}と呼ばれる暗黙のブロックに囲まれている。
@end defspec

@defspec function* symbol-or-lambda
これは、引数が@code{lambda}フォームならそのフォームは完全なCommon Lisp
引数リストを使ってよいことを除いて正規の@code{function}フォームと同一
である。
@end defspec

また、@var{arglist}をその文法に含むこのパッケージで定義された
(@code{defsetf}や@code{flet}のような)すべてのフォームは完全なCommon
Lisp引数リストを許す。

あなたの関数から多くの@dfn{CL}機能にアクセスするために@code{defun*}を
使う必要は@emph{ない}ことに注意せよ。これらの機能は常に存在する;
@code{defun*}と@code{defun}の相違は単により柔軟な引数リストとその暗黙
のブロックである。

Common Lisp引数リストの完全なフォームは

@example
(@var{var}...
 &optional (@var{var} @var{initform} @var{svar})...
 &rest @var{var}
 &key ((@var{keyword} @var{var}) @var{initform} @var{svar})...
 &aux (@var{var} @var{initform})...)
@end example

5つの引数リスト節はそれぞれ付加的である。@var{svar}、@var{initform}、
そして@var{keyword}部分は付加的である; 省略するなら、
@samp{(@var{var})}は単に@samp{@var{var}}と書いてもよい。

第1節は0個かそれ以上の@dfn{必須}引数から成る。これらの引数は関数
呼び出し時には常に指定しなければならない; 必須引数に関する限り、Emacs
LispとCommon Lispに相違はない。

第2節は@dfn{付加}引数から成る。これらの引数は関数呼び出し時に
指定してもよい; 指定されない場合、@var{initform}は引数として使われる
既定値を指定する。(@var{initform}がない場合は既定値として@code{nil}を
使うことを意味する) @var{initform}は先立つ引数がすでに確立した
束縛とともに評価される; @code{(a &optional (b (1+ a)))}は1個または
2個の引数とマッチし、2番目の引数は1番目の引数に1を加えた値を
既定値とする。@var{svar}が指定されると、付加引数が指定された場合は
@code{t}に、引数が省略された場合は@code{nil}に束縛される
補助変数になる。@var{svar}を使わない場合、引数なしで呼び出されたのか、
引数として既定値を明示的に渡されたのかを知る方法はない。

第3節は1個の@dfn{rest}引数から成る。必須引数と付加引数が占めるより
多くの引数が関数へ渡された場合、それらの余分な引数は1個のリストに
集積され``rest''引数変数に束縛される。Common Lispの@code{&rest}は
Emacs Lispのそれと同等である。Common Lispはマクロコンテキストで
@code{&rest}の同義語として@code{&body}を受け入れる;
このパッケージはいつでもそれを受け入れる。

第4節は@dfn{キーワード}引数から成る。これらは引数リスト中の
位置ではなく名前で指定される付加引数である。たとえば、

@example
(defun* foo (a &optional b &key c d (e 17)))
@end example

@noindent
は1個、2個、またはそれ以上の引数で呼び出してもよい関数を定義する。
最初の2個の引数は通常の方法で@code{a}と@code{b}に束縛される。残りの
引数は@code{:c}、@code{:d}、または@code{:e}に続いてその対応する
引数変数に束縛される値であるようなフォームの対でなければならない。
(その名前がコロンで始まるシンボルは@dfn{キーワード}と呼ばれ、
@code{nil}や@code{t}同様に自己引用的である)

たとえば、呼び出し@code{(foo 1 2 :d 3 :c 4)}は5個の引数をそれぞれ1、
2、4、3、そして17にセットする。同じキーワードが1度以上関数呼び出しに
現れる場合、第1の出現が後の出現より優先する。付加引数@code{b}を
指定することなくキーワード引数を指定することはできないことに注意せよ、
なぜなら@code{(foo 1 :c 2)}は@code{b}をキーワード@code{:c}に束縛し、
@code{2}は有効なキーワードではないためエラーを通知するからである。

@var{keyword}シンボルが上のように引数リストに明示的に指定される場合、
そのキーワードは1個のコロンを接頭辞とする単なる変数名の代わりに
使われる。まったくコロンで始まらない@var{keyword}シンボルを
指定できるが、そのようなシンボルは自己引用的ではない; 関数呼び出し中で
明示的にアポストロフィで引用しなければいけない。

通常、たとえば@code{(foo 1 2 :c 3 :goober 4)}のように、
認められていないキーワードを関数に渡すことはエラーである。引数リストの
キーワード節の後にマーカ@code{&allow-other-keys}を加えるか、呼び出し
時に@code{nil}ではない値の@code{:allow-other-keys}引数を
指定することで、認められていないキーワードを無視するようLispに
求めることができる。関数が@code{&rest}と@code{&key}を同時に
両方使うと、``rest''引数は呼び出し時に現れるキーワードリストに
束縛される。たとえば:

@smallexample
(defun* find-thing (thing &rest rest &key need &allow-other-keys)
  (or (apply 'member* thing thing-list :allow-other-keys t rest)
      (if need (error "Thing not found"))))
@end smallexample

@noindent
この関数はキーワード引数@code{:need}をとるが、関数@code{member*}へ
渡される他のキーワード引数も受け入れる。@code{allow-other-keys}は
@code{find-thing}と@code{member*}が互いのキーワード引数に不平を
言わないようにするのに使われる。

(かなりの)性能最適化のために、このパッケージは``rest''引数中の
キーワード検索に@code{memq}を呼び出すことでキーワード引数の走査を
実装する。技術的には、@code{memq}は奇数個の値を偶数個のキーワードと
同様に見るのでこれは正しくない。キーワードシンボルが同じ関数の有効な
キーワード引数の名前と偶然同じ場合、キーワードシンボルを別のキーワード
引数の@emph{値}として偶然渡すと、キーワード構文解析部は
混乱することになる。このあまり重要でないバグは、プログラム中で
キーワードシンボルを一般用途のデータとして使うときにのみ影響がある
場合がある; この習慣はEmacs Lispでは強く反対される。

引数リストの第5節は@dfn{補助変数}から成る。これらは実際にはまったく
引数ではなく、関数実行時@code{nil}または指定された@var{initforms}に
束縛される単なる変数である。スタイル上の好みの問題を除いて、下記の
2個の関数間に相違はない:

@example
(defun* foo (a b &aux (c (+ a b)) d)
  @var{body})

(defun* foo (a b)
  (let ((c (+ a b)) d)
    @var{body}))
@end example

引数リストは@dfn{分配}をサポートする。Common Lispでは、分配は
@code{defmacro}でのみ許される;このパッケージは@code{defun*}や他の引数
リストでも同様に許す。分配では、全引数変数(上の@var{var})は変数の
リストか、より一般的には再帰引数リストで置き換えることができる。
対応する引数値は、その要素が再帰引数リストにマッチする
リストでなければならない。たとえば:

@example
(defmacro* dolist ((var listform &optional resultform)
                   &rest body)
  ...)
@end example

これは、@code{dolist}の第1引数は2個または3個の項目の
リストでなければならないことを示す。このリスト同様に他の引数があれば、
@code{body} に格納される。正規の引数リストで許されるすべての
機能はこれらの再帰引数リストで許される。さらに、
@samp{&whole @var{var}}節は再帰引数リストの先頭で許される。それは
@var{var}をマッチしたリスト全体に束縛する; したがって、
@code{(&whole all a b)}は2つのもののリストにマッチし、@code{a}は
1番目のものに束縛され、@code{b}は2番目のものに束縛され、@code{all}
はそのリスト自身に束縛される。(Common Lispはトップレベルの
@code{defmacro}引数リストでも同様に@code{&whole}を許すが、Emacs Lisp
はこの使用法をサポートしない)

分配の最後の機能は、引数リストはドットでもよいということである、だから
引数リスト@code{(a b . c)}は機能的には@code{(a b &rest c)}と同等である。

最適化品質@code{safety}に0が設定されると(@pxref{宣言})、不正な引数の
数や無効なキーワード引数のエラーチェックは無効である。既定では、引数
リストは厳しくチェックされる。

@node 評価の時間, 関数別名, 引数リスト, プログラム構造
@section 評価の時間

@noindent
通常、バイトコンパイラはコンパイルするファイルのフォームを実際には
実行しない。たとえば、ファイルが@code{(setq foo t)}を含む場合、
コンパイルすることは実際には@code{t}を@code{foo}に設定しない。
@code{setq}がトップレベルフォーム(すなわち@code{defun}または他の
フォームに囲まれていない)だったとしてもそれは真である。しかし、ある
トップレベルフォームをコンパイル時に評価させたい場合がある。たとえば、
ファイルの残りの部分が定義されたマクロを参照できるように、コンパイラは
@code{defmacro}フォームをコンパイル時に実際に評価する。

@defspec eval-when (situations...) forms...
このフォームは本体@var{forms}がいつ評価されるかを制御する。
@var{situations}リストはシンボル@code{compile}、@code{load}、そして
@code{eval}(または長いANSIの同等物、@code{:compile-toplevel}、
@code{:load-toplevel}、そして@code{:execute})のいずれの集合を
含んでもよい。

@code{eval-when}フォームは、トップレベルフォームとして
コンパイルされているかどうかによって異なって扱われる。つまり、
@code{byte-compile-file}のようにファイルやコードのバッファを
コンパイルするコマンドによってコンパイルされているときに特別に扱われ、
文字通りファイルのトップレベルか@code{progn}の内部のトップレベルに
現れる。

コンパイルされたトップレベルの@code{eval-when}には、@code{compile}が
@var{situations}リストにある場合には、@var{forms}本体はコンパイル時に
実行され、@code{load}が@var{situations}リストにある場合には、
@var{forms}は(ロード時に実行されるように)ファイルに書かれる。

コンパイルされていないトップレベルフォームには、状況@code{eval}のみが
関係する。(これはインタプリタが実行するフォーム、
@code{byte-compile-file}ではなく@code{byte-compile}でコンパイルされた
フォーム、トップレベルではないフォームを含む。 ) @code{eval}が
指定された場合、@code{eval-when}は@code{progn}のように振る舞い、
そうでない場合は@code{nil}(@var{forms}本体を無視する)のように
振る舞う。

@code{eval-when}が入れ子の場合、規則はさらに微妙になる;
ぞっとするような詳細(そしてぞっとするような例)はSteele(第2版)を
調べること。

単純な例:

@example
;; top-level forms in foo.el:
(eval-when (compile)           (setq foo1 'bar))
(eval-when (load)              (setq foo2 'bar))
(eval-when (compile load)      (setq foo3 'bar))
(eval-when (eval)              (setq foo4 'bar))
(eval-when (eval compile)      (setq foo5 'bar))
(eval-when (eval load)         (setq foo6 'bar))
(eval-when (eval compile load) (setq foo7 'bar))
@end example

@file{foo.el}がコンパイルされると、これらの変数がコンパイル自身の間に設定される:

@example
foo1  foo3  foo5  foo7      ; `compile'
@end example

@file{foo.elc}がロードされると、これらの変数が設定される:

@example
foo2  foo3  foo6  foo7      ; `load'
@end example

ロードされた@file{foo.el}がコンパイルされていないと、これらの変数が設定される:

@example
foo4  foo5  foo6  foo7      ; `eval'
@end example

仮にこれら7個の@code{eval-when}が@code{defun}内部にあれば、最初の3個は
@code{nil}と同等であり、最後の4個は対応する@code{setq}と同等である。

@code{(eval-when (load eval) @dots{})}はあらゆるコンテキストで
@code{(progn @dots{})}と同等であることに注意せよ。コンパイラは
@code{defmacro}(多少)や@code{require}のようないくつかの
トップレベルフォームを@code{(eval-when (compile load eval) @dots{})}で
包まれているかのように扱う。
@end defspec

Emacs 19は@code{eval-when}と関係がある2個の特殊形式を含む。そのうちの
1個である@code{eval-when-compile}は、どの@code{eval-when}構文要素と
完全に同等ではなく以下に記述される。このパッケージはEmacs 18
ユーザのために@code{eval-when-compile}の1個の版を定義する。

他方のフォーム@code{(eval-and-compile @dots{})}は
@samp{(eval-when (compile load eval) @dots{})}と正確に同等なので、それ
自身はこのパッケージで定義されていない。

@defspec eval-when-compile forms...
@var{forms}はコンパイル時に評価される;実行時、このフォームは結果として
生じる値の引用された定数のように振る舞う。トップレベルで使われると、
@code{eval-when-compile}はちょうど@samp{eval-when (compile eval)}
のようである。他のコンテキストでは、@code{eval-when-compile}は効率
その他の理由でコードがコンパイル時に1度だけ評価されることを許す。

このフォームは真のCommon Lispの@samp{#.}文法に類似している。
@end defspec

@defspec load-time-value form
@var{form}はロード時に評価される; 実行時、このフォームは結果として
生じる値の引用された定数のように振る舞う。

初期のCommon Lispはこれに類似した@samp{#,}文法を持っていたが、ANSI
Common Lispは@code{load-time-value}で置き換えてよりよく定義された
意味論を与えた。

コンパイルされたファイルでは、@code{load-time-value}は@var{form}が
@file{.elc}ファイルがロードされたときに評価され引用された定数だったか
のように使われるように準備する。@code{byte-compile-file}ではなく
@code{byte-compile}でコンパイルされたコードでは、効果は
@code{eval-when-compile}と同一である。コンパイルされていないコードでは、
@code{eval-when-compile}と@code{load-time-value}は正確に@code{progn}の
ように振る舞う。

@example
(defun report ()
  (insert "This function was executed on: "
          (current-time-string)
          ", compiled on: "
          (eval-when-compile (current-time-string))
          ;; or '#.(current-time-string) in real Common Lisp
          ", and loaded on: "
          (load-time-value (current-time-string))))
@end example

@noindent
バイトコンパイルされると、上のdefunの例は下記のコード
(またはもちろんそのコンパイルされた同等のもの)を@file{.elc}ファイルに
生じる:

@example
(setq --temp-- (current-time-string))
(defun report ()
  (insert "This function was executed on: "
          (current-time-string)
          ", compiled on: "
          '"Wed Jun 23 18:33:43 1993"
          ", and loaded on: "
          --temp--))
@end example
@end defspec

@node 関数別名, , 評価の時間, プログラム構造
@section 関数別名

@noindent
この節は、このパッケージがEmacsのGNU Emacs 19以外の版で
利用できるようにするGNU Emacs 19からの機能を記述する。

@defun defalias symbol function
この関数は@var{function}を@var{symbol}の関数セルに設定する。それは、
GNU Emacs 19では後に@code{unload-feature}で元に戻せるように
@code{load-history}に設定を記録することを除いて@code{fset}と同等である。

Emacsの他の版では、@code{defalias}は@code{fset}の同義語である。
@end defun

@node 述語, 制御構造, プログラム構造, トップ
@chapter 述語

@noindent
この節はさまざまな事実が真か偽かをテストするための関数を記述する。

@menu
* データ型の述語::       `typep'、`deftype'、そして`coerce'
* 等値の述語::           `eql'と`equalp'
@end menu

@node データ型の述語, 等値の述語, 述語, 述語
@section データ型の述語

@noindent
@dfn{CL}パッケージはCommon Lispの@code{typep}述語のある版を定義する。

@defun typep object type
@var{object}が型@var{type}かチェックする。@var{type}はCommon Lisp
によって使われる(引用された)型名である。たとえば、
@code{(typep foo 'integer)}は@code{(integerp foo)}と同等である。
@end defun

上の関数への引数@var{type}はシンボルまたはシンボルで始まるリストである。

@itemize @bullet
@item
型名がシンボルの場合、Emacsはその型をテストするための述語関数の名前を
形成するために@samp{-p}をシンボル名に付加する。(適切な場合はその名前が
@samp{-p}でなく@samp{p}で終わる組み込み述語が使われる)

@item
型シンボル@code{t}はすべての型の和を表わす。
@code{(typep @var{object} t)}は常に真である。同様に、型シンボル
@code{nil}はまったくの空を表わし、 @code{(typep @var{object} nil)}は
常に偽である。

@item
型シンボル@code{null}はシンボル@code{nil}を表わす。したがって、
@code{(typep @var{object} 'null)}は@code{(null @var{object})}と同等で
ある。

@item
型シンボル@code{real}は@code{number}の同義語であり、@code{fixnum}は
@code{integer}の同義語である。

@item
型シンボル@code{character}と@code{string-char}は0から255までの範囲の
整数とマッチする。

@item
型シンボル@code{float}は@code{floatp}ではなくこのパッケージで
定義された述語@code{floatp-safe}を使うので、浮動小数点サポートがない
版のEmacsでも正しく動作する。

@item
型リスト@code{(integer @var{low} @var{high})}は@var{low}以上@var{high}
以下の全整数を表現する。どちらの範囲も、その値を含まない境界を指定する
単精度整数のリストか、無境界を指定する@code{*}でもよい。
型@code{(integer * *)}はしたがって@code{integer}と同等である。

@item
同様に、@code{float}、@code{real}、または@code{number}で始まるリストは
特別の範囲に入る型の数を表現する。

@item
@code{and}、@code{or}、そして@code{not}で始まるリストは型の結合を形成
する。たとえば、@code{(or integer (float 0 *))}は整数または
非負浮動小数点数であるすべてのオブジェクトを表現する。

@item
@code{member}または@code{member*}で始まるリストは続く値のいずれかに
@code{eql}であるオブジェクトを表現する。たとえば、
@code{(member 1 2 3 4)}は@code{(integer 1 4)}と同等であり、
@code{(member nil)}は@code{null}と同等である。

@item
フォーム@code{(satisfies @var{predicate})}のリストは引数としてその
オブジェクトとともに呼び出されたとき@var{predicate}が真を返すすべての
オブジェクトを表現する。
@end itemize

下記の関数とマクロ(技術的には述語ではない)は@code{typep}と関係がある。

@defun coerce object type
この関数は@var{object}を指定された@var{type}へ変換を試みる。
@var{object}がすでに@code{typep}で決定されるその型の場合、それは単純に
戻る。そうでなければ、ある変換型が作られる: @var{type}がいずれかの
列型(@code{string}、@code{list}、その他)の場合、@var{object}は
可能ならその型に変換される。@var{type}が@code{character}の場合、長さ
1の文字列や1文字の名前のシンボルは強制型変換できる。@var{type}が
@code{float}の場合、浮動小数点をサポートする版のEmacsでは整数は
強制型変換できる。その他すべての環境では、@code{coerce}はエラーを
通知する。
@end defun

@defspec deftype name arglist forms...
このマクロは@var{name}と呼ばれる新しい型を定義する。それは多くの点で
@code{defmacro}と類似している; @var{name}に型名として出会うと、本体
@var{forms}は評価され、その型と同等の型指定子を戻す。@var{arglist}は
@code{defmacro*}によって受け入れられる種類のCommon Lisp引数
リストである。型指定子@samp{(@var{name} @var{args}...)}はこれらの
引数とともにエクスパンダを呼び出すことで展開される; 型シンボル
@samp{@var{name}}は無引数でエクスパンダを呼び出すことで展開される。
明示的既定値のない付加引数は``default''既定値として@code{nil}の
代わりに@code{*}を使うことを除いて、@var{arglist}は@code{defmacro*}と
同様に処理される。いくつかの例:

@example
(deftype null () '(satisfies null))    ; predefined
(deftype list () '(or null cons))      ; predefined
(deftype unsigned-byte (&optional bits)
  (list 'integer 0 (if (eq bits '*) bits (1- (lsh 1 bits)))))
(unsigned-byte 8)  @equiv{}  (integer 0 255)
(unsigned-byte)  @equiv{}  (integer 0 *)
unsigned-byte  @equiv{}  (integer 0 *)
@end example

@noindent
最後の例は望むならどのようにCommon Lisp @code{unsigned-byte}型指定子を
実装できるかを示す; このパッケージは既定では@code{unsigned-byte}を実装
しない。
@end defspec

@code{typecase}や@code{check-type}マクロも型名を使う。
@xref{条件付き実行}.@xref{アサーション}.@code{map}、
@code{concatenate}、そして@code{merge}関数は戻す列型を指定するために
型名引数をとる。@xref{列}.

@node 等値の述語, , データ型の述語, 述語
@section 等値の述語

@noindent
このパッケージは2個のCommon Lisp述語、@code{eql}と@code{equalp}を定義
する。

@defun eql a b
この関数はほとんど@code{eq}と同じだが、@var{a}と@var{b}が同じ型の
数なら数の等値性を比較する(@code{eq}ではなく@code{equal}のように)点が
異なる。これはEmacs 19のような浮動小数点数サポートとともに
コンパイルされた版のEmacsでのみ相違が生じる。Emacsの浮動小数点数は
単なるコンスセルのように割り当てられたオブジェクトであり、それは
@code{(eq 3.0 3.0)}は真である必要がないことを意味する---2個の
@code{3.0}が別々に割り当てられたら、数は同じだがポインタは異なる。
しかし@code{(eql 3.0 3.0)}は常に真である。

引数の型はマッチしなければならないので、@code{(eql 3 3.0)}は
なお偽である。

Emacs整数は割り当てられているのではなく``ダイレクト''であり、それは
基本的に@code{(eq 3 3)}は常に真になることを意味することに注意せよ。
したがって@code{eq}と@code{eql}は浮動小数点に関係のある場合のみ
異なって振る舞い、浮動小数点数をサポートしない版のEmacsでは
区別がつかない。

正と負の0の扱いにCommon Lispとわずかな不一致がある。いくつかの
マシンは、特にIEEE標準算術のものは、@code{+0}と@code{-0}を別の値として
表現する。標準は@code{(= 0.0 -0.0)}は常に真だと指定しており、
これはまったくEmacs LispとCommon Lispが行なうことなので、通常これは
問題にならない。しかしCommon Lisp標準は@code{(eql 0.0 -0.0)}や
@code{(equal 0.0 -0.0)}はIEEE的マシンでは偽になるべきだと述べている;
Emacs Lispはこれを行なわず、事実Emacs Lispで2種類の0を区別する既知の
方法は@code{format}して負号をチェックすることだけである。
@end defun

@defun equalp a b
この関数は@code{equal}のより柔軟な版である。特に、それは文字列を
大文字小文字を区別せずに比較し、数を型を考慮せずに比較する(そのため
@code{(equalp 3 3.0)}は真である)。ベクタとコンスは再帰的に比較される。
他の全オブジェクトは@code{equal}と同様に比較される。

この関数はいくつかの点でCommon Lispの@code{equalp}と異なる。第1に、
Common Lispの@code{equalp}は@emph{文字}も大文字小文字を区別せずに
比較するが、Emacsは整数と文字を区別しないのでこのパッケージには
非実用的である。Emacs Lispでは文字列はあまりベクタ的ではないという
考え方を保ち、このパッケージの@code{equalp}は文字列と整数のベクタも
比較しない。最後に、Common Lispの@code{equalp}はハッシュ表を順序を
考慮せずに比較するが、このパッケージはハッシュ表を単純にその下にある
構造に関して(このことはLucid Emacs 19のハッシュ表はベクタであり、他の
ハッシュ表はリストであることを意味する)比較する。
@end defun

Common Lispの関数@code{member}と@code{assoc}は要素の比較に@code{eql}を
使っているが、Emacs LispはMacLispの伝統に従いこれらの2個の関数に
@code{equal}を使っていることにも注意せよ。Emacsでは比較に@code{eql}を
使う関数を得るには@code{member*}や@code{assoc*}を使うこと。

@node 制御構造, マクロ, 述語, トップ
@chapter 制御構造

@noindent
下節に記述された機能は、強力な@code{setf}機能やかなりの数のループと
条件付き実行構文要素を含むさまざまな高度な制御構造を実装する。

@menu
* 代入::                   `psetq'フォーム
* 汎変数::                 `setf'、`incf'、`push'、その他
* 変数束縛::               `progv'、`lexical-let'、`flet'、`macrolet'
* 条件付き実行::           `when'、`unless'、`case'、`typecase'
* ブロックと脱出::         `block'、`return'、`return-from'
* 繰り返し::               `do'、`dotimes'、`dolist'、`do-symbols'
* ループ機能::             Common Lisp `loop'マクロ
* 多値::                   `values'、`multiple-value-bind'、その他
@end menu

@node 代入, 汎変数, 制御構造, 制御構造
@section 代入

@noindent
@code{psetq}フォームは@code{setq}に似ているが、多重代入が順次ではなく
並列になされる点が異なる。

@defspec psetq [symbol form]@dots{}
この特殊形式(実際はマクロ)は同時にいくつかの変数に代入するために
使われる。1個だけの@var{symbol}と@var{form}を与えられると、@code{setq}
と同じ効果を持つ。いくつかの@var{symbol}と@var{form}の対を
与えられると、すべての@var{form}をあらかじめ評価し、その後対応する
変数へ格納する。

@example
(setq x 2 y 3)
(setq x (+ x y)  y (* x y))
x
     @result{} 5
y                     ; @r{@code{y}は@code{x}が設定された後に計算された。}
     @result{} 15
(setq x 2 y 3)
(psetq x (+ x y)  y (* x y))
x
     @result{} 5
y                     ; @r{@code{y}は@code{x}が設定される前に計算された。}
     @result{} 6
@end example

最も単純な@code{psetq}の使用法は@code{(psetq x y y x)}であり、2個の
変数の値を交換する。(@code{rotatef}フォームは2個の変数の交換により
便利な方法を提供する; @pxref{修正マクロ})

@code{psetq}は常に@code{nil}を返す。
@end defspec

@node 汎変数, 変数束縛, 代入, 制御構造
@section 汎変数

@noindent
``汎変数''または``placeフォーム''は値を格納できるLispメモリ中の多くの
場所の一つである。最も単純なplaceフォームは通常のLisp変数である。
しかしリストのcarやcdr、配列の要素、シンボルの属性、そして多くの他の
場所もLispの値が格納される場所である。

@code{setf}フォームは@code{setq}に似ているが、単なるシンボルではなく
左辺に任意のplaceフォームを受け入れる点が異なる。たとえば、
@code{(setf (car a) b)}は@code{a}のcarを@code{b}に設定する。これは
@code{(setcar a b)}と同じ作用だが、すべての場所型の設定と
アクセスのために2個の別の関数を憶える必要がない。

汎変数はC言語の``左辺値''と類似しており、同じ表記法を使って
@samp{x = a[i]}は配列から要素を取得し@samp{a[i] = x}は要素を格納する。
Cでは@code{a[i]}のようなある種のフォームだけが左辺値になり得るが、Lisp
には汎変数になり得るフォームの集合がある。

@menu
* 基本的setf::         `setf'とplaceフォーム
* 修正マクロ::         `incf'、`push'、`rotatef'、`letf'、`callf'、その他
* setf独自化::         `define-modify-macro'、`defsetf'、`define-setf-method'
@end menu

@node 基本的setf, 修正マクロ, 汎変数, 汎変数
@subsection 基本的setf

@noindent
@code{setf}マクロは汎変数に作用する最も基本的な方法である。

@defspec setf [place form]@dots{}
このマクロは@var{form}を評価し、それを@var{place}に格納する。
@var{place}は有効な汎変数フォームでなければならない。いくつかの
@var{place}と@var{form}の対がある場合、代入はちょうど@code{setq}
のように順に行なわれる。@code{setf}は最後の@var{form}の値を戻す。

下記のLispフォームは汎変数として働くので、@code{setf}の@var{place}引数
に正しく現れてもよい:

@itemize @bullet
@item
変数を命名するシンボル。言い換えれば、@code{(setf x y)}は
@code{(setq x y)}と正確に同等であり、@code{setq}自身は@code{setf}が
存在する現在では厳密には冗長である。しかし、多くのプログラマは純粋に
スタイルまたは歴史的な理由で、単純変数の設定のためには@code{setq}を
好み続けている。マクロ@code{(setf x y)}は実際には@code{(setq x y)}へ
展開するので、コンパイルされたコードで使う場合に性能上の不利益はない。

@item
下記のLisp関数のいずれかの呼び出し:

@smallexample
car                 cdr                 caar .. cddddr
nth                 rest                first .. tenth
aref                elt                 nthcdr
symbol-function     symbol-value        symbol-plist
get                 get*                getf
gethash             subseq
@end smallexample

@noindent
@code{nthcdr}と@code{getf}のためには、関数のリスト引数はそれ自身有効な
@var{place}フォームでなければならないことに注意せよ。たとえば、
@code{(setf (nthcdr 0 foo) 7)}は@code{foo}自身に7を設定する。
@code{nthcdr}を場所とする@code{push}や@code{pop}はリストのどの位置にも
挿入や削除するために使うことができることに注意せよ。@var{place}
フォームとして@code{nthcdr}を使うことは標準Common Lispへの拡張である。

@item
下記のEmacs特有関数も@code{setf}可能である(これらのいくつかはEmacs 19
またはLucid Emacsだけで定義されている)。

@smallexample
buffer-file-name                  marker-position
buffer-modified-p                 match-data
buffer-name                       mouse-position
buffer-string                     overlay-end
buffer-substring                  overlay-get
current-buffer                    overlay-start
current-case-table                point
current-column                    point-marker
current-global-map                point-max
current-input-mode                point-min
current-local-map                 process-buffer
current-window-configuration      process-filter
default-file-modes                process-sentinel
default-value                     read-mouse-position
documentation-property            screen-height
extent-data                       screen-menubar
extent-end-position               screen-width
extent-start-position             selected-window
face-background                   selected-screen
face-background-pixmap            selected-frame
face-font                         standard-case-table
face-foreground                   syntax-table
face-underline-p                  window-buffer
file-modes                        window-dedicated-p
frame-height                      window-display-table
frame-parameters                  window-height
frame-visible-p                   window-hscroll
frame-width                       window-point
get-register                      window-start
getenv                            window-width
global-key-binding                x-get-cut-buffer
keymap-parent                     x-get-cutbuffer
local-key-binding                 x-get-secondary-selection
mark                              x-get-selection
mark-marker
@end smallexample

これらの多くは、@code{current-local-map}用の@code{use-local-map}や
@code{point}用の@code{goto-char}のように、ダイレクトに対応する``設定''
関数を持つ。@code{point-min}のようないくつかは、@code{setf}
されるとより長いコード列(この場合は
@code{(narrow-to-region x (point-max))})に展開する。

@item
フォーム@code{(substring @var{subplace} @var{n} [@var{m}])}の呼び出し
は、@var{subplace}自身が現在の値が文字列である正しい汎変数であり、格納
される値も文字列である。新たな文字列は宛先文字列の指定された
部分につながれる。たとえば:

@example
(setq a (list "hello" "world"))
     @result{} ("hello" "world")
(cadr a)
     @result{} "world"
(substring (cadr a) 2 4)
     @result{} "rl"
(setf (substring (cadr a) 2 4) "o")
     @result{} "o"
(cadr a)
     @result{} "wood"
a
     @result{} ("hello" "wood")
@end example

上のリストの汎変数@code{buffer-substring}も、現バッファの一部を
置き換えることでこのように動作する。

@item
@var{func}がその格納関数がSteeleの本に記述された意味で``適切な''場合、
フォーム@code{(apply '@var{func} @dots{})}または
@code{(apply (function @var{func}) @dots{})}の呼び出し; 標準Emacsの
place 関数はどれもこの意味で適切ではないので、この機能は
@code{define-setf-method}か@code{defsetf}の長いフォームで自身が
定義するplaceで使われる場合のみ興味あるものである。

@item
マクロ呼び出しであり、そのマクロが展開されて@code{setf}が結果として
生じるフォームに適用される場合。

@item
@code{defsetf}または@code{define-setf-method}がそのために
作られたすべてのフォーム。
@end itemize

@code{setf}への@var{place}引数にこれら以外のあらゆるフォームを使うと
エラーを通知する。

@code{setf}マクロは適正な左から右への順序ですべての部分フォームを
評価するように注意する; たとえば、

@example
(setf (aref vec (incf i)) i)
@end example

@noindent
は@code{(incf i)}を正確に一度、続く@code{i}へのアクセスの前に
評価するように見える; @code{setf}エクスパンダは@code{aref}
のためにどんなsetfメソッドが定義されても実際にこのように動作することを
確実にするために、必要な一時的変数を挿入する(この場合@code{aset}が
使われるだろうが、@code{aset}は便利な順序でその
引数をとるのでそのような手段は必要ないだろう)。

しかし、@var{place}フォームが通常ではない順序でその引数を明示的に
評価するマクロの場合、この通常ではない順序は保存される。Steeleからの
例を改作して、以下があるとすれば

@example
(defmacro wrong-order (x y) (list 'aref y x))
@end example

@noindent
フォーム@code{(setf (wrong-order @var{a} @var{b}) 17)}は、ちょうど
@code{wrong-order}への実際の呼び出しのように、@var{b}を最初に
評価しそれから@var{a}を評価する。
@end defspec

@node 修正マクロ, setf独自化, 基本的setf, 汎変数
@subsection 修正マクロ

@noindent
このパッケージは@code{setf}の他にも、汎変数に作用する多くのマクロを
定義する。@var{place}が単に変数名である場合でも、多くは興味深く
有用である。

@defspec psetf [place form]@dots{}
@code{psetq}が@code{setq}に対応するように、このマクロは@code{setf}に
対応する: いくつかの@var{place}と@var{form}を含むとき、代入は
順次にではなく並列に起こる。つまり、すべての部分フォームは左から右へ
評価され、それからすべての代入が(未定義の順序で)行なわれる。
@end defspec

@defspec incf place &optional x
このマクロは@var{place}に格納されている数を1だけ、または指定されている
場合は@var{x}だけ増やす。増やされた値が戻される。たとえば、
@code{(incf i)}は@code{(setq i (1+ i))}と同等であり、
@code{(incf (car x) 2)}は@code{(setcar x (+ (car x) 2))}と同等である。

もう一度、評価の``明白な''順序を保存するために注意が払われる。たとえば、

@example
(incf (aref vec (incf i)))
@end example

@noindent
は@code{i}を一度増やし、それから@code{i}でアドレスされる@code{vec}の
要素を増やすように現れる; これは実に正確にそれが行なうことであり、上の
フォームは``明らかな''展開と同等では@emph{ない}ことを意味し、

@example
(setf (aref vec (incf i)) (1+ (aref vec (incf i))))   ; 間違い!
@end example

@noindent
ではなく、むしろ何かより以下に似ているようなものである。

@example
(let ((temp (incf i)))
  (setf (aref vec temp) (1+ (aref vec temp))))
@end example

@noindent
もう一度、これらすべては@code{incf}や他の汎変数マクロによって自動的に
注意が払われる。

@code{incf}のよりEmacs特有の例として、式@code{(incf (point) @var{n})}
は@code{(forward-char @var{n})}と本質的に同等である。
@end defspec

@defspec decf place &optional x
このマクロは@var{place}に格納されている数を1だけ、または指定されている
場合は@var{x}だけ減らす。
@end defspec

@defspec pop place
このマクロは@var{place}に格納されているリストの最初の要素を取り除いて
戻す。それは
@code{(prog1 (car @var{place}) (setf @var{place} (cdr @var{place})))}
に類似しているが、すべての部分フォームを一度だけ評価するように注意する
点が異なる。
@end defspec

@defspec push x place
このマクロは@var{place}に格納されるリストの先頭に@var{x}を挿入する。
それは@code{(setf @var{place} (cons(コンス) @var{x} @var{place}))}に
類似しているが、部分フォームの評価が異なる。
@end defspec

@defspec pushnew x place @t{&key :test :test-not :key}
このマクロは@var{place}に格納されているリストの先頭に@var{x}を
挿入するが、@var{x}がリストの存在するどの要素にも@code{eql}でない
場合に限られる。

付加キーワード引数は@code{adjoin}と同様に解釈される。
@xref{集合としてのリスト}.
@end defspec

@defspec shiftf place@dots{} newvalue

このマクロは左へ1つ@var{place}をシフトし、@var{newvalue}の値(それは
単なる汎変数ではなく、どんなLisp式でもよい)をシフトして入れ、最初の
@var{place}からシフトして出された値を戻す。したがって、
@code{(shiftf @var{a} @var{b} @var{c} @var{d})}は以下と同等だが

@example
(prog1
    @var{a}
  (psetf @var{a} @var{b}
         @var{b} @var{c}
         @var{c} @var{d}))
@end example

@noindent
@var{a}、@var{b}、そして@var{c}の部分フォームは明白な順序でそれぞれ
一度だけ実際には評価される点が異なる。
@end defspec

@defspec rotatef place@dots{}
このマクロは循環的に@var{place}を左へ一つ回転する。したがって、
@code{(rotatef @var{a} @var{b} @var{c} @var{d})}は以下と同等だが

@example
(psetf @var{a} @var{b}
       @var{b} @var{c}
       @var{c} @var{d}
       @var{d} @var{a})
@end example

@noindent
部分フォームの評価が異なる。@code{rotatef}は常に@code{nil}を戻す。
@code{(rotatef @var{a} @var{b})}は@var{a}と@var{b}を便利に
交換することに注意せよ。
@end defspec

下記のマクロはこのパッケージのために発明された; これらはCommon Lispに
類似するものはない。

@defspec letf (bindings@dots{}) forms@dots{}
このマクロは@code{let}に類似しているが、単なるシンボルではなく
汎変数用である。それぞれの@var{binding}はフォーム
@code{(@var{place} @var{value})}であるべきである; @var{place}の
オリジナルの内容はセーブされ、@var{value}がそれらに格納され、それから
本体@var{form}が実行される。その後、@var{places}はオリジナルの
セーブされた内容へ設定し戻される。この大掃除は、@var{form}が
@code{throw}またはエラーのために正規でない脱出をした場合ですら起こる。

たとえば、

@example
(letf (((point) (point-min))
       (a 17))
  ...)
@end example

@noindent
はバッファの先頭へ現バッファの``ポイント''を動かし、17へ@code{a}を
束縛する(通常の@code{let}と同様だが、@code{a}が単なる通常の
変数だからである)。本体が脱出した後、@code{a}はそのオリジナルの値に
設定し戻され、ポイントはそのオリジナルの位置へ戻る。

@code{(point)}の@code{letf}は@code{save-excursion}とはあまり似ていない
ことに注意せよ。なぜなら後者はバッファ内の挿入と削除を追跡するマーカを
効果的にセーブするからである。実際は、@code{(point-marker)}の
@code{letf}はこの振る舞いにずっと近い(@code{point}と
@code{point-marker}は@code{setf}場所としては同等である; どちらも格納値
として整数かマーカを受け入れる)。

汎変数はリストのように見えるため、@var{binding}として@samp{(foo nil)}
のために@samp{foo}を使用する@code{let}の簡略表記法は@code{letf}
ではあいまいになるので許されていない。

しかし、@var{binding}指定子は1要素のリスト@samp{(@var{place})}でもよく、
それは@samp{(@var{place} @var{place})}に類似している。言い換えれば、
@var{place}は本体へ入ることで乱されず、@code{letf}の効果はその後
@var{place}のオリジナルの値を戻すことだけである
(@code{(@var{place} @var{place})}の例により示唆された冗長なアクセスと
格納は実際には起こらない)。

多くの場合、@var{place}は@code{letf}フォームに入るときによく定義された
値を持たなければならない。例外は単純変数と@code{symbol-value}や
@code{symbol-function}への呼び出しだけである。入るときにシンボルが束縛
されていない場合、脱出時に@code{makunbound}または@code{fmakunbound}で
単に未束縛にされる。
@end defspec

@defspec letf* (bindings@dots{}) forms@dots{}
@code{let*}が@code{let}に対応するように、このマクロは@code{letf}に対応
する: それは並列の順序ではなく順次に束縛を行なう。
@end defspec

@defspec callf @var{function} @var{place} @var{args}@dots{}
これは``汎用''修正マクロである。@var{function}を呼び出す。
@var{function}は引用符のない関数名、マクロ名、または
ラムダでなければならない。引数として@var{place}と@var{args}を渡し、
@var{place}へ結果を代入し戻す。たとえば、
@code{(incf @var{place} @var{n})}は@code{(callf + @var{place} @var{n})}
と同じである。さらにいくつかの例:

@example
(callf abs my-number)
(callf concat (buffer-name) "<" (int-to-string n) ">")
(callf union happy-people (list joe bob) :test 'same-person)
@end example

@xref{setf独自化}, @code{define-modify-macro}、修正マクロのための幾分
簡潔な表記法を作るための方法。@code{callf}は標準Common Lispへの拡張で
あることに再度注意せよ。
@end defspec

@defspec callf2 @var{function} @var{arg1} @var{place} @var{args}@dots{}
このマクロは@code{callf}に似ているが、@var{place}が関数の第1ではなく
@emph{第2}引数である点が異なる。たとえば、
@code{(push @var{x} @var{place})}は
@code{(callf2 cons @var{x} @var{place})}と同等である。
@end defspec

@code{callf}や@code{callf2}マクロは、@code{incf}、@code{pushnew}、
そして@code{define-modify-macro}のような他のマクロのための
ビルディングブロックとして役に立つ。@code{letf}や@code{letf*}マクロは
シンボルマクロの処理に使われる; @pxref{マクロ束縛}.

@node setf独自化, , 修正マクロ, 汎変数
@subsection setf独自化

@noindent
Common Lispは、さまざまな方法で汎変数を拡張することをユーザに許す3個の
マクロ、@code{define-modify-macro}、@code{defsetf}、そして
@code{define-setf-method}を定義する。

@defspec define-modify-macro name arglist function [doc-string]
このマクロは@code{incf}や@code{decf}に類似する``read-modify-write''
マクロを定義する。マクロ@var{name}は@var{arglist}によって記述される
追加の引数が続く@var{place}引数をとるために定義される。呼び出し

@example
(@var{name} @var{place} @var{args}...)
@end example

@noindent
は下記に展開されるが

@example
(callf @var{func} @var{place} @var{args}...)
@end example

@noindent
これは順に大まかに以下と同等である。

@example
(setf @var{place} (@var{func} @var{place} @var{args}...))
@end example

たとえば:

@example
(define-modify-macro incf (&optional (n 1)) +)
(define-modify-macro concatf (&rest args) concat)
@end example

@code{&key}は@var{arglist}の中には許されないが、@code{&rest}は関数へ
キーワードを渡すためには十分なことに注意せよ。

Common Lispで定義される修正マクロのほとんどは
@code{define-modify-macro}のパターンに正確には従っていない。たとえば、
@code{push}はよくない順序で引数をとり、@code{pop}は完全に変則である。
@code{get-setf-method}を使って``手で''これらのマクロを定義できるし、
内部の@code{setf}ビルディングブロックをどのように使うかを見るために
ソースファイル@file{cl-macs.el}を調べることもできる。
@end defspec

@defspec defsetf access-fn update-fn

これは2個の@code{defsetf}フォームのより単純な方である。@var{access-fn}
が場所をアクセスする関数の名前である場合、これは対応する格納関数として
@var{update-fn}を宣言する。その後、

@example
(setf (@var{access-fn} @var{arg1} @var{arg2} @var{arg3}) @var{value})
@end example

@noindent
は以下に展開される。

@example
(@var{update-fn} @var{arg1} @var{arg2} @var{arg3} @var{value})
@end example

@noindent
@var{update-fn}は真の関数か、関数のような方法でその引数を評価する
マクロであることが必須である。また、@var{update-fn}はその結果として
@var{value}を戻すことを期待される。さもなければ、上の展開は@code{setf}
が振る舞うことになっていることのための規則に従わないだろう。

特殊な(非Common Lisp)拡張として、@code{defsetf}への@code{t}の第3引数は
@code{update-fn}の戻り値は適切でないと言っているので、上の@code{setf}
はより以下に似たようなものへ展開されるべきである。

@example
(let ((temp @var{value}))
  (@var{update-fn} @var{arg1} @var{arg2} @var{arg3} temp)
  temp)
@end example

setfメソッドの標準一式から引かれた、@code{defsetf}の使用のいくつかの
例は:

@example
(defsetf car setcar)
(defsetf symbol-value set)
(defsetf buffer-name rename-buffer t)
@end example
@end defspec

@defspec defsetf access-fn arglist (store-var) forms@dots{}
これは2番目の、より複雑な@code{defsetf}のフォームである。それは追加の
@var{store-var}引数を除いてむしろ@code{defmacro}と似ている。
@var{forms}は、@var{arglist}によって記述された引数をともにする
@var{access-fn}への呼び出しによって形成された汎変数に@var{store-var}
の値を格納するLispフォームを戻すべきである。@var{forms}は@code{setf}
メソッドを文書化する文字列で始まってもよい(関数の先頭に現れる
文書文字列と類似している)。

たとえば、@code{defsetf}の単純なフォームは以下の簡略表記法である。

@example
(defsetf @var{access-fn} (&rest args) (store)
  (append '(@var{update-fn}) args (list store)))
@end example

戻されるLispフォームは制限されていない仕方で@var{arglist}や
@var{store-var}からの引数へアクセスできる; このsetf-methodを起動する
@code{setf}や@code{incf}のようなマクロは、評価の明白な順序が
保存されることを確実にするために必要な一時的変数を挿入する。

標準パッケージから引かれた別の例:

@example
(defsetf nth (n x) (store)
  (list 'setcar (list 'nthcdr n x) store))
@end example
@end defspec

@defspec define-setf-method access-fn arglist forms@dots{}
これは新しいplaceフォームを作るための最も一般的な方法である。
@var{arglist}に記述された引数と一緒に@var{access-fn}への@code{setf}が
展開されると、@var{forms}は評価されて5項目のリストを
戻さなければならない:

@enumerate
@item
@dfn{一時変数}のリスト。

@item
上の一時変数に対応する@dfn{値フォーム}のリスト。一時変数は
汎変数上のどんな作用の第1ステップとしてもこれらの値フォームへ
束縛される。

@item
正確に1個の@dfn{格納変数}のリスト(一般的に@code{gensym}への
呼び出しから得られる)。

@item
格納変数の内容を汎変数に格納するLispフォーム。一時変数は上述したように
束縛されていると仮定する。

@item
汎変数の内容にアクセスするLispフォーム。一時変数は束縛されていると
仮定する。
@end enumerate
これは同じ名前のCommon Lispマクロとほとんど同じだが、メソッドは5個の
値自身ではなく5個の値のリストを戻す点は異なる。それはEmacs Lispは
多重戻り値のCommon Lispの記法をサポートしていないからである。

もう一度、@var{forms}は文書文字列で始まってもよい。

setfメソッドは一時変数に関して最大限に保守的であるべきである。
@code{defsetf}によって生成されるsetfメソッドの中で、第2戻り値は単に
placeフォーム中の引数リストであり、第1戻り値は@code{gensym}によって
生成される対応する一時変数の数のリストである。@code{setf}や@code{incf}
のようにこのsetfメソッドを使うマクロは不要とわかった多くの一時変数を
最適化するので、setfメソッド自身を最適化する理由はほとんどない。
@end defspec

@defun get-setf-method place(場所) &optional env
この関数は、@code{defsetf}や@code{define-setf-method}によって以前に
記録された定義を呼び出すことで、@var{place}のためのsetfメソッドを
戻す。結果は上述した5個の値のリストである。あなた自身の@code{incf}に
似た修正マクロを作るためにこの関数を使える(実際は内部関数
@code{cl-setf-do-modify}や@code{cl-setf-do-store}を使う方がよい。
少しだけ使いやすく、かなりの最適化も行なう; 単純な例として@code{incf}
関数のソースコードを調べよ)。

引数@var{env}は、@code{get-setf-method}が@var{place}のマクロを展開する
必要がある場合に@code{macroexpand}へ渡される``環境''を指定する。それは
マクロへの@code{&environment}か、@code{get-setf-method}を呼んだsetf
メソッドから来るべきである。

@code{apply}や@code{substring}のためのsetfメソッドのソースコードも
参照のこと。それぞれはより単純な場合に@code{get-setf-method}を
呼び出すことによって動作し、それからさまざまな方法で結果を
マッサージする。
@end defun

現代のCommon Lispは関数の@code{setf}の振る舞いを指定するための第2の、
独立した方法を定義する。すなわち、その名前がシンボルではなくリスト
@code{(setf @var{name})}である``@code{setf}関数''である。たとえば、
@code{(defun (setf foo) @dots{})}は、@code{setf}が@code{foo}に適用する
際に使われる関数を定義する。このパッケージは、現在は@code{setf}関数を
サポートしない。まだ@code{defsetf}されていないか宣言されていない
フォームで@code{setf}を使うことはコンパイル時エラーである; より新しい
Common Lispでは、関数@code{(setf @var{func})}は後で
定義されるかもしれないのでこれはエラーではないだろう。

@iftex
@secno=4
@end iftex

@node 変数束縛, 条件付き実行, 汎変数, 制御構造
@section 変数束縛

@noindent
これらのLispフォームは変数や関数の名前との束縛を作る。Lispの組み込み
@code{let}フォームと類似している。

同じく変数束縛に関係する@code{letf}や@code{letf*}フォームは
@xref{修正マクロ}.

@menu
* 動的束縛::             `progv'フォーム
* レキシカルな束縛::     `lexical-let'とレキシカルクロージャ
* 関数束縛::             `flet'と`labels'
* マクロ束縛::           `macrolet'と`symbol-macrolet'
@end menu

@node 動的束縛, レキシカルな束縛, 変数束縛, 変数束縛
@subsection 動的束縛

@noindent
標準@code{let}フォームは、コンパイル時にその名前が既知である変数を
束縛する。@code{progv}フォームはその名前が実行時に計算される変数を
束縛する容易な方法を提供する。

@defspec progv symbols values forms@dots{}
このフォームは実行時に計算された変数の集合に、@code{let}スタイルの
変数束縛を確立する。式の@var{symbols}と@var{values}は評価され、
それぞれシンボルと値のリストを戻さなければならない。シンボルは本体
@var{form}が続く限り、対応する値に束縛される。@var{values}が
@var{symbols}より短い場合、終わりのいくつかのシンボルは本体内では
未束縛にされる(@code{makunbound}によってのように)。@var{symbols}が
@var{values}より短い場合、余分の値は無視される。
@end defspec

@node レキシカルな束縛, 関数束縛, 動的束縛, 変数束縛
@subsection レキシカルな束縛

@noindent
@dfn{CL}パッケージは、Common Lispの@code{let}フォームにより厳密に従う
下記のマクロを定義する:

@defspec lexical-let (bindings@dots{}) forms@dots{}
このフォームは、確立する束縛が純粋にレキシカルである点以外は@code{let}
とほぼ似ている。レキシカルな束縛はCのような言語の局所変数と
類似している: 物理的に@code{lexical-let}(マクロ展開後)の本体内の
コードだけが束縛変数を参照してよい。

@example
(setq a 5)
(defun foo (b) (+ a b))
(let ((a 2)) (foo a))
     @result{} 4
(lexical-let ((a 2)) (foo a))
     @result{} 7
@end example

@noindent
この例では、@code{a}の正規の@code{let}束縛は実際グローバル変数@code{a}
を一時的に変更するので、@code{foo}は2への@code{a}の束縛を
見ることができる。しかし@code{lexical-let}は実際本体内で使うために別の
局所変数@code{a}を作り、同名のグローバル変数にどんな影響もない。

レキシカルな束縛の最も重要な使用法は@dfn{クロージャ}を作ることである。
クロージャは外のレキシカル変数を参照する関数オブジェクトである。
たとえば:

@example
(defun make-adder (n)
  (lexical-let ((n n))
    (function (lambda (m) (+ n m)))))
(setq add17 (make-adder 17))
(funcall add17 4)
     @result{} 21
@end example

@noindent
呼び出し@code{(make-adder 17)}は引数に17を加える関数オブジェクトを
戻す。@code{let}が@code{lexical-let}の代わりに使われる場合、
関数オブジェクトは@code{make-adder}自身の呼び出しの間だけ17へ
束縛されているグローバルの@code{n}を参照するだろう。

@example
(defun make-counter ()
  (lexical-let ((n 0))
    (function* (lambda (&optional (m 1)) (incf n m)))))
(setq count-1 (make-counter))
(funcall count-1 3)
     @result{} 3
(funcall count-1 14)
     @result{} 17
(setq count-2 (make-counter))
(funcall count-2 5)
     @result{} 5
(funcall count-1 2)
     @result{} 19
(funcall count-2)
     @result{} 6
@end example

@noindent
ここで@code{make-counter}への各呼び出しは別の局所変数@code{n}を作る。
それは戻される関数オブジェクト用の私的なカウンターとして働く。

その上で閉じられたレキシカル変数は、ちょうど他のLispオブジェクトと
同様にそれへの最後の参照がなくなるまで存続する。たとえば、
@code{count-2}は変数@code{n}のインスタンスを参照する関数オブジェクトを
参照する; これはその変数への唯一の参照なので、
@code{(setq count-2 nil)}の後にはガベジコレクタは@code{n}のこの
インスタンスを削除できるだろう。もちろん、@code{lexical-let}が実際には
クロージャをまったく作らない場合、レキシカル変数は@code{lexical-let}が
戻るとすぐに自由である。

多くのクロージャはそれらが参照する束縛のエクステントの間だけ使われる;
これらはLisp語法では``downward funargs''として知られている。クロージャ
がこのように使われる場合、正規のEmacs Lisp動的束縛で十分であり、
@code{lexical-let}クロージャより効率的だろう。

@example
(defun add-to-list (x list)
  (mapcar (function (lambda (y) (+ x y))) list))
(add-to-list 7 '(1 2 5))
     @result{} (8 9 12)
@end example

@noindent
このラムダは@code{x}がまだ束縛されているときにのみ使われているので、
そのために真のクロージャを作ることは必要ではない。

名前付きクロージャを作るために@code{lexical-let}の内部で@code{defun}や
@code{flet}を使うことができる。いくつかのクロージャが1個の
@code{lexical-let}の本体で作られる場合、それらはすべてレキシカル変数の
同じインスタンスの上で閉じている。

@code{lexical-let}フォームはCommon Lispへの拡張である。真のCommon Lisp
では、すべての束縛はそうではないと宣言されない限りレキシカルである。
@end defspec

@defspec lexical-let* (bindings@dots{}) forms@dots{}
このフォームはちょうど@code{lexical-let}と似ているが、束縛は
@code{let*}の方法のように順次に作られる点が異なる。
@end defspec

@node 関数束縛, マクロ束縛, レキシカルな束縛, 変数束縛
@subsection 関数束縛

@noindent
これらのフォームは変数の代わりに関数に@code{let}に似た束縛を作る。

@defspec flet (bindings@dots{}) forms@dots{}
このフォームは値セルではなくシンボルの関数セルに@code{let}スタイルの
束縛を確立する。それぞれの@var{binding}はフォーム
@samp{(@var{name} @var{arglist} @var{forms}@dots{})}の
リストでなければならない。それは正確に@code{defun*}
フォームであるかのように関数を定義する。関数@var{name}は@code{flet}の
本体の間だけそれに応じて定義される; それから古い関数定義や
関数定義がないことが戻される。

Common Lispの@code{flet}は@var{name}のレキシカルな束縛を確立するが、
Emacs Lispの@code{flet}は動的束縛を作る。その結果、@code{flet}は
@code{flet}フォーム自身の内部での直接的な呼び出しと同様に間接的な関数
への呼び出しに影響する。

一時的な仕方で関数の振る舞いを無効にしたり修正したりするために
@code{flet}を使うことができる。これはEmacsプリミティブ上でも
動作するが、Emacs内部のプリミティブ関数へのいくつかの呼び出しは
シンボルの関数セルを通さずに行なわれるので、@code{flet}によって
影響されないことに注意せよ。たとえば、

@example
(flet ((message (&rest args) (push args saved-msgs)))
  (do-something))
@end example

このコードはメッセージを表示するのではなく、単にリストにセーブする
関数で組み込み関数@code{message}を置き換えようと試みる。@code{message}
のオリジナルの定義は@code{do-something}の脱出の後に戻される。この
コードは他のLispコードによって生成されるメッセージにはうまく働くが、
Emacs内部で直接生成されるメッセージはLispの@code{message}関数を
通じてではなくメッセージルーチンへの直接のC言語呼び出しを行なうので、
それらは捉えられない。

@code{flet}で定義された関数は@code{defun*}によってサポートされている
完全なCommon Lisp引数表記法を使ってもよい; また、関数本体は
@code{defun*}のように暗黙のブロックに囲まれる。@xref{プログラム構造}.
@end defspec

@defspec labels (bindings@dots{}) forms@dots{}
@code{labels}フォームは@code{flet}と似ているが、動的束縛ではなく
関数名のレキシカルな束縛を作る点が異なる。(真のCommon Lispでは、
@code{flet}と@code{labels}のどちらもわずかに異なる種類のレキシカルな
束縛を作る; Emacs Lispは既定では動的束縛なので、@code{flet}のためにも
動的束縛を使うことはより適切に見える。@code{labels}フォームは
レキシカルな束縛を持っており、Common Lispと完全に互換である。)

レキシカルスコープは、名付けられた関数へのすべての参照は物理的に
@code{labels}フォームの本体内に現れなくてはならないことを意味する。
参照は@code{labels}自身の本体@var{forms}の中にも関数自身の本体の中にも
現れてよい。したがって、@code{labels}は局所再帰関数や相互再帰関数の
集合を定義できる。

関数名への``参照''はその関数への呼び出しか、たとえば@code{mapcar}へ
渡されるために@code{quote}や@code{function}に引用されたその名前の
使用である。
@end defspec

@node マクロ束縛, , 関数束縛, 変数束縛
@subsection マクロ束縛

@noindent
これらのフォームは局所マクロや``シンボルマクロ''を作る。

@defspec macrolet (bindings@dots{}) forms@dots{}
このフォームは@code{flet}と類似しているが、関数の代わりにマクロ
用である。各@var{binding}は@code{defmacro*}への引数と同じフォームの
リストである(すなわち、マクロ名、引数リスト、そして
マクロエクスパンダフォーム)。マクロは@code{macrolet}の本体内の使用に
応じて定義される。

マクロの性質のために、@code{macrolet}はEmacs Lisp内でさえも
レキシカルスコープである: @code{macrolet}束縛は、おそらく本体の他の
マクロの展開後、物理的に本体@var{forms}内に現れる呼び出しにのみ
影響する。
@end defspec

@defspec symbol-macrolet (bindings@dots{}) forms@dots{}
このフォームは@dfn{シンボルマクロ}を作る。それは関数呼び出しよりも
変数参照のように見えるマクロである。各@var{binding}はリスト
@samp{(@var{var} @var{expansion})}である; 本体@var{forms}内の
@var{var}へのすべての参照は@var{expansion}によって置き換えられる。

@example
(setq bar '(5 . 9))
(symbol-macrolet ((foo (car bar)))
  (incf foo))
bar
     @result{} (6 . 9)
@end example

シンボルマクロの@code{setq}は@code{setf}と同様に扱われる。すなわち、
上の@code{(setq foo 4)}は@code{(setf foo 4)}と同等であり、今度は
@code{(setf (car bar) 4)}へ展開する。

同様に、シンボルマクロを束縛する@code{let}や@code{let*}は@code{letf}や
@code{letf*}のように扱われる。これは、レキシカルスコープのルールは
@code{let}の束縛が@code{symbol-macrolet}の束縛をシャドウすることを
引き起こすような真のCommon Lispとは異なる。このパッケージでは、
@code{lexical-let}や@code{lexical-let*}だけがシンボルマクロを
シャドウする。

シンボルマクロには@code{defmacro}に似たものはない; すべての
シンボルマクロは局所的である。@code{symbol-macrolet}の典型的な使用は
他のマクロの展開内である:

@example
(defmacro* my-dolist ((x list) &rest body)
  (let ((var (gensym)))
    (list 'loop 'for var 'on list 'do
          (list* 'symbol-macrolet (list (list x (list 'car var)))
                 body))))

(setq mylist '(1 2 3 4))
(my-dolist (x mylist) (incf x))
mylist
     @result{} (2 3 4 5)
@end example

@noindent
この例では、@code{my-dolist}マクロは変数@code{x}はリストの要素上の真の
参照になる点を除いて@code{dolist}(@pxref{繰り返し})に類似している。
ここで示された@code{my-dolist}呼び出しは下記に展開する。

@example
(loop for G1234 on mylist do
      (symbol-macrolet ((x (car G1234)))
        (incf x)))
@end example

@noindent
これは今度は下記に展開する。

@example
(loop for G1234 on mylist do (incf (car G1234)))
@end example

@code{loop}マクロの記述は@xref{ループ機能}. このパッケージは
@code{my-dolist}とたいへん似た働きをする非標準@code{in-ref}ループ節を
定義する。
@end defspec

@node 条件付き実行, ブロックと脱出, 変数束縛, 制御構造
@section 条件付き実行

@noindent
これらの条件付実行フォームはEmacs Lispの単純な@code{if}、@code{and}、
@code{or}、そして@code{cond}フォームを増加させる。

@defspec when test forms@dots{}
これは``else''フォームがなく、ことによるといくつかの``then''フォームが
ある@code{if}の別の形である。特に、

@example
(when @var{test} @var{a} @var{b} @var{c})
@end example

@noindent
は完全に下記と同等である。

@example
(if @var{test} (progn @var{a} @var{b} @var{c}) nil)
@end example
@end defspec

@defspec unless test forms@dots{}
これは``then''フォームがなく、ことによるといくつかの``else''フォームが
ある@code{if}の別の形である:

@example
(unless @var{test} @var{a} @var{b} @var{c})
@end example

@noindent
は完全に下記と同等である。

@example
(when (not @var{test}) @var{a} @var{b} @var{c})
@end example
@end defspec

@defspec case keyform clause@dots{}
このマクロは@var{keyform}を評価し、それからさまざまな@var{clause}の
中にリストされたのキーの値と比較する。キーにマッチする節はどれでも
実行される; 比較は@code{eql}によってなされる。どの節もマッチしない
場合、@code{case}フォームは@code{nil}を戻す。節は下記の
フォームである。

@example
(@var{keylist} @var{body-forms}@dots{})
@end example

@noindent
ここで@var{keylist}はキーの値のリストである。正確に1個の値がある場合、
かつコンスセルやシンボル@code{nil}または@code{t}ではない場合、リスト
内に囲まずにそれ自身を@var{keylist}として使うことができる。@code{case}
フォーム内のすべてのキーの値は別でなくてはならない。最後の節は他の節が
マッチしない場合にとられる既定節を示すために@var{keylist}の場所に
@code{t}を使ってもよい。(シンボル@code{otherwise}も@code{t}の場所に
認められる。実際のシンボル@code{t}、@code{nil}、または@code{otherwise}
とマッチする節を作るためには、リストの中にシンボルを囲むこと。)

たとえば、この式はキーストロークを読み、それが@samp{a}、@samp{b}、
@key{RET}または@kbd{C-j}、またはそれ以外のどれであるかによって4個の
事の内の1個を行なう。

@example
(case (read-char)
  (?a (do-a-thing))
  (?b (do-b-thing))
  ((?\r ?\n) (do-ret-thing))
  (t (do-other-thing)))
@end example
@end defspec

@defspec ecase keyform clause@dots{}
このマクロはちょうど@code{case}に似ているが、キーが節のどれにも
マッチしない場合は単に@code{nil}を戻すのではなくエラーを通知する点が
異なる。
@end defspec

@defspec typecase keyform clause@dots{}
このマクロは値ではなく型をチェックする@code{case}の版である。
各@var{clause}はフォーム@samp{(@var{type} @var{body}...)}である。
型指定子の記述は@xref{データ型の述語}. たとえば、

@example
(typecase x
  (integer (munch-integer x))
  (float (munch-float x))
  (string (munch-integer (string-to-int x)))
  (t (munch-anything x)))
@end example

型指定子@code{t}はオブジェクトのすべての型にマッチする; 語
@code{otherwise}も許される。いくつかの型のどれかにマッチする1個の節を
作るには、@code{(or ...)}型指定子を使うこと。
@end defspec

@defspec etypecase keyform clause@dots{}
このマクロはちょうど@code{typecase}に似ているが、キーが節のどれにも
マッチしない場合は単に@code{nil}を戻すのではなくエラーを通知する点が
異なる。
@end defspec

@node ブロックと脱出, 繰り返し, 条件付き実行, 制御構造
@section ブロックと脱出

@noindent
Common Lisp@dfn{ブロック}は@code{catch}と@code{throw}にとても
類似している非局所脱出メカニズムを適用するが、それは動的
スコープではなくレキシカルスコープである。このパッケージは実際には
@code{catch}で@code{block}を実装する; しかし、ブロック本体が実際には
ブロックから@code{return-from}しない場合、レキシカルスコープは最適化
バイトコンパイラが高価な@code{catch}を省略することを許す。

@defspec block name forms@dots{}
@var{forms}は@code{progn}によるかのように評価される。しかし、
@var{forms}のいずれかが@code{(return-from @var{name})}を実行する場合、
それらは飛び出して@code{block}フォームからダイレクトに戻る。
@code{block}は、@code{return-from}が起こらないと最後の@var{form}の結果
を戻す。

@code{block}/@code{return-from}メカニズムは@code{catch}/@code{throw}
メカニズムと非常に類似している。主要な相違は、ブロック@var{name}は
評価されないシンボルであり、実行時にタグへと評価するフォーム
(引用符のついたシンボルのように)ではない点である; そしてまた、
ブロックは@code{catch}/@code{throw}では動的スコープであるのに
レキシカルスコープである。これは、@code{catch}の本体から呼び出された
関数も@code{catch}へ@code{throw}できるが、ブロック名を参照する
@code{return-from}は物理的にブロックの本体を作る@var{forms}の中に
現れなければならないことを意味する。それらは他の呼び出された関数中に
現れてはならないが、マクロ展開の中や本体の@code{lambda}に
現れてもよい。ブロック名や@code{catch}名は独立した名前空間を形成する。

真のCommon Lispでは、@code{defun}や@code{defmacro}は関数やマクロと同じ
名前を持つ暗黙のブロックで関数やエクスパンダ本体を囲む。これはEmacs
Lispでは起こらないが、このパッケージは暗黙のブロックを作る
@code{defun*}や@code{defmacro*}フォームを提供する。

このパッケージによって定義される、@code{loop}や@code{dolist}のような
Common Lispループ構文要素も、Common Lispとちょうど同様の暗黙のブロック
を作る。

それらはEmacs Lispの@code{catch}や@code{throw}で実装されているので、
ブロックは実際の@code{catch}構文要素と同じオーバーヘッド(大まかに2度の
関数呼び出し)を持つ。しかし、ZawinskiとFurusethの最適化
バイトコンパイラ(Emacs 19の標準)は、ブロックが事実まったくそれへ
飛び出す@code{return}や@code{return-from}呼び出しを含まない場合、
@code{catch}を最適化し去る。これは、@code{return}を使わない@code{do}
ループや@code{defun*}関数はそれをサポートするためにオーバーヘッドを
払わないことを意味する。
@end defspec

@defspec return-from name [result]
このマクロは@var{name}という名前のブロックから戻る。@var{name}は
(評価されない)シンボルでなければならない。@var{result}フォームが
指定される場合、@code{block}から戻される結果を作るために評価される。
そうでなければ、@code{nil}が戻される。
@end defspec

@defspec return [result]
このマクロは@code{(return-from nil @var{result})}と正確に同等である。
@code{do}や@code{dolist}のようなCommon Lispループは暗黙に@code{nil}
ブロックに自身を囲む。
@end defspec

@node 繰り返し, ループ機能, ブロックと脱出, 制御構造
@section 繰り返し

@noindent
ここで記述されるマクロは、Emacs Lispの基本的な@code{while}ループを補う
ために、より洗練された高水準のループ構文要素を提供する。

@defspec loop forms@dots{}

@dfn{CL}パッケージは、@code{loop}の単純で古いスタイルの意味と、
@dfn{ループマクロ}の@dfn{ループ機能}として知られるきわめて強力で柔軟な
機能をどちらもサポートする。このより高度な機能は下記の節で論じられる;
@pxref{ループ機能}. @code{loop}の単純なフォームはここで記述される。

@code{loop}に0個またはそれ以上のLisp式が続く場合、
@code{(loop @var{exprs}@dots{})}は単純にその式を何度も何度も実行する
無限ループを作る。ループは暗黙の@code{nil}ブロックに囲まれている。
したがって、

@example
(loop (foo) (if (no-more) (return 72)) (bar))
@end example

@noindent
は正確に下記と同等である。

@example
(block nil (while t (foo) (if (no-more) (return 72)) (bar)))
@end example

式のどれもが単なるシンボルの場合、loopはその代わりに後に記述される
ループマクロ仕様と解釈される。(これは実際は制限ではない。上記の
表記法での単なるシンボルは単純に変数の値にアクセスして
捨て去るからである。)
@end defspec

@defspec do (spec@dots{}) (end-test [result@dots{}]) forms@dots{}
このマクロは一般的な繰り返しループを作る。それぞれの@var{spec}は下記の
フォームである:

@example
(@var{var} [@var{init} [@var{step}]])
@end example

ループは下記のように働く: 最初に、それぞれの@var{var}は@code{let}
フォームによるかのように関連づけられた@var{init}の値に束縛される。
それから、ループのそれぞれの繰り返しでは@var{end-test}が評価される;
真の場合、ループは終了する。そうでなければ、本体@var{forms}が
評価され、それぞれの@var{var}は関連づけられた@var{step}式に
(@code{psetq}フォームによるかのように)設定され、次の繰り返しが始まる。
一度@var{end-test}が真になると、@var{result}フォームは@code{do}により
戻される結果を生成するために(@var{var}はまだその値に束縛している
状態で)評価される。

@code{do}ループ全体は暗黙の@code{nil}ブロックに囲まれているので、
どんなときもループを中断して出るために@code{(return)}を使える。

@var{result}フォームがない場合、ループは@code{nil}を戻す。与えられた
@var{var}が@var{step}フォームを持たない場合、@var{init}の値に
束縛されるが、その他の点では@code{do}ループの間(コードが明示的に
修正しない限り)修正されない; この場合はループの周りに
@code{(let ((@var{var} @var{init})) @dots{})}を置くことの単なる
簡略表記法である。@var{init}も省略される場合その既定値は@code{nil}
であり、この場合は再び@code{let}との類似にしたがって単なる
@samp{@var{var}}が@samp{(@var{var})}の場所に使うことができる。

この例(Steeleから)は、リスト@code{foo}と@code{bar}からの連続する値の
対に関数@code{f}を適用するループを説明する; それは呼び出し
@code{(mapcar* 'f foo bar)}と同等である。ループは本体@var{forms}
をまったく持たず、ループの残りの副作用としてすべての仕事をすることに
注意せよ。

@example
(do ((x foo (cdr x))
     (y bar (cdr y))
     (z nil (cons (f (car x) (car y)) z)))
  ((or (null x) (null y))
   (nreverse z)))
@end example
@end defspec

@defspec do* (spec@dots{}) (end-test [result@dots{}]) forms@dots{}
@code{let*}が@code{let}に対応するように、これは@code{do}に対応する。
特に、初期値は@code{let}によってのようにではなく@code{let*}
によってのように束縛され、stepは@code{psetq}によってのようにではなく
@code{setq}によってのように代入される。

上記のループを格別の方法は以下の通り:

@example
(do* ((xp foo (cdr xp))
      (yp bar (cdr yp))
      (x (car xp) (car xp))
      (y (car yp) (car yp))
      z)
  ((or (null xp) (null yp))
   (nreverse z))
  (push (f x y) z))
@end example
@end defspec

@defspec dolist (var list [result]) forms@dots{}
これはリストの要素を横切って繰り返す、より特殊化されたループである。
@var{list}はリストへ評価されなければならない; 本体@var{forms}は
@var{var}がそれぞれのリストの要素に順に束縛された状態で実行される。
最後に、@var{result}フォーム(または@code{nil})がループから戻される
結果を生じるために、@var{var}が@code{nil}に束縛された状態で
評価される。ループは暗黙の@code{nil}ブロックで囲まれる。
@end defspec

@defspec dotimes (var count [result]) forms@dots{}
これは指定された回数繰り返す、より特殊化されたループである。本体は
@var{var}がゼロ(を含む)から@var{count}(を含まない)までの整数に順に
束縛された状態で実行される。それから@code{result}フォームが
ループフォームの戻り値を得るために、@var{var}が繰り返しの総回数に
束縛された状態(すなわち、@code{(max 0 @var{count})})で評価される。
ループは暗黙の@code{nil}ブロックで囲まれる。
@end defspec

@defspec do-symbols (var [obarray [result]]) forms@dots{}
このループはすべてのinternされたシンボル上を繰り返す。@var{obarray}が
指定され@code{nil}でない場合、そのobarray中のすべてのシンボル上をルー
プする。それぞれのシンボルに対して、本体@var{forms}は@var{var}がそのシ
ンボルに束縛された状態で評価される。シンボルは不定の順序で訪問される。
その後、@var{result}フォームがあれば戻り値を得るために(@var{var}が
@code{nil}に束縛された状態で)評価される。ループは暗黙の@code{nil}ブロッ
クで囲まれる。
@end defspec

@defspec do-all-symbols (var [result]) forms@dots{}
これは@var{obarray}引数が省略されている点を除いて@code{do-symbols}と
同一である; 常に既定のobarrayの上で繰り返す。
@end defspec

ベクタやリスト上の繰り返し用のいくつかの他の関数は@xref{列上のマッピング}.

@node ループ機能, 多値, 繰り返し, 制御構造
@section ループ機能

@noindent
Lispの伝統的なループ構文への共通の不平は、Common Lispの@code{dotimes}
やEmacs Lispの@code{while}のようにあまりに単純または制限されているか、
Common Lispの@code{do}ループのようにあまりに読みづらく
不明瞭だということである。

これを治すために、Common Lispの最近の版は、使いやすいがとても強力で
表現力に富む文法を持つ``ループ機能''または``@code{loop}マクロ''と
呼ばれる新しい構文要素を加えた。

@menu
* ループの基本::          `loop'マクロ、基本的な節の構造
* ループの例::            `loop'マクロの動作例
* For節::                 `for'または`as'によって導入される節
* 繰り返し節::            `repeat'、`while'、`thereis'、その他
* 蓄積節::                `collect'、`sum'、`maximize'、その他
* その他の節::            `with'、`if'、`initially'、`finally'
@end menu

@node ループの基本, ループの例, ループ機能, ループ機能
@subsection ループの基本

@noindent
@code{loop}マクロは本質的に、Lisp内にループを記述するために特別に
仕立てられたミニ言語を作る。この言語は正規のLispの標準からは少し奇妙に
見えるが、とても学びやすく、その目的によく適していることがわかる。

@code{loop}はマクロなので、ループ言語のすべての構文解析は
バイトコンパイル時に行なわれる; コンパイルされた@code{loop}は、
手書きの同等の@code{while}ループとちょうど同じ効率である。

@defspec loop clauses@dots{}
ループ構文要素は@var{clause}の連続から成り、それぞれは@code{for}や
@code{do}のようなシンボルによって導入される。節は単純に、最小の余分な
括弧とともに@code{loop}の引数リストに一列に一緒に並べられる。
さまざまな節の型は、一時変数の束縛のような初期化や、ループ内で
行なわれる実行、ステップ実行、最後の大掃除を指定する。

Common Lispはある一般的な節の順序をループ中に指定する:

@example
(loop @var{name-clause}
      @var{var-clauses}@dots{}
      @var{action-clauses}@dots{})
@end example

@var{name-clause}は付加的にループを囲む暗黙のブロックに名前を与える。
既定では、暗黙のブロックは@code{nil}と名付けられる。@var{var-clauses}
はループ中にどの変数が束縛されるかや、どのようにループの進行の間に
修正されたり繰り返されるかを指定する。@var{action-clauses}は、計算や
集積、値の戻しなど、ループの間になされることである。

@code{loop}マクロのEmacs版は節の順序について制限はより弱いが、実行節の
前に@code{with}や@code{for}、@code{repeat}のような変数束縛節を置く場合、
物事はほぼ予想されるように振る舞う。Common Lispと同様に、
@code{initially}と@code{finally}はどこにでも置ける。

ループは一般に既定では@code{nil}を戻すが、@code{collect}のような
蓄積節を使ったり、@code{always}のような終了テスト節を使ったり、暗黙の
ブロックから飛び出すための明示的な@code{return}節を持ったりすることで
値を戻すようにすることができる。(ループ本体は暗黙のブロックに
囲まれているから、ループから脱出するために正規Lispの@code{return}や
@code{return-from}を使うこともできる。)
@end defspec

下記の節は動作するループマクロのいくつかの例を与え、特別のループ節を
非常に詳細に記述する。追加の議論や@code{loop}マクロの例はSteeleの
@dfn{Common Lisp, the Language}第2版を調べること。

@node ループの例, For節, ループの基本, ループ機能
@subsection ループの例

@noindent
許されている節のすべての集合をリストする前に、単に@code{loop}言語の
感じを掴むためにいくつかのループの例を見てみよう。

@example
(loop for buf in (buffer-list)
      collect (buffer-file-name buf))
@end example

@noindent
このループは、@code{buffer-list}によって戻されたリストを使いながら、
すべてのEmacsバッファ上を繰り返す。それぞれのバッファ@code{buf}に
対して、@code{buffer-file-name}を呼び出して結果をリストに集積する。
リストはその後@code{loop}構文要素から戻される。結果はEmacsの
メモリにあるすべてのバッファのファイル名のリストである。語@code{for}や
@code{in}、@code{collect}は@code{loop}言語の中で予約語である。

@example
(loop repeat 20 do (insert "Yowsa\n"))
@end example

@noindent
このループは現バッファに句``Yowsa''を20回挿入する。

@example
(loop until (eobp) do (munch-line) (forward-line 1))
@end example

@noindent
このループは、バッファの終わりまでのすべての行で@code{munch-line}を
呼び出す。ポイントがすでにバッファの終わりにある場合、ループはすぐに
脱出する。

@example
(loop do (munch-line) until (eobp) do (forward-line 1))
@end example

@noindent
このループは上述のものと類似しているが、@code{munch-line}は常に最低
1度は呼び出される。

@example
(loop for x from 1 to 100
      for y = (* x x)
      until (>= y 729)
      finally return (list x (= y 729)))
@end example

@noindent
より複雑なこのループは、その2乗が729である数@code{x}を検索する。
安全のために100までの@code{x}値だけを調べる; 句@samp{to 100}を
省略することは、ループが上方へ無制限に数えることを引き起こすだろう。
2番目の@code{for}節はループの中で@code{x}の2乗になるように@code{y}を
定義する; @code{=}記号の後の式はループを通して毎回再評価される。
@code{until}節はループの終了用の条件を与え、@code{finally}節は
ループが終わったとき何をするかを言う。(この特別の例は、単に
説明のために、可能なものよりも簡潔ではなく書かれた。)

このループは、それ自身でループを定義するのに十分な3個の節(2個は
@code{for}で1個は@code{until})を含んでいるが、それでも3重の入れ子の
ループの一種ではなく1個のループをつくる。入れ子のループがほしい場合、
明示的に@code{loop}構文要素を入れ子にしなければならない。

@node For節, 繰り返し節, ループの例, ループ機能
@subsection For節

@noindent
ほとんどのループは1個かそれ以上の@code{for}節に支配される。@code{for}
節は束縛される変数を記述すると当時に、これらの変数がループ
中にどのようにステップされるか、また通常はこれらの変数に基づいた
終了条件を記述する。

語@code{as}は語@code{for}の同義語である。この語の後には変数名が続き、
望む繰り返しの種類を記述する@code{from}や@code{across}のような語が
続く。Common Lispでは、句@code{being the}がときどき繰り返しの型の前に
来る; このパッケージでは@code{being}と@code{the}はともに付加的である。
語@code{each}は@code{the}の同義語であり、それに続く語は単数でも
複数でもよい: @samp{for x being the elements of y}や
@samp{for x being each element of y}のように。どちらのフォームを
使うかは純粋にスタイルの問題である。

変数は@code{let}によるかにようにループの周りで束縛される:

@example
(setq i 'happy)
(loop for i from 1 to 10 do (do-something-with i))
i
     @result{} happy
@end example

@table @code
@item for @var{var} from @var{expr1} to @var{expr2} by @var{expr3}
この@code{for}節の型は数え上げのループを作る。3個の副項のそれぞれは
付加的だが、節が数え上げの節だとマークされるように少なくても1個の
項がなければならない。

3個の式はそれぞれ変数の開始値、終了値、ステップ値である。ループは、
@var{expr1}から@var{expr2}(を含む)までを既定では上方に(@var{expr3}は
正数でなければならない)数える。@code{from}項を省略した場合、ループは
0から数える; @code{to}項を省略した場合、ループは止まらずに永久に数える
(もちろん、他のループ節によって止まらない限り); @code{by}項を省略した
場合、ループは1のステップで数える。

ループの方向を示すために、語@code{from}を@code{upfrom}または
@code{downfrom}に置き換えることができる。同様に、@code{to}を
@code{upto}または@code{downto}に置き換えることができる。たとえば、
@samp{for x from 5 downto 1}は@code{x}が順に5から1までの整数を
持ちながら5回実行する。また、@code{to}を@code{below}または@code{above}
に置き換えることもできる。これは制限を含むのではないことを除いて
@code{upto}や@code{downto}にそれぞれ似ている:

@example
(loop for x to 10 collect x)
     @result{} (0 1 2 3 4 5 6 7 8 9 10)
(loop for x below 10 collect x)
     @result{} (0 1 2 3 4 5 6 7 8 9)
@end example

数え下げのループのためであっても、@code{by}は常に正数である。
なんらかの種類の@code{from}値が数え下げのループのためには必須である;
@samp{for x downto 5}はそれ自身まったく正しいループ節ではない。

@item for @var{var} in @var{list} by @var{function}
この節は、順に@var{list}のすべての要素で@var{var}を繰り返す。@code{by}
項を指定した場合、@var{function}が@code{cdr}の代わりにリストを
横切るために使われる; それは1個の引数をとる関数でなければならない。
たとえば:

@example
(loop for x in '(1 2 3 4 5 6) collect (* x x))
     @result{} (1 4 9 16 25 36)
(loop for x in '(1 2 3 4 5 6) by 'cddr collect (* x x))
     @result{} (1 9 25)
@end example

@item for @var{var} on @var{list} by @var{function}
この節は@var{list}のすべてのコンスセルで@var{var}を繰り返す。

@example
(loop for x on '(1 2 3 4) collect x)
     @result{} ((1 2 3 4) (2 3 4) (3 4) (4))
@end example

@code{by}がある場合、@code{on}式がリストでなければならないという
理由はない。たとえば:

@example
(loop for x on first-animal by 'next-animal collect x)
@end example

@noindent
ここでは@code{(next-animal x)}は``動物''@var{x}をとり、動物の列
(と仮定されたもの)の中の次のものを戻すか、@var{x}が列の最後の動物の
場合は@code{nil}を戻す。

@item for @var{var} in-ref @var{list} by @var{function}
これは普通の@code{in}節と似ているが、@var{var}は単に一時変数ではなく、
リストの要素上の@code{setf}可能な``参照''になる。たとえば:

@example
(loop for x in-ref my-list do (incf x))
@end example

@noindent
は正しく@code{my-list}のそれぞれの要素の値を1つ増やす。この節は標準
Common Lispへの拡張である。

@item for @var{var} across @var{array}
この節は@var{array}のすべての要素で@var{var}を繰り返す。@var{array}は
ベクタまたは文字列でなければならない。

@example
(loop for x across "aeiou"
      do (use-vowel (char-to-string x)))
@end example

@item for @var{var} across-ref @var{array}
この節は、@var{var}を要素上の@code{setf}可能な参照として配列上を
繰り返す; 上記の@code{in-ref}を参照のこと。

@item for @var{var} being the elements of @var{sequence}
この節は@var{sequence}の要素上で繰り返す。@var{sequence}はリストか
ベクタ、文字列でなければならない。型は実行時に
決定されなければならないので、これは@code{in}または@code{across}
よりもいくぶん効率が悪い。節には、@var{var2}が要素の連続する
インデックスに束縛されるようにするために、追加の項
@samp{using (index @var{var2})}が続いてもよい。

この節の型は@code{loop}マクロの古い版からとられており、最新のCommon
Lispにはない。より古いマクロの@samp{using (sequence ...)}項は
サポートされていない。

@item for @var{var} being the elements of-ref @var{sequence}
この節は、@var{var}を要素上の@code{setf}可能な参照として列上を繰り返す;
上記の@code{in-ref}を参照のこと。

@item for @var{var} being the symbols [of @var{obarray}]
この節は、すべてのinternされたシンボルまたは@var{obarray}中のすべての
シンボル上を繰り返す。ループは、@var{var}を順にそれぞれのシンボルに
束縛して実行される。シンボルは不定の順序で訪問される。

一例として、

@example
(loop for sym being the symbols
      when (fboundp sym)
      when (string-match "^map" (symbol-name sym))
      collect sym)
@end example

@noindent
は、@samp{map}で始まる名前を持つすべての関数のリストを戻す。

Common Lispの語@code{external-symbols}や@code{present-symbols}も
認められるが、Emacs Lispでは@code{symbols}と同等である。

重要でない実装の制限のために、一つの@code{loop}の中にシンボル、
ハッシュ表、キーマップ、オーバレイ、インターバル上で繰り返す、
1つ以上の@code{for}節を持つと正しく動作しない。幸いにも、
そうすることが有用なことはきわめてまれだろう。@code{for ... to}や
@code{while}のような他の節とこれらの節の型の一つを混ぜることは正しい
@emph{ことである}。

@item for @var{var} being the hash-keys of @var{hash-table}
この節は@var{hash-table}のエントリ上で繰り返す。それぞれのハッシュ表
エントリに対して、@var{var}はそのエントリのキーに束縛される。
@samp{the hash-values}をその代わりに書いた場合、@var{var}はエントリの
値に束縛される。@var{var}や@var{var2}がハッシュ表エントリの
2つのそれぞれの部分に束縛されるように、その節に追加の項
@samp{using (hash-values @var{var2})}(@code{hash-values}は@code{the}
に続く語の反対の語である)が続いてもよい。

@item for @var{var} being the key-codes of @var{keymap}
この節は@var{keymap}のエントリ上で繰り返す。GNU Emacs 18と19では、
キーマップは連想リストまたはベクタであり、キーコードは整数または
シンボルである。Lucid Emacs 19ではキーマップは特殊な新しいデータ
型であり、キーコードはシンボルまたはシンボルのリストである。繰り返しは
入れ子になったキーマップや受け継いだ親のキーマップには入らない。
キーコードではなくキーに束縛されたコマンドにアクセスするために
@samp{the key-bindings}を使うことができる。コードと束縛の両方に
アクセスするために@code{using}節を加えることができる。

@item for @var{var} being the key-seqs of @var{keymap}
この節は@var{keymap}とその入れ子になったキーマップで定義されるすべての
キー列上で繰り返す。@var{var}はEmacs 18では文字列の値を、Emacs 19では
ベクタの値をとる。文字列やベクタはそれぞれの繰り返しで
再利用されるので、それらをいつまでも保ちたいならば
コピーしなければならない。同様にコマンド束縛を得るために
@samp{using (key-bindings ...)}節を加えることができる。

@item for @var{var} being the overlays [of @var{buffer}] @dots{}
この節はEmacs 19の``オーバレイ''またはLucid Emacsのバッファの
``エクステント''上で繰り返す(節@code{extents}は@code{overlays}の
同義語である)。Emacs 18の元では、この節は1度も繰り返さない。@code{of}
項が省略された場合、現バッファが使われる。この節は、付加的な
@samp{from @var{pos}}や@samp{to @var{pos}}項も受け入れるが、指定した
リージョンを重ねるオーバレイへの節に制限する。

@item for @var{var} being the intervals [of @var{buffer}] @dots{}
この節は不変のテキスト属性を持つバッファのすべてのインターバル上で
繰り返す。変数@var{var}は開始位置と終了位置のコンスに束縛され、
そこではある開始位置は常に前の終了位置と等しい。この節は@code{of}や
@code{from}、@code{to}、@code{property}項を許す。そこでは後の項は
指定された属性のみに検索を制限する。@code{of}項はバッファか文字列を
指定できる。この節はGNU Emacs 19のみで有用である; 他の版では、すべての
バッファや文字列は1つのインターバルから成る。

@item for @var{var} being the frames
この節はすべてのフレーム上、すなわちEmacsファイル上で開いている
Xウィンドウシステムのウィンドウで繰り返す。この節はEmacs 19の元でのみ
動作する。節@code{screens}は@code{frames}の同義語である。フレームは、
@code{selected-frame}から始まる@code{next-frame}の順序で訪問される。

@item for @var{var} being the windows [of @var{frame}]
この節は現フレームか指定された@var{frame}の(Emacsの意味での)ウィンドウ
上で繰り返す(Emacs 18では常に1つのフレームだけがあり、@code{of}
項はそこでは許されない)。

@item for @var{var} being the buffers
この節はEmacsのすべてのバッファ上で繰り返す。それは
@samp{for @var{var} in (buffer-list)}と同等である。

@item for @var{var} = @var{expr1} then @var{expr2}
この節は一般の繰り返しを行なう。ループを最初に通るとき、@var{var}は
@var{expr1}に束縛される。2回目やそれに続く繰り返しでは、それは
@var{expr2}(@var{var}の古い値を参照してもよい)を評価した値に設定される。
たとえば、これらの2つのループは実際に同じである:

@example
(loop for x on my-list by 'cddr do ...)
(loop for x = my-list then (cddr x) while x do ...)
@end example

この@code{for}の型はどんな種類の終端条件も含まないことに注意せよ;
上記の例は、いつループが終わるかを言うためにそれと@code{while}節を
結合する。

@code{then}項を省略した場合、@var{expr1}は初期設定とそれに続く設定の
両方に使われる:

@example
(loop for x = (random) when (> x 0) return x)
@end example

@noindent
このループは、正数を得るまで@code{(random)}関数から乱数を取得し続けて、
その後戻る。
@end table

1つの列にいくつかの@code{for}節を含む場合、それらは(@code{let*}や
@code{setq}のように)順次に扱われる。節を結合するために代わりに
語@code{and}を使うことができ、その場合は(@code{let}や@code{psetq}
のように)並列に処理される。

@example
(loop for x below 5 for y = nil then x collect (list x y))
     @result{} ((0 nil) (1 1) (2 2) (3 3) (4 4))
(loop for x below 5 and y = nil then x collect (list x y))
     @result{} ((0 nil) (1 0) (2 1) (3 2) (4 3))
@end example

@noindent
第1のループでは、@code{y}は前の節で設定されたばかりの@code{x}の値に
基づいて設定される; 第2のループでは、@code{x}と@code{y}は同時に
設定されるので、@code{y}はループを通して前回から残された@code{x}の値に
基づいて設定される。

@code{loop}マクロの他の機能として@dfn{分配}があり、それは
@code{defmacro}によって提供される分配と概念として類似している。
すべての@code{for}節の@var{var}部分は、単なる変数の代わりに変数の
リストとして与えることができる。ループ実行中に生成される値は
リストでなければならない; リスト中の値は対応する変数に格納される。

@example
(loop for (x y) in '((2 3) (4 5) (6 7)) collect (+ x y))
     @result{} (5 9 13)
@end example

ループ分配では、変数よりも多くの値がある場合は残りの値は無視され、
値よりも多くの変数がある場合は残りの変数は値@code{nil}を取得する。
@code{nil}が変数名として使われた場合、対応する値は無視される。分配は
入れ子になってもよいし、@code{(x . y)}のような変数のドットリストも
許される。

@node 繰り返し節, 蓄積節, For節, ループ機能
@subsection 繰り返し節

@noindent
@code{for}節は別にして、ループが作用する仕方を制御するいくつか他の
ループ節がある。それらはそれら自身だけで使われてもよいし、
1つまたはそれ以上の@code{for}節と結合してもよい。

@table @code
@item repeat @var{integer}
この節は内部の一時変数を使って単純に指定された数まで数える。
このループは、

@example
(loop repeat n do ...)
(loop for temp to n do ...)
@end example

@noindent
2番目は実際には使わない変数のための名前を選ぶように強いることを除いて
同一である。

@item while @var{condition}
この節は、指定した条件(任意のLisp式)が@code{nil}になったらループを
止める。たとえば、下記の2つのループは同等だが、2つ目のループを囲む
暗黙の@code{nil}ブロックは異なる。

@example
(while @var{cond} @var{forms}@dots{})
(loop while @var{cond} do @var{forms}@dots{})
@end example

@item until @var{condition}
この節は指定された条件が真、すなわち非@code{nil}のときにループを止める。

@item always @var{condition}

この節は指定された条件が@code{nil}のときにループを止める。@code{while}
とは違い、@code{return nil}を使ってループを止めるので@code{finally}
節は実行されない。すべての条件が非@code{nil}の場合、ループは@code{t}を
戻す:

@example
(if (loop for size in size-list always (> size 10))
    (some-big-sizes)
  (no-big-sizes))
@end example

@item never @var{condition}
この節は@code{always}と似ているが、ループはすべての条件が偽なら
@code{t}を戻し、そうでなければ@code{nil}を戻す点が異なる。

@item thereis @var{condition}
この節は指定されたフォームが非@code{nil}のときにループを止める; この
場合、非@code{nil}の値を戻す。すべての値が@code{nil}の場合、ループは
@code{nil}を戻す。
@end table

@node 蓄積節, その他の節, 繰り返し節, ループ機能
@subsection 蓄積節

@noindent
これらの節は、ループが指定されたLispの@var{form}に関する情報を
蓄積するようにする。蓄積された結果は、たとえば@code{return}節によって
無効にされない限りループから戻される。

@table @code
@item collect @var{form}
この節は@var{form}の値をリストに集積する。@code{collect}のいくつかの
例がこのマニュアルの他のところで現れる。

語@code{collecting}は@code{collect}の同義語であり、同様に他の蓄積節の
同義語でもある。

@item append @var{form}
この節は、@code{append}を使って値のリストを結果のリストへ集積する。

@item nconc @var{form}
この節は、リストをコピーするのではなく破壊的に修正することで値のリスト
を結果のリストへ集積する。

@item concat @var{form}
この節は指定された@var{form}の値を文字列へ連結する。(これや下記の節は
標準Common Lispへの拡張である。)

@item vconcat @var{form}
この節は指定された@var{form}の値をベクタへ連結する。

@item count @var{form}
この節は、指定された@var{form}が非@code{nil}値へ評価される回数を数える。

@item sum @var{form}
この節は指定された@var{form}の値の合計を蓄積する。@var{form}は
評価されて数にならなければならない。

@item maximize @var{form}
この節は指定された@var{form}の値の最大値を蓄積する。@var{form}は
評価されて数にならなければならない。@code{maximize}が1度も
実行されなかった場合、戻り値は未定義である。

@item minimize @var{form}
この節は指定された@var{form}の最小値を蓄積する。
@end table

蓄積節は、無名の一時変数ではなく変数@var{var}(これはループ中に自動的に
@code{let}束縛される)にデータを集積するようにするために、
@samp{into @var{var}}を続けることができる。また@code{into}蓄積は、
自動的には戻り値を含まない。蓄積された結果を戻すためには、ループは
@code{finally return}のようななんらかの明示的なメカニズムを
使わなければならない。

同じ型のいくつかの蓄積節が同じ場所に蓄積することは正しい。Steeleから:

@example
(loop for name in '(fred sue alice joe june)
      for kids in '((bob ken) () () (kris sunshine) ())
      collect name
      append kids)
     @result{} (fred bob ken sue alice joe kris sunshine june)
@end example

@node その他の節, , 蓄積節, ループ機能
@subsection その他の節

@noindent
この節は残りのループ節を記述する。

@table @code
@item with @var{var} = @var{value}
この節はループの周りである値をある変数に束縛するが、その他の点では
ループ中にその変数を孤立させる。下記のループは基本的に同等である:

@example
(loop with x = 17 do ...)
(let ((x 17)) (loop do ...))
(loop for x = 17 then x do ...)
@end example

当然、変数@var{var}はループの残りでなんらかの用途に
使われるかもしれない。たとえば:

@example
(loop for x in my-list  with res = nil  do (push x res)
      finally return res)
@end example

このループは、@code{res}に蓄積されている新しいリストの先頭に
@code{my-list}の要素を挿入し、それからループの終わりにリスト@code{res}
を戻す。その効果は@code{collect}節の効果と類似しているが、要素は
末尾にではなく@code{res}の先頭に置かれていくという事実のために
逆順になる。

@code{=}項を省略した場合、その変数は@code{nil}に初期化される
(したがって上記の例の@samp{= nil}は不要である)。

@code{with}によって作られる束縛は、@code{let*}によってのように、
既定では順次である。ちょうど@code{for}節のように、@code{with}節はその
代わりに束縛が@code{let}によって作られるようにするために@code{and}と
結合されえる。

@item if @var{condition} @var{clause}
この節は、指定された条件が真の場合だけ、それに続くループを実行する。
下記の@var{clause}は蓄積であるべきである; @code{do}や@code{return}、
@code{if}、@code{unless}節。いくつかの節は、それらを@code{and}で
切り離して結合されてもよい。

これらの節には、@code{else}と、条件が偽の場合に実行される1つまたは
複数の節が続いてもよい。すべての構文要素には、付加的に語@code{end}
(それは入れ子の@code{if}の中で@code{else}や@code{and}
をあいまいでなくするために使われてもよい)が続いてもよい。

実際の条件式の非@code{nil}の値は、``then''部の中で名前@code{it}として
利用できる。たとえば:

@example
(setq funny-numbers '(6 13 -1))
     @result{} (6 13 -1)
(loop for x below 10
      if (oddp x)
        collect x into odds
        and if (memq x funny-numbers) return (cdr it) end
      else
        collect x into evens
      finally return (vector odds evens))
     @result{} [(1 3 5 7 9) (0 2 4 6 8)]
(setq funny-numbers '(6 7 13 -1))
     @result{} (6 7 13 -1)
(loop <@r{same thing again}>)
     @result{} (13 -1)
@end example

2つの節を``then''部に置くための@code{and}の使用に注意せよ。その
1つはそれ自身@code{if}節である。@code{end}は、通常は付加的であるが、
@code{else}が最も外側の@code{if}節を参照することを
明らかにするためにここでは必要だったことにも注意せよ。第1の場合、
ループは@var{x}の奇数と偶数のリストのベクタを戻す。第2の場合、奇数7は
@code{funny-numbers}の一つなのでループは早く戻る; 実際の戻り値は、
@code{memq}呼び出しの結果に基づく。

@item when @var{condition} @var{clause}
この節は単に@code{if}の同義語である。

@item unless @var{condition} @var{clause}
@code{unless}節は、条件の意味が逆であることを除いてちょうど@code{if}に
似ている。

@item named @var{name}
この節は、ループを囲む暗黙のブロックに@code{nil}以外の名前を与える。
@var{name}はブロック名として使われるシンボルである。

@item initially [do] @var{forms}...
このキーワードはループ自身が始まる前(しかし@code{for}や@code{with}に
要求されるすべての変数がその初期値に束縛された後)に実行される1つかそれ
以上のLispフォームを導入する。@code{initially}節はどこにでも
現れることができる; いくつかある場合、それらはループに現れる順に
実行される。キーワード@code{do}は付加的である。

@item finally [do] @var{forms}...
これはループが終わった後(たとえば、@code{for}や@code{while}の要求で)に
実行されるLispフォームを導入する。@code{initially}や@code{finally}節は
ループ構文要素のどこに現れてもよいが、それらはループのそれぞれ始まりや
終わりに(指定された順序で)実行される。

@item finally return @var{form}
これは、戻り値を得るためにループ終了後に実行されるべき@var{form}
について述べる(これや@code{collect}や@code{return}のようないくつか他の
節がないと、ループは単に@code{nil}を戻すだろう)。@code{for}や
@code{with}、@code{into}によって束縛された変数は、@var{form}が
実行されるときにその最後の値をまだ含んでいる。

@item do @var{forms}...
語@code{do}には、ループ本体で暗黙の@code{progn}として実行される任意の
数のLisp式が続いてもよい。この節の例の多くは@code{do}の使用法を
説明する。

@item return @var{form}
この節は、ループが直ちに戻るようにする。それに続くLispフォームは
評価され、@code{loop}フォームの戻り値を与える。@code{finally}節は、
もしあったとしても実行されない。もちろん、@code{return}は一般に
@code{if}や@code{unless}の内部で使われるが、それはトップレベルのループ
節での使用は、そのループは決して1度以上``ループ''に到達しないことを
意味するからである。

節@samp{return @var{form}}は@samp{do (return @var{form})}(あるいは
ループが名付けられている場合は@code{return-from})と同等である。
しかし、@code{return}節は若干効率的に実装されている。
@end table

@code{loop}へユーザ拡張を加える(たとえば@code{setf}に対する
@code{defsetf}に比較できるような)高水準の方法はないが、この
パッケージは、与えられたシンボルがトップレベルループ節や@code{for}節に
出会ったときにそれぞれ呼び出される関数である@code{cl-loop-handler}や
@code{cl-loop-for-handler}と呼ばれる2つの属性を提供する。詳細は
ファイル@file{cl-macs.el}のソースコードを調べよ。

このパッケージの@code{loop}マクロはCommon Lispのそれと互換だが、
@code{loop-finish}やデータ型指定子のようないくつかの機能は
実装されていない。当然、キーマップやオーバレイ、インターバル、
フレーム、ウィンドウ、バッファ上で繰り返す@code{for}節はEmacs特有の
拡張である。

@node 多値, , ループ機能, 制御構造
@section 多値

@noindent
Common Lisp関数は0個またはそれ以上の結果を戻すことができる。Emacs Lisp
関数は、対称的に常に正確に1つの結果を戻す。このパッケージはCommon Lisp
多重戻り値のエミュレートを試みない; 1つ以上の値を戻すCommon Lisp関数の
Emacs版は、(@code{compiler-macroexpand}でのように)単に最初の値を
戻すか、(@code{get-setf-method}でのように)値のリストを戻す。この
パッケージは、多値とともに動作するCommon Lisp関数のための場所確保を
定義@emph{する}が、Emacs Lispでは、それらの関数はその代わりに単に
リスト上で作用する。たとえば、@code{values}フォームはEmacsでは
@code{list}の同義語である。

@defspec multiple-value-bind (var@dots{}) values-form forms@dots{}
このフォームは@var{values-form}を評価する。@var{values-form}は値の
リストを戻さなければならない。それから@var{var}達を@code{let}
でのようにそれぞれの値で束縛し、本体@var{forms}を実行する。値より
多くの@var{var}達がある場合、余分の@var{var}達は@code{nil}に
束縛される。@var{var}達が値より少ない場合、余分の値は無視される。
@end defspec

@defspec multiple-value-setq (var@dots{}) form
このフォームは@var{form}を評価する。@var{form}は値のリストを
戻さなければならない。それから@var{var}達に@code{setq}
でのようにそれぞれの値を設定する。余分の@var{var}達や値は
@code{multiple-value-bind}と同様に扱われる。
@end defspec

より古いQuirozのパッケージは、Common Lisp多値のより忠実な
(しかしなお不完全な)エミュレーションを試みた。古い方法は``通常は''真の
多値をきわめてうまくシミュレートしたが、ある条件下では、メモリ中に後に
無関係な@code{multiple-value-bind}フォームが見るような偽の戻り値を
残す。

Emacs Lispでは完全なエミュレーションは実現不可能なので、この
パッケージは可能な限り単純に、そして予測可能なようにすることを選んだ。

@node マクロ, 宣言, 制御構造, トップ
@chapter マクロ

@noindent
このパッケージは、分配や@code{&environment}、@code{&body}のような
@code{defmacro}のさまざまなCommon Lisp機能を実装する。トップレベルの
@code{&whole}は、技術的困難のために@code{defmacro}のためには
実装されない。@xref{引数リスト}.

分配は、下記のマクロを通してユーザに利用可能になっている:

@defspec destructuring-bind arglist expr forms@dots{}
このマクロは、@var{arglist}の中の変数が@var{expr}によって戻される値の
リストに束縛されている状態で、@var{forms}を実行するコードに展開する。
@var{arglist}は、分配を含む@code{defmacro}引数リストのために
許されるすべての機能を含むことができる(@code{&environment}キーワードは
許されない)。マクロ展開は、@var{expr}が不正な引数の個数のリストを
戻したり、不正なキーワード引数がある場合はエラーを通知するだろう。
@end defspec

このパッケージは、Common Lispの@code{define-compiler-macro}機能も
含んでおり、コンパイル時展開の定義や関数の最適化を許す。

@defspec define-compiler-macro name(名前) arglist forms@dots{}
このフォームは@code{defmacro}と似ているが、コンパイル時にだけ
@var{name}への呼び出しへ展開される点が異なる; Lispインタプリタで
処理される呼び出しは展開されず、@code{macroexpand}関数によっても
展開されない。

引数リストは@code{&whole}キーワードと変数で始まってもよい。この変数は
マクロ呼び出しフォーム自身に、すなわちフォーム
@samp{(@var{name} @var{args}@dots{})}のリストに束縛される。
マクロエクスパンダがこのフォームを変えずに戻す場合、コンパイラは通常の
関数呼び出しとして扱う。このことは、コンパイラマクロが、複雑な
場合はそのままにしながら、関数の特殊な場合のためのオブティマイザとして
働くことを許す。

たとえば、これはこのパッケージの標準部分として現れる単純化された定義の
版である:

@example
(define-compiler-macro member* (&whole form a list &rest keys)
  (if (and (null keys)
           (eq (car-safe a) 'quote)
           (not (floatp-safe (cadr a))))
      (list 'memq a list)
    form))
@end example

@noindent

この定義は、@var{a}が浮動小数点定数ではないような普通の場合に、
@code{(member* @var{a} @var{list})}をより速い@code{memq}の呼び出しへ
変えることを引き起こす; @var{a}がその他の場合か、呼び出しにキーワード
引数がある場合、オリジナルの@code{member*}呼び出しはそのまま残る
(実際の@code{member*}のためのコンパイラマクロは、共通の@code{:test}
述語を含むその他のかなりのものを最適化する)。
@end defspec

@defun compiler-macroexpand form
この関数は@code{macroexpand}に似ているが、通常のマクロではなく
コンパイラマクロを展開する点が異なる。コンパイラマクロがそのために
定義された関数の呼び出しではない場合、またはコンパイラマクロがその
@code{&whole}引数を戻すことでパントすることを決定した場合、@var{form}
を変えずに戻す。@code{macroexpand}のように、それ以上の展開が不可能な
フォームに達するまで繰り返し展開する。
@end defun

@code{macrolet}の記述と``局所''マクロ定義作成のための
@code{symbol-macrolet}フォームについては、@xref{マクロ束縛}.

@node 宣言, シンボル, マクロ, トップ
@chapter 宣言

@noindent
Common Lispは、特別の変数に格納されるデータの型や、それらの変数や
関数がどのように使われるかについて特殊なヒントをコンパイラに
与えることを許す、複雑で強力な``宣言''メカニズムを含む。この
パッケージは、@code{declare} や@code{locally}、@code{proclaim}、
@code{declaim}、@code{the}といったすべてのCommon Lisp宣言フォームの
版を定義する。

Common Lisp宣言のほとんどは、現在はEmacs Lispでは有用ではない。
バイトコードシステムは型情報から利益を得る機会をほとんど
提供していないし、@code{special}宣言は完全に動的スコープのLispでは
冗長だからである。しかし、いくつかの宣言はEmacs 19の最適化
バイトコンパイラが使われるときに意味がある。以前の非最適化
コンパイラでは、これらの宣言は実際には無視される。

@defun proclaim decl-spec
この関数は、@var{decl-spec}によって指定された``グローバル''宣言を
記録する。@code{proclaim}は関数なので、@var{decl-spec}は評価され、
したがって通常は引用符をつけるべきである。
@end defun

@defspec declaim decl-specs@dots{}
このマクロは@code{proclaim}に似ているが、@var{decl-spec}引数を
任意個数取ることと、引数は評価されず引用符はつけない点が異なる。
@code{declaim}マクロはまた、実行時と同様にコンパイル時にも
登録されるように、宣言の周りに
@code{(eval-when (compile load eval) ...)}を置く(このことはきわめて
重要である。宣言は通常、@code{declaim}フォームを含むファイルの残りを
コンパイラが扱う方法に影響するように意図しているからである)。
@end defspec

@defspec declare decl-specs@dots{}
このマクロは、関数や他のコード内で宣言するために使われる。Common Lisp
はさまざまな場所で、一般にLisp文法を通じて、関数本体や@code{let}本体、
その他のような多くの``暗黙の@code{progn}''の始まりで宣言を許す。現在
@code{declare}によって理解される唯一の宣言は@code{special}である。
@end defspec

@defspec locally declarations@dots{} forms@dots{}
このパッケージでは、@code{locally}は@code{progn}と相違はない。
@end defspec

@defspec the type form
@code{the}によって提供される型情報はこのパッケージでは無視される;
言い替えれば、@code{(the @var{type} @var{form})}は@var{form}と
同等である。最適化バイトコンパイラの将来の版はこの情報を
利用するかもしれない。

たとえば、@code{mapcar}はリストと配列の両方にマップできる。
列がリストか配列か前もってわからない限り、コンパイラが
コンパイラが@code{mapcar}をインラインループへ展開することは難しい。

@code{(mapcar 'car (the vector foo))}に対して、将来のコンパイラは、
ループをインラインに展開するための十分な情報を持つかもしれない。
今のところ、Emacs Lispは上記のコードを@code{(mapcar 'car foo)}と正確に
同等に扱う。
@end defspec

@code{proclaim}や@code{declaim}、@code{declare}のそれぞれの
@var{decl-spec}は、どんな種類の宣言かを言うシンボルで始まる
リストであるべきである。このパッケージは、現在は@code{special}や
@code{inline}、@code{notinline}、@code{optimize}、@code{warn}宣言を
理解する(@code{warn}宣言は標準Common Lispへの拡張である)。@code{type}
や@code{ftype}のような他のCommon Lisp宣言は無言で無視される。

@table @code
@item special
Emacs Lispのすべての変数は(Common Lispの意味で)``スペシャル''
であるので、@code{special}宣言は単なる助言である。それらは単に、
指定された変数は意図的に関数本体で束縛されずに参照されることを最適化
バイトコンパイラに告げる。コンパイラは通常、そのような参照に警告を
発するが、それは局所変数への参照の誤記である可能性があるためである。

宣言@code{(declare (special @var{var1} @var{var2}))}は最適化
コンパイラでは@code{(defvar @var{var1}) (defvar @var{var2})}と
同等であり、より古いコンパイラ(非局所参照を警告しない)ではまったく
何とも同等ではない。

トップレベルコンテキストでは、@code{(declaim (special @var{var}))}より
も@code{(defvar @var{var})}と書く方が一般に優れている。@code{defvar}は
あなたの意図をより明らかにするからである。しかし古いバイトコンパイラは、
関数の内部に現れる@code{defvar}を扱えないが、
@code{(declare (special @var{var}))}はすべてのコンパイラで正しく
働くよう注意が払われる。

@item inline
@code{inline} @var{decl-spec}は、コンパイラが準備できるときはいつでも、
その本体を呼び出す関数に``インライン''に展開すべき1つまたはそれ以上の
関数をリストする。たとえば、Common Lisp関数@code{cadr}は、1回の
(比較的高価な)関数呼び出しを省くために、フォーム@code{(cadr @var{x})}
はユーザ関数で呼び出される際に直接@code{(car (cdr @var{x}))}に
展開されるように、このパッケージによって@code{inline}と宣言される。

下記の宣言はすべて同等である。@code{defsubst}フォームは関数を定義して
それをインラインにするのをすべて1度に行なう便利な方法だが、Emacs 19で
しか利用できないことに注意せよ。

@example
(declaim (inline foo bar))
(eval-when (compile load eval) (proclaim '(inline foo bar)))
(proclaim-inline foo bar)      ; Lucid Emacs only
(defsubst foo (...) ...)       ; instead of defun; Emacs 19 only
@end example

@strong{注意せよ:} この宣言は、含んでいるソースファイルが終わった後も
効果を残す。あなたが定義した関数がインラインになるべきと要求するために
使うことは正しいが、外部関数のインライン化を要求するために使うことは
無作法である。

Common Lispでは、ある関数への特別な呼び出しが単にその呼び出しを
インラインにする前に、@code{(declare (inline @dots{}))}を使うことが
可能である; 現在のバイトコンパイラは、これを実装する方法を
提供していないので、@code{(declare (inline @dots{}))}は現在はこの
パッケージによって無視される。

@item notinline
@code{notinline}宣言は、結局インラインにすべきでない関数をリストする;
それは以前の@code{inline}宣言を取り消す。

@item optimize
この宣言は、どのくらいの最適化がコンパイラによってなされるかを制御する。
当然、それは初期の非最適化コンパイラでは無視される。

語@code{optimize}には、@code{(speed 3)}や@code{(safety 2)}のように
任意の数のリストが続く。Commons Lispは、いつくかの最適化``品質''を
定義する; このパッケージは、@code{speed}と@code{safety}以外はすべて
無視する。品質の値は0から3までの整数であるべきである。
0は``重要でない''を、3は``とても重要である''を意味する。両者の品質の
既定レベルは1である。

このパッケージ中では、Emacs 19の最適化コンパイラの場合、@code{speed}
品質は@code{byte-compile-optimize}フラグに結びつけられ、
@code{(speed 0)}の場合は@code{nil}が、より高い設定の場合は@code{t}が
設定される; また、@code{safety}品質は@code{byte-compile-delete-errors}
フラグに結びつけられ、@code{(safety 3)}の場合は@code{t}が、より
低いすべての設定の場合は@code{nil}が設定される(後者のフラグは、その
副作用のみがエラーを通知する可能性があるようなコードを最適化し
去るかどうか(たとえば@code{foo}が実行時に束縛されるかどうかが未知の
場合に@code{(progn foo bar)}を@code{bar}に書き直す)を制御する)。

@code{(safety 0)}でコンパイルしてさえ、Emacsのバイトコードシステムは、
真に害になることが起こらないようにするための十分なチェックを
提供することに注意せよ。たとえば、Emacs自身に重大なバグがなければ、
Emacsは単に完全に最適化されたLispプログラム中のエラーのために
セグメント違反でクラッシュすることはない。

@code{optimize}宣言は、通常はファイルのトップレベルの@code{proclaim}や
@code{declaim}で使われる; Common Lispは、与えられたフォームに局所的な
最適化のレベルを設定するために、@code{declare}と一緒に使われることを
許すが、これは最適化コンパイラの現在の版では正しく動作しないだろう
(@code{declare}は新たな最適化レベルを設定するだろうが、そのレベルは、
囲むフォームが終わった後に自動的には設定解除されないだろう)。

@item warn
この宣言は、どんな種類の警告がバイトコンパイラによって生成されるかを
制御する。再度言うと、最適化コンパイラだけが警告を生成する。
語@code{warn}には、最適化品質に似た形式の任意個数の``警告品質''が
続く。現在サポートされている警告の型は、@code{redefine}や
@code{callargs}、@code{unresolved}、@code{free-vars}である; 現在の
システムでは、0の値はそれらの警告を無効にし、それ以上のすべての値は
有効にする。詳細は最適化バイトコンパイラの文書を見よ。
@end table

@node シンボル, 数, 宣言, トップ
@chapter シンボル

@noindent
このパッケージは、Emacs Lispに無いいくつかのシンボル関連の機能を
定義する。

@menu
* 属性リスト::           `get*'、`remprop'、`getf'、`remf'
* シンボル生成::         `gensym'、`gentemp'
@end menu

@node 属性リスト, シンボル生成, シンボル, シンボル
@section 属性リスト

@noindent
これらの関数は、シンボルに付けられた属性に作用するように、標準Emacs
Lisp関数@code{get}や@code{put}を増加させる。特定のシンボルに
付けられていない、ファーストクラスデータ構造としての属性リストに
作用する関数もある。

@defun get* symbol property &optional default
この関数は@code{get}に似ているが、属性がみつからない場合、
@var{default}引数が戻り値を提供する点が異なる(Emacs Lispの@code{get}は
常に@code{nil}を既定として使う; このパッケージの@code{get*}はCommon
Lispの@code{get}と同等である)。

@code{get*}関数は@code{setf}可能である; このように使われる場合、
@var{default}引数は許されるが無視される。
@end defun

@defun remprop symbol property
この関数は、@var{symbol}の属性リストから、@var{property}のための
エントリを取り除く。属性が実際に見つかって取り除かれた場合は真の値を
戻し、そのような属性がない場合は@code{nil}を戻す(この関数は、
@code{get}は@var{default}を許さなかったので、属性が
見つからないこととその値が@code{nil}である属性を区別することが
難しかったために、おそらく元のEmacsから省略されたのだろう;
したがって、属性を@code{nil}へ設定することは、ほとんどの用途で
@code{remprop}と十分に近かった)。
@end defun

@defun getf place property &optional default
この関数は、リスト@var{place}を属性リスト、すなわち属性名と値の
交替するリストであるかのように走査する。@var{property}と@code{eq}
である@var{place}の偶数番目の要素が見つかった場合、続く奇数番目の
要素が戻される。さもなければ、@var{default}(既定が与えられていない
場合は@code{nil})が戻される。

特に、

@example
(get sym prop)  @equiv{}  (getf (symbol-plist sym) prop)
@end example

@code{getf}を@code{setf}場所として使うことは正しい。その場合、
@var{place}引数はそれ自身正しい@code{setf}場所でなければならない。
@var{default}引数は、もしあれば、このコンテキストでは無視される。その
効果は、@var{property}に対応するリスト中の値セルを(@code{setcar}
によって)変えるか、属性がまだ存在しない場合は、新しい属性と値の対を
リスト上にコンスする。

@example
(put sym prop val)  @equiv{}  (setf (getf (symbol-plist sym) prop) val)
@end example

@code{get}や@code{get*}関数もまた@code{setf}可能である。@code{default}
が無視されるという事実はときには有用になり得る:

@example
(incf (get* 'foo 'usage-count 0))
@end example

ここでは、シンボル@code{foo}の@code{usage-count}属性が、存在する場合は
1だけ増やされ、そうでなければ1(1だけ増やされた0)が設定される。

@code{setf}フォームとして使われない場合、@code{getf}は単に正規の関数で
あり、その@var{place}引数は実際にどんなLisp式であってもよい。
@end defun

@defspec remf place property
このマクロは、@var{place}に格納された属性リストから、@var{property}の
属性と値の対を取り除く。@var{place}は任意の@code{setf}可能な場所の
式である。属性が見つかった場合は真を戻す。@var{property}がたまたま
リストの先頭の場合、実際に@code{(setf @var{place} (cddr @var{place}))}
を行なうが、もっと後で生じた場合は、属性と値のセルをつなぐために単に
@code{setcdr}を使うことに注意せよ。
@end defspec

@iftex
@secno=2
@end iftex

@node シンボル生成, , 属性リスト, シンボル
@section シンボル生成

@noindent
これらの関数は、典型的には一時変数として使われる、ユニークなシンボルを
作成する。

@defun gensym &optional x
この関数は、新しい、ユニークな名前を持つinternされていないシンボルを
(@code{make-symbol}を使って)作る(internされていないシンボルの名前は、
そのシンボルが印字されるときだけ関係がある)。既定では、名前は
@samp{G1000}、@samp{G1001}、@samp{G1002}のように、増加する数列から
生成される。付加引数@var{x}が文字列の場合、その文字列は@samp{G}の
代わりに接頭辞として使われる。internされていないシンボルは、それらの
名前がユーザコード中の``本当の''変数と衝突しないことを
確実にするために、マクロ展開中に一時変数として使われる。
@end defun

@defvar *gensym-counter*
この変数は、@code{gensym}名を生成するために使われるカウンターを
保持する。各@code{gensym}の使用後に1つ増やされる。Common Lisp
ではこれは0に初期化されるが、このパッケージは、そのコンパイル
中にそれぞれ@code{gensym}を使う2つのファイルが一緒にロードされたときに
トラブルを避けるため、ランダムな(時刻依存の)値で初期化する(intern
されていないシンボルは、コンパイラがそれらをファイルへ書き出してEmacs
ローダがロードするときにinternされるので、その名前は、intern
されていないシンボルはロード後もinternされないままであるCommon Lisp
よりも少しだけ、より注意深く扱われなければならない)。
@end defvar

@defun gentemp &optional x
この関数は@code{gensym}に似ているが、新しい@emph{internされた}
シンボルを生成する点が異なる。生成されたシンボルがすでに存在する場合、
この関数はカウンタを1つずつ増やして、新たなシンボルが生成されるまで
再試行し続ける。
@end defun

Quirozの@file{cl.el}パッケージも、自己引用キーワードシンボル作成用に
@code{defkeyword}フォームを定義した。このパッケージは、@code{&key}
引数指定子によって呼び出されるすべてのキーワードを自動的に作り、
キーワード引数に無関係なデータとしてのキーワードの使用に反対するので、
@code{defkeyword}フォームは中止した。

@iftex
@chapno=11
@end iftex

@node 数, 列, シンボル, トップ
@chapter 数

@noindent
この節は、Emacs Lispでは省かれた、数へのいくつかの単純なCommon Lisp
演算を定義する。

@menu
* 数の述語::                    `plusp'、`oddp'、`floatp-safe'、その他
* 数の関数::                    `abs'、`expt'、`floor*'、その他
* 乱数::                        `random*'、`make-random-state'
* 処理系パラメータ::            `most-positive-fixnum'、`most-positive-float'
@end menu

@iftex
@secno=1
@end iftex

@node 数の述語, 数の関数, 数, 数
@section 数の述語

@noindent
これらの関数は、指定された条件が数の引数で真の場合に@code{t}を戻し、
さもなければ@code{nil}を戻す。

@defun plusp number
この述語は、@var{number}が正かどうかをテストする。引数が数でない場合は
エラーである。
@end defun

@defun minusp number
この述語は、@var{number}が負かどうかをテストする。引数が数でない場合は
エラーである。
@end defun

@defun oddp integer
この述語は、@var{integer}が奇数かどうかをテストする。引数が整数でない
場合はエラーである。
@end defun

@defun evenp integer
この述語は、@var{integer}が偶数かどうかをテストする。引数が整数でない
場合はエラーである。
@end defun

@defun floatp-safe object
この述語は、@var{object}が浮動小数点数かどうかをテストする。
浮動小数点数をサポートするシステムでは、これは@code{floatp}と
同等である。他のシステムでは、これは常に@code{nil}を戻す。
@end defun

@iftex
@secno=3
@end iftex

@node 数の関数, 乱数, 数の述語, 数
@section 数の関数

@noindent
これらの関数は、さまざまな数の算術演算を行なう。

@defun abs number(数)
この関数は、@var{number}の絶対値を戻す(より新しいEmacsの版は、これを
組み込み関数として提供する; このパッケージは、プリミティブとして
提供しないEmacs 18版用にだけ@code{abs}を定義する)。
@end defun

@defun expt base power
この関数は、@var{number}乗した@var{base}を戻す(より新しいEmacsの版は、
これを組み込み関数として提供する; このパッケージは、プリミティブとして
提供しないEmacs 18版用にだけ@code{expt}を定義する)。
@end defun

@defun gcd &rest integers
この関数は、引数の最大公約数を戻す。引数が1つの場合、その引数の絶対値
を戻す。引数がない場合は0を戻す。
@end defun

@defun lcm &rest integers
この関数は、引数の最小公倍数を戻す。引数が1つの場合、その引数の絶対値
を戻す。引数がない場合は1を戻す。
@end defun

@defun isqrt integer
この関数は、その整数引数の``整数平方根''、すなわち、引数の真の
平方根より小さいか等しい最大の整数を計算する。
@end defun

@defun floor* number &optional divisor
この関数は、Common Lispの@code{floor}関数を実装する。Emacs 19に
組み込みの単純な@code{floor}関数との名前の衝突を避けるため、
@code{floor*}と呼ばれる。

引数が1つの場合、@code{floor*}は2つの数のリストを戻す: 2つの数は、
整数へ(負の無限大方向へ)丸められた引数と、引数を再び生み出すために
第1の戻り値に加え戻す必要があるような``余り''である。引数が整数@var{x}
の場合、結果は常にリスト@code{(@var{x} 0)}である。引数がEmacs19の
浮動小数点数の場合、第1の結果はLisp整数であり、第2は0(含む)から
1(含まない)の間のLisp浮動小数点数である。

引数が2つの場合、@code{floor*}は@var{divisor}で@var{number}を割り、
商のfloorと、対応する余りを2つの数のリストとして戻す。
@code{(floor* @var{x} @var{y})}が@code{(@var{q} @var{r})}を戻す場合、
@var{r}を0(含む) から@var{r}(含まない)までとして、
@code{@var{q}*@var{y} + @var{r} = @var{x}}である。
@code{(floor* @var{x})}は、正確に@code{(floor* @var{x} 1)}と同等である
ことにも注意せよ。

この関数は、Common Lispの@code{floor}と完全に互換だが、Emacs Lispは
多値関数をサポートしていないので、リストに入った2つの結果を戻す点が
異なる。
@end defun

@defun ceiling* number &optional divisor
この関数は、Common Lispの@code{ceiling}関数を実装する。@code{ceiling}
は、正の無限大方向へ引数または引数の商を丸める点を除いて、@code{floor}
と類似している。余りは0から負の@var{r}までである。
@end defun

@defun truncate* number &optional divisor
この関数は、Common Lispの@code{truncate}関数を実装する。
@code{truncate}は、0の方向へ引数または引数の商を丸める点を除いて、
@code{floor}と類似している。したがって、引数または商が正の場合は
@code{floor*}と、さもなければ@code{ceiling*}と同等である。余りは
@var{number}と同じ符号を持つ。
@end defun

@defun round* number &optional divisor
この関数は、Common Lispの@code{round}関数を実装する。@code{round}は、
最も近い整数へ引数または引数の商を丸める点を除いて、@code{floor}と類似
している。タイ(引数または引数の商が正確に2つの整数の中間)の場合、偶数
へ丸める。
@end defun

@defun mod* number divisor
この関数は、@code{floor}の2つ目の戻り値と同じ値を戻す。
@end defun

@defun rem* number divisor
この関数は、@code{truncate}の2つ目の戻り値と同じ値を戻す。
@end defun

これらの定義は、Quirozの@file{cl.el}パッケージと互換だが、この
パッケージは、既存のEmacs Lisp関数との衝突を避けるために、ある種の
関数名に@samp{*}を付加している点と、多値戻しのメカニズムが異なる。

@iftex
@secno=8
@end iftex

@node 乱数, 処理系パラメータ, 数の関数, 数
@section 乱数

@noindent
このパッケージは、Common Lisp乱数ジェネレータの実装も提供する。独自の
付加適合的アルゴリズムを使っており、多くの
オペレーティングシステムによって提供される単純なジェネレータよりも、
ずっと統計的にきれいな乱数をおそらく与える。

@defun random* number &optional state
この関数は、@var{number}より小さく同じ型(整数か浮動小数点数のどちらか)
の、負でない乱数を戻す。@var{state}引数は乱数ジェネレータの状態を保持
する@code{random-state}オブジェクトでなければならない。この関数は
副作用として、この状態オブジェクトを修正する。@var{state}が省略された
場合、変数@code{*random-state*}を既定とする。@code{*random-state*}は、
あらかじめ初期化された@code{random-state}オブジェクトを含む。
@end defun

@defvar *random-state*
この変数は、システム``既定''の@code{random-state}オブジェクトを含み、
代替の状態オブジェクトを指定しない@code{random*}への呼び出しのために
使われる。Emacsプロセス内の任意の数のプログラムは、さしはさむような
仕方で@code{*random-state*}にアクセスしてもよいので、この変数から
生成される列は、意図や用途にかかわらず再現不能になるだろう。
@end defvar

@defun make-random-state &optional state
この関数は、@code{random-state}オブジェクトを作成またはコピーする。
@var{state}が省略されるか@code{nil}の場合、新しい@code{*random-state*}
のコピーを戻す。これは、@code{(random* @var{n})}と
@code{(random* @var{n} @var{s})}(@var{s}は新しい
ランダムステートオブジェクト)の呼び出しの将来の列は同一の乱数列を
戻すという意味でコピーである。

@var{state}が@code{random-state}オブジェクトの場合、この関数はその
オブジェクトのコピーを戻す。@var{state}が@code{t}の場合、この関数は
日時を種とする新しい@code{random-state}オブジェクトを戻す。Common Lisp
への拡張として、@var{state}は整数であってもよく、その場合は新しい
オブジェクトはその整数を種とする; それぞれ異なる整数の種は、完全に
異なる乱数列を生じるだろう。

@code{random-state}オブジェクトをバッファまたはファイルに印字して、
後に@code{read}で読み戻すことは正しい。プログラムが、デバッグ用に後に
再現させられるような疑似乱数の列を使いたい場合、新しい列を
取得するために@code{(make-random-state t)}を呼び出して、後にこの列を
ファイルへ印字することができる。プログラムが後で再実行される場合、
ファイルからオリジナルな実行のランダムステートを読むことができる。
@end defun

@defun random-state-p object
この述語は、@var{object}が@code{random-state}オブジェクトの場合に
@code{t}を、さもなければ@code{nil}を戻す。
@end defun

@node 処理系パラメータ, , 乱数, 数
@section 処理系パラメータ

@noindent
このパッケージは、数に関するいくつかの有用な定数を定義する。

@defvar most-positive-fixnum
この定数は、Lisp整数が保持できる最大値と等しい。典型的には
@code{2^23-1}または@code{2^25-1}である。
@end defvar

@defvar most-negative-fixnum
この定数は、Lisp整数が保持できる最小値(最も負の値)と等しい。
@end defvar

下記のパラメータは浮動小数点数と関係がある。このパッケージは、
さまざまな方法で計算機の浮動小数点算術を用いてこれらの値を決定する。
これらの演算は遅いかもしれないので、それらの初期化用のコードは、
パラメータが使われる可能性がある前に呼び出されなければならない切り
離された関数に保たれている。

@defun cl-float-limits
この関数は、@code{most-positive-float}のようなCommon Lisp浮動小数点
パラメータが初期化されていることを確実にする。この関数が呼び
出されるまで、これらのパラメータは@code{nil}だろう。このEmacsの版が
(たとえばEmacs 18のほとんどの版のように)浮動小数点数をサポートしない
場合、それらのパラメータは@code{nil}のままだろう。パラメータがすでに
初期化されている場合、この関数は直ちに戻る。

そのアルゴリズムはほとんどの現代のマシンに有効な仮定を置いているが、
マシンの算術が、たとえば10進法のようにきわめて普通でない場合は
失敗するだろう。
@end defun

真のCommon Lispは、4つまでの異なる浮動小数点精度を持つので、
@code{most-positive-single-float}や@code{most-positive-double-float}、
@code{most-positive-long-float}などのような定数の一群を持つ。Emacsは
1つの浮動小数点精度のみを持つので、このパッケージは定数名から精度の
語を省略する。

@defvar most-positive-float
この定数は、Lisp浮動小数点数が保持できる最大値と等しい。算術が無限を
サポートするようなシステムでは、これは最大の@emph{有限の}値である。
IEEEマシンでは、その値はおおよそ@code{1.79e+308}である。
@end defvar

@defvar most-negative-float
この定数は、Lisp浮動小数点数が保持できる最も負の数と等しい
(@code{(- most-positive-float)}と等しいと仮定される)。
@end defvar

@defvar least-positive-float
この定数は、0より大きい最小のLisp浮動小数点値と等しい。IEEEマシンでは、
非正規がサポートされている場合は約@code{4.94e-324}、そうでなければ
約@code{2.22e-308}である。
@end defvar

@defvar least-positive-normalized-float
この定数は、0より大きい最小の正規化されたLisp浮動小数点(すなわち、IEEE
非正規化が精度の損失を生じない最小の値)と等しい。IEEEマシンでは、この
値は約@code{2.22e-308}である。非正規化の概念や段階的なアンダーフローを
サポートしていないマシンでは、この定数は常に
@code{least-positive-float}と等しい。
@end defvar

@defvar least-negative-float
この定数は、@code{least-positive-float}
@end defvar

@defvar least-negative-normalized-float
この定数は、@code{least-positive-normalized-float}の負の相対物である。
@end defvar

@defvar float-epsilon
この定数は、別の値を生み出すために1.0に加えることができる、最小の正の
Lisp浮動小数点値である。より小さな数を1.0に加えても、丸めのために再び
1.0を生じる。IEEEマシンでは、epsilonは約@code{2.22e-16}である。
@end defvar

@defvar float-negative-epsilon
この定数は、別の値を生み出すために1.0から減じることができる、最小の正
の値である。IEEEマシンでは約@code{1.11e-16}である。
@end defvar

@iftex
@chapno=13
@end iftex

@node 列, リスト, 数, トップ
@chapter 列

@noindent
Common Lispは、@dfn{列}に作用するかなりの数の関数を定義している。列は
リストや文字列、ベクタのいずれかである。Emacs Lispはそれらのいくつか、
特に@code{elt}や@code{length}を含む; このパッケージは、残りのほとんど
を定義する。

@menu
* 列の基本::                 すべての列関数で共有される引数
* 列上のマッピング::         `mapcar*'、`mapcan'、`map'、`every'、その他
* 列関数::                   `subseq'、`remove*'、`substitute'、その他
* 列の検索::                 `find'、`position'、`count'、`search'、その他
* 列のソート::               `sort*'、`stable-sort'、`merge'
@end menu

@node 列の基本, 列上のマッピング, 列, 列
@section 列の基本

@noindent
列関数の多くはキーワード引数をとる; @pxref{引数リスト}. すべての
キーワード引数は付加的であり、指定される場合は任意の順序に現れてよい。

@code{:key}引数は、@code{nil}あるいは1引数の関数を
渡されなければならない。このキー関数は、それを通して列の要素が
見えるようなフィルタとして使われる; たとえば、
@code{(find x y :key 'car)}は@code{(assoc* x y)}と似ている: @code{x}
自身に等しい要素ではなく、その@code{car}が@code{x}に等しいリストの
要素を検索する。@code{:key}が省略されるか@code{nil}の場合、フィルタは
実際には恒等関数である。

@code{:test}と@code{:test-not}引数は、@code{nil}あるいは2引数の
関数でなければならない。テスト関数は、2つの列要素を比較するために、
あるいは検索値と列要素を比較するために使われる(2つの値は、それから
派生したオリジナルの列関数の引数と同じ順序で、両方が同じ列からくる
場合は列に現れるのと同じ順序で、テスト関数に渡される)。@code{:test}
引数は、マッチを示すために真(非@code{nil})を戻す関数を
指定しなければならない; そのかわりに、マッチを示すために@emph{偽}を
戻す関数を与えるために@code{:test-not}を使ってもよい。既定のテスト
関数は@code{:test 'eql}である。

@var{item}と@code{:test}または@code{:test-not}をとる関数の多くには、
変種@code{-if}や@code{-if-not}もある。そこでは、@var{predicate}関数が
@var{item}の代わりに渡され、その述語が真(あるいは@code{-if-not}の
場合は偽)を戻す場合、列の要素はマッチする。たとえば:

@example
(remove* 0 seq :test '=)  @equiv{}  (remove-if 'zerop seq)
@end example

@noindent
は、列@code{seq}からすべての0を取り除く。

いくつかの演算は、引数列の部分列に働くことができる; これらの関数は、
既定がそれぞれ0と列の長さである@code{:start}と@code{:end}引数をとる。
@var{start}(含む)と@var{end}(含まない)の間の要素だけが、その演算に
影響される。@var{end}引数は、列の長さを表わすために@code{nil}を
渡されてもよい; さもなければ、@var{start}と@var{end}はともに整数で、
@code{0 <= @var{start} <= @var{end} <= (length @var{seq})}
でなければならない。関数が2つの列引数をとる場合、制限は、第1の列は
キーワード@code{:start1}と@code{:end1}で、第2の列はキーワード
@code{:start2}と@code{:end2}で定義される。

いくつかの関数は、@code{:from-end}引数と@code{:count}引数を
受け入れる。@code{:from-end}が非@code{nil}の場合、演算が左から
右へではなく右から左へ列を通っていくことを引き起こし、@code{:count}
は、取り除かれるか処理されるかする要素の最大数の整数を指定する。

列関数は、@code{:test}や@code{:test-not}、@code{:key}関数がさまざまな
要素上で呼び出される順序を保証しない。したがって、これらの関数の
副作用に依存するのは悪い考えである。たとえば、@code{:from-end}は列が
実際に逆順で走査されることを引き起こすかもしれないし、正順で走査して、
しかし後ろから走査されたように結果を計算してもよい(@code{mapcar*}や
@code{every}のようないくつかの関数は、副作用がこれらの場合は完全に
受け入れられるように、関数が呼び出される順序を正確に指定@emph{する})。

GNU Emacs 19の文字列は、文字データと同様に``テキスト属性''を
含んでもよい。注がある場合を除いて、列関数によってテキスト属性が
保存されるかどうかは未定義である。たとえば
@code{(remove* ?A @var{str})}は、@var{str}からコピーされて結果として
生じた文字の属性を保存するかもしれないし、保存しないかもしれない。

@node 列上のマッピング, 列関数, 列の基本, 列
@section 列上のマッピング

@noindent
これらの関数は、リストまたは配列の要素上に、指定した関数を``マップ''
する。それらはすべて、組み込み関数@code{mapcar}のテーマの変奏である。

@defun mapcar* function seq &rest more-seqs
この関数は、その引数列に連続する並列の要素の集合上で@var{function}を
呼び出す。1つの@var{seq}引数の場合、@code{mapcar}と同等である; @var{n}
列の場合、結果のリストの第1要素を生み出すために、それぞれの列の
第1要素を@var{n}引数として関数を呼び出す。それから第2要素以降にも
同様に呼び出す。マップは、最も短い列が尽きたらすぐに止まる。引数列は、
リストや文字列、ベクタのいずれの混合でもよい; 戻される列は常に
リストである。

Common Lispの@code{mapcar}は多重引数を受け入れるが、リスト上でのみ
動作する; Emacs Lispの@code{mapcar}は1つの列引数を受け入れる。この
パッケージの@code{mapcar*}は、両方に互換なスーパーセットとして
動作する。
@end defun

@defun map result-type function seq &rest more-seqs
この関数は、ちょうど@code{mapcar*}のように、引数列の上に@var{function}
をマップするが、リストではなく型@var{result-type}の列を戻す。
@var{result-type}は下記のシンボルの1つでなければならない:
@code{vector}、@code{string}、@code{list}(この場合、効果は
@code{mapcar*}と同じ)、または@code{nil}(この場合、結果は捨て去られ、
@code{map}は@code{nil}を戻す)。
@end defun

@defun maplist function list &rest more-lists
この関数は、その引数リストのそれぞれの上で@var{function}を呼び出して、
それらのリストの@code{cdr}の上で呼び出して、というように最短のリストが
尽きるまで続く。結果はリストのフォーム中に戻される。したがって
@code{maplist}は、前進するポインタの@code{car}ではなく、リストの
ポインタ自身を通っていく点を除いて、@code{mapcar*}と似ている。
@end defun

@defun mapc function seq &rest more-seqs
この関数は@code{mapcar*}と似ているが、@var{function}によって戻される
値はリストに集積されるのではなく、無視され捨て去られる点が異なる。
@code{mapc}の戻り値は、第1の列@var{seq}である。
@end defun

@defun mapl function list &rest more-lists
この関数は@code{maplist}に似ているが、@var{function}によって戻される
値を捨て去る点が異なる。
@end defun

@defun mapcan function seq &rest more-seqs
この関数は@code{mapcar*}に似ているが、単に戻り値
(リストでなければならない)を集積するのではなく、@code{nconc}を使って
連結する点が異なる。
@end defun

@defun mapcon function list &rest more-lists
この関数は@code{maplist}に似ているが、@code{nconc}を使って戻り値を
連結する点が異なる。
@end defun

@defun some predicate seq &rest more-seqs
この関数は、順に@var{seq}の各要素に@var{predicate}を呼び出す;
@var{predicate}が非@code{nil}を戻す場合、@code{some}はその値を戻し、
そうでなければ@code{nil}を戻す。いくつかの列引数が与えられる場合、
ちょうど@code{mapcar*}のように、最短の列が尽きるまで並列に列を通る。
左から右への順序で要素が訪問されることや、@var{predicate}が
非@code{nil}を戻すとすぐにマッピングが止まるという事実に依存できる。
@end defun

@defun every predicate seq &rest more-seqs
この関数は、順に列の各要素に@var{predicate}を呼び出す; @var{predicate}
がいずれかの要素で@code{nil}を戻すとすぐに@code{nil}を、述語がすべての
要素で真の場合に@code{t}を戻す。
@end defun

@defun notany predicate seq &rest more-seqs
この関数は、順に列の各要素に@var{predicate}を呼び出す; @var{predicate}
がいずれかの要素で非@code{nil}を戻すとすぐに@code{nil}を、述語がすべて
の要素で@code{nil}の場合に@code{t}を戻す。
@end defun

@defun notevery predicate seq &rest more-seqs
この関数は、順に列の各要素に@var{predicate}を呼び出す; @var{predicate}
がいずれかの要素で@code{nil}を戻すとすぐに非@code{nil}を、述語がすべて
の要素で真の場合に@code{t}を戻す。
@end defun

@defun reduce function seq @t{&key :from-end :start :end :initial-value :key}
この関数は、結合二項演算を使って@var{seq}の要素を結合する。
@var{function}が@code{*}で@var{seq}がリスト@code{(2 3 4 5)}だと
仮定する。最初のリストの2つの要素は@code{(* 2 3) = 6}と結合される;
これは次の要素@code{(* 6 4) = 24}と結合され、最後の要素
@code{(* 24 5) = 120}と結合される。@code{*}関数はたまたま
自己縮約的なので、@code{(* 2 3 4 5)}は@code{reduce}への明示的な
呼び出しと同じ効果を持つことに注意せよ。

@code{:from-end}が真の場合、縮約は左結合の代わりに右結合である:

@example
(reduce '- '(1 2 3 4))
     @equiv{} (- (- (- 1 2) 3) 4) @result{} -8
(reduce '- '(1 2 3 4) :from-end t)
     @equiv{} (- 1 (- 2 (- 3 4))) @result{} -2
@end example

@code{:key}が指定された場合、それは順に列の各要素上で呼び出される、
1引数の関数である。

@code{:initial-value}が指定された場合、それは実際に列の先頭に
(@code{:from-end}の場合は末尾に)加えられる。@code{:key}関数は初期値に
は適用され@emph{ない}。

列が、初期値を含めて正確に1つの要素を持つ場合、その要素は決して
@var{function}を呼び出すことなしに戻される。列が空の(そして
初期値がない)場合、@var{function}は戻り値を得るために、引数なしで呼び
出される。
@end defun

これらのマッピング演算はすべて、@code{loop}マクロで便利に
表現することができる。コンパイルされたコードでは、関数呼び出しのない
インラインコードとしてループを生成するので、@code{loop}の方が
速いだろう。

@node 列関数, 列の検索, 列上のマッピング, 列
@section 列関数

@noindent
この節は、列に作用するかなりの数のCommon Lisp関数を記述する。

@defun subseq sequence start &optional end
この関数は、引数@var{sequence}の与えられた部分列を戻す。@var{sequence}
はリストや、文字列、ベクタでもよい。インデックス@var{start}と@var{end}
は範囲内でなければならず、@var{start}は@var{end}より大きくてはならない。
@var{end}が省略された場合、列の長さを既定とする。戻り値は常にコピーで
ある; @var{sequence}と構造を共有しない。

Common Lispへの拡張として、@var{start}および/または@var{end}は負数でも
よい。その場合、それらは列の終わりからの距離を表現する。これは、Emacs
の@code{substring}関数と互換である。@code{subseq}は、負の@var{start}や
@var{end}を許す@emph{唯一の}列関数であることに注意せよ。

要素の指定した範囲を別の列の要素で置き換えるために、@code{subseq}
フォーム上で@code{setf}を使うことができる。置き換えは、以下に記述する
@code{replace}によってのように行なわれる。
@end defun

@defun concatenate result-type &rest seqs
この関数は、型@var{result-type}の結果の列を形成するために、引数列を
一緒に連結する。@var{result-type}はシンボル@code{vector}または
@code{string}、@code{list}のいずれかである。引数は、結果が引数と
同一である@code{(concatenate 'list '(1 2 3))}のような場合ですら常に
コピーされる。
@end defun

@defun fill seq item @t{&key :start :end}
この関数は、値@var{item}で列の要素(あるいは列の指定された部分)を満たす。
@end defun

@defun replace seq1 seq2 @t{&key :start1 :end1 :start2 :end2}
この関数は、@var{seq2}の一部を@var{seq1}の一部にコピーする。列
@var{seq1}は伸びたり縮んだりしない; コピーされるデータの量は、単に元と
先の(副)列の短い方である。この関数は@var{seq1}を戻す。

@var{seq1}と@var{seq2}が@code{eq}の場合、開始と終了引数で示される
範囲が重なっていても正しく動作する。しかし、@var{seq1}と@var{seq2}が、
記憶域を共有するが@code{eq}ではないリストであり、開始と終了引数が
重なる範囲を指定する場合、その効果は未定義である。
@end defun

@defun remove* item seq @t{&key :test :test-not :key :count :start :end :from-end}
これは、@var{item}にマッチするすべての要素を取り除いた@var{seq}の
コピーを戻す。結果は、ある状況では@var{seq}と記憶域を共有するか
@code{eq}であってもよいが、オリジナルの@var{seq}は修正されない。
@code{:test}や@code{:test-not}、@code{:key}引数は使われる
マッチテストを定義する; 既定では、@var{item}と@code{eql}の要素が
取り除かれる。@code{:count}引数は、取り除かれてよいマッチする要素の
最大数を指定する(一番左の@var{count}マッチだけが取り除かれる)。
@code{:start}と@code{:end}引数は、要素が取り除かれる@var{seq}の領域を
指定する; 領域の外の要素は、マッチしないか取り除かれない。
@code{:from-end}引数が真の場合、要素は先頭からではなく列の終わりから
削除されるべきだということを表わす(これは@var{count}も指定された
場合にだけ問題となる)。
@end defun

@defun delete* item seq @t{&key :test :test-not :key :count :start :end :from-end}
これは、@var{item}にマッチする@var{seq}のすべての要素を削除する。
それは破壊的な作用である。Emacs Lispは、伸縮可能な文字列やベクタを
サポートしないので、これはそれらの列型には@code{remove*}と同じである。
リストに対しては、@code{remove*}はオリジナルのリストを保存するために
必要な場合はリストをコピーするが、@code{delete*}は引数リストの
部分をつなぐ。@code{append}と@code{nconc}を比較せよ。これらは、Emacs
Lisp中にある類似の非破壊的/破壊的リスト演算である。
@end defun

@findex remove-if
@findex remove-if-not
@findex delete-if
@findex delete-if-not
述語起源の関数@code{remove-if}や@code{remove-if-not}、@code{delete-if}、
@code{delete-if-not}は同様に定義される。

@defun delete item list
このMacLisp互換の関数は、@var{item}と@code{equal}なすべての要素を
@var{list}から削除する。@code{delete}関数は、Emacs 19へは組み込まれて
いる; このパッケージは、Emacs 18にそれを同等に定義する。
@end defun

@defun remove item list
この関数は、@var{item}と@code{equal}なすべての要素を@var{list}から
取り除く。@code{remove}はEmacs 19へは組み込まれていないが、
このパッケージは@code{delete}との対称のためにそれを定義する。
@end defun

@defun remq item list
この関数は、@var{item}と@code{eq}なすべての要素を@var{list}から
取り除く。@code{remq}はEmacs 19へは組み込まれていないが、
このパッケージは@code{delq}との対称のためにそれを定義する。
@end defun

@defun remove-duplicates seq @t{&key :test :test-not :key :start :end :from-end}
この関数は、重複要素を取り除いた@var{seq}のコピーを戻す。つまり、
列からの2つの要素が@code{:test}や@code{:test-not}、@code{:key}引数に
従ってマッチする場合、一番右のものだけが保たれる。@code{:from-end}が
真の場合、一番左のものがその代わりに保たれる。@code{:start}または
@code{:end}が指定された場合、その部分列の要素だけが調べられるか
取り除かれる。
@end defun

@defun delete-duplicates seq @t{&key :test :test-not :key :start :end :from-end}
この関数は、@var{seq}から重複要素を削除する。それは
@code{remove-duplicates}の破壊的版である。
@end defun

@defun substitute new old seq @t{&key :test :test-not :key :count :start :end :from-end}
この関数は、@var{old}とマッチするすべての要素を@var{new}と置き換えた
@var{seq}のコピーを戻す。@code{:count}や@code{:start}、@code{:end}、
@code{:from-end}引数は、置き換えが行なわれる数を制限するために使われて
もよい。
@end defun

@defun nsubstitute new old seq @t{&key :test :test-not :key :count :start :end :from-end}
これは、@code{substitute}の破壊的版である; それは、列の変更されたコピー
を戻すのではなく、@code{setcar}や@code{aset}を使って置き換えを行なう。
@end defun

@findex substitute-if
@findex substitute-if-not
@findex nsubstitute-if
@findex nsubstitute-if-not
@code{substitute-if}や@code{substitute-if-not}、@code{nsubstitute-if}、
@code{nsubstitute-if-not}関数は同様に定義される。これらのために、
@var{predicate}が@var{old}引数の場所に与えられる。

@node 列の検索, 列のソート, 列関数, 列
@section 列の検索

@noindent
これらの関数は、列の中で要素や部分列を検索する(@code{member*}や
@code{assoc*}も参照; @pxref{リスト})。

@defun find item seq @t{&key :test :test-not :key :start :end :from-end}
この関数は、@var{item}とマッチする要素を見つけるために@var{seq}を検索
する。マッチが見つかった場合、マッチした要素を戻す。そうでなければ、
@code{nil}を戻す。@code{:from-end}が真でない場合、一番左のマッチを戻す。
@code{:from-end}が真の場合、一番右のマッチを戻す。@code{:start}や
@code{:end}引数は、検索される要素の範囲を制限するために使用してもよい。
@end defun

@defun position item seq @t{&key :test :test-not :key :start :end :from-end}
この関数は@code{find}と似ているが、項目自身ではなく、マッチする項目の
列の中の位置を示す整数を戻す点が異なる。@code{:start}が0でない
場合でさえ、位置は全体として列の開始から相対である。マッチする要素が
見つからない場合、この関数は@code{nil}を返す。
@end defun

@defun count item seq @t{&key :test :test-not :key :start :end}
この関数は、@var{item}とマッチする@var{seq}の要素の数を戻す。結果は
常に負ではない整数である。
@end defun

@findex find-if
@findex find-if-not
@findex position-if
@findex position-if-not
@findex count-if
@findex count-if-not
@code{find-if}や@code{find-if-not}、@code{position-if}、
@code{position-if-not}、@code{count-if}、@code{count-if-not}は同様に
定義される。

@defun mismatch seq1 seq2 @t{&key :test :test-not :key :start1 :end1 :start2 :end2 :from-end}
この関数は、@var{seq1}と@var{seq2}の指定された部分を比較する。それらが
同じ長さで、対応する要素が(@code{:test}や@code{:test-not}、@code{:key}
に従って)マッチする場合、この関数は@code{nil}を戻す。ミスマッチがある
場合、この関数は第1のミスマッチ要素の(@var{seq1}に相対な)インデクスを
戻す。これは、マッチしない一番左の要素のペアか、2つの非マッチ列の短い
方が尽きた場所である。

@code{:from-end}が真の場合、要素は@code{(1- @var{end1})}と
@code{(1- @var{end2})}から始まり右から左へ比較される。列が異なる場合、
一番右の(@var{seq1}に相対な)相違のインデクスに1を加えた値が戻される。

興味深い例は@code{(mismatch str1 str2 :key 'upcase)}であり、これは
大文字小文字を区別せずに2つの文字列を比較する。
@end defun

@defun search seq1 seq2 @t{&key :test :test-not :key :from-end :start1 :end1 :start2 :end2}
この関数は、@var{seq1}(あるいは@code{:start1}や@code{:end1}で
指定された部分)とマッチする部分列を見つけるために@var{seq2}を
検索する。@code{:start2}や@code{:end2}で定義される領域内に完全に入る
マッチのみが考慮される。戻り値は、@var{seq2}の開始に相対な一番左
マッチの一番左の要素のインデクスか、マッチが見つからない場合は
@code{nil}である。@code{:from-end}が真の場合、この関数は
@emph{一番右の}マッチする部分列を見つける。
@end defun

@node 列のソート, , 列の検索, 列
@section 列のソート

@defun sort* seq predicate @t{&key :key}
この関数は、要素の対を比較するために@var{predicate}を使って決定される
昇順に@var{seq}をソートする。@var{predicate}は、その第1引数がその第2
引数より小さい場合にのみ真(非@code{nil})を戻さなければならない。
たとえば@code{<}や@code{string-lessp}は、それぞれ数や文字列を
ソートするのに適切な述語関数である; @code{>}は昇順ではなく降順で数を
ソートするだろう。

この関数は、単なるリストにではなく、列のすべての型に作用できる点で、
Emacs組み込みの@code{sort}と異なる。また、@var{predicate}関数へ
与えられるデータを前処理するのに使われる、@code{:key}引数を受け
入れる。たとえば、

@example
(setq data (sort data 'string-lessp :key 'downcase))
@end example

@noindent
は、大文字小文字を考慮せずにアルファベットの昇順に文字列の列@var{data}
をソートする。@code{car}の@code{:key}関数は、連想リストのソートに有用
だろう。

@code{sort*}関数は破壊的である; 適切な仕方で@code{cdr}ポインタを実際に
再配列することで、リストをソートする。
@end defun

@defun stable-sort seq predicate @t{&key :key}
この関数は、@var{seq}を@dfn{安定して}ソートする。@dfn{安定して}とは、
@var{predicate}に関して等値な2つの要素は、ソートによってその元の
順序から再配列されないことが保証されているという意味である。

実際、@code{sort*}と@code{stable-sort}は、その下にある@code{sort}関数
が既定では安定なので、Emacs Lispでは同等である。しかしこのパッケージは、
将来@code{sort*}のために非安定な方法を使う権利を予約する。
@end defun

@defun merge type seq1 seq2 predicate @t{&key :key}
この関数は、それらの要素を差しはさむことで、2つの列@var{seq1}と
@var{seq2}をマージする。結果の列は、(@code{concatenate}の意味で)
@var{type}の型を持ち、2つの入力列の長さの和と等しい長さを持つ。列は
破壊的に修正されるかもしれない。@var{seq1}と@var{seq2}内の要素の
順序は、差しはさみで保存される; 2つの列の要素は、(@code{sort}の
意味で) @var{predicate}で比較され、より小さい要素が結果の先に行く。
要素が等値の場合、結果では@var{seq1}が@var{seq2}からの要素よりも
先にくる。従って、@var{seq1}と@var{seq2}がともに@var{predicate}に
従ってソートされる場合、結果は@var{predicate}に従って(安定に)
ソートされたマージ列だろう。
@end defun

@node リスト, ハッシュ表, 列, トップ
@chapter リスト

@noindent
ここに記述される関数はリストに作用する。

@menu
* リスト関数::                    `caddr'、`first'、`last*'、`list*'、その他
* 式の置き換え::                  `subst'、`sublis'、その他
* 集合としてのリスト::            `member*'、`adjoin'、`union'、その他
* 連想リスト::                    `assoc*'、`rassoc*'、`acons'、`pairlis'
@end menu

@node リスト関数, 式の置き換え, リスト, リスト
@section リスト関数

@noindent
この節は、リスト上、すなわちコンスセルの連鎖上のかなりの数の単純な演算
を記述する。

@defun caddr x
この関数は、@code{(car (cdr (cdr @var{x})))}と同等である。同様にこの
パッケージは、@var{xxx}が4つまでの@samp{a}および/または@samp{d}
である、28個の@code{c@var{xxx}r}関数すべてを定義する。これらの
関数はすべて@code{setf}可能であり、それらへの呼び出しは、最大の
効率のためにバイトコンパイラでインラインに展開される。
@end defun

@defun first x
この関数は、@code{(car @var{x})}の同義語である。同様に、関数
@code{second}、@code{third}、@dots{}、@code{tenth}はリスト@var{x}の
与えられた要素を戻す。
@end defun

@defun rest x
この関数は、@code{(cdr @var{x})}の同義語である。
@end defun

@defun endp x
Common Lispは、この関数は@code{null}と同様に動作するが、@code{x}が
@code{nil}でもコンスセルでもない場合はエラーを通知するように定義する。
このパッケージは、単に@code{null}の同義語として@code{endp}を定義する。
@end defun

@defun list-length x
この関数は、@code{(length @var{x})}と正確に同じようにリスト@var{x}の
長さを戻すが、@var{x}が循環リスト(cdr連鎖が@code{nil}で
終端するのではなくループを形成する)の場合、この関数は@code{nil}を戻す
(正規の@code{length}関数は、循環リストを与えられた場合、はまりこんで
動けなくなるだろう)。
@end defun

@defun last* x &option(付加)al n
この関数は、リスト@var{x}の最後のコンスか、最後から@var{n}番目のコンス
を戻す。@var{n}が省略された場合、1を既定とする。``最後のコンス''は、
その@code{cdr}が別のコンスセルではない、リストの最初のコンスセルを
意味する(通常のリストでは、最後のコンスの@code{cdr}は@code{nil}
である)。@var{x}が@code{nil}または@var{n}よりも短い場合、この関数は
@code{nil}を戻す。リストの最後の@emph{要素}は、
@code{(car (last @var{x}))}であることに注意せよ。

Emacs関数@code{last}は、付加引数@var{n}を扱わないことを除いて
同じことをする。
@end defun

@defun butlast x &optional n
この関数は、最後の要素、または最後の@var{n}個の要素を取り除いたリスト
@var{x}を戻す。@var{n}が0より大きい場合、オリジナルのリストに損害を
与えないように、リストのコピーを作る。一般に、
@code{(append (butlast @var{x} @var{n}) (last @var{x} @var{n}))}は、
@var{x}と等値なリストを戻す。
@end defun

@defun nbutlast x &optional n
これは、リストのコピーを作るのではなく、適切な要素の@code{cdr}を破壊的
に修正することで動作する@code{butlast}の版である。
@end defun

@defun list* arg &rest others
この関数は、その引数のリストを構成する。最後の引数は、構成される最後の
セルの@code{cdr}になる。従って、@code{(list* @var{a} @var{b} @var{c})}
は@code{(cons @var{a} (cons @var{b} @var{c}))}と同等であり、
@code{(list* @var{a} @var{b} nil)}は@code{(list @var{a} @var{b})}と
同等である。

(この関数は、Common Lispで実際に@code{list*}と呼ばれることに注意せよ;
@code{member*}や@code{defun*}のように、このパッケージのために
発明された名前ではない)
@end defun

@defun ldiff list sublist
@var{sublist}が@var{list}の副リストの場合、すなわち、@var{list}の
コンスセルの1つと@code{eq}の場合、この関数は、@var{sublist}までで
@var{sublist}は含まない@var{list}の部分のコピーを戻す。たとえば、
@code{(ldiff x (cddr x))}はリスト@code{x}の最初の2つの要素を戻す。結果
はコピーである; オリジナルの@var{list}は修正されない。@var{sublist}が
@var{list}の副リストでない場合、@var{list}全体のコピーが戻される。
@end defun

@defun copy-list list
この関数は、リスト@var{list}のコピーを戻す。それは、@code{(1 2 . 3)}の
ようなドットリストを正しくコピーする。
@end defun

@defun copy-tree x &optional vecp
この関数は、コンスセル@var{x}の木のコピーを戻す。@code{cdr}方向沿いに
だけコピーする@code{copy-sequence}(やその別名である@code{copy-list})と
は異なり、この関数は@code{car}と@code{cdr}の両方の方向に沿って(再帰的
に)コピーする。@var{x}がコンスセルではない場合、単に@var{x}を変えずに
戻す。付加的な@var{vecp}引数が真の場合、この関数はコンスセルと
同じように(再帰的に)ベクタをコピーする。
@end defun

@defun tree-equal x y @t{&key :test :test-not :key}
この関数は、コンスセルの2つの木を比較する。@var{x}と@var{y}がともに
コンスセルの場合、それらの@code{car}と@code{cdr}が再帰的に比較される。
@var{x}も@var{y}もコンスセルではない場合、@code{eql}か指定されたテスト
に従って比較される。@code{:key}関数が指定された場合、両方の木の要素に
適用される。@xref{列}.
@end defun

@iftex
@secno=3
@end iftex

@node 式の置き換え, 集合としてのリスト, リスト関数, リスト
@section 式の置き換え

@noindent
これらの関数は、コンスセルの木全体で要素を置き換える。(リストの
トップレベルの要素だけに作用する@code{substitute}関数に関しては、
@xref{列関数}.)

@defun subst new old tree @t{&key :test :test-not :key}
この関数は、コンスセルの木である@var{tree}の中の、@var{old}の出現を
@var{new}で置き換える。置き換えられた木を戻す。木は、置き換えが
起こらなかった部分は引数@var{tree}と記憶域を共有するかもしれない点は
除いて、コピーである。オリジナルの@var{tree}は修正されない。この
関数は、構成要素のコンスセルの@code{car}と@code{cdr}両方に再帰し、
@var{old}に対して比較する。@var{old}自身がコンスセルの場合、木の中の
マッチするセルは、そのセル中は再帰的に置き換えられることなしに、
通常通り置き換えられる。@var{old}との比較は、指定されたテスト(既定では
@code{eql})に従ってなされる。@code{:key}関数は、木の要素に
適用されるが、@var{old}には適用されない。
@end defun

@defun nsubst new old tree @t{&key :test :test-not :key}
この関数は@code{subst}と似ているが、コピーするのではなく(@code{setcar}
または@code{setcdr}で)破壊的に修正することで動作する点が異なる。
@end defun

@findex subst-if
@findex subst-if-not
@findex nsubst-if
@findex nsubst-if-not
@code{subst-if}や@code{subst-if-not}、@code{nsubst-if}、
@code{nsubst-if-not}関数は同様に定義される。

@defun sublis alist tree @t{&key :test :test-not :key}
この関数は@code{subst}と似ているが、@var{old}と@var{new}の対の
連想リストを取る点が異なる。木の各要素は、(@code{:key}関数がある
場合はそれを適用後)@var{alist}の@code{car}と比較される; マッチする
場合、対応する@code{cdr}で置き換えられる。
@end defun

@defun nsublis alist tree @t{&key :test :test-not :key}
これは@code{sublis}の破壊版である。
@end defun

@node 集合としてのリスト, 連想リスト, 式の置き換え, リスト
@section 集合としてのリスト

@noindent
これらの関数は、要素の集合を表現するリストに作用する。

@defun member item list
このMacLisp互換の関数は、@var{item}と@code{equal}である要素を見つける
ために@var{list}を検索する。@code{member}関数はEmacs 19へ組み込まれて
いる; このパッケージは、Emacs 18に同等にそれを定義する。Common Lisp互
換版の下記の関数を参照せよ。
@end defun

@defun member* item list @t{&key :test :test-not :key}
この関数は、@var{item}とマッチする要素を見つけるために@var{list}を
検索する。マッチが見つかった場合、その@code{car}がマッチする要素である
コンスセルを戻す。さもなければ@code{nil}を戻す。要素は、既定では
@code{eql}で比較される; この振る舞いを修正するために、@code{:test}や
@code{:test-not}、@code{:key}引数を使ってもよい。@xref{列}.

この関数の名前は、Emacs 19に定義されている非互換な@code{member}関数を
避けるために、@samp{*}で接尾辞づけられていることに注意せよ(その関数は
比較に@code{equal}を使う; それは
@code{(member* @var{item} @var{list} :test 'equal)}と同等である)。
@end defun

@findex member-if
@findex member-if-not
@code{member-if}と@code{member-if-not}関数は同様に、与えられた述語を
満たす要素を検索する。

@defun tailp sublist list
この関数は、@var{sublist}が@var{list}の副リスト、すなわち@var{sublist}
が@var{list}またはその@code{cdr}のいずれかと@code{eql}である場合に、
@code{t}を戻す。
@end defun

@defun adjoin item list @t{&key :test :test-not :key}
この関数は、@var{item}がそのリストにまだ存在しない場合(@code{member*}
によって決定される)にだけ、@code{(cons @var{item} @var{list})}のように、
@var{list}の先頭に@var{item}をコンスする。@code{:key}引数が指定された
場合、@var{item}がリストの一部に``なろうとしている''のを推理するために、
検索の間に@var{list}の要素と同様に@var{item}に適用される。
@end defun

@defun union list1 list2 @t{&key :test :test-not :key}
この関数は、項目の集合を表現する2つのリストを結合し、それらの2つの集合
の和集合を表現するリストを戻す。結果のリストは、@var{list1}または
@var{list2}に現れるすべての項目を含み、それ以外は含まない。要素が
@var{list1}と@var{list2}にともに現れる場合、それは1度だけコピーされる。
項目が@var{list1}または@var{list2}中で重複している場合、その重複が結果
のリストに生き残るかどうかは未定義である。結果のリスト中の要素の順序も
未定義である。
@end defun

@defun nunion list1 list2 @t{&key :test :test-not :key}
これは@code{union}の破壊版である; コピーするのではなく、可能ならば引数
リストの記憶域を再利用しようと試みる。
@end defun

@defun intersection list1 list2 @t{&key :test :test-not :key}
この関数は、@var{list1}と@var{list2}で表現される集合の積集合を計算する。
それは、@var{list1}と@var{list2}にともに現れる項目のリストを戻す。
@end defun

@defun nintersection list1 list2 @t{&key :test :test-not :key}
これは@code{intersection}の破壊版である。コピーするのではなく、
@var{list1}の記憶域を再利用しようと試みる。@var{list2}の記憶域は再利用
し@emph{ない}。
@end defun

@defun set-difference list1 list2 @t{&key :test :test-not :key}
この関数は、@var{list1}と@var{list2}の``差集合''、すなわち@var{list1}
に現れるが@var{list2}には現れ@emph{ない}要素の集合を計算する。
@end defun

@defun nset-difference list1 list2 @t{&key :test :test-not :key}
これは破壊的な@code{set-difference}であり、可能なら@var{list1}を再利用
しようとする。
@end defun

@defun set-exclusive-or list1 list2 @t{&key :test :test-not :key}
この関数は、@var{list1}と@var{list2}の``排他的論理和集合''、すなわち
@var{list1}と@var{list2}の正確に1つだけ現れる要素の集合を計算する。
@end defun

@defun nset-exclusive-or list1 list2 @t{&key :test :test-not :key}
これは破壊的な@code{set-exclusive-or}であり、可能なら@var{list1}と
@var{list2}を再利用しようとする。
@end defun

@defun subsetp list1 list2 @t{&key :test :test-not :key}
この関数は、@var{list1}が@var{list2}の部分集合を表現しているかどうか、
すなわち@var{list1}の各要素が@var{list2}にも現れるかどうかを
チェックする。
@end defun

@node 連想リスト, , 集合としてのリスト, リスト
@section 連想リスト

@noindent
@dfn{連想リスト}は、値の1つの集合から他の集合への写像を表現するリスト
である; その要素がコンスセルであるすべてのリストは連想リストである。

@defun assoc* item a-list @t{&key :test :test-not :key}
この関数は、その@code{car}が与えられた@var{item}と(@code{:test}や
@code{:test-not}、@code{:key}の意味で、または@code{eql}での比較で)
マッチする要素を見つけるために、連想リスト@var{a-list}を検索する。
マッチする要素がある場合はそれを、さもなければ@code{nil}を戻す。
コンスセルではない@var{a-list}の要素は無視する(これは、Emacs Lispでの
@code{assq}や@code{assoc}の振る舞いに対応する; Common Lispの
@code{assoc}は@code{nil}を無視するが、@var{a-list}のそれ以外の非コンス
要素はエラーとみなす)。
@end defun

@defun rassoc* item a-list @t{&key :test :test-not :key}
この関数は、その@code{cdr}が@var{item}とマッチする要素を検索する。
@var{a-list}が写像を表現する場合、これは@var{item}へ逆写像を適用する。
@end defun

@defun rassoc item a-list
この関数は、@code{equal}の@code{:test}引数を持つ@code{rassoc*}のように
検索する。それは、Emacs Lispの標準の@code{assoc}関数と類似している。
Emacs Lisp標準@code{assoc}関数はCommon Lispの伝統よりもMacLispに
由来する。
@end defun

@findex assoc-if
@findex assoc-if-not
@findex rassoc-if
@findex rassoc-if-not
@code{assoc-if}や@code{assoc-if-not}、@code{rassoc-if}、
@code{rassoc-if-not}関数は同様に定義される。

連想リストを構築する2つの単純な関数は:

@defun acons key value alist
これは@code{(cons (cons @var{key} @var{value}) @var{alist})}と
同等である。
@end defun

@defun pairlis keys values &optional alist
これは
@code{(nconc (mapcar* 'cons @var{keys} @var{values}) @var{alist})}と
同等である。
@end defun

@node ハッシュ表, 構造体, リスト, トップ
@chapter ハッシュ表

@noindent
@dfn{ハッシュ表}は、``値''に``キー''をマップするデータ構造である。
キーと値は任意のLispデータオブジェクトであってよい。ハッシュ表は、
与えられたキーを検索する時間がほぼ一定だという特性を持つ; より単純な
連想リストのようなデータ構造は、リスト中のエントリ数に比例する
時間がかかる。

@defun make-hash-table @t{&key :test :size}
この関数は、その要素比較用の関数が@code{:test}(既定では@code{eql})
であり、およそ@code{:size}の要素に合うように割り当てられたハッシュ表
オブジェクトを作成して戻す。@code{:size}引数は、単に助言を
与えるものである; より多くの要素を格納する場合、表は自動的に
大きくなる。@code{:size}が省略された場合、手頃な既定値が使われる。

Common Lispは、@code{eq}と@code{eql}、@code{equal}、@code{equalp}
だけを@code{:test}引数の正しい値として許す。このパッケージでは、
すべての適当な述語関数が動作するが、何か他のものを使う場合、あなたの
述語に適切なことを確実にするために、以下に記述するハッシュ関数の詳細を
チェックすべきである。

(Lucid Emacs 19のような)Emacsのある版は、組み込みのハッシュ表型を
含む; これらの版では、@code{eq}のテストを伴う@code{make-hash-table}
がこれらの組み込みのハッシュ表を使う。他のすべての場合では、先頭に
識別用の``タグ''シンボルを伴うリストのフォームを取る
ハッシュテーブルオブジェクトを戻す。このパッケージのすべての
ハッシュ表関数は、両方のハッシュ表の型に作用できる; 通常は、どちらの
型が使われているかを知ることは決してないだろう。

この関数は、付加的なCommon Lispキーワード@code{:rehash-size}と
@code{:rehash-threshold}を受け入れるが、その値は無視する。
@end defun

@defun gethash key table &optional default
この関数は、@var{table}の中で@var{key}を調べる。もし、表のテスト関数に
従って、存在するキーのいずれかにマッチするという意味で、@var{key}が
表に存在する場合、関連づけられた値が戻される。そうでなければ、
@var{default}(または@code{nil})が戻される。

ハッシュ表に新しいデータを格納するためには、@code{gethash}への
呼び出しに@code{setf}を使う。@var{key}がすでに表に存在する場合、
対応する値は格納する値へ変更される。@var{key}がまだ存在しない場合、
新たなエントリが表へ加えられ、必要ならば表はより大きなサイズへ
再割り当てされる。@var{default}引数は許されるが、この場合は
無視される。この状況は、@code{get*}のそれと正確に同じである;
@pxref{属性リスト}.
@end defun

@defun remhash key table
この関数は、@var{table}から@var{key}のためのエントリを取り除く。
エントリが取り除かれた場合、@code{t}を戻す。@var{key}がテーブルに
現れない場合、何も行なわず@code{nil}を戻す。
@end defun

@defun clrhash table
この関数は、@var{table}からすべてのエントリを取り除き、空のハッシュ表
のままにしておく。
@end defun

@defun maphash function table
この関数は、@var{table}の各エントリに対して@var{function}を呼び出す。
それは@var{function}へ2つの引数、与えられたエントリのキーと値を渡す。
@var{function}の戻り値は無視される; @var{maphash}自身は@code{nil}を
戻す。ハッシュ表上で繰り返す代替の方法は、@xref{ループ機能}.
@end defun

@defun hash-table-count table
この関数は、@var{table}内のエントリ数を戻す。@strong{警告:} Lucid
Emacs 19のハッシュ表の現在の実装は、@code{remhash}がエントリを
取り除いたときに、格納された@code{count}を減らさない。従ってこの関数の
戻り値は、表で@code{remhash}を使い、かつ表のテストが@code{eq}の場合、
信頼できない。エントリを数えるためのより遅いけれども信頼できる方法は、
@code{(loop for x being the hash-keys of @var{table} count t)}である。
@end defun

@defun hash-table-p object
この関数は、@var{object}がハッシュ表の場合に@code{t}を、さもなければ
@code{nil}を戻す。これはハッシュ表の両方の型(Lucid Emacs組み込みの表と
特殊なリストで実装された表の両方)を認識する。
@end defun

ハッシュ表を扱うときには、使われる``ハッシュ関数''を正確に知ることが
有用である場合がある。このパッケージは、Emacs Lispの``obarray''を
使ってハッシュ表を実装する。``obarray''は、Emacs Lispがシンボルの
後をたどるために使うのと同じデータ構造である。それぞれのハッシュ表は、
埋め込まれたobarrayを含む。@code{gethash}へ与えられるキーの値は、
さまざまな手段で文字列へ変換され、それから@code{intern}や
@code{intern-soft}を使ってobarrayの中を調べられる。与えられたキー
文字列に対応するシンボルまたは``bucket''は、その@code{symbol-value}
として、その文字列へハッシュしたすべてのキーと値の対の連想リストを
含む。テスト関数によっては、多くのエントリを同じbucketへ
ハッシュすることも可能である。たとえばテストが@code{eql}の場合、
シンボル@code{foo}と2つの別々に組み立てられた文字列@code{"foo"}は、
同じbucketに3つのエントリを作るだろう。検索時間はbucket内で
線形なので、あまりに多くのものを同じハッシュに格納しないように準備する
場合に、ハッシュ表は最も効果的だろう。

下記のアルゴリズムが、Lispオブジェクトをハッシュ文字列へ変換するために
使われる:

@itemize @bullet
@item
文字列は、直接ハッシュ文字列として使われる(しかしテスト関数が
@code{equalp}の場合、文字列はまず@code{downcase}される)。

@item
シンボルは、その@code{symbol-name}にしたがってハッシュされる。

@item
整数は、その値を16で割った余りによって、16のbucketの1つに
ハッシュされる。浮動小数点数は、整数に切り捨てられて、16で割った
余りによってハッシュされる。

@item
コンスセルは、その@code{car}にしたがってハッシュされる; 空ではない
ベクタは、その第1要素にしたがってハッシュされる。

@item
すべての他のオブジェクトの型は、@code{"*"}と名付けられた1つのbucketへ
ハッシュする。
@end itemize

@noindent
したがって、たとえばハッシュ表の中の多くのバッファオブジェクトを
検索することは、1つのbucketを通した(なおかなり速い)線形時間の検索へ
帰するだろう。ところが、異なったシンボルを検索することは、各シンボルは
一般にはそれ自身のbucketへハッシュするので、とても速いだろう。

ハッシュテーブルの中のobarrayの大きさは、要素の数が増えるにつれて
自動的に調節される。

特別な場合として、0または1の@code{:size}引数を伴う
@code{make-hash-table}は、多くのリストのobarrayではなく、1つの
連想リストを使うハッシュ表オブジェクトを作る。とても小さい
表のためには、調査がキーから文字列への変換またはobarrayの中の調査を
必要としないので、この構造はより効率的である。しかしこのような表は、
検索をするためにはその大きさに比例する時間がかかることが保証される。

@iftex
@chapno=18
@end iftex

@node 構造体, アサーション, ハッシュ表, トップ
@chapter 構造体

@noindent
Common Lispの@dfn{構造体}メカニズムは、Cの@code{struct}型に類似する
データ型を定義する一般的な方法を提供する。構造体は、いくつかの数の
@dfn{スロット}を含むLispオブジェクトであり、スロットのそれぞれは任意の
Lispデータオブジェクトを保持できる。スロットのアクセスや設定、構造体
オブジェクトの作成やコピー、ある特定の構造体の型のオブジェクトを
認識する関数が提供される。

真のCommon Lispでは、それぞれの構造体型は、すべての存在するLisp型とは
別の新しい型である。下にあるEmacs Lispシステムは、新しい別の型を作る
方法を提供しないので、このパッケージは、識別するための特殊な``タグ''
シンボルを伴うベクタ(要求によってはリスト)として構造体を実装する。

@defspec defstruct name slots@dots{}
@code{defstruct}フォームは、@var{name}と呼ばれる、指定された
@var{slots}を持つ新しい構造体型を定義する(@var{slots}は構造体型を
記述する文字列で始まってもよい)。単純な場合、@var{name}や@var{slots}
のそれぞれはシンボルである。たとえば、

@example
(defstruct person name age sex)
@end example

@noindent
は、3つのスロットを含む、@code{person}と呼ばれる構造体型を定義する。
@code{person}オブジェクト@var{p}が与えられると、
@code{(person-name @var{p})}や@code{(person-age @var{p})}、
@code{(person-sex @var{p})}を呼ぶことでそれらのスロットに
アクセスできる。これらのすべてのplaceフォームで@code{setf}を
使うことで、これらのスロットを変更することもできる:

@example
(incf (person-age birthday-boy))
@end example

@code{make-person}を呼び出すことで、新しい@code{person}を
作ることができる。@code{make-person}は、新しいオブジェクトのスロットの
初期値を指定するために、キーワード引数@code{:name}と@code{:age}、
@code{:sex}を取る(これらの引数のいずれかを省略すると、Common Lisp
標準によれば、対応するスロットは``未定義''のままである; Emacs Lisp
では、このような初期化されていないスロットは@code{nil}で埋められる)。

@code{person}が与えられると、@code{(copy-person @var{p})}は、その
スロットが@var{p}のそれと@code{eq}である同じ型の新しいオブジェクトを
作る。

任意のLispオブジェクト@var{x}が与えられると、@code{(person-p @var{x})}
は@var{x}が@code{person}のように見える場合は真を、さもなければ偽を
戻す(再び、Common Lispではこの述語は正確だろう; Emacs Lispでできる
最善のことは、@var{x}が正しいタグシンボルで始まる正しい長さの
ベクタであることを確かめることである)。

@code{person-name}のようなアクセサは、通常は(実際に@code{person-p}を
使って)それらの引数をチェックし、引数が不正な型の場合はエラーを
通知する。このチェックは、@code{(optimize (safety @dots{}))}
宣言によって影響される。既定のSafetyレベル1は、すべての不正な引数を
見つける、いくぶん最適化されたチェックを使うが、無益な
エラーメッセージを使うかもしれない(たとえば、
``expected a @code{person}''ではなく``expected a vector''のように)。
Safetyレベル0は、下にある@code{aref}呼び出しによって提供されるものを
除いて、すべてのチェックを省略する; Safetyレベル2と3は、不正な入力に
対して常に記述的なエラーメッセージを印字する、厳しいチェックを行なう。
@xref{宣言}.

@example
(setq dave (make-person :name "Dave" :sex 'male))
     @result{} [cl-struct-person "Dave" nil male]
(setq other (copy-person dave))
     @result{} [cl-struct-person "Dave" nil male]
(eq dave other)
     @result{} nil
(eq (person-name dave) (person-name other))
     @result{} t
(person-p dave)
     @result{} t
(person-p [1 2 3 4])
     @result{} nil
(person-p "Bogus")
     @result{} nil
(person-p '[cl-struct-person counterfeit person object])
     @result{} t
@end example

一般に、@var{name}は名前のシンボルか、名前のシンボルの後に任意の数の
@dfn{構造体オプション}が続くリストである; それぞれの@var{slot}は、
スロットシンボルか、フォーム
@samp{(@var{slot-name} @var{default-value} @var{slot-options}@dots{})}
のリストである。@var{default-value}は、スロットの値を指定せずに
構造体型のインスタンスが作られるすべてのときに評価されるLisp
フォームである。

Common Lispは、いくつかのスロットオプションを定義しているが、
このパッケージで実装されている唯一のものは@code{:read-only}である。
このオプションに対する非@code{nil}の値は、そのスロットは@code{setf}
可能であってはならないということを意味する; スロットの値は、
オブジェクトが作られたときに決定され、その後は変わらない。

@example
(defstruct person
  (name nil :read-only t)
  age
  (sex 'unknown))
@end example

@code{:read-only}以外のすべてのスロットオプションは無視される。

不明瞭な歴史的な理由のため、構造体オプションはスロットオプションと
異なるフォームを取る。構造体オプションは、キーワードシンボルか、
キーワードシンボルで始まり、ことによると引数が続くリストである
(対称的に、スロットオプションはリストで囲まれないキーと値の対である)。

@example
(defstruct (person (:constructor create-person)
                   (:type list)
                   :named)
  name age sex)
@end example

下記の構造体オプションが認められる。

@table @code
@iftex
@itemmax=0 in
@advance@leftskip-.5@tableindent
@end iftex
@item :conc-name
引数は、その印字名がスロットアクセサ関数の名前のために接頭辞として
使われるシンボルである。既定は、構造体型の名前にハイフンが
続いたものである。オプション@code{(:conc-name p-)}は、この接頭辞を
@code{p-}に変える。引数として@code{nil}を指定することは接頭辞なしを
意味するので、スロット名自身がアクセサ関数を名付けるために使われる。

@item :constructor
単純な場合、このオプションは、コンストラクタ関数のために使われる代替の
名前である1つの引数を取る。既定は、たとえば@code{make-person}のように
@code{make-@var{name}}である。上記の例は、これを@code{create-person}に
変える。引数として@code{nil}を指定することは、標準の
コンストラクタはまったく生成されないことを意味する。

このオプションの完全なフォームでは、コンストラクタ名には任意の
引数リストが続く。Common Lisp引数リストのフォーマットの記述は、
@xref{プログラム構造}.  @code{&rest}や@code{&key}のようなすべての
オプションがサポートされる。引数名はスロット名とマッチすべきである;
それぞれのスロットは、対応する引数で初期化される。その名前が引数
リストに現れないスロットは、スロット記述子の@var{default-value}に
基づいて初期化される。また、既定を指定しない@code{&optional}と
@code{&key}引数は、スロット記述子からその既定を取る。スロット名に
対応しない引数を含むことは正しい; スロットに対応@emph{する}付加引数や
キーワード引数、@code{&aux}引数のための既定で参照される場合、それらは
有用である。

1つの構造体に、完全なフォーマットの@code{:constructor}
オプションをいくつでも指定できる。単純フォーマットの
@code{:constructor}オプションで無効にしない限り、既定の
コンストラクタも同様に生成される。

@example
(defstruct
 (person
  (:constructor nil)   ; no default constructor
  (:constructor new-person (name sex &optional (age 0)))
  (:constructor new-hound (&key (name "Rover")
                                (dog-years 0)
                           &aux (age (* 7 dog-years))
                                (sex 'canine))))
 name age sex)
@end example

ここでの第1のコンストラクタは、キーワードによってではなく、位置でその
引数を取る(公式なCommon Lispの用語では、キーワードの代わりに引数の順序
によって働くコンストラクタは、``BOAコンストラクタ''と呼ばれる。いや、
私がこれをでっちあげているのではない)。たとえば、
@code{(new-person "Jane" 'female)}は、そのスロットがそれぞれ
@code{"Jane"}と0、@code{female}であるpersonを生成する。

第2のコンストラクタは、2つのキーワード引数を取る。@code{:name}は、
@code{name}スロットを初期化し、@code{"Rover"}を既定とする。
@code{:dog-years}は、それ自身があるスロットに対応するのではないが、
@code{age}スロットを初期化するために使われる。@code{sex}スロットは、
強制的にシンボル@code{canine}になり、それを無効にする文法を持たない。

@item :copier
引数は、この方のコピー関数の代替名である。既定は@code{copy-@var{name}}
である。@code{nil}はコピー関数を生成しないことを意味する(この実装では、
すべてのコピー関数は、単に@code{copy-sequence}の同義語である)。

@item :predicate
引数は、この型のオブジェクトを認識する述語の代替名である。既定は
@code{@var{name}-p}である。@code{nil}は述語関数を生成しないことを意味
する(@code{:type}オプションが、@code{:named}オプションなしで使われる
場合、述語は決して生成されない)。

真のCommon Lispでは、@code{:predicate}が使われても、@code{typep}は常に
構造体オブジェクトを認識できる。このパッケージでは、@code{typep}は単に
@code{@var{typename}-p}と呼ばれる関数を探すので、既定の述語名を使う
場合だけ構造体型に対して動作するだろう。

@item :include
このオプションは、とても制限されたC++スタイルの継承の形式を実装する。
引数は、前もって@code{defstruct}で作られた別の構造体型の名前である。
その効果は、新しい構造体型が、含められた構造体型のすべてのスロット
(加えて、もちろんこの構造体のスロット記述子で記述されたすべての新しい
スロットも)を受け継ぐようにすることである。新しい構造体は、含められた
構造体の``特殊化''と考えられる。事実、含められた型の述語や
スロットアクセサは、新しい型のオブジェクトも受け入れる。

含められた構造体名の後に、@code{:include}オプションへ余分の引数がある
場合、これらのオプションは、含められた構造体のスロットのための、
ことによると修正された既定値を伴うスロット記述子の置き換えとして
扱われる。Steeleから例を借りると:

@example
(defstruct person name (age 0) sex)
     @result{} person
(defstruct (astronaut (:include person (age 45)))
  helmet-size
  (favorite-beverage 'tang))
     @result{} astronaut

(setq joe (make-person :name "Joe"))
     @result{} [cl-struct-person "Joe" 0 nil]
(setq buzz (make-astronaut :name "Buzz"))
     @result{} [cl-struct-astronaut "Buzz" 45 nil nil tang]

(list (person-p joe) (person-p buzz))
     @result{} (t t)
(list (astronaut-p joe) (astronaut-p buzz))
     @result{} (nil t)

(person-name buzz)
     @result{} "Buzz"
(astronaut-name joe)
     @result{} error: "astronaut-name accessing a non-astronaut"
@end example

したがって、@code{astronaut}が@code{person}の特殊化である場合、
すべての@code{astronaut}は@code{person}でもある(しかし逆は
真ではない)。すべての@code{astronaut}は、@code{person}のすべての
スロットを含み、加えてastronautに特有の特別なスロットを持つ。
(@code{person-name}のような) people上で働く作用は、ちょうど他のpeople
のようにastronaut上で働く。

@item :print-function
完全なCommon Lispでは、このオプションは、構造体型のインスタンスを
印字するために呼び出される関数を指定することを許す。Emacs Lisp
システムは、Lispプリンタ中にこのような機能を許すフックを
提供しないため、このパッケージは単に@code{:print-function}を無視する。

@item :type
引数は、シンボル@code{vector}または@code{list}
のどちらかでなければならない。これは、新しい構造体型を実装するために、
どちらの基礎となるLispデータ型が使われるべきかを語る。ベクタが既定で
使われるが、@code{(:type list)}は、その代わりに構造体オブジェクトが
リストとして格納されることを引き起こす。

構造体オブジェクト用にベクタ表現を使うことは、Emacs Lispではベクタを
作ることはやや遅いとはいえ、すべての構造体スロットが素早く
アクセスできるという有利な点を持つ。リストは作りやすいが、後の方の
スロットをアクセスするのに比較的長い時間がかかる。

@item :named
この引数を取らないオプションは、特有の``タグ''シンボルが構造体
オブジェクトの先頭に格納されることを引き起こす。@code{:type}を使い、
かつ@code{:named}を使わないことは、構造体型が識別機能を持たない単なる
ベクタまたはリストとして格納される結果になる。

@code{:type}を明示的に指定しない場合、既定は名前付きベクタを
使うことである。したがって、@code{:named}は@code{:type}との結合にのみ
有用である。

@example
(defstruct (person1) name age sex)
(defstruct (person2 (:type list) :named) name age sex)
(defstruct (person3 (:type list)) name age sex)

(setq p1 (make-person1))
     @result{} [cl-struct-person1 nil nil nil]
(setq p2 (make-person2))
     @result{} (person2 nil nil nil)
(setq p3 (make-person3))
     @result{} (nil nil nil)

(person1-p p1)
     @result{} t
(person2-p p2)
     @result{} t
(person3-p p3)
     @result{} error: function person3-p undefined
@end example

名前のない構造体はタグを持たないので、@code{defstruct}は、それを
認識するために有用な述語を作ることができない。
また、@code{person3-name}のようなアクセサは生成されるが、どんな型
チェックもできないだろう。たとえば@code{person3-name}関数は、この
場合は単に@code{car}の同義語である。対称的に、@code{person2-name}は
処理の前に、その引数が実際に@code{person2}オブジェクトであるかを
確かめることができる。

@item :initial-offset
引数は非負の整数でなければならない。それは、構造体の先頭で``空''
のままにしておくスロット数を指定する。構造体が名前付きの場合、タグが
リストまたはベクタの指定された位置に現れる; さもなければ、第1の
スロットがその位置に現れる。より早い位置は、コンストラクタによって
@code{nil}で満たされ、それ以外は無視される。型が他の型を
@code{:include}する場合、@code{:initial-offset}は、含まれる型の最後の
スロットと最初の新しいスロットの間のスキップされるスロット数を
指定する。
@end table
@end defspec

注記されている場合を除いて、このパッケージの@code{defstruct}機能は
Common Lispのそれと完全に互換である。

@iftex
@chapno=23
@end iftex

@node アサーション, 効率の配慮, 構造体, トップ
@chapter アサーションとエラー

@noindent
この節は@dfn{アサーション}、すなわちプログラムが正しく働いている場合に
真でなければならない条件をテストする2つのマクロを記述する。
アサーションは、Lispプログラムの振る舞いに決して何も追加しない;
すべてがそうあるべきであるように、単に``正気のチェック''
をするだけである。

最適化属性@code{speed}が3にセットされており、@code{safety}が3より
小さい場合、バイトコンパイラは、下記のアサーションを最適化し去る。
アサーションは最適化し去られるかもしれないので、それらが副作用を
含むことは悪い考えである。

@defspec assert test-form [show-args string args@dots{}]
このフォームは、@var{test-form}が真である(すなわち評価して非@code{nil}
値になる)ことを確かめる。そうである場合、@code{nil}を戻す。テストが
満足されない場合、@code{assert}はエラーを通知する。

@var{test-form}を含む既定のエラーメッセージが得られる。@var{string}
引数と付加的な余分の引数を含むことで、異なるエラーメッセージを
指定できる。これらの引数は、エラーを通知するために単に@code{error}へ
渡される。

付加的な第2の引数@var{show-args}が@code{nil}ではなく@code{t}である場合、
エラーメッセージは(@var{string}があってもなくても)、トップレベル
@var{form}のあらゆる非定数引数を含む。たとえば:

@example
(assert (> x 10) t "x is too small: %d")
@end example

この@var{show-args}の使用法は、Common Lispへの拡張である。真のCommon
Lispでは、第2引数は、エラーからの継続の前にユーザーによって@code{setf}
可能な@var{places}のリストを与える。Emacs Lispは継続可能なエラーを
サポートしないので、@var{places}を指定することは意味がない。
@end defspec

@defspec check-type form type [string]
このフォームは、@var{form}は評価して型@var{type}の値になるかを確かめる。
そうである場合、@code{nil}を戻す。そうでない場合、@code{check-type}は
@code{wrong-type-argument}エラーを通知する。既定のエラーメッセージは、
@var{type}と@var{form}自身に加えて、誤った値をリストする。@var{string}
が指定される場合、それはエラーメッセージの@var{type}の場所へ含められる。
たとえば:

@example
(check-type x (integer 1 *) "a positive integer")
@end example

@var{type}に使われてよい型指定子の記述は、@xref{データ型の述語}.

Common Lispでは、@code{check-type}への第1引数は@code{setf}での使用に
適切な@var{place}でなければならないことに注意せよ。なぜなら
@code{check-type}は、ユーザが@var{place}を修正することを許す継続可能な
エラーを通知するからである。
@end defspec

下記のエラー関連マクロも定義される:

@defspec ignore-errors forms@dots{}
これは、正確に@code{progn}のように@var{forms}を実行するが、@var{forms}
の間はエラーが無視される点が異なる。より正確には、エラーが通知された
場合、@code{ignore-errors}は直ちに@var{forms}の実行を中止して@code{nil}
を戻す。@var{forms}が正常に終了する場合、@code{ignore-errors}は最後の
@var{form}の結果を戻す。
@end defspec

@node 効率の配慮, Common Lispとの互換性, アサーション, トップ
@appendix 効率の配慮

@appendixsec マクロ

@noindent
@code{defun*}や@code{loop}、@code{setf}のようなこのパッケージの高度な
機能の多くは、Lispマクロとして実装されている。バイトコンパイルされた
コードでは、これらの複雑な表記法は単純で効率のよい同等のLispコードに
展開される。たとえば、フォーム

@example
(incf i n)
(push x (car p))
@end example

@noindent
は、コンパイル時に下記のLispフォームへ展開される:

@example
(setq i (+ i n))
(setcar p (cons x (car p)))
@end example

@noindent
これらは、Lispでそれぞれの作用を行なう最も効率的な方法である。
したがって、コンパイルされたコードの中では、より読みやすい@code{incf}
や@code{push}フォームを使うことに性能上の不利益はない。

他方、@emph{インタプリトされた}コードは、実行されるたびにこれらの
マクロを展開しなければならない。この理由により、マクロを猛烈に使う
コードはコンパイルされることが強く推奨される(このマニュアルで``関数''
ではなく``特殊フォーム''とラベルを付けられている機能はマクロである)。
@code{incf}を100回使うループは、コンパイルされた場合はかなり速く
実行し、マクロ展開が100回生成され、使用され、捨て去られる
必要がないので、ガベジコレクションもより少なくなるだろう。

@code{cl-prettyexpand}関数を使うことで、どのようにマクロが展開するかを
知ることができる。

@defun cl-prettyexpand form &optional full
この関数は、引数として1つのLispフォームを取り、現バッファ(字下げが
適正に働くようにLispモードでなければならない)にきちんと
フォーマットされたそのコピーを挿入する。フォーム中に現れるすべてのLisp
マクロも展開する。この関数を使う最も容易な方法は、@code{*scratch*}
バッファへ行き、たとえば以下をタイプして、

@example
(cl-prettyexpand '(loop for x below 10 collect x))
@end example

@noindent
閉じ括弧の直後で@kbd{C-x C-e}をタイプすることである; 展開

@example
(block nil
  (let* ((x 0)
         (G1004 nil))
    (while (< x 10)
      (setq G1004 (cons x G1004))
      (setq x (+ x 1)))
    (nreverse G1004)))
@end example

@noindent
がバッファへ挿入されるだろう(@code{block}マクロはインタプリタと
コンパイラで異なって展開されるので、@code{cl-prettyexpand}
はそれをそのままにしている。一時変数@code{G1004}は@code{gensym}
によって作られた)。

付加引数@var{full}が真の場合、@code{block}や@code{eval-when}、
コンパイラマクロを含む@emph{すべての}マクロが展開される。展開は、
@var{form}がコンパイルされるファイル中の
トップレベルフォームであるかのようになされる。たとえば、

@example
(cl-prettyexpand '(pushnew 'x list))
     @print{} (setq list (adjoin 'x list))
(cl-prettyexpand '(pushnew 'x list) t)
     @print{} (setq list (if (memq 'x list) list (cons 'x list)))
(cl-prettyexpand '(caddr (member* 'a list)) t)
     @print{} (car (cdr (cdr (memq 'a list))))
@end example

@code{adjoin}や@code{caddr}、@code{member*}はすべて、共通の
場合にそれらを最適化するための組み込みのコンパイラマクロを
持っていることに注意せよ。
@end defun

@ifinfo
@example

@end example
@end ifinfo
@appendixsec エラーチェック

@noindent
Common Lispへの追従は一般に、効率を犠牲にしていない。いくつかの例外が、
周辺的な非互換性を犠牲にして相当な利益が可能な場合になされた。一例は、
キーワード引数を走査するための@code{memq}(これは
バイトコンパイラによって非常に効率的に扱われる)の使用である; これは、
キーワードシンボルがキーワードとデータの値に同時に使われるようなまれな
場合に混乱する可能性がある。これが実用的なコードの中で
起こることはきわめてありそうになく、@code{memq}の使用は、キーワード
引数を伴う関数が@code{&optional}引数を使う関数とほとんど同じくらい
速いことを許す。

(Steeleの本で具体化された)Common Lisp標準は、従うプログラム中では
発生しないことになっている状況を示すために、句``その場合、それは
エラーである''を使う; 処理系は、これらの状況中でエラーを
通知することを、必須ではないが強く奨励される。
このパッケージはときどき、コンパクトさと効率の利益のために、このような
エラーチェックを省略する。たとえば、@code{do}変数指定子は、1つか2つ、
あるいは3つのフォームのリストということになっている; 余分の
フォームは、このパッケージでは文法エラーを通知するのではなく
無視される。@code{endp}関数は単に、このパッケージでは@code{null}の
同義語である。キーワード引数を取る関数は、奇数個の引数を受け入れ、
値@code{nil}がそれに続くかのように末尾のキーワードを扱う。

(@code{defun*}やその友人によって処理されるとき)引数リストは、今述べた
重要でない点を除いて、厳しくチェック@emph{される}; 特に、キーワード
引数は有効性をチェックされ、@code{&allow-other-keys}と
@code{:allow-other-keys}は完全に実装されている。キーワード有効性
チェックは、わずかに時間を消費する(しかしバイトコンパイルされた
コードではそれほど悪くはない); チェックを省略するために
@code{&allow-other-keys}を使える。@code{find}や@code{member*}
のようなこのパッケージで定義された関数は、そのキーワード引数の有効性
チェックを行なう。

@ifinfo
@example

@end example
@end ifinfo
@appendixsec 最適化コンパイラ

@noindent
Emacs 18に付属のバイトコンパイラは、ファイルのトップレベル位置
(すなわち、@code{defun}や他の囲むフォームの外)に現れるマクロの展開に
失敗する。これは、@code{defun*}や@code{eval-when}、@code{defstruct}
のようなトップレベルマクロを使うプログラムに、悲惨な
結果をもたらすだろう。この問題を回避するために、@dfn{CL}パッケージは、
トップレベルマクロを展開するようにEmacs 18のコンパイラに
パッチをあてる。あなた自身のマクロがトップレベルコンテキストで使われる
場合も、このパッチが適用されるだろう。このパッチは、すでに類似の
パッチが適用されたEmacs 18コンパイラの版に害を与えないし、
Jamie ZawinskiとHallvard Furusethによって書かれた最適化Emacs 19
コンパイラには影響しない。パッチはEmacsのメモリ中の
バイトコンパイラコードへ適用され、ディスク上の格納されている
@file{bytecomp.elc}ファイルへ適用されるのでは@emph{ない}。

(Emacs 18のための)Emacs 19コンパイラは、
@code{archive.cis.ohio-state.edu}のようなさまざまなEmacs Lisp
アーカイブサイトで利用できる。その使用は大いに推奨される; Common Lisp
マクロの多くは、最適化により改善される可能性があるコードを発する。
特に、@code{block}は(明示的であろうと、@code{defun*}や@code{loop}
のような構文要素中に暗黙であろうと)かなりの実行時の不利益を持つ;
最適化コンパイラは、ブロックの内部で@code{return}や@code{return-from}
によって実際に参照されない@code{block}を取り除く。

@node Common Lispとの互換性, 古いCLとの互換性, 効率の配慮, トップ
@appendix Common Lispとの互換性

@noindent
下記は、このパッケージとSteele(第2版)に文書化されたCommon Lispとの間の
すべての既知の非互換のリストである。

@code{member}や@code{assoc}、@code{floor}のようなある種の関数名は、
(非互換な)Emacs Lisp関数によってすでに取られていた; このパッケージは、
これらの関数のCommon Lisp版の名前に@samp{*}を付加する。

語@code{defun*}は、拡張されたCommon Lisp引数リストを関数で使うために、
@code{defun}の代わりに必要である。同様に、@code{defmacro*}と
@code{function*}は、これらのフォームの完全な機能の引数リストを理解する
版である。@code{&whole}キーワードは、@code{defmacro}引数リストでは
(再帰的引数リストの中を例外として)動作しない。

効率的な実装を許すために、キーワード引数は、キーワードシンボルが他の
キーワード引数の@emph{値}として渡された場合に混乱するかもしれない、
わずかに下等な構文解析器を使う(つまり、
@code{(memq :@var{keyword} @var{rest-of-arguments})}が、与えられた
キーワード引数の中を@code{:@var{keyword}}を見つけようと走査するために
使われる)。

@code{eql}と@code{equal}述語は、IEEE浮動小数点の正の0と負の0を
区別しない。@code{equalp}述語は、Common Lispといくつかの相違がある;
@pxref{述語}.

@code{setf}メカニズムは完全に互換だが、setf-methodは5つの値を
直接戻すのではなく、5つの値のリストを戻す点が異なる。また、
(@code{(defun (setf foo) @dots{})}が典型的であるような)新しい
``@code{setf}関数''の概念は実装されていない。

@code{do-all-symbols}フォームは、@var{obarray}引数がない
@code{do-symbols}と同じである。Common Lispでは、このフォームはすべての
パッケージ中のすべてのシンボルの上で繰り返す。Emacsのobarrayは、
ファーストクラスのパッケージメカニズムではないので、
@code{do-all-symbols}が既定のobarray以外を確認する方法はない。

@code{loop}マクロは、@code{loop-finish}と型指定子が実装されていない
点を除いて完全である。

多値戻し機能はリストを多値として扱うが、それはEmacs Lispは多重戻り値を
直接サポートしないためである。@code{values}または@code{values-list}が、
@code{multiple-value-bind}や他の多値受け取り側へ戻るために常に使われる
場合、マクロはCommon Lispと互換だろう; @code{values}が
@code{multiple-value-@dots{}}なしで使われたり、
@code{multiple-value-@dots{}}が@code{values}なしで使われたりする場合、
効果はCommon Lispとは異なるだろう。

多くのCommon Lisp宣言は無視され、その他は概念としてはCommon Lisp標準に
マッチするが、詳細はマッチしない。たとえば局所@code{special}宣言は、
Emacs Lispでは純粋に助言だが、Steeleの本に規定されたスコープ規則に
厳密には従わない。

変数@code{*gensym-counter*}は、0ではなく疑似乱数値で開始する。これは、
生成されたシンボルは、ファイルへ書かれ、ファイルからロードされたときに
internされるという事実をうまく処理できる。

@code{defstruct}機能は互換だが、構造体は、ある特殊な別の型ではなく、
既定では@code{:type vector :named}の型である点が異なる。
また、@code{:type}スロットオプションは無視される。

@code{check-type}の第2引数は異なる扱いをされる。

@node 古いCLとの互換性, Common Lispの移植, Common Lispとの互換性, トップ
@appendix 古いCLとの互換性

@noindent
下記は、このパッケージとより古いQuirozの@file{cl.el}パッケージとの間の
すべての既知の非互換のリストである。

このパッケージの関数の多重戻り値のエミュレーションは、より古い
パッケージのそれと非互換である。あのパッケージは、真のCommon Lisp
多重戻り値にできる限り近付くように試みた; 不幸にも、それは100%
信頼できるものではなく、自由に使われた場合に時おり
意外なことになりがちだった。このパッケージは、よりシンプルな方法を
使う。すなわち、値のリストで多値を置き換える。それは、著しくCommon
Lispとは相違するが、より予測可能である。

@code{defkeyword}フォームと@code{keywordp}関数は、このパッケージでは
実装されていない。

@code{member}や@code{floor}、@code{ceiling}、@code{truncate}、
@code{round}、@code{mod}、@code{rem}関数は、Emacs 18またはEmacs 19に
存在する関数との衝突を避けるために、このパッケージでは接尾辞@samp{*}が
付けられる。より古いパッケージは、単にこれらの関数を再定義し、
組み込みの意味を上書きして、Emacs 19で重大な可搬性の問題を引き
起こした(いくつかのより最近のQuirozパッケージの版は、それらの名前を
@code{cl-member}その他へ変えた; このパッケージは、@code{member*}
その他への別名として後者の名前を定義する)。

古いパッケージのバグがあるかCommon Lisp標準と一致しないある種の
関数は、このパッケージの準拠している版と非互換である。たとえば、
@code{eql}や@code{member}は、あのパッケージでは@code{eq}や@code{memq}
の同義語であったり、@code{setf}はその引数の評価の正しい順序を
保存できなかったり、など。

最後に、より古いパッケージとは異なり、このパッケージは注意深く、
内部名のすべてに接頭辞@code{cl-}を付けている。(@code{floatp-safe}や
@code{letf}のような)追加の機能として明示的に定義されているいくつかの
関数を除いて、このパッケージは、Common Lispの一部ではない、どんな
非@samp{cl-}シンボルも移出しない。

@ifinfo
@example

@end example
@end ifinfo
@appendixsec @code{cl-compat}パッケージ

@noindent
@dfn{CL}パッケージは、互換パッケージ@code{cl-compat}のフォームの中に、
古い@file{cl.el}のいくつかの機能のエミュレーションを含む。それを
使うためには、あなたのプログラムの中に@code{(require 'cl-compat)}を
置くこと。

古いパッケージは、@code{cl-}接頭辞や他の表記法なしで、かなりの数の内部
ルーチンを定義していた。これらのルーチンへの呼び出しが、既存のLisp
コードに入り込んでしまっているかもしれない。@code{cl-compat}は、下記の
内部ルーチンのエミュレーションを提供する: @code{pair-with-newsyms}、
@code{zip-lists}、@code{unzip-lists}、@code{reassemble-arglists}、
@code{duplicate-symbols-p}、@code{safe-idiv}.

いくつかの@code{setf}フォームは、ユーザコードが直接呼び出す
かもしれない内部関数への呼び出しへ翻訳された。関数@code{setnth}や
@code{setnthcdr}、@code{setelt}がこのカテゴリに入る; それらは
@code{cl-compat}で定義されるが、最良の修正は@code{setf}を適正に
使うように変えることである。

@code{cl-compat}ファイルは、キーワード関数@code{keywordp}や
@code{keyword-of}、@code{defkeyword}を定義する。データとしての
キーワードの使用には反対なので、それらは新しい@dfn{CL}
パッケージによっては定義されない。

キーワード引数構文解析用の@code{build-klist}メカニズムは、
@code{cl-compat}でエミュレートされている; しかし
@code{with-keyword-args}はエミュレートされておらず、どんな場合でも、
@code{defun*}によって提供されるより自然なキーワード引数処理を
使うように変えるのが最良である。

多重戻り値は、2つのCommon Lispパッケージで異なって扱われる。古い
パッケージの方法は、真のCommon Lispにより互換だったが、ある場合には
偽の多重戻り値を報告することを引き起こす発見的方法を使った。
@code{cl-compat}パッケージは、古いCLパッケージと互換の多重値マクロの
集合を定義する; 再び、それらは本質的に発見的であるが、古いパッケージの
マクロが動作するところならどこでも動作することが保証される。``公式の''
多重値機能との名前の衝突を避けるため、@code{cl-compat}のそれは
大文字で始まる名前を持つ: @code{Values}、@code{Values-list}、
@code{Multiple-value-bind}など。

関数@code{cl-floor}や@code{cl-ceiling}、@code{cl-truncate}、
@code{cl-round}は、古いスタイルの多値メカニズムを使うために、ちょうど
それらが古いパッケージでしたのと同じように@code{cl-compat}で定義される。
より新しい@code{floor*}や友人は、多値としてではなくリスト中にその2つの
結果を戻す。古いパッケージの古い版は、ありのままの名前@code{floor}や
@code{ceiling}その他を使ったことに注意せよ; それらはEmacs 19の組み込み
のものと衝突するので、@code{cl-compat}はそれらの名前を使えない。

@node Common Lispの移植, 関数索引, 古いCLとの互換性, トップ
@appendix Common Lispの移植

@noindent
このパッケージは、Emacs Lispへの拡張として使われることを意図されており、
真のCommon LispのEmacs実装としては意図されていない。Emacs LispとCommon
Lispの間の残りの相違のいくつかは、大きなCommon Lispアプリケーションを
Emacsへ移植することを難しくしている。一例として、このパッケージの機能
のいくつかは、ANSIまたはSteeleに完全には従っていない;
@pxref{Common Lispとの互換性}. しかし、このパッケージがまったく
提供しない機能もかなり多くある。ここには、Common LispコードをEmacsに
持ってくるときに警戒したくなる、いくつかの主要な省略がある。

@itemize @bullet
@item
大文字小文字の区別がないこと。Common Lispのシンボルは、既定では
大文字小文字の区別がない。いくつかのプログラムは、ある関数または
変数をある場所では@code{foo}として、別の場所では@code{Foo}または
@code{FOO}として参照する。Emacs Lispはそれれを3つの別のシンボルとして
扱う。

いくつかのCommon Lispコードは、完全に大文字で書かれている。一方Emacsは、
プログラム自身の関数や変数にこの規約を喜んで使わせるので、@code{if}や
@code{defun}のようなLisp組み込みへの呼び出しは、小文字に
変えなければならなくなるだろう。

@item
レキシカルスコープ。Common Lispでは、関数引数や@code{let}の束縛は、
物理的にその本体内(またはその本体のマクロ展開内)での参照にだけ
適用する。Emacs Lispでは対照的に、本体から呼び出された関数の内側でさえ
変数への束縛が見える@dfn{動的スコープ}を使う。

Common Lispの変数は、@code{special}と宣言するか@code{defvar}を
使うことで動的スコープにすることができる。Emacs Lispでは、すべての
変数が@code{special}と宣言されているようなものである。

しばしば、動的スコープLispの中でさえレキシカルスコープのために書かれた
コードを使うことができるが、常にというわけではない。これは、Emacs Lisp
では失敗するCommon Lispコード断片の例である:

@example
(defun map-odd-elements (func list)
  (loop for x in list
        for flag = t then (not flag)
        collect (if flag x (funcall func x))))

(defun add-odd-elements (list x)
  (map-odd-elements (function (lambda (a) (+ a x))) list))
@end example

@noindent
Common Lispでは、2つの関数の@code{x}の使用法は完全に独立している。
Emacs Lispでは、@code{add-odd-elements}によって作られた@code{x}への
束縛は、@code{(+ a x)}関数が呼び出される間は@code{map-odd-elements}の
束縛で隠されるだろう。

(このパッケージは、自身のマッピング関数の中で内部的に@code{x}ではなく
@code{cl-x}のような名前を使うことで、このような問題を避ける; あなた
自身の変数のために@code{cl-}接頭辞を使わない限り、衝突は起こらない)

Common Lispスタイルのレキシカルな束縛を確立する@code{lexical-let}
フォームの記述と、Emacs正規の@code{let}とどのように
異なるかのいくつかの例は、@xref{レキシカルな束縛}.

@item
リーダマクロ。Common Lispは、個々の文字のレベルで働く第2のマクロの型を
含む。たとえば、Common Lispは@code{'}と呼ばれるリーダマクロによって
引用符表記法を実装するが、Emacs Lispの構文解析器は、単に引用符を特殊な
場合として扱う。いくつかのLispパッケージは、自身用の特殊文法を
作るためにリーダマクロを使うが、それをEmacs構文解析器は読めない。

ついでに言えば、リーダマクロの欠如は、Emacs Lispの普通ではない
バッククォート文法の背後にある理由である。バッククォートはLisp
パッケージとして実装されており、Emacs構文解析器に組み
込みではないので、標準の関数/マクロ呼び出し表記法と共に使われる、
@code{`}と名付けられた正規のマクロを使うように強いられる。

@item
その他の文法機能。Common Lispは、Emacs Lisp構文解析器が理解できない、
@code{#}で始まるかなりの数の表記法を提供する。たとえば、
@samp{#| ... |#}は代替の注釈表記法であり、@samp{#+lucid (foo)}は、
Lucid Common Lisp内を除いて@code{(foo)}を無視するように構文解析器に
言う。

@item
パッケージ。Common Lispでは、シンボルは@dfn{パッケージ}に分けられる。
Lisp組み込みのシンボルは、典型的には1つのパッケージに格納される;
ベンダ拡張のシンボルは別のパッケージに置かれ、それぞれの
アプリケーションプログラムは、それ自身のシンボルのためのパッケージを
持つかもしれない。あるシンボルはパッケージによって``移出''され、他の
シンボルは内部的である; あるパッケージは、他のパッケージの移出された
シンボルを``使用''または移入する。この移入と移出のために通常は
見えないかもしれないシンボルをアクセスするために、Common Lispは、
@code{package:symbol}または@code{package::symbol}のような文法を
提供する。

Emacs Lispは、すべてのinternされたシンボルに1つの名前空間を持ち、
名前の先頭に@code{cl-}のような接頭辞を置くという命名規約を使う。
いくつかのEmacsパッケージは、接頭辞として@code{cl:}や@code{cl::}を使う
Common Lispに似た規約を採用する。しかし、Emacs構文解析器はコロンを
理解せず、単にそれらをシンボル名の一部として扱う。したがって、
@code{mapcar}と@code{lisp:mapcar}はCommon Lispでは同じシンボルを
参照するかもしれないが、Emacs Lispではそれらは完全に別のものである。
あるシンボルを、時には正式な名前で参照し、別の時には短い名前で参照する
Common Lispプログラムは、Emacsにはきれいに移植できないだろう。

Emacs Lispは``obarray''の概念を持っており、それはパッケージに似た
シンボルの集積だが、この機能は真のパッケージメカニズムとして使えるほど
十分に強力ではない。

@item
@code{format}関数は、Common LispとEmacs Lispの間でまったく違っている。
フォーマット文字列の前に、追加の``宛先''引数をとる。@code{nil}の宛先は、
Emacs Lispのように文字列をフォーマットすることを意味する; @code{t}の
宛先は、(Emacsの@code{message}のように)ターミナルへ書くことを
意味する。また、フォーマット制御文字列は完全に異なる;
フォーマットコードを導入するために、@code{%}の代わりに@code{~}を使い、
利用できるコードの集合はずっと豊富である。文字列リテラルの@code{\n}
のような表記法はない; その代わりに、@code{format}は``改行''
フォーマットコードである@code{~%}とともに使われる。より高度な
フォーマットコードは、パラグラフ詰め込み、大文字小文字変換、そして
ループや条件付き実行のような機能さえ提供する。

このパッケージで、Common Lispの@code{format}の大部分を実装することは
可能だったかもしれないとしても(もちろん@code{format*}の名のもとに)、
時間と労力をかけるだけの値打ちがないように思われた。@code{format*}
のかなりのサブセットを実装するためですら、巨大なコード量が
必要だっただろうし、さらに、Emacs Lispの@code{format}を越えて提供する
機能はめったに有用ではないだろう。

@item
ベクタ定数は、Emacs Lispでは角括弧を使うが、Common Lispでは
@code{#(a b c)}記法を使う。さらに問題を複雑にすることには、Emacs 19は、
何か完全に違うこと---属性を持つ文字列のために、それ自身の@code{#(}
表記法を導入する。

@item
Common Lispでは、文字と整数は別である。文字定数の表記法も異なる:
@code{?A}の代わりに@code{#\A}である。また、@code{string=}と
@code{string-equal}はEmacs Lispでは同義語だが、Common Lispでは後者は
大文字小文字を区別しない。

@item
データ型。いくつかのCommon Lispデータ型は、Emacs Lispには存在しない。
有理数と複素数はなく、大きな整数もない(すべての整数は``fixnum''である)。
すべての配列は1次元である。リードテーブルやパス名はない; ストリームは、
それら自身が新しいデータ型ではなく、存在するデータ型の集合である。
ハッシュ表やランダムステート、構造体、パッケージ(obarray)は別の
型ではなく、Lispベクタやリストから造られる。

@item
Common Lisp Object System(CLOS)とCommon Lispコンディションシステムは実
装されていない。しかし、@uref{ftp://ftp.ultranet.com/pub/zappo}のEIEIO
パッケージは、いくつかのCLOS機能を実装する。

@item
異なる名前のEmacs Lisp機能と完全に重複するCommon Lisp機能は、一般に
実装されていない。たとえば、Emacs Lispが@code{defconst}を
使うところで、Common Lispは@code{defconstant}を使う。同様に、
@code{make-list}は2つのLispで異なった方法でその引数をとるが、正確に
同じことをするので、このパッケージはCommon Lispスタイルの
@code{make-list}をわざわざ実装しなかった。

@item
このパッケージに含まれていない、より注意が必要ないくつかのCommon Lisp
機能は: @code{compiler-let}、@code{tagbody}、@code{prog}、
@code{ldb/dpb}、@code{parse-integer}、@code{cerror}。

@item
再帰。再帰は、Emacs LispでちょうどCommon Lispと同じように動作するが、
さまざまなEmacs Lispシステムやコンパイラの詳細が、再帰を多くのLisp
よりも非効率的にしている。ある流派は、他のテクニックよりもLispで再帰を
使うことを好む; 彼らは、以下のようなものを使って数のリストを
合計するかもしれない:

@example
(defun sum-list (list)
  (if list
      (+ (car list) (sum-list (cdr list)))
    0))
@end example

@noindent
そこでは、より繰り返し的に考えるプログラマは以下のフォームの1つを
書くかもしれない:

@example
(let ((total 0)) (dolist (x my-list) (incf total x)) total)
(loop for x in my-list sum x)
@end example

これは、多くのCommon Lispではおもにスタイル上の選択だろうが、
Emacs Lispでは、繰り返しフォームは再帰よりもかなり速いことを
知っておくべきである。またLispプログラマは、現在のEmacs Lisp
コンパイラは末尾再帰を最適化しないことを注記したいだろう。
@end itemize

@node 関数索引, 変数索引, Common Lispの移植, トップ
@unnumbered 関数索引

@printindex fn

@node 変数索引, , 関数索引, トップ
@unnumbered 変数索引

@printindex vr

@contents
@bye
