\input texinfo      @c -*-texinfo-*-
@c Copyright 1988-1999
@c Free Software Foundation, Inc.
@c
@c %**start of header 
@c makeinfo ignores cmds prev to setfilename, so its arg cannot make use
@c of @set vars.  However, you can override filename with makeinfo -o.
@setfilename gdb-ja.info
@c
@include gdb-cfg.texi
@c
@ifset GENERIC
@settitle Debugging with @value{GDBN}
@end ifset
@ifclear GENERIC
@settitle Debugging with @value{GDBN} (@value{TARGET})
@end ifclear
@setchapternewpage odd
@c %**end of header

@iftex
@c @smallbook
@c @cropmarks
@end iftex

@finalout
@syncodeindex ky cp

@c readline appendices use @vindex
@syncodeindex vr cp

@c !!set GDB manual's edition---not the same as GDB version!
@set EDITION Seventh

@c !!set GDB manual's revision date
@set DATE February 1999

@c THIS MANUAL REQUIRES TEXINFO-2 macros and info-makers to format properly.

@ifinfo
@c This is a dir.info fragment to support semi-automated addition of
@c manuals to an info tree.  zoo@cygnus.com is developing this facility.
@format
START-INFO-DIR-ENTRY
* Gdb: (gdb).                     The @sc{gnu} debugger.
END-INFO-DIR-ENTRY
@end format
@end ifinfo
@c
@c
@ifinfo
This file documents the @sc{gnu} debugger @value{GDBN}.


This is the @value{EDITION} Edition, @value{DATE}, 
of @cite{Debugging with @value{GDBN}: the @sc{gnu} Source-Level Debugger}
for @value{GDBN} Version @value{GDBVN}.

Copyright (C) 1988-1999 Free Software Foundation, Inc.

Permission is granted to make and distribute verbatim copies of
this manual provided the copyright notice and this permission notice
are preserved on all copies.

@ignore
Permission is granted to process this file through TeX and print the
results, provided the printed document carries copying permission
notice identical to this one except for the removal of this paragraph
(this paragraph not being relevant to the printed manual).

@end ignore
Permission is granted to copy and distribute modified versions of this
manual under the conditions for verbatim copying, provided also that the
entire resulting derived work is distributed under the terms of a
permission notice identical to this one.

Permission is granted to copy and distribute translations of this manual
into another language, under the above conditions for modified versions.
@end ifinfo

@ignore
Japanese translation by Kazuhisa Ichikawa
Japanese Texinfo version by IIDA, Yosiaki

(Please send your comments on this Japanese version to ki@home.email.ne.jp)
@end ignore

@titlepage
@title Debugging with @value{GDBN}
@subtitle The @sc{gnu} Source-Level Debugger
@ifclear GENERIC
@subtitle (@value{TARGET})
@end ifclear
@sp 1
@ifclear HPPA
@subtitle @value{EDITION} Edition, for @value{GDBN} version @value{GDBVN}
@subtitle @value{DATE}
@author Richard M. Stallman and Roland H. Pesch
@end ifclear
@ifset HPPA
@subtitle Edition @value{EDITION}, for @value{HPVER} (based on @value{GDBN} @value{GDBVN})
@subtitle @value{DATE}
@author Richard M. Stallman and Roland H. Pesch (modified by HP)
@end ifset
@page
@ifclear HPPA
@tex
{\parskip=0pt
\hfill (Send bugs and comments on @value{GDBN} to bug-gdb\@prep.ai.mit.edu.)\par
\hfill {\it Debugging with @value{GDBN}}\par
\hfill \TeX{}info \texinfoversion\par
}
@end tex
@end ifclear
@ifset HPPA
@tex
{\parskip=0pt
\hfill {\it Debugging with @value{GDBN}}\par
\hfill \TeX{}info \texinfoversion\par
}
@end tex
@end ifset

@vskip 0pt plus 1filll
Copyright @copyright{} 1988-1999 Free Software Foundation, Inc. 
@sp 2
@ifclear HPPA
Published by the Free Software Foundation @*
59 Temple Place - Suite 330, @*
Boston, MA 02111-1307 USA @*
Printed copies are available for $20 each. @*
ISBN 1-882114-11-6 @*
@end ifclear
                
Permission is granted to make and distribute verbatim copies of
this manual provided the copyright notice and this permission notice
are preserved on all copies.

Permission is granted to copy and distribute modified versions of this
manual under the conditions for verbatim copying, provided also that the
entire resulting derived work is distributed under the terms of a
permission notice identical to this one.

Permission is granted to copy and distribute translations of this manual
into another language, under the above conditions for modified versions.
@end titlepage
@page

@ifnottex
@node Top, Summary, (dir), (dir)
@top Debugging with @value{GDBN}

このファイルには、
@sc{gnu}のシンボリック・デバッガである@value{GDBN}のことが
説明してあります。

@value{EDITION}版、@value{DATE}、@value{GDBN}バージョン@value{GDBVN}

Copyright (C) 1988-1999 Free Software Foundation, Inc.
@menu
* Summary::                     @value{GDBN}の要約
@ifclear BARETARGET
* Sample Session::              @value{GDBN}セッションのサンプル
@end ifclear

* Invocation::                  @value{GDBN}の起動・終了
* Commands::                    @value{GDBN}コマンド
* Running::                     @value{GDBN}配下でのプログラムの実行
* Stopping::                    停止と継続
* Stack::                       スタックの検査
* Source::                      ソース・ファイルの検査
* Data::                        データの検査
@ifclear CONLY
* Languages::                   異なる言語の使用
@end ifclear

@ifset CONLY
* C::                           C言語サポート
@end ifset

* Symbols::                     シンボル・テーブルの検査
* Altering::                    実行の変更
* GDB Files::                   @value{GDBN}ファイル
* Targets::                     デバッグ・ターゲットの指定
* Controlling GDB::             @value{GDBN}の制御
* Sequences::                   一連のコマンドのグループ化
@ifclear DOSHOST
* Emacs::                       @sc{gnu} Emacsの中での@value{GDBN}の使用
@end ifclear

* GDB Bugs::                    @value{GDBN}のバグ報告

@ifclear PRECONFIGURED
@ifclear HPPA
* Formatting Documentation::    @value{GDBN}ドキュメントのフォーマットと印刷
@end ifclear

@end ifclear

* Command Line Editing::        コマンドライン編集
* Using History Interactively:: ヒストリの対話的な使用
* Installing GDB::              GDBのインストール
* Index::                       インデックス

 --- The Detailed Node Listing ---

@value{GDBN}の要約

* Free Software::               フリー・ソフトウェア
* Contributors::                GDBに貢献した人々

@value{GDBN}の起動・終了

* Invoking GDB::                @value{GDBN}の起動
* Quitting GDB::                @value{GDBN}の終了
* Shell Commands::              @value{GDBN}の中でのシェル・コマンドの使用

@value{GDBN}の起動

* File Options::                ファイルの選択
* Mode Options::                モードの選択

@value{GDBN}コマンド

* Command Syntax::              @value{GDBN}に対するコマンドの指定
* Completion::                  コマンド名の補完
* Help::                        ヘルプの表示

@value{GDBN}配下でのプログラムの実行

* Compilation::                 デバッグのためのコンパイル
* Starting::                    ユーザ・プログラムの起動
@ifclear BARETARGET
* Arguments::                   ユーザ・プログラムの引数
* Environment::                 ユーザ・プログラムの環境
@end ifclear

* Working Directory::           ユーザ・プログラムの作業ディレクトリ
* Input/Output::                ユーザ・プログラムの入出力
* Attach::                      既に実行中のプロセスのデバッグ
* Kill Process::                子プロセスの終了
@ifclear HPPA
* Process Information::         追加のプロセス情報
@end ifclear

* Threads::                     マルチスレッド・プログラムのデバッグ
* Processes::                   マルチプロセス・プログラムのデバッグ

停止と継続

* Breakpoints::                 ブレイクポイント、ウォッチポイント、キャッチポイント
* Continuing and Stepping::     実行の再開
@ifset POSIX
* Signals::                     シグナル
@end ifset
@ifclear BARETARGET
* Thread Stops::                マルチスレッド・プログラムの停止と起動
@end ifclear

ブレイクポイント、ウォッチポイント、キャッチポイント

* Set Breaks::                  ブレイクポイントの設定
* Set Watchpoints::             ウォッチポイントの設定
* Set Catchpoints::             キャッチポイントの設定
* Delete Breaks::               ブレイクポイントの削除
* Disabling::                   ブレイクポイントの無効化
* Conditions::                  ブレイクポイントの成立条件
* Break Commands::              ブレイクポイント・コマンド・リスト
@ifclear CONLY
* Breakpoint Menus::            ブレイクポイント・メニュー
@end ifclear

スタックの検査

* Frames::                      スタック・フレーム
* Backtrace::                   バックトレース
* Selection::                   フレームの選択
* Frame Info::                  フレームに関する情報
* Alpha/MIPS Stack::            Alpha/MIPSマシンの関数スタック

ソース・ファイルの検査

* List::                        ソース行の表示
@ifclear DOSHOST
* Search::                      ソース・ファイル内の検索
@end ifclear
* Source Path::                 ソース・ディレクトリの指定
* Machine Code::                ソースとマシン・コード

データの検査

* Expressions::                 式
* Variables::                   プログラム変数
* Arrays::                      人工配列
* Output Formats::              出力フォーマット
* Memory::                      メモリの調査
* Auto Display::                自動表示
* Print Settings::              表示設定
* Value History::               値ヒストリ
* Convenience Vars::            コンビニエンス変数
* Registers::                   レジスタ
@ifclear HAVE-FLOAT
* Floating Point Hardware::     浮動小数ハードウェア
@end ifclear

異なる言語の使用

* Setting::                     ソース言語の切り替え
* Show::                        言語の表示
@ifset MOD2
* Checks::                      型と範囲のチェック
@end ifset

* Support::                     サポートされる言語

ソース言語の切り替え

* Filenames::                   ファイル拡張子と言語
* Manually::                    手作業による作業言語の設定
* Automatically::               @value{GDBN}による作業言語の推定

@ifset MOD2
型と範囲のチェック

* Type Checking::               型チェックの概要
* Range Checking::              範囲チェックの概要
@end ifset

サポートされる言語

@ifset MOD2
* C::                           C/C++

C言語サポート

* C Operators::                 C演算子

C言語サポート
@end ifset

* C Operators::                 C/C++演算子
* C Constants::                 C/C++定数
* Cplus expressions::           C++式
* C Defaults::                  C/C++のデフォルト設定
@ifset MOD2
* C Checks::                    C/C++の型チェックと範囲チェック
@end ifset
* Debugging C::                 @value{GDBN}とC
* Debugging C plus plus::       C++用の@value{GDBN}機能

@ifset MOD2
Modula-2

* M2 Operators::                組み込み演算子
* Built-In Func/Proc::          組み込み関数と組み込みプロシージャ
* M2 Constants::                Modula-2定数
* M2 Defaults::                 Modula-2デフォルト設定
* Deviations::                  標準Modula-2との差異
* M2 Checks::                   Modula-2の型チェックと範囲チェック
* M2 Scope::                    スコープ演算子@code{::}と@code{.}
* GDB/M2::                      @value{GDBN}とModula-2
@end ifset

実行の変更

* Assignment::                  変数への代入
* Jumping::                     異なるアドレスにおける処理継続
@ifclear BARETARGET
* Signaling::                   ユーザ・プログラムへのシグナルの通知
@end ifclear
* Returning::                   関数からの復帰
* Calling::                     ユーザ・プログラム関数の呼び出し
* Patching::                    ユーザ・プログラムへのパッチ適用

@value{GDBN}ファイル

* Files::                       ファイルを指定するコマンド
* Symbol Errors::               シンボル・ファイル読み込み時のエラー

デバッグ・ターゲットの指定

* Active Targets::              アクティブ・ターゲット
* Target Commands::             ターゲットを管理するコマンド
@ifclear HPPA
* Byte Order::                  ターゲットのバイト・オーダの選択
* Remote::                      リモート・デバッグ

リモート・デバッグ
@end ifclear

@ifset REMOTESTUB
* Remote Serial::               @value{GDBN}リモート・シリアル・プロトコル
@end ifset

@ifset I960
* i960-Nindy Remote::		@value{GDBN}とリモートi960（Nindy）
@end ifset

@ifset AMD29K
* UDI29K Remote::               AMD29K用のUDIプロトコル
* EB29K Remote::		AMD29K用のEBMONプロトコル
@end ifset

@ifset VXWORKS
* VxWorks Remote::		@value{GDBN}とVxWorks
@end ifset

@ifset ST2000
* ST2000 Remote::               @value{GDBN}とTandem ST2000
@end ifset

@ifset H8
* Hitachi Remote::              @value{GDBN}と日立のマイクロ・プロセッサ
@end ifset

@ifset MIPS
* MIPS Remote::			@value{GDBN}とMIPSボード
@end ifset

@ifset SIMS
* Simulator::                   シミュレートされたCPUターゲット
@end ifset

@value{GDBN}の制御

* Prompt::                      プロンプト
* Editing::                     コマンド編集
* History::                     コマンド・ヒストリ
* Screen Size::                 画面サイズ
* Numbers::                     数値
* Messages/Warnings::           オプションの警告およびメッセージ

一連のコマンドのグループ化

* Define::                      ユーザ定義コマンド
* Hooks::                       ユーザ定義コマンド・フック
* Command Files::               コマンド・ファイル
* Output::                      制御された出力を得るためのコマンド

@value{GDBN}のバグ報告

* Bug Criteria::                本当にバグを見つけたのかどうかを知る方法
* Bug Reporting::               バグの報告方法

@value{GDBN}のインストール

* Separate Objdir::             異なるディレクトリでの@value{GDBN}のコンパイル
* Config Names::                ホストとターゲットの名前の指定
* Configure Options::           configureオプションの要約
@end menu

@end ifnottex

@node Summary, Sample Session, Top, Top
@unnumbered @value{GDBN}の要約

@value{GDBN}のようなデバッガの目的は、
実行中のプログラムの内部において何が起こっているのか、
あるいは、
プログラムがクラッシュしたときに何をしていたのかを知ることができるようにすることにあります。

@value{GDBN}は、
実際のバグを発見できるようにするために4つのこと
（さらに、
これらを支援するために他のことも）
行います。

@itemize @bullet
@item
ユーザ・プログラムを、
その動作に影響を与える可能性のある様々なことを指定して起動する

@item
指定された条件が成立したときにユーザ・プログラムを停止する

@item
停止したときにユーザ・プログラムが何を行っていたかを調べる

@item
ユーザ・プログラムの内部を変更することによって、
1つのバグの影響を試験的に修正して、
ほかのバグについて調べる
@end itemize

@ifclear CONLY
@value{GDBN}を使ってCおよびC++で記述されたプログラムをデバッグすることができます。
@c "MOD2" used as a "miscellaneous languages" flag here.
@c This is acceptable while there is no real doc for Chill and Pascal.
@ifclear MOD2
詳細については、
@xref{Support,,Supported languages}。
@end ifclear
@ifset MOD2
詳細については、
@xref{C,,C and C++}。

Modula-2とChillのサポートはまだ部分的なものです。
Modula-2に関する情報については、
@xref{Modula-2,,Modula-2}。
Chillに関するドキュメントはまだありません。

集合、
サブ範囲
（subrange）、
ファイル変数、
入れ子関数を使っているPascalプログラムをデバッグすることは、
現時点ではできません。
Pascalの構文を使って、
式の入力、
変数の値の表示、
およびそれに類することを実行することを、
@value{GDBN}はサポートしていません。
@end ifset

@ifset FORTRAN
@cindex Fortran
@value{GDBN}は、
Fortranで記述されたプログラムのデバッグに使うことができます。
しかし、
Fortranの構文を使って、
式の入力、
変数の値の表示、
およびそれに類する機能を実行することは、
まだサポートされていません。
変数によっては、
末尾にアンダースコアを付けて参照する必要のある場合があります。
@end ifset
@end ifclear

@ifset HPPA
このマニュアルは、
リリース10.20、
10.30、
11.0のHP-UXオペレーティング・システムが動作するHP 9000システム上に実装された、
バージョン0.75のHP Wildebeest (WDB)のドキュメントです。
HP WDB 0.75は、
@sc{gnu} C/C++コンパイラだけでなく、
HP ANSI Cコンパイラ、
HP ANSI C++コンパイラによって生成されたコードのデバッグにも使用することができます。
Fortran、
Modula-2、
Chillで記述されたプログラムのデバッグはサポートされていません。
@end ifset

@menu
* Free Software::               フリー・ソフトウェア
* Contributors::                GDBに貢献した人々
@end menu

@node Free Software, Contributors, Summary, Summary
@unnumberedsec フリー・ソフトウェア

@value{GDBN}は@dfn{フリー・ソフトウェア}であり、
@sc{gnu} General Public License （GPL）により保護されています。
あなたは、
GPLによって、
ライセンスされたプログラムをコピーしたり改造したりする自由を与えられます。
しかし、コピーを入手した人は誰でも、
そのコピーとともに、
そのコピーを修正する自由を手に入れますし
（つまりソース・コードを入手することができなければならないということです）、
また、
さらにそのコピーを配布する自由も手に入れます。
通常、
ソフトウェア会社は、
著作権によりユーザの自由を妨げます。
Free Software FoundationはGPLを使ってこれらの自由を保護します。

基本的には、
GPLは、
「あなたはこれらの自由を与えられるが、
これらの自由をほかの誰からも奪うことはできない」
と主張するライセンスです。

@node Contributors,  , Free Software, Summary
@unnumberedsec GDBに貢献した人々

Richard Stallmanは、
GDB、
および、
その他の多くの
@sc{gnu}
プログラムの最初の開発者です。
ほかにも多くの人々がGDBの開発に貢献してきました。
この節では、
主要な貢献者を紹介したいと思います。
フリー・ソフトウェアの素晴らしい点の1つは、
誰もがそれに貢献する自由があるということです。
残念ながら、
ここですべての人を紹介することはできません。
@value{GDBN}
ディストリビューションに含まれる
@file{ChangeLog}
というファイルにおおまかな紹介を載せてあります。

バージョン2.0よりもずっと前の変更内容は、いつのまにか紛失してしまいました。

@quotation
@emph{お願い:}
このセクションへの追加は大歓迎です。
あなたやあなたの友人
（公平を期すため、あなたの敵も加えておきましょう）
が不当にもこのリストから除外されているのであれば、
喜んで名前を付け加えます。
@end quotation

彼らの多大な労働が感謝されていないと思われないように、
最初に、
@value{GDBN}の主要なリリースを通じて
@value{GDBN}の面倒を見てきた人々に特に感謝します。
その人々とは、
Jim Blandy（リリース4.18）、
Jason Molenda（リリース4.17）、
Stan Shebs（リリース4.14）、
Fred Fish（リリース4.16, 4.15, 4.13, 4.12, 4.11, 4.10, 4.9）、
Stu GrossmanとJohn Gilmore（リリース4.8, 4.7, 4.6, 4.5, 4.4）、
John Gilmore（リリース4.3, 4.2, 4.1, 4.0, 3.9）、
Jim Kingdon（リリース3.5, 3.4, 3.3）、
Randy Smith（リリース3.2, 3.1, 3.0） です。

Richard Stallmanは、様々な機会にPeter TerMaat、Chris Hanson、Richard
Mlynarikの支援を受けながら、2.8までのリリースを担当しました。

@ifclear CONLY
Michael Tiemannは、
GDBにおける@sc{gnu} C++サポートのほとんどを開発してくれました。
C++のサポートについては、
Per Bothnerからも重要な貢献がありました。
James Clarkは@sc{gnu} C++のデマングラ
（demangler）
を開発してくれました。
C++についての初期の仕事は
Peter TerMaatによるものです
（彼はまた、
リリース3.0までの一般的なアップデート作業の多くを担当してくれました）。
@end ifclear

@value{GDBN} 4は、
複数のオブジェクト・ファイル・フォーマットを調べるのに BFD
サブルーチン・ライブラリを使用しています。
BFDは、
David V. Henkel-Wallace、
Rich Pixley、
Steve Chamberlain、
John Gilmoreによる共同プロジェクトです。

David Johnsonは、最初のCOFFサポートを開発してくれました。
Pace Willisonは最初のカプセル化されたCOFF
（encapsulated COFF）
のサポートを開発してくれました。

Harris Computer Systems社のBrent Bensonは、
DWARF 2のサポート部分を提供してくれました。

Adam de BoorとBradley DavisはISI Optimum Vのサポート部分を提供してくれました。
Per Bothner、引地信之、Alessandro Forinは、
MIPSのサポート部分を提供してくれました。
Jean-Daniel FeketeはSun 386iのサポート部分を提供してくれました。
Chris HansonはHP9000サポートを改善してくれました。
引地信之と長谷井智之は、
Sony/News OS 3のサポート部分を提供してくれました。
David JohnsonはEncore Umaxのサポート部分を提供してくれました。
Jyrki KuoppalaはAltos 3068のサポート部分を提供してくれました。
Jeff LawはHP PAとSOMのサポート部分を提供してくれました。
Keith PackardはNS32Kのサポート部分を提供してくれました。
Doug RabsonはAcorn Risc Machineのサポート部分を提供してくれました。
Bob RuskはHarris Nighthawk CX-UXのサポート部分を提供してくれました。
Chris SmithはConvexのサポート
（および、Fortranデバッグのサポート）
部分を提供してくれました。
Jonathan StoneはPyramidのサポート部分を提供してくれました。
Michael TiemannはSPARCのサポート部分を提供してくれました。
Tim TuckerはGould NP1とGould Powernodeのサポート部分を提供してくれました。
Pace WillisonはIntel 386のサポート部分を提供してくれました。
Jay VosburghはSymmetryのサポート部分を提供してくれました。

Andreas SchwabはM68K Linuxのサポート部分を提供してくれました。

Rich SchaeferとPeter SchauerはSunOS共用ライブラリのサポートを手伝ってくれました。

Jay FenlasonとRoland McGrathは、
@value{GDBN}とGASがいくつかのマシン命令セットに関して共通の認識を持つようにしてくれました。

Patrick Duval、Ted Goldstein、Vikram Koka、Glenn Engelはリモート・デバッグ機能の開発を手伝ってくれました。
Intel社、Wind River Systems 社、AMD社、ARM社はそれぞれ、
i960、VxWorks、A29K UDI、RDIターゲット用のリモート・デバッグ・モジュールを提供してくれました。

Brian Foxは、コマンドライン編集やコマンドライン・ヒストリを提供する
readlineライブラリの開発者です。

SUNY BuffaloのAndrew Beersは言語切り替えのソース・コード
@ifset MOD2
とModula-2サポート
@end ifset
を開発し、このマニュアルのプログラミング言語関連
（Languages）
の章を提供してくれました。

Fred FishはUnix System Vr4サポートのほとんどを開発してくれました。
@ifclear CONLY
彼はまた、
C++のオーバーロードされたシンボルを扱えるようコマンド補完機能を拡張してくれました。 
@end ifclear

Hitachi America, Ltd.は、
H8/300プロセッサ、
H8/500プロセッサ、
および、
Super-Hプロセッサのサポートを後援してくれました。

NECは、
v850プロセッサ、
Vr4xxxプロセッサ、
および、
Vr5xxxプロセッサのサポートを後援してくれました。

Mitsubishi（三菱）は、
D10Vプロセッサ、
D30Vプロセッサ、
および、
M32R/Dプロセッサのサポートを後援してくれました。

Toshiba（東芝）は、
TX39 Mipsプロセッサのサポートを後援してくれました。

Matsushita（松下）は、
MN10200プロセッサとMN10300プロセッサのサポートを後援してくれました。

Fujitsu（富士通）は、
SPARCliteプロセッサとFR30プロセッサのサポートを後援してくれました。

Kung Hsu、Jeff Law、Rick Sladkeyはハードウェア・ウォッチポイントのサポートを追加してくれました。

Michael Snyderはトレースポイントのサポートを追加してくれました。

Stu Grossmanはgdbserverを開発してくれました。

Jim Kingdon、Peter Schauer、Ian Taylor、Stu GrossmanはGDB全体にわたって、
ほとんど数えることができないほどのバグ・フィックスとソース・コードの整理を行ってくれました。

Hewlett-Packard社のBen Krepp、
Richard Title、
John Bishop、
Susan Macchia、
Kathy Mann、
Satish Pai、
India Paul、
Steve Rehrauer、
Elena Zannoniは、
PA-RISC 2.0アーキテクチャ、
HP-UX 10.20、10.30、11.0(narrow mode)、
HPによるカーネル・スレッドの実装、
HP aC++コンパイラ、
および、
端末ユーザ・インターフェイスの各サポート部分を提供してくれました。
また、
このマニュアルの中のHP固有の情報は、
Kim Haaseにより提供されたものです。

Cygnus Solutions社は、
1991年以降、
GDBの保守作業とGDBの多くの開発作業を後援しています。
フルタイムでGDBに関わる仕事をしたCygnusのエンジニアは、
Mark Alexander、
Jim Blandy、
Per Bothner、
Edith Epstein、
Chris Faylor、
Fred Fish、
Martin Hunt、
Jim Ingham、
John Gilmore、
Stu Grossman、
Kung Hsu、
Jim Kingdon、
John Metzler、
Fernando Nasser、
Geoffrey Noer、
Dawn Perchik、
Rich Pixley、
Zdenek Radouch、
Keith Seitz、
Stan Shebs、
David Taylor、
Elena Zannoniです。
さらに、
Dave Brolley、
Ian Carmichael、
Steve Chamberlain、
Nick Clifton、
JT Conklin、
Stan Cox、
DJ Delorie、
Ulrich Drepper、
Frank Eigler、
Doug Evans、
Sean Fagan、
David Henkel-Wallace、
Richard Henderson、
Jeff Holcomb、
Jeff Law、
Jim Lemke、
Tom Lord、
Bob Manson、
Michael Meissner、
Jason Merrill、
Catherine Moore、
Drew Moseley、
Ken Raeburn、
Gavin Romig-Koch、
Rob Savoye、
Jamie Smith、
Mike Stump、
Ian Taylor、
Angela Thomas、
Michael Tiemann、
Tom Tromey、
Ron Unrau、
Jim Wilson、
David Zuhnは、
大小様々な貢献をしてくれました。


@ifclear BARETARGET
@node Sample Session, Invocation, Summary, Top
@chapter @value{GDBN}セッションのサンプル

その気になれば、
このマニュアルを使って@value{GDBN}のすべてを学習することももちろん可能ですが、
@value{GDBN}を使い始めるには、
いくつかのコマンドを知っていれば十分です。
本章では、そのようなコマンドについて説明します。

@iftex
@value{GDBN}の出力情報との区別が容易につくように、
このサンプル・セッションでは、
ユーザの入力を
@b{input}
のように太字で表わします。
@end iftex

@c FIXME: this example may not be appropriate for some configs, where
@c FIXME...primary interest is in remote use.

汎用的なマクロ・プロセッサである@sc{gnu} @code{m4}には、
かつて、
まだ正式なバージョンがリリースされる以前に、
次のような不具合がありました。
引用を表わす文字列をデフォルトとは異なるものに変更すると、
あるマクロ定義の内部に入れ子状態になっている他のマクロ定義を取り出すために使われるコマンドが、
正しく動作しなくなることがある、
という不具合です。
以下の短い@code{m4}セッションでは、
@code{0000}に展開されるマクロ@code{foo}を定義しています。
さらに、
@code{m4}の組み込みコマンド@code{defn}を使って、
マクロ@code{bar}に同一の定義を与えています。
ところが、
引用の開始文字列を@code{<QUOTE>}に、
引用の終了文字列を@code{<UNQUOTE>}にそれぞれ変更すると、
全く同一の手順で新しい同義語@code{baz}を定義しようとしても、
うまくいかないのです。

@smallexample
$ @b{cd gnu/m4}
$ @b{./m4}
@b{define(foo,0000)}

@b{foo}
0000
@b{define(bar,defn(`foo'))}

@b{bar}
0000
@b{changequote(<QUOTE>,<UNQUOTE>)}

@b{define(baz,defn(<QUOTE>foo<UNQUOTE>))}
@b{baz}
@b{C-d}
m4: End of input: 0: fatal error: EOF in string
@end smallexample

@noindent
ここで@value{GDBN}を使って、
何が起こっているのか調べてみましょう。

@ifclear HPPA
@smallexample
$ @b{@value{GDBP} m4}
@c FIXME: this falsifies the exact text played out, to permit smallbook
@c FIXME... format to come out better.
@value{GDBN} is free software and you are welcome to distribute copies
 of it under certain conditions; type "show copying" to see 
 the conditions.
There is absolutely no warranty for @value{GDBN}; type "show warranty" 
 for details.

@value{GDBN} @value{GDBVN}, Copyright 1999 Free Software Foundation, Inc...
(@value{GDBP})
@end smallexample
@end ifclear
@ifset HPPA
@smallexample
$ @b{@value{GDBP} m4}
Wildebeest is free software and you are welcome to distribute copies of
it under certain conditions; type "show copying" to see the conditions.
There is absolutely no warranty for Wildebeest; type "show warranty"
for details.

Hewlett-Packard Wildebeest 0.75 (based on GDB 4.16)
(built for PA-RISC 1.1 or 2.0, HP-UX 10.20)
Copyright 1996, 1997 Free Software Foundation, Inc.
(@value{GDBP})
@end smallexample
@end ifset

@noindent
@value{GDBN}は、
必要なときに他のシンボルを見つけるのに最低限必要となるシンボル情報しか読み込みません。
その結果、
最初のプロンプトが表示されるまでの時間が極めて短いのです。
ここで、
出力情報がこのマニュアルの紙幅に収まるようにするために、
@value{GDBN}に対して表示幅を通常よりも狭くするよう指示を出してみましょう。

@smallexample
(@value{GDBP}) @b{set width 70}
@end smallexample

@noindent
@code{m4}の組み込みコマンドである@code{changequote}がどのように動作するのかを調べてみる必要があります。
ソースを見ると、
関連するサブルーチンが@code{m4_changequote}であることがわかります。
そこで、
@value{GDBN}の@code{break}コマンドでブレイクポイントを設定してみます。

@smallexample
(@value{GDBP}) @b{break m4_changequote}
Breakpoint 1 at 0x62f4: file builtin.c, line 879.
@end smallexample

@noindent
@code{run}コマンドを使って、
@value{GDBN}の管理下で@code{m4}を走らせます。
@code{m4_changequote}サブルーチンに到達するまでは、
プログラムは通常どおりの動作をします。

@smallexample
(@value{GDBP}) @b{run}
Starting program: /work/Editorial/gdb/gnu/m4/m4
@b{define(foo,0000)}

@b{foo}
0000
@end smallexample

@noindent
ブレイクポイントでプログラムを停止させるために@code{changequote}を実行すると、
@value{GDBN}は@code{m4}の実行を停止し、
停止した箇所のコンテキスト情報を表示します。

@smallexample
@b{changequote(<QUOTE>,<UNQUOTE>)}

Breakpoint 1, m4_changequote (argc=3, argv=0x33c70) 
    at builtin.c:879
879         if (bad_argc(TOKEN_DATA_TEXT(argv[0]),argc,1,3))
@end smallexample

@noindent
次に@code{n}（@code{next}）コマンドを実行すると、
現在停止している関数の中で1行だけ処理が実行されます。

@smallexample
(@value{GDBP}) @b{n}
882         set_quotes((argc >= 2) ? TOKEN_DATA_TEXT(argv[1])\
 : nil,
@end smallexample

@noindent
@code{set_quotes}というのは、
いわくありげなサブルーチンです。
@code{next}コマンドの代わりに@code{s}（@code{step}）コマンドを使うことで、
このサブルーチンの中に入ることができます。
@code{step}コマンドは、
それが@emph{どの}サブルーチンの中にあるかということにかかわりなく、
次の1行に移動します。
この場合、
次の1行は@code{set_quotes}の中ですから、
そこへ移動することになります。

@smallexample
(@value{GDBP}) @b{s}
set_quotes (lq=0x34c78 "<QUOTE>", rq=0x34c88 "<UNQUOTE>")
    at input.c:530
530         if (lquote != def_lquote)
@end smallexample

@noindent
@code{m4}がその中で現在停止しているサブルーチン
（および、そのサブルーチンへの引数）
が表示されています。
これをスタック・フレーム表示と呼びます。
それは、
スタックの状態を要約した情報を表示しています。
@code{backtrace}コマンド
（あるいは、
@code{bt}と省略することもできます）
を使って、
現在、
スタック全体の中のどこにいるかを知ることもできます。
@code{backtrace}コマンドは、
アクティブなサブルーチンのスタック・フレームを表示します。

@smallexample
(@value{GDBP}) @b{bt}
#0  set_quotes (lq=0x34c78 "<QUOTE>", rq=0x34c88 "<UNQUOTE>")
    at input.c:530
#1  0x6344 in m4_changequote (argc=3, argv=0x33c70) 
    at builtin.c:882
#2  0x8174 in expand_macro (sym=0x33320) at macro.c:242
#3  0x7a88 in expand_token (obs=0x0, t=209696, td=0xf7fffa30)
    at macro.c:71
#4  0x79dc in expand_input () at macro.c:40
#5  0x2930 in main (argc=0, argv=0xf7fffb20) at m4.c:195
@end smallexample

@noindent
次に、2、3行先に進んで、
何が起こっているのかを見てみましょう。
最初の2回は、
@samp{s}コマンドを使います。
続く2回は、
@code{xstrdup}サブルーチンの中に入ってしまうのを防ぐために、
@code{n}コマンドを使います。

@smallexample
(@value{GDBP}) @b{s}
0x3b5c  532         if (rquote != def_rquote)
(@value{GDBP}) @b{s}
0x3b80  535         lquote = (lq == nil || *lq == '\0') ?  \
def_lquote : xstrdup(lq);
(@value{GDBP}) @b{n}
536         rquote = (rq == nil || *rq == '\0') ? def_rquote\
 : xstrdup(rq);
(@value{GDBP}) @b{n}
538         len_lquote = strlen(rquote);
@end smallexample

@noindent
最後に表示された行は、少し妙な感じがします。
2つの変数@code{lquote}、
@code{rquote}を調べて、
本当にそれが、
新たに指定された引用開始文字列、
引用終了文字列であるかどうか確認することができます。
値を調べるには@code{p}（@code{print}）コマンドを使用します。

@smallexample
(@value{GDBP}) @b{p lquote}
$1 = 0x35d40 "<QUOTE>"
(@value{GDBP}) @b{p rquote}
$2 = 0x35d50 "<UNQUOTE>"
@end smallexample

@noindent
@code{lquote}と@code{rquote}は確かに引用開始文字列、
引用終了文字列のようです。
前後関係を調べるには、
@code{l}（@code{list}）コマンドを使って、
現在停止している行を中心にその前後10行を表示します。

@smallexample
(@value{GDBP}) @b{l}
533             xfree(rquote);
534
535         lquote = (lq == nil || *lq == '\0') ? def_lquote\
 : xstrdup (lq);
536         rquote = (rq == nil || *rq == '\0') ? def_rquote\
 : xstrdup (rq);
537
538         len_lquote = strlen(rquote);
539         len_rquote = strlen(lquote);
540     @}
541
542     void
@end smallexample

@noindent
@code{len_lquote}と@code{len_rquote}に値を設定している行を実行させてから、
それらの値を調べてみましょう。

@smallexample
(@value{GDBP}) @b{n}
539         len_rquote = strlen(lquote);
(@value{GDBP}) @b{n}
540     @}
(@value{GDBP}) @b{p len_lquote}
$3 = 9
(@value{GDBP}) @b{p len_rquote}
$4 = 7
@end smallexample

@noindent
@code{len_lquote}と@code{len_rquote}が、
それぞれ@code{lquote}と@code{rquote}の長さであるとすると、
ここに表示されている値は明らかに誤りです。
@code{p}コマンドを使って、
正しい値を設定することができます。
@code{p}コマンドによって任意の式の値を表示することができますが、
ここでいう「式」には、
サブルーチンの呼び出しや、
値の割り当ても含まれます。

@smallexample
(@value{GDBP}) @b{p len_lquote=strlen(lquote)}
$5 = 7
(@value{GDBP}) @b{p len_rquote=strlen(rquote)}
$6 = 9
@end smallexample

@noindent
新しい引用文字列をセットした状態で、
@code{m4}の組み込みコマンド@code{defn}を使用しようとすると発生する問題を修正するには、
これだけで十分でしょうか?
@code{c}（@code{continue}）コマンドを使えば、
@code{m4}に処理を継続させて、
実際に問題を発生させていた例を実行することができます。

@smallexample
(@value{GDBP}) @b{c}
Continuing.

@b{define(baz,defn(<QUOTE>foo<UNQUOTE>))}

baz
0000
@end smallexample

@noindent
今度はうまくいきました。
新たにセットされた引用文字列は、
デフォルトの引用文字列と同じように機能しました。
問題の原因は、
プログラム内の2箇所のタイプ・ミスで、
長さの設定が正しく行われていないことにあったようです。
EOFを入力して、
@code{m4}を終了させましょう。

@smallexample
@b{C-d}
Program exited normally.
@end smallexample

@noindent
@samp{Program exited normally.}というメッセージは、
@value{GDBN}が出力したもので、
@code{m4}の実行が終了したことを意味しています。
@value{GDBN}の
@code{quit}コマンドで、
@value{GDBN}セッションを終了することができます。

@smallexample
(@value{GDBP}) @b{quit}
@end smallexample
@end ifclear

@node Invocation, Commands, Sample Session, Top
@chapter @value{GDBN}の起動・終了

本章では、
@value{GDBN}の起動方法、
終了方法を説明します。
基本は、
以下の2つです。

@itemize @bullet
@item 
@samp{@value{GDBP}}と入力してGDBを起動する
@item 
@kbd{quit}または@kbd{C-d}を入力してGDBを終了する
@end itemize

@menu
* Invoking GDB::                @value{GDBN}の起動
* Quitting GDB::                @value{GDBN}の終了
* Shell Commands::              @value{GDBN}の中でのシェル・コマンドの使用
@end menu

@node Invoking GDB, Quitting GDB, Invocation, Invocation
@section @value{GDBN}の起動

@ifset H8EXCLUSIVE
日立（Hitachi）
のマイクロプロセッサにアタッチしたリモート・デバッガとして
@value{GDBP}を起動する方法の詳細については、
@ref{Hitachi Remote,,@value{GDBN} and Hitachi Microprocessors}
を参照してください。
@end ifset

@code{@value{GDBP}}というプログラムを実行することで、
@value{GDBN}が起動されます。
ひとたび起動されると、
@value{GDBN}は終了を指示されるまで、
端末からのコマンド入力を受け付けます。

あるいは、
最初から@value{GDBN}のデバッグ環境を指定するために、
様々な引数やオプションを指定して
@code{@value{GDBP}}プログラムを実行することもできます。

@ifset GENERIC
ここで説明するコマンドライン・オプションは、
様々な状況に対応するために設計されたものです。
環境によっては、
ここで説明するオプションのいくつかは、
事実上使用できない場合もあります。
@end ifset

@value{GDBN}の最も基本的な起動方法は、
デバッグされる実行プログラムの名前を引数に指定することです。

@example
@value{GDBP} @var{program}
@end example

@ifclear BARETARGET
@noindent
起動時に、
実行プログラム名とともに、
コア・ファイルの名前を指定することもできます。

@example
@value{GDBP} @var{program} @var{core}
@end example

あるいは、
既に実行中のプロセスをデバッグする場合には、
そのプロセスIDを第2引数に指定することもできます。

@example
@value{GDBP} @var{program} 1234
@end example

@noindent
ここでは、
@value{GDBN}はプロセスID @code{1234}のプロセスにアタッチします
（ただし、
@file{1234}という名前のファイルが存在しないというのが条件です。
@value{GDBN}は、
まずコア・ファイルの存在を確認します）。

@ifclear HPPA
このような第2引数の利用が可能であるためには、
かなり完成されたオペレーティング・システムが必要になります。
ボード・コンピュータに接続して、
リモート・デバッガとして@value{GDBN}を使用する場合には、
そもそも「プロセス」という概念がないかもしれませんし、
多くの場合、
コア・ダンプというものもないでしょう。
@end ifclear
@end ifclear

@code{gdb}を起動すると、
@value{GDBN}の無保証性を説明する文章が表示されますが、
@code{-silent}オプションを指定することで、
これを表示しないようにすることもできます。

@smallexample
@value{GDBP} -silent
@end smallexample

@noindent
コマンドライン・オプションを指定することで、
@value{GDBN}の起動方法をさらに制御することができます。
@value{GDBN}自身に、
使用可能なオプションを表示させることができます。

@c __ @noindent

@example
@value{GDBP} -help
@end example

@noindent
のように@value{GDBP}プログラムを実行することで、
使用可能なオプションがすべて、
その使用方法についての簡単な説明付きで表示されます
（短縮して、
@samp{@value{GDBP} -h}という形で実行しても同じ結果が得られます）。

ユーザの指定したすべてのオプションと引数は、
順番に処理されます。
@samp{-x}オプションが指定されている場合は特別で、
順序の違いに意味がでてきます。

@menu
@ifclear GENERIC
@ifset REMOTESTUB
* Remote Serial::               @value{GDBN}リモート・シリアル・プロトコル
@end ifset
@ifset I960
* i960-Nindy Remote::		@value{GDBN}とリモートi960（Nindy）
@end ifset
@ifset AMD29K
* UDI29K Remote::               AMD29K用のUDIプロトコル
* EB29K Remote::		AMD29K用のEBMONプロトコル
@end ifset
@ifset VXWORKS
* VxWorks Remote::		@value{GDBN}とVxWorks
@end ifset
@ifset ST2000
* ST2000 Remote::               @value{GDBN}とTandem ST2000
@end ifset
@ifset H8
* Hitachi Remote::              @value{GDBN}と日立のマイクロ・プロセッサ
@end ifset
@ifset MIPS
* MIPS Remote::			@value{GDBN}とMIPSボード
@end ifset
@ifset SPARCLET
* Sparclet Remote::             @value{GDBN}とSparcletボード
@end ifset
@ifset SIMS
* Simulator::                   シミュレートされたCPUターゲット
@end ifset
@end ifclear
@c remnant makeinfo bug requires this blank line after *two* end-ifblahs:

* File Options::                ファイルの選択
* Mode Options::                モードの選択
@end menu

@ifclear GENERIC
@ifclear HPPA
@c {{この@includeがあるとtexinfo-format-bufferがエラーになる}}
@c {{よって意図的にコメントアウトした                       }}
@c @include remote-ja.texi
@end ifclear
@end ifclear

@node File Options
@subsection ファイルの選択

@ifclear BARETARGET
起動された@value{GDBN}は、
指定された引数のうちオプション以外のものは、
実行ファイル名およびコア・ファイル名
（あるいはプロセスID）
であると解釈します。
これは、
@samp{-se}オプションと@samp{-c}オプションが指定されたのと同じことです
（@value{GDBN}は、
対応するオプション・フラグを持たない最初の引数を@samp{-se}オプション付きと同等とみなし、
同じく対応するオプション・フラグを持たない第2の引数があれば、
これを@samp{-c}オプション付きと同等とみなします）。
@end ifclear
@ifset BARETARGET
@c {{as specifying... はoptionsにかかっているのか？}}
@value{GDBN}は、
起動時に、
実行ファイルを指定するオプションを除くすべての引数を読み込みます。
これは、
引数が@samp{-se}オプションによって指定された場合でも同様です。
@end ifset

多くのオプションには、
完全形と短縮形があります。
以下の一覧では、
その両方を示します。
オプション名は、
他のオプションと区別がつけば、
最後まで記述しなくても、
@value{GDBN}によって正しく認識されます
（オプション名には@samp{-}ではなく@samp{--}を使うことも可能ですが、
ここでは一般的な慣例にしたがうこととします）。

@table @code
@item -symbols @var{file}
@itemx -s @var{file}
@var{file}で指定されるファイルからシンボル・テーブルを読み込みます。

@item -exec @var{file}
@itemx -e @var{file}
可能であれば、
@var{file}で指定されるファイルを、
実行ファイルとして使います。
@ifset BARETARGET
@end ifset
@ifclear BARETARGET
また、
このファイルを、
コア・ダンプとともにデータを解析するために使います。
@end ifclear

@item -se @var{file}
@var{file}で指定されるファイルからシンボル・テーブルを読み込み、
かつ、
このファイルを実行ファイルとして使います。

@ifclear BARETARGET
@item -core @var{file}
@itemx -c @var{file}
@var{file}で指定されるファイルを解析すべきコア・ダンプとして使います。

@item -c @var{number}
@var{number}で指定されるプロセスIDを持つプロセスに接続します。
これは、
@code{attach}コマンドを実行するのと同等です
（ただし、
@var{number}で指定される名前のコア・ダンプ形式のファイルが存在する場合は、
そのファイルをコア・ダンプとして読み込みます）。
@end ifclear

@item -command @var{file}
@itemx -x @var{file}
@var{file}で指定されるファイル内に記述された@value{GDBN}コマンドを実行します。
@xref{Command Files,, Command files}。

@item -directory @var{directory}
@itemx -d @var{directory}
ソース・ファイルを検索するパスに@var{directory}で指定されるディレクトリを追加します。

@ifclear BARETARGET
@ifclear HPPA
@item -m
@itemx -mapped
@emph{注意: このオプションは、
すべてのシステムでサポートされているわけではない、
オペレーティング・システムのある機能に依存しています。}@*
システム上で、
@code{mmap}システム・コールによるファイルのメモリへのマッピングが使用可能である場合、
このオプションを使うことで、
プログラムのシンボル情報を再利用可能なファイルとしてカレント・ディレクトリに書き出させることができます。
仮にデバッグ中のプログラム名が@file{/tmp/fred}であるとすると、
マップされたシンボル・ファイルは@file{./fred.syms}となります。
この後の@value{GDBN}デバッグ・セッションは、
このファイルの存在を検出し、
そこから迅速にシンボル情報をマップします。
この場合、
実行プログラムからシンボル情報を読み込むことはありません。

@file{.syms}ファイルは、
@value{GDBN}が実行されるホスト・マシンに固有のものです。
このファイルは、
内部の@value{GDBN}シンボル・テーブルのイメージをそのまま保存したものです。
これを、
複数のホスト・プラットフォーム上において、
共有することはできません。
@end ifclear
@end ifclear

@ifclear HPPA
@item -r
@itemx -readnow
シンボル・ファイル内のシンボル・テーブル全体をただちに読み込みます。
デフォルトの動作では、
シンボル情報は必要になるたびに徐々に読み込まれます。
このオプションを使うと起動までに時間がかかるようになりますが、
その後の処理は速くなります。
@end ifclear
@end table

@ifclear BARETARGET
@ifclear HPPA
@code{-mapped}オプションと@code{-readnow}オプションは、
完全なシンボル情報を含む@file{.syms}ファイルを作成するために、
通常は一緒に指定されます
（@file{.syms}ファイルに関する詳細については、
@xref{Files,,Commands to specify files}）。
後に使用する目的で@file{.syms}を作成するだけで、
それ以外には何もしないようにするためのGDBの単純な起動方法は、
以下のとおりです。

@example
	gdb -batch -nx -mapped -readnow programname
@end example
@end ifclear
@end ifclear

@node Mode Options,  , File Options, Invoking GDB
@subsection モードの選択

@value{GDBN}を様々なモードで実行することが可能です。
例えば、
batchモードやquietモードなどがあります。

@table @code
@item -nx
@itemx -n
初期化ファイルに記述されたコマンドを実行しません
（通常、
初期化ファイルは@file{.gdbinit}という名前です。
ただし、
PC上では@file{gdb.ini}となります）。
通常は、
すべてのコマンド・オプションと引数が処理された後に、
初期化ファイル内のコマンドが実行されます。
@xref{Command Files,,Command files}。

@item -quiet
@itemx -q
紹介メッセージおよびコピーライト・メッセージを表示しません。
これらのメッセージは、
batchモードでも表示されません。

@item -batch
batchモードで実行されます。
@samp{-x}オプションで指定されたすべてのコマンド・ファイルを処理した後、
終了コード@code{0}で終了します
（@samp{-n}オプションによって禁止されていなければ、
初期化ファイル内に記述されているすべてのコマンドも実行されます）。
コマンド・ファイルに記述された@value{GDBN}コマンドの実行中にエラーが発生した場合には、
@code{0}以外の終了コードで終了します。

batchモードは@value{GDBN}をフィルタとして実行する場合に便利です。
例えば、
あるプログラムを別のコンピュータ上にダウンロードして実行する場合などです。
このような使い方の邪魔にならないよう、

@example
Program exited normally.
@end example

@noindent
というメッセージは、
batchモードでは表示されません
（通常このメッセージは、
@value{GDBN}の管理下で実行中のプログラムが終了するときに、
必ず表示されます）。

@item -cd @var{directory}
カレント・ディレクトリではなく、
@var{directory}で指定されたディレクトリを作業ディレクトリとして、
@value{GDBN}を実行します。

@ifclear DOSHOST
@item -fullname
@itemx -f
@sc{gnu} Emacsが@value{GDBN}をサブ・プロセスとして起動するとき、
このオプションを指定します。
このオプションは、
スタック・フレームを表示するときには、
必ず完全なファイル名と行番号を標準的な認識可能な書式で出力するよう@value{GDBN}に対して指示するものです
（スタック・フレームは、
例えば、
プログラムの実行が停止されたときに必ず表示されます）。
認識可能な書式とは、
先頭に2つの@samp{\032}文字、
続いてコロンで区切られたファイル名、
行番号、
桁位置、
最後に改行、
というものです。
Emacs-@value{GDBN}インターフェイス・プログラムは、
フレームに対応するソース・コードを表示させる命令として、
2つの@samp{\032}文字を使用します。
@end ifclear

@ifset SERIAL
@ifclear HPPA
@item -b @var{bps}
@value{GDBN}によってリモート・デバッグ用に使用されるシリアル・インターフェイスの回線速度
（ボーレートあるいはBPS）
を設定します。
@end ifclear

@item -tty @var{device}
プログラムの標準入力および標準出力として@var{device}を使用して実行します。
@c FIXME: kingdon thinks there is more to -tty.  Investigate.
@end ifset

@ifset HPPA
@item -tui
端末ユーザ・インターフェイス（Terminal User Interface）を使います。
これに関する情報については、
Webブラウザを使用して、
ファイル@file{TUI.html}を読んでください。
通常このファイルは、
HP-UXシステムの@code{/opt/langtools/wdb/doc}ディレクトリにインストールされています。
Emacsから@value{GDBN}を実行する場合には、
このオプションを使用しないでください
（@pxref{Emacs, ,Using @value{GDBN} under @sc{gnu} Emacs}を参照）。

@item -xdb
いくつかのXDBコマンドを使用することができる、
XDB互換モードで実行します。
これに関する情報については、
ファイル@file{xdb_trans.html}を参照してください。
通常このファイルは、
HP-UXシステムの@code{/opt/langtools/wdb/doc}ディレクトリにインストールされています。
@end ifset
@end table

@node Quitting GDB, Shell Commands, Invoking GDB, Invocation
@section @value{GDBN}の終了
@cindex exiting @value{GDBN}
@cindex leaving @value{GDBN}
@cindex @value{GDBN}の終了[@value{GDBN}のしゅうりょう]
@cindex 終了、@value{GDBN}の[しゅうりょう、@value{GDBN}の]

@table @code
@kindex quit @r{[}@var{expression}@r{]}
@kindex q
@item quit
@value{GDBN}を終了するためには、
@code{quit}コマンド
（省略形は@code{q}）
を使用するか、
あるいは、
ファイルの終端文字
（通常は@kbd{C-d}）
を入力します。
@var{expression}を指定しない場合、
@value{GDBN}は正常終了します。
@var{expression}が指定された場合、
@var{expression}の評価結果をエラー・コードとして終了します。
@end table

@cindex interrupt
@cindex 割り込み[わりこみ]
割り込み
（多くの場合@kbd{C-c}）
は@value{GDBN}を終了させません。
割り込みは通常、
実行中の@value{GDBN}コマンドを終了させ、
@value{GDBN}のコマンド・レベルに復帰させます。
割り込み文字は、
いつ入力しても安全です。
というのは、
割り込みの発生が危険である間は、
@value{GDBN}が割り込みの発生を抑止するからです。

@ifclear BARETARGET
アタッチされたプロセスやデバイスを制御するために
@value{GDBN}を使用していた場合、
@code{detach}コマンドでそれを解放することができます
（@pxref{Attach, ,Debugging an already-running process}）。
@end ifclear

@node Shell Commands,  , Quitting GDB, Invocation
@section シェル・コマンド

デバッグ・セッションの途中でシェル・コマンドを実行する必要がある場合、
@value{GDBN}を終了したり一時停止させたりする必要はありません。
@code{shell}コマンドを使用することができます。

@table @code
@kindex shell
@cindex shell escape
@cindex シェル・エスケープ
@item shell @var{command string}
@var{command string}で指定されるコマンド文字列を実行するために標準シェルを起動します。
@ifclear DOSHOST
@code{SHELL}環境変数が設定されていれば、
その値が実行されるべきシェルを決定します。
@code{SHELL}環境変数が設定されていなければ、
@value{GDBN}は@code{/bin/sh}を実行します。
@end ifclear
@end table

開発環境ではしばしば@code{make}ユーティリティが必要とされます。
@value{GDBN}内部で@code{make}ユーティリティを使用する場合は、
@code{shell}コマンドを使用する必要はありません。

@table @code
@kindex make
@cindex calling make
@cindex @code{make}の呼び出し[makeのよびだし]
@cindex 呼び出し、@code{make}の[よびだし、makeの]
@item make @var{make-args}
@var{make-args}で指定される引数とともに@code{make}プログラムを実行します。
これは、
@samp{shell make @var{make-args}}を実行するのと同じことです。
@end table

@node Commands, Running, Invocation, Top
@chapter @value{GDBN} コマンド

@value{GDBN}コマンドの名前は、
最初の2、
3文字に省略することができます。
ただし、
省略されたコマンド名があいまいであってはなりません。
さらに、
同じ@value{GDBN}コマンドを連続して使用する場合には、
@key{RET}キーを押すだけで十分です。
また、
@key{TAB}キーを押すことで、
途中まで入力されたコマンド名を補完させることができます
（複数の補完候補がある場合には、
その一覧を表示します）。

@menu
* Command Syntax::              @value{GDBN}に対するコマンドの指定
* Completion::                  コマンド名の補完
* Help::                        ヘルプの表示
@end menu

@node Command Syntax, Completion, Commands, Commands
@section コマンドの構文

@value{GDBN}コマンドは1行で入力されます。
1行の長さには上限がありません。
行は、
コマンド名で始まり、
コマンド名によって意味が決まる引数がそれに続きます。
例えば、
@code{step}コマンドは@code{step}を実行する回数を引数に取ります。
例えば、
@samp{step 5}のようになります。
@code{step}コマンドは引数なしでも実行可能です。
コマンドによっては、
全く引数を受け付けないものもあります。

@cindex abbreviation
@cindex 省略形[しょうりゃくけい]
@cindex 短縮形[たんしゅくけい]
@cindex 略称[りゃくしょう]
@value{GDBN}コマンド名は省略可能です。
ただし、
省略された名前があいまいなものではあってはなりません。
省略形は、
それぞれのコマンドのドキュメント内に記載されています。
場合によっては、
あいまいな省略形も許されることがあります。
例えば、
@code{s}は、
文字@code{s}で始まるコマンドがほかにも存在するにもかかわらず、
@code{step}コマンドの省略形として特別に定義されています。
ある省略形が使用可能か否かは、
それを@code{help}コマンドへの引数として使用することで判定可能です。

@cindex repeating commands
@cindex コマンドの繰り返し[コマンドのくりかえし]
@cindex 繰り返し、コマンドの[くりかえし、コマンドの]
@kindex RET
@value{GDBN}への入力として空行を与える
（@key{RET}キーだけを押す）
ことは、
1つ前に実行したコマンドを繰り返すということを意味します。
ただし、
いくつかのコマンド
（例えば、@code{run}コマンド）は、
この方法で実行を繰り返すことはできません。
意図に反して再実行してしまうと問題を引き起こす可能性があるため、
繰り返し実行してほしくないようなコマンドの場合です。

@code{list}コマンドと@code{x}コマンドは、
@key{RET}キーにより繰り返し実行すると、
新たに引数が生成されて実行されるので、
前回実行されたときと全く同様の状態で繰り返し実行されるわけではありません。
こうすることで、
ソース・コードの内容やメモリの内容を容易に調べることができます。

@value{GDBN}は、
別の用途でも@key{RET}キーを使用します。
@code{more}ユーティリティと同様の方法で、
長い出力を分割して表示する場合です
（@pxref{Screen Size,,Screen size}）。
このような場合、
@key{RET}キーを余分に押してしまうことは往々にしてありえるので、
@value{GDBN}はこのような表示方法を使用しているコマンドについては、
@key{RET}キーによる繰り返し実行を行いません。

@kindex #
@cindex comment
@cindex コメント
テキストの中に@kbd{#}記号があると、
そこから行末まではコメントになります。
コメントの部分は実行されません。
これは、
特にコマンド・ファイルの中で便利です
（@pxref{Command Files,,Command files}）。

@node Completion, Help, Command Syntax, Commands
@section コマンド名の補完

@cindex completion
@cindex word completion
@cindex 単語の補完[たんごのほかん]
@cindex 補完[ほかん]
途中まで入力されたコマンド名は、
それがあいまいでなければ、
@value{GDBN}が残りの部分を補完してくれます。
また、
いつでも、
コマンド名の補完候補の一覧を表示してくれます。
この機能は、
@value{GDBN}コマンド名、
@value{GDBN}サブ・コマンド名、
ユーザ・プログラムのシンボル名に対して有効です。

@value{GDBN}に単語の残りの部分を補完させたい場合には、
@key{TAB}キーを押します。
補完候補が1つしか存在しない場合、
@value{GDBN}は残りの部分を補完し、
ユーザがコマンドを
（@key{RET}キーを押すことで）
完結させるのを待ちます。
例えば、
ユーザが以下のように入力したとしましょう。

@c FIXME "@key" does not distinguish its argument sufficiently to permit
@c complete accuracy in these examples; space introduced for clarity.
@c If texinfo enhancements make it unnecessary, it would be nice to
@c replace " @key" by "@key" in the following...
@example
(@value{GDBP}) info bre @key{TAB}
@end example

@noindent
@value{GDBN}は@samp{breakpoints}という単語の残りの部分を補完します。
なぜなら、
@code{info}コマンドのサブ・コマンドのうち、
@samp{bre}で始まるのはこの単語だけだからです。

@example
(@value{GDBP}) info breakpoints
@end example

@noindent
この時点で、
ユーザは@key{RET}キーを押して@code{info breakpoints}コマンドを実行するか、
あるいは@samp{breakpoints}コマンドが実行したいコマンドではなかった場合には、
バックスペース・キーを押してこれを消去してから、
他の文字を入力することができます
（最初から@code{info breakpoints}コマンドを実行するつもりであれば、
コマンド名補完機能ではなくコマンド名の省略形を利用して、
@samp{info bre}と入力した後、
ただちに@key{RET}キーを押してもいいでしょう）。

@key{TAB}キーが押されたときに、
2つ以上の補完候補が存在する場合、
@value{GDBN}はベル音を鳴らします。
さらにいくつか文字を入力してから補完を再度試みることも可能ですし、
単に続けて@key{TAB}キーを押すことも可能です。
後者の場合、
@value{GDBN}は補完候補の全一覧を表示します。
例えば、
@samp{make_}で始まる名前を持つサブルーチンにブレイクポイントを設定したいような場合に、
@kbd{b make_}まで入力して@key{TAB}キーを入力したところベル音が鳴ったとしましょう。
ここで続けて@key{TAB}キーを入力すると、
プログラム内の@samp{make_}で始まるすべてのサブルーチン名が表示されます。
例えば、
以下のように入力したとします。

@example
(@value{GDBP}) b make_ @key{TAB}
@end example

@noindent
ここで@value{GDBN}はベル音を鳴らします。
もう一度@key{TAB}キーを入力すると、
以下のように表示されます。

@example
make_a_section_from_file     make_environ               
make_abs_section             make_function_type         
make_blockvector             make_pointer_type          
make_cleanup                 make_reference_type        
make_command                 make_symbol_completion_list
(@value{GDBP}) b make_
@end example

@noindent
補完候補を表示した後、
ユーザが続きを入力できるよう、
@value{GDBN}は途中まで入力された文字列
（ここでは@samp{b make_}）
を再表示します。

最初から補完候補の一覧を表示したいのであれば、
@key{TAB}キーを2回押す代わりに@kbd{M-?}を入力することもできます。
ここで、
@kbd{M-?}というのは@kbd{@key{META} ?}を意味します。
これを入力するには、
@ifclear DOSHOST
キーボード上に@key{META}シフト・キーとして指定されたキーがあれば、
それを押しながら@kbd{?}を入力します。
@key{META}シフト・キーがない場合には、
@end ifclear
@key{ESC}キーを押した後、
@kbd{?}を入力します。

@cindex quotes in commands
@cindex completion of quoted strings
@cindex コマンド内の引用[コマンドないのいんよう]
@cindex 引用、コマンド内の[いんよう、コマンドないの]
@cindex 引用文字列の補完[いんようもじれつのほかん]
@cindex 補完、引用文字列の[ほかん、いんようもじれつの]
@cindex クオート
ときには、
入力したい文字列が、
論理的には『単語』であっても、
@value{GDBN}が通常は単語の一部に含めない括弧のような文字を含む場合があります。
このような場合に単語の補完機能を使用するためには、
@value{GDBN}コマンド内において、
そのような単語を@code{'}
（単一引用符）
で囲みます。

@ifclear CONLY
このようなことが必要になる可能性が最も高いのは、
C++関数名を入力するときでしょう。
これは、
C++が関数のオーバーローディング
（引数の型の違いによって識別される、
同一の名前を持つ関数の複数の定義）
をサポートしているからです。
例えば、
関数@code{name}にブレイクポイントを設定する場合、
それが@code{int}型のパラメータを取る@code{name(int)}なのか、
それとも@code{float}型のパラメータを取る@code{name(float)}なのかをはっきりさせる必要があります。
このような場合に単語の補完機能を使用するには、
単一引用符@code{'}を関数名の前に入力します。
こうすることによって、
@key{TAB}キーまたは@kbd{M-?}キーが押されて単語補完が要求されたときに、
補完候補の決定には通常よりも多くのことを検討する必要のあることが@value{GDBN}に通知されます。

@example
(@value{GDBP}) b 'bubble( @key{M-?}
bubble(double,double)    bubble(int,int)
(@value{GDBP}) b 'bubble(
@end example

場合によっては、
名前の補完をするには引用符を使用する必要があるということを、
@value{GDBN}が自分で認識できることもあります。
このような場合、
ユーザが引用符を入力していなくても、
@value{GDBN}が
（可能な限り補完を行いつつ）
引用符を挿入してくれます。

@example
(@value{GDBP}) b bub @key{TAB}
@exdent @value{GDBN}は入力された1行を以下のように変更し、
ベル音を鳴らします。
(@value{GDBP}) b 'bubble(
@end example

@noindent
一般的には、
オーバーロードされたシンボルに対して補完が要求された際に引数リストがまだ入力されていないと、
@value{GDBN}は、
引用符が必要であると判断します
（そして実際に挿入します）。

オーバーロードされた関数に関する情報については、
@pxref{Cplus expressions, ,C++ expressions}。
コマンド@code{set overload-resolution off}を使用すれば、
オーバーロードの解決を無効化することができます。
@pxref{Debugging C plus plus, ,@value{GDBN} features for C++}。
@end ifclear


@node Help,  , Completion, Commands
@section ヘルプの表示
@cindex online documentation
@cindex オンライン文書[オンラインぶんしょ]
@cindex 説明文字列[せつめいもじれつ]
@cindex ヘルプ情報[ヘルプじょうほう]
@kindex help

@code{help}コマンドを使うことで、
@value{GDBN}コマンドに関するヘルプ情報を@value{GDBN}自身に表示させることができます。

@table @code
@kindex h
@item help
@itemx h
@code{help}コマンド
（省略形は@code{h}）
を引数なしで実行することで、
コマンドのクラス名の簡単な一覧を表示させることができます。

@smallexample
(@value{GDBP}) help
List of classes of commands:

running -- Running the program
stack -- Examining the stack
data -- Examining data
breakpoints -- Making program stop at certain points
files -- Specifying and examining files
status -- Status inquiries
support -- Support facilities
user-defined -- User-defined commands
aliases -- Aliases of other commands
obscure -- Obscure features

Type "help" followed by a class name for a list of 
commands in that class.
Type "help" followed by command name for full 
documentation.
Command name abbreviations are allowed if unambiguous.
(@value{GDBP})
@end smallexample

@item help @var{class}
一般的なクラス名を引数に指定することで、
そのクラスに属するコマンドの一覧を表示させることができます。
@code{status}クラスを指定した場合の表示例を以下に示します。

@smallexample
(@value{GDBP}) help status
Status inquiries.

List of commands:

@c Line break in "show" line falsifies real output, but needed
@c to fit in smallbook page size.
show -- Generic command for showing things set
 with "set"
info -- Generic command for printing status

Type "help" followed by command name for full 
documentation.
Command name abbreviations are allowed if unambiguous.
(@value{GDBP})
@end smallexample

@item help @var{command}
@code{help}の引数にコマンド名を指定することで、
そのコマンドの使用法に関する簡単な説明が表示されます。

@kindex complete
@item complete @var{args}
@code{complete @var{args}}コマンドにコマンド名の先頭の部分を指定すると、
コマンド名の補完候補の一覧を表示します。
@var{args}には、
補完されるべきコマンド名の先頭の文字列を指定します。
例えば、

@smallexample
complete i
@end smallexample

@noindent
は、以下のような結果を表示します。

@smallexample
@group
info
inspect
ignore
@end group
@end smallexample

@noindent
これは、
@sc{gnu} Emacsでの使用を想定したものです。
@end table

@code{help}コマンドに加えて、
@value{GDBN}の@code{info}コマンドおよび@code{show}コマンドを使用することで、
ユーザ・プログラムの状態や@value{GDBN}の状態を問い合わせることができます。
どちらのコマンドも、
多くの観点からの問い合わせをサポートしています。
このマニュアルでは、
それぞれを適切と思われる箇所で紹介しています。
索引の@code{info}や@code{show}の部分に、
それぞれのサブ・コマンドの紹介されているページが示されています。
@xref{Index}。

@c @group
@table @code
@kindex info
@kindex i
@item info
このコマンド
（省略形は@code{i}）
は、
ユーザ・プログラムの状態を表わす情報を表示するものです。
例えば、
@code{info args}によってユーザ・プログラムに与えられた引数を、
@code{info registers}によって現在使用中のレジスタの一覧を、
@code{info breakpoints}によってユーザが設定したブレイクポイントの一覧を、
それぞれ表示することができます。
@w{@code{help info}}によって、
@code{info}コマンドのサブ・コマンドの完全な一覧が表示されます。

@kindex set
@item set
@code{set}コマンドによって、
ある式の評価結果を環境変数に割り当てることができます。
例えば、
@value{GDBN}のプロンプト文字列を$記号に変更するには、
@code{set prompt $}を実行します。

@kindex show
@item show
@code{info}コマンドとは異なり、
@code{show}コマンドは@value{GDBN}自身の状態を表わす情報を表示するものです。
@code{show}コマンドで表示可能な状態はすべて、
対応する@code{set}コマンドで変更可能です。
例えば、
数値の表示に使用する基数は
@code{set radix}コマンドで制御できます。
現在どの基数が使用されているかを単に知るためには、
@code{show radix}コマンドを使用します。

@kindex info set
変更可能なすべてのパラメータとそれらの現在の値を表示するためには、
@code{show}コマンドを引数なしで実行します。
また、
@code{info set}コマンドを使用することもできます。
どちらのコマンドも、
同じ情報を出力します。
@c FIXME: "info set" violates the rule that "info" is for state of
@c FIXME...program.  Ck w/ GNU: "info set" to be called something else,
@c FIXME...or change desc of rule---eg "state of prog and debugging session"?
@end table
@c @end group

以下に、
対応する@code{set}コマンドを持たないという意味で例外的である、
3つの@code{show}サブ・コマンドを示します。

@table @code
@kindex show version
@cindex version number
@cindex バージョン番号[バージョンばんごう]
@item show version
実行中の@value{GDBN}のバージョンを表示します。
@value{GDBN}に関する障害レポートには、
この情報を含める必要があります。
もしも異なるバージョンの@value{GDBN}を複数使用しているのであれば、
ときには現在実行している@value{GDBN}のバージョンをはっきりさせたいこともあるでしょう。
@value{GDBN}のバージョンが上がるにつれ、
新しいコマンドが導入され、
古いコマンドはサポートされなくなるかもしれません。
バージョン番号は、
@value{GDBN}の起動の際にも表示されます。

@kindex show copying
@item show copying
@value{GDBN}のコピー作成許可に関する情報が表示されます。

@kindex show warranty
@item show warranty
@sc{gnu}の『無保証
（NO WARRANTY）』声明文が表示されます。
@end table

@node Running, Stopping, Commands, Top
@chapter @value{GDBN}配下でのプログラムの実行

プログラムを@value{GDBN}配下で実行するには、
コンパイル時にデバッグ情報を生成する必要があります。
@ifclear BARETARGET
ユーザが選択した環境で、
必要に応じて引数を指定して、
@value{GDBN}を起動することができます。
プログラムの入力元と出力先をリダイレクトすること、
既に実行中のプロセスをデバッグすること、
子プロセスを終了させることもできます。
@end ifclear

@menu
* Compilation::                 デバッグのためのコンパイル
* Starting::                    ユーザ・プログラムの起動
@ifclear BARETARGET
* Arguments::                   ユーザ・プログラムの引数
* Environment::                 ユーザ・プログラムの環境
@end ifclear

* Working Directory::           ユーザ・プログラムの作業ディレクトリ
* Input/Output::                ユーザ・プログラムの入出力
* Attach::                      既に実行中のプロセスのデバッグ
* Kill Process::                子プロセスの終了
@ifclear HPPA
* Process Information::         追加のプロセス情報
@end ifclear

* Threads::                     マルチスレッド・プログラムのデバッグ
* Processes::                   マルチプロセス・プログラムのデバッグ
@end menu

@node Compilation, Starting, Running, Running
@section デバッグのためのコンパイル

プログラムを効率的にデバッグするためには、
そのプログラムのコンパイル時にデバッグ情報を生成する必要があります。
このデバッグ情報はオブジェクト・ファイルに格納されます。
この情報は、
個々の変数や関数の型、
ソース・コード内の行番号と実行形式コードのアドレスとの対応などを含みます。

デバッグ情報の生成を要求するには、
コンパイラの実行時に@samp{-g}オプションを指定します。

多くのCコンパイラでは、
@samp{-g}オプションと@samp{-O}オプションを同時に指定することができません。
このようなコンパイラでは、
デバッグ情報付きの最適化された実行ファイルを生成することができません。

@ifclear HPPA
@sc{gnu}のCコンパイラである@value{NGCC}は、
@end ifclear
@ifset HPPA
@sc{gnu}のCコンパイラである@value{NGCC}のほかに、
HP ANSI CコンパイラとHP ANSI C++コンパイラも、
@end ifset
@samp{-O}オプションの有無にかかわらず、
@samp{-g}オプションが指定できます。
したがって、
最適化されたコードをデバッグすることが可能です。
プログラムをコンパイルするときには、
@emph{常に}@samp{-g}オプションを指定することをお勧めします。
自分のプログラムは正しいと思うかもしれませんが、
自分の幸運を信じて疑わないというのは無意味なことです。

@cindex optimized code, debugging
@cindex debugging optimized code
@cindex 最適化コードのデバッグ[さいてきかコードのデバッグ]
@cindex デバッグ、最適化コードの[デバッグ、さいてきかコードの]
@samp{-g -O}オプションを指定してコンパイルされたプログラムをデバッグするときには、
オプティマイザがコードを再調整していることを忘れないでください。
デバッガは、
実際に存在するコードの情報を表示します。
実行されるパスがソース・ファイルの記述と一致していなくても、
あまり驚かないでください。
これは極端な例ですが、
定義されているが実際には使われていない変数を、
@value{GDBN}は認識しません。
なぜなら、
コンパイラの最適化処理により、
そのような変数は削除されるからです。

命令スケジューリング機能を持つマシンなどでは、
@samp{-g}を指定してコンパイルされたプログラムでは正しく動作することが、
@samp{-g -O}を指定してコンパイルされたプログラムでは正しく動作しないということがあります。
@samp{-g -O}を指定してコンパイルされたプログラムのデバッグで何かおかしな点があれば、
@samp{-g}だけを指定してコンパイルしてみてください。
これで問題が解決するようであれば、
（再現環境と一緒に）
障害として私たちに報告してください。

古いバージョンの@sc{gnu} Cコンパイラは、
デバッグ情報の生成のためのオプションの1つとして
@w{@samp{-gg}}をサポートしていました。
現在の@value{GDBN}はこのオプションをサポートしていません。
お手元の@sc{gnu} Cコンパイラにこのオプションがあるようであれば、
それは使わないでください。

@need 2000
@node Starting, Arguments, Compilation, Running
@section ユーザ・プログラムの起動
@cindex starting
@cindex running
@cindex 開始[かいし]
@cindex 起動[きどう]
@cindex 実行[じっこう]

@table @code
@kindex run
@item run
@itemx r
@value{GDBN}配下でユーザ・プログラムの実行を開始するには@code{run}コマンドを使用してください。
@ifset VXWORKS
（VxWorks以外の環境では）
@end ifset
最初にプログラム名を指定する必要があります。
これには、
@value{GDBN}への引数を使用する方法
（@pxref{Invocation, ,Getting In and Out of @value{GDBN}}）
と、
@code{file}コマンドまたは@code{exec-file}コマンドを使用する方法
（@pxref{Files, ,Commands to specify files}）
とがあります。

@end table

@ifclear BARETARGET
プロセスをサポートする環境でプログラムを実行している場合、
@code{run}コマンドは下位プロセスを生成し、
そのプロセスにプログラムを実行させます
（プロセスをサポートしていない環境では、
@code{run}コマンドはプログラムの先頭アドレスにジャンプします）。

プログラムの実行は、
上位プロセスから受け取る情報によって影響されます。
@value{GDBN}はこの情報を指定する手段を提供しています。
これは、
ユーザ・プログラムが起動される@emph{前}に実行されていなければなりません
（ユーザ・プログラムの実行後にその情報を変更することも可能ですが、
その変更結果は、
次にプログラムを実行したときに初めて有効になります）。
この情報は、
4つに分類することができます。

@table @asis
@item @emph{引数}
ユーザ・プログラムに与える引数を、
@code{run}コマンドへの引数として指定します。
ターゲット上でシェルが使用可能であれば、
引数を表現するのに通常使用する手法
（例えば、
ワイルドカード拡張や変数による代替など）
が利用できるよう、
シェルを経由して引数を渡します。
UNIXシステムでは、
@code{SHELL}環境変数によって、
使用されるシェルを選択することができます。
@xref{Arguments, ,Your program's arguments}。

@item @emph{環境}
ユーザ・プログラムは通常、
@value{GDBN}の環境を継承します。
@value{GDBN}の@code{set environment}コマンドと
@code{unset environment}コマンドを使用して、
ユーザ・プログラムの実行に影響する環境の一部を変更することができます。
@xref{Environment, ,Your program's environment}。

@item @emph{作業ディレクトリ}
ユーザ・プログラムは@value{GDBN}の作業ディレクトリを継承します。
@value{GDBN}の作業ディレクトリは、
@value{GDBN}の@code{cd}コマンドで設定可能です。
@xref{Working Directory, ,Your program's working directory}。

@item @emph{標準入力、標準出力}
ユーザ・プログラムは通常、
@value{GDBN}が標準入力、
標準出力として使用しているのと同一のデバイスを、
標準入力、
標準出力として使用します。
@code{run}コマンドのコマンド・ライン上で、
標準入力、
標準出力をリダイレクトすることも可能です。
また、
@code{tty}コマンドによって別のデバイスを割り当てることも可能です。
@xref{Input/Output, ,Your program's input and output}。

@cindex pipes
@cindex パイプ
@emph{注意:} 入出力のリダイレクトは機能しますが、
デバッグ中のプログラムの出力を、
パイプを使用して他のプログラムに渡すことはできません。
このようなことをすると、
@value{GDBN}は誤って、
別のプログラムのデバッグを開始してしまうでしょう。
@end table
@end ifclear

@code{run}コマンドを実行すると、
ユーザ・プログラムはすぐに実行を始めます。
プログラムを停止させる方法については、
@xref{Stopping, ,Stopping and continuing}。
プログラムが停止すると、
@code{print}コマンドまたは@code{call}コマンドを使用して、
プログラム内の関数を呼び出すことができます。
@xref{Data, ,Examining Data}。

@value{GDBN}が最後にシンボル情報を読み込んだ後に、
シンボル・ファイルの修正タイムスタンプが変更されている場合、
@value{GDBN}はシンボル・テーブルを破棄し再読み込みを行います。
この場合、
@value{GDBN}は、
その時点におけるブレイクポイントの設定を保持しようと試みます。

@ifclear BARETARGET
@node Arguments, Environment, Starting, Running
@section ユーザ・プログラムの引数

@cindex arguments (to your program)
@cindex ユーザ・プログラムへの引数[ユーザ・プログラムへのひきすう]
@cindex 引数、ユーザ・プログラムへの[ひきすう、ユーザ・プログラムへの]
ユーザ・プログラムへの引数は、
@code{run}コマンドへの引数によって指定可能です。
それはまずシェルに渡され、
ワイルドカードの展開やI/Oのリダイレクトの後、
プログラムに渡されます。
@code{SHELL}環境変数によって、
@value{GDBN}の使用するシェルが指定されます。
@code{SHELL}環境変数が定義されていないと、
@value{GDBN}は@code{/bin/sh}を使用します。

引数を指定せずに
@code{run}コマンドを実行すると、
前回@code{run}コマンドを実行したときの引数、
または、
@code{set args}コマンドでセットされた引数が使用されます。

@kindex set args
@table @code
@item set args
ユーザ・プログラムが次に実行されるときに使用される引数を指定します。
@code{set args}が引数なしで実行された場合、
@code{run}コマンドは、
ユーザ・プログラムを引数なしで実行します。
一度プログラムに引数を指定して実行すると、
次にプログラムを引数なしで実行する唯一の方法は、
@code{run}コマンドを実行する前に
@code{set args}コマンドを実行することです。

@kindex show args
@item show args
ユーザ・プログラムが実行されるときに渡される引数を表示します。
@end table

@node Environment, Working Directory, Arguments, Running
@section ユーザ・プログラムの環境

@cindex environment (of your program)
@cindex ユーザ・プログラムの環境[ユーザ・プログラムのかんきょう]
@cindex 環境、ユーザ・プログラムの[かんきょう、ユーザ・プログラムの]
@dfn{環境}とは、
環境変数とその値の集合のことです。
環境変数は、
慣例として、
ユーザ名、
ユーザのホーム・ディレクトリ、
端末タイプ、
実行プログラムのサーチ・パスなどを記録します。
通常、
環境変数はシェル上で設定され、
ユーザの実行するすべてのプログラムによって継承されます。
デバッグ時には、
@value{GDBN}を終了・再起動せずに環境を変更して、
ユーザ・プログラムを実行できると便利でしょう。

@table @code
@kindex path
@item path @var{directory}
@var{directory}で指定されるディレクトリを環境変数@code{PATH}
（実行ファイルのサーチ・パス）
の先頭に追加します。
これは、
@value{GDBN}とユーザ・プログラムの両方に対して有効です。
@samp{:}
（コロン）
またはスペースで区切られた複数のディレクトリを指定することもできます。
環境変数@code{PATH}の中に既に@var{directory}が含まれている場合には、
@var{directory}は環境変数@code{PATH}の先頭に移動されます。
これにより、
@var{directory}はより早く検索されることになります。

文字列@samp{$cwd}によって、
@value{GDBN}がパスを検索する時点における作業ディレクトリを参照することができます。
@samp{.}
（ピリオド）
を使用すると、
@code{path}コマンドを実行したディレクトリを参照することになります。
@var{directory}引数に@samp{.}
（ピリオド）
が含まれていると、
@value{GDBN}はまずそれを
（カレント・ディレクトリに）
置き換えてから、
サーチ・パスに追加します。
@c 'path' is explicitly nonrepeatable, but RMS points out it is silly to
@c document that, since repeating it would be a no-op.

@kindex show paths
@item show paths
実行ファイルを検索するパスの一覧
（環境変数@code{PATH}の値）を表示します。

@kindex show environment
@item show environment @r{[}@var{varname}@r{]}
ユーザ・プログラム起動時に渡される環境変数@var{varname}の値を表示します。
@var{varname}が指定されない場合は、
プログラムに渡されるすべての環境変数の名前と値が表示されます。
@code{environment}は@code{env}に省略可能です。

@kindex set environment
@item set environment @var{varname} @r{[}=@r{]} @var{value}
環境変数@var{varname}の値として@var{value}をセットします。
値の変更はユーザ・プログラムに対してのみ有効で、
@value{GDBN}に対しては無効です。
@var{value}には任意の文字列が指定可能です。
環境変数の値は単なる文字列であり、
その解釈はユーザ・プログラムに委ねられています。
@var{value}は必須パラメータではありません。
省略された場合には、
変数には空文字列がセットされます。
@c "any string" here does not include leading, trailing
@c blanks. Gnu asks: does anyone care?

例えば、
以下のコマンドは、
後にUNIXプログラムが実行されるときのユーザ名として@samp{foo}をセットします
（@samp{=}の前後のスペースは見やすくするためのもので、
実際には必要ありません）。

@example
set env USER = foo
@end example

@kindex unset environment
@item unset environment @var{varname}
ユーザ・プログラムに渡される環境から、
環境変数@var{varname}を削除します。
これは、
@samp{set env @var{varname} =}とは異なります。
@code{unset environment}は、
環境変数の値として空文字列をセットするのではなく、
環境変数そのものを環境から削除します。
@end table

@emph{注意:} @value{GDBN}は、
環境変数@code{SHELL}により指定されるシェル
（環境変数@code{SHELL}が設定されていない場合には@code{/bin/sh}）
を使用してプログラムを実行します。
@code{SHELL}環境変数の指定するシェルが初期化ファイルを実行するものである場合
（例えば、
C-shellの@file{.cshrc}、
BASHの@file{.bashrc}）、
初期化ファイルの中で設定された環境変数はユーザ・プログラムに影響を与えます。
環境変数の設定は、
@file{.login}や@file{.profile}のように、
ユーザがシステム内に入るときに実行されるファイルに移したほうがよいでしょう。

@node Working Directory, Input/Output, Environment, Running
@section ユーザ・プログラムの作業ディレクトリ

@cindex working directory (of your program)
@cindex ユーザ・プログラムの作業ディレクトリ[ユーザ・プログラムのさぎょうディレクトリ]
@cindex 作業ディレクトリ、ユーザ・プログラムの[さぎょうディレクトリ、ユーザ・プログラムへの]
@code{run}コマンドで実行されるユーザ・プログラムは、
実行時の@value{GDBN}の作業ディレクトリを継承します。
@value{GDBN}の作業ディレクトリは、
もともと親プロセス
（通常はシェル）
から継承したものですが、
@code{cd}コマンドによって、
@value{GDBN}の中から新しい作業ディレクトリを指定することができます。

@value{GDBN}の作業ディレクトリは、
@value{GDBN}によって操作されるファイルを指定するコマンドに対して、
デフォルト・ディレクトリとして機能します。
@xref{Files, ,Commands to specify files}。

@table @code
@kindex cd
@item cd @var{directory}
@value{GDBN}の作業ディレクトリを@var{directory}にします。

@kindex pwd
@item pwd
@value{GDBN}の作業ディレクトリを表示します。
@end table

@node Input/Output, Attach, Working Directory, Running
@section ユーザ・プログラムの入出力

@cindex redirection
@cindex i/o
@cindex terminal
@cindex リダイレクト
@cindex 入出力[にゅうしゅつりょく]
@cindex 端末[たんまつ]
@value{GDBN}配下で実行されるプログラムは、
デフォルトでは、
@value{GDBN}と同一の端末に対して入出力を行います。
@value{GDBN}は、
ユーザとのやりとりのために、
端末モードを@value{GDBN}用に変更します。
このとき、
ユーザ・プログラムが使用していた端末モードは記録され、
ユーザ・プログラムを継続実行すると、
そのモードに戻ります。

@table @code
@kindex info terminal
@item info terminal
ユーザ・プログラムが使用している端末モードに関して@value{GDBN}が記録している情報を表示します。
@end table

@code{run}コマンドにおいてシェルのリダイレクト機能を使用することによって、
ユーザ・プログラムの入出力をリダイレクトすることが可能です。
例えば、

@example
run > outfile
@end example

@noindent
はユーザ・プログラムの実行を開始し、
その出力をファイル@file{outfile}に書き込みます。

@kindex tty
@cindex controlling terminal
@cindex 制御端末[せいぎょたんまつ]
ユーザ・プログラムの入出力先を指定する別の方法に、
@code{tty}コマンドがあります。
このコマンドはファイル名を引数として取り、
そのファイルを後に実行される@code{run}コマンドのデフォルトの入出力先とします。
このコマンドはまた、
後の@code{run}コマンドにより生成される子プロセスを制御する端末を変更します。
例えば、

@example
tty /dev/ttyb
@end example

@noindent
は、
それ以降に実行される@code{run}コマンドによって起動されるプロセスの
デフォルトの入出力先および制御端末を@file{/dev/ttyb}端末とします。

@code{run}コマンド実行時に明示的にリダイレクト先を指定することで、
@code{tty}コマンドで指定された入出力装置を変更することができますが、
制御端末の設定は変更できません。

@code{tty}コマンドを使用した場合も、
@code{run}コマンドで入力をリダイレクトした場合も、
ユーザ・プログラムの入力元だけが変更されます。
これらのコマンドを実行しても、
@value{GDBN}の入力元は、ユーザの使用している端末のままです。

@node Attach, Kill Process, Input/Output, Running
@section 既に実行中のプロセスのデバッグ
@kindex attach
@cindex attach
@cindex アタッチ

@table @code
@item attach @var{process-id}
@value{GDBN}の外で起動され、
既に実行中のプロセスにアタッチします
（@code{info files}コマンドで、
現在デバッグ対象となっているプログラムの情報が表示されます）。
このコマンドは、
プロセスIDを引数に取ります。
UNIXプロセスのプロセスIDを知るのに通常使用する方法は、
@code{ps}ユーティリティ、
または、
シェル・コマンドの@samp{jobs -l}の実行です。

@code{attach}コマンドを実行後@key{RET}キーを押しても、
コマンドは再実行されません。
@end table

@code{attach}コマンドを使用するには、
プロセスをサポートする環境でユーザ・プログラムを実行する必要があります。
例えば、
オペレーティング・システムの存在しないボード・コンピュータのような環境で動作するプログラムに対して、
@code{attach}コマンドを使うことはできません。
さらに、
ユーザは、
プロセスに対してシグナルを送信する権利を持っている必要があります。

@code{attach}コマンドを使用すると、
デバッガは、
まずカレントな作業ディレクトリの中で、
プロセスにより実行されているプログラムを見つけようとします。
（プログラムが見つからなければ）
次に、
ソース・ファイルのサーチ・パス
（@pxref{Source Path, ,Specifying source directories}）
を使用して、
プログラムを見つけようとします。
@code{file}コマンドを使用して、
プログラムをロードすることも可能です。
@xref{Files, ,Commands to Specify Files}。

指定されたプロセスをデバッグする準備が整った後に、
@value{GDBN}が最初にすることは、
そのプロセスを停止することです。
@code{run}コマンドを使用してプロセスを起動した場合は、
通常使用可能なすべての@value{GDBN}コマンドを使用して、
アタッチされたプロセスの状態を調べたり変更したりすることができます。
@ifclear HPPA
ブレイクポイントの設定、
@end ifclear
@ifset HPPA
（共用ライブラリの中を除く）
ブレイクポイントの設定、
@end ifset
ステップ実行、
継続実行、
記憶域の内容の変更が可能です。
プロセスの実行を継続したいのであれば、
@value{GDBN}がプロセスにアタッチした後に、
@code{continue}コマンドを使用することができます。

@table @code
@kindex detach
@item detach
アタッチされたプロセスのデバッグが終了した場合には、
@code{detach}コマンドを使用してそのプロセスを@value{GDBN}の管理から解放することができます。
プロセスからディタッチしても、
そのプロセスは実行を継続します。
@code{detach}コマンド実行後は、
ディタッチされたプロセスと
@value{GDBN}は互いに完全に依存関係がなくなり、
@code{attach}コマンドによる別のプロセスへのアタッチや、
@code{run}コマンドによる別のプロセスの起動が可能になります。
@code{detach}コマンドを実行後@key{RET}キーを押しても、
@code{detach}コマンドは再実行されません。
@end table

プロセスがアタッチされている状態で、
@value{GDBN}を終了したり@code{run}コマンドを使用したりすると、
アタッチされたプロセスを終了させてしまいます。
デフォルトの状態では、
このようなことを実行しようとすると、
@value{GDBN}が確認を求めてきます。
この確認処理を行うか否かは、
@code{set confirm}コマンドで設定可能です
（@pxref{Messages/Warnings, ,Optional warnings and messages}）。

@ifset HPPA
@node Kill Process, Threads, Attach, Running
@section 子プロセスの終了
@end ifset
@ifclear HPPA
@node Kill Process, Process Information, Attach, Running
@section 子プロセスの終了
@end ifclear

@table @code
@kindex kill
@item kill
@value{GDBN}配下で実行しているユーザ・プログラムのプロセスを終了させます。
@end table

このコマンドは、
実行中のプロセスではなく、
コア・ダンプをデバッグしたいときに便利です。
@value{GDBN}は、
ユーザ・プログラムの実行中は、
コア・ダンプ・ファイルを無視します。

いくつかのオペレーティング・システム上では、
@value{GDBN}の管理下でブレイクポイントを設定されている状態のプログラムを、
@value{GDBN}の外で実行することができません。
このような場合、
@code{kill}コマンドを使用することで、デバッガの外でのプログラムの実行が可能になります。

@code{kill}コマンドは、
プログラムを再コンパイル、
再リンクしたい場合にも便利です。
というのは、
多くのシステムでは、
プロセスとして実行中の実行ファイルを更新することはできないからです。
次に@code{run}コマンドを実行したときに、
@value{GDBN}は、
実行ファイルが変更されていることを認識し、
シンボル・テーブルを再度読み込みます
（この際、その時点でのブレイクポイントの設定を維持しようと試みます）。

@ifclear HPPA
@node Process Information, Threads, Kill Process, Running
@section プロセス情報

@kindex /proc
@cindex process image
@cindex プロセスのイメージ
いくつかのオペレーティング・システムは、
@samp{/proc}と呼ばれる便利な機能を提供しています。
これは、
ファイル・システム関連のサブルーチンを使用して、
実行中プロセスのイメージを調べるのに使用することができます。
@value{GDBN}が、
この機能を持つオペレーティング・システム用に構成されていれば、
@code{info proc}コマンドを使用することで、
ユーザ・プログラムを実行しているプロセスに関するいくつかの情報を知ることができます。
@code{info proc}は、
@code{procfs}をサポートするSVR4システム上でのみ機能します。

@table @code
@kindex info proc
@item info proc
プロセスに関して入手可能な情報を要約して出力します。

@kindex info proc mappings
@item info proc mappings
プログラムがアクセスすることのできるアドレス範囲を表示します。
出力情報には、
それぞれのアドレス範囲に対してユーザ・プログラムが持つ読み込み権、
書き込み権、
実行権の情報が含まれます。

@kindex info proc times
@item info proc times
ユーザ・プログラムおよびその子
（プロセス）
の起動時刻、
ユーザ・レベルのCPU消費時間、
システム・レベルのCPU消費時間を表示します。

@kindex info proc id
@item info proc id
ユーザ・プログラムに関連のあるプロセスのID情報を表示します。
ユーザ・プログラムのプロセスID、
親（プロセス）のプロセスID、
プロセス・グループID、
セッションIDを出力します。

@kindex info proc status
@item info proc status
プロセスの状態に関する一般的な情報を出力します。
プロセスが停止している場合は、
停止した理由、
（シグナルを受信した場合には）
受信したシグナルが出力情報に含まれます。

@item info proc all
プロセスに関する上記の情報をすべて表示します。
@end table
@end ifclear

@ifset HPPA
@node Threads, Processes, Kill Process, Running
@section マルチスレッド・プログラムのデバッグ
@end ifset
@ifclear HPPA
@node Threads, Processes, Process Information, Running
@section マルチスレッド・プログラムのデバッグ
@end ifclear

@cindex threads of execution
@cindex multiple threads
@cindex switching threads
@cindex 実行のスレッド[じっこうのスレッド]
@cindex スレッド、実行の[スレッド、じっこうの]
@cindex 多重スレッド[たじゅうスレッド]
@cindex マルチスレッド
@cindex スレッドの切り替え[スレッドのきりかえ]
@cindex 切り替え、スレッドの[きりかえ、スレッドの]
HP-UXやSolarisのようなオペレーティング・システムにおいては、
1つのプログラムが複数の@dfn{スレッド}を実行することができます。
「スレッド」の正確な意味は、
オペレーティング・システムによって異なります。
しかし、
一般的には、
1つのアドレス空間を共有するという点を除けば、
プログラム内のマルチスレッドは、
マルチプロセスと類似しています
（アドレス空間の共有とは、
複数のスレッドが同一の変数の値を参照したり変更したりすることが可能であるということです）。
その一方で、
個々のスレッドは自分用のレジスタ、
実行スタック、
そしておそらくはプライベート・メモリを持ちます。

@value{GDBN}は、
マルチスレッド・プログラムのデバッグ用に、
以下のような便利な機能を提供しています。

@itemize @bullet
@item 新規スレッド生成の自動的な通知
@item スレッドを切り替えるコマンド@samp{thread @var{threadno}}
@item 既存のスレッドに関する情報を問い合わせるコマンド@samp{info threads}
@item 1つのコマンドを複数のスレッドに対して実行するコマンド@samp{thread apply [@var{threadno}] [@var{all}] @var{args}}
@item スレッド固有のブレイクポイント
@end itemize

@ifclear HPPA
@quotation
@emph{注意:} これらの機能は、
スレッドをサポートするオペレーティング・システム用に構成された
すべての@value{GDBN}で使用可能なわけではありません。
@value{GDBN}がスレッドをサポートしていない環境では、
これらのコマンドは無効です。
例えば、
スレッドをサポートしていないシステム上で
@value{GDBN}の@samp{info threads}コマンドを実行しても何も表示されませんし、
@code{thread}コマンドの実行は常に拒絶されます。

@smallexample
(@value{GDBP}) info threads
(@value{GDBP}) thread 1
Thread ID 1 not known.  Use the "info threads" command to
see the IDs of currently known threads.
@end smallexample
@c FIXME to implementors: how hard would it be to say "sorry, this GDB
@c                        doesn't support threads"?
@end quotation
@end ifclear

@cindex focus of debugging
@cindex current thread
@cindex デバッグの対象[デバッグのたいしょう]
@cindex 対象、デバッグの[たいしょう、デバッグの]
@cindex カレント・スレッド
@value{GDBN}のスレッド・デバッグ機能により、
ユーザ・プログラムの実行中に、
すべてのスレッドを観察することができます。
ただし、
@value{GDBN}に制御権のある状態では、
特定の1つのスレッドだけがデバッグの対象となります。
このスレッドは、
@dfn{カレント・スレッド}と呼ばれます。
デバッグ用のコマンドは、
カレント・スレッドの立場から見たプログラムの情報を表示します。

@ifclear HPPA
@kindex New @var{systag}
@cindex thread identifier (system)
@cindex システムのスレッド識別子[システムのスレッドしきべつし]
@cindex スレッド識別子、システムの[スレッドしきべつし、システムの]
@cindex 識別子、システムのスレッド[しきべつし、システムのスレッド]
@c FIXME-implementors!! It would be more helpful if the [New...] message
@c included GDB's numeric thread handle, so you could just go to that
@c thread without first checking `info threads'.
ユーザ・プログラム内部において新しいスレッドの存在を検出すると、
@value{GDBN}は、
@samp{[New @var{systag}]}という形式で、
ターゲット・システム上におけるこのスレッドのIDを表示します。
ここで@var{systag}とはスレッドのIDで、
その形式はシステムによって異なります。
例えば、
LynxOS上では、
@value{GDBN}が新しいスレッドを検出すると、

@example
[New process 35 thread 27]
@end example

@noindent
のように表示されます。
一方、
SGIのシステム上では、
@var{systag}は単に@samp{process 368}のような形式で、
これ以外の情報は含まれません。

@c FIXME!! (1) Does the [New...] message appear even for the very first
@c         thread of a program, or does it only appear for the
@c         second---i.e., when it becomes obvious we have a multithread
@c         program?
@c         (2) *Is* there necessarily a first thread always?  Or do some
@c         multithread systems permit starting a program with multiple
@c         threads ab initio?      

@cindex thread number
@cindex thread identifier (GDB)
@cindex @value{GDBN}のスレッド識別子[@value{GDBN}のスレッドしきべつし]
@cindex スレッド識別子、@value{GDBN}の[スレッドしきべつし、@value{GDBN}の]
@cindex 識別子、@value{GDBN}のスレッド[しきべつし、@value{GDBN}のスレッド]
@value{GDBN}は、
ユーザ・プログラム内の個々のスレッドに対して、
デバッグ用の整数値のスレッド番号を独自に割り当てます。

@table @code
@kindex info threads
@item info threads
その時点においてユーザ・プログラム中に存在するすべてのスレッドに関する要約を表示します。
個々のスレッドに関して、
以下の情報が
（列挙された順に）
表示されます。

@enumerate
@item
@value{GDBN}により割り当てられたスレッド番号

@item
ターゲット・システムのスレッドID（@var{systag}）

@item
スレッドのカレントなスタック・フレームの要約
@end enumerate

@noindent
@value{GDBN}により割り当てられたスレッド番号の左のアスタリスク@samp{*}は、
そのスレッドがカレント・スレッドであることを意味しています。

以下に例を示します。
@end table
@c end table here to get a little more width for example

@smallexample
(@value{GDBP}) info threads
  3 process 35 thread 27  0x34e5 in sigpause ()
  2 process 35 thread 23  0x34e5 in sigpause ()
* 1 process 35 thread 13  main (argc=1, argv=0x7ffffff8)
    at threadtest.c:68
@end smallexample
@end ifclear
@ifset HPPA

@cindex thread number
@cindex thread identifier (GDB)
@cindex @value{GDBN}のスレッド識別子[@value{GDBN}のスレッドしきべつし]
@cindex スレッド識別子、@value{GDBN}の[スレッドしきべつし、@value{GDBN}の]
@cindex 識別子、@value{GDBN}のスレッド[しきべつし、@value{GDBN}のスレッド]
@value{GDBN}は、
デバッグを行うために、
自身のスレッド番号
--スレッドの生成順に割り当てられるサイズの小さい整数値--
を、
ユーザ・プログラムの個々のスレッドに関連付けします。

@kindex New @var{systag}
@cindex thread identifier (system)
@cindex スレッド識別子（システム）[スレッドしきべつし（システム）]
@c FIXME-implementors!! It would be more helpful if the [New...] message
@c included GDB's numeric thread handle, so you could just go to that
@c thread without first checking `info threads'.
@value{GDBN}は、
ユーザ・プログラムの中に新しいスレッドの存在を検出するたびに、
@samp{[New @var{systag}]}という形式のメッセージで、
@value{GDBN}のスレッド番号とそのスレッドに対するターゲット・システムの識別子を表示します。
@var{systag}は、
特定のシステム毎に形式の異なるスレッド識別子です。
例えば、
HP-UX上では、
@value{GDBN}が新しいスレッドの存在を検出すると、

@example
[New thread 2 (system thread 26594)]
@end example

@noindent
というメッセージが表示されます。

@table @code
@kindex info threads
@item info threads
ユーザ・プログラムの中に現在存在するすべてのスレッドの要約情報を表示します。
@value{GDBN}は、
個々のスレッドに関して、
以下の情報を
（この順番で）
表示します。

@enumerate
@item @value{GDBN}によって割り当てられたスレッド番号

@item ターゲット・システムのスレッド識別子（@var{systag}）

@item そのスレッドの現在のスタック・フレームの要約情報
@end enumerate

@noindent
@value{GDBN}スレッド番号の左側にあるアスタリスク@samp{*}は、
そのスレッドが、
カレント・スレッドであることを示しています。

以下に、
例を示します。
@end table
@c end table here to get a little more width for example

@example
(@value{GDBP}) info threads
    * 3 system thread 26607  worker (wptr=0x7b09c318 "@@") at quicksort.c:137
      2 system thread 26606  0x7b0030d8 in __ksleep () from /usr/lib/libc.2
      1 system thread 27905  0x7b003498 in _brk () from /usr/lib/libc.2
@end example
@end ifset

@table @code
@kindex thread @var{threadno}
@item thread @var{threadno}
スレッド番号@var{threadno}を割り当てられたスレッドをカレント・スレッドとします。
このコマンドの引数@var{threadno}は、
@samp{info threads}コマンドの出力の最初のフィールドに表示される、
@value{GDBN}内部のスレッド番号です。
@value{GDBN}は、
指定されたスレッドのシステム上のIDとカレントなスタック・フレームの要約を表示します。

@smallexample
@c FIXME!! This example made up; find a @value{GDBN} w/threads and get real one
(@value{GDBP}) thread 2
@ifclear HPPA
[Switching to process 35 thread 23]
@end ifclear
@ifset HPPA
[Switching to thread 2 (system thread 26594)]
@end ifset
0x34e5 in sigpause ()
@end smallexample

@noindent
@samp{[New @dots{}]}メッセージと同様、
@samp{Switching to}の後ろに表示される情報の形式は、
そのシステムにおけるスレッドの識別方法に依存します。

@kindex thread apply
@item thread apply [@var{threadno}] [@var{all}]  @var{args}
@code{thread apply}コマンドにより、
1つのコマンドを1つ以上のスレッドに対して実行することができます。
実行対象となるスレッドのスレッド番号を、
引数@var{threadno}に指定します。
@var{threadno}は、
@samp{info threads}コマンドの出力の最初のフィールドに表示される、
@value{GDBN}内部のスレッド番号です。
すべてのスレッドに対してコマンドを実行するには、
@code{thread apply all} @var{args}コマンドを使用してください。
@end table

@cindex automatic thread selection
@cindex switching threads automatically
@cindex threads, automatic switching
@cindex スレッドの自動的選択[スレッドのじどうてきせんたく]
@cindex 自動的選択、スレッドの[じどうてきせんたく、スレッドの]
@value{GDBN}がユーザ・プログラムを停止させるとき、
その理由がブレイクポイントであれシグナルの受信であれ、
ブレイクポイントに到達したスレッド、
または、
シグナルを受信したスレッドが自動的に選択されます。
@value{GDBN}は、
@samp{[Switching to @var{systag}]}という形式のメッセージでそのスレッドを示し、
コンテキスト切り替えの発生に注意を促します。

複数スレッドを持つプログラムの停止時や起動時のGDBの動作の詳細については、
@xref{Thread Stops,,Stopping and starting multi-thread programs}。

また、
複数スレッドを持つプログラムの中におけるウォッチポイントについては、
@xref{Set Watchpoints,,Setting watchpoints}。
@end ifclear

@ifclear HPPA
@node Processes,  , Threads, Running
@section マルチプロセス・プログラムのデバッグ

@cindex fork, debugging programs which call
@cindex multiple processes
@cindex processes, multiple
@cindex @code{fork}を呼び出す関数のデバッグ[forkをよびだすかんすうのデバッグ]
@cindex マルチプロセス
@cindex プロセス、多重[プロセス、たじゅう]
@code{fork}関数を使用して新たにプロセスを生成するプログラムのデバッグに関しては、
@value{GDBN}は特別な機能を提供していません。
プログラムが@code{fork}を実行するとき、
@value{GDBN}
は引き続き親プロセスのデバッグを継続し、
子プロセスは妨げられることなく実行を続けます。
子プロセスが実行するコードにブレイクポイントを設定してあると、
子プロセスは@code{SIGTRAP}シグナルを受信し、
（そのシグナルをキャッチする処理がなければ）
子プロセスは終了してしまいます。

@cindex @code{sleep}
しかし、
子プロセスをデバッグしたい場合には、
それほど困難ではない回避策があります。
@code{fork}の呼び出し後に子プロセスが実行するソース・コードの中に、
@code{sleep}関数の呼び出しを加えてください。
@value{GDBN}に子プロセスのデバッグをさせる理由がないときに遅延が発生することのないように、
特定の環境変数が設定されているときのみ、
あるいは、
特定のファイルが存在するときのみ、
@code{sleep}関数を呼び出すようにするとよいでしょう。
子プロセスが@code{sleep}を呼び出している間に、
@code{ps}ユーティリティを使用して子プロセスのプロセスIDを獲得します。
次に、
@value{GDBN}に対して
（親プロセスもデバッグするのであれば、
新たに@value{GDBN}を起動して、
その@value{GDBN}に対して）、
子プロセスにアタッチするよう指示してください
（@pxref{Attach}）。
これ以降は、
通常の方法でプロセスにアタッチした場合と全く同様に、
子プロセスのデバッグが可能です。
@end ifclear
@ifset HPPA
@node Processes,  , Threads, Running
@section マルチプロセス・プログラムのデバッグ

@cindex fork, debugging programs which call
@cindex multiple processes
@cindex processes, multiple
@cindex @code{fork}を呼び出す関数のデバッグ[forkをよびだすかんすうのデバッグ]
@cindex マルチプロセス[マルチプロセス]
@cindex プロセス、多重[プロセス、たじゅう]

@value{GDBN}は、
@code{fork}関数、
または、
@code{vfork}関数を使用して新たにプロセスを生成するプログラムのデバッグをサポートしています。

デフォルトでは、
プログラムが@code{fork}を実行するとき、
@value{GDBN}は、
引き続き親プロセスのデバッグを継続し、
子プロセスは、
妨げられることなく実行を続けます。

親プロセスではなく子プロセスの実行を追跡したい場合は、
コマンド@w{@code{set follow-fork-mode}}を使用します。

@table @code
@kindex set follow-fork-mode
@item set follow-fork-mode @var{mode}
プログラムによる@code{fork}や@code{vfork}の呼び出しに反応するよう、
デバッガを設定します。
@code{fork}や@code{vfork}の呼び出しは、
新しいプロセスを生成します。
@var{mode}は、
以下のいずれかです。

@table @code
@item parent
@code{fork}の後、
元のプロセスをデバッグします。
子プロセスは、
妨げられることなく実行されます。

@item child
@code{fork}の後、
新しいプロセスをデバッグします。
親プロセスは、
妨げられることなく実行されます。

@item ask
上記のどちらを選択するかを、
デバッガが問い合わせます。
@end table

@item show follow-fork-mode
@code{fork}や@code{vfork}の呼び出しに対して、
現在、
デバッガがどのように反応するよう設定されているかを表示します。
@end table

子プロセスをデバッグするよう要求されているときに、
@code{vfork}に続けて@code{exec}が呼び出されると、
@value{GDBN}は、
新しいターゲットを、
設定されている最初のブレイクポイントまで実行します。
元のプログラムの@code{main}にブレイクポイントがセットされていると、
子プロセスの@code{main}にもブレイクポイントがセットされます。

子プロセスが@code{vfork}によって生成（spawn）された場合、
@code{exec}の呼び出しが完了するまで、
子プロセス、
親プロセスのどちらもデバッグすることはできません。

@code{exec}の呼び出し後に、
@value{GDBN}に対して@code{run}コマンドを発行すると、
新しいターゲットが再始動されます。
親プロセスを再始動するには、
親プロセスの実行ファイル名を引数に指定して、
@code{file}コマンドを使用します。

@code{catch}コマンドを使用することによって、
@code{fork}、
@code{vfork}、
@code{exec}の呼び出しが行われるたびに、
@value{GDBN}を停止させることができます。
@xref{Set Catchpoints, ,Setting catchpoints}。
@end ifset

@node Stopping, Stack, Running, Top
@chapter 停止と継続

デバッガを使用する主な目的は、
プログラムが終了してしまう前に停止させたり、
問題のあるプログラムを調査して何が悪いのかを調べたりすることにあります。

@value{GDBN}内部においてプログラムが停止する原因はいくつかあります。
例えば、
@ifclear BARETARGET
シグナルの受信、
@end ifclear
ブレイクポイントへの到達、
@code{step}コマンドのような@value{GDBN}コマンドの実行後の新しい行への到達などです。
プログラムが停止すると、
変数の値の調査や設定、
新しいブレイクポイントの設定、
既存のブレイクポイントの削除などを行った後に、
プログラムの実行を継続することができます。
通常、
@value{GDBN}が表示するメッセージは、
ユーザ・プログラムの状態について多くの情報を提供してくれます。
ユーザはいつでも明示的にこれらの情報を要求することができます。

@table @code
@kindex info program
@item info program
ユーザ・プログラムの状態に関する情報を表示します。
表示される情報は、
そのプログラムの実行状態
（実行中か否か）、
@ifclear BARETARGET
そのプログラムのプロセス、
@end ifclear
プログラムが停止した理由です。
@end table

@menu
* Breakpoints::                 ブレイクポイント、ウォッチポイント、キャッチポイント
* Continuing and Stepping::     実行の再開
@ifset POSIX
* Signals::                     シグナル
@end ifset

@ifclear BARETARGET
* Thread Stops::                マルチスレッド・プログラムの停止と起動
@end ifclear

@end menu

@node Breakpoints, Continuing and Stepping, Stopping, Stopping
@section ブレイクポイント、ウォッチポイント、キャッチポイント

@cindex breakpoints
@cindex ブレイクポイント
@dfn{ブレイクポイント}によって、
プログラム内のある特定の箇所に到達するたびに、
プログラムを停止することができます。
個々のブレイクポイントについて、
そのブレイクポイントにおいてプログラムを停止させるためには満足されなければならない、
より詳細な条件を設定することができます。
ブレイクポイントの設定は、
いくつかある@code{break}コマンドのいずれかによって行います
（@pxref{Set Breaks, ,Setting breakpoints}）。
行番号、
関数名、
プログラム内における正確なアドレスを指定することで、
プログラムのどこで停止するかを指定することができます。

HP-UX、
SunOS 4.x、
SVR4、
Alpha OSF/1上では、
実行開始前に共用ライブラリ内にブレイクポイントを設定することもできます。
HP-UXシステムでは、
ちょっとした制約があります。
プログラムによって直接呼び出されるのではない共用ライブラリ・ルーチン
（例えば、
@code{pthread_create}の呼び出しにおいて、
引数として指定されるルーチン）
にブレイクポイントをセットするためには、
そのプログラムの実行が開始されるまで待たなければなりません。

@cindex watchpoints
@cindex memory tracing
@cindex breakpoint on memory address
@cindex breakpoint on variable modification
@cindex ウォッチポイント
@cindex メモリのトレース
@cindex メモリ・アドレスのブレイクポイント[メモリ・アドレスのブレイクポイント]
@cindex ブレイクポイント、メモリ・アドレスの[ブレイクポイント、メモリ・アドレスの]
@cindex 変数変化のブレイクポイント[へんすうへんかのブレイクポイント]
@cindex ブレイクポイント、変数変化の[ブレイクポイント、へんすうへんかの]
@dfn{ウォッチポイント}は、
ある式の値が変化したときにユーザ・プログラムを停止させる、
特別なブレイクポイントです。
ウォッチポイントは、
他のブレイクポイントと同じように管理することができますが、
設定だけは特別なコマンドで行います
（@pxref{Set Watchpoints, ,Setting watchpoints}）。
有効化、
無効化、
および削除を行うときに使用する各コマンドは、
対象がブレイクポイントであってもウォッチポイントであっても同一です。

ブレイクポイントで@value{GDBN}が停止するたびに、
常に自動的にユーザ・プログラム内のある値を表示させるようにすることができます。
@xref{Auto Display,, Automatic display}。

@cindex catchpoints
@cindex breakpoint on events
@cindex キャッチポイント
@cindex イベントに対するブレイクポイント[イベントにたいするブレイクポイント]
@dfn{キャッチポイント}は、
C++の例外の発生やライブラリのローディングのようなある種のイベントが発生したときに、
ユーザ・プログラムを停止させる、
また別の特殊なブレイクポイントです。
ウォッチポイントと同様、
キャッチポイントを設定するために使用する特別なコマンドがあります。
（@pxref{Set Catchpoints, ,Setting catchpoints}）。
しかし、
この点を除けば、
キャッチポイントを他のブレイクポイントと同様に管理することができます。
（ユーザ・プログラムがシグナルを受信したときに停止するようにするためには、
@code{handle}コマンドを使用します。
@pxref{Signals, ,Signals}）。

@cindex breakpoint numbers
@cindex numbers for breakpoints
@cindex ブレイクポイント番号[ブレイクポイントばんごう]
@cindex 番号、ブレイクポイント[ばんごう、ブレイクポイント]
ユーザが新規に作成した個々のブレイクポイント、
ウォッチポイント、
キャッチポイントに対して、
@value{GDBN}は番号を割り当てます。
この番号は1から始まる連続する整数値です。
ブレイクポイントの様々な側面を制御するコマンドの多くにおいて、
変更を加えたいブレイクポイントを指定するのにこの番号を使用します。
個々のブレイクポイントを@dfn{有効化}、
@dfn{無効化}することができます。
無効化されたブレイクポイントは、
再度有効化されるまで、
ユーザ・プログラムの実行に影響を与えません。

@menu
* Set Breaks::                  ブレイクポイントの設定
* Set Watchpoints::             ウォッチポイントの設定
* Set Catchpoints::             キャッチポイントの設定
* Delete Breaks::               ブレイクポイントの削除
* Disabling::                   ブレイクポイントの無効化
* Conditions::                  ブレイクポイントの成立条件
* Break Commands::              ブレイクポイント・コマンド・リスト
@ifclear CONLY
* Breakpoint Menus::            ブレイクポイント・メニュー
@end ifclear

@c  @ifclear BARETARGET
@c  * Error in Breakpoints::        ``Cannot insert breakpoints''
@c  @end ifclear
@end menu

@node Set Breaks, Set Watchpoints, Breakpoints, Breakpoints
@subsection ブレイクポイントの設定

@c FIXME LMB what does GDB do if no code on line of breakpt?  
@c       consider in particular declaration with/without initialization.
@c
@c FIXME 2 is there stuff on this already? break at fun start, already init?

@kindex break
@kindex b
@kindex $bpnum
@cindex latest breakpoint
@cindex 最後のブレイクポイント[さいごのブレイクポイント]
ブレイクポイントは、
@code{break}コマンド
（省略形は@code{b}）
によって設定されます。
デバッガのコンビニエンス変数@samp{$bpnum}に、
最後に設定されたブレイクポイントの番号が記録されます。
コンビニエンス変数の使用方法については、
@xref{Convenience Vars,, Convenience variables}。

ブレイクポイントの設定箇所を指定する方法はいくつかあります。

@table @code
@item break @var{function}
関数@var{function}のエントリにブレイクポイントを設定します。
@ifclear CONLY
ソース言語が
（例えばC++のように）
シンボルのオーバーロード機能を持つ場合、
@var{function}は、
プログラムを停止させる可能性を持つ1つ以上の箇所を指すことがあります。
このような状況に関する説明については、
@xref{Breakpoint Menus,,Breakpoint menus}。
@end ifclear

@item break +@var{offset}
@itemx break -@var{offset}
その時点において選択されているフレームにおいて実行が停止している箇所から、
指定された行数だけ先または手前にブレイクポイントを設定します。

@item break @var{linenum}
カレントなソース・ファイル内の@var{linenum}で指定される行番号を持つ行に、
ブレイクポイントを設定します。
ここで「カレントなソース・ファイル」とは、
最後にソース・コードが表示されたファイルを指します。
このブレイクポイントは、
その行に対応するコードが実行される直前に、
ユーザ・プログラムを停止させます。

@item break @var{filename}:@var{linenum}
@var{filename}で指定されるソース・ファイルの@var{linenum}で指定される番号の行に、
ブレイクポイントを設定します。

@item break @var{filename}:@var{function}
@var{filename}で指定されるソース・ファイル内の@var{function}で指定される関数エントリにブレイクポイントを設定します。
同じ名前の関数が複数のファイルに存在する場合以外は、
ファイル名と関数名を同時に指定する必要はありません。

@item break *@var{address}
@var{address}で指定されるアドレスにブレイクポイントを設定します。
これは、
プログラムの中の、
デバッグ情報やソース・ファイルが手に入らない部分にブレイクポイントを設定するのに使用できます。

@item break
引数なしで実行されると、
@code{break}コマンドは、
選択されたスタック・フレーム内において次に実行される命令にブレイクポイントを設定します
（@pxref{Stack, ,Examining the Stack}）。
最下位にあるスタック・フレーム以外のフレームが選択されていると、
このブレイクポイントは、
制御がそのフレームに戻ってきた時点で、
ユーザ・プログラムを停止させます。
これが持つ効果は、
選択されたフレームの下位にあるフレームにおいて
@code{finish}コマンドを実行するのと似ています。
ただし、
1つ異なるのは、
@code{finish}コマンドがアクティブなブレイクポイントを残さないという点です。
最下位のスタック・フレームにおいて引数なしで
@code{break}コマンドを実行した場合、
そのときに停止していた箇所に次に到達したときに、
@value{GDBN}はユーザ・プログラムを停止させます。
これは、
ループの内部では便利でしょう。

@value{GDBN}は通常、
実行を再開したときに、
最低でも1命令が実行されるまでの間は、
ブレイクポイントの存在を無視します。
そうでなければ、
ブレイクポイントで停止した後、
そのブレイクポイントを無効にしない限り、
先へ進めないことになってしまいます。
この規則は、
ユーザ・プログラムが停止したときに、
既にそのブレイクポイントが存在したか否かにかかわらず、
適用されます。

@item break @dots{} if @var{cond}
@var{cond}で指定される条件式付きでブレイクポイントを設定します。
そのブレイクポイントに達すると、
必ず条件式@var{cond}が評価されます。
評価結果がゼロでない場合、
すなわち、
評価結果が真である場合のみ、
ユーザ・プログラムを停止します。
@samp{@dots{}}の部分には、
これまでに説明してきた停止箇所を指定するための引数のいずれかが入ります
（@samp{@dots{}}は省略も可能です）。
ブレイクポイントの条件式の詳細については、
@xref{Conditions, ,Break conditions}。

@kindex tbreak
@item tbreak @var{args}
プログラムを1回だけ停止させるブレイクポイントを設定します。
@var{args}の部分は@code{break}コマンドと同様であり、
ブレイクポイントも同じように設定されますが、
@code{tbreak}により設定されたブレイクポイントは、
プログラムが最初にそこで停止した後に自動的に削除されます。
@xref{Disabling, ,Disabling breakpoints}。

@ifclear HPPA
@kindex hbreak
@item hbreak @var{args}
ハードウェアの持つ機能を利用したブレイクポイントを設定します。
@var{args}の部分は@code{break}コマンドと同様であり、
ブレイクポイントも同じように設定されますが、
@code{hbreak}により設定されるブレイクポイントは、
ハードウェアによるサポートを必要とします。
ターゲット・ハードウェアによっては、
このような機能を持たないものもあるでしょう。
これの主な目的は、
EPROM/ROMコードのデバッグであり、
ユーザはある命令にブレイクポイントを設定するのに、
その命令を変更する必要がありません。
これは、
SPARClite DSUの提供するトラップ発生機能と組み合わせて使用することができます。
DSUは、
デバッグ・レジスタに割り当てられた
データ・アドレスまたは命令アドレスをプログラムがアクセスすると、
トラップを発生させます。
ハードウェアの提供するブレイクポイント・レジスタは、
データ・ブレイクポイントを2つまでしか取れないので、
3つ以上使用しようとすると、
@value{GDBN}はそれを拒絶します。
このような場合、
不要になったハードウェア・ブレイクポイントを削除または無効化してから、
新しいハードウェア・ブレイクポイントを設定してください。
@xref{Conditions, ,Break conditions}。

@kindex thbreak
@item thbreak @var{args}
ハードウェアの機能を利用して、
プログラムを1回だけ停止させるブレイクポイントを設定します。
@var{args}の部分は@code{hbreak}コマンドと同様であり、
ブレイクポイントも同じように設定されます。
しかし、
@code{tbreak}コマンドの場合と同様、
最初にプログラムがそこで停止した後に、
このブレイクポイントは自動的に削除されます。
また、
@code{hbreak}コマンドの場合と同様、
このブレイクポイントはハードウェアによるサポートを必要とするものであり、
ターゲット・ハードウェアによっては、
そのような機能がないこともあるでしょう。
@xref{Disabling, ,Disabling breakpoints}。
また、
@xref{Conditions, ,Break conditions}。
@end ifclear

@kindex rbreak
@cindex regular expression
@cindex 正規表現[せいきひょうげん]
@item rbreak @var{regex}
@c FIXME what kind of regexp?
@var{regex}で指定される正規表現にマッチするすべての関数にブレイクポイントを設定します。
このコマンドは、
正規表現にマッチしたすべての関数に無条件ブレイクポイントを設定し、
設定されたすべてのブレイクポイントの一覧を表示します。
設定されたブレイクポイントは、
@code{break}コマンドで設定されたブレイクポイントと同様に扱われます。
他のすべてのブレイクポイントと同様の方法で、
削除、
無効化、
および条件の設定が可能です。

@ifclear CONLY
C++プログラムのデバッグにおいて、
あるオーバーロードされたメンバ関数が、
特別なクラスだけが持つメンバ関数というわけではない場合、
そのメンバ関数にブレイクポイントを設定するのに、
@code{rbreak}コマンドは便利です。
@end ifclear

@kindex info breakpoints
@cindex @code{$_} and @code{info breakpoints}
@item info breakpoints @r{[}@var{n}@r{]}
@itemx info break @r{[}@var{n}@r{]}
@itemx info watchpoints @r{[}@var{n}@r{]}
設定された後、
削除されていない、
すべてのブレイクポイント、
ウォッチポイント、
キャッチポイントの一覧を表示します。
個々のブレイクポイントについて、
以下の情報が表示されます。

@table @emph
@item ブレイクポイント番号
@item タイプ
ブレイクポイント、
ウォッチポイント、
または、
キャッチポイント
@item 廃棄
ブレイクポイントに次に到達したときに、
無効化または削除されるべくマークされているか否かを示します。
@item 有効／無効
有効なブレイクポイントを@samp{y}、
有効でないブレイクポイントを@samp{n}で示します。
@item アドレス
ユーザ・プログラム内のブレイクポイントの位置をメモリ・アドレスとして示します。
@item 対象
ユーザ・プログラムのソース内におけるブレイクポイントの位置を、
ファイル名および行番号で示します。
@end table

@noindent
ブレイクポイントが条件付きのものである場合、
@code{info break}コマンドは、
そのブレイクポイントに関する情報の次の行に、
その条件を表示します。
ブレイクポイント・コマンドがあれば、
続いてそれが表示されます。

@noindent
@code{info break}コマンドに引数としてブレイクポイント番号@var{n}が指定されると、
その番号に対応するブレイクポイントだけが表示されます。
コンビニエンス変数@code{$_}、
および、
@code{x}コマンドのデフォルトの参照アドレスには、
一覧の中で最後に表示されたブレイクポイントのアドレスが設定されます
（@pxref{Memory, ,Examining memory}）。

@noindent
@code{info break}コマンドは、
ブレイクポイントに到達した回数を表示します。
これは、
@code{ignore}コマンドと組み合わせると便利です。
まず、
@code{ignore}コマンドによってブレイクポイントへの到達をかなりの回数無視するよう設定します。
プログラムを実行し、
@code{info break}コマンドの出力結果から何回ブレイクポイントに到達したかを調べます。
再度プログラムを実行し、
今度は前回の実行時に到達した回数より1だけ少ない回数だけ無視するように設定します。
こうすることで、
前回の実行時にそのブレイクポイントに最後に到達したときと同じ状態でプログラムを停止させることが簡単にできます。
@end table

@value{GDBN}では、
ユーザ・プログラム内の同一箇所に何度でもブレイクポイントを設定することができます。
これは、
くだらないことでも、
無意味なことでもありません。
設定されるブレイクポイントが条件付きのものである場合、
これはむしろ有用です
（@pxref{Conditions, ,Break conditions}）。

@cindex negative breakpoint numbers
@cindex internal @value{GDBN} breakpoints
@cindex 負のブレイクポイント番号[ふのブレイクポイントばんごう]
@cindex 内部のブレイクポイント番号[ないぶのブレイクポイントばんごう]
@value{GDBN}自身が、
特別な目的でユーザ・プログラム内部にブレイクポイントを設定することがあります。
例えば、
（Cプログラムにおける）
@code{longjmp}を適切に処理するためなどです。
これらの内部的なブレイクポイントには@code{-1}から始まる負の番号が割り当てられます。
@samp{info breakpoints}コマンドは、
このようなブレイクポイントを表示しません。

これらのブレイクポイントは、
@value{GDBN}の保守コマンド@samp{maint info breakpoints}で表示することができます。

@table @code
@kindex maint info breakpoints
@item maint info breakpoints
@samp{info breakpoints}コマンドと同様の形式で呼び出され、
ユーザが明示的に設定したブレイクポイントと、
@value{GDBN}が内部的な目的で使用しているブレイクポイントの両方を表示します。
内部的なブレイクポイントは、
負のブレイクポイント番号で示されます。
タイプ欄にブレイクポイントの種類が表示されます。

@table @code
@item breakpoint
明示的に設定された普通のブレイクポイント

@item watchpoint
明示的に設定された普通のウォッチポイント

@item longjmp
@code{longjmp}が呼び出されたときに正しくステップ処理ができるように、
内部的に設定されたブレイクポイント

@item longjmp resume
@code{longjmp}のターゲットとなる箇所に内部的に設定されたブレイクポイント

@item until
@value{GDBN}の@code{until}コマンドで一時的に使用される内部的なブレイクポイント

@item finish
@value{GDBN}の@code{finish}コマンドで一時的に使用される内部的なブレイクポイント

@ifset HPPA
@item shlib events
共用ライブラリ・イベント
@end ifset
@end table
@end table


@node Set Watchpoints, Set Catchpoints, Set Breaks, Breakpoints
@subsection ウォッチポイントの設定

@cindex setting watchpoints
@cindex software watchpoints
@cindex hardware watchpoints
@cindex ウォッチポイントの設定[ウォッチポイントのせってい]
@cindex 設定、ウォッチポイントの[せってい、ウォッチポイントの]
@cindex ソフトウェア・ウォッチポイント
@cindex ハードウェア・ウォッチポイント

ウォッチポイントを設定することで、
ある式の値が変化したときに、
プログラムの実行を停止させることができます。
その値の変更が、
プログラムのどの部分で行われるかをあらかじめ知っている必要はありません。

システムによって、
ウォッチポイントがソフトウェアによって実装されていることもあれば、
ハードウェアによって実装されていることもあります。
GDBは、
ユーザ・プログラムをシングル・ステップ実行して、
そのたびに変数の値をテストすることによって、
ソフトウェア・ウォッチポイントを実現しています。
これは、
通常の実行と比較すると、
何百倍も遅くなります。
（それでも、
プログラムのどの部分が問題を発生させたのか全く手掛りのない誤りを見つけることができるのであれば、
十分価値のあることかもしれません）。

HP-UXやLinuxのようなシステム上のGDBには、
ハードウェア・ウォッチポイントのサポートも組み込まれています。
これを使用すれば、
ユーザ・プログラムの実行が遅くなることはありません。

@table @code
@kindex watch
@item watch @var{expr}
@var{expr}で指定される式に対してウォッチポイントを設定します。
プログラムが式の値を書き換えるときに、
@value{GDBN}はプログラムの実行を停止させます。

@kindex rwatch
@item rwatch @var{expr}
@var{expr}で指定される対象が読み込みアクセスされるときにプログラムを停止させるウォッチポイントを設定します。
2つめのウォッチポイントとして設定するのであれば、
1つめのウォッチポイントも@code{rwatch}コマンドで設定されていなければなりません。

@kindex awatch
@item awatch @var{expr}
@c {{原文では以下で間違って @var{args} となっていた。}}
@var{expr}で指定される対象が読み込みアクセス、
書き込みアクセスされるときにプログラムを停止させるウォッチポイントを設定します。
2つめのウォッチポイントとして設定するのであれば、
1つめのウォッチポイントも@code{awatch}コマンドで設定されていなければなりません。

@kindex info watchpoints
@item info watchpoints
ウォッチポイント、
ブレイクポイント、
キャッチポイントの一覧を表示します。
これは、
@code{info break}と同じです。
@end table

@value{GDBN}は、
可能であれば、
@dfn{ハードウェア・ウォッチポイント}を設定します。
ハードウェア・ウォッチポイントをセットした場合は高速な実行が可能であり、
デバッガは、
変更を引き起こした命令のところで、
値の変更を報告することができます。
ハードウェア・ウォッチポイントを設定できない場合、
@value{GDBN}は、
ソフトウェア・ウォッチポイントを設定します。
これは、
実行速度も遅く、
値の変更は、
その変更が実際に発生した後に、
その変更を引き起こした命令のところではなく、
1つ後ろの文のところで報告されます

@code{watch}コマンドを実行すると、
ハードウェア・ウォッチポイントの設定が可能な場合には、
@value{GDBN}は、
以下のような報告を行います。

@example
Hardware watchpoint @var{num}: @var{expr}
@end example

@noindent

SPARClite DSUは、
デバッグ・レジスタに割り当てられた
データ・アドレスや命令アドレスにプログラムがアクセスすると、
トラップを発生させます。
@c {{facilitateの訳は、「支援する」よりも良い言葉があるはず}}
データ・アドレスについては、
DSUが@code{watch}コマンドを支援しています。
しかし、
ハードウェアの提供するブレイクポイント・レジスタは、
データ・ウォッチポイントを2つまでしか取れず、
その2つは同じ種類のウォッチポイントでなければなりません。
例えば、
2つのウォッチポイントを、
両方とも@code{watch}コマンドで設定すること、
両方とも@code{rwatch}コマンドで設定すること、
@strong{あるいは}、
両方とも@code{awatch}コマンドで設定することは可能ですが、
それぞれを異なるコマンドで設定することはできません。
異なる種類のウォッチポイントを同時に設定しようとしても、
コマンドの実行を@value{GDBN}が拒否します。
このような場合、
使用しないウォッチポイント・コマンドを削除または無効化してから、
新しいウォッチポイント・コマンドを設定してください。

@code{print}や@code{call}を使用して関数を対話的に呼び出すと、
それまでにセットされていたウォッチポイントはいずれも、
GDBが別の種類のブレイクポイントに到達するか、
あるいは、
関数の呼び出しが終了するまでの間は、
効果を持たなくなります。

@ifclear BARETARGET
@quotation
@cindex watchpoints and threads
@cindex threads and watchpoints
@cindex ウォッチポイントとスレッド
@cindex スレッドとウォッチポイント
@ifclear HPPA
@emph{注意:}
マルチスレッド・プログラムでは、
ウォッチポイントの有用性は限定されます。
現在のウォッチポイントの実装では、
@value{GDBN}は、
@emph{単一スレッドの中}
でしか式の値を監視することができません。
カレント・スレッドの処理の結果としてのみ、
その式の値が変更されること
（かつ、
他のスレッドがカレント・スレッドにはならないこと）
が確実であれば、
通常どおり、
ウォッチポイントを使用することができます。
しかし、
カレント・スレッド以外のスレッドが式の値を変更することがあると、
@value{GDBN}は、
その変更に気付かないかもしれません。
@end ifclear
@ifset HPPA
@emph{注意:}
マルチスレッド・プログラムでは、
ソフトウェア・ウォッチポイントの有用性は限定されます。
ソフトウェア・ウォッチポイントを生成した場合、
@value{GDBN}は、
@emph{単一スレッドの中}
でしか式の値を監視することができません。
カレント・スレッドの処理の結果としてのみ、
その式の値が変更されることが
（かつ、
他のスレッドがカレント・スレッドにはならないことが）
確実であれば、
通常どおり、
ソフトウェア・ウォッチポイントを使用することができます。
しかし、
カレント・スレッド以外のスレッドが式の値を変更することがあると、
@value{GDBN}は、
その変更に気付かないかもしれません。
（これに対して、
ハードウェア・ウォッチポイントは、
すべてのスレッドの中で式を監視します。）
@end ifset
@end quotation
@end ifclear

@node Set Catchpoints, Delete Breaks, Set Watchpoints, Breakpoints
@subsection キャッチポイントの設定
@cindex catchpoints
@cindex exception handlers
@cindex event handling
@cindex キャッチポイント
@cindex 例外ハンドラ[れいがいハンドラ]
@cindex 例外処理[れいがいしょり]

@dfn{キャッチポイント}を使用することによって、
C++例外や共用ライブラリのローディングのような、
ある種のプログラム・イベントが発生したときに、
デバッガを停止させることができます。
キャッチポイントを設定するには、
@code{catch}コマンドを使用します。

@table @code
@kindex catch
@item catch @var{event}
@var{event}で指定されるイベントが発生したときに
停止します。
@var{event}は、
以下のいずれかです。
@table @code
@item throw
@kindex catch throw
C++例外の発生。

@item catch
@kindex catch catch
C++例外のキャッチ。

@item exec
@kindex catch exec
@code{exec}の呼び出し。
現在これは、
HP-UXにおいてのみ利用可能です。

@item fork
@kindex catch fork
@code{fork}の呼び出し。
現在これは、
HP-UXにおいてのみ利用可能です。

@item vfork
@kindex catch vfork
@code{vfork}の呼び出し。
現在これは、
HP-UXにおいてのみ利用可能です。

@item load
@itemx load @var{libname}
@kindex catch load
任意の共用ライブラリの動的なローディング、
あるいは、
@var{libname}で指定されるライブラリのローディング。
現在これは、
HP-UXにおいてのみ利用可能です。

@item unload
@itemx unload @var{libname}
@kindex catch unload
動的にロードされた任意の共用ライブラリのアンローディング、
あるいは、
@var{libname}で指定されるライブラリのアンローディング。
現在これは、
HP-UXにおいてのみ利用可能です。
@end table

@item tcatch @var{event}
1回だけ停止させるキャッチポイントを設定します。
最初にイベントが捕捉された後に、
キャッチポイントは自動的に削除されます。
@end table

カレントなキャッチポイントの一覧を表示するには、
@code{info break}コマンドを使用します。

現在、
@value{GDBN}におけるC++の例外処理
（@code{catch throw}と@code{catch catch}）
にはいくつかの制限があります。

@itemize @bullet
@item
関数を対話的に呼び出すと、
@value{GDBN}は通常、
その関数が実行を終了したときに、
ユーザに制御を戻します。
しかし、
その関数呼び出しが例外を発生させると、
ユーザへ制御を戻すメカニズムが実行されないことがあります。
この場合、
ユーザ・プログラムは、
アボートするか、
あるいは、
ブレイクポイントへの到達、
@value{GDBN}が監視しているシグナルの受信、
そのプログラム自体の終了などのイベントが発生するまで、
継続実行されることになります。
これは、
例外に対するキャッチポイントを設定してある場合にもあてはまります。
対話的な関数呼び出しの間は、
例外に対するキャッチポイントは無効化されています。

@item
対話的に例外を発生させることはできません。

@item
対話的に例外ハンドラを組み込むことはできません。
@end itemize

@cindex raise exceptions
@cindex 例外の発生[れいがいのはっせい]
@cindex 発生、例外の[はっせい、れいがいの]
@code{catch}コマンドが、
例外処理をデバッグする手段としては最適なものではないような場合もあります。
どこで例外が発生したのかを正確に知りたい場合、
例外ハンドラが呼び出される@emph{前}にプログラムを停止させた方がよいでしょう。
なぜなら、
スタック・ポインタの調整が行われる前のスタックの状態を見ることができるからです。
例外ハンドラの内部にブレイクポイントを設定してしまうと、
どこで例外が発生したのかを調べるのは簡単ではないでしょう。

例外ハンドラが呼び出される直前で停止させるには、
実装に関する知識が若干必要になります。
@sc{gnu} C++の場合、
以下のようなANSI Cインターフェイスを持つ
@code{__raise_exception}というライブラリ関数を呼び出すことで例外を発生させます。

@example
    /* @var{addr}は例外識別子が格納される領域
       @var{id}は例外識別子 */
    void __raise_exception (void **@var{addr}, void *@var{id});
@end example
@c {{以前、上のコメントに脚注を入れていたが、削除した。}}
@c {{なぜかというと、以下の理由による。}}
@c {{ 1. @example の中では脚注の処理がうまくいかない}}
@c {{ 2. コメント中の「ID」が、コードでは「@var{id}」で}}
@c {{参照されていて、ＴｅＸで違うように印字されてしまう}}
@c {{ 3. コード中の「addr」は原文でもコメント中で「ADDR」}}
@c {{になっていなかった}}

@noindent
スタック・ポインタの調整が行われる前に、
すべての例外をデバッガにキャッチさせるには、
@code{__raise_exception}にブレイクポイントを設定します
（@pxref{Breakpoints, ,Breakpoints; watchpoints; and exceptions}）。

@var{id}の値に依存する条件を付けたブレイクポイント
（@pxref{Conditions, ,,Break conditions}）
を使用することで、
特定の例外が発生したときにだけユーザ・プログラムを停止させることができます。
複数の条件付きブレイクポイントを設定することで、
複数の例外の中のどれかが発生したときにユーザ・プログラムを停止させることもできます。


@node Delete Breaks, Disabling, Set Catchpoints, Breakpoints
@subsection ブレイクポイントの削除

@cindex clearing breakpoints, watchpoints, catchpoints
@cindex deleting breakpoints, watchpoints, catchpoints
@cindex ブレイクポイント、ウォッチポイント、キャッチポイントの削除[ブレイクポイント、ウォッチポイント、キャッチポイントのさくじょ]
@cindex 削除、ブレイクポイント、ウォッチポイント、キャッチポイントの[さくじょ、ブレイクポイント、ウォッチポイント、キャッチポイントの]
@cindex 消去、ブレイクポイント、ウォッチポイント、キャッチポイントの[しょうきょ、ブレイクポイント、ウォッチポイント、キャッチポイントの]
ブレイクポイント、
ウォッチポイント、
キャッチポイントがプログラムを1回停止させた後、
同じところで再びプログラムを停止させたくない場合、
それらを取り除くことがしばしば必要になります。
これが、
ブレイクポイントの@dfn{削除}と呼ばれるものです。
削除されたブレイクポイントはもはや存在しなくなり、
それが存在したという記録も残りません。

@code{clear}コマンドを使用する場合、
ブレイクポイントを、
それがプログラム内部のどこに存在するかを指定することによって削除します。
@code{delete}コマンドの場合は、
ブレイクポイント番号を指定することで、
個々のブレイクポイント、
ウォッチポイント、
キャッチポイントを削除することができます。

ブレイクポイントで停止した後、
先へ進むために、
そのブレイクポイントを削除する必要はありません。
ユーザが実行アドレスを変更することなく継続実行する場合、
最初に実行される命令に設定されているブレイクポイントを、
@value{GDBN}は自動的に無視します。

@table @code
@kindex clear
@item clear
選択されているスタック・フレーム内において次に実行される命令に設定されているブレイクポイントを削除します
（@pxref{Selection, ,Selecting a frame}）。
最下位にあるフレームが選択されている場合、
ユーザ・プログラムが停止した箇所に設定されているブレイクポイントを削除するのに便利な方法です。

@item clear @var{function}
@itemx clear @var{filename}:@var{function}
@var{function}で指定される関数のエントリに設定されているブレイクポイントを削除します。

@item clear @var{linenum}
@itemx clear @var{filename}:@var{linenum}
指定された行、
または、
その行内に記述されたコードに設定されたブレイクポイントを削除します。

@cindex delete breakpoints
@cindex 削除、ブレイクポイントの[さくじょ、ブレイクポイントの]
@kindex delete
@kindex d
@item delete @r{[}breakpoints@r{]} @r{[}@var{bnums}@dots{}@r{]}
引数で指定された番号を持つブレイクポイント、
ウォッチポイント、
キャッチポイントを削除します。
引数が指定されない場合、
すべてのブレイクポイントを削除します
（@code{set confirm off}コマンドが事前に実行されていない場合、
@value{GDBN}は、
削除してもよいかどうか確認を求めてきます）。
このコマンドの省略形は
@code{d}です。
@end table

@node Disabling, Conditions, Delete Breaks, Breakpoints
@subsection ブレイクポイントの無効化

@kindex disable breakpoints
@kindex enable breakpoints
ブレイクポイント、
ウォッチポイント、
キャッチポイントを削除するのではなく、
@dfn{無効化}したい場合もあるでしょう。
無効化によって、
ブレイクポイントは、
それがあたかも削除されたかのように機能しなくなりますが、
後に再度@dfn{有効化}することができるよう、
そのブレイクポイントに関する情報は記憶されます。

ブレイクポイント、
ウォッチポイント、
キャッチポイントは、
@code{enable}コマンドと@code{disable}コマンドによって有効化、
無効化されます。
これらのコマンドには、
引数として1つ以上のブレイクポイント番号を指定することも可能です。
指定すべき番号が分からない場合は、
@code{info break}コマンド、
または、
@code{info watch}コマンドによってブレイクポイント、
ウォッチポイント、
キャッチポイントの一覧を表示させてください。

ブレイクポイント、
ウォッチポイント、
キャッチポイントは、
有効／無効という観点から見て、
4つの異なる状態を持つことができます。

@itemize @bullet
@item
有効。
ブレイクポイントはユーザ・プログラムを停止させます。
@code{break}コマンドで設定されたブレイクポイントの初期状態はこの状態です。
@item
無効。
ブレイクポイントはユーザ・プログラムの実行に影響を与えません。
@item
1回有効。
ブレイクポイントはユーザ・プログラムを停止させますが、
停止後、
そのブレイクポイントは無効状態になります。
@code{tbreak}コマンドで設定されたブレイクポイントの初期状態はこの状態です。
@item
1回有効（削除）。
ブレイクポイントはユーザ・プログラムを停止させますが、
停止直後に、
そのブレイクポイントは完全に削除されます。
@end itemize

以下のコマンドを使用することで、
ブレイクポイント、
ウォッチポイント、
キャッチポイントの有効化、
無効化が可能です。

@table @code
@kindex disable breakpoints
@kindex disable
@kindex dis
@item disable @r{[}breakpoints@r{]} @r{[}@var{bnums}@dots{}@r{]}
指定されたブレイクポイントを無効化します。
番号が1つも指定されない場合は、
すべてのブレイクポイントが無効化されます。
無効化されたブレイクポイントは何ら影響力を持ちませんが、
そのブレイクポイントに関する情報まで削除されるわけではありません。
そのブレイクポイントを無視する回数、
ブレイクポイント成立の条件、
ブレイクポイント・コマンドなどのオプションは、
後にそのブレイクポイントが有効化される場合に備えて、
記憶されています。
@code{disable}コマンドは
@code{dis}と省略することができます。

@kindex enable breakpoints
@kindex enable
@item enable @r{[}breakpoints@r{]} @r{[}@var{bnums}@dots{}@r{]}
指定されたブレイクポイント
（または、
すべての定義済みブレイクポイント）
を有効化します。
有効化されたブレイクポイントは、
再びユーザ・プログラムを停止させることができるようになります。

@item enable @r{[}breakpoints@r{]} once @var{bnums}@dots{}
指定されたブレイクポイントを一時的に有効化します。
このコマンドで有効化されたブレイクポイントはどれも、
最初にプログラムを停止させた直後に、
@value{GDBN}によって無効化されます。

@item enable @r{[}breakpoints@r{]} delete @var{bnums}@dots{}
1回だけプログラムを停止させ、
その直後に削除されるような設定で、
指定されたブレイクポイントを有効化します。
このコマンドで有効化されたブレイクポイントはどれも、
最初にプログラムを停止させた直後に、
@value{GDBN}によって削除されます。
@end table

@code{tbreak}コマンド
（@pxref{Set Breaks, ,Setting breakpoints}）
で設定されたブレイクポイントを除き、
ユーザによって設定されたブレイクポイントの初期状態は有効状態です。
その後、
ユーザが上記のコマンドのいずれかを使用した場合に限り、
無効化されたり有効化されたりします
（@code{until}コマンドは、
独自にブレイクポイントを設定、
削除することができますが、
ユーザの設定した他のブレイクポイントの状態は変更しません。
@pxref{Continuing and Stepping, ,Continuing and stepping}）。

@node Conditions, Break Commands, Disabling, Breakpoints
@subsection ブレイクポイントの成立条件
@cindex conditional breakpoints
@cindex breakpoint conditions
@cindex 条件付きのブレイクポイント[じょうけんつきのブレイクポイント]
@cindex ブレイクポイント、条件付きの[ブレイクポイント、じょうけんつきの]

@c FIXME what is scope of break condition expr?  Context where wanted?
@c      in particular for a watchpoint?  
最も単純なブレイクポイントは、
指定された箇所にプログラムが到達するたびに、
プログラムの実行を停止させます。
ブレイクポイントに対して@dfn{条件}を指定することも可能です。
ここで、
「条件」とは、
プログラムが記述された言語で表現された真偽値を表す式のことです
（@pxref{Expressions, ,Expressions}）。
条件付きのブレイクポイントにプログラムが到達するたびに、
その式が評価されます。
そして、
その結果が@emph{真}であった場合だけ、
プログラムは停止します。

これは、
プログラムの正当性を検査するために診断式を使用するのとは逆になります。
診断式の場合は、
成立しないとき、
すなわち条件が偽であるときに、
プログラムを停止させます。
C言語で@var{assert}という診断式をテストするためには、
しかるべきブレイクポイントに@w{@samp{! @var{assert}}}という条件を設定します。

ウォッチポイントに対して条件を設定することもできます。
もともとウォッチポイントは、
ある式の値を検査するものですから、
これは必要ないかもしれません。
しかし、
ある変数の新しい値がある特定の値に等しいか否かを検査するのは条件式のほうに任せて、
ウォッチポイントの対象そのものは単にその変数の名前にしてしまうという設定の方が簡単でしょう。

ブレイクポイントの成立条件に副作用を持たせたり、
場合によってはプログラム内部の関数を呼び出させたりすることもできます。
プログラムの進行状況をログに取る関数を呼び出したり、
特別なデータ構造をフォーマットして表示するユーザ定義の関数を使用したい場合などに便利です。
この効果は、
同じアドレスに有効なブレイクポイントが別に設定されていない限り、
完全に予測可能です
（別のブレイクポイントが設定されていると、
@value{GDBN}はこのブレイクポイントを先に検出し、
他のブレイクポイントで設定した条件式をチェックすることなくプログラムを停止させてしまうかもしれません）。
あるブレイクポイントに到達したときに、
副作用を持つ処理を実行させるためには、
ブレイクポイント・コマンドの方がより便利であり、
より柔軟でしょう
（@pxref{Break Commands, ,Breakpoint command lists}）。

ブレイクポイントの成立条件は、
ブレイクポイントを設定する際に、
@code{break}コマンドの引数に@samp{if}を使用することによって、
設定できます。
@xref{Set Breaks, ,Setting breakpoints}。
ブレイクポイントの成立条件は、
@code{condition}コマンドによっていつでも変更できます。
@ifclear HPPA
@c The watch command now seems to recognize the if keyword.
@c catch doesn't, though.
@code{watch}コマンドは、
@code{if}キーワードを認識しません。
ウォッチポイントに対して条件を追加設定する唯一の方法は、
@code{condition}コマンドを使うことです。
@end ifclear
@ifset HPPA
@code{watch}コマンドの中で
@code{if}キーワードを使用することもできます。
@code{catch}コマンドは、
@code{if}キーワードを認識しません。
キャッチポイントに対して条件を追加設定する唯一の方法は、
@code{condition}コマンドを使うことです。
@end ifset

@table @code
@kindex condition
@item condition @var{bnum} @var{expression}
@var{bnum}で指定される番号のブレイクポイント、
ウォッチポイント、
キャッチポイントの成立条件として、
@var{expression}を指定します。
条件を設定した後、
番号@var{bnum}のブレイクポイントは、
@var{expression}の値が真
（C言語の場合はゼロ以外の値）
であるときのみ、
ユーザ・プログラムを停止させます。
@code{condition}コマンドを使用すると、
@value{GDBN}はただちに@var{expression}の構文の正当性、
および、
@var{expression}の中で使用されるシンボル参照の、
ブレイクポイントのコンテキストにおける有効性をチェックします。
@c FIXME so what does GDB do if there is no referent?  Moreover, what
@c about watchpoints?
しかし、
@code{condition}コマンドが実行されるときに、
@var{expression}の値が@value{GDBN}によって実際に評価されるわけではありません。
@xref{Expressions, ,Expressions}。

@item condition @var{bnum}
@var{bnum}で指定される番号のブレイクポイントから条件を削除します。
実行後、
それは通常の無条件ブレイクポイントになります。
@end table

@cindex ignore count (of breakpoint)
@cindex 通過カウント[つうかカウント]
ブレイクポイント成立条件の特別なものに、
ブレイクポイントに到達した回数がある数に達したときにプログラムを停止させるというものがあります。
これは大変便利なので、
それを実現するための特別な方法が提供されています。
それは、
ブレイクポイントの@dfn{通過カウント}
（ignore count）
を使用する方法です。
すべてのブレイクポイントは、
通過カウントと呼ばれる整数値を持っています。
ほとんどの場合、
この通過カウントの値はゼロであり、
何ら影響力を持ちません。
しかし、
通過カウントとして正の値を持つブレイクポイントに到達すると、
ユーザ・プログラムはそこで停止せず、
単に通過カウントの値を1減少させて処理を継続します。
したがって、
通過カウントが@var{n}であると、
ユーザ・プログラムがそのブレイクポイントに到達した回数が@var{n}以下の間は、
そのブレイクポイントにおいてプログラムは停止しません。

@table @code
@kindex ignore
@item ignore @var{bnum} @var{count}
@var{bnum}で指定される番号のブレイクポイントの通過カウントを@var{count}で指定される値に設定します。
ブレイクポイントへの到達回数が@var{count}以下の間、
ユーザ・プログラムは停止しません。
この間、
@value{GDBN}は、
通過カウントの値を1減少させる以外には何もしません。

次にブレイクポイントに到達したときにプログラムを停止させるには、
@var{count}にゼロを指定してください。

ブレイクポイントで停止した後に@code{continue}コマンドを使用して実行を再開する場合、
@code{ignore}コマンドを使用することなく、
直接@code{continue}コマンドの引数に通過カウントを指定することができます。
@xref{Continuing and Stepping,,Continuing and stepping}。

ブレイクポイントが通過カウントとして正の値を持ち、
かつ、
成立条件を持つ場合、
成立条件はチェックされません。
通過カウントが0に達すると、
@value{GDBN}は成立条件のチェックを再開します。

@w{@samp{$foo-- <= 0}}のように、
評価のたびに値の減少するコンビニエンス変数を使用した評価式によって、
通過カウントと同様の効果を達成することができます。
@xref{Convenience Vars, ,Convenience variables}。
@end table

通過カウントは、
ブレイクポイント、
ウォッチポイント、
キャッチポイントに適用されます。

@node Break Commands, Breakpoint Menus, Conditions, Breakpoints
@subsection ブレイクポイント・コマンド・リスト

@cindex breakpoint commands
@cindex ブレイクポイント・コマンド
ブレイクポイント
（あるいは、
ウォッチポイント、
キャッチポイント）
に対して、
それによってプログラムが停止したときに実行される一連のコマンドを指定することができます。
例えば、
ある特定の式の値を表示したり、
他のブレイクポイントを有効化したりできると便利なこともあるでしょう。

@table @code
@kindex commands
@kindex end
@item commands @r{[}@var{bnum}@r{]}
@itemx @dots{} @var{command-list} @dots{}
@itemx end
@var{bnum}で指定される番号を持つブレイクポイントに対して一連のコマンドを指定します。
コマンド自体は、
次の行以下に記述します。
コマンドの記述を終了するには、
@code{end}だけから成る1行を記述します。

ブレイクポイントからすべてのコマンドを削除するには、
@code{commands}行に続いて
（コマンドを1つも指定せずに）
@code{end}を記述します。

引数@var{bnum}が指定されない場合、
@code{commands}は、
最後に設定されたブレイクポイント、
ウォッチポイント、
キャッチポイントを対象とします
（最後に到達したブレイクポイントではありません）。
@end table

@var{command-list}の記述中は、
@key{RET}キーが持つ、
最後に実行されたコマンドを繰り返し実行する機能は無効です。

ブレイクポイント・コマンドを使用してプログラムの実行を再開することができます。
@code{continue}、
@code{step}、
または、
実行を再開させるその他の任意のコマンドを使用してください。

コマンド・リストの中で、
実行を再開するコマンドの後に記述されているものは無視されます。
というのは、
プログラムが実行を再開すると
（たとえそれが@code{next}コマンドや@code{step}コマンドによるものであっても）
別のブレイクポイントに到達する可能性があり、
そのブレイクポイントがコマンド・リストを持っていると、
どちらのリストを実行するべきかあいまいになるからです。

@kindex silent
コマンド・リストの先頭に指定されたコマンドが@code{silent}であると、
ブレイクポイントで停止したときに通常出力されるメッセージは表示されません。
これは、
ある特定のメッセージを出力して実行を継続するようなブレイクポイントを設定するのに望ましいでしょう。
コマンド・リスト中の後続のコマンドがどれもメッセージを出力しない場合、
ブレイクポイントに到達したことをユーザに示す情報は何も表示されないことになります。
@code{silent}はブレイクポイント・コマンド・リストの先頭においてのみ意味を持ちます。

@code{echo}、
@code{output}、
@code{printf}の各コマンドを使用することで、
細かく管理された出力を表示することができます。
これらのコマンドは、
@code{silent}指定のブレイクポイントで使うと便利です。
@xref{Output, ,Commands for controlled output}。

例えば、
ブレイクポイント・コマンドを使用して、
@code{foo}へのエントリにおいて
@code{x}が正の値を持つときに、
その値を表示するには以下のようにします。

@example
break foo if x>0
commands
silent
printf "x is %d\n",x
cont
end
@end example

ブレイクポイント・コマンドの1つの応用として、
あるバグの持つ影響を取り除いて、
他のバグを見つけるためにテストを継続することができます。
誤りのある行の次の行にブレイクポイントを設定し、
その条件の中で誤りの発生を検査し、
ブレイクポイント・コマンドの中で修正の必要な変数に正しい値を割り当てます。
コマンド・リストの最後には@code{continue}コマンドを記述して、
プログラムが停止しないようにします。
また、
プログラムの先頭には@code{silent}コマンドを記述し、
何も出力されないようにします。
以下に例を挙げます。

@example
break 403
commands
silent
set x = y + 4
cont
end
@end example

@ifclear CONLY
@node Breakpoint Menus,  , Break Commands, Breakpoints
@subsection ブレイクポイント・メニュー
@cindex overloading
@cindex symbol overloading
@cindex オーバーロード
@cindex シンボルのオーバーロード

プログラミング言語によっては
（特にC++の場合）、
異なるコンテキストにおいて使用するために、
同一の関数名を複数回定義することが可能です。
これは、
@dfn{オーバーローディング}と呼ばれます。
関数名がオーバーロードされている場合、
@samp{break @var{function}}だけでは、
どこにブレイクポイントを設定したいのかを@value{GDBN}に正しく指定するのに十分ではありません。
このような場合には、
ブレイクポイントを設定したい関数がどれであるかを正確に指定するために、
@samp{break @var{function}(@var{types})}のような形式を使用することができます。
このような形式を使用しないと、
@value{GDBN}は候補となりえるブレイクポイントの一覧を番号付きのメニューとして表示し、
プロンプト@samp{>}によってユーザの選択を待ちます。
先頭の2つの選択肢は常に、
@samp{[0] cancel}と@samp{[1] all}です。
@kbd{1}を入力すると、
候補となるすべての関数のそれぞれの定義に対してブレイクポイントを設定します。
また、
@kbd{0}を入力すると、
新たにブレイクポイントを設定することなく
@code{break}コマンドを終了します。

例えば、
以下に示すセッションの抜粋は、
オーバーロードされたシンボル@code{String::after}に対してブレイクポイントを設定しようとした場合を示しています。
ここでは、
この関数名を持つ関数定義の中から3つを選択しています。

@c FIXME! This is likely to change to show arg type lists, at least
@smallexample
@group
(@value{GDBP}) b String::after
[0] cancel
[1] all
[2] file:String.cc; line number:867
[3] file:String.cc; line number:860
[4] file:String.cc; line number:875
[5] file:String.cc; line number:853
[6] file:String.cc; line number:846
[7] file:String.cc; line number:735
> 2 4 6
Breakpoint 1 at 0xb26c: file String.cc, line 867.
Breakpoint 2 at 0xb344: file String.cc, line 875.
Breakpoint 3 at 0xafcc: file String.cc, line 846.
Multiple breakpoints were set.
Use the "delete" command to delete unwanted
 breakpoints.
(@value{GDBP})
@end group
@end smallexample
@end ifclear

@c  @ifclear BARETARGET
@c  @node Error in Breakpoints
@c  @subsection ``Cannot insert breakpoints''
@c
@c  FIXME!! 14/6/95  Is there a real example of this?  Let's use it.
@c
@c  Under some operating systems, breakpoints cannot be used in a program if
@c  any other process is running that program.  In this situation,
@c  attempting to run or continue a program with a breakpoint causes 
@c  @value{GDBN} to stop the other process.
@c
@c  When this happens, you have three ways to proceed:
@c
@c  @enumerate
@c  @item
@c  Remove or disable the breakpoints, then continue.
@c
@c  @item
@c  Suspend @value{GDBN}, and copy the file containing your program to a new 
@c  name.  Resume @value{GDBN} and use the @code{exec-file} command to specify
@c  that @value{GDBN} should run your program under that name.  
@c  Then start your program again.
@c
@c  @item
@c  Relink your program so that the text segment is nonsharable, using the
@c  linker option @samp{-N}.  The operating system limitation may not apply
@c  to nonsharable executables.
@c  @end enumerate
@c  @end ifclear

@node Continuing and Stepping, Signals, Breakpoints, Stopping
@section 継続実行とステップ実行

@cindex stepping
@cindex continuing
@cindex resuming execution
@cindex ステップ実行[ステップじっこう]
@cindex 継続実行[けいぞくじっこう]
@cindex 実行の再開[じっこうのさいかい]
@dfn{継続実行}とは、
ユーザ・プログラムの実行を再開して、
それが正常に終了するまで実行させることを指します。
一方、
@dfn{ステップ実行}とは、
ユーザ・プログラムを1「ステップ」だけ実行することを指します。
ここで「ステップ」とは、
（使用されるコマンドによって）
1行のソース・コードを指すこともありますし、
1マシン命令を指すこともあります。
継続実行の場合でもステップ実行の場合でも、
@ifset BARETARGET
ブレイクポイント
@end ifset
@ifclear BARETARGET
ブレイクポイントやシグナル
@end ifclear
が原因となって、
正常終了する前にユーザ・プログラムが停止することがあります
@ifclear BARETARGET
（シグナルによってプログラムが停止した場合、
実行を再開するには
@code{handle}コマンドまたは@w{@samp{signal 0}}
コマンドを使用するとよいでしょう。
@xref{Signals, ,Signals}）
@end ifclear
。

@table @code
@kindex continue
@kindex c
@kindex fg
@item continue @r{[}@var{ignore-count}@r{]}
@itemx c @r{[}@var{ignore-count}@r{]}
@itemx fg @r{[}@var{ignore-count}@r{]}
ユーザ・プログラムが最後に停止した箇所から、
プログラムの実行を再開します。
停止箇所に設定されているブレイクポイントは無視されます。
オプションの引数@var{ignore-count}によって、
停止箇所のブレイクポイントを無視する回数を指定することができます。
これは@code{ignore}コマンドと似た効果を持ちます
（@pxref{Conditions, ,Break conditions}）。

引数@var{ignore-count}は、
ユーザ・プログラムがブレイクポイントによって停止した場合にのみ意味を持ちます。
これ以外の場合には、
@code{continue}コマンドへの引数は無視されます。

@code{c}および@code{fg}は、
簡便さのためだけに提供されている同義コマンドで、
@code{continue}コマンドと全く同様の動作をします。
@end table

別の箇所で実行を再開するには、
呼び出し関数に戻る@code{return}コマンド
（@pxref{Returning, ,Returning from a function}）、
または、
ユーザ・プログラム内の任意の箇所へ移動する@code{jump}コマンド
（@pxref{Jumping, ,Continuing at a different address}）
を使用することができます。

ステップ実行を使用する典型的なテクニックは、
問題があると思われる関数やプログラム部分の先頭にブレイクポイント
(@pxref{Breakpoints, ,Breakpoints; watchpoints; and catchpoints})
を設定し、
ブレイクポイントで停止するまでプログラムを実行させた後、
問題が再現するまで、
関連しそうな変数の値を調べながら、
疑わしい部分を1行ずつ実行することです。

@table @code
@kindex step
@kindex s
@item step
異なるソース行に到達するまでユーザ・プログラムを継続実行した後、
プログラムを停止させ、
@value{GDBN}に制御を戻します。
このコマンドの省略形は@code{s}です。

@quotation
@c "without debugging information" is imprecise; actually "without line
@c numbers in the debugging information".  (gcc -g1 has debugging info but
@c not line numbers).  But it seems complex to try to make that
@c distinction here.
@emph{注意:}
デバッグ情報なしでコンパイルされた関数の内部にいるときに@code{step}コマンドを使用すると、
デバッグ情報付きの関数に達するまでプログラムの実行は継続されます。
同様に、
@code{step}コマンドがデバッグ情報なしでコンパイルされた関数の内部へ入って、
停止することはありません。
デバッグ情報を持たない関数の内部でステップ実行を行うには、
後述の@code{stepi}コマンドを使用してください。
@end quotation

@code{step}コマンドは、
ソース・コード行の最初の命令においてのみ停止するようになりました。
これにより、
以前のバージョンで発生していた、
@code{switch}文や@code{for}文などにおいて複数回停止してしまうという問題が回避されています。
同じ行の中にデバッグ情報を持つ関数への呼び出しがあると、
@code{step}コマンドは続けて停止します。

さらに、
@code{step}コマンドは、
サブルーチンが行番号情報を持つ場合に限り、
サブルーチンの内部に入り込むようになりました。
サブルーチンが行番号情報を持たない場合、
@code{step}コマンドは@code{next}コマンドと同様の動作をします。
これにより、
MIPSマシン上で@code{cc -gl}を使用した場合に発生していた問題が回避されています。
以前のバージョンでは、
サブルーチンが何らかのデバッグ情報を持っていれば、
その内部に入り込んでいました。

@item step @var{count}
@code{step}コマンドによるステップ実行を@var{count}回繰り返します。
ステップ実行を@var{count}回繰り返し終わる前に、
ブレイクポイントに到達する
@ifclear BARETARGET
か、
あるいは、
ステップ実行とは関連のないシグナルが発生した
@end ifclear
場合には、
ただちにステップ実行を中断して停止します。

@kindex next
@kindex n
@item next @r{[}@var{count}@r{]}
カレントな
（最下位の）
スタック・フレーム上において、
ソース・コード上の次の行まで実行します。
これは@code{step}コマンドと似ていますが、
@code{next}コマンドは、
ソース・コード上に関数呼び出しが存在すると、
その関数を停止することなく最後まで実行します。
プログラムが停止するのは、
@code{next}コマンドを実行したときと同一のスタック・フレーム上において、
ソース・コード上の異なる行まで実行が継続されたときです。
このコマンドの省略形は@code{n}です。

引数@var{count}は、
@code{step}コマンドの場合と同様、
繰り返し回数です。

@c  FIX ME!!  Do we delete this, or is there a way it fits in with
@c  the following paragraph?   ---  Vctoria
@c
@c  @code{next} within a function that lacks debugging information acts like
@c  @code{step}, but any function calls appearing within the code of the
@c  function are executed without stopping.

@code{next}コマンドは、
ソース・コード行の最初の命令においてのみ停止するようになりました。
これにより、
以前のバージョンで発生していた、
@code{switch}文や@code{for}文などにおいて複数回停止してしまうという問題が回避されています。

@kindex finish
@item finish
選択されているスタック・フレーム上の関数が復帰するまで、
実行を継続します。
戻り値があれば、
それを表示します。

@code{return}コマンド
（@pxref{Returning, Returning from a function}）
と比較してみてください。

@kindex until
@kindex u
@item until
@itemx u
カレントなスタック・フレーム上において、
カレント行よりも後ろにある行に到達するまで実行を継続します。
このコマンドは、
ループ内において複数回ステップ実行をするのを回避するために使用されます。
これは@code{next}コマンドに似ていますが、
唯一の相違点は、
@code{until}コマンドによってジャンプ命令が実行された場合、
プログラム・カウンタの値がジャンプ命令のアドレスより大きくなるまで、
プログラムが継続実行されるという点です。

これは、
ステップ実行によってループ内の最後の行に到達した後に@code{until}コマンドを実行することで、
ループから抜け出るまでプログラムを継続実行させることができるということを意味しています。
これに対して、
ループ内の最後の行で@code{next}コマンドを実行すると、
プログラムはループの先頭に戻ってしまうので、
ループ内の処理を繰り返すことを余儀なくされます。

@code{until}コマンドの実行により、
プログラムがカレントなスタック・フレームから抜け出ようとすると、
そこで@code{until}コマンドはプログラムを停止します。

実行されるマシン・コードの順序がソース行の順序と一致しない場合、
@code{until}コマンドは直観にいくらか反するような結果をもたらすかもしれません。
例えば、
以下に挙げるデバッグ・セッションからの抜粋では、
@code{f} （@code{frame}）
コマンドによって、
プログラムが@code{206}行めにおいて停止していることが示されています。
ところが、
@code{until}コマンドを実行すると、
@code{195}行めで停止してしまいます。

@example
(@value{GDBP}) f
#0  main (argc=4, argv=0xf7fffae8) at m4.c:206
206                 expand_input();
(@value{GDBP}) until
195             for ( ; argc > 0; NEXTARG) @{
@end example

これは、
コンパイラが、
実行の効率を高めるために、
C言語では
@code{for}ループ本体の前に記述されているループ終了のための条件判定を、
ループの先頭ではなく末尾で行うコードを生成したためです。
この判定式にまで処理が進んだとき、
@code{until}コマンドはあたかもループの先頭に戻ったかのように見えます。
しかしながら、
実際のマシン・コードのレベルでは、
前の命令に戻ったわけではありません。

引数のない@code{until}コマンドは、
1命令ごとのステップ実行によって実現されるため、
引数付きの
@code{until}コマンドに比べて処理性能が劣ります。

@item until @var{location}
@itemx u @var{location}
@var{location}で指定される箇所に到達するか、
カレントなスタック・フレームを抜け出るまで、
ユーザ・プログラムを継続実行します。
@var{location}は@code{break}コマンドの受け付ける形式の引数です
（@pxref{Set Breaks, , Setting breakpoints}）。
この形式による@code{until}コマンドはブレイクポイントを使用するため、
引数のない@code{until}コマンドより処理性能が優れています。

@kindex stepi
@kindex si
@item stepi
@itemx si
1マシン命令を実行した後、停止してデバッガに戻ります。

マシン命令単位でステップ実行する場合、
@samp{display/i $pc}を使用すると便利なことがしばしばあります。
これは、
ユーザ・プログラムが停止するたびに、
次に実行される命令を@value{GDBN}に自動的に表示させます。
@xref{Auto Display,, Automatic display}。

引数として、
@code{step}コマンドと同様、
繰り返し回数を取ります。

@need 750
@kindex nexti
@kindex ni
@item nexti
@itemx ni
1マシン命令を実行しますが、
それが関数の呼び出しである場合は、
関数から復帰するまで実行を継続します。

引数として、@code{next}コマンドと同様、
繰り返し回数を取ります。
@end table

@ifset POSIX
@node Signals, Thread Stops, Continuing and Stepping, Stopping
@section シグナル
@cindex signals
@cindex シグナル

シグナルは、
プログラム内で発生する非同期イベントです。
オペレーティング・システムによって、
使用可能なシグナルの種類が定義され、
それぞれに名前と番号が割り当てられます。
例えば、
UNIXにおいては、
割り込み
（通常は、@kbd{Ctrl}キーを押しながら@kbd{C}を押す）
を入力したときにプログラムが受信する
@code{SIGINT}、
その使用領域からかけ離れたメモリ域を参照したときにプログラムが受信する@code{SIGSEGV}、
アラームのタイムアウト時に発生する
（プログラムからアラームを要求した場合にのみ発生する）
@code{SIGALRM}シグナルなどがあります。

@cindex fatal signals
@cindex 致命的シグナル[ちめいてきシグナル]
@code{SIGALRM}など、
いくつかのシグナルは、
プログラムの正常な機能の一部です。
@code{SIGSEGV}などの他のシグナルは、
エラーを意味します。
これらのシグナルは、
プログラムが事前にそれを処理する何らかの方法を指定しないと、
@dfn{致命的}な
（プログラムを即座に終了させる）
ものとなります。
@code{SIGINT}はユーザ・プログラム内部のエラーを意味するものではありませんが、
通常は致命的なものであり、
割り込みの目的であるプログラムの終了を実現することができます。

@value{GDBN}は、
ユーザ・プログラム内部における任意のシグナル発生を検出することができます。
ユーザは、
個々のシグナルの発生時に何を実行するかを、
@value{GDBN}に対して事前に指定することができます。

@cindex handling signals
@cindex シグナルの処理[シグナルのしょり]
@cindex 処理、シグナルの[しょり、シグナルの]
通常@value{GDBN}は、
@code{SIGALRM}のようなエラーではないシグナルを無視するよう
（これらのシグナルがユーザ・プログラムの中で持っている役割を妨害することのないよう）
設定されています。
その一方で、
エラーのシグナルが発生した場合にはすぐにユーザ・プログラムを停止させるよう設定されています。
これらの設定は@code{handle}コマンドによって変更することができます。

@table @code
@kindex info signals
@item info signals
すべてのシグナルを一覧にして表示します。
また、
個々のシグナルについて、
@value{GDBN}がそれをどのように処理するよう設定されているかを表示します。
このコマンドを使用して、
定義済みのすべてのシグナルのシグナル番号を知ることができます。

@code{info handle}は、
@code{info signals}に対して設定された新しい別名です。

@kindex handle
@item handle @var{signal} @var{keywords}@dots{}
@value{GDBN}が@var{signal}で指定されるシグナルを処理する方法を変更します。
@var{signal}には、
シグナル番号またはシグナル名称
（先頭の@samp{SIG}は省略可能）
を指定します。
キーワード@var{keywords}によって、
どのように変更するかを指定します。
@end table

@c @group
@code{handle}コマンドが受け付けるキーワードには省略形を使用することができます。
省略しない場合、
キーワードは以下のようになります。

@table @code
@item nostop
@value{GDBN}に対して、
このシグナルが発生してもユーザ・プログラムを停止しないよう指示します。
@value{GDBN}は、
シグナルを受信したことをメッセージ出力によってユーザに通知することができます。

@item stop
@value{GDBN}に対して、
このシグナルが発生するとユーザ・プログラムを停止するよう指示します。
これは、
@code{print}キーワードを暗黙のうちに含みます。

@item print
@value{GDBN}に対して、
このシグナルが発生するとメッセージを表示するよう指示します。

@item noprint
@value{GDBN}
に対して、
このシグナルが発生したことを知らせないよう指示します。
これは、
@code{nostop}キーワードを暗黙のうちに含みます。

@item pass
@value{GDBN}に対して、
このシグナルの発生をユーザ・プログラムが検出できるようにするよう指示します。
ユーザ・プログラムはシグナルを処理することができます。
致命的で処理できないシグナルが発生した場合、
ユーザ・プログラムは停止するかもしれません。

@item nopass
@value{GDBN}に対して、
このシグナルの発生をユーザ・プログラムが検出できないようにするよう指示します。
@end table
@c @end group

シグナルによってユーザ・プログラムが停止した場合、
実行を継続するまでそのシグナルは検出されません。
@emph{その時点において}、
そのシグナルに対して@code{pass}キーワードが有効であれば、
ユーザ・プログラムは、
実行継続時にシグナルを検出します。
言い換えれば、
@value{GDBN}がシグナルの発生を報告してきたとき、
@code{handle}コマンドに@code{pass}キーワードまたは@code{nopass}キーワードを指定することで、
実行を継続したときにプログラムにそのシグナルを検出させるか否かを制御することができます。

また、
@code{signal}コマンドを使用することによって、
ユーザ・プログラムがシグナルを検出できないようにしたり、
通常は検出できないシグナルを検出できるようにしたり、
あるいは任意の時点で任意のシグナルをユーザ・プログラムに検出させたりすることができます。
例えば、
ユーザ・プログラムが何らかのメモリ参照エラーによって停止した場合、
ユーザは、
さらに実行を継続しようとして、
問題のある変数に正しい値を設定して継続実行しようとするかもしれません。
しかし、
実行継続直後に検出される致命的なシグナルのために、
おそらくユーザ・プログラムはすぐに終了してしまうでしょう。
このようなことを回避したければ、
@w{@samp{signal 0}}コマンドによって実行を継続することができます。
@xref{Signaling, ,Giving your program a signal}。
@end ifset

@ifclear BARETARGET
@node Thread Stops,  , Signals, Stopping
@section マルチスレッド・プログラムの停止と起動

ユーザ・プログラムが複数のスレッド
（@pxref{Threads,, Debugging programs with multiple threads}）
を持つ場合、
すべてのスレッドにブレイクポイントを設定するか、
特定のスレッドにブレイクポイントを設定するかを選択することができます。

@table @code
@cindex breakpoints and threads
@cindex thread breakpoints
@cindex ブレイクポイントとスレッド
@cindex スレッドのブレイクポイント
@kindex break @dots{} thread @var{threadno}
@item break @var{linespec} thread @var{threadno}
@itemx break @var{linespec} thread @var{threadno} if @dots{}
@var{linespec}はソース行を指定します。
記述方法はいくつかありますが、
どの方法を使っても結果的にはソース行を指定することになります。

@code{break}コマンドに修飾子@samp{thread @var{threadno}}を使用することで、
ある特定のスレッドがこのブレイクポイントに到達したときだけ@value{GDBN}がプログラムを停止するよう、
指定することができます。
ここで@var{threadno}は、
@value{GDBN}によって割り当てられるスレッド識別番号で、
@samp{info threads}コマンドによる出力の最初の欄に表示されるものです。

ブレイクポイントを設定する際に@samp{thread @var{threadno}}を指定しなければ、
そのブレイクポイントはユーザ・プログラム内部の@emph{すべて}のスレッドに適用されます。

条件付きのブレイクポイントに対しても@code{thread}識別子を使用することができます。
この場合、
以下のように@samp{thread @var{threadno}}をブレイクポイント成立条件の前に記述してください。

@smallexample
(gdb) break frik.c:13 thread 28 if bartab > lim
@end smallexample

@end table

@cindex stopped threads
@cindex threads, stopped
@cindex 停止したスレッド[ていししたスレッド]
@cindex スレッド、停止した[スレッド、ていしした]
いかなる理由によるのであれ@value{GDBN}配下においてユーザ・プログラムが停止した場合、
カレント・スレッドだけではなく、
@emph{すべて}の実行スレッドが停止します。
これにより、
知らないうちに状態の変化が発生することを心配することなく、
スレッドの切り替えも含めて、
プログラム全体の状態を検査することができます。

@cindex continuing threads
@cindex threads, continuing
@cindex スレッドの再開[スレッドのさいかい]
@cindex 再開、スレッドの[さいかい、スレッドの]
逆に、
プログラムの実行を再開したときには、
@emph{すべて}のスレッドが実行を開始します。
これは、
@code{step}コマンドや@code{next}コマンドによる@emph{シングル・ステップ実行の場合でも同様}です。

特に@value{GDBN}は、
すべてのスレッドの歩調を合わせてシングル・ステップ実行することはできません。
スレッドのスケジューリングは、
デバッグ対象のマシンのオペレーティング・システムに依存する
（@value{GDBN}が管理するわけではない）
ので、
カレント・スレッドがシングル・ステップの実行を完了する前に、
他のスレッドは複数の文を実行してしまうかもしれません。
また、
プログラムが停止するとき、
他のスレッドは2つの文の間の境界のところでぴったり停止するよりも、
文の途中で停止してしまう方が一般的です。

また、
継続実行やステップ実行の結果、
プログラムが別のスレッド内で停止してしまうこともありえます。
最初のスレッドがユーザの要求した処理を完了する前に、
他のスレッドがブレイクポイントに到達した場合、
シグナルを受信した場合、
例外が発生した場合には、
常にこのようなことが発生します。

OSによっては、
OSスケジューラをロックすることによって、
ただ1つのスレッドだけが実行されるようにすることができます。

@table @code
@item set scheduler-locking @var{mode}
スケジューラのロッキング・モード（locking mode）を設定します。
@code{off}の場合は、
ロックのメカニズムは機能せず、
任意の時点において、
どのスレッドも実行される可能性を持ちます。
@code{on}の場合は、
再始動（resume）されるスレッドの優先順位が低い場合には、
カレント・スレッドだけが実行を継続することができます。
@code{step}モードでは、
シングル・ステップ実行のための最適化が行われます。
ステップ実行をしている間、
他のスレッドが「プロンプトを横取りする」ことがないよう、
カレント・スレッドに占有権が与えられます。
また、
ステップ実行をしている間、
他のスレッドはきわめて稀にしか
（あるいは、
まったく）
実行するチャンスを与えられません。
@code{next}コマンドによって関数呼び出しの次の行まで処理を進めると、
他のスレッドが実行される可能性は高くなります。
また、
@code{continue}、
@code{until}、
@code{finish}のようなコマンドを使用すると、
他のスレッドは
完全に自由に実行されることができます。
しかし、
そのタイムスライスの中でブレイクポイントに到達しない限り、
他のスレッドが、
デバッグの対象となっているスレッドから、
GDBプロンプトを横取りすることはありません。

@item show scheduler-locking
スケジューラの現在のロッキング・モードを表示します。
@end table

@end ifclear


@node Stack, Source, Stopping, Top
@chapter スタックの検査

ユーザ・プログラムが停止したとき、
まず最初に、
どこで停止したのか、
そして、
どのようにしてそこに到達したのかを知る必要があるでしょう。

@cindex call stack
@cindex 呼び出しスタック[よびだしスタック]
ユーザ・プログラムが関数呼び出しを行うたびに、
その呼び出しに関する情報が生成されます。
その情報には、
ユーザ・プログラム内においてその呼び出しが発生した場所、
関数呼び出しの引数、
呼び出された関数内部のローカル変数などが含まれます。
その情報は、
@dfn{スタック・フレーム}と呼ばれるデータ・ブロックに保存されます。
スタック・フレームは、
@dfn{呼び出しスタック}と呼ばれるメモリ域に割り当てられます。

ユーザ・プログラムが停止すると、
スタックを検査する@value{GDBN}コマンドを使用して、
この情報をすべて見ることができます。

@cindex selected frame
@cindex 選択されたフレーム[せんたくされたフレーム]
@value{GDBN}は1つのスタック・フレームを@dfn{選択}していて、
多くの@value{GDBN}コマンドはこの選択されたフレームを暗黙のうちに参照します。
特に、
@value{GDBN}に対してユーザ・プログラム内部の変数の値を問い合わせると、
@value{GDBN}は選択されたフレームの内部においてその値を探そうとします。
関心のあるフレームを選択するための特別な@value{GDBN}コマンドが提供されています。
@xref{Selection, ,Selecting a frame}。

ユーザ・プログラムが停止すると、
@value{GDBN}はその時点において実行中のフレームを自動的に選択し、
@code{frame}コマンド
（@pxref{Frame Info, ,Information about a frame}）
のように、
そのフレームに関する情報を簡潔に表示します。

@menu
* Frames::                      スタック・フレーム
* Backtrace::                   バックトレース
* Selection::                   フレームの選択
* Frame Info::                  フレームに関する情報
* Alpha/MIPS Stack::            Alpha/MIPSマシンの関数スタック

@end menu

@node Frames, Backtrace, Stack, Stack
@section スタック・フレーム

@cindex frame
@cindex stack frame
@cindex フレーム
@cindex スタック・フレーム
呼び出しスタックは、
@dfn{スタック・フレーム}、
または短縮して@dfn{フレーム}と呼ばれる、
連続した小部分に分割されます。
個々のフレームは、
ある関数に対する1回の呼び出しに関連するデータです。
フレームには、
関数への引数、
関数のローカル変数、
関数の実行アドレスなどの情報が含まれます。

@cindex initial frame
@cindex outermost frame
@cindex innermost frame
@cindex 初期フレーム[しょきフレーム]
@cindex 最上位のフレーム[さいじょういのフレーム]
@cindex 最下位のフレーム[さいかいのフレーム]
ユーザ・プログラムが起動されたとき、
スタックには@code{main}関数のフレームが1つ存在するだけです。
これは、
@dfn{初期}フレームまたは「@dfn{最上位のフレーム}」と呼ばれます。
関数が呼び出されるたびに、
新たにフレームが作成されます。
関数が復帰すると、
その関数を呼び出したときに生成されたフレームが取り除かれます。
関数が再帰的に呼び出される場合、
1つの関数に対して多くのフレームが生成されるということもありえます。
実際に実行中の関数に対応するフレームは、
「@dfn{最下位のフレーム}」と呼ばれます。
これは、
存在するすべてのスタック・フレームの中で、
最も新しく作成されたものです。

@cindex frame pointer
@cindex フレーム・ポインタ
ユーザ・プログラムの内部においては、
スタック・フレームはアドレスによって識別されます。
スタック・フレームは多くのバイトから構成され、
それぞれがそれ自身のアドレスを持っています。
そのアドレスがフレームのアドレスとなるような1バイトを選択する慣習的な方法を、
すべての種類のコンピュータが提供しています。
通常、
あるフレーム内部で実行中は、
そのフレームのアドレスが@dfn{フレーム・ポインタ・レジスタ}と呼ばれるレジスタに格納されています。

@cindex frame number
@cindex フレームの番号[フレームのばんごう]
@value{GDBN}は、
既存のスタック・フレームのすべてに番号を割り当てます。
最下位のフレームは0で、
それを呼び出したフレームは1となります。
以下、
最下位のフレームを起点として、
順番に値を割り当てていきます。
これらの番号はユーザ・プログラム内部には実際には存在しません。
これらの番号は、
@value{GDBN}コマンドでスタック・フレームを指定することができるように、
@value{GDBN}によって割り当てられたものです。

@c below produces an acceptable overful hbox. --mew 13aug1993
@cindex frameless execution
@cindex フレームを持たない関数の実行[フレームをもたないかんすうのじっこう]
コンパイラによっては、
スタック・フレームを使用しなくても実行可能なように関数をコンパイルする方法を提供しているものもあります
（例えば、
@code{@value{GCC}}のオプション@samp{-fomit-frame-pointer}を指定すると、
フレームを持たない関数が生成されます）。
これは、
フレームをセットアップする時間を節約するために、
頻繁に利用されるライブラリ関数に対してしばしば適用されます。
これらの関数の呼び出しを処理するために@value{GDBN}が提供する機能は限られています。
最下位のフレームの関数呼び出しがスタック・フレームを持たない場合、
@value{GDBN}は、
あたかもそれが通常どおりに番号0のフレームを持つものとみなして、
関数呼び出しの連鎖を跡づけることができるようにします。
しかしながら、
最下位以外のスタック位置に存在する、
フレームを持たない関数に対しては、
@value{GDBN}は特別な処置を取りません。

@table @code
@kindex frame
@item frame @var{args}
@code{frame}コマンドによって、
あるスタック・フレームから別のスタック・フレームに移動し、
選択したスタック・フレームを表示させることができます。
@var{args}は、
フレームのアドレスまたはスタック・フレーム番号です。
引数なしで実行すると、
@code{frame}コマンドはカレントなスタック・フレームを表示します。

@kindex select-frame
@item select-frame
@code{select-frame}コマンドによって、
フレームを表示することなく、
あるスタック・フレームから別のスタック・フレームに移動することができます。
これは、
@code{frame}コマンドから、
表示処理を取り除いたものです。
@end table

@node Backtrace, Selection, Frames, Stack
@section バックトレース

@cindex backtraces
@cindex tracebacks
@cindex stack traces
@cindex バックトレース
@cindex トレースバック
@cindex スタック/トレース
バックトレースとは、
ユーザ・プログラムが現在いる箇所にどのようにして到達したかを示す要約情報です。
複数のフレームが存在する場合、
1フレームの情報を1行に表示します。
現在実行中のフレーム
（番号0のフレーム）
を先頭に、
それを呼び出したフレーム
（番号1のフレーム）
を次行に、
以降、
同様にスタックをさかのぼって情報を表示します。

@table @code
@kindex backtrace
@kindex bt
@item backtrace
@itemx bt
全スタックのバックトレースを表示します。
スタック内のすべてのフレームが、
1行に1フレームずつ表示されます。

システムの割り込み文字
（通常は、@kbd{Ctrl}キーを押しながら@kbd{C}を押す）
によって、
いつでもバックトレースを停止することができます。

@item backtrace @var{n}
@itemx bt @var{n}
引数のない@code{backtrace}コマンドと似ていますが、
最下位のフレームから数えて@var{n}個のフレームだけが表示されます。

@item backtrace -@var{n}
@itemx bt -@var{n}
引数のない@code{backtrace}コマンドと似ていますが、
最上位のフレームから数えて@var{n}個のフレームだけが表示されます。
@end table

@kindex where
@kindex info stack
@kindex info s
@code{backtrace}の別名としては、
ほかに@code{where}や@code{info stack}
（省略形は@code{info s}）
があります。

@code{backtrace}コマンドの出力結果の各行に、
フレーム番号と関数名が表示されます。
@code{set print address off}コマンドを実行していなければ、
プログラム・カウンタの値も表示されます。
@code{backtrace}コマンドの出力結果では、
関数への引数に加えて、
ソース・ファイル名や行番号も表示されます。
プログラム・カウンタが、
行番号で指定される行の最初のコードを指している場合、
その値は省略されます。

以下に@code{backtrace}の例を示します。
これは、
@samp{bt 3}の出力であり、
したがって最下位のフレームから3フレームが表示されています。

@smallexample
@group
#0  m4_traceon (obs=0x24eb0, argc=1, argv=0x2b8c8) 
    at builtin.c:993
#1  0x6e38 in expand_macro (sym=0x2b600) at macro.c:242
#2  0x6840 in expand_token (obs=0x0, t=177664, td=0xf7fffb08)
    at macro.c:71
(More stack frames follow...)
@end group
@end smallexample

@noindent
番号0のフレームを表示する行の先頭には、
プログラム・カウンタの値がありません。
これは、
@code{builtin.c}の@code{993}行めの最初のコードにおいて
ユーザ・プログラムが停止したことを表わしています。

@node Selection, Frame Info, Backtrace, Stack
@section フレームの選択

スタックやユーザ・プログラム内の他のデータを調べるためのほとんどのコマンドは、
それが実行された時点において選択されているスタック・フレーム上で動作します。
以下に、
スタック・フレームを選択するためのコマンドを列挙します。
どのコマンドも、
それによって選択されたスタック・フレームに関する簡単な説明を最後に表示します。

@table @code
@kindex frame
@kindex f
@item frame @var{n}
@itemx f @var{n}
番号@var{n}のフレームを選択します。
最下位の
（現在実行中の）
フレームが番号0のフレーム、
最下位のフレームを呼び出したフレームが番号1のフレーム、
以下同様となります。
最も大きい番号を持つフレームは@code{main}のフレームです。

@item frame @var{addr}
@itemx f @var{addr}
アドレス@var{addr}のフレームを選択します。
スタック・フレームの連鎖がバグのために破壊されてしまって、
@value{GDBN}がすべてのフレームに正しく番号を割り当てられないような場合に、
この方法が役に立ちます。
さらに、
ユーザ・プログラムが複数のスタックを持ち、
スタックの切り替えを行うような場合にも有効です。

@ifclear H8EXCLUSIVE
@ifclear HPPA
SPARCアーキテクチャでは、
フレームを任意に選択するには、
フレーム・ポインタ、
スタック・ポインタの2つのアドレスを@code{frame}に指定する必要があります。

MIPS、
Alphaの両アーキテクチャでは、
スタック・ポインタ、
プログラム・カウンタの2つのアドレスが必要です。

29kアーキテクチャでは、
レジスタ・スタック・ポインタ、
プログラム・カウンタ、
メモリ・スタック・ポインタの3つのアドレスが必要です。
@c note to future updaters: this is conditioned on a flag
@c SETUP_ARBITRARY_FRAME in the tm-*.h files.  The above is up to date
@c as of 27 Jan 1994.
@end ifclear
@end ifclear

@kindex up
@item up @var{n}
スタックを@var{n}フレームだけ上へ移動します。
@var{n}が正の値の場合、
最上位のフレームに向かって移動します。
これは、
より大きいフレーム番号を持ち、
より長く存在しているフレームへの移動です。
@var{n}のデフォルト値は、
0です。

@kindex down
@kindex do
@item down @var{n}
スタックを@var{n}フレームだけ下へ移動します。
@var{n}が正の値の場合、
最下位のフレームに向かって移動します。
これは、
より小さいフレーム番号を持ち、
より最近作成されたフレームへの移動です。
@var{n}のデフォルト値は1です。
@code{down}の省略形は@code{do}です。
@end table

これらのコマンドはいずれも、
最後にフレームに関する情報を2行で表示します。
1行めには、
フレーム番号、
関数名、
引数、
ソース・ファイル名、
そのフレーム内において実行停止中の行番号が表示されます。
2行めには、
実行停止中のソース行が表示されます。

@need 1000
以下に、
例を示します。

@smallexample
@group
(@value{GDBP}) up
#1  0x22f0 in main (argc=1, argv=0xf7fffbf4, env=0xf7fffbfc)
    at env.c:10
10              read_input_file (argv[i]);
@end group
@end smallexample

この情報が表示された後で、
@code{list}コマンドを引数なしで実行すると、
フレーム内で実行停止中の行を中心に10行のソース行が表示されます。
@xref{List, ,Printing source lines}。

@table @code
@kindex down-silently
@kindex up-silently
@item up-silently @var{n}
@itemx down-silently @var{n}
これら2つのコマンドは、
それぞれ、
@code{up}コマンド、
@code{down}コマンドの変種です。
相違点は、
ここに挙げた2つのコマンドが、
新しいフレームに関する情報を表示することなく実行されるという点にあります。
これらは、
情報の出力が不必要で邪魔ですらある、
@value{GDBN}のコマンド・スクリプトの中での使用を主に想定したものです。
@end table

@node Frame Info, Alpha/MIPS Stack, Selection, Stack
@section フレームに関する情報

既に挙げたもの以外にも、
選択されたフレームに関する情報を表示するコマンドがいくつかあります。

@table @code
@item frame
@itemx f
このコマンドは、
引数なしで実行されると、
別のフレームを選択するのではなく、
その時点において選択中のフレームに関する簡単な説明を表示します。
このコマンドの省略形は@code{f}です。
引数付きの場合、
このコマンドはスタック・フレームを選択するのに使用されます。
@xref{Selection, ,Selecting a frame}。

@kindex info frame
@kindex info f
@item info frame
@itemx info f
このコマンドは、
選択されたフレームに関する詳細な情報を表示します。
表示される情報には、
以下のようなものがあります。

@itemize @bullet
@item 
フレームのアドレス
@item
1つ下位の（選択されたフレームによって呼び出された）フレームのアドレス
@item
1つ上位の（選択されたフレームを呼び出した）フレームのアドレス
@item
選択されたフレームに対応するソース・コードを記述した言語
@item
フレームの引数のアドレス
@item
退避されているプログラム・カウンタ（呼び出し側フレームの実行アドレス）
@item
退避されているレジスタ
@end itemize

@noindent
これらの詳細な情報は、
何か問題が発生して、
スタックの形式が通常の慣習に合致しなくなった場合に、
役に立ちます。

@item info frame @var{addr}
@itemx info f @var{addr}
アドレス@var{addr}のフレームに関する詳細な情報を、
そのフレームを選択することなく表示します。
このコマンドによって、
その時点において選択されていたフレームとは異なるフレームが選択されてしまうことはありません。
このコマンドでは、
@code{frame}コマンドに指定するのと同様のアドレスを
（アーキテクチャによっては複数）
指定する必要があります。
@xref{Selection, ,Selecting a frame}。

@kindex info args
@item info args
選択中のフレームの引数を、
1行に1つずつ表示します。

@item info locals
@kindex info locals
選択中のフレームのローカル変数を、
1行に1つずつ表示します。
これらはすべて、
選択中のフレームの実行箇所においてアクセス可能な
（静的変数または自動変数として宣言された）
変数です。

@ifclear CONLY
@ifclear HPPA
@kindex info catch
@cindex catch exceptions
@cindex exception handlers
@cindex 例外のキャッチ[れいがいのキャッチ]
@cindex キャッチ、例外の[キャッチ、れいがいの]
@cindex 例外のハンドラ[れいがいのハンドラ]
@cindex ハンドラ、例外の[ハンドラ、れいがいの]
@item info catch
選択中のスタック・フレームの実行箇所においてアクティブな状態にある、
すべての例外ハンドラの一覧を表示します。
他の例外ハンドラを参照したい場合は、
関連するフレームに
（@code{up}コマンド、
@code{down}コマンド、
@code{frame}コマンドを使用して）
移動してから、
@code{info catch}を実行します。
@xref{Set Catchpoints, , Setting catchpoints}。
@end ifclear
@end ifclear
@end table

@node Alpha/MIPS Stack,  , Frame Info, Stack
@section MIPS/Alphaマシンの関数スタック

@cindex stack on Alpha
@cindex stack on MIPS
@cindex Alpha stack
@cindex MIPS stack
@cindex スタック、Alphaの
@cindex スタック、MIPSの
@cindex Alphaのスタック
@cindex MIPSのスタック
AlphaベースのコンピュータとMIPSベースのコンピュータは、
変わったスタック・フレームを使用しています。
そのため、
関数の先頭を見つけるために、
@value{GDBN}はときどきオブジェクト・コードを逆方向に検索する必要があります。

@cindex response time, MIPS debugging
@cindex 応答時間、MIPSデバッグの[おうとうじかん、MIPSデバッグの]
応答時間を改善するために
（特に、
このような検索を実行するのに、
速度の遅いシリアル回線を使用するほかない、
組み込みアプリケーションの場合）、
以下に列挙するコマンドを使用して検索量を制限するとよいでしょう。

@table @code
@cindex @code{heuristic-fence-post} (Alpha,MIPS)
@item set heuristic-fence-post @var{limit}
関数の先頭を検索するために@value{GDBN}が検査するバイト数を、
最高で@var{limit}バイトに制限します。
@var{limit}に@var{0}
（デフォルト）
を指定すると、
無制限に検索することを意味します。
@var{limit}に@var{0}以外の値を指定すると、
その値が大きければ大きいほど検索バイト数も多くなり、
したがって検索の実行により長い時間がかかります。

@item show heuristic-fence-post
現在の検索制限値を表示します。
@end table

@noindent
これらのコマンドは、
@value{GDBN}が、
Alphaプロセッサ上、
または、
MIPSプロセッサ上においてプログラムをデバッグするよう構成されている場合に
@emph{のみ}使用することができます。


@node Source, Data, Stack, Top
@chapter ソース・ファイルの検査

@value{GDBN}は、
ユーザ・プログラムのソース・コードの一部を表示することができます。
これは、
プログラムの中に記録されているデバッグ情報によって、
そのプログラムをビルドするのに使用されたソース・ファイルを
@value{GDBN}が知ることができるからです。
ユーザ・プログラムが停止すると、
@value{GDBN}は自発的にプログラムが停止した行を表示します。
同様に、
ユーザがあるスタック・フレーム
（@pxref{Selection, ,Selecting a frame}）
を選択すると、
そのフレームにおいて実行が停止している行を@value{GDBN}は表示します。
明示的にコマンドを使用することで、
ソース・ファイルの他の部分を表示することも可能です。

@ifclear DOSHOST
@sc{gnu} Emacsインターフェイス経由で@value{GDBN}を使用しているユーザは、
Emacsの提供する機能を使ってソース・ファイルを参照する方を好むかもしれません。
これについては、
@xref{Emacs, ,Using @value{GDBN} under @sc{gnu} Emacs}。
@end ifclear

@menu
* List::                        ソース行の表示
@ifclear DOSHOST
* Search::                      ソース・ファイル内の検索
@end ifclear

* Source Path::                 ソース・ディレクトリの指定
* Machine Code::                ソースとマシン・コード
@end menu

@node List, Search, Source, Source
@section ソース行の表示

@kindex list
@kindex l
ソース・ファイル内の行を表示するには、
@code{list}コマンド
（省略形は@code{l}）
を使用します。
デフォルトでは、
10行が表示されます。
ソース・ファイルのどの部分を表示するかを指定する方法がいくつかあります。

最もよく使われる@code{list}コマンドの形式を以下に示します。

@table @code
@item list @var{linenum}
現在のソース・ファイルの行番号@var{linenum}を中心に、
その前後の行を表示します。

@item list @var{function}
関数@var{function}の先頭を中心に、
その前後の行を表示します。

@item list
ソース・ファイル行の続きを表示します。
既に表示された最後の行が@code{list}コマンドによって表示されたのであれば、
その最後の行の次の行以降が表示されます。
しかし、
既に表示された最後の行が、
スタック・フレーム
（@pxref{Stack, ,Examining the Stack}）
の表示の一部として1行だけ表示されたのであれば、
その行の前後の行が表示されます。

@item list -
前回表示された行の前に位置する行を表示します。
@end table

@code{list}コマンドを上記の形式のいずれかによって実行すると、
@value{GDBN}はデフォルトでは10行のソース行を表示します。
これは@code{set listsize}コマンドによって変更することができます。

@table @code
@kindex set listsize
@item set listsize @var{count}
@code{list}コマンドで表示される行数を@var{count}に設定します
（@code{list}コマンドの引数で他の値が明示的に指定された場合は、
この設定は効力を持ちません）。

@kindex show listsize
@item show listsize
@code{list}コマンドが表示する行数を表示します。
@end table

@code{list}コマンドを実行後、
@key{RET}キーによって@code{list}コマンドを実行した場合、
引数は破棄されます。
したがって、
これは単に@code{list}と入力して実行したのと同じことになります。
同じ行が繰り返し表示されるよりも、
この方が役に立つでしょう。
ただし、
引数@samp{-}は例外となります。
この引数は繰り返し実行の際にも維持されるので、
繰り返し実行することで、
ソース・ファイルの内容がさかのぼって表示されていきます。

@cindex linespec
@cindex 行指定[ぎょうしてい]
一般的には、
@code{list}コマンドは、
ユーザによって0個、
1個、
または2個の@dfn{行指定}（@dfn{linespec}）が与えられることを期待しています。
ここで行指定とは、
ソース行を指定するものです。
いくつかの記述方法がありますが、
いずれも結果的には何らかのソース行を指定するものです。
@code{list}コマンドの引数として使用できる引数の完全な説明を以下に示します。

@table @code
@item list @var{linespec}
@var{linespec}によって指定される行を中心に、
その前後の行を表示します。

@item list @var{first},@var{last}
@var{first}行から@var{last}行までを表示します。
両引数はいずれも行指定です。

@item list ,@var{last}
@var{last}行までを表示します。

@item list @var{first},
@var{first}行以降を表示します。

@item list +
最後に表示された行の次の行以降を表示します。

@item list -
最後に表示された行の前の行以前を表示します。

@item list
前述のとおり。
@end table

以下に、
ソースの特定の1行を指定する方法を示します。
これは、
いずれも行指定です。

@table @code
@item @var{number}
現在のソース・ファイルの行番号@var{number}の行を指定します。
@code{list}コマンドの引数に2つの行指定がある場合、
2つめの行指定は、
最初の行指定と同一のソース・ファイルを指定します。

@item +@var{offset}
最後に表示された行から@var{offset}で指定される行数だけ下にある行を指定します。
2つの行指定を引数として持つ@code{list}コマンドにおいて、
これが2つめの行指定として使用される場合、
最初の行指定から@var{offset}で指定される行数だけ下の行を指定します。

@item -@var{offset}
最後に表示された行から@var{offset}で指定される行数だけ上にある行を指定します。

@item @var{filename}:@var{number}
ソース・ファイル@var{filename}の行番号@var{number}の行を指定します。

@item @var{function}
関数@var{function}の本体の先頭行を指定します。
例えばC言語では、
左括弧
（@samp{@{}）
のある行を指します。

@item @var{filename}:@var{function}
ファイル@var{filename}内の関数@var{function}の本体を開始する左括弧
（@samp{@{}）
のある行を指定します。
異なるソース・ファイルの中に同一の名前の関数が複数ある場合にのみ、
あいまいさを回避するために、
関数名とともにファイル名を指定する必要があります。

@item *@var{address}
プログラム・アドレス@var{address}を含む行を指定します。
@var{address}には任意の式を指定することができます。
@end table

@ifclear DOSHOST
@node Search, Source Path, List, Source
@section ソース・ファイル内の検索
@cindex searching
@cindex 検索[けんさく]
@kindex reverse-search

カレントなソース・ファイル内において正規表現による検索を行うためのコマンドが2つあります。

@table @code
@kindex search
@kindex forward-search
@item forward-search @var{regexp}
@itemx search @var{regexp}
@samp{forward-search @var{regexp}}コマンドは、
最後に@code{list}コマンドによって表示された行の1つ下の行から、
1行ずつ正規表現@var{regexp}による検索を行います。
正規表現にマッチするものが見つかると、
その行を表示します。
@samp{search @var{regexp}}という同義のコマンドを使うこともできます。
コマンド名は、
省略して@code{fo}とすることができます。

@item reverse-search @var{regexp}
@samp{reverse-search @var{regexp}}コマンドは、
最後に@code{list}コマンドによって表示された行の1つ上の行から、
1行ずつ逆方向に向かって正規表現@var{regexp}による検索を行います。
正規表現にマッチするものが見つかると、
その行を表示します。
コマンド名は、
省略して@code{rev}とすることができます。
@end table
@end ifclear

@node Source Path, Machine Code, Search, Source
@section ソース・ディレクトリの指定

@cindex source path
@cindex directories for source files
@cindex ソースのパス
@cindex ディレクトリ、ソース・ファイルの
実行形式プログラムは、
それがコンパイルされたソース・ファイルの名前だけを記録して、
ソース・ファイルの存在するディレクトリ名を記録しないことがあります。
また、
ディレクトリ名が記録された場合でも、
コンパイル時とデバッグ時との間に、
そのディレクトリが移動してしまっている可能性があります。
@value{GDBN}は、
ソース・ファイルを検索すべきディレクトリの一覧を持っています。
これは、
@dfn{ソース・パス}と呼ばれます。
@value{GDBN}は、
ソース・ファイルが必要なときにはいつでも、
それが見つかるまで、
このリストの中のすべてのディレクトリを、
リストの中に記述されている順に探します。
実行ファイルのサーチ・パスは、
この目的では@emph{使用されない}ことに気をつけてください。
またカレントな作業ディレクトリも、
それがたまたまソース・パスの中にある場合を除けば、
この目的で使用されることはありません。

@value{GDBN}がソース・パスの中でソース・ファイルを見つけることができない場合、
プログラムがディレクトリ名を記録してあれば、
そのディレクトリも検索されます。
ソース・パスにディレクトリの指定がなく、
コンパイルされたディレクトリの名前も記録されていない場合、
@value{GDBN}は最後の手段としてカレント・ディレクトリを探します。

ソース・パスを空にした場合、
または、
再調整した場合、
ソース・ファイルを見つけた場所や個々の行のファイル内の位置のような、
@value{GDBN}が内部でキャッシュしている情報は消去されます。

@kindex directory
@kindex dir
@value{GDBN}を起動した時点では、
ソース・パスにはディレクトリの指定がありません。
ディレクトリをソース・パスに追加するには、
@code{directory}コマンドを使用してください。

@table @code
@item directory @var{dirname} @dots{}
@item dir @var{dirname} @dots{}
ディレクトリ@var{dirname}をソース・パスの先頭に追加します。
個々のディレクトリをコロン@samp{:}または空白で区切ることによって、
複数のディレクトリをこのコマンドに渡すことができます。
ソース・パスの中に既に存在するディレクトリを指定することもできます。
この場合、
そのディレクトリの、
ソース・パスの中での位置が前に移動するので、
@value{GDBN}はそのディレクトリの中を以前よりも早く検索することになります。

@kindex cdir
@kindex cwd
@kindex $cdir
@kindex $cwd
@cindex compilation directory
@cindex current directory
@cindex working directory
@cindex directory, current
@cindex directory, compilation
@cindex コンパイルするディレクトリ
@cindex ディレクトリ、コンパイルする
@cindex カレントなディレクトリ
@cindex 現在のディレクトリ[げんざいのディレクトリ]
@cindex ディレクトリ、現在の[ディレクトリ、げんざいの]
@cindex 作業ディレクトリ[さぎょうディレクトリ]
（コンパイル時のディレクトリが記録されていれば）
それを指すのに文字列@samp{$cdir}を使うことができます。
また、
カレントな作業ディレクトリを指すには、
文字列@samp{$cwd}を使うことができます。
@samp{$cwd}と@samp{.}
（ピリオド）
とは同じではありません。
前者は、
@value{GDBN}セッション内においてカレントな作業ディレクトリが変更された場合、
変更されたディレクトリを指します。
これに対して後者は、
ソース・パスへの追加を行ったときに、
その時点におけるカレント・ディレクトリに展開されてしまいます。

@item directory
ソース・パスの内容を再び空にします。
ソース・パスを空にする前に、
確認を求めてきます。

@c RET-repeat for @code{directory} is explicitly disabled, but since
@c repeating it would be a no-op we do not say that.  (thanks to RMS)

@item show directories
@kindex show directories
ソース・パスを表示します。
ソース・パスに含まれるディレクトリ名を見ることができます。
@end table

ソース・パスの中に、
不要となってしまったディレクトリが混在していると、
@value{GDBN}が誤ったバージョンのソースを見つけてしまい、
混乱をもたらすことがあります。
以下の手順によって、
正常な状態にすることができます。

@enumerate
@item
ソース・パスを空にするために、
@code{directory}コマンドを引数なしで実行します。

@item
ソース・パス中に含めたいディレクトリが組み込まれるよう、
@code{directory}コマンドに適切な引数を指定して実行します。
すべてのディレクトリを、
1回のコマンド実行で追加することができます。
@end enumerate

@node Machine Code,  , Source Path, Source
@section ソースとマシン・コード

@code{info line}コマンドを使用してソース行をプログラム・アドレスに
（あるいは、
プログラム・アドレスをソース行に）
対応付けすることができます。
また、
@code{disassemble}コマンドを使用して、
あるアドレス範囲をマシン命令として表示することもできます。
@sc{gnu} Emacsモードで実行されている場合、
現在の@code{info line}コマンドは、
指定された行を示す矢印を表示します。
また、
@code{info line}コマンドは、
アドレスを16進形式だけではなくシンボリック形式でも表示します。

@table @code
@kindex info line
@item info line @var{linespec}
ソース行@var{linespec}に対応するコンパイル済みコードの開始アドレス、
終了アドレスを表示します。
@code{list}コマンド
（@pxref{List, ,Printing source lines}）
が理解できる任意の形式によってソース行を指定することができます。
@end table

例えば、
@code{info line}コマンドによって、
関数@code{m4_changequote}の最初の行に対応するオブジェクト・コードの位置を知ることができます。

@smallexample
(@value{GDBP}) info line m4_changecom
Line 895 of "builtin.c" starts at pc 0x634c and ends at 0x6350.
@end smallexample

@noindent
また、
（@var{linespec}の形式として@code{*@var{addr}}を使用することで）
ある特定のアドレスがどのソース行に含まれているのかを問い合わせることができます。

@smallexample
(@value{GDBP}) info line *0x63ff
Line 926 of "builtin.c" starts at pc 0x63e4 and ends at 0x6404.
@end smallexample

@cindex @code{$_} and @code{info line}
@code{info line}の実行後、
@code{x}コマンドのデフォルト・アドレスは、
その行の先頭アドレスに変更されます。
これにより、
マシン・コードの調査を開始するには@samp{x/i}を実行するだけで十分となります
（@pxref{Memory, ,Examining memory}）。
また、
このアドレスはコンビニエンス変数@code{$_}の値として保存されます
（@pxref{Convenience Vars, ,Convenience variables}）。

@table @code
@kindex disassemble
@cindex assembly instructions
@cindex instructions, assembly
@cindex machine instructions
@cindex listing machine instructions
@cindex アセンブリ命令の表示[アセンブリめいれいのひょうじ]
@cindex 命令の表示、アセンブリ[めいれいのひょうじ、アセンブリ]
@cindex マシン命令の表示[マシンめいれいのひょうじ]
@cindex 表示、マシン命令の[ひょうじ、マシンめいれいの]
@cindex 機械語命令の表示[きかいごめいれいのひようじ]
@cindex 逆アセンブル[ぎゃくアセンブル]
@item disassemble
この特殊コマンドは、
あるメモリ範囲をマシン命令としてダンプ出力します。
デフォルトのメモリ範囲は、
選択されたフレームにおいてプログラム・カウンタが指している箇所を含む関数です。
このコマンドに引数を1つ渡すと、
それはプログラム・カウンタ値を指定することになります。
@value{GDBN}は、
その値が指す箇所を含んでいる関数をダンプ出力します。
2つの引数を渡すと、
ダンプ出力するアドレス範囲
（1つめのアドレスは含まれますが、
2つめのアドレスは含まれません）
を指定することになります。
@end table

@ifclear H8EXCLUSIVE
以下の例は、
あるアドレス範囲のHP PA-RISC 2.0コードを逆アセンブルした結果を示しています。

@smallexample
(@value{GDBP}) disas 0x32c4 0x32e4
Dump of assembler code from 0x32c4 to 0x32e4:
0x32c4 <main+204>:      addil 0,dp
0x32c8 <main+208>:      ldw 0x22c(sr0,r1),r26
0x32cc <main+212>:      ldil 0x3000,r31
0x32d0 <main+216>:      ble 0x3f8(sr4,r31)
0x32d4 <main+220>:      ldo 0(r31),rp
0x32d8 <main+224>:      addil -0x800,dp
0x32dc <main+228>:      ldo 0x588(r1),r26
0x32e0 <main+232>:      ldil 0x3000,r31
End of assembler dump.
@end smallexample
@end ifclear

@ifset H8EXCLUSIVE
一例として、
以下に、
関数@code{fact}の逆アセンブル出力の先頭部分を示します。

@smallexample
(@value{GDBP}) disas fact
Dump of assembler code for function fact:
to 0x808c:
0x802c <fact>: 6d f2		mov.w r2,@@-r7
0x802e <fact+2>:  6d f3		mov.w r3,@@-r7
0x8030 <fact+4>:  6d f6		mov.w r6,@@-r7
0x8032 <fact+6>:  0d 76		mov.w r7,r6
0x8034 <fact+8>:  6f 70 00 08	mov.w @@(0x8,r7),r0
0x8038 <fact+12>  19 11		sub.w	r1,r1
 .
 .
 . 
@end smallexample
@end ifset

アーキテクチャによっては、
一般に使用される命令ニーモニックを複数持つものや、
異なる構文を持つものがあります。

@table @code
@kindex set assembly-language
@cindex assembly instructions
@cindex instructions, assembly
@cindex machine instructions
@cindex listing machine instructions
@c {{原文の索引項目が数十行前のそれらと同一なので、ちょっと工夫。}}
@cindex アセンブリ言語の選択[アセンブリげんごのせんたく]
@cindex 命令セット[めいれいセット]
@cindex マシン命令の選択[マシンめいれいのせんたく]
@cindex 選択、マシン命令の[せんたく、マシンめいれいの]
@cindex 機械語命令の選択[きかいごめいれいのせんたく]
@item set assembly-language @var{instruction-set}
@code{disassemble}コマンドまたは@code{x/i}コマンドによってプログラムの逆アセンブルを行う際に使用する
命令セットを選択します。

現在のところ、
このコマンドは、
Intel x86ファミリに対してのみ定義されています。
@var{instruction-set}は、
@code{i386}と@code{i8086}のいずれかにセットすることができます。
デフォルトは@code{i386}です。
@end table


@node Data, Languages, Source, Top
@chapter データの検査

@cindex printing data
@cindex examining data
@cindex データの検査[データのけんさ]
@cindex 検査、データの[けんさ、データの]
@cindex 出力、データの[しゅつりょく、データの]
@cindex 表示、データの[ひょうじ、データの]
@kindex print
@kindex inspect
@c "inspect" is not quite a synonym if you are using Epoch, which we do not
@c document because it is nonstandard...  Under Epoch it displays in a
@c different window or something like that.
ユーザ・プログラムの中のデータを調べる通常の方法は、
@code{print}コマンド
（省略形は@code{p}）、
またはそれと同義のコマンドである
@code{inspect}コマンドを使用することです。
@ifclear CONLY
これは、
ユーザ・プログラムが記述された言語
（@pxref{Languages, ,Using @value{GDBN} with Different Languages}）
による式を評価し、
その値を出力するものです。
@end ifclear

@table @code
@item print @var{exp}
@itemx print /@var{f} @var{exp}
@var{exp}は
（ソース言語による）
式です。
デフォルトでは、
@var{exp}の値は、
@var{exp}のデータ型にとって適切な形式で表示されます。
@samp{/@var{f}}を指定することで、
他の形式を選択することも可能です。
@samp{/@var{f}}の@var{f}は形式を指定する文字です。
@pxref{Output Formats,,Output formats}。

@item print
@itemx print /@var{f}
@var{exp}を省略すると、
@value{GDBN}は@dfn{値ヒストリ}
（@pxref{Value History, ,Value history}）
の最後の値を再表示します。
これは、
同じ値を異なる形式で調べるのに便利です。
@end table

データを調べるためのより低レベルの方法は、
@code{x}コマンドを使うことです。
これは、
指定されたアドレスのメモリ上のデータを、
指定された形式で表示するものです。
@xref{Memory, ,Examining memory}。

型に関する情報に関心があるとき、
また、
構造体
@ifclear CONLY
やクラス
@end ifclear
のフィールドがどのように宣言されているかという点に関心があるときは、
@code{print}コマンドではなく@code{ptype @var{exp}}コマンドを使用してください。
@xref{Symbols, ,Examining the Symbol Table}。

@menu
* Expressions::                 式
* Variables::                   プログラム変数
* Arrays::                      人工配列
* Output Formats::              出力フォーマット
* Memory::                      メモリの調査
* Auto Display::                自動表示
* Print Settings::              表示設定
* Value History::               値ヒストリ
* Convenience Vars::            コンビニエンス変数
* Registers::                   レジスタ
@ifclear HAVE-FLOAT
* Floating Point Hardware::     浮動小数ハードウェア
@end ifclear

@end menu

@node Expressions, Variables, Data, Data
@section 式

@cindex expressions
@cindex 式[しき]
@code{print}コマンド、
および、
ほかの多くの@value{GDBN}コマンドは、
式を受け取って、
その値を評価します。
ユーザの使用しているプログラミング言語によって定義されている定数、
変数、
演算子は、
いずれも@value{GDBN}における式の中で有効です。
これには、
条件式、
関数呼び出し、
キャスト、
文字列定数が含まれます。
しかし、
プリプロセッサの@code{#define}コマンドによって定義されるシンボルは、
残念ながら含まれません。

現在の@value{GDBN}は、
ユーザの入力する式において配列定数をサポートします。
@c {{原文では、@var{@{element, element@dots{}@}} }}
その構文は、
@var{@{element, element}@dots{}@var{@}}です。
例えば、
コマンド@code{print @{1, 2, 3@}}を使用して、
ターゲット・プログラム内で@code{malloc()}によって獲得されたメモリ内に配列を作成することができます。

@ifclear CONLY
C言語は大変広汎に使用されているので、
このマニュアルの中で示される例の中の式はC言語で記述されています。
他の言語での式の使い方に関する情報については、
@xref{Languages, , Using @value{GDBN} with Different Languages}。

この節では、
プログラミング言語によらず@value{GDBN}の式で使用できる演算子を説明します。

キャストは、
C言語のみならず、
すべての言語でサポートされています。
これは、
メモリ内のあるアドレスにある構造体を調べるのに、
数値をポインタにキャストするのが大変便利であるからです。
@c FIXME: casts supported---Mod2 true?
@end ifclear

プログラミング言語によらず共通に使用可能な演算子に加えて、
@value{GDBN}は以下の演算子をサポートしています。

@table @code
@item @@
@samp{@@}は、
メモリの一部を配列として処理するための2項演算子です。
詳細については、
@xref{Arrays, ,Artificial arrays}。

@item ::
@samp{::}によって、
それを定義している関数またはファイルを特定して、
変数を指定することができます。
@xref{Variables, ,Program variables}。

@cindex @{@var{type}@}
@cindex type casting memory
@cindex memory, viewing as typed object
@cindex casts, to view memory
@cindex 型変換したメモリ[かたへんかんしたメモリ]
@cindex メモリ、型変換した[メモリ、かたへんかんした]
@cindex キャストしたメモリ
@item @{@var{type}@} @var{addr}
@var{addr}で示されるメモリ上のアドレスに格納されている、
@var{type}で示される型のオブジェクトを参照します。
@var{addr}には、
評価結果が整数値またはポインタになるような任意の式を指定することができます
（ただし、
2項演算子の前後には、
キャストを使う場合と同様の括弧が必要です）。
これは、
@var{addr}の位置に通常存在するデータの型がいかなるものであろうとも、
使用することができます。
@end table

@node Variables, Arrays, Expressions, Data
@section プログラム変数

最も一般的に使用される式は、
ユーザ・プログラム内部の変数名です。

式の中の変数は、
選択されたスタック・フレーム
（@pxref{Selection, ,Selecting a frame}）
内において解釈されます。
これは、
以下の2つのいずれかとなります。

@itemize @bullet
@item
グローバル変数
（または、
ファイル・スコープの静的変数）
@end itemize

@noindent
あるいは 

@itemize @bullet
@item
プログラム言語のスコープ規則によって、
そのフレームの実行中の箇所から可視の変数
@end itemize  

@noindent
つまり、
以下の例において、
ユーザ・プログラムが関数@code{foo}を実行中は、
変数@code{a}を調べたり使用したりすることができますが、
変数@code{b}を使用したり調べたりすることができるのは、
@code{b}が宣言されているブロックの内部をユーザ・プログラムが実行中である場合に限られます。

@example
foo (a)
     int a;
@{
  bar (a);
  @{
    int b = test ();
    bar (b);
  @}
@}
@end example

@cindex variable name conflict
@cindex 変数名の衝突[へんすうめいのしょうとつ]
ただし、
これには1つ例外があります。
特定の1ソース・ファイルをスコープとする変数や関数は、
たとえ現在の実行箇所がそのファイルの中ではなくても、
参照することができます。
しかし、
このような変数または関数が
（異なるソース・ファイル中に）
同じ名前で複数個存在するということがありえます。
このような場合、
その名前を参照すると予期できない結果をもたらします。
2つのコロンを並べる記法によって、
特定の関数またはファイルの中の静的変数を指定することができます。

@cindex colon-colon
@cindex 2重コロン[2じゅうコロン]
@cindex 2つのコロン[2つのコロン]
@iftex
@c info cannot cope with a :: index entry, but why deprive hard copy readers?
@kindex ::
@end iftex
@example
@var{file}::@var{variable}
@var{function}::@var{variable}
@end example

@noindent
ここで@var{file}または@var{function}は、
静的変数@var{variable}のコンテキスト名です。
ファイル名の場合は、
引用符を使用することによって、
@value{GDBN}がファイル名を確実に1つの単語として解釈するようにさせることができます。
例えば、
ファイル@file{f2.c}の中で定義されたグローバル変数@code{x}の値を表示するには、

@example
(@value{GDBP}) p 'f2.c'::x
@end example

@noindent
のようにします。

@ifclear CONLY
@cindex C++ scope resolution
@cindex C++のスコープ解決[C++のスコープかいけつ]
このような@samp{::}の用途が、
これと非常によく似ているC++における@samp{::}の用途と衝突することは非常に稀です。
@value{GDBN}は、
式の内部においてC++のスコープ解釈演算子の使用もサポートしています。
@c FIXME: Um, so what happens in one of those rare cases where it's in
@c conflict??  --mew
@end ifclear

@cindex wrong values
@cindex variable values, wrong
@cindex 正しくない値[ただしくないあたい]
@cindex 変数値、正しくない[へんすうち、ただしくない]
@quotation
@emph{注意:}
ときどき、
新しいスコープに入った直後やスコープから出る直前に、
関数内部の特定の箇所から見ると、
ローカル変数の値が正しくないように見えることがあります。
@end quotation
マシン命令単位でステップ実行を行っているときに、
このような問題を経験することがあるかもしれません。
これは、
ほとんどのマシンでは、
（ローカル変数定義を含む）
スタック・フレームのセットアップに複数の命令が必要となるからです。
マシン命令単位でステップ実行を行う場合、
スタック・フレームが完全に構築されるまでの間は、
変数の値が正しくないように見えることがあります。
スコープから出るときには、
スタック・フレームを破棄するのに、
通常複数のマシン命令が必要とされます。
それらの命令群の中をステップ実行し始めた後には、
ローカル変数の定義は既に存在しなくなっているかもしれません。

このようなことは、
コンパイラが重要な最適化を実施する場合にも、
発生する可能性があります。
常に正確な値が見えることを確実にするためには、
コンパイルの際に、
すべての最適化を行わないようにします。

@node Arrays, Output Formats, Variables, Data
@section 人工配列

@cindex artificial array
@cindex 人工配列[じんこうはいれつ]
@kindex @@
メモリ内に連続的に配置されている同一型のオブジェクトを表示することが役に立つことがよくあります。
配列の一部や動的にサイズの決定される配列にアクセスするのに、
そこへのポインタしかプログラム内部に存在しないような場合です。

これは、
2項演算子@samp{@@}を使用して、
連続したメモリ範囲を@dfn{人工配列}として参照することで可能です。
@samp{@@}の左側のオペランドは、
参照したい配列の最初の要素で、
かつ、
1個のオブジェクトでなければなりません。
また、
右側のオペランドは、
その配列の中の参照したい部分の長さでなければなりません。
結果は、
その要素がすべて左側の引数と同型である配列の値です。
第1の要素は左側の引数そのものです。
第2の要素は、
第1の要素を保持するメモリ域の直後のメモリ上から取られます。
これ以降の要素も同様です。
以下に例を示します。
プログラムが以下のようになっているとしましょう。

@example
int *array = (int *) malloc (len * sizeof (int));
@end example

@noindent
以下を実行することで、
@code{array}の内容を表示することができます。

@example
p *array@@len
@end example

@samp{@@}の左側のオペランドは、
メモリ上に実在するものでなければなりません。
このような方法で@samp{@@}によって作成された配列の値は、
配列の添字付けの見地からは他の配列と同様に振る舞い、
式の中で使用された場合は強制的にポインタとして扱われます。
人工配列は、
一度表示された後、
値ヒストリ
（@pxref{Value History, ,Value history}）
を通して式の中に現れることがよくあります。

人工配列を作成するもう1つの方法は、
キャストを使用することです。
これによって、
ある値を配列として解釈し直します。
この値は、
メモリ上に実在するものでなくてもかまいません。
@example
(@value{GDBP}) p/x (short[2])0x12345678
$1 = @{0x1234, 0x5678@}
@end example

ユーザの便宜を考慮して、
（例えば、
@c {{原文では「@samp{(@var{type})[])@var{value}}」}}
@samp{(@var{type}[])@var{value}}のように）
配列の長さが省略された場合
その値を満たすサイズを
（@samp{sizeof(@var{value})/sizeof(@var{type})}のように）
@value{GDBN}が計算します。
@example
(@value{GDBP}) p/x (short[])0x12345678
$2 = @{0x1234, 0x5678@}
@end example

ときには、
人工配列の機構では十分でないことがあります。
かなり複雑なデータ構造では、
関心のある要素が連続的に並んでいないことがあります。
例えば、
配列の中のポインタの値に関心がある場合です。
このような状況において役に立つ回避策の1つに、
関心のある値のうち最初のものを表示する式の中のカウンタとしてコンビニエンス変数
（@pxref{Convenience Vars, ,Convenience variables}）
を使用し、
@key{RET}キーによってその式を繰り返し実行することです。
例えば、
構造体へのポインタの配列@code{dtab}があり、
個々の構造体のフィールド@code{fv}の値に関心があるとしましょう。
以下に、
この場合の例を示します。

@example
set $i = 0
p dtab[$i++]->fv
@key{RET}
@key{RET}
@dots{}
@end example

@node Output Formats, Memory, Arrays, Data
@section 出力フォーマット

@cindex formatted output
@cindex output formats
@cindex 出力フォーマット[しゅつりょくフォーマット]
@cindex フォーマット、出力[フォーマット、しゅつりょく]
@cindex 整形した出力[せいけいしたしゅつりょく]
デフォルトでは、
@value{GDBN}はデータの型にしたがって値を表示します。
ときには、
これが望ましくない場合もあります。
例えば、
数値を16進で表示したい場合やポインタを10進で表示したい場合があるでしょう。
あるいは、
メモリ内のある特定のアドレスのデータを文字列や命令として表示させたい場合もあるでしょう。
このようなことをするためには、
値を表示するときに@dfn{出力フォーマット}を指定します。

出力フォーマットの最も単純な使用方法は、
既に評価済みの値の表示方法を指定することです。
これは、
@code{print}コマンドの最初の引数をスラッシュとフォーマット文字で開始することで行います。
サポートされているフォーマット文字は、
以下のとおりです。

@table @code
@item x
値を整数値とみなし、
16進で表示します。

@item d
値を符号付き10進の整数値として表示します。

@item u
値を符号なし10進の整数値として表示します。

@item o
値を8進の整数値として表示します。

@item t
値を2進の整数値として表示します。
@samp{t}はtwoを省略したものです。
@footnote{原注：フォーマット文字@samp{b}は使用できません。
フォーマット文字は@code{x}コマンドでも共通して使用されますが、
@code{x}コマンドでは、
@samp{b}はbyteの省略形として使用されているためです。
@xref{Memory,,Examining memory}。}

@item a
@cindex unknown address, locating
@cindex 未知のアドレス[みちのアドレス]
値を、
16進の絶対アドレス、
および、
そのアドレスより前にあるシンボルのうち最も近い位置にあるものからのオフセット・アドレスとして表示します。
このフォーマットを使用することで、
未知のアドレスがどこに
（どの関数の中に）
あるのかを知ることができます。

@example
(@value{GDBP}) p/a 0x54320
$3 = 0x54320 <_initialize_vx+396>
@end example

@item c
値を整数値とみなし、
文字定数として表示します。

@item f
値を浮動小数点数値とみなし、
典型的な浮動小数点の構文で出力します。
@end table

例えば、
プログラム・カウンタの値を16進数で表示する
（@pxref{Registers}）
には、
以下を実行してください。

@example
p/x $pc
@end example

@noindent
スラッシュの前にはスペースが必要ではないことに注意してください。
これは、
@value{GDBN}のコマンド名にはスラッシュを含めることができないからです。

値ヒストリの最後の値を異なる形式で再表示するには、
@code{print}コマンドに対して式を指定せずにフォーマットだけを指定して実行します。
例えば、
@samp{p/x}を実行すると最後の値を16進で再表示します。

@node Memory, Auto Display, Output Formats, Data
@section メモリの調査

コマンド@code{x}
（examineのx）
を使用することで、
ユーザ・プログラム内のデータ型にかかわらず、
メモリ上の値をいくつかの形式で調べることができます。

@cindex examining memory
@cindex 調査、メモリの[ちょうさ、メモリの]
@table @code
@kindex x
@item x/@var{nfu} @var{addr}
@itemx x @var{addr}
@itemx x
メモリ上の値を調べるには@code{x}コマンドを使用してください。
@end table

@var{n}、
@var{f}、
@var{u}はいずれも、
どれだけのメモリをどのようにフォーマットして表示するかを指定するための、
必須ではないパラメータです。
@var{addr}は、
メモリの表示を開始するアドレスを指定する式です。
@var{nfu}の部分にデフォルトを使用するのであれば、
スラッシュ@samp{/}は必要ありません。
いくつかのコマンドによって、
@var{addr}に対して便利なデフォルト値を指定することができます。

@table @r
@item @var{n}（繰り返し回数）
繰り返し回数は10進の整数値です。
デフォルトは1です。
これによって、
（単位@var{u}の）
メモリをどれだけ表示するかを指定します。
@c This really is **decimal**; unaffected by 'set radix' as of GDB
@c 4.1.2.

@item @var{f}（表示フォーマット）
表示フォーマットには、
@code{print}コマンドによって使用されるフォーマット、
@samp{s}（NULL文字で終了する文字列）、
@samp{i}（マシン命令）
のいずれかを指定します。
初期状態では、
デフォルトは@samp{x}
（16進）
です。
デフォルトは、
@code{x}コマンドまたは@code{print}コマンドを実行するたびに変更されます。

@item @var{u}（メモリ・サイズの単位）
単位の大きさは以下のいずれかになります。

@table @code
@item b
バイト
@item h
ハーフ・ワード（2バイト）
@item w
ワード（4バイト）---これが初期状態のデフォルトです。
@item g
ジャイアント・ワード（8バイト）
@end table

@code{x}コマンド実行時に単位の大きさを指定するたびに、
その大きさが、
次に@code{x}コマンドを実行する際のデフォルトになります
（フォーマット@samp{s}および
@samp{i}については、
単位の大きさは無視されます。
これらについては、
通常、
単位の大きさを指定しません）。

@item @var{addr}（表示を開始するアドレス）
@var{addr}は、
@value{GDBN}にメモリの表示を開始させたいアドレスです。
この式は、
必ずしもポインタ値を持つ必要はありません
（ポインタ値を持つことも可能です）。
これは常に、
メモリ内のある1バイトを指す整数値のアドレスとして解釈されます。
式に関する詳細については、
@xref{Expressions, ,Expressions}。
@var{addr}のデフォルトは通常、
最後に調べられたアドレスの次のアドレスになります。
しかし、
ほかのコマンドによってもデフォルトのアドレスが設定されます。
該当するコマンドは、
@code{info breakpoints}
（デフォルトは、
最後に表示されたブレイクポイントのアドレスに設定されます）、
@code{info line}
（デフォルトは、
行の先頭アドレスに設定されます）、
および@code{print}コマンド
（メモリ内の値を表示するのに使用した場合）
です。
@end table

例えば、
@samp{x/3uh 0x54320}は、
先頭アドレス@code{0x54320}から始めて、
メモリ上の3個のハーフ・ワード
（@code{h}）
の値を、
符号なし10進整数値
（@samp{u}）
としてフォーマットして表示するよう求める要求です。
また、
@samp{x/4xw $sp}は、
スタック・ポインタ
（@samp{$sp}については、
@pxref{Registers}）
の上位4ワード
（@samp{w}）
のメモリの内容を16進
（@samp{x}）
で表示します。

単位の大きさを示す文字と出力フォーマットを指定する文字とは異なるので、
単位の大きさとフォーマットのどちらが前にくるべきかを記憶しておく必要はありません。
どちらを先に記述しても動作します。
@samp{4xw}という出力指定と@samp{4wx}という出力指定とは、
全く同一の意味を持ちます
（ただし、
繰り返し回数@var{n}は最初に指定しなければなりません。
@samp{wx4}ではうまく動きません）。

単位の大きさ@var{u}は、
フォーマット@samp{s}および@samp{i}については無視されますが、
繰り返し回数@var{n}を使用したいことがあるかもしれません。
例えば、
@samp{3i}はオペランドも含めて3つのマシン命令を表示したいということを指定しています。
@code{disassemble}コマンドは、
マシン命令を調べる別の方法を提供してくれます。
@xref{Machine Code,,Source and machine code}。

@code{x}コマンドへの引数のデフォルトはすべて、
@code{x}コマンドを使用してメモリ上を連続的に参照するために最少の情報だけを指定すればよいように設計されています。
例えば、
@samp{x/3i @var{addr}}によってマシン命令を調べた後、
@samp{x/7}とするだけで、
続く7個のマシン命令を調べることができます。
@key{RET}キーによって@code{x}コマンドを繰り返し実行する場合は、
前回の繰り返し回数@var{n}が再度使用されます。
その他の引数も、
後続の@code{x}コマンド使用時のデフォルトになります。

@cindex @code{$_}, @code{$__}, and value history
@cindex 値ヒストリと@code{$_}や@code{$__}[あたいヒストリと$_や$__]
@code{x}コマンドによって表示されるアドレスや内容は、
値ヒストリに保存されません。
これらの数がしばしば膨大になり、
邪魔になるからです。
その代わりに@value{GDBN}は、
これらの値をコンビニエンス変数@code{$_}および@code{$__}の値として、
後続の式の内部で使用できるようにします。
@code{x}コマンドを実行後、
最後に調べられたアドレスは、
コンビニエンス変数@code{$_}の値として式の中で使用することができます。
また、
@value{GDBN}によって調べられたそのアドレスの内容は、
コンビニエンス変数@code{$__}の値として使用可能です。

@code{x}コマンドに繰り返し回数が指定されている場合、
保存されるのは、
最後に表示されたメモリ単位のアドレスとその内容です。
これは、
最後の出力行にいくつかのメモリ単位が表示されている場合は、
最後に表示されたアドレス値と一致しません。

@node Auto Display, Print Settings, Memory, Data
@section 自動表示
@cindex automatic display
@cindex display of expressions
@cindex 自動表示[じどうひょうじ]
@cindex 式の表示[しきのひょうじ]

ある1つの式の値を
（それがどのように変化するかを見るために）
頻繁に表示したい場合は、
その式を@dfn{自動表示リスト}に加えて、
ユーザ・プログラムが停止するたびに、
@value{GDBN}がその値を表示するようにするとよいでしょう。
リストに加えられた個々の式には、
それを識別するための番号が割り当てられます。
ある式をリストから削除する際に、
その番号を指定します。
自動表示は、
例えば以下のように表示されます。

@example
2: foo = 38
3: bar[5] = (struct hack *) 0x3804
@end example

@noindent
ここでは、
項目番号、
式、
および、
その式の現在の値が表示されます。
@code{x}コマンドや@code{print}コマンドによって手動で表示を要求する場合と同様、
好みの出力フォーマットを指定することができます。
実は、
@code{display}コマンドは、
ユーザのフォーマットの指定の詳細度によって、
@code{print}コマンドと@code{x}コマンドのいずれを使用するかを決定しています。
単位の大きさが指定された場合や、
@code{x}コマンドでしかサポートされていない2つのフォーマット
（@samp{i}と@samp{s}）
のいずれかが指定された場合には、
@code{x}コマンドが使用されます。
それ以外の場合は、
@code{print}コマンドが使用されます。

@table @code
@kindex display
@item display @var{exp}
ユーザ・プログラムが停止するたびに表示される式のリストに、
式@var{exp}を追加します。
@xref{Expressions, ,Expressions}。

コマンドの実行後に@key{RET}キーを押しても、
@code{display}コマンドは繰り返し実行されません。

@item display/@var{fmt} @var{exp}
@var{fmt}の部分に、
大きさや繰り返し回数は指定せず、
出力フォーマットだけを指定した場合は、
式@var{exp}を自動表示リストに追加して、
出力時のフォーマットが常に、
指定されたフォーマット@var{fmt}になるよう調整します。
@xref{Output Formats,,Output formats}。

@item display/@var{fmt} @var{addr}
@var{fmt}の部分に@samp{i}、
@samp{s}を指定した場合、
あるいは、
単位の大きさ、
単位の数を指定した場合は、
ユーザ・プログラムが停止するたびに調べるメモリ・アドレスとして式@var{addr}を追加します。
ここで「調べる」というのは、
実際には@samp{x/@var{fmt} @var{addr}}を実行することを意味します。
@xref{Memory, ,Examining memory}。
@end table

例えば、
@samp{display/i $pc}は、
ユーザ・プログラムが停止するたびに、
次に実行されるマシン命令を見るのに便利です
（@samp{$pc}は、
プログラム・カウンタを指すのに一般に使用される名前です。
@pxref{Registers}）。

@table @code
@kindex delete display
@kindex undisplay
@item undisplay @var{dnums}@dots{}
@itemx delete display @var{dnums}@dots{}
表示すべき式のリストから、
項目番号@var{dnums}に対応する要素を削除します。

@code{undisplay}コマンドを実行後に@key{RET}キーを押しても、
コマンドは再実行されません
（仮に再実行されてしまうとすると、
@samp{No display number @dots{}}というエラーになるだけです）。

@kindex disable display
@item disable display @var{dnums}@dots{}
項目番号@var{dnums}の表示を不可にします。
表示不可にされた表示項目は自動的には表示されませんが、
削除されたわけではありません。
後に、
表示可能にすることができます。

@kindex enable display
@item enable display @var{dnums}@dots{}
項目番号@var{dnums}の表示を可能にします。
これにより、
表示不可が指定されるまで、
式の自動表示が再度有効になります。

@item display
リスト上の式のカレントな値を表示します。
これは、
ユーザ・プログラムが停止したときに実行されるのと同一の処理です。

@kindex info display
@item info display
自動的に表示されるよう設定された式のリストを表示します。
個々の式の項目番号は表示されますが、
値は表示されません。
このリストには、
表示不可になっている式も含まれ、
そのことが分かるようにマーク付けされています。
また、
表示されるリストには、
その時点ではアクセスできない自動変数を参照しているために、
その時点では値を表示することのできない式も含まれます。
@end table

表示される式がローカル変数への参照を含む場合、
そのローカル変数がセットアップされているコンテキストの範囲外では、
その式は無意味です。
このような式は、
その中の変数の1つでも定義されないコンテキストが実行開始されると表示不可になります。
例えば、
引数@code{last_char}を取る関数の内部で@code{display last_char}コマンドを実行すると、
その関数の内部でユーザ・プログラムが実行を停止し続ける間は、
@value{GDBN}はこの引数を表示します。
ほかの箇所
（@code{last_char}という変数が存在しない箇所）
で停止したときには、
自動的に表示不可となります。
次にユーザ・プログラムが@code{last_char}が意味を持つ箇所で停止したときには、
再びその式の表示を可能にすることができます。

@node Print Settings, Value History, Auto Display, Data
@section 表示設定

@cindex format options
@cindex print settings
@cindex フォーマットのオプション
@cindex 表示設定[ひょうじせってい]
@value{GDBN}は、
配列、
構造体、
シンボルをどのように表示するかを制御するための方法を提供しています。

@noindent
これらの設定は、どのプログラミング言語で記述されたプログラムのデバッグにも便利です。

@table @code
@kindex set print address
@item set print address
@itemx set print address on
これにより@value{GDBN}は、
メモリ・アドレスの内容を表示する場合でも、
スタック・トレース、
構造体の値、
ポインタの値、
ブレイクポイントなどの位置を示すアドレスを表示します。
デフォルトは@code{on}です。
例として、
@code{set print address on}のときのスタック・フレームの表示結果を示します。

@smallexample
@group
(@value{GDBP}) f
#0  set_quotes (lq=0x34c78 "<<", rq=0x34c88 ">>")
    at input.c:530
530         if (lquote != def_lquote)
@end group
@end smallexample

@item set print address off
アドレスの内容を表示するときには、
そのアドレスを表示しません。
例えば、
@code{set print address off}のときに前の例と同一のスタック・フレームを表示すると、
以下のようになります。

@smallexample
@group
(@value{GDBP}) set print addr off
(@value{GDBP}) f
#0  set_quotes (lq="<<", rq=">>") at input.c:530
530         if (lquote != def_lquote)
@end group
@end smallexample

@samp{set print address off}を使用することで、
@value{GDBN}のインターフェイスからマシンに依存する表示を取り除くことができます。
例えば、
@code{print address off}を指定してあれば、
ポインタ引数の有無にかかわらず、
すべてのマシン上において同一のバックトレース情報を得るはずです。

@kindex show print address
@item show print address
アドレスが表示されるか否かを示します。
@end table

@value{GDBN}がシンボリックなアドレスを表示する際には通常、
そのアドレスの前にある最も近い位置のシンボルと、
そのシンボルからのオフセットを表示します。
そのシンボルによってアドレスが一意に決まらない場合
（例えば、
単一のファイル内でのみ有効な名前である場合）
には、
確認の必要があるかもしれません。
1つの方法は、
例えば@samp{info line *0x4537}のように、
@code{info line}コマンドを実行することです。
または、
シンボリックなアドレスを表示するときに、
一緒にソース・ファイルや行番号を表示するよう@value{GDBN}を設定する方法もあります。

@table @code
@kindex set print symbol-filename
@item set print symbol-filename on
シンボリックな形式のアドレスの表示において、
そのシンボルのソース・ファイル名と行番号を表示するよう@value{GDBN}に通知します。

@item set print symbol-filename off
シンボルのソース・ファイル名と行番号を表示しません。これがデフォルトです。

@kindex show print symbol-filename
@item show print symbol-filename
シンボリックな形式でのアドレス表示において、
@value{GDBN}がそのシンボルのソース・ファイル名と行番号を表示するか否かを示します。
@end table

シンボルのソース・ファイル名と行番号を表示するのが役に立つもう1つの状況として、
コードを逆アセンブルする場合があります。
@value{GDBN}が、
個々の命令に対応する行番号とソース・ファイルを表示してくれます。

また、
アドレスをシンボリック形式で表示させるのは、
そのアドレスと、
そのアドレスより前にあるシンボルのうち、
そのアドレスに最も近い位置にあるものとの間が適度に接近している場合に限定させたい
こともあるもでしょう。

@table @code
@kindex set print max-symbolic-offset
@item set print max-symbolic-offset @var{max-offset}
アドレスと、
そのアドレスより前にある最も近いシンボルの間のオフセットが@var{max-offset}未満のときのみ、
そのアドレスをシンボリックな形式で表示するよう@value{GDBN}に通知します。
デフォルトは0で、
これは@value{GDBN}に対して、
アドレスより前にシンボルがある場合には、
常にそのアドレスをシンボリックな形式で表示するよう通知します。

@kindex show print max-symbolic-offset
@item show print max-symbolic-offset
@value{GDBN}がシンボリックなアドレスを表示する上限となる、
最大のオフセット値を問い合わせます。
@end table

@cindex wild pointer, interpreting
@cindex pointer, finding referent
@cindex ポインタの参照する位置[ポインタのさんしょうするいち]
@cindex 参照する位置、ポインタの[さんしょうするいち、ポインタの]
@cindex シンボリック形式のアドレス解釈[シンボリックけいしきのアドレスかいしゃく]
あるポインタがどこを指しているか定かではない場合には、
@samp{set print symbol-filename on}を試みてください。
こうすれば、
@samp{p/a @var{pointer}}を使用して、
そのポインタが指している変数の名前とソース・ファイル上の位置が分かります。
これは、
アドレスをシンボリック形式で解釈します。
例えば以下の例では、
ある変数@code{ptt}がファイル@file{hi2.c}内で定義された別の変数@code{t}を指していることを、
@value{GDBN}が教えてくれています。

@example
(@value{GDBP}) set print symbol-filename on
(@value{GDBP}) p/a ptt
$4 = 0xe008 <t in hi2.c>
@end example

@quotation
@emph{注意:}
ローカル変数を指すポインタについては、
たとえ適切な@code{set print}オプションが有効になっていても、
@samp{p/a}はそのポインタによって参照される変数のシンボル名やファイル名を表示しません。
@end quotation

異なる種類のオブジェクトについては、
他の設定によって表示方法が制御されます。

@table @code
@kindex set print array
@item set print array
@itemx set print array on
配列をきれいに表示します。
このフォーマットは読むのには便利ですが、
より多くのスペースを取ります。
デフォルトは@samp{off}です。

@item set print array off
配列を詰め込み形式で表示します。

@kindex show print array
@item show print array
配列の表示方法として、
詰め込み形式ときれいな形式のどちらが選択されているかを示します。

@kindex set print elements
@item set print elements @var{number-of-elements}
@value{GDBN}によって表示される配列の要素の数に上限を設定します。
@value{GDBN}が大きな配列を表示している際に、
表示された要素の数が@code{set print elements}コマンドで設定された数に達すると、
そこで表示が停止されます。
この上限は、
文字列の表示にも適用されます。
@var{number-of-elements}に0をセットすると、
要素は無制限に表示されます。

@kindex show print elements
@item show print elements
大きな配列を表示する際に@value{GDBN}が表示する要素数を示します。
0の場合、
表示される要素数に制限はありません。

@kindex set print null-stop
@item set print null-stop
最初に@sc{NULL}が検出された時点で、
@value{GDBN}に文字配列の表示を停止させます。
これは、
大きな配列が実際には短い文字列しか含んでいないときに役に立ちます。

@kindex set print pretty
@item set print pretty on
構造体を表示する際に、
インデントされた形式で1行に1メンバずつ@value{GDBN}に表示させます。
以下に例を示します。

@smallexample
@group
$1 = @{
  next = 0x0,
  flags = @{
    sweet = 1,
    sour = 1
  @},
  meat = 0x54 "Pork"
@}
@end group
@end smallexample

@item set print pretty off
構造体を詰め込み形式で@value{GDBN}に表示させます。
以下に例を示します。

@smallexample
@group
$1 = @{next = 0x0, flags = @{sweet = 1, sour = 1@}, \
meat = 0x54 "Pork"@}
@end group
@end smallexample

@noindent
これがデフォルトの形式です。

@kindex show print pretty
@item show print pretty
@value{GDBN}が、
構造体を表示するのにどちらの形式を使用しているかを示します。

@kindex set print sevenbit-strings
@item set print sevenbit-strings on
7ビット文字だけを使用して表示します。
このオプションがセットされていると、
@value{GDBN}は
（文字列内または単一文字内の）
8ビット文字を@code{\}@var{nnn}という表記法で表示します。
この設定は、英語
（@sc{ascii}）
環境において、
文字の最上位ビットをマーカや「メタ」ビットとして使用する場合に最適です。

@item set print sevenbit-strings off
8ビット文字を表示します。
これにより文字セットの使用が国際的になります。
これがデフォルトです。

@kindex show print sevenbit-strings
@item show print sevenbit-strings
@value{GDBN}が7ビット文字だけを表示するか否かを示します。

@kindex set print union
@item set print union on
@value{GDBN}に対して、
構造体の中に含まれている共用体を表示するよう通知します。
これが、
デフォルトの設定です。

@item set print union off
@value{GDBN}に対して、
構造体の中に含まれている共用体を表示しないよう通知します。

@kindex show print union
@item show print union
@value{GDBN}に対して、
構造体の中に含まれている共用体を表示するか否かを問い合わせます。

例えば、
以下のように宣言されている場合、

@smallexample
typedef enum @{Tree, Bug@} Species;
typedef enum @{Big_tree, Acorn, Seedling@} Tree_forms;
typedef enum @{Caterpillar, Cocoon, Butterfly@} 
              Bug_forms;

struct thing @{
  Species it;
  union @{
    Tree_forms tree;
    Bug_forms bug;
  @} form;
@};

struct thing foo = @{Tree, @{Acorn@}@};
@end smallexample

@noindent
@code{set print union on}が有効な場合、
@samp{p foo}は以下のような表示を行います。

@smallexample
$1 = @{it = Tree, form = @{tree = Acorn, bug = Cocoon@}@}
@end smallexample

@noindent
また、
@code{set print union off}が有効な場合、
@samp{p foo}は以下のような表示を行います。

@smallexample
$1 = @{it = Tree, form = @{...@}@}
@end smallexample
@end table

@ifclear CONLY
@need 1000
@noindent
以下の設定は、
C++プログラムをデバッグしているときに関係があります。

@table @code
@cindex demangling
@cindex エンコードされた形式[エンコードされたけいしき]
@cindex デマングル
@kindex set print demangle
@item set print demangle
@itemx set print demangle on
C++のシンボル名を、
型セーフ（type-safe）なリンクのためにアセンブラ、
リンカに渡されるエンコードされた
（mangled）
形式ではなく、
ソースに記述された形式で表示します。
デフォルトは@samp{on}です。

@kindex show print demangle
@item show print demangle
C++のシンボル名が、
エンコードされた
（mangled）
形式、
ソース
（demangled）
形式のいずれの形式で表示されるかを示します。

@kindex set print asm-demangle
@item set print asm-demangle
@itemx set print asm-demangle on
C++のシンボル名を、
命令の逆アセンブル時のようにアセンブラ・コードで表示しているときにも、
エンコードされた
（mangled）
形式ではなく、
ソース形式で表示します。
デフォルトは@samp{off}です。

@kindex show print asm-demangle
@item show print asm-demangle
アセンブラ・コードの表示において、
C++シンボル名をエンコードされた
（mangled）
形式、
ソース
（demangled）
形式のいずれの形式で表示するかを示します。

@kindex set demangle-style
@cindex C++ symbol decoding style
@cindex symbol decoding style, C++
@cindex C++のシンボルの表現[C++のシンボルのひょうげん]
@cindex シンボルの表現、C++の[シンボルのひょうげん、C++の]
@item set demangle-style @var{style}
C++シンボル名を表現するために様々なコンパイラによって使用される
いくつかのエンコーディング方式の中から1つを選択します。
現在@var{style}として選択可能であるのは、以下のとおりです。

@table @code
@item auto
@value{GDBN}がユーザ・プログラムを解析してデコーディング方式を決定することを許します。

@item gnu
@sc{gnu} C++（@code{g++}）エンコーディング・アルゴリズムに基づいてデコードします。
@ifclear HPPA
これが、
デフォルトです。
@end ifclear

@item hp
HP ANSI C++（@code{aCC}）エンコーディング・アルゴリズムに基づいてデコードします。

@item lucid
Lucid C++（@code{lcc}）エンコーディング・アルゴリズムに基づいてデコードします。

@item arm
@cite{C++ Annotated Reference Manual}に記述されているアルゴリズムを使用してデコードします。
@strong{注意:}
この設定だけでは、
@code{cfront}によって生成された実行モジュールをデバッグするのに十分ではありません。
これを可能にするためには、
@value{GDBN}をさらに拡張する必要があります。

@end table
@var{style}を指定しないと、
指定可能なフォーマットの一覧が表示されます。

@kindex show demangle-style
@item show demangle-style
C++シンボルをデコードするのに現在使用されているエンコーディング方式を示します。

@kindex set print object
@item set print object
@itemx set print object on
オブジェクトへのポインタを表示する際に、
仮想関数テーブルを使用して、
@emph{宣言}された型ではなく、
オブジェクトの@emph{実際}の
（派生された）
型を表示します。

@item set print object off
仮想関数テーブルは参照せず、
オブジェクトの宣言された型だけを表示します。
これがデフォルトの設定です。

@kindex show print object
@item show print object
オブジェクトの実際の型と宣言された型のどちらが表示されるかを示します。

@kindex set print static-members
@item set print static-members
@itemx set print static-members on
C++のオブジェクトを表示する際、
静的メンバを表示します。
デフォルトは@samp{on}です。

@item set print static-members off
C++のオブジェクトを表示する際、
静的メンバを表示しません。

@kindex show print static-members
@item show print static-members
C++の静的メンバが表示されるか否かを示します。

@c These don't work with HP ANSI C++ yet.
@kindex set print vtbl
@item set print vtbl
@itemx set print vtbl on
C++の仮想関数テーブルをきれいな形式で表示します。
デフォルトは@samp{off}です。
@ifset HPPA
（@code{vtbl}コマンドは、
HP ANSI C++コンパイラ（@code{aCC}）
によってコンパイルされたプログラムに対しては、
機能しません。）
@end ifset

@item set print vtbl off
C++の仮想関数テーブルをきれいな形式で表示しません。

@kindex show print vtbl
@item show print vtbl
C++の仮想関数テーブルをきれいな形式で表示するか否かを示します。
@end table
@end ifclear

@node Value History, Convenience Vars, Print Settings, Data
@section 値ヒストリ

@cindex value history
@cindex 値ヒストリ[あたいヒストリ]
@code{print}コマンドにより表示された値は、
@value{GDBN}の
@dfn{値ヒストリ}に保存されます。
これによりユーザは、
これらの値をほかの式の中で参照することができます。
値は、
シンボル・テーブルが
（例えば、
@code{file}コマンドや@code{symbol-file}コマンドにより）
再読み込みされるか破棄されるまで、
維持されます。
シンボル・テーブルが変更されると、
値ヒストリが破棄されるのは、
その中の値が、
シンボル・テーブル内で定義されている型を参照しているかもしれないからです。

@cindex @code{$}
@cindex @code{$$}
@cindex history number
@cindex ヒストリ番号[ヒストリばんごう]
表示される値は@dfn{ヒストリ番号}を与えられ、
この番号によって参照することができます。
この番号は1から始まる連続した整数です。
@code{print}コマンドは、
値に割り当てられたヒストリ番号を、
値の前に@samp{$@var{num} = }という形で表示します。
ここで、
@var{num}がそのヒストリ番号です。

値ヒストリの中の任意の値を参照するには、
@samp{$}に続けてヒストリ番号を指定します。
@code{print}コマンドが出力に付加するラベルは、
ユーザにこのことを知らせるためのものです。
@code{$}単体では、
ヒストリ内の最も新しい値を参照し、
@code{$$}はその1つ前の値を参照します。
@code{$$@var{n}}は、
最新のものから数えて@var{n}番目の値を参照します。
@code{$$2}は@code{$$}の1つ前の値を参照し、
@code{$$1}は@code{$$}と同一、
@code{$$0}は@code{$}と同一です。

例えば、
ユーザがたった今、
構造体へのポインタを表示し、
今度はその構造体の内容を見たいと考えているとしましょう。
この場合は、

@example
p *$
@end example

@noindent
を実行すれば十分です。

また、
連結された構造体があり、
そのメンバの@code{next}が次の構造体を指すポインタであるとすると、
次の構造体の内容を表示するには、

@example
p *$.next
@end example

@noindent
とします。

このように連結された構造体を次々に表示するには、
このコマンドを繰り返し実行すればよく、
それは@key{RET}キーによって可能です。

このヒストリは、
式ではなく、
値を記録するという点に注意してください。
@code{x}の値が4のときに、
以下のコマンドを実行すると、
@code{print}コマンドによって値ヒストリに記録される値は、
@code{x}の値が変化したにもかかわらず4のままです。

@example
print x
set x=5
@end example

@table @code
@kindex show values
@item show values
値ヒストリ内の最新の10個の値を、
項目番号付きで表示します。
これは、
@samp{p@ $$9}を10回実行するようなものですが、
両者の違いは、
@code{show values}がヒストリを変更しないという点にあります。

@item show values @var{n}
値ヒストリ内の項目番号@var{n}を中心に、
その前後の10個の値を表示します。

@item show values +
値ヒストリ内の値のうち最後に表示されたものの直後にある10個の値を表示します。
値が存在しない場合には、
何も表示されません。
@end table

@code{show values @var{n}}を繰り返し実行するのに@key{RET}キーを押すことは、
@samp{show values +}を実行するのと全く同じ結果をもたらします。

@node Convenience Vars, Registers, Value History, Data
@section コンビニエンス変数

@cindex convenience variables
@cindex コンビニエンス変数[コンビニエンスへんすう]
@value{GDBN}の@dfn{コンビニエンス変数}は、
@value{GDBN}の中にある値を保持しておいて、
それを後に参照するという目的で使用することができます。
これらの変数は、
@value{GDBN}内部においてのみ存在するものです。
それらはユーザ・プログラムの中に存在するものではなく、
コンビニエンス変数を設定してもユーザ・プログラムの実行には直接影響を与えません。
したがって、
ユーザはこれを自由に使用することができます。

コンビニエンス変数名は、
先頭が@samp{$}で始まります。
@samp{$}で始まる名前は、
あらかじめ定義されたマシン固有のレジスタ名
（@pxref{Registers}）
と一致しない限り、
コンビニエンス変数の名前として使用することができます
（これに対して、
値ヒストリの参照名では@samp{$}に続けて@emph{番号}を記述します。
@xref{Value History, ,Value history}）。

ユーザ・プログラムの中で変数に値を設定するのと同じように、
代入式を使用してコンビニエンス変数に値を保存することができます。
例えば、
@code{object_ptr}が指すオブジェクトが保持する値を@code{$foo}に保存するには、
以下のようにします。

@example
set $foo = *object_ptr
@end example

コンビニエンス変数は、
最初に使用されたときに生成されますが、
新しい値を割り当てるまで、
その値は空
（@code{void}）
です。
値は、
いつでも代入することによって変更可能です。

コンビニエンス変数には決まった型はありません。
コンビニエンス変数には、
既に異なる型のデータが割り当てられている場合でも、
構造体や配列を含めた任意の型のデータを割り当てることができます。
コンビニエンス変数は、
式として使用される場合には、
その時点における値の型を持ちます。

@table @code
@kindex show convenience
@item show convenience
それまでに使用されたコンビニエンス変数とその値の一覧を表示します。
省略形は、
@code{show con}です。
@end table

コンビニエンス変数の1つの使い方に、
インクリメントされるカウンタや先へ進んでいくポインタとしての使い方があります。
例えば、
構造体配列の中の連続する要素のあるフィールドの値を表示したい場合、
以下のコマンドを@key{RET}キーで繰り返し実行します。

@example
set $i = 0
print bar[$i++]->contents
@end example

@noindent

@value{GDBN}によって、
いくつかのコンビニエンス変数が自動的に作成され、
役に立ちそうな値が設定されます。

@table @code
@kindex $_
@item $_
@code{$_}変数には、
@code{x}コマンドによって最後に調べられたアドレスが自動的に設定されます
（@pxref{Memory, ,Examining memory}）。
@code{x}コマンドによって調べられるデフォルトのアドレスを提供する他のコマンドも、
@code{$_}にそのアドレスを設定します。
このようなコマンドには、
@code{info line}や@code{info breakpoint}があります。
@code{$_}の型は、
@code{x}コマンドによって設定された場合は@code{$__}の型へのポインタであり、
それ以外の場合は@code{void *}です。

@kindex $__
@item $__
@code{$__}変数には、
@code{x}コマンドによって最後に調べられたアドレス位置にある値が自動的に設定されます。
型は、
データが表示されたフォーマットに適合するように選択されます。

@item $_exitcode
@kindex $_exitcode
@code{$_exitcode}変数には、
デバッグされているプログラムが終了した際の終了コードが自動的に設定されます。
@end table

@ifset HPPA
ドル記号で始まる関数名や変数名を指定すると、
@value{GDBN}は、
コンビニエンス変数を探す前に、
まず、
ユーザ名やシステム名を探します。
@end ifset

@node Registers, Floating Point Hardware, Convenience Vars, Data
@section レジスタ

@cindex registers
@cindex レジスタ
マシン・レジスタの内容は、
先頭が@samp{$}で始まる名前を持つ変数として、
式の中で参照することができます。
レジスタの名前は、
マシンによって異なります。
@code{info registers}コマンドを使用することで、
そのマシンで使用されているレジスタの名前を知ることができます。

@table @code
@kindex info registers
@item info registers
（選択されたスタック・フレームにおける）
浮動小数点レジスタを除くすべてのレジスタの名前と値を表示します。

@kindex info all-registers
@cindex floating point registers
@cindex 浮動小数点レジスタ[ふどうしょうすうてんレジスタ]
@item info all-registers
浮動小数点レジスタも含めてすべてのレジスタの名前と値を表示します。

@item info registers @var{regname} @dots{}
指定されたレジスタ@var{regname}の
@var{相対化}された値（@dfn{relativized} value）を表示します。
以下に詳しく述べるように、
レジスタの値は、
通常は、
選択されたスタック・フレームと関係を持つ相対的な値です。
@var{regname}には、
ユーザの使用しているマシン上において有効な任意のレジスタの値が設定可能です。
先頭の@samp{$}は、
あってもなくてもかまいません。
@end table

@value{GDBN}は、
そのマシン・アーキテクチャが持つレジスタの正規のニーモニックと衝突しない限り、
ほとんどのマシン上
（の式の中）
において利用可能な、
4つの「標準的」なレジスタ名を持っています。
レジスタ名@code{$pc}と@code{$sp}は、
プログラム・カウンタ・レジスタとスタック・ポインタを指すために使われます。
@code{$fp}は、
カレントなスタック・フレームへのポインタを保持するレジスタを指すために使われます。
@code{$ps}は、
プロセッサの状態を保持するレジスタを指すために使われます。
例えば、
プログラム・カウンタの値を16進数で表示するには、
以下のように実行します。

@example
p/x $pc
@end example

@noindent
また、
次に実行される命令を表示するには、
以下のように実行します。

@example
x/i $pc
@end example

@noindent
さらに、
スタック・ポインタ
@footnote{原注：これは、
スタックがメモリの下位方向に伸長するマシン
（最近のほとんどのマシンがそうです）
上において、
スタックから1ワードを取り除く方法です。
これは、
最下位のスタック・フレームが選択されていることを想定しています。
これ以外のスタック・フレームが選択されているときには、
@code{$sp}に値を設定することは許されません。
マシン・アーキテクチャに依存することなくスタックからフレーム全体を取り除くには、
@code{return}を使用します。
@xref{Returning, ,Returning from a function}。}
に4を加えるには、
以下のように実行します。

@example
set $sp += 4
@end example

可能な場合にはいつでも、
これら4つの標準的なレジスタ名が使用可能です。
ユーザのマシンが異なる正規のニーモニックを使用している場合でも、
名前の衝突さえ起こらなければ、
使用可能です。
@code{info registers}コマンドにより、
正規名を見ることができます。
例えば、
SPARC上で
@code{info registers}コマンドを実行すると、
プロセッサ・ステータス・レジスタは@code{$psr}と表示されますが、
このレジスタを@code{$ps}として参照することもできます。

レジスタがこの方法で調べられるとき、
@value{GDBN}は普通のレジスタの内容を常に整数値とみなします。
マシンによっては、
浮動小数点値以外を保持できないレジスタを持つものがあります。
このようなレジスタは、
浮動小数点値を持つものとみなされます。
普通のレジスタの内容を浮動小数点値として参照する方法はありません
（@samp{print/f $@var{regname}}により、
浮動小数点値として値を@emph{表示する}ことはできます）。

レジスタには、
rawとvirtualの2つの異なるデータ形式を取るものがあります。
これは、
オペレーティング・システムによってレジスタの内容が保存されるときのデータ形式が、
ユーザ・プログラムが通常認識しているものと同じではないことを意味しています。
例えば、
68881浮動小数点コプロセッサのレジスタの値は常にextended
（raw）形式で保存されていますが、
C言語によるプログラムは通常double
（virtual）形式を想定しています。
このような場合、
@value{GDBN}は通常
（ユーザ・プログラムにとって意味のある形式である）
virtual形式だけを扱いますが、
@code{info registers}コマンドはデータを両方の形式で表示してくれます。

通常、
レジスタの値は、
選択されたスタック・フレーム
（@pxref{Selection, ,Selecting a frame}）
と関係を持つ相対的な値です。
これは、
ユーザにレジスタの値として見えるものは、
選択されたフレームから呼び出されているすべてのスタック・フレームが終了し、
退避されたレジスタの値が復元されたときに、
そのレジスタが持つであろう値です。
ハードウェア・レジスタの本当の値を知りたければ、
最下位のフレームを
（@w{@samp{frame 0}}で）
選択しなければなりません。

しかし、
@value{GDBN}は、
コンパイラが生成したコードから、
どこにレジスタが保存されているかを推論する必要があります。
退避されていないレジスタがある場合や、
@value{GDBN}が退避されたレジスタを見つけることができない場合は、
どのスタック・フレームを選択していても結果は同じです。

@ifset AMD29K
@table @code
@kindex set rstack_high_address
@cindex AMD 29K register stack
@cindex register stack, AMD29K
@cindex レジスタ・スタック、AMD29Kの
@item set rstack_high_address @var{address}
AMD 29000ファミリ・プロセッサでは、
レジスタは「レジスタ・スタック」と呼ばれるところに退避されます。
@value{GDBN}には、
このスタックの大きさを知ることはできません。
通常
@value{GDBN}は、
スタックは十分に大きいと想定します。
このために、
実際には存在しないメモリ位置を、
@value{GDBN}が参照してしまうことがありえます。
必要であれば、
@code{set rstack_high_address}コマンドによってレジスタ・スタックの最終アドレスを指定することによって、
この問題を回避することができます。
引数はアドレスでなければなりません。
@samp{0x}を先頭に記述することで、
アドレスを16進数で指定することができます。

@kindex show rstack_high_address
@item show rstack_high_address
AMD 29000ファミリ・プロセッサにおけるレジスタ・スタックのカレントな上限を表示します。
@end table
@end ifset

@ifclear HAVE-FLOAT
@node Floating Point Hardware,  , Registers, Data
@section 浮動小数ハードウェア
@cindex floating point
@cindex 浮動小数ハードウェア[ふどうしょうすうハードウェア]

構成によっては、
@value{GDBN}は浮動小数ハードウェアの状態について、
より詳しい情報を提供することができます。

@table @code
@kindex info float
@item info float
浮動小数ユニットに関するハードウェア依存の情報を表示します。
浮動小数チップの種類によって、
表示内容やレイアウトは変わります。
現在、
@samp{info float}はARMマシンとx86マシンにおいてサポートされています。
@end table
@end ifclear

@ifclear CONLY
@node Languages, Symbols, Data, Top
@chapter 異なる言語の使用
@cindex languages
@cindex 言語[げんご]

@ifset MOD2
異なるプログラミング言語であっても共通点があるのが普通ですが、
その表記法が全く同様であるということはめったにありません。
例えば、
ポインタ
@code{p}の指す値を取り出す方法は、
ANSI Cでは@code{*p}ですが、
Modula-2では@code{p^}です。
値の表現方法
（および表示方法）
もまた異なります。
16進数は、
Cでは@samp{0x1ae}のようになりますが、
Modula-2では@samp{1AEH}のようになります。
@end ifset

@cindex working language
@cindex 作業言語[さぎょうげんご]
いくつかの言語については、
言語固有の情報が@value{GDBN}に組み込まれており、
これにより、
プログラムを記述した言語を使って上記のような操作を記述したり、
プログラムを記述した言語の構文にしたがって@value{GDBN}に値を出力させることができます。
式を記述するのに使用される言語を、
@dfn{作業言語}と呼びます。

@menu
* Setting::                     ソース言語の切り替え
* Show::                        言語の表示
@ifset MOD2
* Checks::                      型と範囲のチェック
@end ifset

* Support::                     サポートされる言語
@end menu

@node Setting, Show, Languages, Languages
@section ソース言語の切り替え

作業言語を制御する方法は2つあります。
@value{GDBN}に自動的に設定させる方法と、
ユーザが手作業で選択する方法です。
どちらの目的でも、
@code{set language}コマンドを使用することができます。
起動時のデフォルトでは、
@value{GDBN}が言語を自動的に設定するようになっています。
作業言語は、
ユーザの入力する式がどのように解釈されるか、
あるいは、
値がどのように表示されるかを決定します。

この作業言語とは別に、
@value{GDBN}の認識しているすべてのソース・ファイルには、
それ自体の作業言語があります。
オブジェクト・ファイルのフォーマットによっては、
ソース・ファイルの記述言語を示す情報を、
コンパイラが書き込んでいることがあるかもしれません。
しかし、
ほとんどの場合、
@value{GDBN}はファイル名から言語を推定します。
ソース・ファイルの言語の種類が、
C++シンボル名がデコード
（demangle）
されるか否かを制御します。
これにより@code{backtrace}は、
個々のフレームを、
その対応する言語にしたがって適切に表示することができます。
@value{GDBN}の中から、
ソース・ファイルの言語を設定することはできません。

他の言語で記述されたソースからCのソースを生成する、
@code{cfront}や@code{f2c}のようなプログラムをユーザが使用する場合には、
このことが問題となるでしょう。
このような場合には、
生成されるCの出力に@code{#line}指示子を使用するよう、
そのプログラムを設定してください。
こうすることによって、
@value{GDBN}は、
元になったプログラムのソース・コードが記述された言語を正しく知ることができ、
生成されたCのコードではなく、
元になったソース・コードを表示します。

@menu
* Filenames::                   ファイル拡張子と言語
* Manually::                    手作業による作業言語の設定
* Automatically::               @value{GDBN}によるソース言語の推定
@end menu

@node Filenames, Manually, Setting, Setting
@subsection ファイル拡張子と言語のリスト

ソース・ファイル名が以下のいずれかの拡張子を持つ場合、
@value{GDBN}はその言語を以下に示すものと推定します。

@table @file

@item .c
Cソース・ファイル

@item .C
@itemx .cc
@itemx .cp
@itemx .cpp
@itemx .cxx
@itemx .c++
C++ソース・ファイル

@item .f
@itemx .F
Fortranソース・ファイル

@ifclear HPPA
@item .ch
@itemx .c186
@itemx .c286
CHILLソース・ファイル
@end ifclear

@ifset MOD2
@item .mod
Modula-2ソース・ファイル
@end ifset

@item .s
@itemx .S
アセンブラ言語のソース・ファイル。
この場合、
実際の動作はほとんどC言語と同様ですが、
ステップ実行時に、
関数呼び出しのための事前処理部を@value{GDBN}はスキップしません。
@end table

さらに、
言語に対してファイル名の拡張子を関連付けすることも可能です。
@xref{Show, , Displaying the language}。

@node Manually, Automatically, Filenames, Setting
@subsection 作業言語の設定

@value{GDBN}に言語を自動的に設定させる場合、
ユーザのデバッグ・セッションとユーザのプログラムにおいて、
式は同様に解釈されます。

@kindex set language
もしそうしたければ、
言語を手作業で設定することもできます。
そのためには、
コマンド@samp{set language @var{lang}}を実行します。
ここで、
@var{lang}は、
@ifclear MOD2
@code{c}
@end ifclear
@ifset MOD2
@code{c}や@code{modula-2}
@end ifset
のような言語名です。
サポートされている言語のリストは、
@samp{set language}で表示させることができます。

@ifclear MOD2
言語を手作業で設定すると、
@value{GDBN}は、
作業言語を自動的に更新することができなくなります。
例えば、
C++のプログラムをデバッグするのに@code{c}の設定を使用すると、
名前が正しくデマングル（demangle）されない、
オーバーロードの解決が機能しない、
ユーザ定義の演算子が正しく解釈されない、
などの問題が発生するかもしれません。
@end ifclear
@ifset MOD2
言語を手作業で設定すると、
@value{GDBN}は、
作業言語を自動的に更新することができなくなります。
このことは、
作業言語がソースの言語と同一ではなく、
かつ、
ある式がどちらの言語でも有効でありながら、
その意味が異なるような状況でプログラムをデバッグしようとしたときに、
混乱をもたらす可能性があります。
例えば、
カレントなソース・ファイルがC言語で記述されていて、
@value{GDBN}がそれをModula-2として解析している場合に、

@example
print a = b + c
@end example

@noindent
のようなコマンドを実行すると、
その結果は意図したものとは異なるものになるでしょう。
これはC言語では、
@code{b}と@code{c}とを加算して、
その結果を@code{a}に入れるということを意味し、
表示される結果は、
@code{a}の値となります。
Modula-2では、
これは@code{a}と@code{b+c}の結果を比較して@code{BOOLEAN}型の値を出力することを意味します。
@end ifset

@node Automatically,  , Manually, Setting
@subsection @value{GDBN}によるソース言語の推定

@value{GDBN}に作業言語を自動的に設定させるには、
@samp{set language local}または@samp{set language auto}を使用します。
この場合、
@value{GDBN}は作業言語を推定します。
つまり、
ユーザ・プログラムが
（通常はブレイクポイントに達することによって）
あるフレーム内部で停止したとき、
@value{GDBN}は、
そのフレーム内の関数に対して記録されている言語を作業言語として設定します。
フレームの言語が不明の場合
（つまり、
そのフレームに対応する関数またはブロックが、
既知ではない拡張子を持つソース・ファイルにおいて定義されている場合）、
カレントな作業言語は変更されず、
@value{GDBN}は警告メッセージを出力します。

このようなことは、
全体がただ1つの言語で記述されているほとんどのプログラムにおいては
不要であると思われるでしょう。
しかし、
あるソース言語で記述されたプログラム・モジュールやライブラリは、
他のソース言語で記述されたメイン・プログラムから使用することができます。
このような場合に@samp{set language auto}を使用することで、
作業言語を手作業で設定する必要がなくなります。

@ifset MOD2
@node Show, Checks, Setting, Languages
@section 言語の表示
@end ifset
@ifclear MOD2
@node Show, Support, Setting, Languages
@section 言語の表示
@end ifclear

以下のコマンドは、
作業言語、
および、
ソース・ファイルの記述言語を知りたいときに役に立ちます。

@kindex show language
@kindex info frame
@kindex info source
@table @code
@item show language
カレントな作業言語を表示します。
@code{print}コマンドなどによって
ユーザ・プログラム内部の変数を含む式を作成したり評価したりするには、
このコマンドによって示される言語を使用します。

@item info frame
選択されているフレームのソース言語を表示します。
このフレームの中の識別子を使用すると、
この言語が作業言語になります。
このコマンドにより表示される他の情報について知りたい場合は、
@xref{Frame Info, ,Information about a frame}。

@item info source
選択されているソース・ファイルのソース言語を表示します。
このコマンドにより表示される他の情報のことを知りたい場合は、
@xref{Symbols, ,Examining the Symbol Table}。
@end table

普通ではない状況においては、
標準のリストに含まれない拡張子を持つソース・ファイルがあるかもしれません。
この場合には、
その拡張子を特定の言語に明示的に関連付けすることができます。

@kindex set extension-language
@kindex info extensions
@table @code
@item set extension-language @var{.ext} @var{language}
拡張子@var{.ext}を持つソース・ファイルは、
ソース言語@var{language}
によって記述されているものと想定するよう設定します。

@item info extensions
すべてのファイル拡張子と、
その拡張子に関連付けされた言語を一覧表示します。
@end table

@ifset MOD2
@node Checks, Support, Show, Languages
@section 型と範囲のチェック

@quotation
@emph{注意:}
現在のリリースでは、
型チェックと範囲チェックを行う@value{GDBN}コマンドは組み込まれていますが、
それらは実際には何も実行しません。
このセクションでは、
これらのコマンドが本来持つべく意図されている機能について記述してあります。
@end quotation
@c FIXME remove warning when type/range code added

いくつかの言語は、
一連のコンパイル時チェック、
実行時チェックによって、
一般によく見られるエラーの発生を防ぐように設計されています。
これらのチェックには、
関数や演算子への引数の型のチェックや、
数学的操作の結果のオーバーフローを実行時に確実に検出することなどが含まれています。
このようなチェックは、
型の不一致を排除したり、
ユーザ・プログラムの実行時に範囲エラーをチェックしたりすることによって、
コンパイル後のプログラムの正しさを確かなものにするのに役に立ちます。

@value{GDBN}は、
ユーザが望むのであれば、
上記のような条件のチェックを行います。
@value{GDBN}はユーザ・プログラムの文をチェックすることはしませんが、
例えば、
@code{print}コマンドによる評価を目的として@value{GDBN}に直接入力された式をチェックすることはできます。
作業言語の場合と同様に、
@value{GDBN}が自動的にチェックを行うか否かを、
ユーザ・プログラムのソース言語によって決定することもできます。
サポートされている言語のデフォルトの設定については、
@xref{Support, ,Supported languages}。

@menu
* Type Checking::               型チェックの概要
* Range Checking::              範囲チェックの概要
@end menu

@c {{subsectionの直前で改頁されることがあるため、@cindexを後ろに移動。}}
@node Type Checking, Range Checking, Checks, Checks
@subsection 型チェックの概要
@cindex type checking
@cindex checks, type
@cindex 型チェック[かたチェック]

いくつかの言語、
例えばModula-2などは、
強く型付けされています。
これは、
演算子や関数への引数は正しい型でなくてはならず、
そうでない場合にはエラーが発生するということを意味しています。
このようなチェックは、
型の不一致のエラーが実行時に問題を発生させるのを防いでくれます。
例えば、
1+2は

@smallexample
1 + 2 @result{} 3
@exdent ですが、1+2.3は
@error{} 1 + 2.3
@end smallexample

@noindent
のようにエラーになります。

第2の例がエラーになるのは、
@code{CARDINAL}型の1は@code{REAL}型の2.3と型の互換性がないからです。

@value{GDBN}コマンドの中で使われる式については、
ユーザが@value{GDBN}の型チェック機能に対して、
以下のような指示を出すことができます。

@itemize @bullet
@item
チェックを行わない
@item
あらゆる不一致をエラーとして扱い、式を破棄する
@item
型の不一致が発生したときには警告メッセージを出力するだけで、
式の評価を実行する
@end itemize  

最後の指示が選択された場合、
@value{GDBN}は上記の第2の（エラー）例のような式でも評価しますが、
その際には警告メッセージを出力します。

型チェックをしないよう指示した場合でも、
型に関係のある原因によって@value{GDBN}が式の評価ができなくなる場合がありえます。
例えば、
@value{GDBN}は@code{int}の値と@code{struct foo}の値を加算する方法を知りません。
こうした特定の型エラーは、
使用されている言語に起因するものではなく、
この例のように、
そもそも評価することが意味をなさないような式に起因するものです。

個々の言語は、
それが型に関してどの程度厳密であるかを定義しています。
例えば、
Modula-2とCはいずれも、
算術演算子への引数としては数値を要求します。
Cでは、
列挙型とポインタは数値として表わすことができますので、
これらは算術演算子への正当な引数となります。
特定の言語に関する詳細については、
@xref{Support, ,Supported languages}。

@value{GDBN}は、
型チェック機能を制御するためのコマンドをさらにいくつか提供しています。

@kindex set check
@kindex set check type
@kindex show check type
@table @code
@item set check type auto
カレントな作業言語に応じて、
型チェックを実行する、
または、
実行しないよう設定します。
個々の言語のデフォルトの設定については、
@xref{Support, ,Supported languages}。

@item set check type on
@itemx set check type off
カレントな作業言語のデフォルトの設定を無視して、
型チェックを実行する、
または、
実行しないよう設定します。
その設定が言語のデフォルトと一致しない場合は、
警告メッセージが出力されます。
型チェックを実行するよう設定されているときの式の評価において型の不一致が発生した場合には、
@value{GDBN}はメッセージを出力して式の評価を終了させます。

@item set check type warn
型チェック機能に警告メッセージを出力させますが、
式の評価自体は常に実行するよう試みさせます。
式の評価は、
他の原因のために不可能になる場合もあります。
例えば、
@value{GDBN}には数値と構造体の加算はできません。

@item show type
型チェック機能のカレントな設定と、
@value{GDBN}がそれを自動的に設定しているか否かを表示します。
@end table

@c {{subsectionの直前で改頁されることがあるため、@cindexを後ろに移動。}}
@node Range Checking,  , Type Checking, Checks
@subsection 範囲チェックの概要
@cindex range checking
@cindex checks, range
@cindex 範囲チェック[はんいチェック]
@cindex チェック、範囲[チェック、はんい]

いくつかの言語
（例えば、
Modula-2）
では、
型の上限を超えるとエラーになります。
このチェックは、
実行時に行われます。
このような範囲チェックは、
計算結果がオーバーフローしたり、
配列の要素へのアクセス時に使うインデックスが配列の上限を超えたりすることがないことを確実にすることによって、
プログラムの正しさを確かなものにすることを意図したものです。

@value{GDBN}コマンドの中で使う式については、
範囲エラーの扱いを以下のいずれかにするよう
@value{GDBN}に指示することができます。

@itemize @bullet
@item
範囲エラーを無視する
@item
範囲エラーを常にエラーとして扱い、
式を破棄する
@item
警告メッセージを出力するだけで、
式を評価する
@end itemize  

範囲エラーは、
数値がオーバフローした場合、
配列インデックスの上限を超えた場合、
どの型のメンバでもない定数が入力された場合に発生します。
しかし、
言語の中には、
数値のオーバフローをエラーとして扱わないものもあります。
C言語の多くの実装では、
数学的演算によるオーバフローは、
結果の値を「一巡」させて小さな値にします。
例えば、
@var{m}が整数値の最大値、
@var{s}が整数値の最小値とすると、

@example
@var{m} + 1 @result{} @var{s}
@end example

@noindent
になります。

これも個々の言語に固有な性質であり、
場合によっては、
個々のコンパイラやマシンに固有な性質であることもあります。
特定の言語に関する詳細については、
@xref{Support, , Supported languages}。

@value{GDBN}は、
範囲チェック機能を制御するためのコマンドをさらにいくつか提供しています。

@kindex set check
@kindex set check range
@kindex show check range
@table @code
@item set check range auto
カレントな作業言語に応じて、
範囲チェックを実行する、
または、
実行しないよう設定します。
個々の言語のデフォルトの設定については、
@xref{Support, ,Supported languages}。

@item set check range on
@itemx set check range off
カレントな作業言語のデフォルトの設定を無視して、
範囲チェックを実行する、
または、
実行しないよう設定します。
設定が言語のデフォルトとは異なる場合は、
警告メッセージが出力されます。
範囲エラーが発生した場合は、
メッセージが表示され、
式の評価は終了させられます。

@item set check range warn
@value{GDBN}の範囲チェック機能が範囲エラーを検出した場合、
メッセージを出力し、
式の評価を試みます。
例えば、
プロセスが、
自分の所有していないメモリをアクセスした場合
（多くのUnixシステムで典型的に見られる例です）
など、
他の理由によって式の評価が不可能な場合があります。

@item show range
範囲チェック機能のカレントな設定と、
それが@value{GDBN}によって自動的に設定されているのか否かを表示します。
@end table
@end ifset

@ifset MOD2
@node Support,  , Checks, Languages
@section サポートされる言語
@end ifset
@ifclear MOD2
@node Support,  , Show, Languages
@section サポートされる言語
@end ifclear

@ifset MOD2
@value{GDBN}は、
C、
C++、
Fortran、
Chill、
アセンブリ言語、
Modula-2をサポートしています。
@end ifset
@ifclear MOD2
@value{GDBN}は、
C、
C++、
Fortran、
Chill、
アセンブリ言語をサポートしています。
@end ifclear
いくつかの@value{GDBN}の機能は、
使用されている言語にかかわらず、
式の中で使用できます。
@value{GDBN}の@code{@@}演算子、
@code{::}演算子、
および@samp{@{type@}addr}
（@pxref{Expressions, ,Expressions}）
は、
サポートされている任意の言語において使用することができます。

次節以降で、
個々のソース言語が@value{GDBN}によってどの程度までサポートされているのかを詳しく説明します。
これらの節は、
言語についてのチュートリアルやリファレンスとなることを意図したものではありません。
むしろ、
@value{GDBN}の式解析機能が受け付ける式や、
異なる言語における正しい入出力フォーマットのリファレンス・ガイドとしてのみ役に立つものです。
個々の言語については良い書籍が数多く出ています。
言語についてのリファレンスやチュートリアルが必要な場合は、
これらの書籍を参照してください。

@ifset MOD2
@menu
* C::                           C/C++
* Modula-2::                    Modula-2
@end menu

@node C, Modula-2, , Support
@subsection C/C++
@cindex C and C++
@cindex expressions in C or C++
@cindex 式、CやC++の[しき、CやC++の]
@end ifset

CとC++は密接に関連しているので、
@value{GDBN}の機能の多くは両方の言語に適用できます。このようなものについては、2つの言語を一緒に議論します。

@ifclear MOD2
@c Cancel this below, under same condition, at end of this chapter!
@raisesections
@end ifclear

@ifclear HPPA
@cindex C++
@kindex g++
@cindex @sc{gnu} C++
C++のデバッグ機能は、
C++コンパイラと@value{GDBN}によって協同で実装されています。
したがって、
C++のコードを効率よくデバッグするには、
@sc{gnu} @code{g++}、
HP ANSI C++コンパイラ（@code{aCC}）などの、
サポートされているC++コンパイラで、
C++のプログラムをコンパイルする必要があります。

@sc{gnu} C++を使用する場合、
最高の結果を引き出すには、
stabsデバッグ・フォーマット
を使用してください。
@code{g++}のコマンドライン・オプション@samp{-gstabs}、
または、
@samp{-gstabs+}によって、
このフォーマットを明示的に選択することができます。
詳細については、
@ref{Debugging Options,,Options for Debugging Your Program or @sc{gnu} CC, gcc.info, Using @sc{gnu} CC}
の部分を参照してください。
@end ifclear
@ifset HPPA
@cindex C++
@kindex g++
@cindex @sc{gnu} C++
HP Cコンパイラ（@code{cc}）、
GNU Cコンパイラ（@code{gcc}）
のどちらを使用してコンパイルしたCプログラムでも、
また、
HP ANSI C++コンパイラ（@code{aCC}）、
@sc{gnu} C++コンパイラ（@code{g++}）
のどちらを使用してコンパイルしたプログラムでも、
@value{GDBN}を使用してデバッグすることができます。

@sc{gnu} C++コンパイラでコンパイルする場合、
デバッグの際に最高の結果を引き出すには、
stabsデバッグ・フォーマット
を使用してください。
@code{g++}のコマンドライン・オプション@samp{-gstabs}、
または、
@samp{-gstabs+}によって、
このフォーマットを明示的に選択することができます。
詳細については、
@ref{Debugging Options,,Options for Debugging Your Program or @sc{gnu} CC, gcc.info, Using @sc{gnu} CC}
の部分を参照してください。
@end ifset
@end ifclear

@ifset CONLY
@node C, Symbols, Data, Top
@chapter C言語サポート
@cindex C language
@cindex expressions in C
@cindex 式、Cの[しき、Cの]

デバッグの際にCの式を使用することができるよう、
C言語に固有の情報が@value{GDBN}の中に組み込まれています。
また、
これにより、
@value{GDBN}は、
Cの慣習と一貫性のある方法で値を出力することができます。

@menu
* C Operators::                 C演算子
@end menu
@end ifset

@ifclear CONLY
@menu
* C Operators::                 C/C++演算子
* C Constants::                 C/C++定数
* Cplus expressions::           C++式
* C Defaults::                  C/C++のデフォルト設定
@ifset MOD2
* C Checks::                    C/C++の型チェックと範囲チェック
@end ifset

* Debugging C::                 @value{GDBN}とC
* Debugging C plus plus::       C++用の@value{GDBN}機能
@end menu
@end ifclear

@c {{subsubsectionの直前で改頁されることがあるため、@cindexを後ろに移動。}}
@ifclear CONLY
@node C Operators, C Constants, , C
@subsubsection C/C++演算子
@cindex C and C++ operators
@cindex 演算子、CやC++の[えんざんし、CやC++の]
@end ifclear
@ifset CONLY
@node C Operators, C Constants, C, C
@section C演算子
@cindex C operators
@cindex 演算子、Cの[えんざんし、Cの]
@end ifset

演算子は、
特定の型の値に対して定義されなければなりません。
例えば、
@code{+}は数値に対しては定義されていますが、
構造体に対しては定義されていません。
演算子は、
型のグループに対して定義されることがよくあります。

@ifclear CONLY
C/C++に対しては、以下の定義が有効です。
@end ifclear

@itemize @bullet
@item
@ifclear HPPA
@emph{整数型}には、
任意の記憶クラス指定子を持つ@code{int}が含まれます。
@code{char}、
@code{enum}も整数型です。
@end ifclear
@ifset HPPA
@emph{整数型}には、
任意の記憶クラス指定子を持つ@code{int}が含まれます。
@code{char}、
@code{enum}も整数型です。
また、
C++の場合は、
@code{bool}も整数型に含まれます。
@end ifset

@item
@emph{浮動小数点型}には、
@code{float}と@code{double}が含まれます。

@item
@emph{ポインタ型}には、
型@var{type}に対して@code{(@var{type} *)}により定義されるすべての型が含まれます。

@item
@emph{スカラ型}には、
上記のすべてが含まれます。
@end itemize

@noindent
以下の演算子がサポートされています。
これらは優先順位の低いものから順に並べられています。

@table @code
@item ,
カンマ、
あるいは、
順序付けの演算子です。
カンマによって区切られたリストの中の式は、
左から右の順で評価されます。
最後に評価された式の結果が、
式全体の評価結果になります。

@item =
代入。
代入された値が、
代入式の値になります。
スカラ型に対して定義されています。

@item @var{op}=
@w{@code{@var{a} @var{op}= @var{b}}}という形式の式において使用され、
@w{@code{@var{a} = @var{a op b}}}に変換されます。
@w{@code{@var{op}=}}と@code{=}は、
同一の優先順位を持ちます。
@var{op}には、
@code{|}、
@code{^}、
@code{&}、
@code{<<}、
@code{>>}、
@code{+}、
@code{-}、
@code{*}、
@code{/}、
@code{%}の各演算子が使用できます。

@item ?:
3項演算子です。
@code{@var{a} ? @var{b} : @var{c}}は、
@var{a}が真であれば@var{b}、
偽であれば@var{c}とみなすことができます。
@var{a}は整数型でなければなりません。

@item ||
論理@sc{or}です。
整数型に対して定義されています。

@item &&
論理@sc{and}です。
整数型に対して定義されています。

@item |
ビットごとの@sc{or}です。
整数型に対して定義されています。

@item ^
ビットごとの排他的@sc{or}です。
整数型に対して定義されています。

@item &
ビットごとの@sc{and}です。
整数型に対して定義されています。

@item ==@r{、}!=
等価、
および、
不等価です。
スカラ型に対して定義されています。
これらの式の値は、
偽のときはゼロであり、
真のときはゼロ以外の値となります。

@item <@r{、}>@r{、}<=@r{、}>=
未満、
超過、
以下、
以上です。
スカラ型に対して定義されています。
これらの式の値は、
偽のときはゼロであり、
真のときはゼロ以外の値となります。

@item <<@r{、}>>
左シフト、
右シフトです。
整数型に対して定義されています。

@item @@
@value{GDBN}の「人工配列」演算子です
（@pxref{Expressions, ,Expressions}）。

@item +@r{、}-
加算および減算です。
整数型、
浮動小数点型、
ポインタ型に対して定義されています。

@item *@r{、}/@r{、}%
乗算、
除算、
剰余です。
乗算と除算は、
整数型と浮動小数点型に対して定義されています。
剰余は、
整数型に対して定義されています。

@item ++@r{, }--
インクリメント、
デクリメントです。
変数の前にある場合は、
式の中でその変数が使用される前に実行されます。
変数の後ろにある場合は、
変数の値が使用された後に実行されます。

@item *
ポインタの間接参照です。
ポインタ型に対して定義されています。
@code{++}と同一の優先度を持ちます。

@item &
アドレス参照演算子です。変数に対して定義されています。
@code{++}と同一の優先順位を持ちます。

@ifclear CONLY
C++のデバッグでは、
C++言語そのものにおいては許されていないような@samp{&}の使用法を、
@value{GDBN}は実装しています。
C++の
（@samp{&@var{ref}}により宣言される）
参照変数が格納されているアドレスを調べるのに、
@samp{&(&@var{ref})}
（あるいは、
もしそうしたいのであれば単に@samp{&&@var{ref}}）
を使用することができます。
@end ifclear

@item -
マイナス（負）です。
整数型と浮動小数点型に対して定義されています。
@code{++}と同一の優先順位を持ちます。

@item !
論理@sc{not}です。
整数型に対して定義されています。
@code{++}と同一の優先順位を持ちます。

@item ~
ビットごとの@sc{not}
（補数）
演算子です。
整数型に対して定義されています。
@code{++}と同一の優先順位を持ちます。

@item .@r{, }->
構造体のメンバ、
ポインタの指す構造体のメンバをそれぞれ指定する演算子です。
便宜上、
@value{GDBN}は両者を同一のものとして扱い、
格納されている型情報をもとに、
ポインタによる間接参照の必要性を判断します。
構造体
（@code{struct}）
および共用体
（@code{union}）
に対して定義されています。

@ifset HPPA
@item .*@r{, }->*
メンバを指すポインタの間接参照です。
@end ifset

@item []
配列のインデックスです。
@code{@var{a}[@var{i}]}は、
@code{*(@var{a}+@var{i})}として定義されています。
@code{->}と同一の優先順位を持ちます。

@item ()
関数のパラメータ・リストです。
@code{->}と同一の優先順位を持ちます。

@ifclear CONLY
@item ::
C++のスコープ解決演算子です。
構造体（@code{struct}）、
共用体（@code{union}）、
クラス（@code{class}）に対して定義されています。
@end ifclear

@item ::
2重コロンはまた、
@value{GDBN}のスコープ演算子
@ifclear CONLY
も
@end ifclear
@ifset CONLY
を
@end ifset
表わします
（@pxref{Expressions, ,Expressions}）。
@ifclear CONLY
上記の@code{::}と同一の優先順位を持ちます。
@end ifclear
@end table

@ifset HPPA
ユーザ・コードの中で演算子が再定義されていると、
@value{GDBN}は通常、
事前定義されている意味ではなく、
再定義された意味において、
その演算子を実行することを試みます。
@end ifset

@ifclear CONLY
@menu
* C Constants::             
@end menu

@ifset MOD2
@node C Constants, Cplus expressions, C Operators, C
@subsubsection C/C++定数
@end ifset
@ifclear MOD2
@node C Constants, Cplus expressions, C Operators, Support
@subsubsection C/C++定数
@end ifclear

@cindex C and C++ constants
@cindex 定数、C/C++の[ていすう、CやC++の]
@value{GDBN}では、
以下のような方法によって、
C/C++の定数を表わすことができます。
@end ifclear
@ifset CONLY
@c {{sectionの直前で改頁されることがあるため、@cindexを後ろに移動。}}
@node C Constants, Debugging C, C Operators, C
@section C定数
@cindex C constants
@cindex 定数、Cの[ていすう、Cの]

@value{GDBN}では、
以下のような方法によって、
Cの定数を表わすことができます。
@end ifset

@itemize @bullet
@item
整数型定数は、
数字の連続したものです。
8進数定数は、
先頭の@samp{0}
（ゼロ）
により指定されます。
16進数定数は、
先頭の@samp{0x}または@samp{0X}により指定されます。
定数は、
文字@samp{l}
（エル）
により終わることもあります。
この場合、
定数が@code{long}型の値として扱われるべきことを意味します。

@item
浮動小数点型定数は、
連続した数字、
その後ろに小数点、
さらにその後ろに数字という形式です。
場合によっては、
最後に指数部が付くこともあります。
指数部は、
@samp{@w{e@r{[[}+@r{]|}-@r{]}@var{nnn}}}という形式を取ります。
ここで、
@var{nnn}は連続した数字です。
@samp{+}は、
正の指数を示す記号で、
必ずしも必要ではありません。

@item
列挙型定数は、
列挙識別子、
またはそれに対応する整数値より構成されます。

@item
文字型定数は、
単一引用符
（@code{'}）
によって囲まれた単一の文字、
あるいは、
その文字に対応する序数
（通常は、
@sc{ASCII}値）
です。
引用符の中の単一文字は、
文字または@dfn{エスケープ・シーケンス}によって表わすことができます。
エスケープ・シーケンスには2つの表記方法があります。
第1の形式は@samp{\@var{nnn}}で、
@var{nnn}はその文字の序数を表わす8進数です。
第2の形式は@samp{\@var{x}}で、
@samp{@var{x}}はあらかじめ定義された特別な文字です。
例えば、
@samp{\n}は改行を表わします。

@item
文字列型定数は、
連続した文字定数が2重引用符
（@code{"}）
で囲まれたものです。

@item
ポインタ型定数は、
整数値です。
定数へのポインタを、
Cの@samp{&}演算子を使用して記述することができます。

@item
配列定数は、
括弧@samp{@{}と@samp{@}}で囲まれ、
カンマで区切られたリストです。
例えば、
@samp{@{1,2,3@}}は3つの整数値を要素として持つ配列です。
@samp{@{@{1,2@}, @{3,4@}, @{5,6@}@}}は、
3×2の配列です。
また、
@samp{@{&"hi", &"there", &"fred"@}}は3つのポインタを要素として持つ配列です。
@end itemize

@ifclear CONLY
@menu
* Cplus expressions::           
* C Defaults::                  
@ifset MOD2
* C Checks::                    
@end ifset

* Debugging C::                 
@end menu

@ifset MOD2
@node Cplus expressions, C Defaults, C Constants, C
@subsubsection C++式
@end ifset
@ifclear MOD2
@node Cplus expressions, C Defaults, C Constants, Support
@subsubsection C++式
@end ifclear

@cindex expressions in C++
@cindex 式、C++の[しき、C++の]
@value{GDBN}が持っている、
式を処理する機能は、
C++のほとんどの式を解釈することができます。

@ifclear HPPA
@cindex C++ support, not in @sc{coff}
@cindex @sc{coff} versus C++
@cindex C++ and object formats
@cindex object formats and C++
@cindex a.out and C++
@cindex @sc{ecoff} and C++
@cindex @sc{xcoff} and C++
@cindex @sc{elf}/stabs and C++
@cindex @sc{elf}/@sc{dwarf} and C++
@cindex C++のサポート、@sc{coff}でない
@cindex C++とオブジェクトの形式[C++とオブジェクトのけいしき]
@cindex オブジェクトの形式とC++[オブジェクトのけいしきとC++]
@cindex C++と@sc{ecoff}
@cindex C++と@sc{xcoff}
@cindex C++と@sc{elf}
@cindex C++と@sc{dwarf}
@c FIXME!! GDB may eventually be able to debug C++ using DWARF; check
@c periodically whether this has happened...
@quotation
@emph{注意:}
@value{GDBN}は、
適切なコンパイラが使用されている場合のみ、
C++のコードをデバッグすることができます。
典型的な例を挙げると、
C++のデバッグでは、
シンボル・テーブルの中の追加的なデバッグ情報に依存するため、
特別なサポートが必要になるということがあります。
使用されるコンパイラが、
a.out、
MIPS @sc{ecoff}、
RS/6000 @sc{xcoff}、
@sc{elf}を、
シンボル・テーブルに対するstabs拡張付きで生成することができるのであれば、
以下に列挙する機能を使用することができます
（@sc{gnu} CCの場合は、
@samp{-gstabs}オプションを使用して明示的にstabsデバッグ拡張を要求することができます）。
一方、
オブジェクト・コードのフォーマットが、
標準@sc{coff}や@sc{elf}の@sc{dwarf}である場合には、
@value{GDBN}の提供するほとんどのC++サポートは機能@emph{しません}。
@end quotation
@end ifclear

@enumerate

@cindex member functions
@cindex メンバ関数[メンバかんすう]
@item
メンバ関数の呼び出しが許されます。
以下のような式を使用することができます。

@example
count = aml->GetOriginal(x, y)
@end example

@kindex this
@cindex namespace in C++
@cindex 名前空間、C++の[なまえくうかん、C++の]
@item
メンバ関数が
（選択されたスタック・フレームの中で）
アクティブな場合、
入力された式は、
そのメンバ関数と同一の名前空間を利用することができます。
すなわち、
@value{GDBN}は、
C++と同様の規則にしたがって、
クラス・インスタンスへのポインタ@code{this}への暗黙の参照を許します。

@ifclear HPPA
@cindex call overloaded functions
@cindex type conversions in C++
@cindex オーバーロードされた関数の呼び出し[オーバーロードされたかんすうのよびだし]
@cindex 呼び出し、オーバーロードされた関数の[よびだし、オーバーロードされたかんすうの]
@cindex 型変換、C++での[かたへんかん、C++での]
@item
オーバーロードされた関数を呼び出すことができます。
@value{GDBN}は、
正しい定義の関数呼び出しを決定します。
ただし、
制限が一点あります。
実際に呼び出したい関数が要求する型の引数を使用しなければなりません。
@value{GDBN}は、
コンストラクタやユーザ定義の型演算子を必要とするような変換を実行しません。

@end ifclear
@ifset HPPA
@cindex call overloaded functions
@cindex overloaded functions
@cindex type conversions in C++
@cindex オーバーロードされた関数[オーバーロードされたかんすう]
@cindex 型変換、C++での[かたへんかん、C++での]
@item
オーバーロードされた関数を呼び出すことができます。
@value{GDBN}は、
正しい定義の関数呼び出しを決定しますが、
いくつか制限があります。
まず、
ユーザ定義の型変換、
コンストラクタの呼び出し、
プログラムの中に存在しないテンプレートのインスタンス生成
を必要とするようなオーバーロードの解決を、
GDBは実行しません。
さらに、
省略記号を使用した引数リストやデフォルト引数を処理することもできません。

整数型の変換や拡張、
浮動小数点拡張、
算術変換、
ポインタ変換、
クラス・オブジェクトのベース・クラスへの変換、
および、
関数やポインタ配列などの標準的な変換は実行されます。
関数引数の数は、
正確に一致していなければなりません。

オーバーロードの解決は、
@code{set overload-resolution off}が指定されていない限り、
常に実行されます。
@xref{Debugging C plus plus, ,@value{GDBN} features for C++}。

次の例に示すように、
あるオーバーロードされた関数を呼び出すために
明示的な関数シグニチャを使用するためには、
@code{set overload-resolution off}を指定しなければなりません。
@smallexample
p 'foo(char,int)'('x', 13)
@end smallexample
@value{GDBN}のコマンド補完機能を利用すれば、
このようなことは簡単になります。
@pxref{Completion, ,Command completion}.

@end ifset

@cindex reference declarations
@cindex 参照宣言[さんしょうせんげん]
@item
@value{GDBN}は、
C++の参照変数として宣言された変数を理解します。
C++のソース・コードで参照変数を使用するのと同一の方法で、
参照変数を式の中で使用することができます。
参照変数は自動的に間接参照されます。

@value{GDBN}がフレームを表示する際に表示されるパラメータ一覧の中では、
参照変数の値は
（他の変数とは異なり）
表示されません。
これにより、
表示が雑然となることを回避できます。
というのは、
参照変数は大きい構造体に対して使用されることが多いからです。
参照変数の
@emph{アドレス}は、
@samp{set print address off}を指定しない限り、
常に表示されます。

@item
@value{GDBN}はC++の名前解決演算子@code{::}をサポートしています。
プログラム中と同様に、
式の中でこれを使用することができます。
あるスコープが別のスコープの中で定義されることがありえるため、
必要であれば@code{::}を繰り返し使用することができます。
例えば、
@samp{@var{scope1}::@var{scope2}::@var{name}}という具合です。
@value{GDBN}はまた、
CおよびC++のデバッグにおいて、
ソース・ファイルを指定することで名前のスコープを解決することを許します
（@pxref{Variables, ,Program variables}）。
@end enumerate

@ifset HPPA
さらに、
@value{GDBN}は、
仮想関数の正しい呼び出し、
オブジェクトの仮想ベース・クラスの表示、
ベース・サブオブジェクトの中の関数の呼び出し、
オブジェクトのキャスト、
ユーザ定義演算子の実行をサポートしています。
@end ifset

@ifset MOD2
@node C Defaults, C Checks, Cplus expressions, C
@subsubsection C/C++のデフォルト
@end ifset
@ifclear MOD2
@node C Defaults, Debugging C, Cplus expressions, Support
@subsubsection C/C++のデフォルト
@end ifclear
@cindex C and C++ defaults
@cindex デフォルト、C/C++の

@ifclear HPPA
@value{GDBN}が自動的に型チェックや範囲チェックの設定を行うことを許すと、
作業言語がCやC++に変更されるときにはいつも、
それらの設定はデフォルトで@code{off}になります。
これは、
作業言語を選択したのがユーザであっても@value{GDBN}であっても同様です。
@end ifclear

@value{GDBN}が自動的に言語の設定を行うことを許すと、
@value{GDBN}は、
名前が@file{.c}、
@file{.C}、
@file{.cc}などで終わるソース・ファイルを認識していて、
これらのファイルからコンパイルされたコードの実行を開始するときに、
作業言語をCまたはC++に設定します。
詳細については、
@xref{Automatically, ,Having @value{GDBN} infer the source language}。

@ifset MOD2
@c Type checking is (a) primarily motivated by Modula-2, and (b)
@c unimplemented.  If (b) changes, it might make sense to let this node
@c appear even if Mod-2 does not, but meanwhile ignore it. roland 16jul93.
@node C Checks, Debugging C, C Defaults, C Constants
@subsubsection C/C++の型チェックと範囲チェック
@cindex C and C++ checks
@cindex チェック、CやC++の

デフォルトでは、
@value{GDBN}がCやC++の式を解析するときには、
型チェックは行われません。
しかし、
ユーザが型チェックを有効にすると、
@value{GDBN}は以下の条件が成立するときに、
2つの変数の型が一致しているとみなします。

@itemize @bullet
@item
2つの変数が構造を持ち、
同一の構造体タグ、
共用体タグ、
または列挙型タグを持つ。

@item
2つの変数が同一の型名を持つ、
あるいは、
@code{typedef}によって同一の型に宣言されている型を持つ。

@ignore
@c leaving this out because neither J Gilmore nor R Pesch understand it.
@c FIXME--beers?
@item
The two @code{struct}, @code{union}, or @code{enum} variables are
declared in the same declaration.  (Note: this may not be true for all C
compilers.)
@end ignore
@end itemize

範囲チェックは、
onに設定されている場合、
数学的演算において実行されます。
配列のインデックスは、
それ自体は配列ではないポインタのインデックスとして使用されることが多いため、
チェックされません。
@end ifset
@end ifclear

@ifclear CONLY
@ifset MOD2
@node Debugging C, Debugging C plus plus, C Checks, C
@subsubsection @value{GDBN}とC
@end ifset
@ifclear MOD2
@node Debugging C, Debugging C plus plus, C Defaults, Support
@subsubsection @value{GDBN}とC
@end ifclear
@end ifclear
@ifset CONLY
@node Debugging C,  , C Constants, C
@section @value{GDBN}とC
@end ifset

@code{set print union}コマンドと@code{show print union}コマンドは共用体型
（@code{union}）
に適用されます。
@samp{on}に設定されると、
構造体
（@code{struct}）
@ifclear CONLY
やクラス
（@code{class}）
@end ifclear
の内部にある共用体
（@code{union}）
はすべて表示されます。
@samp{on}でない場合、
それは@samp{@{...@}}と表示されます。

@code{@@}オペレータは、
ポインタとメモリ割り当て関数によって作られた動的配列のデバッグに役に立ちます。
@xref{Expressions, ,Expressions}。

@ifclear CONLY
@menu
* Debugging C plus plus::       
@end menu

@ifset MOD2
@node Debugging C plus plus,  , Debugging C, C
@subsubsection C++用の@value{GDBN}機能
@end ifset
@ifclear MOD2
@node Debugging C plus plus,  , Debugging C, Support
@subsubsection C++用の@value{GDBN}機能
@end ifclear

@cindex commands for C++
@cindex コマンド、C++専用の[コマンド、C++せんようの]
@value{GDBN}のコマンドの中には、
C++を使用しているときに特に役に立つものがあり、
また、
C++専用に特に設計されたものがあります。
以下に、
その要約を示します。

@table @code
@cindex break in overloaded functions
@cindex オーバーロードされている関数のブレイク[オーバーロードされているかんすうのブレイク]
@item @r{breakpoint menus}
名前がオーバーロードされている関数の内部にブレイクポイントを設定したい場合、
関心のある関数定義を指定するのに、
@value{GDBN}のブレイクポイント・メニューが役に立ちます。
@xref{Breakpoint Menus,,Breakpoint menus}。

@cindex overloading in C++
@cindex オーバーロード、C++での
@item rbreak @var{regex}
あるオーバーロードされたメンバ関数が、
特別なクラスだけが持つメンバ関数というわけではない場合、
そのメンバ関数にブレイクポイントを設定するのに、
正規表現によるブレイクポイントの設定が役に立ちます。
@xref{Set Breaks, ,Setting breakpoints}。

@cindex C++ exception handling
@cindex C++の例外処理[C++のれいがいしょり]
@item catch throw
@itemx catch catch
C++の例外処理をデバッグするのに使用します。
@xref{Set Catchpoints, , Setting catchpoints}。

@cindex inheritance
@cindex 継承[けいしょう]
@item ptype @var{typename}
型@var{typename}に関して、継承関係などの情報を表示します。
@xref{Symbols, ,Examining the Symbol Table}。

@cindex C++ symbol display
@cindex C++のシンボル表示[C++のシンボルひょうじ]
@item set print demangle
@itemx show print demangle
@itemx set print asm-demangle
@itemx show print asm-demangle
コードをC++のソースとして表示する場合と、
逆アセンブル処理の結果を表示する場合に、
C++のシンボルをソース形式で表示するか否かを制御します。
@xref{Print Settings, ,Print settings}。

@item set print object
@itemx show print object
オブジェクトの型を表示する際に、
派生した
（実際の）
型と宣言された型のどちらを表示するかを選択します。
@xref{Print Settings, ,Print settings}。

@item set print vtbl
@itemx show print vtbl
仮想関数テーブルの表示形式を制御します。
@xref{Print Settings, ,Print settings}。
@ifset HPPA
（@code{vtbl}コマンドは、
HP ANSI C++コンパイラ（@code{aCC}）
によってコンパイルされたプログラムに対しては機能しません。）

@kindex set overload-resolution
@cindex overloaded functions
@cindex オーバーロードされた関数[オーバーロードされたかんすう]
@item set overload-resolution on
C++の式の評価に際して、
オーバーロード解決を有効化します。
デフォルトはonです。
@value{GDBN}は、
オーバーロードされた関数の引数を評価し、
標準的なC++の変換規則
（詳細については、
@pxref{Cplus expressions, ,C++ expressions}）
を利用して、
引数の型がマッチするシグニチャを持つ関数を探します。
マッチする関数を見つけることができない場合は、
メッセージを出力します。

@item set overload-resolution off
C++の式の評価に際して、
オーバーロード解決を無効化します。
@value{GDBN}は、
オーバーロードされた関数のうちクラスのメンバ関数ではないものについては、
引数が正しい型であるか否かにかかわりなく、
シンボル・テーブルの中で最初に見つかった、
指定された名前を持つ関数を選択します。
オーバーロードされた関数のうちクラスのメンバ関数でもあるものについては、
引数の型が@emph{正確}にマッチするシグニチャを持つ関数を探します。
@end ifset

@item @r{オーバーロードされたシンボル名}
オーバーロードされたシンボルを宣言するのに
C++において使用されるのと同一の表記法を使用して、
オーバーロードされたシンボル定義のうち、
特定のものを指定することができます。
単に@var{symbol}と入力するのではなく、
@code{@var{symbol}(@var{types})}と入力してください。
@value{GDBN}コマンドラインの単語補完機能を使用して、
利用可能な選択肢を一覧表示させたり、
型のリストを完結させたりすることができます。
この機能の使用方法の詳細については、
@xref{Completion,, Command completion}。
@end table
@ifclear MOD2
@c cancels "raisesections" under same conditions near bgn of chapter
@lowersections
@end ifclear

@ifset MOD2
@node Modula-2,  ,C , Support
@subsection Modula-2
@cindex Modula-2

Modula-2をサポートするために開発された@value{GDBN}の拡張機能は、
（現在開発中の）
@sc{gnu} Modula-2コンパイラによって生成されたコードだけをサポートします。
他のModula-2コンパイラは現在サポートされていません。
他のModula-2コンパイラが生成した実行形式モジュールをデバッグしようとすると、
おそらく、
@value{GDBN}が実行モジュールのシンボル・テーブルを読み込もうとしたところでエラーになるでしょう。

@cindex expressions in Modula-2
@cindex 式、Modula-2での[しき、Modula-2での]
@menu
* M2 Operators::                組み込み演算子
* Built-In Func/Proc::          組み込み関数と組み込みプロシージャ
* M2 Constants::                Modula-2定数
* M2 Defaults::                 Modula-2デフォルト設定
* Deviations::                  標準Modula-2との差異
* M2 Checks::                   Modula-2の型チェックと範囲チェック
* M2 Scope::                    スコープ演算子@code{::}と@code{.}
* GDB/M2::                      @value{GDBN}とModula-2
@end menu

@node M2 Operators, Built-In Func/Proc, Modula-2, Modula-2
@subsubsection Modula-2演算子
@cindex Modula-2 operators
@cindex 演算子、Modula-2の[えんざんし、Modula-2の]

演算子は、
特定の型の値に対して定義されなければなりません。
例えば、
@code{+}は数値に対して定義され、
構造体に対しては定義されません。
演算子は、
型のグループに対して定義されることがよくあります。
Modula-2においては、
以下の定義が有効です。

@itemize @bullet

@item
@emph{整数型}は、
@code{INTEGER}、
@code{CARDINAL}、
およびそのサブ範囲
（subrange）
から成ります。

@item
@emph{文字型}は、
@code{CHAR}とそのサブ範囲から成ります。

@item
@emph{浮動小数点型}は、
@code{REAL}から成ります。

@item
@emph{ポインタ型}は、
@code{POINTER TO @var{type}}
のように宣言された任意の型から成ります。

@item
@emph{スカラ型}は、
上記のすべての型から成ります。

@item
@emph{集合型}は、
@code{SET}、
@code{BITSET}から成ります。

@item
@emph{ブール型}は、
@code{BOOLEAN}から成ります。
@end itemize

@noindent
以下の演算子がサポートされています。
ここでは、
優先順位の低いものから順に並べています。

@table @code
@item ,
関数の引数の区切り記号、
または、
配列のインデックスの区切り記号です。

@item :=
代入です。
@var{var} @code{:=} @var{value}の値は
@var{value}です。

@item <@r{、}>
未満、
超過です。
整数型、
浮動小数点型、
列挙型に対して定義されています。

@item <=@r{、}>=
整数型、
浮動小数点型、
列挙型に対しては、
以下、
以上を表わします。
集合型に対しては、
集合の包含関係を表わします。
@code{<}と同一の優先順位を持ちます。

@item =@r{、}<>@r{、}#
スカラ型に対して定義されている等価および2種類の不等価です。
@code{<}と同一の優先順位を持ちます。
@value{GDBN}スクリプトの中では、
@code{#}がスクリプトのコメント記号でもあるため、
不等価としては@code{<>}だけが使用可能です。

@item IN
集合のメンバを表わします。
集合型、
およびそのメンバの型に対して定義されています。
@code{<}と同一の優先順位を持ちます。

@item OR
ブール型の@sc{OR}
（disjunction）
です。
ブール型に対して定義されています。

@item AND@r{、}&
ブール型の@sc{AND}
（conjunction）
です。
ブール型に対して定義されています。

@item @@
@value{GDBN}の「人工配列」演算子です
（@pxref{Expressions, ,Expressions}）。

@item +@r{、}-
整数型、
浮動小数点型に対しては、
加算、
減算を表わします。
集合型に対しては、
和集合
（union）、
差集合
（difference）
を表わします。

@item *
整数型、
浮動小数点型に対しては、
乗算を表わします。
集合型に対しては、
積集合
（intersection）
を表わします。

@item /
浮動小数点型に対しては、
除算を表わします。
集合型に対しては、
対称的差集合
（symmetric difference）
を表わします。
@code{*}と同一の優先順位を持ちます。

@item DIV@r{、}MOD
整数型の除算における商と剰余を表わします。
整数型に対して定義されています。
@code{*}と同一の優先順位を持ちます。

@item -
マイナス（負）です。
@code{INTEGER}、
@code{REAL}型のデータに対して定義されています。

@item ^
ポインタの間接参照です。
ポインタ型に対して定義されています。

@item NOT
ブール型の@sc{NOT}です。
ブール型に対して定義されています。
@code{^}と同一の優先順位を持ちます。

@item .
@code{RECORD}フィールドの区切り記号です。
@code{RECORD}データに対して定義されます。
@code{^}と同一の優先順位を持ちます。

@item []
配列のインデックスを指定します。
@code{ARRAY}型のデータに対して定義されています。
@code{^}と同一の優先順位を持ちます。

@item ()
プロシージャの引数リストを指定します。
@code{PROCEDURE}オブジェクトに対して定義されています。
@code{^}と同一の優先順位を持ちます。

@item ::@r{、}.
@value{GDBN}およびModula-2のスコープ指定演算子です。
@end table

@quotation
@emph{注意:}
集合、
および集合に対する操作は、
まだサポートされていません。
このため、
@value{GDBN}は@code{IN}演算子、
あるいは、
集合に対して@code{+}、
@code{-}、
@code{*}、
@code{/}、
@code{=}、
@code{<>}、
@code{#}、
@code{<=}、
@code{>=}のいずれかの演算子が使用された場合、
これをエラーとして扱います。
@end quotation

@c {{subsubsectionの直前で改頁されることがあるため、@cindexを後ろに移動。}}
@node Built-In Func/Proc, M2 Constants, M2 Operators, Modula-2
@subsubsection 組み込み関数と組み込みプロシージャ
@cindex Modula-2 built-ins
@cindex 組み込み機能、Modula-2の[くみこみきのう、Modula-2の]

Modula-2では、
いくつかの組み込みプロシージャ、
組み込み関数が使用できます。
これらの説明にあたり、
以下のメタ変数を使用します。

@table @var

@item a
@code{ARRAY}型の変数を表わします。

@item c
@code{CHAR}型の定数、
または変数を表わします。

@item i
整数型の変数、
または定数を表わします。

@item m
集合に属する識別子を表わします。
通常、
同一関数の中でメタ変数@var{s}とともに使用されます。
@var{s}の型は、
@code{SET OF @var{mtype}}でなければなりません
（ここでの@var{mtype}は@var{m}の型です）。

@item n
整数型または浮動小数点型の、
変数または定数を表わします。

@item r
浮動小数点型の変数または定数を表わします。

@item t
型を表わします。

@item v
変数を表わします。

@item x
多くの型の中の1つの型の、
変数または定数を表わします。
詳細については、
関数の説明の部分を参照してください。
@end table

また、
すべてのModula-2の組み込みプロシージャは、
以下に説明する値を返します。

@table @code
@item ABS(@var{n})
値@var{n}の絶対値を返します。

@item CAP(@var{c})
@var{c}が小文字であれば、
それを大文字にして返します。
@var{c}が小文字でなければ、
@var{c}をそのまま返します。

@item CHR(@var{i})
序数が@var{i}である文字を返します。

@item DEC(@var{v})
変数@var{v}の値から1を引きます。
新しい値を返します。

@item DEC(@var{v},@var{i})
変数@var{v}の値から@var{i}で示される値を引きます。
新しい値を返します。

@item EXCL(@var{m},@var{s})
集合@var{s}から要素@var{m}を取り除きます。
新しい集合を返します。

@item FLOAT(@var{i})
整数値@var{i}に等しい浮動小数点値を返します。

@item HIGH(@var{a})
配列@var{a}の最後の要素のインデックスを返します。

@item INC(@var{v})
変数@var{v}の値に1を加えます。
新しい値を返します。

@item INC(@var{v},@var{i})
変数@var{v}の値に@var{i}で示される値を加えます。
新しい値を返します。

@item INCL(@var{m},@var{s})
集合@var{s}に要素@var{m}が存在しない場合、
要素@var{m}を追加します。
新しい集合を返します。

@item MAX(@var{t})
型@var{t}の最大値を返します。

@item MIN(@var{t})
型@var{t}の最小値を返します。

@item ODD(@var{i})
@var{i}が奇数であればブール型の@code{TRUE}を返します。

@item ORD(@var{x})
引数の序数値を返します。
例えば、
文字の序数値は、
（@sc{ascii}文字セットをサポートするマシン上では）
その@sc{ascii}値です。
ここで@var{x}は、
整数型、
文字型、
列挙型のような順序を持つ型でなければなりません。

@item SIZE(@var{x})
引数のサイズを返します。
@var{x}は変数または型のいずれかです。

@item TRUNC(@var{r})
@var{r}の整数部を返します。

@item VAL(@var{t},@var{i})
型@var{t}のメンバのうち、
その序数値が@var{i}であるものを返します。
@end table

@quotation
@emph{注意:}
集合、
および集合に対する操作はまだサポートされていません。
したがって、
@code{INCL}プロシージャ、
@code{EXCL}プロシージャを使用すると、
@value{GDBN}はエラーとして扱います。
@end quotation

@c {{subsubsectionの直前で改頁されることがあるため、@cindexを後ろに移動。}}
@node M2 Constants, M2 Defaults, Built-In Func/Proc, Modula-2
@subsubsection 定数
@cindex Modula-2 constants
@cindex 定数、Modula-2の[ていすう、Modula-2の]

@value{GDBN}では、
Modula-2の定数を以下のような方法で表現することができます。

@itemize @bullet

@item
整数型の定数は、
単に数字が連続したものです。
式の中で使用された場合、
定数は、
式の他の部分と互換性のある型を持つものとみなされます。
16進数の整数は末尾に@samp{H}を付加することで、
また、
8進数の整数は末尾に@samp{B}を付加することで指定されます。

@item
浮動小数点型の定数は、
連続した数字、
その後ろに小数点、
さらにその後ろに連続した数字が続くものです。
場合によっては、
この後ろに指数部を指定することができます。
指数部の形式は@samp{E@r{[}+@r{|}-@r{]}@var{nnn}}で、
@samp{@r{[}+@r{|}-@r{]}@var{nnn}}の部分で希望する指数を指定します。
浮動小数点型定数のすべての数字は、
有効な10進数値でなければなりません。

@item
文字型定数は、
単一引用符（@code{'}）または2重引用符（@code{"}）で囲まれた単一文字より成ります。
文字型定数は、
その文字の序数値
（通常は@sc{ascii}値）
の後ろに@samp{C}を付加することで表現することもできます。

@item
文字列型定数は、
単一引用符（@code{'}）または2重引用符（@code{"}）で囲まれた連続する文字から成ります。
C言語のスタイルでのエスケープ・シーケンスも使用できます。
エスケープ・シーケンスに関する簡単な説明については、
@xref{C Constants, ,C and C++ constants}。

@item
列挙型定数は、
列挙識別子から成ります。

@item
ブール型定数は、
識別子@code{TRUE}および@code{FALSE}から成ります。

@item
ポインタ型定数は、
整数値だけから成ります。

@item
集合型定数は、
まだサポートされていません。
@end itemize

@node M2 Defaults, Deviations, M2 Constants, Modula-2
@subsubsection Modula-2デフォルト
@cindex Modula-2 defaults
@cindex デフォルト、Modula-2の

型チェックと範囲チェックが@value{GDBN}により自動的に設定される場合、
作業言語がModula-2に変わるたびに、
それらはデフォルトで@code{on}に設定されます。
これは、
作業言語を選択したのがユーザであろうと@value{GDBN}であろうと同様です。

@value{GDBN}に自動的に言語を設定させると、
ファイル名の末尾が@file{.mod}であるファイルからコンパイルされたコードに入るたびに、
作業言語はModula-2に設定されます。
詳細については、
@xref{Automatically, ,Having @value{GDBN} set the language automatically}。

@node Deviations, M2 Checks, M2 Defaults, Modula-2
@subsubsection 標準Modula-2との差異
@cindex Modula-2, deviations from
@cindex 差異、標準Modula-2との[さい、ひょうじゅんModula-2との]

Modula-2プログラムのデバッグを容易にするために2、
3の修正が施されています。
これは主に、
型に対する厳密性を緩めることによって実現されています。

@itemize @bullet
@item
標準Modula-2とは異なり、
ポインタ型定数は整数値から作成することができます。
これにより、
デバッグ中にポインタ変数の値を変更することができるようになります
（標準Modula-2では、
ポインタ変数に格納されている実際のアドレスを知ることはできません。
ポインタ変数内のアドレスは、
他のポインタ変数、
または、
ポインタを返す式を直接的に代入することによってのみ修正することができます）。

@item
表示不可の文字を表わすのに、
C言語のエスケープ・シーケンスを文字列や文字において使用することができます。
@value{GDBN}はこれらのエスケープ・シーケンスを埋め込んだまま文字列を表示します。
表示不可の単一文字は、
@samp{CHR(@var{nnn})}という形式で表示されます。

@item
代入演算子
（@code{:=}）
は、
右側の引数の値を返します。

@item
すべての組み込みプロシージャは、
引数を修正し、
@emph{さらに}それを返します。
@end itemize

@node M2 Checks, M2 Scope, Deviations, Modula-2
@subsubsection Modula-2の型チェックと範囲チェック
@cindex Modula-2 checks
@cindex チェック、Modula-2の

@quotation
@emph{注意:}
@value{GDBN}は現在のところ、
型チェック、
範囲チェックをまだ実装していません。
@end quotation
@c FIXME remove warning when type/range checks added

@value{GDBN}は、
以下のいずれかの条件が成立するとき、
2つのModula-2変数の型が等しいとみなします。

@itemize @bullet
@item
2つの型が、
@code{TYPE @var{t1} = @var{t2}}文によって等しいと宣言されている型である。

@item
2つの型が同一行において宣言されている
（注：これは@sc{gnu} Modula-2コンパイラにおいては正しいのですが、
他のコンパイラにおいては正しくない可能性があります）。
@end itemize

型チェックが有効である限り、
等しくない型の変数を組み合わせようとする試みはすべてエラーとなります。

範囲チェックは、
数学的操作、
代入、
配列のインデックス境界、
およびすべての組み込み関数、
組み込みプロシージャにおいて実行されます。

@node M2 Scope, GDB/M2, M2 Checks, Modula-2
@subsubsection スコープ演算子@code{::}と@code{.}
@cindex scope
@cindex スコープ演算子[スコープえんざんし]
@kindex .
@cindex colon, doubled as scope operator
@cindex コロン、スコープ演算子の2重[コロン、スコープえんざんしの2じゅう]
@ifinfo
@kindex colon-colon
@c Info cannot handle :: but TeX can.
@end ifinfo
@iftex
@kindex ::
@end iftex

Modula-2のスコープ演算子
（@code{.}）
と@value{GDBN}のスコープ演算子
（@code{::}）
との間には2、
3の微妙な相違点があります。
この2つは似た構文を持っています。

@example

@var{module} . @var{id}
@var{scope} :: @var{id}
@end example

@noindent
ここで、
@var{scope}はモジュール名またはプロシージャ名、
@var{module}はモジュール名、
@var{id}はユーザ・プログラムの中で宣言された任意の
（異なるモジュール以外の）
識別子です。

@code{::}演算子を使用すると、
@value{GDBN}は@var{scope}によって指定されたスコープにおいて識別子@var{id}を探します。
指定されたスコープにおいてそれを見つけることができないと、
@value{GDBN}は@var{scope}によって指定されたスコープを包含するすべてのスコープを探します。

@code{.}演算子を使用すると、
@value{GDBN}はカレントなスコープにおいて、
@var{modue}によって指定された定義モジュールから取り込まれた、
@var{id}によって指定される識別子を探します。
この演算子では、
識別子@var{id}が定義モジュール@var{module}から取り込まれていない場合や@var{module}において@var{id}が識別子でない場合は、
エラーになります。

@node GDB/M2,  , M2 Scope, Modula-2
@subsubsection @value{GDBN}とModula-2

@value{GDBN}コマンドの中には、
Modula-2プログラムのデバッグにはほとんど役に立たないものがいくつかあります。
@code{set print}、
@code{show print}の5つのサブ・コマンド@samp{vtbl}、
@samp{demangle}、
@samp{asm-demangle}、
@samp{object}、
@samp{union}はC/C++にのみ適用されます。
最初の4つはC++に適用され、
最後の1つはCの共用体
（@code{union}）
に適用されます。
これらは、
Modula-2において直接類似するものが存在しません。

@code{@@}演算子
（@pxref{Expressions, ,Expressions}）
は、
どの言語においても使用することができますが、
Modula-2においてはあまり役に立ちません。
この演算子は、
@dfn{動的配列}のデバッグを支援することを目的とするものですが、
C/C++では作成できる動的配列は、
Modula-2では作成できません。
しかし、
整数値定数によってアドレスを指定することができるので、
@samp{@{@var{type}@}@var{adrexp}}は役に立ちます
（@pxref{Expressions, ,Expressions}）。

@cindex @code{#} in Modula-2
@cindex Modula-2の@code{#}
@value{GDBN}スクリプトの中では、
Modula-2の不等価演算子@code{#}はコメントの開始記号として解釈されます。
代わりに@code{<>}を使用してください。
@end ifset
@end ifclear

@node Symbols, Altering, Languages, Top
@chapter シンボル・テーブルの検査

ここで説明するコマンドによって、
ユーザ・プログラムの中で定義されているシンボル情報
（変数名、
関数名、
型名）
に関する問い合わせを行うことができます。
この情報はユーザ・プログラムのテキストに固有のもので、
プログラムの実行時に変わるものではありません。
@value{GDBN}はこの情報を、
ユーザ・プログラムのシンボル・テーブルの中、
または、
@value{GDBN}起動時に指定されたファイル
（@pxref{File Options, ,Choosing files}）
の中で見つけるか、
ファイル管理コマンド
（@pxref{Files, ,Commands to specify files}）
の実行によって見つけます。

@cindex symbol names
@cindex names of symbols
@cindex quoting names
@cindex シンボルの名前[シンボルのなまえ]
@cindex 名前、シンボルの[なまえ、シンボルの]
@cindex 引用[いんよう]
ときには、
参照する必要のあるシンボルの中に、
@value{GDBN}が通常は単語の区切り文字として扱う文字が含まれていることがあるかもしれません。
特に多いのが、
他のソース・ファイルの中の静的変数を参照する場合です
（@pxref{Variables,,Program variables}）。
ファイル名は、
オブジェクト・ファイルの中にデバッグ・シンボルとして記録されていますが、
@value{GDBN}は通常、
典型的なファイル名、
例えば@file{foo.c}を解析して、
3つの単語
@samp{foo}、
@samp{.}（ピリオド）、
@samp{c}であるとみなします。
@value{GDBN}が@samp{foo.c}を単一のシンボルであると認識できるようにするには、
それを単一引用符で囲みます。
例えば、

@example
p 'foo.c'::x
@end example

@noindent
は、
@code{x}の値をファイル@file{foo.c}のスコープの中で検索します。

@table @code
@kindex info address
@item info address @var{symbol}
@var{symbol}で指定されるシンボルのデータがどこに格納されているかを示します。
レジスタ変数の場合は、
それがどのレジスタに入っているかを示します。
レジスタ変数ではないローカル変数の場合は、
その変数が常に格納されている位置の、
スタック・フレーム内におけるオフセット値を表示します。

@samp{print &@var{symbol}}との相違に注意してください。
@samp{print &@var{symbol}}はレジスタ変数に対しては機能しませんし、
スタック内のローカル変数に対して実行すると、
その変数のカレントなインスタンスの存在するアドレスそのものが表示されます。

@kindex whatis
@item whatis @var{exp}
式@var{exp}のデータ型を表示します。
@var{exp}は実際には評価されず、
@var{exp}内の副作用を持つ操作
（例えば、代入や関数呼び出し）
は実行されません。
@xref{Expressions, ,Expressions}。

@item whatis
値ヒストリの最後の値である
@code{$}のデータ型を表示します。

@kindex ptype
@item ptype @var{typename}
データ型@var{typename}の説明を表示します。
@var{typename}は型の名前です。
Cで記述されたコードの場合は、
@ifclear CONLY
@samp{class @var{class-name}}、
@end ifclear
@samp{struct @var{struct-tag}}、
@samp{union @var{union-tag}}、
@samp{enum @var{enum-tag}}という形式を取ることができます。

@item ptype @var{exp}
@itemx ptype
式@var{exp}の型に関する説明を表示します。
単に型の名前を表示するだけではなく、
詳細な説明も表示するという点で、
@code{ptype}は@code{whatis}と異なります。

例えば、
変数宣言

@example
struct complex @{double real; double imag;@} v;
@end example

@noindent
に対して、
@code{whatis}、
@code{ptype}はそれぞれ以下のような出力をもたらします。

@example
@group
(@value{GDBP}) whatis v
type = struct complex
(@value{GDBP}) ptype v
type = struct complex @{
    double real;
    double imag;
@}
@end group
@end example

@noindent
@code{whatis}と同様、
引数なしで@code{ptype}を使用すると、
値ヒストリの最後の値である@code{$}の型を参照することになります。

@kindex info types
@item info types @var{regexp}
@itemx info types
その名前が@var{regexp}で指定される正規表現にマッチするすべての型
（あるいは、
引数を指定しなければ、
ユーザ・プログラム中のすべての型）
の簡単な説明を表示します。
個々の型の完全な名前は、
それ自体が1つの完全な行を構成するものとみなして、
マッチされます。
したがって、
@samp{i type value}は、
ユーザ・プログラムの中で、
その名前が文字列@code{value}を含むすべての型に関する情報を表示し、
@samp{i type ^value$}は、
名前が@code{value}そのものである型に関する情報だけを表示します。

このコマンドは@code{ptype}とは2つの点で異なります。
まず第1に@code{whatis}と同様、
詳細な情報を表示しません。
第2に、
型が定義されているすべてのソース・ファイルを一覧表示します。

@kindex info source
@item info source
カレントなソース・ファイル、
すなわち、
カレントな実行箇所を含む関数のソース・ファイルの、
ファイル名とそれが記述された言語の名前を表示します。

@kindex info sources
@item info sources
ユーザ・プログラムのソース・ファイルのうち、
デバッグ情報の存在するものすべての名前を、
2つの一覧にして表示します。
2つの一覧とは、
シンボルが既に読み込まれたファイルの一覧と、
後に必要なときにシンボルが読み込まれるファイルの一覧です。

@kindex info functions
@item info functions
すべての定義済み関数の名前とデータ型を表示します。

@item info functions @var{regexp}
その名前が@var{regexp}で指定される正規表現にマッチする部分を持つすべての定義済み関数の名前とデータ型を表示します。
したがって、
@samp{info fun step}は、
その名前が文字列@code{step}を含むすべての関数を見つけ、
@samp{info fun ^step}は、
名前が文字列@code{step}で始まるすべての関数を見つけます。

@kindex info variables
@item info variables
関数の外部で宣言されているすべての変数
（つまり、
ローカル変数を除く変数）
の名前とデータ型を表示します。

@item info variables @var{regexp}
その名前が正規表現@var{regexp}にマッチする部分を持つすべての
（ローカル変数を除く）
変数の名前とデータ型を表示します。

@ignore
This was never implemented.
@kindex info methods
@item info methods
@itemx info methods @var{regexp}
The @code{info methods} command permits the user to examine all defined
methods within C++ program, or (with the @var{regexp} argument) a
specific set of methods found in the various C++ classes.  Many
C++ classes provide a large number of methods.  Thus, the output
from the @code{ptype} command can be overwhelming and hard to use.  The
@code{info-methods} command filters the methods, printing only those
which match the regular-expression @var{regexp}.
@end ignore

@ifclear HPPA
@cindex reloading symbols
@cindex 再ロード、シンボルの[さいロード、シンボルの]
@cindex リロード
いくつかのシステムにおいては、
ユーザ・プログラムの停止・再起動を伴うことなく、
そのユーザ・プログラムを構成する個々のオブジェクト・ファイルを更新することができます。
@ifset VXWORKS
例えば、
VxWorksでは、
欠陥のあるオブジェクト・ファイルを再コンパイルして、
実行を継続することができます。
@end ifset
このようなマシン上でプログラムを実行しているのであれば、
自動的に再リンクされたモジュールのシンボルを@value{GDBN}に再ロードさせることができます。

@table @code
@kindex set symbol-reloading
@item set symbol-reloading on
ある特定の名前を持つオブジェクト・ファイルが再検出されたときに、
対応するソース・ファイルのシンボル定義を入れ替えます。

@item set symbol-reloading off
同じ名前を持つオブジェクト・ファイルを再検出したときに、
シンボル定義を入れ替えません。
これがデフォルトの状態です。
モジュールの自動再リンクを許しているシステム上でプログラムを実行しているのでない場合は、
@code{symbol-reloading}の設定はoffのままにするべきです。
さもないと、
（異なるディレクトリやライブラリの中にある）
同じ名前を持ついくつかのモジュールを含むような大きなプログラムをリンクする際に、
@value{GDBN}
はシンボルを破棄してしまうかもしれません。

@kindex show symbol-reloading
@item show symbol-reloading
@code{symbol-reloading}のカレントな設定
（@code{on}または@code{off}）
を表示します。
@end table
@end ifclear

@ifset HPPA
@kindex set opaque-type-resolution
@item set opaque-type-resolution on
オペーク（opaque）型の解決を行うよう@value{GDBN}に指示します。
オペーク型とは、
@code{struct}、
@code{class}、
または、
@code{union}へのポインタとして宣言されている型
--例えば、@code{struct MyType *}--
であり、
かつ、
@code{struct MyType}@footnote{訳注：その型（ポインタ）の指す実体}
の完全な宣言が行われているソース・ファイルとは異なるソース・ファイルにおいて使用される型のことです。
デフォルトはonです。

このサブコマンドの設定を変更しても、
ファイルのシンボルが次にロードされるまでは効力を持ちません。

@item set opaque-type-resolution off
オペーク型の解決を行わないよう@value{GDBN}に指示します。
この場合、
オぺーク型は以下のように表示されます。
@smallexample
@{<no data fields>@}
@end smallexample

@kindex show opaque-type-resolution
@item show opaque-type-resolution
オペーク型の解決が行われるか否かを示します。
@end ifset

@kindex maint print symbols
@cindex symbol dump
@cindex シンボル・ダンプ
@kindex maint print psymbols
@cindex partial symbol dump
@cindex 部分的シンボル・ダンプ[ぶぶんてきシンボル・ダンプ]
@item maint print symbols @var{filename}
@itemx maint print psymbols @var{filename}
@itemx maint print msymbols @var{filename}
デバッグ・シンボル・データのダンプをファイル@var{filename}の中に書き込みます。
これらのコマンドは、
@value{GDBN}のシンボル読み込みコードをデバッグするのに使われています。
デバッグ・データを持つシンボルだけがダンプに含まれます。
@samp{maint print symbols}を使用すると、
@value{GDBN}は、
完全な詳細情報を入手済みのすべてのシンボルの情報をダンプに含めます。
つまり、
ファイル@var{filename}には、
@value{GDBN}がそのシンボルを読み込み済みのファイルに対応するシンボルが反映されます。
@code{info sources}コマンドを使用することで、
これらのファイルがどれであるかを知ることができます。
代わりに@samp{maint print psymbols}を使用すると、
@value{GDBN}
が部分的にしか知らないシンボルに関する情報もダンプの中に含まれます。
これは、
@value{GDBN}がざっと読みはしたものの、
まだ完全には読み込んでいないファイルに定義されているシンボルに関する情報です。
最後に@samp{maint print msymbols}では、
@value{GDBN}が何らかのシンボル情報を読み込んだオブジェクト・ファイルから、
最小限必要とされるシンボル情報がダンプされます。
@value{GDBN}がどのようにしてシンボルを読み込むかについては、
@ref{Files, ,Commands to specify files}
（の@code{symbol-file}の説明の部分）
を参照してください。
@end table

@node Altering, GDB Files, Symbols, Top
@chapter 実行の変更

ユーザ・プログラムの中に誤りのある箇所を見つけると、
その明らかな誤りを訂正することで、
その後の実行が正しく行われるかどうかを知りたくなるでしょう。
@value{GDBN}にはプログラムの実行に変化を与える機能があり、
これを使って実験することで、
その答を知ることができます。

例えば、
変数やメモリ上のある箇所に新しい値を格納すること、
@ifclear BARETARGET
ユーザ・プログラムにシグナルを送ること、
ユーザ・プログラムを異なるアドレスで再起動すること、
@end ifclear
@c {{???}}
@ifset BARETARGET
ユーザ・プログラムを異なるアドレスで再起動すること、
@end ifset
関数が完全に終了する前に呼び出し元に戻ることなどが可能です。

@menu
* Assignment::                  変数への代入
* Jumping::                     異なるアドレスにおける処理継続
@ifclear BARETARGET
* Signaling::                   ユーザ・プログラムへのシグナルの通知
@end ifclear

* Returning::                   関数からの復帰
* Calling::                     ユーザ・プログラム関数の呼び出し
* Patching::                    ユーザ・プログラムへのパッチ適用
@end menu

@node Assignment, Jumping, Altering, Altering
@section 変数への代入

@cindex assignment
@cindex setting variables
@cindex 代入[だいにゅう]
@cindex 更新、変数値の[こうしん、へんすうちの]
@cindex 設定、変数値の[せってい、へんすうちの]
@cindex 変更、変数値の[へんこう、へんすうちの]
ある変数の値を変更するには、
代入式を評価します。
@xref{Expressions, ,Expressions}。
例えば、

@example
print x=4
@end example

@noindent
は、
変数@code{x}に値4を格納してから、
その代入式の値
（すなわち4）
を表示します。
@ifclear CONLY
サポートされている言語の演算子の詳細情報については、
@xref{Languages, ,Using @value{GDBN} with Different Languages}。
@end ifclear

@kindex set variable
@cindex variables, setting
@cindex 変数への代入[へんすうへのだいにゅう]
代入の結果を表示させることに関心がなければ、
@code{print}コマンドの代わりに@code{set}コマンドを使用してください。
実際のところ@code{set}コマンドは、
式の値が表示もされず、
値ヒストリ
（@pxref{Value History, ,Value history}）
にも入らないということを除けば、
@code{print}コマンドと同等です。
式は、
その結果の入手だけを目的として評価されます。

@ifclear HPPA
@code{set}コマンドの引数となる文字列の先頭の部分が、
@code{set}コマンドのサブ・コマンドの名前と一致してしまうような場合には、
ただの@code{set}コマンドではなく@code{set variable}コマンドを使用してください。
このコマンドは、
サブ・コマンドを持たないという点を除けば、
@code{set}コマンドと同等です。
例えば、
ユーザ・プログラムに@code{width}という変数がある場合、
@samp{set width=13}によってこの変数に値を設定しようとするとエラーになります。
これは、
@value{GDBN}が@code{set width}というコマンドを持っているためです。

@example
(@value{GDBP}) whatis width
type = double
(@value{GDBP}) p width
$4 = 13
(@value{GDBP}) set width=47
Invalid syntax in expression.
@end example

@noindent
ここで不正な表現となっているのは、
もちろん@samp{=47}の部分です。
プログラム内の変数@code{width}に値を設定するには、
以下のようにしてください。

@example
(@value{GDBP}) set var width=47
@end example
@end ifclear
@ifset HPPA
@code{set}コマンドは、
プログラムの変数名と衝突する可能性のあるサブコマンドを多く持っているので、
ただの@code{set}コマンドではなく、
@code{set variable}コマンドを使用する方が良いでしょう。
例えば、
プログラムの中に@code{g}という名前の変数がある場合に、
単に@samp{set g=4}として新しい値をセットしようとすると、
問題が発生します。
これは、
@value{GDBN}が@code{set gnutarget}というコマンドを持っていて、
その省略形が@code{set g}であるからです。

@example
@group
(@value{GDBP}) whatis g
type = double
(@value{GDBP}) p g
$1 = 1
(@value{GDBP}) set g=4
(gdb) p g
$2 = 1
(@value{GDBP}) r
The program being debugged has been started already.
Start it from the beginning? (y or n) y
Starting program: /home/smith/cc_progs/a.out
"/home/smith/cc_progs/a.out": can't open to read symbols: Invalid bfd target.
(@value{GDBP}) show g
The current BFD target is "=4".
@end group
@end example

@noindent
プログラム変数@code{g}の値は変わらず、
@code{gnutarget}にこっそりと不正な値をセットしてしまいました。
変数@code{g}に値をセットするためには、
以下のようにします。

@example
(@value{GDBP}) set var g=4
@end example
@end ifset

@value{GDBN}は、
代入時の暗黙の型変換をC言語よりも多くサポートしています。
整数値を自由にポインタ型変数に格納できますし、
その逆もできます。
また、
任意の構造体を、
同じサイズの別の構造体、
または、
より小さいサイズの別の構造体に変換することができます。
@comment FIXME: how do structs align/pad in these conversions?
@comment        /doc@cygnus.com 18dec1990

メモリ上の任意の箇所に値を格納するには、
指定されたアドレスにおいて指定された型の値を生成するために、
@samp{@{@dots{}@}}を使用します
（@pxref{Expressions, ,Expressions}）。
例えば@code{@{int@}0x83040}は、
メモリ・アドレス@code{0x83040}を整数値として参照します
（メモリ上における、
ある特定のサイズと表現を示唆しています）。
また、

@example
set @{int@}0x83040 = 4
@end example

@noindent
は、
そのメモリ・アドレスに値4を格納します。

@node Jumping, Signaling, Assignment, Altering
@section 異なるアドレスにおける処理継続

通常、
ユーザ・プログラムを継続実行するには、
@code{continue}コマンドを使用して、
停止した箇所から継続実行させます。
以下のコマンドを使用することで、
ユーザが選択したアドレスにおいて実行を継続させることができます。

@table @code
@kindex jump
@item jump @var{linespec}
@var{linespec}で指定される行において、
実行を再開します。
その行にブレイクポイントが設定されている場合には、
実行は再びすぐに停止します。
@var{linespec}の形式については、
@xref{List, ,Printing source lines}。
一般的な慣例として、
@code{jump}コマンドは、
@code{tbreak}コマンドと組み合わせて使用されます。
@xref{Set Breaks, ,Setting breakpoints}。

@code{jump}コマンドは、
カレントなスタック・フレーム、
スタック・ポインタ、
メモリ内の任意の箇所の内容、
プログラム・カウンタを除くレジスタの内容を変更しません。
@var{linespec}で指定される行が、
現在実行されている関数とは異なる関数の中にある場合、
それら2つの関数が異なるパターンの引数やローカル変数を期待していると、
奇妙な結果が発生するかもしれません。
このため、
指定された行が、
現在実行されている関数の中にない場合、
@code{jump}コマンドは実行の確認を求めてきます。
しかし、
ユーザがプログラムのマシン言語によるコードを熟知していたとしても、
奇妙な結果の発生することが予想されます。

@item jump *@var{address}
@var{address}で指定されるアドレスにある命令から、
実行を再開します。
@end table

@ifclear HPPA
@c Doesn't work on HP-UX; have to set $pcoqh and $pcoqt.
レジスタ@code{$pc}に新しい値を設定することで、
@code{jump}コマンドとほとんど同等の効果を実現することができます。
両者の違いは、
レジスタ@code{$pc}に値を設定しただけでは、
ユーザ・プログラムの実行は再開されないという点にあります。
ユーザが実行を@emph{継続するとき}に、
プログラムが実行を再開するアドレスが変更されるだけです。
例えば、

@example
set $pc = 0x485
@end example

@noindent
を実行すると、
次に@code{continue}コマンドやステップ実行を行うコマンドが実行されるとき、
ユーザ・プログラムが停止したアドレスにある命令ではなく、
アドレス@code{0x485}にある命令から実行されることになります。
@xref{Continuing and Stepping, ,Continuing and stepping}。
@end ifclear

@code{jump}コマンドが最も一般的に使用されるのは、
既に実行されたプログラム部分を、
さらに多くのブレイクポイントを設定した状態で再実行する場合でしょう。
これにより、
実行される処理の内容をさらに詳しく調べることができます。

@ifclear BARETARGET
@c @group
@node Signaling, Returning, Jumping, Altering
@section ユーザ・プログラムへのシグナルの通知

@table @code
@kindex signal
@item signal @var{signal}
実行を停止した箇所からユーザ・プログラムを再開させますが、
すぐに@var{signal}で指定されるシグナルを通知します。
@var{signal}には、
シグナルの名前または番号を指定できます。
例えば、
多くのシステムにおいて、
@code{signal 2}と@code{signal SIGINT}はどちらも、
割り込みシグナルを通知する方法です。

一方、
@var{signal}が0であれば、
シグナルを通知することなく実行を継続します。
ユーザ・プログラムがシグナルのために停止し、
通常であれば、
@code{continue}コマンドによって実行を再開するとそのシグナルを検知してしまうような場合に便利です。
@w{@samp{signal 0}}を実行すると、
プログラムはシグナルを受信することなく実行を再開します。

@code{signal}を実行した後、
@key{RET}キーを押しても、
繰り返し実行は行われません。
@end table
@c @end group

@code{signal}コマンドを実行することは、
シェルから@code{kill}ユーティリティを実行するのと同じではありません。
@code{kill}によってシグナルを送ると、
@value{GDBN}はシグナル処理テーブルによって何をするべきかを決定します
（@pxref{Signals}）。
一方、
@code{signal}コマンドは、
ユーザ・プログラムに直接シグナルを渡します。

@end ifclear

@node Returning, Calling, Signaling, Altering
@section 関数からの復帰

@table @code
@cindex returning from a function
@cindex 復帰、関数からの[ふっき、かんすうからの]
@cindex 返る、関数から[かえる、かんすうから]
@cindex 戻る、関数から[もどる、かんすうから]
@cindex リターン
@kindex return
@item return
@itemx return @var{expression}
@code{return}コマンドによって、
呼び出されている関数の実行をキャンセルすることができます。
式@var{expression}を引数に指定すると、
その値が関数の戻り値として使用されます。
@end table

@code{return}を実行すると、
@value{GDBN}は選択されているスタック・フレーム
（および、
その下位にあるすべてのフレーム）
を破棄します。
破棄されたフレームは、
実行を完結する前に復帰したのだと考えればよいでしょう。
戻り値を指定したいのであれば、
その値を@code{return}への引数として渡してください。

このコマンドは、
選択されているスタック・フレーム
（@pxref{Selection, ,Selecting a frame}）、
および、
その下位にあるすべてのフレームをポップして、
もともと選択されていたフレームを呼び出したフレームを、
最下位のフレームにします。
つまり、
そのフレームが選択されることになります。
指定された値は、
関数から戻り値を返すのに使用されるレジスタに格納されます。

@code{return}コマンドは実行を再開しません。
関数から復帰した直後の状態で、
プログラムを停止したままにします。
これに対して、
@code{finish}コマンド
（@pxref{Continuing and Stepping, ,Continuing and stepping}）は、
選択されているスタック・フレームが自然に復帰するまで、
実行を再開、
継続します。

@node Calling, Patching, Returning, Altering
@section プログラム関数の呼び出し

@cindex calling functions
@cindex 関数の呼び出し[かんすうのよびだし]
@cindex 呼び出し、関数の[よびだし、かんすうの]
@kindex call
@table @code
@item call @var{expr}
@code{void}型の戻り値を表示することなく、
式@var{expr}を評価します。
@end table

ユーザ・プログラムの中からある関数を呼び出したいが、
void型の戻り値を出力させたくない場合、
この@code{print}コマンドの変種を使用することができます。
@code{void}型でない戻り値は表示され、
値ヒストリに保存されます。

@ifclear HPPA
A29Kでは、
ユーザに制御される変数@code{call_scratch_address}によって、
GDBがデバッグ対象の関数を呼び出すときに使用するスクラッチ領域が指定されます。
通常はスクラッチ領域をスタック上に置きますが、
この方法は命令空間とデータ空間を別々に持つシステム上では機能しないため、
これが必要になります。
@end ifclear

@node Patching,  , Calling, Altering
@section プログラムへのパッチ適用
@cindex patching binaries
@cindex writing into executables
@cindex バイナリのパッチ
@cindex パッチ、バイナリの
@cindex 実行コードへの書き込み[じっこうコードへのかきこみ]
@cindex 書き込み、実行コードへの[かきこみ、じっこうコードへの]
@ifclear BARETARGET
@cindex writing into corefiles
@cindex コア・ファイルへの書き込み[コア・ファイルへのかきこみ]
@cindex 書き込み、コア・ファイルへの[かきこみ、コア・ファイルへの]
@end ifclear

デフォルトでは、
@value{GDBN}はユーザ・プログラムの実行コードを持つファイル
@ifclear BARETARGET
（あるいは、
コア・ファイル）
@end ifclear
を書き込み不可の状態でオープンします。
これにより、
マシン・コードを誤って変更してしまうことを防ぐことができます。
しかし、
ユーザ・プログラムのバイナリに意図的にパッチを適用することもできなくなってしまいます。

バイナリにパッチを適用したいのであれば、
@code{set write}コマンドによって明示的にそのことを指定することができます。
例えば、
内部的なデバッグ・フラグを立てたり、
緊急の修正を行いたいということがあるでしょう。

@table @code
@kindex set write
@item set write on
@itemx set write off
@samp{set write on}を指定すると、
@value{GDBN}は実行ファイル
@ifclear BARETARGET
やコア・ファイル
@end ifclear
を、
読み込み、
書き込みともに可能な状態でオープンします。
@samp{set write off}
（デフォルト）
を指定すると、
@value{GDBN}はこれらのファイルを読み込みしかできない状態でオープンします。

既にファイルをロード済みの場合、
@code{set write}の設定を変更後、
その変更を反映させるためには、
（@code{exec-file}コマンド
@ifclear BARETARGET
、
@code{core-file}コマンド
@end ifclear
を使用して）、
そのファイルを再ロードしなければなりません。

@item show write
@kindex show write
実行ファイル
@ifclear BARETARGET
、コア・ファイル
@end ifclear
が、
読み込みだけではなく書き込みもできる状態でオープンされる設定になっているか否かを表示します。
@end table

@node GDB Files, Targets, Altering, Top
@chapter @value{GDBN}ファイル

@value{GDBN}はデバッグ対象となるプログラムのファイル名を知っている必要があります。
これは、
プログラムのシンボル・テーブルを読み込むためでもあり、
また、
プログラムを起動するためでもあります。
@ifclear BARETARGET
過去に生成されたコア・ダンプをデバッグするには、
@value{GDBN}にコア・ダンプ・ファイルの名前を教えてやらなければなりません。
@end ifclear

@menu
* Files::                       ファイルを指定するコマンド
* Symbol Errors::               シンボル・ファイル読み込み時のエラー
@end menu

@node Files, Symbol Errors, GDB Files, GDB Files
@section ファイルを指定するコマンド
@cindex symbol table
@cindex シンボル・テーブル

@ifclear BARETARGET
@cindex core dump file
@cindex コア・ダンプ・ファイル
実行ファイルやコア・ダンプ・ファイルの名前を指定したい場合があります。
これは通常、
@value{GDBN}の起動コマンドへの引数を利用して、
起動時に行います
（@pxref{Invocation, , Getting In and Out of @value{GDBN}}）。
@end ifclear
@ifset BARETARGET
実行ファイルの名前を指定するには通常、
@value{GDBN}の起動時のコマンド引数を利用して行います
（@pxref{Invocation, , Getting In and Out of @value{GDBN}}）。
@end ifset

ときには、
@value{GDBN}のセッション中に、
異なるファイルに切り替える必要がでてくることがあります。
あるいは、
@value{GDBN}を起動するときに、
使いたいファイルの名前を指定するのを忘れたということもあるかもしれません。
このような場合に、
新しいファイルを指定する@value{GDBN}コマンドが便利です。

@table @code
@cindex executable file
@cindex 実行ファイル[じっこうファイル]
@kindex file
@item file @var{filename}
@var{filename}で指定されるプログラムをデバッグ対象にします。
そのプログラムは、
シンボル情報とメモリ内容を獲得するために読み込まれます。
また、
ユーザが@code{run}コマンドを使用したときに実行されます。
ユーザがディレクトリを指定せず、
そのファイルが@value{GDBN}の作業ディレクトリに見つからない場合、
シェルが実行すべきファイルを探すときと同様、
@value{GDBN}は、
ファイルを探すべきディレクトリのリストとして環境変数@code{PATH}の値を使用します。
@code{path}コマンドによって、
@value{GDBN}、
ユーザ・プログラムの両方について、
この変数の値を変更することができます。

@ifclear HPPA
ファイルをメモリにマップすることのできるシステムでは、
補助的なファイル@file{@var{filename}.syms}に、
ファイル@var{filename}のシンボル・テーブル情報が格納されることがあります。
このような場合、
@value{GDBN}は、
@file{@var{filename}.syms}というファイルからシンボル・テーブルをメモリ上にマップすることで、
起動に要する時間を短くします。
詳細については、
（以下に説明する@code{file}コマンド、
@code{symbol-file}コマンド、
@code{add-symbol-file}コマンドを実行する際にコマンドライン上で使用可能な）
ファイル・オプションの@samp{-mapped}、
@samp{-readnow}の説明を参照してください。
@end ifclear

@item file
@code{file}コマンドを引数なしで実行すると、
@value{GDBN}は実行ファイル、
シンボル・テーブルに関して保持している情報をすべて破棄します。

@kindex exec-file
@item exec-file @r{[} @var{filename} @r{]}
実行するプログラムが@var{filename}で指定されるファイル内に存在する
（ただし、
シンボル・テーブルはそこには存在しない）
ということを指定します。
@value{GDBN}は、
必要であれば、
ユーザ・プログラムの存在場所を見つけるために、
環境変数@code{PATH}を使用します。
@var{filename}を指定しないと、
実行ファイルに関して保持している情報を破棄するよう指示したことになります。

@kindex symbol-file
@item symbol-file @r{[} @var{filename} @r{]}
@var{filename}で指定されるファイルからシンボル・テーブル情報を読み込みます。
必要な場合には@code{PATH}が検索されます。
同一のファイルから、
シンボル・テーブルと実行プログラムの両方を獲得する場合には、
@code{file}コマンドを使用してください。

@code{symbol-file}を引数なしで実行すると、
@value{GDBN}がユーザ・プログラムのシンボル・テーブルに関して持っている情報は消去されます。

@code{symbol-file}コマンドが実行されると、
それまで@value{GDBN}が保持していたコンビニエンス変数、
値ヒストリ、
すべてのブレイクポイント、
自動表示式は破棄されます。
その理由は、
これらの情報の中に、
@value{GDBN}が破棄した古いシンボル・テーブルのデータの一部である、
シンボルやデータ型を記録する内部データへのポインタが含まれているかもしれないからです。

@code{symbol-file}を一度実行した後に@key{RET}キーを押しても、
@code{symbol-file}の実行は繰り返されません。

@value{GDBN}は、
特定の環境用に構成されると、
その環境において生成される標準フォーマットのデバッグ情報を理解するようになります。
@sc{gnu}コンパイラを使うこともできますし、
ローカルな環境の規約に従う他のコンパイラを使用することもできます。
@ifclear HPPA
通常は、
@sc{gnu}コンパイラを使用しているときに最高の結果を引き出すことができます。
例えば@code{@value{GCC}}を使用すると、
最適化されたコードに対してデバッグ情報を生成することができます。
@end ifclear

COFFを使用する古いSVR3システムを除外すれば、
ほとんどの種類のオブジェクト・ファイルでは、
@code{symbol-file}コマンドを実行しても、
通常は、
ただちにシンボル・テーブルの全体が読み込まれるわけではありません。
実際に存在するソース・ファイルとシンボルを知るために、
シンボル・テーブルを素早く調べるだけです。
詳細な情報は、
後にそれが必要になったときに、
一度に1ソース・ファイルずつ読み込まれます。

2段階に分けて読み込むという手法は、
@value{GDBN}の起動時間の短縮を目的としています。
ほとんどの場合、
このような手法が採用されているということに気付くことはありません。
せいぜい、
特定のソース・ファイルに関するシンボル・テーブルの詳細が読み込まれている間、
たまに停止するくらいです
（もしそうしたいのであれば、
@code{set verbose}コマンドを使うことによって、
このようにして停止しているときにはメッセージを表示させることもできます。
@xref{Messages/Warnings, ,Optional warnings and messages}）。

@ifclear HPPA
COFFについては、
まだこの2段階方式を実装していません。
シンボル・テーブルが
COFFフォーマットで格納されている場合、
@code{symbol-file}コマンドはシンボル・テーブル・データの全体をただちに読み込みます。
COFFのstabs拡張フォーマット（stabs-in-COFF）では、
デバッグ情報が実際にはstabsフォーマットの内部に存在するため、
2段階方式が実装されていることに注意してください。

@kindex readnow
@cindex reading symbols immediately
@cindex symbols, reading immediately
@cindex 読み込み、シンボルの即時[よみこみ、シンボルのそくじ]
@cindex シンボルの即時読み込み[シンボルのそくじよみこみ]
@kindex mapped
@cindex memory-mapped symbol file
@cindex saving symbol table
@cindex メモリにマップされたシンボル・ファイル
@cindex シンボル・ファイル、メモリにマップされた
@cindex 保存、シンボル・テーブルの[ほぞん、シンボル・テーブルの]
@item symbol-file @var{filename} @r{[} -readnow @r{]} @r{[} -mapped @r{]}
@itemx file @var{filename} @r{[} -readnow @r{]} @r{[} -mapped @r{]}
@value{GDBN}が確実にシンボル・テーブル全体を保持しているようにしたいのであれば、
シンボル・テーブル情報を読み込む任意のコマンド実行時に
@samp{-readnow}オプションを使用することで、
2段階によるシンボル・テーブル読み込み方式を使わないようにさせることができます。
@end ifclear

@ifclear BARETARGET
@ifclear HPPA
@code{mmap}システム・コールによるファイルのメモリへのマッピングがシステム上において有効な場合、
もう1つのオプション
@samp{-mapped}を使って、
@value{GDBN}に対して、
再利用可能なファイルの中にユーザ・プログラムのシンボルを書き込ませることができます。
後の@value{GDBN}デバッグ・セッションは、
（プログラムに変更がない場合）
実行プログラムからシンボル・テーブルを読み込むのに時間を費やすことなく、
この補助シンボル・ファイルからシンボル情報をマップします。
@samp{-mapped}オプションを使用することは、
コマンドライン・オプション@samp{-mapped}を指定して@value{GDBN}を起動するのと同じ効果を持ちます。

補助シンボル・ファイルがユーザ・プログラムのシンボル情報をすべて確実に持つように、
両方のオプションを同時に指定することもできます。

@var{myprog}という名前のプログラムの補助シンボル・ファイルは、
@samp{@var{myprog}.syms}という名前になります。
このファイルが存在すると、
（それが、
対応する実行ファイルよりも新しい限り）
ユーザが@var{myprog}をデバッグしようとすると、
@value{GDBN}は常にそのファイルを使おうとします。
特別なオプションやコマンドは必要ありません。

@file{.syms}ファイルは、
@value{GDBN}を実行したホスト・マシンに固有のものです。
それは、
@value{GDBN}内部におけるシンボル・テーブルの正確なイメージを保持しています。
複数のホスト・プラットフォーム間で共用することはできません。
@end ifclear

@c FIXME: for now no mention of directories, since this seems to be in
@c flux.  13mar1992 status is that in theory GDB would look either in
@c current dir or in same dir as myprog; but issues like competing
@c GDB's, or clutter in system dirs, mean that in practice right now
@c only current dir is used.  FFish says maybe a special GDB hierarchy
@c (eg rooted in val of env var GDBSYMS) could exist for mappable symbol
@c files.

@kindex core
@kindex core-file
@item core-file @r{[} @var{filename} @r{]}
「メモリ上のイメージ」として使用されるコア・ダンプ・ファイルの存在場所を指定します。
伝統的に、
コア・ファイルは、
それを生成したプロセスのアドレス空間の一部だけを保持しています。
@value{GDBN}は、
実行ファイルそのものにアクセスすることによって、
保持されていない部分を獲得することができます。

@code{core-file}を引数なしで実行すると、
コア・ファイルを一切使用しないことを指定したことになります。

ユーザ・プログラムが実際に@value{GDBN}の管理下で実行中の場合は、
コア・ファイルは無視されることに注意してください。
したがって、
ある時点までユーザ・プログラムを実行させた後に、
コア・ファイルをデバッグしたくなったような場合、
プログラムを実行しているサブ・プロセスを終了させなければなりません。
サブ・プロセスの終了は、
@code{kill}コマンドで行います
（@pxref{Kill Process, ,Killing the child process}）。
@end ifclear

@ifclear BARETARGET
@ifclear HPPA
@kindex add-symbol-file
@cindex dynamic linking
@cindex 動的リンク[どうてきリンク]
@cindex ダイナミック・リンク
@item add-symbol-file @var{filename} @var{address}
@itemx add-symbol-file @var{filename} @var{address} @r{[} -readnow @r{]} @r{[} -mapped @r{]}
@code{add-symbol-file}コマンドは、
@var{filename}で指定されるファイルから追加的なシンボル・テーブル情報を読み込みます。
@var{filename}で指定されるファイルが
（何か別の方法によって）
実行中のプログラムの中に動的にロードされた場合に、
このコマンドを使用します。
@var{address}は、
ファイルがロードされたメモリ・アドレスでなければなりません。
@value{GDBN}は独力でこのアドレスを知ることはできません。
@var{address}は式として指定することもできます。

@var{filename}で指定されるファイルのシンボル・テーブルは、
もともと@code{symbol-file}コマンドによって読み込まれたシンボル・テーブルに追加されます。
@code{add-symbol-file}コマンドは何回でも使用することができます。
新たに読み込まれたシンボル・テーブルのデータは、
古いデータに追加されていきます。
古いシンボル・データをすべて破棄するには、
@code{symbol-file}コマンドを使用してください。

@code{add-symbol-file}コマンドを実行した後に@key{RET}キーを押しても、
@code{add-symbol-file}コマンドは繰り返し実行されません。

@code{symbol-file}コマンドと同様、
@samp{-mapped}オプションと@samp{-readnow}オプション使用して、
@var{filename}で指定されるファイルのシンボル・テーブル情報を@value{GDBN}がどのように管理するかを変更することができます。

@kindex add-shared-symbol-file
@item add-shared-symbol-file
@code{add-shared-symbol-file}コマンドは、
Motorola 88k用のHarris' CXUXオペレーティング・システム上でのみ使用することができます。
@value{GDBN}は自動的に共有ライブラリを探しますが、
@value{GDBN}がユーザの共有ライブラリを見つけてくれない場合には、
@code{add-shared-symbol-file}コマンドを実行できます。
このコマンドは引数を取りません。
@end ifclear
@end ifclear

@ifclear HPPA
@kindex section
@item section
@c {{このへんの記述は全体的におかしい。}}
@c {{SECTIONとADDRが未記述の引数の値を表わしているのだとすると、}}
@c {{@var{section}と@var{addr}とすべき。}}
@c {{とりあえず、SECTION -> @var{section}、ADDR -> @var{addr}に変更 }}
@code{section}コマンドは、
実行ファイルの@var{section}セクションのベース・アドレスを@var{addr}に変更します。
これは、
（a.outフォーマットのように）
実行ファイルがセクション・アドレスを保持していない場合や、
ファイルの中で指定されているアドレスが誤っている場合に使うことができます。
個々のセクションは、
個別に変更されなければなりません。
@c {{ここも。}}
@samp{info files}コマンドによって、
すべてのセクションとそのアドレスを一覧表示することができます。
@end ifclear

@kindex info files
@kindex info target
@item info files
@itemx info target
@code{info files}と@code{info target}は同義です。
両方とも、
カレント・ターゲット
（@pxref{Targets, ,Specifying a Debugging Target}）
に関する情報を表示します。
表示される情報には、
@value{GDBN}が現在使用中の
@ifclear BARETARGET
実行ファイルやコア・ダンプ・ファイル
@end ifclear
@ifset BARETARGET
実行ファイル
@end ifset
の名前、
シンボルがそこからロードされたファイルの名前を含みます。
@code{help target}コマンドは、
カレントなターゲットではなく、
すべての可能なターゲットを一覧表示します。
@end table

ファイルを指定するすべてのコマンドは、
引数として、
絶対パスによるファイル名と相対パスによるファイル名のどちらでも受け付けます。
@value{GDBN}は、
常にファイル名を絶対パス名に変換して、
絶対パスの形で記憶します。

@ifclear BARETARGET
@cindex shared libraries
@cindex 共有ライブラリ[きょうゆうライブラリ]
@ifclear HPPA
@c added HP-UX -- Kim (HP writer)
@value{GDBN}は、
HP-UX、
SunOS、
SVr4、
Irix 5、
IBM RS/6000の共有ライブラリをサポートします。
@end ifclear
@ifset HPPA
@value{GDBN}は、
HP-UXの共有ライブラリをサポートします。
@end ifset
ユーザが@code{run}コマンドを実行したり、
コア・ファイルを調べようとすると、
@value{GDBN}は自動的に共有ライブラリからシンボル定義をロードします
（ユーザが@code{run}コマンドを発行するまでは、
共有ライブラリ内部の関数への参照があっても、
@value{GDBN}にはそれを理解することができません。
コア・ファイルをデバッグしている場合は、
この限りではありません）。
@ifset HPPA
プログラムがライブラリを明示的にロードする場合は、
@code{shl_load}の呼び出しの時点において、
@value{GDBN}が自動的にシンボルをロードします。
@end ifset
@c FIXME: some @value{GDBN} release may permit some refs to undef
@c FIXME...symbols---eg in a break cmd---assuming they are from a shared
@c FIXME...lib; check this from time to time when updating manual

@table @code
@kindex info sharedlibrary
@kindex info share
@item info share
@itemx info sharedlibrary
現在ロードされている共有ライブラリの名前を表示します。

@kindex sharedlibrary
@kindex share
@item sharedlibrary @var{regex}
@itemx share @var{regex}

UNIXの正規表現にマッチするファイルに対応する、
共有オブジェクト・ライブラリのシンボルをロードします。
自動的にロードされるファイルと同様、
ユーザ・プログラムによってコア・ファイルのために必要とされる共有ライブラリ、
または
@code{run}コマンド実行時に必要とされる共有ライブラリだけがロードされます。
@var{regex}が省略されると、
ユーザ・プログラムによって必要とされるすべての共有ライブラリがロードされます。
@end table

@ifset HPPA
@value{GDBN}は、
共用ライブラリのローディングを検出し、
新しくロードされたライブラリから自動的にシンボルを読み込みます。
この読み込みは、
ある上限まで行われます。
この上限の値は、
最初にセットされますが、
そうしたければ変更することも可能です。

上限を超えた共用ライブラリのシンボルは、
明示的にロードされなければなりません。
これらのシンボルをロードするには、
@code{sharedlibrary} @var{filename}コマンドを使用します。
共用ライブラリのベース・アドレスは@value{GDBN}によって自動的に決定されるので、
指定する必要はありません。

上限を表示、
または、
セットするには、
以下のコマンドを使用します。

@table @code
@kindex set auto-solib-add
@item set auto-solib-add @var{threshold}
自動ロードするサイズの上限を、
メガバイト単位でセットします。
@c {{the inferiorの訳は「優先度の低いスレッド」で良いか？}}
@var{threshold}の値がゼロ以外であれば、
すべての共用オブジェクト・ライブラリのシンボルは、
優先度の低いスレッドが実行を開始したとき、
または、
ダイナミック・リンカが、
新しいライブラリがロードされたことを@value{GDBN}に通知したときに、
そのプログラムとライブラリのシンボル・テーブルのサイズがこの上限を超えるまで、
自動的にロードされます。
@var{threshold}の値がゼロであれば、
シンボルは、
@code{sharedlibrary}コマンドを使用して、
手作業でロードしなければなりません。
デフォルトの上限は、
100メガバイトです。

@kindex show auto-solib-add
@item show auto-solib-add
現在の自動ロードのサイズの上限を、
メガバイト単位で表示します。
@end table
@end ifset

@end ifclear

@node Symbol Errors,  , Files, GDB Files
@section シンボル・ファイル読み込み時のエラー

シンボル・ファイルの読み込み中に、
@value{GDBN}はときどき問題にぶつかることがあります。
例えば、
認識できないシンボル・タイプを見つけたり、
コンパイラの出力に既知の問題を発見することがあります。
デフォルトでは、
このようなエラーがあったことを、
@value{GDBN}はユーザに知らせません。
なぜなら、
このようなエラーは比較的よく見られるものであり、
コンパイラのデバッグをしているような人々だけが関心を持つようなものだからです。
もし、
正しく構築されていないシンボル・テーブルに関する情報を見ることに関心があれば、
@code{set complaints}コマンドを使用することで、
何回問題が発生しようと個々のタイプの問題について1回だけメッセージを出力するよう指示することができますし、
また、
何回問題発生したかを見るためにより多くのメッセージを表示するよう指示することもできます
（@pxref{Messages/Warnings, ,Optional warnings and messages}）。

現在のバージョンで表示されるメッセージとその意味を以下に記します。

@table @code
@item inner block not inside outer block in @var{symbol}

シンボル情報は、
シンボルのスコープの先頭と末尾の位置を示します
（例えば、
ある関数の先頭、
あるいは、
ブロックの先頭など）。
このエラーは、
内側のスコープのブロックが、
外側のスコープのブロックに完全に包含されていないことを意味しています。

@value{GDBN}は、
内側のブロックが外側のブロックと同一のスコープを持つものとして扱うことで、
この問題を回避します。
外側のブロックが関数でない場合には、エラー・メッセージの
@var{symbol}の部分が@samp{@code{(don't know)}}のように表示されることがあります。

@item block at @var{address} out of order

シンボルのスコープとなるブロックに関する情報は、
アドレスの低い方から昇順に並んでいなければなりません。
このエラーは、
そうなっていないということを示しています。

@value{GDBN}はこの問題を回避することはせず、
読み込もうとしているソース・ファイルのシンボルを見つけるのに支障が出ます
（@code{set verbose on}を指定することで、
どのソース・ファイルが関係しているかを知ることができます。
@xref{Messages/Warnings, ,Optional warnings and messages}）。

@item bad block start address patched

シンボルのスコープとなるブロックに関する情報の中の開始アドレスが、
1つ前のソース行のアドレスより小さい値です。
これは、
SunOS 4.1.1
（および、
それ以前のバージョン）
のCコンパイラで発生することが分かっています。

@value{GDBN}は、
シンボルのスコープとなるブロックが1つ前のソース行から始まるものとして扱うことによって、
この問題を回避します。

@item bad string table offset in symbol @var{n}

@cindex foo
シンボル番号@var{n}のシンボルが持っている文字列テーブルへのポインタが、
文字列テーブルのサイズを超える値です。

@value{GDBN}は、
このシンボルが@code{foo}という名前を持つものとみなすことによって、
この問題を回避します。
この結果、
多くのシンボルが@code{foo}という名前を持つことになってしまうと、
他の問題が発生する可能性があります。

@item unknown symbol type @code{0x@var{nn}}

シンボル情報の中に、
どのようにして読み取ればよいのか@value{GDBN}には分からないような、
新しいデータ型が含まれています。
@code{0x@var{nn}}は理解できなかったシンボルの型を16進数で表わしたものです。

@value{GDBN}は、
このようなシンボル情報を無視することによって、
このエラーを回避します。
通常、
プログラムのデバッグを行うことは可能になりますが、
ある特定のシンボルにアクセスすることができなくなります。
このような問題にぶつかり、
それをデバッグしたいのであれば、
@code{@value{GDBP}}自身を使って@code{@value{GDBP}}をデバッグすることができます。
この場合、
シンボル@code{complain}にブレイクポイントを設定し、
関数@code{read_dbx_symtab}まで実行してから、
@code{*bufp}によってシンボルを参照します。

@item stub type has NULL name
@value{GDBN}は、
ある構造体
@ifclear CONLY
またはクラス
@end ifclear
に関する完全な定義を見つけることができませんでした。

@ifclear CONLY
@item const/volatile indicator missing (ok if using g++ v1.x), got@dots{}

あるC++のメンバ関数に関するシンボル情報に、
より新しいコンパイラを使用した場合には生成されるいくつかの情報が欠けています。
@end ifclear

@item info mismatch between compiler and debugger

@value{GDBN}は、
コンパイラが生成した型の指定を解析できませんでした。
@end table

@node Targets, Controlling GDB, GDB Files, Top
@chapter デバッグ・ターゲットの指定
@cindex debugging target
@cindex デバッグ・ターゲット
@kindex target

@dfn{ターゲット}とは、
ユーザ・プログラムが持つ実行環境を指します。
@ifclear HPPA
@ifclear BARETARGET
多くの場合、
@value{GDBN}はユーザ・プログラムと同一のホスト環境上で実行されます。
この場合には、
@code{file}コマンドや@code{core}コマンドを実行すると、
その副作用としてデバッグ・ターゲットが指定されます。
例えば、
物理的に離れた位置にあるホスト・マシン上で@value{GDBN}を実行したい場合や、
シリアル・ポート経由でスタンドアロン・システムを制御したい場合、
または、
TCP/IP接続を利用してリアルタイム・システムを制御したい場合などのように、
より多くの柔軟性が必要とされる場合、
@end ifclear
@end ifclear
@ifset HPPA
HP-UXシステム上では、
@value{GDBN}は、
PA-RISCアーキテクチャ上で実行されているプロセスのデバッグをサポートするよう、
コンフィギュレーションが行われています。
このことは、
ターゲットとしては、
以下のものだけが可能であるということを意味しています。

@itemize @bullet
@item
HP-UX上で実行するようコンパイル、
リンクされた実行可能プログラム

@item
@value{GDBN}
（の@code{run}コマンド）
によって開始された、
または、
@value{GDBN}以外から開始され
（@code{attach}コマンドによって）
アタッチされた、
実行中のHP-UXプロセス

@item
以前の実行時にアボートした
HP-UXプロセスによって生成されたコア・ファイル
@end itemize

HP-UX上の@value{GDBN}には、
リモート・デバッグや、
他のプラットフォーム上で実行されるプログラムをサポートするような
コンフィギュレーションは行われていません。
@end ifset
@ifset BARETARGET
@c {{ここの You は陽に訳さない}}
@end ifset
@code{target}コマンドを使うことによって、
@value{GDBN}に設定されたターゲットの種類の中から1つを指定することができます
（@pxref{Target Commands, ,Commands for managing targets}）。

@menu
* Active Targets::              アクティブ・ターゲット
* Target Commands::             ターゲットを管理するコマンド
@ifset REMOTESTUB
* Byte Order::                  ターゲットのバイト・オーダの選択
* Remote::                      リモート・デバッグ
@end ifset

@end menu

@node Active Targets, Target Commands, Targets, Targets
@section アクティブ・ターゲット
@cindex stacking targets
@cindex active targets
@cindex multiple targets
@cindex 併用、ターゲットの[へいよう、ターゲットの]
@cindex アクティブ・ターゲット
@cindex 多重ターゲット[たじゅうターゲット]

@ifclear BARETARGET
ターゲットには3つのクラスがあります。
プロセス、コア・ファイル、
そして、
実行ファイルです。
@value{GDBN}は同時に、
1クラスにつき1つ、
全体で最高で3つまでアクティブなターゲットを持つことができます。
これにより、
（例えば）
コア・ファイルに対して行ったデバッグ作業を破棄することなく、
プロセスを起動してその動作を調べることができます。

例えば、
@samp{gdb a.out}を実行すると、
実行ファイル@code{a.out}が唯一のアクティブなターゲットになります。
コア・ファイル
（おそらくは、
前回実行したときにクラッシュしてコア・ダンプしたもの）
を併せて指定すると、
@value{GDBN}は2つのターゲットを持ち、
メモリ・アドレスを知る必要がある場合には、
それを知るために2つのターゲットを並行して使用します。
この場合、
まずコア・ファイルを参照し、
次に実行ファイルを参照します。
（典型的には、
これら2つのクラスのターゲットは相互に補完的です。
というのも、
コア・ファイルには、
プログラムが持っている変数などの読み書き可能なメモリ域の内容とマシン・ステータスだけがあり、
実行ファイルには、
プログラムのテキストと初期化されたデータだけがあるからです）。
@end ifclear

@code{run}コマンドを実行すると、
ユーザの実行ファイルはアクティブなプロセス・ターゲットにもなります。
プロセス・ターゲットがアクティブな間は、
メモリ・アドレスを要求するすべての@value{GDBN}コマンドは、
プロセス・ターゲットを参照します。
@ifclear BARETARGET
アクティブなコア・ファイル・ターゲットや
@end ifclear
実行ファイル・ターゲットの中のアドレスは、
プロセス・ターゲットがアクティブな間は、
隠された状態になります。

@ifset BARETARGET
新しい実行ファイル・ターゲットを選択するには、
@code{exec-file}コマンドを使用します
（@pxref{Files, ,Commands to specify files}）。
@end ifset
@ifclear BARETARGET
新しいコア・ファイル・ターゲットや実行ファイル・ターゲットを選択するには、
@code{core-file}コマンドや@code{exec-file}コマンドを使用します
（@pxref{Files, ,Commands to specify files}）。
既に実行中のプロセスをターゲットとして指定するには、
@code{attach}コマンドを使用します
（@pxref{Attach, ,Debugging an already-running process}）。
@end ifclear

@node Target Commands, Byte Order, Active Targets, Targets
@section ターゲットを管理するコマンド

@table @code
@item target @var{type} @var{parameters}
@value{GDBN}のホスト環境をターゲット・マシン
@ifset BARETARGET
に接続します。
@end ifset
@ifclear BARETARGET
またはターゲット・プロセスに接続します。
ターゲットとは、
典型的には、
デバッグ機能と通信するためのプロトコルを指します。
引数@var{type}によって、
ターゲット・マシンの種類またはプロトコルを指定します。

@var{parameters}はターゲット・プロトコルによって解釈されるものですが、
典型的には、
接続すべきデバイス名やホスト名、
プロセス番号、
ボーレートなどが含まれます。
@end ifclear

@code{target}コマンドを実行した後に@key{RET}キーを押しても、
@code{target}コマンドは再実行されません。

@kindex help target
@item help target
利用可能なすべてのターゲットの名前を表示します。
現在選択されているターゲットを表示させるには、
@code{info target}コマンドまたは@code{info files}コマンドを使用します
（@pxref{Files, ,Commands to specify files}）。

@item help target @var{name}
ある特定のターゲットに関する説明を表示します。
選択時に必要となるパラメータも表示されます。

@kindex set gnutarget
@item set gnutarget @var{args}
@value{GDBN}は、
自分で持っているライブラリBFDを使用してユーザ・ファイルを読み込みます。
@value{GDBN}は、
@dfn{実行ファイル}、
@dfn{コア・ファイル}、
@dfn{.oファイル}のどれを自分が読み込んでいるのかを知っています。
しかし、
@code{set gnutarget}コマンドを使用して、
ファイルのフォーマットを指定することもできます。
ほとんどの@code{target}コマンドとは異なり、
@code{gnutarget}における@code{target}は、
マシンではなくプログラムです。

@emph{注意:}
@code{set gnutarget}でファイル・フォーマットを指定するには、
実際のBFD名を知っている必要があります。

@noindent
@xref{Files, , Commands to specify files}。

@kindex show gnutarget  
@item show gnutarget
@code{gnutarget}がどのようなファイル・フォーマットを読むよう設定されているかを表示させるには、
@code{show gnutarget}コマンドを使用します。
@code{gnutarget}を設定していない場合、
個々のファイルのフォーマットを@value{GDBN}が自動的に決定します。
この場合、
@code{show gnutarget}を実行すると
@samp{The current BDF target is "auto"}
と表示されます。
@end table

@ifclear HPPA
以下に、
一般的なターゲットをいくつか示します
（GDBの構成によって、
利用可能であったり利用不可であったりします）。
@end ifclear
@ifset HPPA
HP-UXシステム上において有効なターゲットは、
以下のとおりです。
@end ifset

@table @code
@kindex target exec
@item target exec @var{program}
実行ファイルです。
@samp{target exec @var{program}}は@samp{exec-file @var{program}}と同じです。

@ifclear BARETARGET
@kindex target core
@item target core @var{filename}
コア・ダンプ・ファイルです。
@samp{target core @var{filename}}は@samp{core-file @var{filename}}と同じです。
@end ifclear

@kindex target remote
@item target remote @var{dev}
@value{GDBN}固有のプロトコルによる、
リモートのシリアル・ターゲットです。
引数@var{dev}によって、
接続を確立するために使用するシリアル装置
（例えば、
@file{/dev/ttya}）
を指定します。
@xref{Remote, ,Remote debugging}。
@code{target remote}は、
@code{load}コマンドもサポートするようになりました。
これは、
スタブをターゲット・システム上に持っていく方法が別にあり、
かつ、
ダウンロードが実行されたときに破壊されないようなメモリ域にそれを置くことができる場合にのみ役に立ちます。

@ifclear HPPA
@kindex target sim
@item target sim
CPUシミュレータです。
@xref{Simulator,,Simulated CPU Target}。
@end ifclear
@end table

以下のターゲットはすべて、
特定のCPUに固有のものであり、
特定の構成においてのみ利用可能です。
@c should organize by CPU

@table @code

@kindex target abug
@item target abug @var{dev}
M68K用のABug ROMモニタです。

@kindex target adapt
@item target adapt @var{dev}
A29K用のAdaptモニタです。

@kindex target amd-eb
@item target amd-eb @var{dev} @var{speed} @var{PROG}
@cindex AMD EB29K
シリアル回線により接続されている、
リモートのPCに組み込まれたAMD EB29Kボードです。
@code{target remote}の場合と同様、
@var{dev}はシリアル装置です。
@var{speed}によって回線速度を指定することができます。
@var{PROG}は、
デバッグ対象となるプログラムをPC上のDOSから見た場合の名前です。
@xref{EB29K Remote, ,The EBMON protocol for AMD29K}。

@kindex target array
@item target array @var{dev}
Array Tech LSI33K RAIDコントローラ・ボードです。

@kindex target bug
@item target bug @var{dev}
MVME187（m88k）ボード上で動作するBUGモニタです。

@kindex target cpu32bug
@item target cpu32bug @var{dev}
CPU32（M68K）ボード上で動作するCPU32BUGモニタです。

@kindex target dbug
@item target dbug @var{dev}
Motorola ColdFire用のdBUG ROMモニタです。

@kindex target ddb
@item target ddb @var{dev}
Mips Vr4300用のNEC DDBモニタです。

@kindex target dink32
@item target dink32 @var{dev}
PowerPC用のDINK32 ROMモニタです。

@kindex target e7000
@item target e7000 @var{dev}
日立H8、
SH用のE7000エミュレータです。

@kindex target es1800
@item target es1800 @var{dev}
M68K用のES-1800エミュレータです。

@kindex target est
@item target est @var{dev}
CPU32（M68K）ボード上で動作するEST-300 ICEモニタです。

@kindex target hms
@item target hms @var{dev}
ユーザのホストにシリアル回線で接続された日立のSH、
H8/300、
H8/500ボードです。
@ifclear H8EXCLUSIVE
特別なコマンドである@code{device}と@code{speed}によって、
使用されるシリアル回線と通信速度を制御します。
@xref{Hitachi Remote,,@value{GDBN} and Hitachi Microprocessors}。

@kindex target lsi
@item target lsi @var{dev}
Mips用のLSI ROMモニタです。

@kindex target m32r
@item target m32r @var{dev}
三菱M32R/D ROMモニタです。

@kindex target mips
@item target mips @var{dev}
Mips用のIDT/SIM ROMモニタです。

@kindex target mon960
@item target mon960 @var{dev}
Intel i960用のMON960モニタです。

@kindex target nindy
@item target nindy @var{devicename}
Nindy Monitorにより制御されるIntel 960ボードです。
@var{devicename}は、接続に使用するシリアル装置の名前です。
例えば@file{/dev/ttya}です。
@xref{i960-Nindy Remote, ,@value{GDBN} with a remote i960 (Nindy)}。

@kindex target nrom
@item target nrom @var{dev}
NetROM ROMエミュレータです。
このターゲットは、
ダウンロードのみサポートしています。

@kindex target op50n
@item target op50n @var{dev}
OKI HPPAボード上で動作するOP50Nモニタです。

@kindex target pmon
@item target pmon @var{dev}
Mips用のPMON ROMモニタです。

@kindex target ppcbug
@item target ppcbug @var{dev}
@kindex target ppcbug1
@item target ppcbug1 @var{dev}
PowerPC用のPPCBUG ROMモニタです。

@kindex target r3900
@item target r3900 @var{dev}
東芝R3900 Mips用のDensan DVE-R3900 ROMモニタです。

@kindex target rdi
@item target rdi @var{dev}
RDIライブラリ・インターフェイスを経由したARM Angelモニタです。
 
@kindex target rdp
@item target rdp @var{dev}
ARM Demonモニタです。

@kindex target rom68k
@item target rom68k @var{dev}
M68K IDPボード上で動作するROM 68Kモニタです。

@kindex target rombug
@item target rombug @var{dev}
OS/9000用のROMBUG ROMモニタです。

@kindex target sds
@item target sds @var{dev}
（MotorolaのADSなどの）
PowerPCボード上で動作するSDSモニタです。

@kindex target sparclite
@item target sparclite @var{dev}
ロードするためだけの目的で使用される、
富士通のsparcliteボードです。
プログラムをデバッグするためには、
さらに別のコマンドを使用しなければなりません。
一例を挙げると、
@value{GDBN}の標準的なリモート・プロトコルを使用する
target remote @var{dev}です。

@kindex target sh3
@kindex target sh3e
@item target sh3 @var{dev}
@item target sh3e @var{dev}
日立SH-3、
SH-3Eターゲット・システムです。

@kindex target st2000
@item target st2000 @var{dev} @var{speed}
Tandem STDBUGプロトコルを実行しているTandem ST2000電話交換機です。
@var{dev}は、
ST2000のシリアル回線に接続されている装置の名前です。
@var{speed}は通信回線の速度です。
@value{GDBN}がST2000にTCPまたはTelnetで接続するよう構成されている場合、
引数は使用されません。
@xref{ST2000 Remote,,@value{GDBN} with a Tandem ST2000}。

@kindex target udi
@item target udi @var{keyword}
AMD UDIプロトコルを使用するRemote AMD29Kターゲットです。
引数@var{keyword}が、
使用する29Kボードまたはシミュレータを指定します。
@xref{UDI29K Remote,,The UDI protocol for AMD29K}。

@kindex target vxworks
@item target vxworks @var{machinename}
TCP/IPで接続されたVxWorksシステムです。
引数@var{machinename}は、
ターゲット・システムのマシン名またはIPアドレスです。
@xref{VxWorks Remote, ,@value{GDBN} and VxWorks}。

@kindex target w89k
@item target w89k @var{dev}
Winbond HPPAボード上で動作するW89Kモニタです。

@end ifclear
@end table

@ifset GENERIC
@value{GDBN}の構成によって、
利用可能なターゲットも異なるものになります。
構成次第で、
ターゲットの数は多くなったり少なくなったりします。
@end ifset

多くのリモート・ターゲットでは、
接続に成功すると、
実行プログラムのコードをダウンロードすることが必要となります。

@table @code

@kindex load @var{filename}
@item load @var{filename}
@ifset GENERIC
構成によって@value{GDBN}に組み込まれたリモート・デバッグ機能によっては、
@code{load}コマンドが使用可能になります。
これが利用可能な場合、
実行ファイル@var{filename}が
（例えば、
ダウンロードやダイナミック・リンクによって）
リモート・システム上でデバッグできるようになることを意味します。
また、
@code{load}コマンドは@code{add-symbol-file}コマンドと同様、
ファイル@var{filename}のシンボル・テーブルを@value{GDBN}内に記録します。

@value{GDBN}が@code{load}コマンドを提供していない場合、
それを実行しようとすると
「@code{You can't do that when your target is @dots{}}」
というエラー・メッセージが表示されます。
@end ifset

実行ファイルの中で指定されたアドレスに、
ファイルはロードされます。
オブジェクト・ファイルのフォーマットによっては、
プログラムをリンクするときに、
ファイルをロードするアドレスを指定できるものもあります。
これ以外のフォーマット
（例えば、
a.out）
では、
オブジェクト・ファイルのフォーマットによって固定的にアドレスが指定されます。
@c FIXME! This would be a good place for an xref to the GNU linker doc.

@ifset VXWORKS
VxWorksで@code{load}コマンドを実行すると、
@var{filename}で指定される実行ファイルがカレントなターゲット・システム上で動的にリンクされ、
シンボルが@value{GDBN}に追加されます。
@end ifset

@ifset I960
@cindex download to Nindy-960
@cindex Nindy-960へのダウンロード
@cindex ダウンロード、Nindy-960への
Intel 960ボードのNindyインターフェイスでは、
@code{load}コマンドは@var{filename}で指定されるファイルを960側にダウンロードし、
そのシンボルを@value{GDBN}に追加します。
@end ifset

@ifset H8
@cindex download to H8/300 or H8/500
@cindex H8/300 or H8/500 download
@cindex download to Hitachi SH
@cindex Hitachi SH download
@cindex H8/300やH8/500へのダウンロード
@cindex ダウンロード、H8/300やH8/500への
@cindex 日立SHへのダウンロード[ひたちSHへのダウンロード]
@cindex ダウンロード、日立SHへの[ダウンロード、ひたちSHへの]
日立のSH、
H8/300、
H8/500ボード
（@pxref{Hitachi Remote,,@value{GDBN} and Hitachi Microprocessors}）
に対するリモート・デバッグを選択すると、
@code{load}コマンドはユーザ・プログラムを日立ボードにダウンロードし、
（@code{file}コマンドと同様）
ユーザのホスト・マシン上の@value{GDBN}のカレントなターゲット実行ファイルとしてオープンします。
@end ifset

@code{load}コマンドを実行した後に@key{RET}キーを押しても、
@code{load}コマンドは繰り返し実行されません。
@end table

@ifset REMOTESTUB
@node Byte Order, Remote, Target Commands, Targets
@section ターゲットのバイト・オーダの選択
@cindex choosing target byte order
@cindex target byte order
@cindex ターゲットのバイト・オーダの選択[ターゲットのバイト・オーダのせんたく]
@cindex 選択、ターゲットのバイト・オーダの[せんたく、ターゲットのバイト・オーダの]
@cindex バイト・オーダの選択、ターゲットの[バイト・オーダのせんたく、ターゲットの]
@kindex set endian big
@kindex set endian little
@kindex set endian auto
@kindex show endian

MIPS、
PowerPC、
Hitachi SHなどのプロセッサは、
ビッグ・エンディアン、
リトル・エンディアンのどちらのバイト・オーダでも実行することができます。
通常は、
実行ファイルまたはシンボルの中に、
エンディアン種別を指定するビットがあるので、
どちらを使用するかを気にする必要はありません。
しかし、
GDBの認識しているプロセッサのエンディアン種別を手作業で調整することができれば、
便利なこともあるでしょう。

@table @code
@kindex set endian big
@item set endian big
@value{GDBN}に対して、
ターゲットはビッグ・エンディアンであると想定するよう指示します。

@kindex set endian little
@item set endian little
@value{GDBN}に対して、
ターゲットはリトル・エンディアンであると想定するよう指示します。

@kindex set endian auto
@item set endian auto
@value{GDBN}に対して、
実行ファイルに関連付けされているバイト・オーダを使用するよう指示します。

@item show endian
@value{GDBN}が認識している、
ターゲットの現在のバイト・オーダ種別を表示します。

@end table

これらのコマンドは、
ホスト上でのシンボリック・データの解釈を調整するだけであり、
ターゲット・システムに対しては全く何の影響も持たないということに注意してください。

@node Remote,  , Byte Order, Targets
@section リモート・デバッグ
@cindex remote debugging
@cindex リモート・デバッグ
@cindex 遠隔デバッグ[えんかくデバッグ]

通常の方法で@value{GDBN}を実行させることのできないマシン上で実行中のプログラムをデバッグするには、
リモート・デバッグ機能を使うのが便利です。
例えば、
オペレーティング・システムのカーネルのデバッグや、
フル機能を持つデバッガを実行するのに十分な機能を持つ汎用的なオペレーティング・システムを持たない小規模なシステムでのデバッグでは、
ユーザはリモート・デバッグ機能を使うことになるかもしれません。

@value{GDBN}は、
その構成によっては、
特別なシリアル・インターフェイスやTCP/IPインターフェイスを持ち、
これを特定のデバッグ・ターゲット用に使用することができます。
さらに、
@value{GDBN}には汎用的なシリアル・プロトコルが組み込まれており
（@value{GDBN}固有のもので、
特定のターゲット・システムに固有なものではありません）、
リモート・スタブを作成すれば、
これを使用することができます。
リモート・スタブとは、
@value{GDBN}と通信するためにリモート・システム上で動作するコードです。

@value{GDBN}の構成によっては、
他のリモート・ターゲットが利用可能な場合もあります。
利用可能なリモート・ターゲットを一覧表示させるには、
@code{help target}コマンドを使用します。
@end ifset

@ifset GENERIC
@c Text on starting up GDB in various specific cases; it goes up front
@c in manuals configured for any of those particular situations, here
@c otherwise.
@menu
@ifset REMOTESTUB
* Remote Serial::               @value{GDBN}リモート・シリアル・プロトコル
@end ifset
@ifset I960
* i960-Nindy Remote::		@value{GDBN}とリモートi960（Nindy）
@end ifset
@ifset AMD29K
* UDI29K Remote::               AMD29K用のUDIプロトコル
* EB29K Remote::		AMD29K用のEBMONプロトコル
@end ifset
@ifset VXWORKS
* VxWorks Remote::		@value{GDBN}とVxWorks
@end ifset
@ifset ST2000
* ST2000 Remote::               @value{GDBN}とTandem ST2000
@end ifset
@ifset H8
* Hitachi Remote::              @value{GDBN}と日立のマイクロ・プロセッサ
@end ifset
@ifset MIPS
* MIPS Remote::			@value{GDBN}とMIPSボード
@end ifset
@ifset SPARCLET
* Sparclet Remote::             @value{GDBN}とSparcletボード
@end ifset
@ifset SIMS
* Simulator::                   シミュレートされたCPUターゲット
@end ifset
@end menu

@include remote-ja.texi
@end ifset

@node Controlling GDB
@chapter @value{GDBN}の制御

@code{set}コマンドによって@value{GDBN}の操作方法を変更することができます。
@value{GDBN}によるデータの表示方法を変更するコマンドについては、
@pxref{Print Settings, ,Print settings}。
この章では、
その他の設定について説明します。

@menu
* Prompt::                      プロンプト
* Editing::                     コマンド編集
* History::                     コマンド・ヒストリ
* Screen Size::                 画面サイズ
* Numbers::                     数値
* Messages/Warnings::           オプションの警告およびメッセージ
@end menu

@node Prompt, Editing, Controlling GDB, Controlling GDB
@section プロンプト

@cindex prompt
@cindex プロンプト

@value{GDBN}は、
@dfn{プロンプト}と呼ばれる文字列を表示することで、
コマンドを受け付ける用意ができたことを示します。
通常、
この文字列は@samp{(@value{GDBP})}です。
@code{set prompt}コマンドによって、
プロンプトの文字列を変更することができます。
例えば、
@value{GDBN}を使って@value{GDBN}自体をデバッグしているときには、
どちらか一方の@value{GDBN}セッションのプロンプトを変更して、
どちらの@value{GDBN}とやりとりしているのか区別できるようにすると便利です。

@emph{注:} 以前のバージョンとは異なり、
現在の@code{set prompt}は、
ユーザが設定したプロンプトの後ろに空白を追加しません。
ユーザは、
空白で終わるプロンプト、
空白で終わらないプロンプトのいずれでも設定することができます。

@table @code
@kindex set prompt
@item set prompt @var{newprompt}
今後は@var{newprompt}をプロンプトとして使用するよう、
@value{GDBN}に指示します

@kindex show prompt
@item show prompt
@samp{Gdb's prompt is: @var{your-prompt}} という形式の1行を表示します
@end table

@node Editing, History, Prompt, Controlling GDB
@section コマンド編集
@cindex readline
@cindex command line editing
@cindex コマンド編集[コマンドへんしゅう]

@value{GDBN}は入力コマンドを@dfn{readline}インターフェイスによって読み込みます。
この@sc{gnu}ライブラリを使うことで、
ユーザに対してコマンドライン・インターフェイスを提供するプログラムは、
統一された振る舞いをするようになります。
これを使うことの利点としては、
@sc{gnu} Emacsスタイルまたは@dfn{vi}スタイルによるコマンドのインライン編集、
@code{csh}スタイルのヒストリ代替、
複数のデバッグ・セッションにまたがるコマンド・ヒストリの保存と呼び出しができるようになることが挙げられます。

@code{set}コマンドによって、
@value{GDBN}におけるコマンドライン編集の振る舞いを制御することができます。

@table @code
@kindex set editing
@cindex editing
@cindex 編集[へんしゅう]
@item set editing
@itemx set editing on
コマンドライン編集を使用可能にします
（コマンドライン編集は、
デフォルトの状態で使用可能です）。

@item set editing off
コマンドライン編集を使用不可にします。

@kindex show editing
@item show editing
コマンドライン編集が使用可能かどうかを示します。
@end table

@node History, Screen Size, Editing, Controlling GDB
@section コマンド・ヒストリ

デバッグ・セッション中にユーザが入力したコマンドを@value{GDBN}に記録させることができるため、
ユーザは実際に何が実行されたかを確実に知ることができます。
以下のコマンドを使って、
@value{GDBN}のコマンド・ヒストリ機能を管理します。

@table @code
@cindex history substitution
@cindex history file
@cindex ヒストリ置換[ヒストリちかん]
@cindex ヒストリ・ファイル
@kindex set history filename
@kindex GDBHISTFILE
@item set history filename @var{fname}
@value{GDBN}コマンド・ヒストリ・ファイルの名前を@var{fname}に設定します。
@value{GDBN}は、
最初にこのファイルからコマンド・ヒストリ・リストの初期値を読み込み、
終了時には、
このファイルにセッション中のコマンド・ヒストリを書き込みます。
コマンド・ヒストリ・リストには、
ヒストリ展開機能、
あるいは、
後に列挙するヒストリ・コマンド編集文字によってアクセスすることができます。
このファイル名は、
デフォルトでは環境変数@code{GDBHISTFILE}の値になりますが、
この変数が設定されていない場合には@file{./.gdb_history}になります。

@cindex history save
@cindex ヒストリの記録[ヒストリのきろく]
@kindex set history save
@item set history save
@itemx set history save on
コマンド・ヒストリをファイルの中に記録します。
ファイルの名前は@code{set history filename}コマンドで指定可能です。
デフォルトでは、
このオプションは使用不可の状態になっています。

@item set history save off
コマンド・ヒストリをファイルの中に記録するのを停止します。

@cindex history size
@cindex ヒストリの大きさ[ヒストリのおおきさ]
@kindex set history size
@item set history size @var{size}
@value{GDBN}がヒストリ・リストの中に記録するコマンドの数を設定します。
デフォルトでは、
この値は環境変数@code{HISTSIZE}の値に設定されますが、
この変数が設定されていない場合は256になります。
@end table

@cindex history expansion
@cindex ヒストリ展開[ヒストリてんかい]
ヒストリ展開機能により、
文字@kbd{!}には特別な意味が割り当てられます。
@ifset have-readline-appendices
@xref{Event Designators}。
@end ifset

@kbd{!}は、
C言語における論理@sc{not}の演算子でもあるので、
ヒストリ展開機能はデフォルトではoffになっています。
@code{set history expansion on}コマンドによってヒストリ展開を利用できるようにした場合には、
（@kbd{!}を式の中で論理@sc{not}として使うのであれば）
@kbd{!}の後ろに空白かタブを入れることによって、
それが展開されないようにする必要のある場合があります。
ヒストリ展開が有効になっている場合でも、
readlineのヒストリ機能は、
@kbd{!=}や@kbd{!(}という文字列を置き換えようとはしません。

ヒストリ展開を制御するコマンドには、
以下のようなものがあります。

@table @code
@kindex set history expansion
@item set history expansion on
@itemx set history expansion
ヒストリ展開を使用可能にします。
ヒストリ展開はデフォルトでは使用不可です。

@item set history expansion off
ヒストリ展開を使用不可にします。

readlineのコードには、
ヒストリ編集機能やヒストリ展開機能に関する、
より完全なドキュメントが付属しています。
@sc{gnu} Emacsや@code{vi}のことをよく知らない人は、
このドキュメントを読むとよいでしょう。
@ifset have-readline-appendices
@xref{Command Line Editing}。
@end ifset

@c @group
@kindex show history
@item show history
@itemx show history filename
@itemx show history save
@itemx show history size
@itemx show history expansion
これらのコマンドは、
@value{GDBN}のヒストリ・パラメータの状態を表示します。
単に@code{show history}を実行すると、
4つのパラメータの状態がすべて表示されます。
@c @end group
@end table

@table @code
@kindex show commands
@item show commands
コマンド・ヒストリ中の最後の10個のコマンドを表示します。

@item show commands @var{n}
コマンド番号@var{n}のコマンドを中心に、
その前後の10個のコマンドを表示します。

@item show commands +
最後に表示されたコマンドに続く10個のコマンドを表示します。
@end table

@node Screen Size, Numbers, History, Controlling GDB
@section 画面サイズ
@cindex size of screen
@cindex pauses in output
@cindex 画面サイズ[がめんサイズ]
@cindex サイズ、画面[サイズ、がめん]
@cindex 一時停止、出力の[いちじていし、しゅつりょくの]
@cindex 停止、出力の[ていし、しゅつりょくの]

@value{GDBN}のコマンドは、
大量の情報を画面上に出力することがあります。
大量の情報をすべて読むのを支援するために、
@value{GDBN}は1ページ分の情報を出力するたびに、
出力を停止してユーザからの入力を求めます。
出力を継続したい場合は
@key{RET}キーを押し、
残りの出力を破棄したい場合は@kbd{q}を入力します。
また、
画面幅の設定によって、
どこで行を折り返すかが決まります。
@value{GDBN}は、
単純に次の行に折り返すのではなく、
出力の内容に応じて読みやすいところで折り返すよう試みます。

通常@value{GDBN}は、
termcapデータベースと@code{TERM}環境変数の値、
さらに、
@code{stty rows}、
@code{stty cols}の設定から、
画面の大きさを知っています。
この結果が正しくない場合、
@c {{...で優先させることが...}}
@code{set height}コマンドと@code{set width}コマンドで画面の大きさの設定を変更することができます。

@table @code
@kindex set height
@kindex set width
@kindex show width
@kindex show height
@item set height @var{lpp}
@itemx show height
@itemx set width @var{cpl}
@itemx show width
これらの@code{set}コマンドは、
画面の高さを@var{lpp}行に、
幅を@var{cpl}桁に指定します。
@c {{対応...}}
関連する@code{show}コマンドが、
現在の設定を表示します。

ゼロ行の高さを指定すると、
@value{GDBN}は出力がどんなに長くても、
出力途中で一時停止することをしません。
これは、
出力先がファイルやエディタのバッファである場合に便利です。

同様に、
@samp{set width 0}を指定することによって、
@value{GDBN}に行の折り返しを行わせないようにすることもできます。
@end table

@node Numbers, Messages/Warnings, Screen Size, Controlling GDB
@section 数値
@cindex number representation
@cindex entering numbers
@cindex 数値表現[すうちひょうげん]
@cindex 入力、数値の[にゅうりょく、すうちの]

@value{GDBN}に対して8進、
10進、
16進の数値を慣例にしたがって入力することはいつでも可能です。
8進数は@samp{0}で始まります。
10進数は@samp{.}で終わります。
16進数は@samp{0x}で始まります。
このどれにも該当しないものは、
デフォルトで10進数として入力されます。
同様に、
数値を表示するときも、
特定のフォーマットが指定されていなければ、
デフォルトで10進数として表示されます。
@code{set radix}コマンドによって、
入力、
出力の両方のデフォルトを変更することができます。

@table @code
@kindex set input-radix
@item set input-radix @var{base}
数値入力のデフォルトの基数を設定します。
サポートされる選択肢は10進数の8、
10、
16です。
@var{base}自身はあいまいにならないように指定するか、
あるいは、
現在のデフォルトの基数を使用して指定します。
例えば、

@smallexample
set radix 012
set radix 10.
set radix 0xa
@end smallexample

@noindent
は基数を10進数に設定します。
一方、
@samp{set radix 10}は、
現在の基数を
（それがどれであれ）
変更しません。

@kindex set output-radix
@item set output-radix @var{base}
数値の表示に使うデフォルトの基数を設定します。
サポートされる@var{base}の選択肢は
10進数の8、
10、
16です。
@var{base}自身はあいまいにならないように指定するか、
あるいは、
現在のデフォルトの基数を使用して指定します。

@kindex show input-radix
@item show input-radix
数値の入力に現在使われているデフォルトの基数を表示します。

@kindex show output-radix
@item show output-radix
数値の表示に現在使われているデフォルトの基数を表示します。
@end table

@node Messages/Warnings,  , Numbers, Controlling GDB
@section オプションの警告およびメッセージ

デフォルトでは、
@value{GDBN}は内部の動作に関する情報を表示しません。
性能の遅いマシンで実行している場合には、
@code{set verbose}コマンドを使うとよいでしょう。
これによって、
@value{GDBN}は、
長い内部処理を実行するときにメッセージを出力することで、
クラッシュと勘違いされないようにします。

現在のところ、
@code{set verbose}コマンドによって制御されるメッセージは、
ソース・ファイルのシンボル・テーブルを読み込み中であることを知らせるメッセージです。
@ref{Files, ,Commands to specify files}の@code{symbol-file}を参照してください。

@table @code
@kindex set verbose
@item set verbose on
@value{GDBN}が特定の情報メッセージを出力するようにします。

@item set verbose off
@value{GDBN}が特定の情報メッセージを出力しないようにします。

@kindex show verbose
@item show verbose
@code{set verbose}がon、
offのどちらの状態であるかを表示します。
@end table

デフォルトでは、
オブジェクト・ファイルのシンボル・テーブルに問題を検出しても、
@value{GDBN}はメッセージを出力しません。
しかし、
コンパイラをデバッグしているようなときには、
このような情報があると便利かもしれません
（@pxref{Symbol Errors, ,Errors reading symbol files}）。

@table @code
@kindex set complaints
@item set complaints @var{limit}
異常な型のシンボルを検出するたびに@value{GDBN}が出力するメッセージの総数を@var{limit}個とします。
@var{limit}個のメッセージを表示すると、
その後は問題を検出してもメッセージを表示しないようになります。
メッセージを1つも出力させないようにするには、
@var{limit}にゼロを指定してください。
メッセージの出力が抑止されないようにするには、
@var{limit}に大きな値を設定してください。

@kindex show complaints
@item show complaints
@value{GDBN}が何個までシンボル異常に関するメッセージを出力できるよう設定されているかを表示します。
@end table

デフォルトでは、
@value{GDBN}は慎重に動作し、
コマンドを本当に実行するのか確認するために、
ときには馬鹿げているとさえ思えるような質問を多く尋ねてきます。
例えば、
既に実行中のプログラムを実行しようとすると、
次のように質問してきます。

@example
(@value{GDBP}) run
The program being debugged has been started already.
Start it from the beginning? (y or n)
@end example

ユーザが、
実行したコマンドの結果を何がなんでも見てみたいのであれば、
この「機能」を抑止することができます。

@table @code
@kindex set confirm
@cindex flinching
@cindex confirmation
@cindex stupid questions
@cindex 慎重な動作[しんちょうなどうさ]
@cindex 確認[かくにん]
@cindex 馬鹿げた質問[ばかげたしつもん]
@item set confirm off
確認要求を行わないようにします。

@item set confirm on
確認要求を行うようにします
（デフォルト）。

@kindex show confirm
@item show confirm
確認要求の現在の設定を表示します。
@end table

@node Sequences, Emacs, Controlling GDB, Top
@chapter 一連のコマンドのグループ化

ブレイクポイント・コマンド
（@pxref{Break Commands, ,Breakpoint command lists}）
とは別に、
一連のコマンドを一括して実行するために保存する2つの方法を、
@value{GDBN}は提供しています。
ユーザ定義コマンドとコマンド・ファイルがそれです。

@menu
* Define::                      ユーザ定義コマンド
* Hooks::                       ユーザ定義コマンド・フック
* Command Files::               コマンド・ファイル
* Output::                      制御された出力を得るためのコマンド
@end menu

@node Define, Hooks, Sequences, Sequences
@section ユーザ定義コマンド

@cindex user-defined command
@cindex ユーザ定義コマンド[ユーザていぎコマンド]
@dfn{ユーザ定義コマンド}とは、
一連の@value{GDBN}コマンドに単一コマンドとしての名前を新たに割り当てたものです。
これは、
@code{define}コマンドによって行われます。
ユーザ・コマンドは、
空白で区切られた引数を最高で10個まで受け取ることができます。
@c {{原文では、@var{$arg0@dots{}$arg9} }}
引数は、
ユーザ・コマンドの中で、
@var{$arg0}@dots{}@var{$arg9}としてアクセスすることができます。
簡単な例を以下に示します。

@smallexample
define adder
  print $arg0 + $arg1 + $arg2
@end smallexample

@noindent
このコマンドを実行するには、以下のようにします。

@smallexample
adder 1 2 3
@end smallexample

@noindent
上の例では、
@code{adder}というコマンドを定義しています。
このコマンドは、
3つの引数の合計を表示します。
引数は文字列で代用されますので、
変数を参照することもできますし、
複雑な式を使うこともできます。
また、
下位関数の呼び出しを行うこともできます。

@table @code
@kindex define
@item define @var{commandname}
@var{commandname}という名前のコマンドを定義します。
同じ名前のコマンドが既に存在する場合は、
再定義の確認を求められます。

コマンドの定義は、
@code{define}コマンドに続いて与えられる、
他の@value{GDBN}コマンド行から構成されます。
これらのコマンドの末尾は、
@code{end}を含む行によって示されます。

@kindex if
@kindex else
@item if
引数として、
評価の対象となる式を1つだけ取ります。
その後に一連のコマンドが続きますが、
これらのコマンドは、
式の評価結果が真
（ゼロ以外の値）
である場合にだけ実行されます。
さらに、
@code{else}行が続くことがあり、
この場合は、
@code{else}行の後に、
式の評価結果が偽であった場合にだけ実行される一連のコマンドが続きます。
末尾は、
@code{end}を含む行によって示されます。

@kindex while
@item while
構文は@code{if}と似ています。
引数として、
評価の対象となる式を1つだけ取ります。
その後には、
実行されるべきコマンドが1行に1つずつ続き、
最後に@code{end}がなければなりません。
コマンドは、
式の評価結果が真である限り、
繰り返し実行されます。

@kindex document
@item document @var{commandname}
ユーザ定義コマンド@var{commandname}のドキュメントを記述します。
このドキュメントは@code{help}コマンドによってアクセスできます。
コマンド@var{commandname}は既に定義済みでなければなりません。
このコマンドは、
@code{define}コマンドが一連のコマンド定義を読み込むのと同様に、
@code{end}で終わる一連のドキュメントを読み込みます。
@code{document}コマンドの実行が完了すると、
コマンド@var{commandname}に対して@code{help}コマンドを実行すると、
ユーザの記述したドキュメントが表示されます。

@code{document}コマンドを再度実行することによって、
コマンドのドキュメントを変更することができます。
@code{define}コマンドによってコマンドを再定義しても、
ドキュメントは変更されません。

@kindex help user-defined
@item help user-defined
すべてのユーザ定義コマンドを一覧表示します。
個々のコマンドにドキュメントがあれば、
その1行目が表示されます。

@kindex show user
@item show user
@itemx show user @var{commandname}
@var{commandname}で指定されるコマンドを定義するのに使われた@value{GDBN}コマンドを表示します
（ドキュメントは表示されません）。
@var{commandname}を指定しないと、
すべてのユーザ定義コマンドの定義が表示されます。
@end table

ユーザ定義コマンドが実行されるときに、
定義内のコマンドは表示されません。
定義内のコマンドがどれか1つでもエラーになると、
ユーザ定義コマンドの実行が停止されます。

対話的に使われている場合には確認を求めてくるようなコマンドも、
ユーザ定義コマンドの内部で使われている場合には確認を求めることなく処理を継続します。
通常は実行中の処理に関してメッセージを表示する@value{GDBN}コマンドの多くが、
ユーザ定義コマンドの中から呼び出されている場合にはメッセージを表示しません。

@node Hooks, Command Files, Define, Sequences
@section ユーザ定義コマンド・フック
@c {{原文の索引項目 ``command files'' は恐らく間違い}}
@c {{ <bug-gdb@prep.ai.mit.edu> 宛にメール必要}}
@cindex command hooks
@cindex コマンド・フック

特別な種類のユーザ定義コマンドである、
@emph{フック}を定義することができます。
@samp{hook-foo}というユーザ定義コマンドが存在すると、
@samp{foo}というコマンドを実行するときにはいつも、
@samp{foo}コマンドが実行される前に
（引数のない）
@samp{hook-foo}が実行されます。

また、
仮想コマンドである@samp{stop}が存在します。
（@samp{hook-stop}を）
定義すると、
ユーザ・プログラムの実行が停止するたびに、
その定義内のコマンドが実行されます。
実行タイミングは、
ブレイクポイント・コマンドの実行、
自動表示対象の表示、
および、
スタック・フレームの表示の直前です。

@ifclear BARETARGET
例えば、
シングル・ステップ実行をしている際には@code{SIGALRM}シグナルを無視し、
通常の実行時には通常どおり処理したい場合には、
以下のように定義します。

@example
define hook-stop
handle SIGALRM nopass
end

define hook-run
handle SIGALRM pass
end

define hook-continue
handle SIGLARM pass
end
@end example
@end ifclear

@value{GDBN}のコマンドのうち、
その名前が1つの単語から成るものには、
フックを定義することができます。
ただし、
コマンド・エイリアスにフックを定義することはできません。
フックは、
コマンドの基本名に対して定義しなければなりません。
例えば、
@code{bt}ではなく@code{backtrace}を使います。
@c FIXME!  So how does Joe User discover whether a command is an alias
@c or not?
フックの実行中にエラーが発生すると、
@value{GDBN}コマンドは停止します。
（ユーザが実際に入力したコマンドが実行する機会を与えられる前に）
@value{GDBN}はプロンプトを表示します。

既知のコマンドのいずれにも対応しないフックを定義しようとすると、
@code{define}コマンドは警告メッセージを表示します。

@node Command Files, Output, Hooks, Sequences
@section コマンド・ファイル

@cindex command files
@cindex コマンド・ファイル
@value{GDBN}のコマンド・ファイルとは、
各行が@value{GDBN}コマンドとなっているファイルのことです。
（行の先頭が@kbd{#}の）
コメントも含めることができます。
コマンド・ファイル内の空行は何も実行しません。
それは、
端末上での実行の場合とは異なり、
最後に実行されたコマンドの繰り返しを意味しません。

@cindex init file
@cindex @file{.gdbinit}
@cindex 初期化ファイル[しょきかファイル]
@value{GDBN}を起動すると、
自動的に@dfn{初期化ファイル}からコマンドを読み込んで実行します。
これは、
Unix上では@file{.gdbinit}という名前のファイルであり、
DOS/Windows上では@file{gdb.ini}という名前のファイルです。
@value{GDBN}は、
ユーザのホーム・ディレクトリに初期化ファイルがあればまずそれを読み込み、
続いてコマンンドライン・オプションとオペランドを処理した後、
カレントな作業ディレクトリに初期化ファイルがあればそれを読み込みます。
このように動くのは、
ユーザのホーム・ディレクトリに初期化ファイルを置くことで、
コマンドライン上のオプションやオペランドの処理に影響を与える
（@code{set complaints}のような）
オプションを設定することができるようにするためです。
@samp{-nx}オプションを使用すると、
初期化ファイルは実行されません。
@pxref{Mode Options, ,Choosing modes}。

@ifset GENERIC
@cindex init file name
@cindex 初期化ファイル名[しょきかファイルめい]
@value{GDBN}のいくつかの構成では、
初期化ファイルは異なる名前で知られています
（このような環境では、
特別な形式の@value{GDBN}が他の形式の@value{GDBN}と共存する必要があり、
そのために特別なバージョンの@value{GDBN}の初期化ファイルには異なる名前が付けられます）。
特別な名前の初期化ファイルを持つ環境には、
以下のようなものがあります。

@kindex .vxgdbinit
@itemize @bullet
@item
VxWorks（Wind River Systems社のリアルタイムOS）: @samp{.vxgdbinit}

@kindex .os68gdbinit
@item
OS68K（Enea Data Systems社のリアルタイムOS）: @samp{.os68gdbinit}

@kindex .esgdbinit
@item
ES-1800（Ericsson Telecom社のAB M68000エミュレータ）: @samp{.esgdbinit}
@end itemize
@end ifset

また、
@code{source}コマンドによって、
コマンド・ファイルの実行を要求することもできます。

@table @code
@kindex source
@item source @var{filename}
コマンド・ファイル@var{filename}を実行します。
@end table

コマンド・ファイルの各行は順番に実行されます。
コマンドの実行時に、
そのコマンドは表示されません。
どれか1つでもコマンドがエラーになると、
コマンド・ファイルの実行は停止されます。

対話的に使われている場合には確認を求めてくるようなコマンドも、
コマンド・ファイル内で使われている場合は確認を求めることなく処理を継続します。
通常は実行中の処理についてメッセージを表示する@value{GDBN}コマンドの多くが、
コマンド・ファイルの中から呼び出されている場合にはメッセージを表示しません。

@node Output,  , Command Files, Sequences
@section 制御された出力を得るためのコマンド

コマンド・ファイルやユーザ定義コマンドの実行中には、
通常の@value{GDBN}の出力は抑止されます。
唯一出力されるのは、
定義内のコマンドが明示的に表示するメッセージだけです。
ここでは、
ユーザが希望するとおりの出力を生成するのに役に立つ、
3つのコマンドについて説明します。

@table @code
@kindex echo
@item echo @var{text}
@c I do not consider backslash-space a standard C escape sequence
@c because it is not in ANSI.
@var{text}を表示します。
通常は表示されない文字も、
Cのエスケープ・シーケンスを使うことで@var{text}の中に含めることができます。
例えば、
改行コードを表示するには@samp{\n}を使います。
@strong{明示的に指定しない限り、
改行コードは表示されません。}
標準的なCのエスケープ・シーケンスに加えて、
バックスラッシュの後ろに空白を置くことで、
空白が表わされます。
これは、
先頭や末尾に空白のある文字列を表示するのに便利です。
というのは、
こうしないと、
引数の先頭や末尾の空白は削除されるからです。
@samp{@w{ }and foo =@w{ }}を表示するには、
@samp{echo \@w{ }and foo = \@w{ }}を実行してください。

Cと同様、
@var{text}の末尾にバックスラッシュを置くことで、
コマンドを次の行以降に継続することができます。
例えば、

@example
echo This is some text\n\
which is continued\n\
onto several lines.\n
@end example

は

@example
echo This is some text\n
echo which is continued\n
echo onto several lines.\n
@end example

と同じ出力をもたらします。

@kindex output
@item output @var{expression}
@var{expression}の値を表示し、
それ以外には何も表示しません。
改行コードも、
@samp{$@var{nn} = }も表示されません。
@var{expression}の値は値ヒストリには入りません。
式の詳細については、
@xref{Expressions, ,Expressions}。

@item output/@var{fmt} @var{expression}
@var{expression}の値を、
@var{fmt}で指定されるフォーマットで表示します。
@code{print}コマンドと同じフォーマットを指定することができます。
詳細については、
@xref{Output Formats,,Output formats}。

@kindex printf
@item printf @var{string}, @var{expressions}@dots{}
@var{string}で指定された文字列にしたがって@var{expressions}の値を表示します。
複数の@var{expressions}はカンマで区切られ、
数値かポインタのいずれかを指定できます。
これらの値は、
ユーザ・プログラムからCのサブルーチン

@example
printf (@var{string}, @var{expressions}@dots{});
@end example

を実行した場合と同様に、
@var{string}の指定にしたがって表示されます。

例えば、
次のようにして2つの値を16進数で表示することができます。

@smallexample
printf "foo, bar-foo = 0x%x, 0x%x\n", foo, bar-foo
@end smallexample

フォーマットを指定する文字列の中で使えるバックスラッシュ・エスケープ・シーケンスは、
バックスラッシュとそれに続く単一文字から構成される簡単なものだけです。
@end table

@ifclear DOSHOST
@node Emacs, GDB Bugs, Sequences, Top
@chapter @sc{gnu} Emacsの中での@value{GDBN}の使用

@cindex Emacs
@cindex @sc{gnu} Emacs
@value{GDBN}でデバッグ中のプログラムのソース・ファイルを@sc{gnu} Emacsを使って参照（および編集）するための、
特別なインターフェイスが提供されています。

このインターフェイスを使うには、
Emacsの中で@kbd{M-x gdb}コマンドを使います。
デバッグしたい実行ファイルを引数として指定してください。
このコマンドは、
@value{GDBN}をEmacsのサブプロセスとして起動し、
新しく作成したEmacsバッファを通じて入出力を行います。
@ifset HPPA
（Emacsから@value{GDBN}を実行する場合には、
@code{-tui}オプションを使用しないでください。）
@end ifset

Emacsの中での@value{GDBN}の使い方は、
通常の@value{GDBN}の使い方とほぼ同様ですが、
2つ相違点があります。

@itemize @bullet
@item
「端末」へのすべての入出力はEmacsバッファへ送られる。
@end itemize

これは、
@value{GDBN}コマンドとその出力、
および、
デバッグ対象のユーザ・プログラムによる入出力の両方に適用されます。

以前に実行したコマンド・テキストをコピーして再入力することができるので便利です。
出力された部分に関しても同様のことができます。

EmacsのShellモードで利用可能なすべての機能を、
ユーザ・プログラムとのやりとりで使うことができます。
特に、
通常どおりにシグナルを送信することができます。
例えば、
@kbd{C-c C-c}で割り込みシグナルを、
@kbd{C-c C-z}でストップ・シグナルを発生させることができます。

@itemize @bullet
@item
@value{GDBN}はEmacsを使ってソース・コードを表示する。
@end itemize

@value{GDBN}がスタック・フレームを表示するときにはいつでも、
Emacsがそのフレームのソース・ファイルを自動的に見つけて、
カレント行の左側の余白に矢印
（@samp{=>}）
を表示します。
Emacsはソース・コードを別バッファに表示し、
スクリーンを2つに分けて、
@value{GDBN}セッションとソースをともに表示します。

@c {{原文では、ただの search}}
@value{GDBN}の@code{list}コマンドや@code{search}コマンドを明示的に使えば、
通常どおりの出力を生成することもできますが、
これらをEmacsから使う理由はおそらくないでしょう。

@quotation
@emph{注意:} ユーザ・プログラムの存在するディレクトリがユーザのカレント・ディレクトリでない場合、
ソース・ファイルの存在場所についてEmacsは簡単に混乱に陥ります。
このような場合、
ソースを表示するための追加のディスプレイ・バッファは表示されません。
@value{GDBN}は、
ユーザの環境変数@code{PATH}のリストの中にあるディレクトリを探索してプログラムを見つけ出しますので、
@value{GDBN}の入出力セッションは通常どおり進行します。
しかしEmacsは、
このような状況においてソース・ファイルを見つけ出すのに十分な情報を@value{GDBN}から受け取っていません。
この問題を回避するには、
ユーザ・プログラムの存在するディレクトリから@value{GDBN}モードを開始するか、
@kbd{M-x gdb}の引数の入力を求められたときに、
絶対パスでファイル名を指定します。

Emacsの既存の@value{GDBN}バッファから、
デバッグ対象をどこかほかの場所にあるプログラムに変更する目的で@value{GDBN}の@code{file}コマンドを使うと、
同様の混乱の発生することがあります。
@end quotation

デフォルトでは、
@kbd{M-x gdb}は@file{gdb}という名前のプログラムを呼び出します。
別の名前で@value{GDBN}を呼び出す必要がある場合
（例えば、
異なる構成の@value{GDBN}を別の名前で持っているような場合）
は、
Emacsの@code{gdb-command-name}という変数を設定します。
例えば

@example
(setq gdb-command-name "mygdb")
@end example

@noindent
（を@kbd{ESC ESC}に続けて入力するか、
あるいは、
@code{*scratch*}バッファまたは@file{.emacs}ファイルに入力することで）
Emacsは@code{gdb}の代わりに「@code{mygdb}」という名前のプログラムを呼び出します。

@value{GDBN}のI/Oバッファでは、
標準的なShellモードのコマンドに加えて、
以下のような特別なEmacsコマンドを使うことができます。

@table @kbd
@item C-h m
Emacsの@value{GDBN}モードの機能に関する説明を表示します。

@item M-s
@value{GDBN}の@code{step}コマンドのように、
ソース行を1行実行します。
さらに、
カレントなファイルとその中における位置を示すために、
表示ウィンドウを更新します。

@item M-n
@value{GDBN}の@code{next}コマンドのように、
関数呼び出しをすべてスキップして、
現在の関数内の次のソース行まで実行を進めます。
さらに、
カレントなファイルとその中における位置を示すために、
表示ウィンドウを更新します。

@item M-i
@value{GDBN}の@code{stepi}コマンドのように、
1命令を実行します。
必要に応じて表示ウィンドウを更新します。

@item M-x gdb-nexti
@value{GDBN}の@code{nexti}コマンドを使って、
次の命令まで実行します。
必要に応じて表示ウィンドウを更新します。

@item C-c C-f
@value{GDBN}の@code{finish}コマンドのように、
選択されたスタック・フレームを終了するまで実行を継続します。

@item M-c
@value{GDBN}の@code{continue}コマンドのように、
ユーザ・プログラムの実行を継続します。

@emph{注意:} Emacs v19では、
このコマンドは@kbd{C-c C-p}です。

@item M-u
@value{GDBN}の@code{up}コマンドのように、
数値引数によって示される数だけ上位のフレームに移動します
（@pxref{Arguments, , Numeric Arguments, Emacs, The @sc{gnu} Emacs Manual}
@footnote{訳注：@cite{GNU Emacs 19 マニュアル}（星雲社）の「ニューメリック引数」、
@cite{GNU Emacs マニュアル}（共立出版）の「数引数」に、
日本語訳があります。}）。

@emph{注意:} Emacs v19では、
このコマンドは@kbd{C-c C-u}です。

@item M-d
@value{GDBN}の@code{down}コマンドのように、
数値引数によって示される数だけ下位のフレームに移動します。

@emph{注意:} Emacs v19では、
このコマンドは@kbd{C-c C-d}です。

@item C-x &
カーソルの位置にある数値を読み取り、
@value{GDBN}のI/Oバッファの末尾に挿入します。
例えば、
以前に表示されたアドレスの前後のコードを逆アセンブルしたいとしましょう。
この場合、
まず@kbd{disassemble}と入力し、
次に表示されたアドレスのところにカーソルを移動し、
@code{disassemble}への引数を@kbd{C-x &}で読み取ります。

@code{gdb-print-command}リストの要素を定義することによって、
これをさらにカスタマイズすることができます。
これが定義されていると、
@kbd{C-x &}で入手した数値が挿入される前に、
それをフォーマットしたり、
処理したりすることができるようになります。
@kbd{C-x &}に数値引数を指定すると、
特別なフォーマット処理を必要としているという意味になり、
その数値がリストの要素を取得するためのインデックスとなります。
リストの要素が文字列の場合は、
挿入される数値はEmacsの@code{format}関数によってフォーマットされます。
リストの要素が文字列以外の場合は、
その数値が、
対応するリスト要素への引数として渡されます。
@end table

どのソース・ファイルが表示されている場合でも、
Emacsの@kbd{C-x SPC}（@code{gdb-break}）コマンドは、
ポイントの置かれているソース行にブレイクポイントを設定するよう@value{GDBN}に対して指示します。

ソースを表示中のバッファを誤って削除してしまった場合に、
それを再表示させる簡単な方法は、
@value{GDBN}バッファの中で@code{f}コマンドを入力して、
フレーム表示を要求することです。
Emacs配下では、
カレント・フレームのコンテキストを表示するために必要であれば、
ソース・バッファが再作成されます。

Emacsによって表示されるソース・ファイルは、
通常どおりの方法でソース・ファイルにアクセスする、
普通のEmacsバッファによって表示されます。
そうしたいのであれば、
これらのバッファの中でファイルの編集を行うこともできますが、
@value{GDBN}とEmacsの間で行番号に関する情報が交換されていることを頭に入れておいてください。
テキストに行を挿入したり、
削除したりすると、
@value{GDBN}の認識しているソース行番号は、
実際のコードと正しく対応しなくなってしまいます。

@c The following dropped because Epoch is nonstandard.  Reactivate
@c if/when v19 does something similar. ---doc@cygnus.com 19dec1990
@ignore
@kindex Emacs Epoch environment
@kindex Epoch
@kindex inspect

Version 18 of @sc{gnu} Emacs has a built-in window system 
called the @code{epoch}
environment.  Users of this environment can use a new command,
@code{inspect} which performs identically to @code{print} except that
each value is printed in its own window.
@end ignore
@end ifclear

@node GDB Bugs
@c links whacked to pacify makeinfo
@c , Command Line Editing, Emacs, Top
@chapter @value{GDBN}のバグ報告
@cindex bugs in @value{GDBN}
@cindex reporting bugs in @value{GDBN}
@cindex バグ報告、@value{GDBN}の[バグほうこく、@value{GDBN}の]
@cindex 報告、@value{GDBN}のバグ[ほうこく、@value{GDBN}のバグ]

ユーザからのバグ報告は、
@value{GDBN}の信頼性を向上させるのに重要な役割を果たしています。

バグを報告することで、
その問題の解決につながり、
結果として報告者自ら利益を得ることができるかもしれません。
もちろん、
何の解決にもつながらないこともあります。
しかし、
いずれにしても、
バグ報告の主要な意義は、
次のバージョンの@value{GDBN}をより良いものにすることで、
コミュニティ全体の役に立つという点にあります。
バグ報告は、
@value{GDBN}の保守作業へのユーザからの貢献です。

バグ報告がその目的とするところを首尾よく達成できるようにするためには、
バグを修正することを可能にするような情報が提供されなければなりません。

@menu
* Bug Criteria::                本当にバグを見つけたのかどうかを知る方法
* Bug Reporting::               バグの報告方法
@end menu

@node Bug Criteria, Bug Reporting, GDB Bugs, GDB Bugs
@section 本当にバグを見つけたのかどうかを知る方法
@cindex bug criteria
@cindex バグの基準[バグのきじゅん]

発見した現象がバグかどうかよく分からない場合には、
以下のガイドラインを参照してください。

@itemize @bullet
@cindex fatal signal
@cindex debugger crash
@cindex crash of debugger
@cindex 致命的シグナル[ちめいてきシグナル]
@cindex デバッガのクラッシュ
@cindex クラッシュ、デバッガの
@item
入力された情報が何であれ、
デバッガが致命的なシグナルを受信するのであれば、
それは@value{GDBN}のバグです。
信頼性のあるデバッガは決してクラッシュなどしません。

@cindex error on valid input
@cindex エラー、正当な入力にたいする[エラー、せいとうなにゅうりょくにたいする]
@item
正当な入力に対して@value{GDBN}がエラー・メッセージを出力するのであれば、
それはバグです。
（クロス・デバッグを行っている場合には、
ターゲットへの接続に問題がある可能性もあるということに注意してください。）

@cindex invalid input
@cindex 不正な入力[ふせいなにゅうりょく]
@item
不正な入力に対して@value{GDBN}がエラー・メッセージを出力しないのであれば、
それはバグです。
ただし、
ユーザにとって「不正な入力」に思えるものが、
実は「拡張機能」であったり
「古くから使われている用法のサポート」であったりすることもあります。

@item
デバッグ・ツールに関する経験が豊富なユーザからの@value{GDBN}の改善提案は、
どのような場合でも歓迎です。
@footnote{訳注：この日本語の翻訳マニュアルへの改善提案は、
@email{ki@@home.email.ne.jp}に送ってください。}
@end itemize

@node Bug Reporting,  , Bug Criteria, GDB Bugs
@section バグの報告方法
@cindex bug reports
@cindex @value{GDBN} bugs, reporting
@cindex バグの報告[バグのほうこく]
@cindex @value{GDBN}のバグの報告[@value{GDBN}のバグのほうこく]

@ifclear HPPA
いくつかの企業や個人が@sc{gnu}のソフトウェアをサポートしています。
こうしたサポート組織から@value{GDBN}を入手したのであれば、
まずその組織に連絡することをお勧めします。

サポートを提供している多くの企業、
個人の連絡先情報が、
@sc{gnu} Emacsディストリビューションの@file{etc/SERVICE}ファイルに記載されています。
@c should add a web page ref...

どのような場合でも、
@value{GDBN}のバグ報告を
（英語で）
以下のアドレスに送ることをお勧めします。
@footnote{訳注：この日本語の翻訳マニュアルのバグは、
日本語（か英語）で、
@email{ki@@home.email.ne.jp}に報告してください。}

@example
bug-gdb@@prep.ai.mit.edu
@end example

@strong{@samp{info-gdb}、
@samp{help-gdb}、
および、
いかなるニュースグループにもバグ報告を送ることはしないでください。}
@value{GDBN}ユーザのほとんどは、
バグ報告を受け取りたいと考えてはいません。
バグ報告を受け取りたいと思っている人は、
@samp{bug-gdb}の配信を受けるようにしているはずです。

メーリング・リスト@samp{bug-gdb}には、
リピータとして機能する@samp{gnu.gdb.bug}というニュースグループがあります。
このメーリング・リストとニュースグループは、
全く同一のメッセージを配信しています。
メーリング・リストではなくニュースグループにバグ報告を流そうと考える人がよくいます。
これはうまく機能するように見えますが、
1つ重大な問題があります。
ニュースグループへの投稿では、
送信者へのメール・パスが分からないことがよくあります。
したがって、
もっと多くの情報が必要になったときに、
バグの報告者と連絡を取ることができない可能性があります。
こういうことがあるので、
メーリング・リストへのバグ報告の方が望ましいのです。

最後の手段として、
バグ報告を（英語で）紙に書いて下記に郵送するという方法があります。

@example
@sc{gnu} Debugger Bugs
Free Software Foundation Inc.
59 Temple Place - Suite 330
Boston, MA 02111-1307
USA
@end example
@end ifclear

@ifset HPPA
HP GDBが、
HP ANSI Cコンパイラ・キット、
または、
HP ANSI C++コンパイラ・キットに付属していたものであれば、
問題の報告はHPのテクニカル・サポートに送ってください。

Hewlett-PackardのWebサイトからHP GDBを入手したのであれば、
問題の報告は電子メールで@code{wdb-www@@ch.hp.com}に送ってください。
@end ifset

役に立つバグ報告を行うための最も根本的な原則は、
@strong{すべての事実を報告する}ことです。
ある事実を書くべきか省くべきかよく分からない場合は、
書くようにしてください。

事実が省略されてしまうことがよくありますが、
これはバグ報告者が、
自分には問題の原因は既に分かっていると考え、
いくつかの細かい点は関係がないと仮定してしまうからです。
したがって、
例の中で使った変数の名前などは重要ではないと、
報告者は考えます。
おそらくそうかもしれません。
しかし、
完全にそうであるとも言い切れません。
メモリの参照がデタラメな場所を指しているというバグで、
それがたまたまメモリ上においてその名前が置かれている箇所から値を取り出しているということがあるかもしれません。
名前が異なれば、
そこの内容は、
バグが存在するにもかかわらずデバッガが正しく動作してしまうような値になるかもしれません。
このようなことがないよう、
特定の完全な実例を提供してください。
バグの報告者にとっては、
このようにするのが最も簡単なはずであり、
かつ、
それが最も役に立つのです。

バグ報告の目的は、
そのバグを修正することができるようにすることにある、
という点を頭に入れておいてください。
そのバグが、
以前に報告されたものと同じであるという可能性もありますが、
バグ報告が完全なもので、
必要な情報がすべて含まれたものでなければ、
バグの報告者にも私たちにもそのことを知ることができません。

ときどき、
2、3の大雑把な事実だけを記述して、
「何か思い当たることはありますか?」と聞いてくる人がいます。
このようなバグ報告は役に立ちません。
このような報告には、
より適切なバグ報告を送るよう報告者に注意する場合を除いて、
@emph{返事をすることを拒否する}よう強くお願いします。

バグを修正できるようにするためには、
報告者は以下の情報をすべて含めるべきです。

@itemize @bullet
@item
@value{GDBN}のバージョン。
@value{GDBN}のバージョンは、
引数を指定せずに@value{GDBN}を起動すると、
表示されます。
また、
いつでも@code{show version}コマンドで表示させることができます。

この情報がないと、
カレント・バージョンの@value{GDBN}を使ってバグを探すことに意味があるのかどうかを知ることができません。

@item
使っているマシンのタイプ、
オペレーティング・システムの名前とバージョン番号。

@ifclear HPPA
@item
@value{GDBN}をコンパイルするのに使われたコンパイラ
（および、
そのバージョン）。
例えば、
@value{GCC}--2.8.1。
@end ifclear

@item
デバッグ対象のプログラムをコンパイルするのに使われたコンパイラ
（および、
そのバージョン）。
例えば、
@value{GCC}--2.8.1、
あるいは、
HP92453-01 A.10.32.03 HP Cコンパイラ。
GCCについては、
@code{gcc --version}によってこの情報を知ることができます。
他のコンパイラについては、
そのドキュメントを参照してください。

@item
バグを見つけたプログラムをコンパイルする際に、
コンパイラに渡したコマンド引数。
例えば、
@samp{-O}オプションを使ったか否かなど。
何か重要な点を省いてしまうことがないよう、
すべての引数を記述してください。
@file{Makefile}のコピー
（あるいは、
@c {{Makefileではなく、make}}
@code{make}からの出力）
を添付すれば十分でしょう。

引数が何であったのかを私たちが推測しようとしても、
おそらく誤った推測をしてしまうでしょう。
そうなると、
バグは再現しないかもしれません。

@item
バグを再現することのできる、
完全な入力スクリプトとすべての必要なソース・ファイル。

@item
発見された、
正しくないと思われる動作の説明。
例えば、
「致命的なシグナルを受信する」など。

もちろん、
@value{GDBN}が致命的なシグナルを受信するというバグであれば、
私たちも間違いなくそれに気がつくでしょう。
しかし、
出力が正しくないというバグであれば、
紛れもない誤りでなければ、
私たちはそれに気付かないかもしれません。
私たちが間違いをする可能性を排除するようにしてください。

たとえ致命的なシグナルを受信するような問題であっても、
報告者はそのことを明示的に報告するべきです。
何か奇妙なことが起こっていると仮定しましょう。
例えば、
報告者が使っている@value{GDBN}にちぐはぐなところがあるとか、
報告者のシステム上にあるCライブラリのバグだった、
というような場合です
（こういうことは、
実際にありました！）。
このような場合、
報告者の@value{GDBN}はクラッシュしても、
私たちのところではクラッシュしません。
クラッシュするはずであると報告されていれば、
私たちの@value{GDBN}がクラッシュしなくても、
「私たちのところではバグが発生しない」ということを知ることができます。
クラッシュするはずであるという報告がなければ、
実際の現象から何も結論を引き出すことができません。

@ifclear HPPA
@item
もし@value{GDBN}のソースへの修正を提案したいのであれば、
コンテキスト付きの差分情報を送ってください。
@value{GDBN}のソースについて何か議論する場合も、
行番号に言及するのではなく、
コンテキストに言及してください。

私たちが開発中のソースの行番号は、
報告者の持っているソースの行番号とは一致しないでしょう。
報告者から見たソースの行番号は、
私たちにとって役に立つ情報を提供してくれません。
@end ifclear
@end itemize

以下に、
バグ報告に必要ではない情報をいくつか列挙します。

@itemize @bullet
@item
バグの包括的な説明。

バグを見つけると、
多くの時間をかけて、
入力ファイルをどのように変更するとバグが発生しなくなり、
どのように変更した場合はバグが発生し続けるかを調べる人がよくいます。

これは多くの場合、
時間のかかる作業であり、
しかもあまり役に立ちません。
というのは、
私たちがバグを見つけるのは、
デバッガでブレイクポイントを使いながら1つの実例を実行させることによってであり、
一連の実例からの純粋な演繹によってではないからです。
時間を無駄にせず、
何かほかのことに使うようお勧めします。

もちろん、
一番最初にバグを見つけたときの実例の@emph{代わり}となる、
もっと単純な実例を見つけることができるのであれば、
私たちにとっても便利です。
出力におけるエラーはより発見しやすいものですし、
デバッガ配下で実行させる方が時間がかかりません。

しかし、
単純化は絶対に必要というわけでもありません。
こういうことをしたくないのであれば、
バグを発見したときのテスト・ケース全体を送って、
バグの報告を行ってください。

@item
バグに対するパッチ。

バグに対するパッチは、
それが良いものであれば、
役に立ちます。
しかし、
パッチがあれば十分であるとみなして、
テスト・ケースのような必要な情報を送るのを省かないでください。
提供されたパッチに問題があり、
別の方法で問題を修正することにする場合もありますし、
提供されたパッチを全く理解できないということもあるかもしれません。

@value{GDBN}のような複雑なプログラムでは、
コード中のある特定のパスを通るような実例を作成するのは困難なことがあります。
報告者が実例を送ってくれなければ、
私たちには実例を作成することができず、
したがって、
バグが修正されたことを検証することができなくなってしまいます。

また、
報告者の送ってくれたパッチがどのような問題を修正しようとしているのか私たちに理解できない場合、
あるいは、
なぜそのパッチが改善になるのか私たちが理解できない場合、
そのパッチを組み込むことはしません。
テスト・ケースが1つでもあれば、
そうしたことを理解するのに役立つでしょう。

@item
バグが何であるか、
あるいは、
何に依存しているかに関する推測。

このような推測は普通は間違っているものです。
私たちですら、
デバッガを使って事実を見出すまでは、
このような点に関して正しく推測することはできないのです。
@end itemize

@c The readline documentation is distributed with the readline code 
@c and consists of the two following files:
@c     rluser.texinfo
@c     inc-hist.texi
@c Use -I with makeinfo to point to the appropriate directory,
@c environment var TEXINPUTS with TeX.
@include rluser-ja.texinfo
@include inc-hist-ja.texi


@ifclear PRECONFIGURED
@ifclear HPPA
@node Formatting Documentation
@c links whacked to pacify makeinfo
@c , Installing GDB, Renamed Commands, Top
@appendix ドキュメントのフォーマット

@cindex @value{GDBN} reference card
@cindex reference card
@cindex @value{GDBN}リファレンス・カード[@value{GDBN}リファレンス・カード]
@cindex リファレンス・カード
@value{GDBN} 4には、
PostScriptまたはGhostScriptでそのまま印刷できる、
フォーマット済みのリファレンス・カードが含まれています。
@footnote{原注：バージョン@value{GDBVN}では@file{gdb-@value{GDBVN}/gdb/refcard.ps}です。}
これは、
メインのソース・ディレクトリの下の@file{gdb}サブディレクトリにあります。
PostScriptまたはGhostscriptを使えるプリンタがあれば、
@file{refcard.ps}を使ってすぐにリファレンス・カードを印刷することができます。

@value{GDBN} 4には、
リファレンス・カードのソースも含まれています。
@TeX{}を使えば、
以下のようにしてこれをフォーマットすることができます。

@example
make refcard.dvi
@end example

@value{GDBN}のリファレンス・カードは、
米国のレター・サイズの用紙に@dfn{ランドスケープ}・モードで印刷するようにデザインされています。
レター・サイズは、
横幅が11インチ、
高さが8.5インチです。
@sc{dvi}出力プログラムへのオプションとして、
この印刷形式を指定する必要があります。

@cindex documentation
@cindex ドキュメント

すべての@value{GDBN}ドキュメントは、
マシン上で読むことのできるディストリビューションの一部として提供されます。
ドキュメントはTexinfoフォーマットで記述されています。
これは、
単一のソースからオンライン・マニュアルとハードコピー・マニュアルの両方を生成するドキュメント・システムです。
Infoフォーマット・コマンドの1つを使ってオンライン・ドキュメントを作成することができ、
@TeX{}
（または@code{texi2roff}）
を使ってハード・コピーの組版ができます。

@value{GDBN}には、
このマニュアルのフォーマット済みのオンラインInfoバージョンも含まれています。
これは、
@file{gdb}サブディレクトリにあります。
メインのInfoファイルは@file{gdb-@value{GDBVN}/gdb/gdb.info}で、
同じディレクトリにある@samp{gdb.info*}にマッチする従属ファイルを参照します。
必要であれば、
これらのファイルを印刷したり、
任意のエディタで表示して読むこともできます。
しかし、
これらのファイルは、
@sc{gnu} Emacsの@code{info}サブシステムや
@sc{gnu} Texinfoの一部として配布されるスタンドアロンの@code{info}プログラムを使った方が読みやすいでしょう。

これらのInfoファイルを自分でフォーマットしたいのであれば、
@code{texinfo-format-buffer}や@code{makeinfo}のようなInfoフォーマット・プログラムが必要になります。

@code{makeinfo}がインストールされていて、
@value{GDBN}ソース・ディレクトリのトップ・レベル
（バージョン@value{GDBVN}では@file{gdb-@value{GDBVN}}）
にいる場合は、
以下のようにしてInfoファイルを作成することができます。

@example
cd gdb
make gdb.info
@end example

このマニュアルのコピーの組版を行って印刷するには、
@TeX{}、
@TeX{}の@sc{dvi}出力ファイルを印刷するプログラム、
および、
Texinfo定義ファイル@file{texinfo.tex}が必要です。

@TeX{}は組版プログラムです。
@TeX{}は直接ファイルを印刷しませんが、
@sc{dvi}ファイルと呼ばれるものを生成します。
組版されたドキュメントを印刷するには、
@sc{dvi}ファイルを印刷するプログラムが必要です。
システム上に@TeX{}がインストールされていれば、
@sc{dvi}ファイルを印刷するプログラムも入っている可能性があります。
印刷に使われるコマンドの正確な名前はシステムにより異なります。
@kbd{lpr -d}が一般によく使われます。
また
（PostScriptプリンタでは）
@kbd{dvips}がよく使われます。
@sc{dvi}プリント・コマンドを使う際には、
ファイル名に拡張子を付けないか、
あるいは、
@samp{.dvi}という拡張子を付ける必要があるかもしれません。

また、
@TeX{}は@file{texinfo.tex}という名のマクロ定義ファイルを必要とします。
このファイルは@TeX{}に対して、
Texinfoフォーマットで記述されたドキュメントをどのようにして組版するかを教えます。
@TeX{}は自分自身では、
Texinfoファイルを読むことも組版することもできません。
@file{texinfo.tex}はGDBととともに配布されていて、
@file{gdb-@var{version-number}/texinfo}ディレクトリにあります。

@TeX{}と@sc{dvi}印刷プログラムがインストールされていれば、
このマニュアルを組版して、
印刷することができます。
メインのソース・ディレクトリの下の@file{gdb}サブディレクトリ
（例えば、
@file{gdb-@value{GDBVN}/gdb}）
に移動して、
以下のように実行します。

@example
make gdb.dvi
@end example

その後、
@file{gdb.dvi}を@sc{dvi}印刷プログラムに渡します。
@end ifclear

@node Installing GDB, Index, Using History Interactively, Top
@appendix @value{GDBN}のインストール
@cindex configuring @value{GDBN}
@cindex installation
@cindex 設定、@value{GDBN}の[せってい、@value{GDBN}の]
@cindex インストール

@ifset HPPA
@value{GDBN}
（HP WDB 0.75）
が、
HP-UXリリース11.0のHP ANSI C開発キット、
または、
HP ANSI C++開発キットに付属しているものであれば、
@value{GDBN}のビルドやインストールを行うのに、
特別なことをする必要はありません。

@value{GDBN}
（HP WDB 0.75）
を、
HPのWebサイトから入手する場合は、
@code{swinstall}によってインストール可能なパッケージとソース・ツリーのいずれか一方、
または、
両方をダウンロードすることができます。

ほとんどのユーザは、
@code{swinstall}によってインストール可能なパッケージに含まれている
@value{GDBN}バイナリをインストールすることを希望するでしょう。
この方法でのインストールには、
以下のようなコマンドを使用します。

@smallexample
/usr/sbin/swinstall -s @var{package-name} WDB
@end smallexample

あるいは、
ソース・ディストリビューションから@value{GDBN}をビルドすることも可能です。
自分たちの必要に合わせて@value{GDBN}をカスタマイズするために、
デバッガのソースを変更することを考えている高度なユーザは、
このようなことを希望するかもしれません。
ソース・ディストリビューションには、
@file{gdb-4.16/...}をルートとするソース・ツリーを
@code{tar}でまとめたものが入っています。
この後に示す手順は、
このソース・ツリーから実行可能な@file{gdb}をビルドする方法を説明するものです。
ここに説明する手順は、
HPの配布しているWDBソース・ツリーにも適用可能であると、
HPは考えています。
しかし、
WDBのソース・ツリーからHP以外のプラットフォーム用の@file{gdb}をビルドすることを、
HPは明示的にはサポートしていません。
このようにしてビルドされた@file{gdb}は動作するかもしれませんが、
WDB 0.75のリリース・ノートに記載されているプラットフォーム以外では、
HPはテストを行っていません。
@end ifset

@value{GDBN}には、
インストールのための準備作業を自動化する@code{configure}スクリプトが付属しています。
@code{configure}を実行した後に@code{make}を実行することで、
@code{gdb}をビルドすることができます。

@iftex
@c irrelevant in info file; it's as current as the code it lives with.
@footnote{原注：バージョン@value{GDBVN}よりさらに新しい@value{GDBN}を持っている場合には、
ソースの中に含まれる@file{README}ファイルを参照してください。
このマニュアルの出版後、
インストール手順が改善されていることがあるかもしれません。}
@end iftex

@value{GDBN}ディストリビューションには、
@value{GDBN}をビルドするのに必要なすべてのソース・コードが、
単一のディレクトリの下に収められています。
このディレクトリの名前は通常、
@samp{gdb}の後ろにバージョン番号を付加したものです。

例えば、
バージョン@value{GDBVN}の@value{GDBN}ディストリビューションは、
@file{gdb-@value{GDBVN}}というディレクトリに収められています。
このディレクトリには、
以下のものが含まれます。

@table @code
@item gdb-@value{GDBVN}/configure @r{（およびサポート・ファイル）}
@value{GDBN}、
および、
@value{GDBN}が必要とするすべてのライブラリの構成を行うためのスクリプト

@item gdb-@value{GDBVN}/gdb
@value{GDBN}自身に固有のソース

@item gdb-@value{GDBVN}/bfd
Binary File Descriptorライブラリのソース

@item gdb-@value{GDBVN}/include
@sc{gnu}インクルード・ファイル

@item gdb-@value{GDBVN}/libiberty
@samp{-liberty}フリー・ソフトウェア・ライブラリのソース

@item gdb-@value{GDBVN}/opcodes
opcodeテーブルおよび逆アセンブラのライブラリのソース

@item gdb-@value{GDBVN}/readline
@sc{gnu}コマンドライン・インターフェイスのソース

@item gdb-@value{GDBVN}/glob
@sc{gnu}ファイル名パターン・マッチング・サブルーチンのソース

@item gdb-@value{GDBVN}/mmalloc
メモリにマップされる@sc{gnu} mallocパッケージのソース
@end table

@value{GDBN}の構成とビルドを行う最も簡単な方法は、
@file{gdb-@var{version-number}}ソース・ディレクトリから@code{configure}を実行することです。
ここでの例では、
このディレクトリは@file{gdb-@value{GDBVN}}です。

もしまだ@file{gdb-@var{version-number}}ソース・ディレクトリにいないのであれば、
まずそこに移動してください。
続いて@code{configure}を実行します。
@value{GDBN}が実行されるプラットフォームの識別子を引数として渡します。

例えば、
以下のようにします。

@example
cd gdb-@value{GDBVN}
./configure @var{host}
make
@end example

@noindent
@var{host}は、
@value{GDBN}が実行されるプラットフォームを識別する識別子です。
例えば@samp{sun4}や@samp{decstation}などです
（多くの場合@var{host}は省略することができます。
この場合@code{configure}は、
ユーザのシステムを調べることによって正しい値を推定しようとします）。

@samp{configure @var{host}}を実行した後に@code{make}を実行することで、
@file{bfd}、
@file{readline}、
@file{mmalloc}、
@file{libiberty}の各ライブラリがビルドされ、
最後に@code{gdb}自体がビルドされます。
構成されたソース・ファイルやバイナリは、
対応するソース・ディレクトリに残されます。

@need 750
@code{configure}はBourneシェル
（@code{/bin/sh}）
のスクリプトです。
ユーザが別のシェルを実行していて、
システムがこのことを自動的に認識してくれない場合は、
明示的に@code{sh}にスクリプトを実行させる必要があるかもしれません。

@example
sh configure @var{host}
@end example

バージョン@value{GDBVN}のソース・ディレクトリである@file{gdb-@value{GDBVN}}のように、
配下に複数のライブラリやプログラムのソース・ディレクトリを含むディレクトリから@code{configure}を実行すると、
@code{configure}は配下にあるそれぞれのディレクトリのための構成ファイルを作成します
（@samp{--norecursion}オプションによって、
そうしないよう指定した場合は別です）。

@value{GDBN}ディストリビューションの中の特定のサブディレクトリを構成したいだけの場合には、
そのサブディレクトリから@code{configure}スクリプトを実行することができます。
ただし、
@code{configure}スクリプトへのパスを必ず指定してください。

例えば、
バージョン@value{GDBVN}では、
@code{bfd}サブディレクトリだけを構成するには以下のようにします。

@example
@group
cd gdb-@value{GDBVN}/bfd
../configure @var{host}
@end group
@end example

@code{@value{GDBP}}はどこにでもインストールできます。
あらかじめ固定されたパスは1つもありません。
ただし、
ユーザのパスにある
（@samp{SHELL}環境変数により指定される）
シェルが誰にでも読み込み可能であることを確かめる必要があります。
@value{GDBN}はシェルを使ってユーザ・プログラムを起動するということを憶えておいてください。
子プロセスが読み込み不可のプログラムである場合、
システムによっては、
@value{GDBN}がそれをデバッグするのを拒否します。

@menu
* Separate Objdir::             異なるディレクトリでの@value{GDBN}のコンパイル
* Config Names::                ホストとターゲットの名前の指定
* Configure Options::           configureオプションの要約
@end menu

@node Separate Objdir, Config Names, Installing GDB, Installing GDB
@section 異なるディレクトリでの@value{GDBN}のコンパイル

いくつかのホスト・マシンおよびターゲット・マシン用の@value{GDBN}を実行したい場合、
ホストとターゲットの個々の組み合わせ用にコンパイルされた異なる@code{gdb}が必要になります。
@code{configure}には、
個々の構成をソース・ディレクトリにではなく個別のサブディレクトリに生成する機能があり、
このようなことが簡単にできるように設計されています。
ユーザの使っている@code{make}プログラムに@samp{VPATH}機能があれば
（@sc{gnu} @code{make}にはあります）、
これら個々のディレクトリにおいて@code{make}を実行することで、
そこで指定されている@code{gdb}プログラムをビルドすることができます。

個別のディレクトリにおいて@code{gdb}をビルドするには、
ソースの置かれている場所を指定するために、
@samp{--srcdir}オプションを使って@code{configure}を実行します
（同時に、
ユーザの作業ディレクトリから@code{configure}を見つけるためのパスも指定する必要があります。
もし、
@code{configure}へのパスが@samp{--srcdir}への引数として指定するものと同じであれば、
@samp{--srcdir}オプションは指定しなくてもかまいません。
指定されなければ、
同じであると仮定されます）。

例えば、
バージョン@value{GDBVN}でSun 4用の@value{GDBN}を別のディレクトリにおいて構築するには、
以下のようにします。

@example
@group
cd gdb-@value{GDBVN}
mkdir ../gdb-sun4
cd ../gdb-sun4
../gdb-@value{GDBVN}/configure sun4
make
@end group
@end example

@code{configure}が、
別の場所にあるソース・ディレクトリを使って、
ある構成を作成する際には、
ソース・ディレクトリ配下のディレクトリ・ツリーと同じ構造のディレクトリ・ツリーを
（同じ名前で）
バイナリ用に作成します。
この例では、
Sun 4用のライブラリ@file{libiberty.a}は@file{gdb-sun4/libiberty}ディレクトリに、
@value{GDBN}自身は@file{gdb-sun4/gdb}ディレクトリにそれぞれ作成されます。

いくつかの@value{GDBN}の構成を別々のディレクトリにおいてビルドする理由としてよくあるのが、
クロス・コンパイル
（@value{GDBN}は@dfn{ホスト}と呼ばれるあるマシン上で動作し、
@dfn{ターゲット}と呼ばれる別のマシンで実行されているプログラムをデバッグする）
環境用に@value{GDBN}を構成する場合です。
クロス・デバッグのターゲットは、
@code{configure}に対する@samp{--target=@var{target}}オプションを使って指定します。

プログラムやライブラリをビルドするために@code{make}を実行するときには、
構成されたディレクトリにいなければなりません。
これは、
@code{configure}を実行したときにいたディレクトリ
（または、
そのサブディレクトリの1つ）
です。

@code{configure}が個別のソース・ディレクトリに生成した@code{Makefile}は再帰的に呼び出されます。
@file{gdb-@value{GDBVN}}
（あるいは、
@samp{--srcdir=@var{dirname}/gdb-@value{GDBVN}}により構成された別のディレクトリ）
などのソース・ディレクトリにおいて@code{make}を実行すると、
必要とされるすべてのライブラリがビルドされ、
その後にGDBがビルドされることになります。

複数のホストまたはターゲットの構成が、
異なる複数のディレクトリに存在する場合、
（例えば、
それらが個々のホスト上にNFSマウントされている場合）
並行して@code{make}を実行することができます。
複数の構成が互いに干渉し合うということはありません。

@node Config Names, Configure Options, Separate Objdir, Installing GDB
@section ホストとターゲットの名前の指定

@code{configure}スクリプトにおけるホストおよびターゲットの指定方法は、
3つの名称部分を持ちますが、
あらかじめ定義された短い別名もいくつかサポートされています。
完全名は、
以下のようなパターンの3つの情報部分を持ちます。

@example
@var{architecture}-@var{vendor}-@var{os}
@end example

例えば、
ホストを指定する引数@var{host}として、
あるいは、
@code{--target=@var{target}}オプションの@var{target}の部分に、
@code{sun4}という別名を使うことができます。
これと同等の完全名は@samp{sparc-sun-sunos4}です。

@value{GDBN}に付属している@code{configure}スクリプトには、
サポートされているすべてのホスト名、
ターゲット名、
および、
別名を問い合わせするための機能はありません。
@code{configure}は、
Bourneシェル・スクリプトの@code{config.sub}を呼び出すことによって、
省略名を完全名に対応付けします。
このスクリプトを使って、
省略名の意味が推測と合っているかどうかをテストすることもできます。
以下に例を示します。

@smallexample
% sh config.sub i386-linux
i386-pc-linux-gnu
% sh config.sub alpha-linux
alpha-unknown-linux-gnu
% sh config.sub hp9k700
hppa1.1-hp-hpux
% sh config.sub sun4
sparc-sun-sunos4.1.1
% sh config.sub sun3
m68k-sun-sunos4.1.1
% sh config.sub i986v
Invalid configuration `i986v': machine `i986v' not recognized
@end smallexample

@noindent
@code{config.sub}も、
@value{GDBN}ディストリビューションの一部としてソース・ディレクトリ
（バージョン@value{GDBVN}では、@file{gdb-@value{GDBVN}}）
に入っています。

@node Configure Options,  , Config Names, Installing GDB
@section @code{configure}オプション

以下に、
@value{GDBN}をビルドする上でほとんどの場合に役に立つ
@code{configure}のオプションと引数の要約を示します。
@code{configure}には、
ここには挙げられていないオプションもいくつかあります。
@code{configure}に関する完全な説明については、
@c {{@inforef の部分はどう訳す}}
@inforef{What Configure Does,,configure.info}。

@example
configure @r{[}--help@r{]}
          @r{[}--prefix=@var{dir}@r{]}
          @r{[}--exec-prefix=@var{dir}@r{]}
          @r{[}--srcdir=@var{dirname}@r{]}
          @r{[}--norecursion@r{]} @r{[}--rm@r{]}
          @r{[}--target=@var{target}@r{]}
          @var{host}
@end example

@noindent
そうしたいのであれば、
@samp{--}ではなく単一の@samp{-}でオプションを始めることもできますが、
@samp{--}を使うとオプション名を省略することができます。

@table @code
@item --help
@code{configure}の実行方法の簡単な要約を表示します。

@item --prefix=@var{dir}
プログラムおよびファイルをディレクトリ@file{@var{dir}}にインストールするよう
ソースを構成します。

@item --exec-prefix=@var{dir}
プログラムをディレクトリ@file{@var{dir}}にインストールするよう
ソースを構成します。

@c avoid splitting the warning from the explanation:
@need 2000
@item --srcdir=@var{dirname}
@strong{注意: このオプションを使うには、
@sc{gnu} @code{make}、
あるいは、
@code{VPATH}機能を持つ他の@code{make}を使用する必要があります。}@*
@value{GDBN}ソース・ディレクトリとは別のディレクトリに構成を作成する場合に、
このオプションを使用します。
特に、
いくつかの構成を別々のディレクトリにおいて同時に作成（かつ維持）する場合に、
このオプションを使うことができます。
@code{configure}は、
構成に固有のファイルをカレント・ディレクトリに書き込みますが、
@var{dirname}ディレクトリにあるソースを使うように、
それらのファイルを調整します。
@code{configure}は、
@var{dirname}ディレクトリ配下のソース・ディレクトリ・ツリーと同じ構造を持つディレクトリ・ツリーを、
作業ディレクトリの下に作成します。

@item --norecursion
@code{configure}が実行されたディレクトリ・レベルだけを構成します。
サブディレクトリまで含めて構成することはしません。

@item --target=@var{target}
指定されたターゲット@var{target}で実行するプログラムをクロス・デバッグするために、
@value{GDBN}を構成します。
このオプションを指定しないと、
@value{GDBN}と同じマシン
（@var{ホスト}）
で実行されるプログラムをデバッグするよう、
@value{GDBN}は構成されます。

利用可能なすべてのターゲットの一覧を生成する、
便利な方法はありません。

@item @var{host} @dots{}
指定されたホスト@var{host}上で実行されるよう@value{GDBN}を構成します。

利用可能なすべてのホストの一覧を生成する、
便利な方法はありません。
@end table

ほかにも利用可能な多くのオプションがありますが、
これは通常、
特殊な目的にのみ必要とされるものです。
@end ifclear

 
@node Index,  , Installing GDB, Top
@unnumbered インデックス

@printindex cp

@tex
% I think something like @colophon should be in texinfo.  In the
% meantime:
\long\def\colophon{\hbox to0pt{}\vfill
\centerline{The body of this manual is set in}
\centerline{\fontname\tenrm,}
\centerline{with headings in {\bf\fontname\tenbf}}
\centerline{and examples in {\tt\fontname\tentt}.}
\centerline{{\it\fontname\tenit\/},}
\centerline{{\bf\fontname\tenbf}, and}
\centerline{{\sl\fontname\tensl\/}}
\centerline{are used for emphasis.}\vfill}
\page\colophon
% Blame: doc@cygnus.com, 1991.
@end tex

@contents
@bye
