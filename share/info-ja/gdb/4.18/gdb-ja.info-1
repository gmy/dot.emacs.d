-*- coding: utf-8 -*-
START-INFO-DIR-ENTRY
* Gdb: (gdb).                     The GNU debugger.
END-INFO-DIR-ENTRY
   This file documents the GNU debugger GDB.

   This is the Seventh Edition, February 1999, of `Debugging with GDB:
the GNU Source-Level Debugger' for GDB Version 4.18.

   Copyright (C) 1988-1999 Free Software Foundation, Inc.

   Permission is granted to make and distribute verbatim copies of this
manual provided the copyright notice and this permission notice are
preserved on all copies.

   Permission is granted to copy and distribute modified versions of
this manual under the conditions for verbatim copying, provided also
that the entire resulting derived work is distributed under the terms
of a permission notice identical to this one.

   Permission is granted to copy and distribute translations of this
manual into another language, under the above conditions for modified
versions.


File: gdb-ja.info,  Node: Top,  Next: Summary,  Prev: (dir),  Up: (dir)

Debugging with GDB
******************

このファイルには、 GNUのシンボリック・デバッガであるGDBのことが
説明してあります。

   Seventh版、February 1999、GDBバージョン4.18

   Copyright (C) 1988-1999 Free Software Foundation, Inc.

* Menu:

* Summary::                     GDBの要約

* Sample Session::              GDBセッションのサンプル

* Invocation::                  GDBの起動・終了
* Commands::                    GDBコマンド
* Running::                     GDB配下でのプログラムの実行
* Stopping::                    停止と継続
* Stack::                       スタックの検査
* Source::                      ソース・ファイルの検査
* Data::                        データの検査

* Languages::                   異なる言語の使用


* Symbols::                     シンボル・テーブルの検査
* Altering::                    実行の変更
* GDB Files::                   GDBファイル
* Targets::                     デバッグ・ターゲットの指定
* Controlling GDB::             GDBの制御
* Sequences::                   一連のコマンドのグループ化

* Emacs::                       GNU Emacsの中でのGDBの使用

* GDB Bugs::                    GDBのバグ報告



* Formatting Documentation::    GDBドキュメントのフォーマットと印刷


* Command Line Editing::        コマンドライン編集
* Using History Interactively:: ヒストリの対話的な使用
* Installing GDB::              GDBのインストール
* Index::                       インデックス

 --- The Detailed Node Listing ---

GDBの要約

* Free Software::               フリー・ソフトウェア
* Contributors::                GDBに貢献した人々

GDBの起動・終了

* Invoking GDB::                GDBの起動
* Quitting GDB::                GDBの終了
* Shell Commands::              GDBの中でのシェル・コマンドの使用

GDBの起動

* File Options::                ファイルの選択
* Mode Options::                モードの選択

GDBコマンド

* Command Syntax::              GDBに対するコマンドの指定
* Completion::                  コマンド名の補完
* Help::                        ヘルプの表示

GDB配下でのプログラムの実行

* Compilation::                 デバッグのためのコンパイル
* Starting::                    ユーザ・プログラムの起動

* Arguments::                   ユーザ・プログラムの引数
* Environment::                 ユーザ・プログラムの環境

* Working Directory::           ユーザ・プログラムの作業ディレクトリ
* Input/Output::                ユーザ・プログラムの入出力
* Attach::                      既に実行中のプロセスのデバッグ
* Kill Process::                子プロセスの終了

* Process Information::         追加のプロセス情報

* Threads::                     マルチスレッド・プログラムのデバッグ
* Processes::                   マルチプロセス・プログラムのデバッグ

停止と継続

* Breakpoints::                 ブレイクポイント、ウォッチポイント、キャッチポイント
* Continuing and Stepping::     実行の再開

* Signals::                     シグナル

* Thread Stops::                マルチスレッド・プログラムの停止と起動

ブレイクポイント、ウォッチポイント、キャッチポイント

* Set Breaks::                  ブレイクポイントの設定
* Set Watchpoints::             ウォッチポイントの設定
* Set Catchpoints::             キャッチポイントの設定
* Delete Breaks::               ブレイクポイントの削除
* Disabling::                   ブレイクポイントの無効化
* Conditions::                  ブレイクポイントの成立条件
* Break Commands::              ブレイクポイント・コマンド・リスト

* Breakpoint Menus::            ブレイクポイント・メニュー

スタックの検査

* Frames::                      スタック・フレーム
* Backtrace::                   バックトレース
* Selection::                   フレームの選択
* Frame Info::                  フレームに関する情報
* Alpha/MIPS Stack::            Alpha/MIPSマシンの関数スタック

ソース・ファイルの検査

* List::                        ソース行の表示

* Search::                      ソース・ファイル内の検索
* Source Path::                 ソース・ディレクトリの指定
* Machine Code::                ソースとマシン・コード

データの検査

* Expressions::                 式
* Variables::                   プログラム変数
* Arrays::                      人工配列
* Output Formats::              出力フォーマット
* Memory::                      メモリの調査
* Auto Display::                自動表示
* Print Settings::              表示設定
* Value History::               値ヒストリ
* Convenience Vars::            コンビニエンス変数
* Registers::                   レジスタ

* Floating Point Hardware::     浮動小数ハードウェア

異なる言語の使用

* Setting::                     ソース言語の切り替え
* Show::                        言語の表示

* Checks::                      型と範囲のチェック

* Support::                     サポートされる言語

ソース言語の切り替え

* Filenames::                   ファイル拡張子と言語
* Manually::                    手作業による作業言語の設定
* Automatically::               GDBによる作業言語の推定


型と範囲のチェック

* Type Checking::               型チェックの概要
* Range Checking::              範囲チェックの概要

サポートされる言語


* C::                           C/C++

C言語サポート

* C Operators::                 C演算子

C言語サポート

* C Operators::                 C/C++演算子
* C Constants::                 C/C++定数
* Cplus expressions::           C++式
* C Defaults::                  C/C++のデフォルト設定

* C Checks::                    C/C++の型チェックと範囲チェック
* Debugging C::                 GDBとC
* Debugging C plus plus::       C++用のGDB機能


Modula-2

* M2 Operators::                組み込み演算子
* Built-In Func/Proc::          組み込み関数と組み込みプロシージャ
* M2 Constants::                Modula-2定数
* M2 Defaults::                 Modula-2デフォルト設定
* Deviations::                  標準Modula-2との差異
* M2 Checks::                   Modula-2の型チェックと範囲チェック
* M2 Scope::                    スコープ演算子`::'と`.'
* GDB/M2::                      GDBとModula-2

実行の変更

* Assignment::                  変数への代入
* Jumping::                     異なるアドレスにおける処理継続

* Signaling::                   ユーザ・プログラムへのシグナルの通知
* Returning::                   関数からの復帰
* Calling::                     ユーザ・プログラム関数の呼び出し
* Patching::                    ユーザ・プログラムへのパッチ適用

GDBファイル

* Files::                       ファイルを指定するコマンド
* Symbol Errors::               シンボル・ファイル読み込み時のエラー

デバッグ・ターゲットの指定

* Active Targets::              アクティブ・ターゲット
* Target Commands::             ターゲットを管理するコマンド

* Byte Order::                  ターゲットのバイト・オーダの選択
* Remote::                      リモート・デバッグ

リモート・デバッグ


* Remote Serial::               GDBリモート・シリアル・プロトコル


* i960-Nindy Remote::		GDBとリモートi960（Nindy）


* UDI29K Remote::               AMD29K用のUDIプロトコル
* EB29K Remote::		AMD29K用のEBMONプロトコル


* VxWorks Remote::		GDBとVxWorks


* ST2000 Remote::               GDBとTandem ST2000


* Hitachi Remote::              GDBと日立のマイクロ・プロセッサ


* MIPS Remote::			GDBとMIPSボード


* Simulator::                   シミュレートされたCPUターゲット

GDBの制御

* Prompt::                      プロンプト
* Editing::                     コマンド編集
* History::                     コマンド・ヒストリ
* Screen Size::                 画面サイズ
* Numbers::                     数値
* Messages/Warnings::           オプションの警告およびメッセージ

一連のコマンドのグループ化

* Define::                      ユーザ定義コマンド
* Hooks::                       ユーザ定義コマンド・フック
* Command Files::               コマンド・ファイル
* Output::                      制御された出力を得るためのコマンド

GDBのバグ報告

* Bug Criteria::                本当にバグを見つけたのかどうかを知る方法
* Bug Reporting::               バグの報告方法

GDBのインストール

* Separate Objdir::             異なるディレクトリでのGDBのコンパイル
* Config Names::                ホストとターゲットの名前の指定
* Configure Options::           configureオプションの要約


File: gdb-ja.info,  Node: Summary,  Next: Sample Session,  Prev: Top,  Up: Top

GDBの要約
*********

GDBのようなデバッガの目的は、
実行中のプログラムの内部において何が起こっているのか、 あるいは、
プログラムがクラッシュしたときに何をしていたのかを知ることができるようにすることにあります。

   GDBは、 実際のバグを発見できるようにするために4つのこと （さらに、
これらを支援するために他のことも） 行います。

   * ユーザ・プログラムを、
     その動作に影響を与える可能性のある様々なことを指定して起動する

   * 指定された条件が成立したときにユーザ・プログラムを停止する

   * 停止したときにユーザ・プログラムが何を行っていたかを調べる

   * ユーザ・プログラムの内部を変更することによって、
     1つのバグの影響を試験的に修正して、 ほかのバグについて調べる

GDBを使ってCおよびC++で記述されたプログラムをデバッグすることができます。
詳細については、 *Note C and C++: C。

   Modula-2とChillのサポートはまだ部分的なものです。
Modula-2に関する情報については、 *Note Modula-2: Modula-2。
Chillに関するドキュメントはまだありません。

   集合、 サブ範囲 （subrange）、 ファイル変数、
入れ子関数を使っているPascalプログラムをデバッグすることは、
現時点ではできません。 Pascalの構文を使って、 式の入力、
変数の値の表示、 およびそれに類することを実行することを、
GDBはサポートしていません。

   GDBは、 Fortranで記述されたプログラムのデバッグに使うことができます。
しかし、 Fortranの構文を使って、 式の入力、 変数の値の表示、
およびそれに類する機能を実行することは、 まだサポートされていません。
変数によっては、
末尾にアンダースコアを付けて参照する必要のある場合があります。

* Menu:

* Free Software::               フリー・ソフトウェア
* Contributors::                GDBに貢献した人々


File: gdb-ja.info,  Node: Free Software,  Next: Contributors,  Prev: Summary,  Up: Summary

フリー・ソフトウェア
====================

GDBは"フリー・ソフトウェア"であり、 GNU General Public License
（GPL）により保護されています。 あなたは、 GPLによって、
ライセンスされたプログラムをコピーしたり改造したりする自由を与えられます。
しかし、コピーを入手した人は誰でも、 そのコピーとともに、
そのコピーを修正する自由を手に入れますし
（つまりソース・コードを入手することができなければならないということです）、
また、 さらにそのコピーを配布する自由も手に入れます。 通常、
ソフトウェア会社は、 著作権によりユーザの自由を妨げます。 Free Software
FoundationはGPLを使ってこれらの自由を保護します。

   基本的には、 GPLは、 「あなたはこれらの自由を与えられるが、
これらの自由をほかの誰からも奪うことはできない」
と主張するライセンスです。


File: gdb-ja.info,  Node: Contributors,  Prev: Free Software,  Up: Summary

GDBに貢献した人々
=================

Richard Stallmanは、 GDB、 および、 その他の多くの GNU
プログラムの最初の開発者です。
ほかにも多くの人々がGDBの開発に貢献してきました。 この節では、
主要な貢献者を紹介したいと思います。
フリー・ソフトウェアの素晴らしい点の1つは、
誰もがそれに貢献する自由があるということです。 残念ながら、
ここですべての人を紹介することはできません。 GDB
ディストリビューションに含まれる `ChangeLog'
というファイルにおおまかな紹介を載せてあります。

バージョン2.0よりもずっと前の変更内容は、いつのまにか紛失してしまいました。

     _お願い:_ このセクションへの追加は大歓迎です。 あなたやあなたの友人
     （公平を期すため、あなたの敵も加えておきましょう）
     が不当にもこのリストから除外されているのであれば、
     喜んで名前を付け加えます。

   彼らの多大な労働が感謝されていないと思われないように、 最初に、
GDBの主要なリリースを通じて GDBの面倒を見てきた人々に特に感謝します。
その人々とは、 Jim Blandy（リリース4.18）、 Jason
Molenda（リリース4.17）、 Stan Shebs（リリース4.14）、 Fred
Fish（リリース4.16, 4.15, 4.13, 4.12, 4.11, 4.10, 4.9）、 Stu
GrossmanとJohn Gilmore（リリース4.8, 4.7, 4.6, 4.5, 4.4）、 John
Gilmore（リリース4.3, 4.2, 4.1, 4.0, 3.9）、 Jim Kingdon（リリース3.5,
3.4, 3.3）、 Randy Smith（リリース3.2, 3.1, 3.0） です。

   Richard Stallmanは、様々な機会にPeter TerMaat、Chris Hanson、Richard
Mlynarikの支援を受けながら、2.8までのリリースを担当しました。

   Michael Tiemannは、 GDBにおけるGNU
C++サポートのほとんどを開発してくれました。 C++のサポートについては、
Per Bothnerからも重要な貢献がありました。 James ClarkはGNU
C++のデマングラ （demangler） を開発してくれました。
C++についての初期の仕事は Peter TerMaatによるものです （彼はまた、
リリース3.0までの一般的なアップデート作業の多くを担当してくれました）。

   GDB 4は、 複数のオブジェクト・ファイル・フォーマットを調べるのに BFD
サブルーチン・ライブラリを使用しています。 BFDは、 David V.
Henkel-Wallace、 Rich Pixley、 Steve Chamberlain、 John
Gilmoreによる共同プロジェクトです。

   David Johnsonは、最初のCOFFサポートを開発してくれました。 Pace
Willisonは最初のカプセル化されたCOFF （encapsulated COFF）
のサポートを開発してくれました。

   Harris Computer Systems社のBrent Bensonは、 DWARF
2のサポート部分を提供してくれました。

   Adam de BoorとBradley DavisはISI Optimum
Vのサポート部分を提供してくれました。 Per Bothner、引地信之、Alessandro
Forinは、 MIPSのサポート部分を提供してくれました。 Jean-Daniel
FeketeはSun 386iのサポート部分を提供してくれました。 Chris
HansonはHP9000サポートを改善してくれました。 引地信之と長谷井智之は、
Sony/News OS 3のサポート部分を提供してくれました。 David
JohnsonはEncore Umaxのサポート部分を提供してくれました。 Jyrki
KuoppalaはAltos 3068のサポート部分を提供してくれました。 Jeff LawはHP
PAとSOMのサポート部分を提供してくれました。 Keith
PackardはNS32Kのサポート部分を提供してくれました。 Doug RabsonはAcorn
Risc Machineのサポート部分を提供してくれました。 Bob RuskはHarris
Nighthawk CX-UXのサポート部分を提供してくれました。 Chris
SmithはConvexのサポート （および、Fortranデバッグのサポート）
部分を提供してくれました。 Jonathan
StoneはPyramidのサポート部分を提供してくれました。 Michael
TiemannはSPARCのサポート部分を提供してくれました。 Tim TuckerはGould
NP1とGould Powernodeのサポート部分を提供してくれました。 Pace
WillisonはIntel 386のサポート部分を提供してくれました。 Jay
VosburghはSymmetryのサポート部分を提供してくれました。

   Andreas SchwabはM68K Linuxのサポート部分を提供してくれました。

   Rich SchaeferとPeter
SchauerはSunOS共用ライブラリのサポートを手伝ってくれました。

   Jay FenlasonとRoland McGrathは、
GDBとGASがいくつかのマシン命令セットに関して共通の認識を持つようにしてくれました。

   Patrick Duval、Ted Goldstein、Vikram Koka、Glenn
Engelはリモート・デバッグ機能の開発を手伝ってくれました。 Intel社、Wind
River Systems 社、AMD社、ARM社はそれぞれ、 i960、VxWorks、A29K
UDI、RDIターゲット用のリモート・デバッグ・モジュールを提供してくれました。

   Brian Foxは、コマンドライン編集やコマンドライン・ヒストリを提供する
readlineライブラリの開発者です。

   SUNY BuffaloのAndrew Beersは言語切り替えのソース・コード
とModula-2サポート を開発し、このマニュアルのプログラミング言語関連
（Languages） の章を提供してくれました。

   Fred FishはUnix System Vr4サポートのほとんどを開発してくれました。
彼はまた、
C++のオーバーロードされたシンボルを扱えるようコマンド補完機能を拡張してくれました。

   Hitachi America, Ltd.は、 H8/300プロセッサ、 H8/500プロセッサ、
および、 Super-Hプロセッサのサポートを後援してくれました。

   NECは、 v850プロセッサ、 Vr4xxxプロセッサ、 および、
Vr5xxxプロセッサのサポートを後援してくれました。

   Mitsubishi（三菱）は、 D10Vプロセッサ、 D30Vプロセッサ、 および、
M32R/Dプロセッサのサポートを後援してくれました。

   Toshiba（東芝）は、 TX39
Mipsプロセッサのサポートを後援してくれました。

   Matsushita（松下）は、
MN10200プロセッサとMN10300プロセッサのサポートを後援してくれました。

   Fujitsu（富士通）は、
SPARCliteプロセッサとFR30プロセッサのサポートを後援してくれました。

   Kung Hsu、Jeff Law、Rick
Sladkeyはハードウェア・ウォッチポイントのサポートを追加してくれました。

   Michael Snyderはトレースポイントのサポートを追加してくれました。

   Stu Grossmanはgdbserverを開発してくれました。

   Jim Kingdon、Peter Schauer、Ian Taylor、Stu
GrossmanはGDB全体にわたって、
ほとんど数えることができないほどのバグ・フィックスとソース・コードの整理を行ってくれました。

   Hewlett-Packard社のBen Krepp、 Richard Title、 John Bishop、 Susan
Macchia、 Kathy Mann、 Satish Pai、 India Paul、 Steve Rehrauer、 Elena
Zannoniは、 PA-RISC 2.0アーキテクチャ、 HP-UX 10.20、10.30、11.0(narrow
mode)、 HPによるカーネル・スレッドの実装、 HP aC++コンパイラ、 および、
端末ユーザ・インターフェイスの各サポート部分を提供してくれました。
また、 このマニュアルの中のHP固有の情報は、 Kim
Haaseにより提供されたものです。

   Cygnus Solutions社は、 1991年以降、
GDBの保守作業とGDBの多くの開発作業を後援しています。
フルタイムでGDBに関わる仕事をしたCygnusのエンジニアは、 Mark Alexander、
Jim Blandy、 Per Bothner、 Edith Epstein、 Chris Faylor、 Fred Fish、
Martin Hunt、 Jim Ingham、 John Gilmore、 Stu Grossman、 Kung Hsu、 Jim
Kingdon、 John Metzler、 Fernando Nasser、 Geoffrey Noer、 Dawn
Perchik、 Rich Pixley、 Zdenek Radouch、 Keith Seitz、 Stan Shebs、
David Taylor、 Elena Zannoniです。 さらに、 Dave Brolley、 Ian
Carmichael、 Steve Chamberlain、 Nick Clifton、 JT Conklin、 Stan Cox、
DJ Delorie、 Ulrich Drepper、 Frank Eigler、 Doug Evans、 Sean Fagan、
David Henkel-Wallace、 Richard Henderson、 Jeff Holcomb、 Jeff Law、
Jim Lemke、 Tom Lord、 Bob Manson、 Michael Meissner、 Jason Merrill、
Catherine Moore、 Drew Moseley、 Ken Raeburn、 Gavin Romig-Koch、 Rob
Savoye、 Jamie Smith、 Mike Stump、 Ian Taylor、 Angela Thomas、
Michael Tiemann、 Tom Tromey、 Ron Unrau、 Jim Wilson、 David Zuhnは、
大小様々な貢献をしてくれました。


File: gdb-ja.info,  Node: Sample Session,  Next: Invocation,  Prev: Summary,  Up: Top

1 GDBセッションのサンプル
*************************

その気になれば、
このマニュアルを使ってGDBのすべてを学習することももちろん可能ですが、
GDBを使い始めるには、 いくつかのコマンドを知っていれば十分です。
本章では、そのようなコマンドについて説明します。

   汎用的なマクロ・プロセッサであるGNU `m4'には、 かつて、
まだ正式なバージョンがリリースされる以前に、
次のような不具合がありました。
引用を表わす文字列をデフォルトとは異なるものに変更すると、
あるマクロ定義の内部に入れ子状態になっている他のマクロ定義を取り出すために使われるコマンドが、
正しく動作しなくなることがある、 という不具合です。
以下の短い`m4'セッションでは、
`0000'に展開されるマクロ`foo'を定義しています。 さらに、
`m4'の組み込みコマンド`defn'を使って、
マクロ`bar'に同一の定義を与えています。 ところが、
引用の開始文字列を`<QUOTE>'に、
引用の終了文字列を`<UNQUOTE>'にそれぞれ変更すると、
全く同一の手順で新しい同義語`baz'を定義しようとしても、
うまくいかないのです。

     $ cd gnu/m4
     $ ./m4
     define(foo,0000)

     foo
     0000
     define(bar,defn(`foo'))

     bar
     0000
     changequote(<QUOTE>,<UNQUOTE>)

     define(baz,defn(<QUOTE>foo<UNQUOTE>))
     baz
     C-d
     m4: End of input: 0: fatal error: EOF in string

ここでGDBを使って、 何が起こっているのか調べてみましょう。

     $ gdb m4
     GDB is free software and you are welcome to distribute copies
      of it under certain conditions; type "show copying" to see
      the conditions.
     There is absolutely no warranty for GDB; type "show warranty"
      for details.

     GDB 4.18, Copyright 1999 Free Software Foundation, Inc...
     (gdb)

GDBは、
必要なときに他のシンボルを見つけるのに最低限必要となるシンボル情報しか読み込みません。
その結果、 最初のプロンプトが表示されるまでの時間が極めて短いのです。
ここで、 出力情報がこのマニュアルの紙幅に収まるようにするために、
GDBに対して表示幅を通常よりも狭くするよう指示を出してみましょう。

     (gdb) set width 70

`m4'の組み込みコマンドである`changequote'がどのように動作するのかを調べてみる必要があります。
ソースを見ると、
関連するサブルーチンが`m4_changequote'であることがわかります。 そこで、
GDBの`break'コマンドでブレイクポイントを設定してみます。

     (gdb) break m4_changequote
     Breakpoint 1 at 0x62f4: file builtin.c, line 879.

`run'コマンドを使って、 GDBの管理下で`m4'を走らせます。
`m4_changequote'サブルーチンに到達するまでは、
プログラムは通常どおりの動作をします。

     (gdb) run
     Starting program: /work/Editorial/gdb/gnu/m4/m4
     define(foo,0000)

     foo
     0000

ブレイクポイントでプログラムを停止させるために`changequote'を実行すると、
GDBは`m4'の実行を停止し、 停止した箇所のコンテキスト情報を表示します。

     changequote(<QUOTE>,<UNQUOTE>)

     Breakpoint 1, m4_changequote (argc=3, argv=0x33c70)
         at builtin.c:879
     879         if (bad_argc(TOKEN_DATA_TEXT(argv[0]),argc,1,3))

次に`n'（`next'）コマンドを実行すると、
現在停止している関数の中で1行だけ処理が実行されます。

     (gdb) n
     882         set_quotes((argc >= 2) ? TOKEN_DATA_TEXT(argv[1])\
      : nil,

`set_quotes'というのは、 いわくありげなサブルーチンです。
`next'コマンドの代わりに`s'（`step'）コマンドを使うことで、
このサブルーチンの中に入ることができます。 `step'コマンドは、
それが_どの_サブルーチンの中にあるかということにかかわりなく、
次の1行に移動します。 この場合、 次の1行は`set_quotes'の中ですから、
そこへ移動することになります。

     (gdb) s
     set_quotes (lq=0x34c78 "<QUOTE>", rq=0x34c88 "<UNQUOTE>")
         at input.c:530
     530         if (lquote != def_lquote)

`m4'がその中で現在停止しているサブルーチン
（および、そのサブルーチンへの引数） が表示されています。
これをスタック・フレーム表示と呼びます。 それは、
スタックの状態を要約した情報を表示しています。 `backtrace'コマンド
（あるいは、 `bt'と省略することもできます） を使って、 現在、
スタック全体の中のどこにいるかを知ることもできます。
`backtrace'コマンドは、
アクティブなサブルーチンのスタック・フレームを表示します。

     (gdb) bt
     #0  set_quotes (lq=0x34c78 "<QUOTE>", rq=0x34c88 "<UNQUOTE>")
         at input.c:530
     #1  0x6344 in m4_changequote (argc=3, argv=0x33c70)
         at builtin.c:882
     #2  0x8174 in expand_macro (sym=0x33320) at macro.c:242
     #3  0x7a88 in expand_token (obs=0x0, t=209696, td=0xf7fffa30)
         at macro.c:71
     #4  0x79dc in expand_input () at macro.c:40
     #5  0x2930 in main (argc=0, argv=0xf7fffb20) at m4.c:195

次に、2、3行先に進んで、 何が起こっているのかを見てみましょう。
最初の2回は、 `s'コマンドを使います。 続く2回は、
`xstrdup'サブルーチンの中に入ってしまうのを防ぐために、
`n'コマンドを使います。

     (gdb) s
     0x3b5c  532         if (rquote != def_rquote)
     (gdb) s
     0x3b80  535         lquote = (lq == nil || *lq == '\0') ?  \
     def_lquote : xstrdup(lq);
     (gdb) n
     536         rquote = (rq == nil || *rq == '\0') ? def_rquote\
      : xstrdup(rq);
     (gdb) n
     538         len_lquote = strlen(rquote);

最後に表示された行は、少し妙な感じがします。 2つの変数`lquote'、
`rquote'を調べて、 本当にそれが、 新たに指定された引用開始文字列、
引用終了文字列であるかどうか確認することができます。
値を調べるには`p'（`print'）コマンドを使用します。

     (gdb) p lquote
     $1 = 0x35d40 "<QUOTE>"
     (gdb) p rquote
     $2 = 0x35d50 "<UNQUOTE>"

`lquote'と`rquote'は確かに引用開始文字列、 引用終了文字列のようです。
前後関係を調べるには、 `l'（`list'）コマンドを使って、
現在停止している行を中心にその前後10行を表示します。

     (gdb) l
     533             xfree(rquote);
     534
     535         lquote = (lq == nil || *lq == '\0') ? def_lquote\
      : xstrdup (lq);
     536         rquote = (rq == nil || *rq == '\0') ? def_rquote\
      : xstrdup (rq);
     537
     538         len_lquote = strlen(rquote);
     539         len_rquote = strlen(lquote);
     540     }
     541
     542     void

`len_lquote'と`len_rquote'に値を設定している行を実行させてから、
それらの値を調べてみましょう。

     (gdb) n
     539         len_rquote = strlen(lquote);
     (gdb) n
     540     }
     (gdb) p len_lquote
     $3 = 9
     (gdb) p len_rquote
     $4 = 7

`len_lquote'と`len_rquote'が、
それぞれ`lquote'と`rquote'の長さであるとすると、
ここに表示されている値は明らかに誤りです。 `p'コマンドを使って、
正しい値を設定することができます。
`p'コマンドによって任意の式の値を表示することができますが、
ここでいう「式」には、 サブルーチンの呼び出しや、
値の割り当ても含まれます。

     (gdb) p len_lquote=strlen(lquote)
     $5 = 7
     (gdb) p len_rquote=strlen(rquote)
     $6 = 9

新しい引用文字列をセットした状態で、
`m4'の組み込みコマンド`defn'を使用しようとすると発生する問題を修正するには、
これだけで十分でしょうか?  `c'（`continue'）コマンドを使えば、
`m4'に処理を継続させて、
実際に問題を発生させていた例を実行することができます。

     (gdb) c
     Continuing.

     define(baz,defn(<QUOTE>foo<UNQUOTE>))

     baz
     0000

今度はうまくいきました。 新たにセットされた引用文字列は、
デフォルトの引用文字列と同じように機能しました。 問題の原因は、
プログラム内の2箇所のタイプ・ミスで、
長さの設定が正しく行われていないことにあったようです。 EOFを入力して、
`m4'を終了させましょう。

     C-d
     Program exited normally.

`Program exited normally.'というメッセージは、 GDBが出力したもので、
`m4'の実行が終了したことを意味しています。 GDBの `quit'コマンドで、
GDBセッションを終了することができます。

     (gdb) quit


File: gdb-ja.info,  Node: Invocation,  Next: Commands,  Prev: Sample Session,  Up: Top

2 GDBの起動・終了
*****************

本章では、 GDBの起動方法、 終了方法を説明します。 基本は、
以下の2つです。

   * `gdb'と入力してGDBを起動する

   * `quit'または`C-d'を入力してGDBを終了する

* Menu:

* Invoking GDB::                GDBの起動
* Quitting GDB::                GDBの終了
* Shell Commands::              GDBの中でのシェル・コマンドの使用


File: gdb-ja.info,  Node: Invoking GDB,  Next: Quitting GDB,  Prev: Invocation,  Up: Invocation

2.1 GDBの起動
=============

`gdb'というプログラムを実行することで、 GDBが起動されます。
ひとたび起動されると、 GDBは終了を指示されるまで、
端末からのコマンド入力を受け付けます。

   あるいは、 最初からGDBのデバッグ環境を指定するために、
様々な引数やオプションを指定して
`gdb'プログラムを実行することもできます。

   ここで説明するコマンドライン・オプションは、
様々な状況に対応するために設計されたものです。 環境によっては、
ここで説明するオプションのいくつかは、
事実上使用できない場合もあります。

   GDBの最も基本的な起動方法は、
デバッグされる実行プログラムの名前を引数に指定することです。

     gdb PROGRAM

起動時に、 実行プログラム名とともに、
コア・ファイルの名前を指定することもできます。

     gdb PROGRAM CORE

   あるいは、 既に実行中のプロセスをデバッグする場合には、
そのプロセスIDを第2引数に指定することもできます。

     gdb PROGRAM 1234

ここでは、 GDBはプロセスID `1234'のプロセスにアタッチします （ただし、
`1234'という名前のファイルが存在しないというのが条件です。 GDBは、
まずコア・ファイルの存在を確認します）。

   このような第2引数の利用が可能であるためには、
かなり完成されたオペレーティング・システムが必要になります。
ボード・コンピュータに接続して、
リモート・デバッガとしてGDBを使用する場合には、
そもそも「プロセス」という概念がないかもしれませんし、 多くの場合、
コア・ダンプというものもないでしょう。

   `gdb'を起動すると、 GDBの無保証性を説明する文章が表示されますが、
`-silent'オプションを指定することで、
これを表示しないようにすることもできます。

     gdb -silent

コマンドライン・オプションを指定することで、
GDBの起動方法をさらに制御することができます。 GDB自身に、
使用可能なオプションを表示させることができます。

     gdb -help

のようにgdbプログラムを実行することで、 使用可能なオプションがすべて、
その使用方法についての簡単な説明付きで表示されます （短縮して、 `gdb
-h'という形で実行しても同じ結果が得られます）。

   ユーザの指定したすべてのオプションと引数は、 順番に処理されます。
`-x'オプションが指定されている場合は特別で、
順序の違いに意味がでてきます。

* Menu:


* File Options::                ファイルの選択
* Mode Options::                モードの選択


File: gdb-ja.info,  Node: File Options,  Next: Mode Options,  Up: Invoking GDB

2.1.1 ファイルの選択
--------------------

起動されたGDBは、 指定された引数のうちオプション以外のものは、
実行ファイル名およびコア・ファイル名 （あるいはプロセスID）
であると解釈します。 これは、
`-se'オプションと`-c'オプションが指定されたのと同じことです （GDBは、
対応するオプション・フラグを持たない最初の引数を`-se'オプション付きと同等とみなし、
同じく対応するオプション・フラグを持たない第2の引数があれば、
これを`-c'オプション付きと同等とみなします）。

多くのオプションには、 完全形と短縮形があります。 以下の一覧では、
その両方を示します。 オプション名は、 他のオプションと区別がつけば、
最後まで記述しなくても、 GDBによって正しく認識されます
（オプション名には`-'ではなく`--'を使うことも可能ですが、
ここでは一般的な慣例にしたがうこととします）。

`-symbols FILE'
`-s FILE'
     FILEで指定されるファイルからシンボル・テーブルを読み込みます。

`-exec FILE'
`-e FILE'
     可能であれば、 FILEで指定されるファイルを、
     実行ファイルとして使います。 また、 このファイルを、
     コア・ダンプとともにデータを解析するために使います。

`-se FILE'
     FILEで指定されるファイルからシンボル・テーブルを読み込み、 かつ、
     このファイルを実行ファイルとして使います。

`-core FILE'
`-c FILE'
     FILEで指定されるファイルを解析すべきコア・ダンプとして使います。

`-c NUMBER'
     NUMBERで指定されるプロセスIDを持つプロセスに接続します。 これは、
     `attach'コマンドを実行するのと同等です （ただし、
     NUMBERで指定される名前のコア・ダンプ形式のファイルが存在する場合は、
     そのファイルをコア・ダンプとして読み込みます）。

`-command FILE'
`-x FILE'
     FILEで指定されるファイル内に記述されたGDBコマンドを実行します。
     *Note Command files: Command Files。

`-directory DIRECTORY'
`-d DIRECTORY'
     ソース・ファイルを検索するパスにDIRECTORYで指定されるディレクトリを追加します。

`-m'
`-mapped'
     _注意: このオプションは、
     すべてのシステムでサポートされているわけではない、
     オペレーティング・システムのある機能に依存しています。_
     システム上で、
     `mmap'システム・コールによるファイルのメモリへのマッピングが使用可能である場合、
     このオプションを使うことで、
     プログラムのシンボル情報を再利用可能なファイルとしてカレント・ディレクトリに書き出させることができます。
     仮にデバッグ中のプログラム名が`/tmp/fred'であるとすると、
     マップされたシンボル・ファイルは`./fred.syms'となります。
     この後のGDBデバッグ・セッションは、 このファイルの存在を検出し、
     そこから迅速にシンボル情報をマップします。 この場合、
     実行プログラムからシンボル情報を読み込むことはありません。

     `.syms'ファイルは、 GDBが実行されるホスト・マシンに固有のものです。
     このファイルは、
     内部のGDBシンボル・テーブルのイメージをそのまま保存したものです。
     これを、 複数のホスト・プラットフォーム上において、
     共有することはできません。

`-r'
`-readnow'
     シンボル・ファイル内のシンボル・テーブル全体をただちに読み込みます。
     デフォルトの動作では、
     シンボル情報は必要になるたびに徐々に読み込まれます。
     このオプションを使うと起動までに時間がかかるようになりますが、
     その後の処理は速くなります。

   `-mapped'オプションと`-readnow'オプションは、
完全なシンボル情報を含む`.syms'ファイルを作成するために、
通常は一緒に指定されます （`.syms'ファイルに関する詳細については、
*Note Commands to specify files: Files）。
後に使用する目的で`.syms'を作成するだけで、
それ以外には何もしないようにするためのGDBの単純な起動方法は、
以下のとおりです。

     	gdb -batch -nx -mapped -readnow programname


File: gdb-ja.info,  Node: Mode Options,  Prev: File Options,  Up: Invoking GDB

2.1.2 モードの選択
------------------

GDBを様々なモードで実行することが可能です。 例えば、
batchモードやquietモードなどがあります。

`-nx'
`-n'
     初期化ファイルに記述されたコマンドを実行しません （通常、
     初期化ファイルは`.gdbinit'という名前です。 ただし、
     PC上では`gdb.ini'となります）。 通常は、
     すべてのコマンド・オプションと引数が処理された後に、
     初期化ファイル内のコマンドが実行されます。 *Note Command files:
     Command Files。

`-quiet'
`-q'
     紹介メッセージおよびコピーライト・メッセージを表示しません。
     これらのメッセージは、 batchモードでも表示されません。

`-batch'
     batchモードで実行されます。
     `-x'オプションで指定されたすべてのコマンド・ファイルを処理した後、
     終了コード`0'で終了します
     （`-n'オプションによって禁止されていなければ、
     初期化ファイル内に記述されているすべてのコマンドも実行されます）。
     コマンド・ファイルに記述されたGDBコマンドの実行中にエラーが発生した場合には、
     `0'以外の終了コードで終了します。

     batchモードはGDBをフィルタとして実行する場合に便利です。 例えば、
     あるプログラムを別のコンピュータ上にダウンロードして実行する場合などです。
     このような使い方の邪魔にならないよう、

          Program exited normally.

     というメッセージは、 batchモードでは表示されません
     （通常このメッセージは、
     GDBの管理下で実行中のプログラムが終了するときに、
     必ず表示されます）。

`-cd DIRECTORY'
     カレント・ディレクトリではなく、
     DIRECTORYで指定されたディレクトリを作業ディレクトリとして、
     GDBを実行します。

`-fullname'
`-f'
     GNU EmacsがGDBをサブ・プロセスとして起動するとき、
     このオプションを指定します。 このオプションは、
     スタック・フレームを表示するときには、
     必ず完全なファイル名と行番号を標準的な認識可能な書式で出力するようGDBに対して指示するものです
     （スタック・フレームは、 例えば、
     プログラムの実行が停止されたときに必ず表示されます）。
     認識可能な書式とは、 先頭に2つの`\032'文字、
     続いてコロンで区切られたファイル名、 行番号、 桁位置、 最後に改行、
     というものです。 Emacs-GDBインターフェイス・プログラムは、
     フレームに対応するソース・コードを表示させる命令として、
     2つの`\032'文字を使用します。

`-b BPS'
     GDBによってリモート・デバッグ用に使用されるシリアル・インターフェイスの回線速度
     （ボーレートあるいはBPS） を設定します。

`-tty DEVICE'
     プログラムの標準入力および標準出力としてDEVICEを使用して実行します。



File: gdb-ja.info,  Node: Quitting GDB,  Next: Shell Commands,  Prev: Invoking GDB,  Up: Invocation

2.2 GDBの終了
=============

`quit'
     GDBを終了するためには、 `quit'コマンド （省略形は`q'）
     を使用するか、 あるいは、 ファイルの終端文字 （通常は`C-d'）
     を入力します。 EXPRESSIONを指定しない場合、 GDBは正常終了します。
     EXPRESSIONが指定された場合、
     EXPRESSIONの評価結果をエラー・コードとして終了します。

   割り込み （多くの場合`C-c'） はGDBを終了させません。 割り込みは通常、
実行中のGDBコマンドを終了させ、 GDBのコマンド・レベルに復帰させます。
割り込み文字は、 いつ入力しても安全です。 というのは、
割り込みの発生が危険である間は、 GDBが割り込みの発生を抑止するからです。

   アタッチされたプロセスやデバイスを制御するために
GDBを使用していた場合、 `detach'コマンドでそれを解放することができます
（*note Debugging an already-running process: Attach.）。


File: gdb-ja.info,  Node: Shell Commands,  Prev: Quitting GDB,  Up: Invocation

2.3 シェル・コマンド
====================

デバッグ・セッションの途中でシェル・コマンドを実行する必要がある場合、
GDBを終了したり一時停止させたりする必要はありません。
`shell'コマンドを使用することができます。

`shell COMMAND STRING'
     COMMAND
     STRINGで指定されるコマンド文字列を実行するために標準シェルを起動します。
     `SHELL'環境変数が設定されていれば、
     その値が実行されるべきシェルを決定します。
     `SHELL'環境変数が設定されていなければ、
     GDBは`/bin/sh'を実行します。

   開発環境ではしばしば`make'ユーティリティが必要とされます。
GDB内部で`make'ユーティリティを使用する場合は、
`shell'コマンドを使用する必要はありません。

`make MAKE-ARGS'
     MAKE-ARGSで指定される引数とともに`make'プログラムを実行します。
     これは、 `shell make MAKE-ARGS'を実行するのと同じことです。


File: gdb-ja.info,  Node: Commands,  Next: Running,  Prev: Invocation,  Up: Top

3 GDB コマンド
**************

GDBコマンドの名前は、 最初の2、 3文字に省略することができます。 ただし、
省略されたコマンド名があいまいであってはなりません。 さらに、
同じGDBコマンドを連続して使用する場合には、
<RET>キーを押すだけで十分です。 また、 <TAB>キーを押すことで、
途中まで入力されたコマンド名を補完させることができます
（複数の補完候補がある場合には、 その一覧を表示します）。

* Menu:

* Command Syntax::              GDBに対するコマンドの指定
* Completion::                  コマンド名の補完
* Help::                        ヘルプの表示


File: gdb-ja.info,  Node: Command Syntax,  Next: Completion,  Prev: Commands,  Up: Commands

3.1 コマンドの構文
==================

GDBコマンドは1行で入力されます。 1行の長さには上限がありません。 行は、
コマンド名で始まり、
コマンド名によって意味が決まる引数がそれに続きます。 例えば、
`step'コマンドは`step'を実行する回数を引数に取ります。 例えば、 `step
5'のようになります。 `step'コマンドは引数なしでも実行可能です。
コマンドによっては、 全く引数を受け付けないものもあります。

   GDBコマンド名は省略可能です。 ただし、
省略された名前があいまいなものではあってはなりません。 省略形は、
それぞれのコマンドのドキュメント内に記載されています。 場合によっては、
あいまいな省略形も許されることがあります。 例えば、 `s'は、
文字`s'で始まるコマンドがほかにも存在するにもかかわらず、
`step'コマンドの省略形として特別に定義されています。
ある省略形が使用可能か否かは、
それを`help'コマンドへの引数として使用することで判定可能です。

   GDBへの入力として空行を与える （<RET>キーだけを押す） ことは、
1つ前に実行したコマンドを繰り返すということを意味します。 ただし、
いくつかのコマンド （例えば、`run'コマンド）は、
この方法で実行を繰り返すことはできません。
意図に反して再実行してしまうと問題を引き起こす可能性があるため、
繰り返し実行してほしくないようなコマンドの場合です。

   `list'コマンドと`x'コマンドは、 <RET>キーにより繰り返し実行すると、
新たに引数が生成されて実行されるので、
前回実行されたときと全く同様の状態で繰り返し実行されるわけではありません。
こうすることで、
ソース・コードの内容やメモリの内容を容易に調べることができます。

   GDBは、 別の用途でも<RET>キーを使用します。
`more'ユーティリティと同様の方法で、 長い出力を分割して表示する場合です
（*note Screen size: Screen Size.）。 このような場合、
<RET>キーを余分に押してしまうことは往々にしてありえるので、
GDBはこのような表示方法を使用しているコマンドについては、
<RET>キーによる繰り返し実行を行いません。

   テキストの中に`#'記号があると、
そこから行末まではコメントになります。 コメントの部分は実行されません。
これは、 特にコマンド・ファイルの中で便利です （*note Command files:
Command Files.）。


File: gdb-ja.info,  Node: Completion,  Next: Help,  Prev: Command Syntax,  Up: Commands

3.2 コマンド名の補完
====================

途中まで入力されたコマンド名は、 それがあいまいでなければ、
GDBが残りの部分を補完してくれます。 また、 いつでも、
コマンド名の補完候補の一覧を表示してくれます。 この機能は、
GDBコマンド名、 GDBサブ・コマンド名、
ユーザ・プログラムのシンボル名に対して有効です。

   GDBに単語の残りの部分を補完させたい場合には、 <TAB>キーを押します。
補完候補が1つしか存在しない場合、 GDBは残りの部分を補完し、
ユーザがコマンドを （<RET>キーを押すことで） 完結させるのを待ちます。
例えば、 ユーザが以下のように入力したとしましょう。

     (gdb) info bre <TAB>

GDBは`breakpoints'という単語の残りの部分を補完します。 なぜなら、
`info'コマンドのサブ・コマンドのうち、
`bre'で始まるのはこの単語だけだからです。

     (gdb) info breakpoints

この時点で、 ユーザは<RET>キーを押して`info
breakpoints'コマンドを実行するか、
あるいは`breakpoints'コマンドが実行したいコマンドではなかった場合には、
バックスペース・キーを押してこれを消去してから、
他の文字を入力することができます （最初から`info
breakpoints'コマンドを実行するつもりであれば、
コマンド名補完機能ではなくコマンド名の省略形を利用して、 `info
bre'と入力した後、 ただちに<RET>キーを押してもいいでしょう）。

   <TAB>キーが押されたときに、 2つ以上の補完候補が存在する場合、
GDBはベル音を鳴らします。
さらにいくつか文字を入力してから補完を再度試みることも可能ですし、
単に続けて<TAB>キーを押すことも可能です。 後者の場合、
GDBは補完候補の全一覧を表示します。 例えば、
`make_'で始まる名前を持つサブルーチンにブレイクポイントを設定したいような場合に、
`b
make_'まで入力して<TAB>キーを入力したところベル音が鳴ったとしましょう。
ここで続けて<TAB>キーを入力すると、
プログラム内の`make_'で始まるすべてのサブルーチン名が表示されます。
例えば、 以下のように入力したとします。

     (gdb) b make_ <TAB>

ここでGDBはベル音を鳴らします。 もう一度<TAB>キーを入力すると、
以下のように表示されます。

     make_a_section_from_file     make_environ
     make_abs_section             make_function_type
     make_blockvector             make_pointer_type
     make_cleanup                 make_reference_type
     make_command                 make_symbol_completion_list
     (gdb) b make_

補完候補を表示した後、 ユーザが続きを入力できるよう、
GDBは途中まで入力された文字列 （ここでは`b make_'） を再表示します。

   最初から補完候補の一覧を表示したいのであれば、
<TAB>キーを2回押す代わりに`M-?'を入力することもできます。 ここで、
`M-?'というのは`<META> ?'を意味します。 これを入力するには、
キーボード上に<META>シフト・キーとして指定されたキーがあれば、
それを押しながら`?'を入力します。 <META>シフト・キーがない場合には、
<ESC>キーを押した後、 `?'を入力します。

   ときには、 入力したい文字列が、 論理的には『単語』であっても、
GDBが通常は単語の一部に含めない括弧のような文字を含む場合があります。
このような場合に単語の補完機能を使用するためには、
GDBコマンド内において、 そのような単語を`'' （単一引用符） で囲みます。

   このようなことが必要になる可能性が最も高いのは、
C++関数名を入力するときでしょう。 これは、
C++が関数のオーバーローディング （引数の型の違いによって識別される、
同一の名前を持つ関数の複数の定義） をサポートしているからです。 例えば、
関数`name'にブレイクポイントを設定する場合、
それが`int'型のパラメータを取る`name(int)'なのか、
それとも`float'型のパラメータを取る`name(float)'なのかをはっきりさせる必要があります。
このような場合に単語の補完機能を使用するには、
単一引用符`''を関数名の前に入力します。 こうすることによって、
<TAB>キーまたは`M-?'キーが押されて単語補完が要求されたときに、
補完候補の決定には通常よりも多くのことを検討する必要のあることがGDBに通知されます。

     (gdb) b 'bubble( <M-?>
     bubble(double,double)    bubble(int,int)
     (gdb) b 'bubble(

   場合によっては、
名前の補完をするには引用符を使用する必要があるということを、
GDBが自分で認識できることもあります。 このような場合、
ユーザが引用符を入力していなくても、 GDBが （可能な限り補完を行いつつ）
引用符を挿入してくれます。

     (gdb) b bub <TAB>
GDBは入力された1行を以下のように変更し、
     ベル音を鳴らします。
     (gdb) b 'bubble(

一般的には、
オーバーロードされたシンボルに対して補完が要求された際に引数リストがまだ入力されていないと、
GDBは、 引用符が必要であると判断します （そして実際に挿入します）。

   オーバーロードされた関数に関する情報については、 *note C++
expressions: Cplus expressions.。 コマンド`set overload-resolution
off'を使用すれば、 オーバーロードの解決を無効化することができます。
*note GDB features for C++: Debugging C plus plus.。


File: gdb-ja.info,  Node: Help,  Prev: Completion,  Up: Commands

3.3 ヘルプの表示
================

`help'コマンドを使うことで、
GDBコマンドに関するヘルプ情報をGDB自身に表示させることができます。

`help'
`h'
     `help'コマンド （省略形は`h'） を引数なしで実行することで、
     コマンドのクラス名の簡単な一覧を表示させることができます。

          (gdb) help
          List of classes of commands:

          running -- Running the program
          stack -- Examining the stack
          data -- Examining data
          breakpoints -- Making program stop at certain points
          files -- Specifying and examining files
          status -- Status inquiries
          support -- Support facilities
          user-defined -- User-defined commands
          aliases -- Aliases of other commands
          obscure -- Obscure features

          Type "help" followed by a class name for a list of
          commands in that class.
          Type "help" followed by command name for full
          documentation.
          Command name abbreviations are allowed if unambiguous.
          (gdb)

`help CLASS'
     一般的なクラス名を引数に指定することで、
     そのクラスに属するコマンドの一覧を表示させることができます。
     `status'クラスを指定した場合の表示例を以下に示します。

          (gdb) help status
          Status inquiries.

          List of commands:

          show -- Generic command for showing things set
           with "set"
          info -- Generic command for printing status

          Type "help" followed by command name for full
          documentation.
          Command name abbreviations are allowed if unambiguous.
          (gdb)

`help COMMAND'
     `help'の引数にコマンド名を指定することで、
     そのコマンドの使用法に関する簡単な説明が表示されます。

`complete ARGS'
     `complete ARGS'コマンドにコマンド名の先頭の部分を指定すると、
     コマンド名の補完候補の一覧を表示します。 ARGSには、
     補完されるべきコマンド名の先頭の文字列を指定します。 例えば、

          complete i

     は、以下のような結果を表示します。

          info
          inspect
          ignore

     これは、 GNU Emacsでの使用を想定したものです。

   `help'コマンドに加えて、
GDBの`info'コマンドおよび`show'コマンドを使用することで、
ユーザ・プログラムの状態やGDBの状態を問い合わせることができます。
どちらのコマンドも、 多くの観点からの問い合わせをサポートしています。
このマニュアルでは、 それぞれを適切と思われる箇所で紹介しています。
索引の`info'や`show'の部分に、
それぞれのサブ・コマンドの紹介されているページが示されています。 *Note
Index::。

`info'
     このコマンド （省略形は`i'） は、
     ユーザ・プログラムの状態を表わす情報を表示するものです。 例えば、
     `info args'によってユーザ・プログラムに与えられた引数を、 `info
     registers'によって現在使用中のレジスタの一覧を、 `info
     breakpoints'によってユーザが設定したブレイクポイントの一覧を、
     それぞれ表示することができます。 `help info'によって、
     `info'コマンドのサブ・コマンドの完全な一覧が表示されます。

`set'
     `set'コマンドによって、
     ある式の評価結果を環境変数に割り当てることができます。 例えば、
     GDBのプロンプト文字列を$記号に変更するには、 `set prompt
     $'を実行します。

`show'
     `info'コマンドとは異なり、
     `show'コマンドはGDB自身の状態を表わす情報を表示するものです。
     `show'コマンドで表示可能な状態はすべて、
     対応する`set'コマンドで変更可能です。 例えば、
     数値の表示に使用する基数は `set radix'コマンドで制御できます。
     現在どの基数が使用されているかを単に知るためには、 `show
     radix'コマンドを使用します。

     変更可能なすべてのパラメータとそれらの現在の値を表示するためには、
     `show'コマンドを引数なしで実行します。 また、 `info
     set'コマンドを使用することもできます。 どちらのコマンドも、
     同じ情報を出力します。

   以下に、 対応する`set'コマンドを持たないという意味で例外的である、
3つの`show'サブ・コマンドを示します。

`show version'
     実行中のGDBのバージョンを表示します。 GDBに関する障害レポートには、
     この情報を含める必要があります。
     もしも異なるバージョンのGDBを複数使用しているのであれば、
     ときには現在実行しているGDBのバージョンをはっきりさせたいこともあるでしょう。
     GDBのバージョンが上がるにつれ、 新しいコマンドが導入され、
     古いコマンドはサポートされなくなるかもしれません。
     バージョン番号は、 GDBの起動の際にも表示されます。

`show copying'
     GDBのコピー作成許可に関する情報が表示されます。

`show warranty'
     GNUの『無保証 （NO WARRANTY）』声明文が表示されます。


File: gdb-ja.info,  Node: Running,  Next: Stopping,  Prev: Commands,  Up: Top

4 GDB配下でのプログラムの実行
*****************************

プログラムをGDB配下で実行するには、
コンパイル時にデバッグ情報を生成する必要があります。
ユーザが選択した環境で、 必要に応じて引数を指定して、
GDBを起動することができます。
プログラムの入力元と出力先をリダイレクトすること、
既に実行中のプロセスをデバッグすること、
子プロセスを終了させることもできます。

* Menu:

* Compilation::                 デバッグのためのコンパイル
* Starting::                    ユーザ・プログラムの起動

* Arguments::                   ユーザ・プログラムの引数
* Environment::                 ユーザ・プログラムの環境

* Working Directory::           ユーザ・プログラムの作業ディレクトリ
* Input/Output::                ユーザ・プログラムの入出力
* Attach::                      既に実行中のプロセスのデバッグ
* Kill Process::                子プロセスの終了

* Process Information::         追加のプロセス情報

* Threads::                     マルチスレッド・プログラムのデバッグ
* Processes::                   マルチプロセス・プログラムのデバッグ


File: gdb-ja.info,  Node: Compilation,  Next: Starting,  Prev: Running,  Up: Running

4.1 デバッグのためのコンパイル
==============================

プログラムを効率的にデバッグするためには、
そのプログラムのコンパイル時にデバッグ情報を生成する必要があります。
このデバッグ情報はオブジェクト・ファイルに格納されます。 この情報は、
個々の変数や関数の型、
ソース・コード内の行番号と実行形式コードのアドレスとの対応などを含みます。

   デバッグ情報の生成を要求するには、
コンパイラの実行時に`-g'オプションを指定します。

   多くのCコンパイラでは、
`-g'オプションと`-O'オプションを同時に指定することができません。
このようなコンパイラでは、
デバッグ情報付きの最適化された実行ファイルを生成することができません。

   GNUのCコンパイラであるGCCは、 `-O'オプションの有無にかかわらず、
`-g'オプションが指定できます。 したがって、
最適化されたコードをデバッグすることが可能です。
プログラムをコンパイルするときには、
_常に_`-g'オプションを指定することをお勧めします。
自分のプログラムは正しいと思うかもしれませんが、
自分の幸運を信じて疑わないというのは無意味なことです。

   `-g
-O'オプションを指定してコンパイルされたプログラムをデバッグするときには、
オプティマイザがコードを再調整していることを忘れないでください。
デバッガは、 実際に存在するコードの情報を表示します。
実行されるパスがソース・ファイルの記述と一致していなくても、
あまり驚かないでください。 これは極端な例ですが、
定義されているが実際には使われていない変数を、 GDBは認識しません。
なぜなら、 コンパイラの最適化処理により、
そのような変数は削除されるからです。

   命令スケジューリング機能を持つマシンなどでは、
`-g'を指定してコンパイルされたプログラムでは正しく動作することが、 `-g
-O'を指定してコンパイルされたプログラムでは正しく動作しないということがあります。
`-g
-O'を指定してコンパイルされたプログラムのデバッグで何かおかしな点があれば、
`-g'だけを指定してコンパイルしてみてください。
これで問題が解決するようであれば、 （再現環境と一緒に）
障害として私たちに報告してください。

   古いバージョンのGNU Cコンパイラは、
デバッグ情報の生成のためのオプションの1つとして
`-gg'をサポートしていました。
現在のGDBはこのオプションをサポートしていません。 お手元のGNU
Cコンパイラにこのオプションがあるようであれば、
それは使わないでください。


File: gdb-ja.info,  Node: Starting,  Next: Arguments,  Prev: Compilation,  Up: Running

4.2 ユーザ・プログラムの起動
============================

`run'
`r'
     GDB配下でユーザ・プログラムの実行を開始するには`run'コマンドを使用してください。
     （VxWorks以外の環境では）
     最初にプログラム名を指定する必要があります。 これには、
     GDBへの引数を使用する方法 （*note Getting In and Out of GDB:
     Invocation.） と、
     `file'コマンドまたは`exec-file'コマンドを使用する方法 （*note
     Commands to specify files: Files.） とがあります。


   プロセスをサポートする環境でプログラムを実行している場合、
`run'コマンドは下位プロセスを生成し、
そのプロセスにプログラムを実行させます
（プロセスをサポートしていない環境では、
`run'コマンドはプログラムの先頭アドレスにジャンプします）。

   プログラムの実行は、
上位プロセスから受け取る情報によって影響されます。
GDBはこの情報を指定する手段を提供しています。 これは、
ユーザ・プログラムが起動される_前_に実行されていなければなりません
（ユーザ・プログラムの実行後にその情報を変更することも可能ですが、
その変更結果は、 次にプログラムを実行したときに初めて有効になります）。
この情報は、 4つに分類することができます。

_引数_
     ユーザ・プログラムに与える引数を、
     `run'コマンドへの引数として指定します。
     ターゲット上でシェルが使用可能であれば、
     引数を表現するのに通常使用する手法 （例えば、
     ワイルドカード拡張や変数による代替など） が利用できるよう、
     シェルを経由して引数を渡します。 UNIXシステムでは、
     `SHELL'環境変数によって、
     使用されるシェルを選択することができます。 *Note Your program's
     arguments: Arguments。

_環境_
     ユーザ・プログラムは通常、 GDBの環境を継承します。 GDBの`set
     environment'コマンドと `unset environment'コマンドを使用して、
     ユーザ・プログラムの実行に影響する環境の一部を変更することができます。
     *Note Your program's environment: Environment。

_作業ディレクトリ_
     ユーザ・プログラムはGDBの作業ディレクトリを継承します。
     GDBの作業ディレクトリは、 GDBの`cd'コマンドで設定可能です。 *Note
     Your program's working directory: Working Directory。

_標準入力、標準出力_
     ユーザ・プログラムは通常、 GDBが標準入力、
     標準出力として使用しているのと同一のデバイスを、 標準入力、
     標準出力として使用します。 `run'コマンドのコマンド・ライン上で、
     標準入力、 標準出力をリダイレクトすることも可能です。 また、
     `tty'コマンドによって別のデバイスを割り当てることも可能です。
     *Note Your program's input and output: Input/Output。

     _注意:_ 入出力のリダイレクトは機能しますが、
     デバッグ中のプログラムの出力を、
     パイプを使用して他のプログラムに渡すことはできません。
     このようなことをすると、 GDBは誤って、
     別のプログラムのデバッグを開始してしまうでしょう。

   `run'コマンドを実行すると、
ユーザ・プログラムはすぐに実行を始めます。
プログラムを停止させる方法については、 *Note Stopping and continuing:
Stopping。 プログラムが停止すると、
`print'コマンドまたは`call'コマンドを使用して、
プログラム内の関数を呼び出すことができます。 *Note Examining Data:
Data。

   GDBが最後にシンボル情報を読み込んだ後に、
シンボル・ファイルの修正タイムスタンプが変更されている場合、
GDBはシンボル・テーブルを破棄し再読み込みを行います。 この場合、 GDBは、
その時点におけるブレイクポイントの設定を保持しようと試みます。


File: gdb-ja.info,  Node: Arguments,  Next: Environment,  Prev: Starting,  Up: Running

4.3 ユーザ・プログラムの引数
============================

ユーザ・プログラムへの引数は、
`run'コマンドへの引数によって指定可能です。 それはまずシェルに渡され、
ワイルドカードの展開やI/Oのリダイレクトの後、 プログラムに渡されます。
`SHELL'環境変数によって、 GDBの使用するシェルが指定されます。
`SHELL'環境変数が定義されていないと、 GDBは`/bin/sh'を使用します。

   引数を指定せずに `run'コマンドを実行すると、
前回`run'コマンドを実行したときの引数、 または、 `set
args'コマンドでセットされた引数が使用されます。

`set args'
     ユーザ・プログラムが次に実行されるときに使用される引数を指定します。
     `set args'が引数なしで実行された場合、 `run'コマンドは、
     ユーザ・プログラムを引数なしで実行します。
     一度プログラムに引数を指定して実行すると、
     次にプログラムを引数なしで実行する唯一の方法は、
     `run'コマンドを実行する前に `set args'コマンドを実行することです。

`show args'
     ユーザ・プログラムが実行されるときに渡される引数を表示します。


File: gdb-ja.info,  Node: Environment,  Next: Working Directory,  Prev: Arguments,  Up: Running

4.4 ユーザ・プログラムの環境
============================

"環境"とは、 環境変数とその値の集合のことです。 環境変数は、
慣例として、 ユーザ名、 ユーザのホーム・ディレクトリ、 端末タイプ、
実行プログラムのサーチ・パスなどを記録します。 通常、
環境変数はシェル上で設定され、
ユーザの実行するすべてのプログラムによって継承されます。
デバッグ時には、 GDBを終了・再起動せずに環境を変更して、
ユーザ・プログラムを実行できると便利でしょう。

`path DIRECTORY'
     DIRECTORYで指定されるディレクトリを環境変数`PATH'
     （実行ファイルのサーチ・パス） の先頭に追加します。 これは、
     GDBとユーザ・プログラムの両方に対して有効です。 `:' （コロン）
     またはスペースで区切られた複数のディレクトリを指定することもできます。
     環境変数`PATH'の中に既にDIRECTORYが含まれている場合には、
     DIRECTORYは環境変数`PATH'の先頭に移動されます。 これにより、
     DIRECTORYはより早く検索されることになります。

     文字列`$cwd'によって、
     GDBがパスを検索する時点における作業ディレクトリを参照することができます。
     `.' （ピリオド） を使用すると、
     `path'コマンドを実行したディレクトリを参照することになります。
     DIRECTORY引数に`.' （ピリオド） が含まれていると、 GDBはまずそれを
     （カレント・ディレクトリに） 置き換えてから、
     サーチ・パスに追加します。

`show paths'
     実行ファイルを検索するパスの一覧
     （環境変数`PATH'の値）を表示します。

`show environment [VARNAME]'
     ユーザ・プログラム起動時に渡される環境変数VARNAMEの値を表示します。
     VARNAMEが指定されない場合は、
     プログラムに渡されるすべての環境変数の名前と値が表示されます。
     `environment'は`env'に省略可能です。

`set environment VARNAME [=] VALUE'
     環境変数VARNAMEの値としてVALUEをセットします。
     値の変更はユーザ・プログラムに対してのみ有効で、
     GDBに対しては無効です。 VALUEには任意の文字列が指定可能です。
     環境変数の値は単なる文字列であり、
     その解釈はユーザ・プログラムに委ねられています。
     VALUEは必須パラメータではありません。 省略された場合には、
     変数には空文字列がセットされます。

     例えば、 以下のコマンドは、
     後にUNIXプログラムが実行されるときのユーザ名として`foo'をセットします
     （`='の前後のスペースは見やすくするためのもので、
     実際には必要ありません）。

          set env USER = foo

`unset environment VARNAME'
     ユーザ・プログラムに渡される環境から、
     環境変数VARNAMEを削除します。 これは、 `set env VARNAME
     ='とは異なります。 `unset environment'は、
     環境変数の値として空文字列をセットするのではなく、
     環境変数そのものを環境から削除します。

   _注意:_ GDBは、 環境変数`SHELL'により指定されるシェル
（環境変数`SHELL'が設定されていない場合には`/bin/sh'）
を使用してプログラムを実行します。
`SHELL'環境変数の指定するシェルが初期化ファイルを実行するものである場合
（例えば、 C-shellの`.cshrc'、 BASHの`.bashrc'）、
初期化ファイルの中で設定された環境変数はユーザ・プログラムに影響を与えます。
環境変数の設定は、 `.login'や`.profile'のように、
ユーザがシステム内に入るときに実行されるファイルに移したほうがよいでしょう。


File: gdb-ja.info,  Node: Working Directory,  Next: Input/Output,  Prev: Environment,  Up: Running

4.5 ユーザ・プログラムの作業ディレクトリ
========================================

`run'コマンドで実行されるユーザ・プログラムは、
実行時のGDBの作業ディレクトリを継承します。 GDBの作業ディレクトリは、
もともと親プロセス （通常はシェル） から継承したものですが、
`cd'コマンドによって、
GDBの中から新しい作業ディレクトリを指定することができます。

   GDBの作業ディレクトリは、
GDBによって操作されるファイルを指定するコマンドに対して、
デフォルト・ディレクトリとして機能します。 *Note Commands to specify
files: Files。

`cd DIRECTORY'
     GDBの作業ディレクトリをDIRECTORYにします。

`pwd'
     GDBの作業ディレクトリを表示します。


File: gdb-ja.info,  Node: Input/Output,  Next: Attach,  Prev: Working Directory,  Up: Running

4.6 ユーザ・プログラムの入出力
==============================

GDB配下で実行されるプログラムは、 デフォルトでは、
GDBと同一の端末に対して入出力を行います。 GDBは、
ユーザとのやりとりのために、 端末モードをGDB用に変更します。 このとき、
ユーザ・プログラムが使用していた端末モードは記録され、
ユーザ・プログラムを継続実行すると、 そのモードに戻ります。

`info terminal'
     ユーザ・プログラムが使用している端末モードに関してGDBが記録している情報を表示します。

   `run'コマンドにおいてシェルのリダイレクト機能を使用することによって、
ユーザ・プログラムの入出力をリダイレクトすることが可能です。 例えば、

     run > outfile

はユーザ・プログラムの実行を開始し、
その出力をファイル`outfile'に書き込みます。

   ユーザ・プログラムの入出力先を指定する別の方法に、
`tty'コマンドがあります。 このコマンドはファイル名を引数として取り、
そのファイルを後に実行される`run'コマンドのデフォルトの入出力先とします。
このコマンドはまた、
後の`run'コマンドにより生成される子プロセスを制御する端末を変更します。
例えば、

     tty /dev/ttyb

は、 それ以降に実行される`run'コマンドによって起動されるプロセスの
デフォルトの入出力先および制御端末を`/dev/ttyb'端末とします。

   `run'コマンド実行時に明示的にリダイレクト先を指定することで、
`tty'コマンドで指定された入出力装置を変更することができますが、
制御端末の設定は変更できません。

   `tty'コマンドを使用した場合も、
`run'コマンドで入力をリダイレクトした場合も、
ユーザ・プログラムの入力元だけが変更されます。
これらのコマンドを実行しても、
GDBの入力元は、ユーザの使用している端末のままです。


File: gdb-ja.info,  Node: Attach,  Next: Kill Process,  Prev: Input/Output,  Up: Running

4.7 既に実行中のプロセスのデバッグ
==================================

`attach PROCESS-ID'
     GDBの外で起動され、 既に実行中のプロセスにアタッチします （`info
     files'コマンドで、
     現在デバッグ対象となっているプログラムの情報が表示されます）。
     このコマンドは、 プロセスIDを引数に取ります。
     UNIXプロセスのプロセスIDを知るのに通常使用する方法は、
     `ps'ユーティリティ、 または、 シェル・コマンドの`jobs
     -l'の実行です。

     `attach'コマンドを実行後<RET>キーを押しても、
     コマンドは再実行されません。

   `attach'コマンドを使用するには、
プロセスをサポートする環境でユーザ・プログラムを実行する必要があります。
例えば、
オペレーティング・システムの存在しないボード・コンピュータのような環境で動作するプログラムに対して、
`attach'コマンドを使うことはできません。 さらに、 ユーザは、
プロセスに対してシグナルを送信する権利を持っている必要があります。

   `attach'コマンドを使用すると、 デバッガは、
まずカレントな作業ディレクトリの中で、
プロセスにより実行されているプログラムを見つけようとします。
（プログラムが見つからなければ） 次に、 ソース・ファイルのサーチ・パス
（*note Specifying source directories: Source Path.） を使用して、
プログラムを見つけようとします。 `file'コマンドを使用して、
プログラムをロードすることも可能です。 *Note Commands to Specify Files:
Files。

   指定されたプロセスをデバッグする準備が整った後に、
GDBが最初にすることは、 そのプロセスを停止することです。
`run'コマンドを使用してプロセスを起動した場合は、
通常使用可能なすべてのGDBコマンドを使用して、
アタッチされたプロセスの状態を調べたり変更したりすることができます。
ブレイクポイントの設定、 ステップ実行、 継続実行、
記憶域の内容の変更が可能です。 プロセスの実行を継続したいのであれば、
GDBがプロセスにアタッチした後に、
`continue'コマンドを使用することができます。

`detach'
     アタッチされたプロセスのデバッグが終了した場合には、
     `detach'コマンドを使用してそのプロセスをGDBの管理から解放することができます。
     プロセスからディタッチしても、 そのプロセスは実行を継続します。
     `detach'コマンド実行後は、 ディタッチされたプロセスと
     GDBは互いに完全に依存関係がなくなり、
     `attach'コマンドによる別のプロセスへのアタッチや、
     `run'コマンドによる別のプロセスの起動が可能になります。
     `detach'コマンドを実行後<RET>キーを押しても、
     `detach'コマンドは再実行されません。

   プロセスがアタッチされている状態で、
GDBを終了したり`run'コマンドを使用したりすると、
アタッチされたプロセスを終了させてしまいます。 デフォルトの状態では、
このようなことを実行しようとすると、 GDBが確認を求めてきます。
この確認処理を行うか否かは、 `set confirm'コマンドで設定可能です
（*note Optional warnings and messages: Messages/Warnings.）。


File: gdb-ja.info,  Node: Kill Process,  Next: Process Information,  Prev: Attach,  Up: Running

4.8 子プロセスの終了
====================

`kill'
     GDB配下で実行しているユーザ・プログラムのプロセスを終了させます。

   このコマンドは、 実行中のプロセスではなく、
コア・ダンプをデバッグしたいときに便利です。 GDBは、
ユーザ・プログラムの実行中は、 コア・ダンプ・ファイルを無視します。

   いくつかのオペレーティング・システム上では、
GDBの管理下でブレイクポイントを設定されている状態のプログラムを、
GDBの外で実行することができません。 このような場合、
`kill'コマンドを使用することで、デバッガの外でのプログラムの実行が可能になります。

   `kill'コマンドは、 プログラムを再コンパイル、
再リンクしたい場合にも便利です。 というのは、 多くのシステムでは、
プロセスとして実行中の実行ファイルを更新することはできないからです。
次に`run'コマンドを実行したときに、 GDBは、
実行ファイルが変更されていることを認識し、
シンボル・テーブルを再度読み込みます
（この際、その時点でのブレイクポイントの設定を維持しようと試みます）。


File: gdb-ja.info,  Node: Process Information,  Next: Threads,  Prev: Kill Process,  Up: Running

4.9 プロセス情報
================

いくつかのオペレーティング・システムは、
`/proc'と呼ばれる便利な機能を提供しています。 これは、
ファイル・システム関連のサブルーチンを使用して、
実行中プロセスのイメージを調べるのに使用することができます。 GDBが、
この機能を持つオペレーティング・システム用に構成されていれば、 `info
proc'コマンドを使用することで、
ユーザ・プログラムを実行しているプロセスに関するいくつかの情報を知ることができます。
`info proc'は、 `procfs'をサポートするSVR4システム上でのみ機能します。

`info proc'
     プロセスに関して入手可能な情報を要約して出力します。

`info proc mappings'
     プログラムがアクセスすることのできるアドレス範囲を表示します。
     出力情報には、
     それぞれのアドレス範囲に対してユーザ・プログラムが持つ読み込み権、
     書き込み権、 実行権の情報が含まれます。

`info proc times'
     ユーザ・プログラムおよびその子 （プロセス） の起動時刻、
     ユーザ・レベルのCPU消費時間、
     システム・レベルのCPU消費時間を表示します。

`info proc id'
     ユーザ・プログラムに関連のあるプロセスのID情報を表示します。
     ユーザ・プログラムのプロセスID、 親（プロセス）のプロセスID、
     プロセス・グループID、 セッションIDを出力します。

`info proc status'
     プロセスの状態に関する一般的な情報を出力します。
     プロセスが停止している場合は、 停止した理由、
     （シグナルを受信した場合には）
     受信したシグナルが出力情報に含まれます。

`info proc all'
     プロセスに関する上記の情報をすべて表示します。


File: gdb-ja.info,  Node: Threads,  Next: Processes,  Prev: Process Information,  Up: Running

4.10 マルチスレッド・プログラムのデバッグ
=========================================

   HP-UXやSolarisのようなオペレーティング・システムにおいては、
1つのプログラムが複数の"スレッド"を実行することができます。
「スレッド」の正確な意味は、
オペレーティング・システムによって異なります。 しかし、 一般的には、
1つのアドレス空間を共有するという点を除けば、
プログラム内のマルチスレッドは、 マルチプロセスと類似しています
（アドレス空間の共有とは、
複数のスレッドが同一の変数の値を参照したり変更したりすることが可能であるということです）。
その一方で、 個々のスレッドは自分用のレジスタ、 実行スタック、
そしておそらくはプライベート・メモリを持ちます。

   GDBは、 マルチスレッド・プログラムのデバッグ用に、
以下のような便利な機能を提供しています。

   * 新規スレッド生成の自動的な通知

   * スレッドを切り替えるコマンド`thread THREADNO'

   * 既存のスレッドに関する情報を問い合わせるコマンド`info threads'

   * 1つのコマンドを複数のスレッドに対して実行するコマンド`thread apply
     [THREADNO] [ALL] ARGS'

   * スレッド固有のブレイクポイント

     _注意:_ これらの機能は、
     スレッドをサポートするオペレーティング・システム用に構成された
     すべてのGDBで使用可能なわけではありません。
     GDBがスレッドをサポートしていない環境では、
     これらのコマンドは無効です。 例えば、
     スレッドをサポートしていないシステム上で GDBの`info
     threads'コマンドを実行しても何も表示されませんし、
     `thread'コマンドの実行は常に拒絶されます。

          (gdb) info threads
          (gdb) thread 1
          Thread ID 1 not known.  Use the "info threads" command to
          see the IDs of currently known threads.

   GDBのスレッド・デバッグ機能により、 ユーザ・プログラムの実行中に、
すべてのスレッドを観察することができます。 ただし、
GDBに制御権のある状態では、
特定の1つのスレッドだけがデバッグの対象となります。 このスレッドは、
"カレント・スレッド"と呼ばれます。 デバッグ用のコマンドは、
カレント・スレッドの立場から見たプログラムの情報を表示します。

   ユーザ・プログラム内部において新しいスレッドの存在を検出すると、
GDBは、 `[New SYSTAG]'という形式で、
ターゲット・システム上におけるこのスレッドのIDを表示します。
ここでSYSTAGとはスレッドのIDで、 その形式はシステムによって異なります。
例えば、 LynxOS上では、 GDBが新しいスレッドを検出すると、

     [New process 35 thread 27]

のように表示されます。 一方、 SGIのシステム上では、
SYSTAGは単に`process 368'のような形式で、 これ以外の情報は含まれません。

   GDBは、 ユーザ・プログラム内の個々のスレッドに対して、
デバッグ用の整数値のスレッド番号を独自に割り当てます。

`info threads'
     その時点においてユーザ・プログラム中に存在するすべてのスレッドに関する要約を表示します。
     個々のスレッドに関して、 以下の情報が （列挙された順に）
     表示されます。

       1. GDBにより割り当てられたスレッド番号

       2. ターゲット・システムのスレッドID（SYSTAG）

       3. スレッドのカレントなスタック・フレームの要約

     GDBにより割り当てられたスレッド番号の左のアスタリスク`*'は、
     そのスレッドがカレント・スレッドであることを意味しています。

     以下に例を示します。

     (gdb) info threads
       3 process 35 thread 27  0x34e5 in sigpause ()
       2 process 35 thread 23  0x34e5 in sigpause ()
     * 1 process 35 thread 13  main (argc=1, argv=0x7ffffff8)
         at threadtest.c:68

`thread THREADNO'
     スレッド番号THREADNOを割り当てられたスレッドをカレント・スレッドとします。
     このコマンドの引数THREADNOは、 `info
     threads'コマンドの出力の最初のフィールドに表示される、
     GDB内部のスレッド番号です。 GDBは、
     指定されたスレッドのシステム上のIDとカレントなスタック・フレームの要約を表示します。

          (gdb) thread 2
          [Switching to process 35 thread 23]
          0x34e5 in sigpause ()

     `[New ...]'メッセージと同様、 `Switching
     to'の後ろに表示される情報の形式は、
     そのシステムにおけるスレッドの識別方法に依存します。

`thread apply [THREADNO] [ALL]  ARGS'
     `thread apply'コマンドにより、
     1つのコマンドを1つ以上のスレッドに対して実行することができます。
     実行対象となるスレッドのスレッド番号を、 引数THREADNOに指定します。
     THREADNOは、 `info
     threads'コマンドの出力の最初のフィールドに表示される、
     GDB内部のスレッド番号です。
     すべてのスレッドに対してコマンドを実行するには、 `thread apply
     all' ARGSコマンドを使用してください。

   GDBがユーザ・プログラムを停止させるとき、
その理由がブレイクポイントであれシグナルの受信であれ、
ブレイクポイントに到達したスレッド、 または、
シグナルを受信したスレッドが自動的に選択されます。 GDBは、 `[Switching
to SYSTAG]'という形式のメッセージでそのスレッドを示し、
コンテキスト切り替えの発生に注意を促します。

複数スレッドを持つプログラムの停止時や起動時のGDBの動作の詳細については、
*Note Stopping and starting multi-thread programs: Thread Stops。

   また、
複数スレッドを持つプログラムの中におけるウォッチポイントについては、
*Note Setting watchpoints: Set Watchpoints。


File: gdb-ja.info,  Node: Processes,  Prev: Threads,  Up: Running

4.11 マルチプロセス・プログラムのデバッグ
=========================================

`fork'関数を使用して新たにプロセスを生成するプログラムのデバッグに関しては、
GDBは特別な機能を提供していません。 プログラムが`fork'を実行するとき、
GDB は引き続き親プロセスのデバッグを継続し、
子プロセスは妨げられることなく実行を続けます。
子プロセスが実行するコードにブレイクポイントを設定してあると、
子プロセスは`SIGTRAP'シグナルを受信し、
（そのシグナルをキャッチする処理がなければ）
子プロセスは終了してしまいます。

   しかし、 子プロセスをデバッグしたい場合には、
それほど困難ではない回避策があります。
`fork'の呼び出し後に子プロセスが実行するソース・コードの中に、
`sleep'関数の呼び出しを加えてください。
GDBに子プロセスのデバッグをさせる理由がないときに遅延が発生することのないように、
特定の環境変数が設定されているときのみ、 あるいは、
特定のファイルが存在するときのみ、
`sleep'関数を呼び出すようにするとよいでしょう。
子プロセスが`sleep'を呼び出している間に、
`ps'ユーティリティを使用して子プロセスのプロセスIDを獲得します。 次に、
GDBに対して （親プロセスもデバッグするのであれば、 新たにGDBを起動して、
そのGDBに対して）、 子プロセスにアタッチするよう指示してください
（*note Attach::）。 これ以降は、
通常の方法でプロセスにアタッチした場合と全く同様に、
子プロセスのデバッグが可能です。


File: gdb-ja.info,  Node: Stopping,  Next: Stack,  Prev: Running,  Up: Top

5 停止と継続
************

デバッガを使用する主な目的は、
プログラムが終了してしまう前に停止させたり、
問題のあるプログラムを調査して何が悪いのかを調べたりすることにあります。

   GDB内部においてプログラムが停止する原因はいくつかあります。 例えば、
シグナルの受信、 ブレイクポイントへの到達、
`step'コマンドのようなGDBコマンドの実行後の新しい行への到達などです。
プログラムが停止すると、 変数の値の調査や設定、
新しいブレイクポイントの設定、
既存のブレイクポイントの削除などを行った後に、
プログラムの実行を継続することができます。 通常、
GDBが表示するメッセージは、
ユーザ・プログラムの状態について多くの情報を提供してくれます。
ユーザはいつでも明示的にこれらの情報を要求することができます。

`info program'
     ユーザ・プログラムの状態に関する情報を表示します。
     表示される情報は、 そのプログラムの実行状態 （実行中か否か）、
     そのプログラムのプロセス、 プログラムが停止した理由です。

* Menu:

* Breakpoints::                 ブレイクポイント、ウォッチポイント、キャッチポイント
* Continuing and Stepping::     実行の再開

* Signals::                     シグナル


* Thread Stops::                マルチスレッド・プログラムの停止と起動


File: gdb-ja.info,  Node: Breakpoints,  Next: Continuing and Stepping,  Prev: Stopping,  Up: Stopping

5.1 ブレイクポイント、ウォッチポイント、キャッチポイント
========================================================

"ブレイクポイント"によって、
プログラム内のある特定の箇所に到達するたびに、
プログラムを停止することができます。 個々のブレイクポイントについて、
そのブレイクポイントにおいてプログラムを停止させるためには満足されなければならない、
より詳細な条件を設定することができます。 ブレイクポイントの設定は、
いくつかある`break'コマンドのいずれかによって行います （*note Setting
breakpoints: Set Breaks.）。 行番号、 関数名、
プログラム内における正確なアドレスを指定することで、
プログラムのどこで停止するかを指定することができます。

   HP-UX、 SunOS 4.x、 SVR4、 Alpha OSF/1上では、
実行開始前に共用ライブラリ内にブレイクポイントを設定することもできます。
HP-UXシステムでは、 ちょっとした制約があります。
プログラムによって直接呼び出されるのではない共用ライブラリ・ルーチン
（例えば、 `pthread_create'の呼び出しにおいて、
引数として指定されるルーチン） にブレイクポイントをセットするためには、
そのプログラムの実行が開始されるまで待たなければなりません。

   "ウォッチポイント"は、
ある式の値が変化したときにユーザ・プログラムを停止させる、
特別なブレイクポイントです。 ウォッチポイントは、
他のブレイクポイントと同じように管理することができますが、
設定だけは特別なコマンドで行います （*note Setting watchpoints: Set
Watchpoints.）。 有効化、 無効化、
および削除を行うときに使用する各コマンドは、
対象がブレイクポイントであってもウォッチポイントであっても同一です。

   ブレイクポイントでGDBが停止するたびに、
常に自動的にユーザ・プログラム内のある値を表示させるようにすることができます。
*Note Automatic display: Auto Display。

   "キャッチポイント"は、
C++の例外の発生やライブラリのローディングのようなある種のイベントが発生したときに、
ユーザ・プログラムを停止させる、 また別の特殊なブレイクポイントです。
ウォッチポイントと同様、
キャッチポイントを設定するために使用する特別なコマンドがあります。
（*note Setting catchpoints: Set Catchpoints.）。 しかし、
この点を除けば、
キャッチポイントを他のブレイクポイントと同様に管理することができます。
（ユーザ・プログラムがシグナルを受信したときに停止するようにするためには、
`handle'コマンドを使用します。 *note Signals: Signals.）。

   ユーザが新規に作成した個々のブレイクポイント、 ウォッチポイント、
キャッチポイントに対して、 GDBは番号を割り当てます。
この番号は1から始まる連続する整数値です。
ブレイクポイントの様々な側面を制御するコマンドの多くにおいて、
変更を加えたいブレイクポイントを指定するのにこの番号を使用します。
個々のブレイクポイントを"有効化"、 "無効化"することができます。
無効化されたブレイクポイントは、 再度有効化されるまで、
ユーザ・プログラムの実行に影響を与えません。

* Menu:

* Set Breaks::                  ブレイクポイントの設定
* Set Watchpoints::             ウォッチポイントの設定
* Set Catchpoints::             キャッチポイントの設定
* Delete Breaks::               ブレイクポイントの削除
* Disabling::                   ブレイクポイントの無効化
* Conditions::                  ブレイクポイントの成立条件
* Break Commands::              ブレイクポイント・コマンド・リスト

* Breakpoint Menus::            ブレイクポイント・メニュー


File: gdb-ja.info,  Node: Set Breaks,  Next: Set Watchpoints,  Prev: Breakpoints,  Up: Breakpoints

5.1.1 ブレイクポイントの設定
----------------------------

ブレイクポイントは、 `break'コマンド （省略形は`b'）
によって設定されます。 デバッガのコンビニエンス変数`$bpnum'に、
最後に設定されたブレイクポイントの番号が記録されます。
コンビニエンス変数の使用方法については、 *Note Convenience variables:
Convenience Vars。

   ブレイクポイントの設定箇所を指定する方法はいくつかあります。

`break FUNCTION'
     関数FUNCTIONのエントリにブレイクポイントを設定します。 ソース言語が
     （例えばC++のように） シンボルのオーバーロード機能を持つ場合、
     FUNCTIONは、
     プログラムを停止させる可能性を持つ1つ以上の箇所を指すことがあります。
     このような状況に関する説明については、 *Note Breakpoint menus:
     Breakpoint Menus。

`break +OFFSET'
`break -OFFSET'
     その時点において選択されているフレームにおいて実行が停止している箇所から、
     指定された行数だけ先または手前にブレイクポイントを設定します。

`break LINENUM'
     カレントなソース・ファイル内のLINENUMで指定される行番号を持つ行に、
     ブレイクポイントを設定します。
     ここで「カレントなソース・ファイル」とは、
     最後にソース・コードが表示されたファイルを指します。
     このブレイクポイントは、 その行に対応するコードが実行される直前に、
     ユーザ・プログラムを停止させます。

`break FILENAME:LINENUM'
     FILENAMEで指定されるソース・ファイルのLINENUMで指定される番号の行に、
     ブレイクポイントを設定します。

`break FILENAME:FUNCTION'
     FILENAMEで指定されるソース・ファイル内のFUNCTIONで指定される関数エントリにブレイクポイントを設定します。
     同じ名前の関数が複数のファイルに存在する場合以外は、
     ファイル名と関数名を同時に指定する必要はありません。

`break *ADDRESS'
     ADDRESSで指定されるアドレスにブレイクポイントを設定します。
     これは、 プログラムの中の、
     デバッグ情報やソース・ファイルが手に入らない部分にブレイクポイントを設定するのに使用できます。

`break'
     引数なしで実行されると、 `break'コマンドは、
     選択されたスタック・フレーム内において次に実行される命令にブレイクポイントを設定します
     （*note Examining the Stack: Stack.）。
     最下位にあるスタック・フレーム以外のフレームが選択されていると、
     このブレイクポイントは、 制御がそのフレームに戻ってきた時点で、
     ユーザ・プログラムを停止させます。 これが持つ効果は、
     選択されたフレームの下位にあるフレームにおいて
     `finish'コマンドを実行するのと似ています。 ただし、 1つ異なるのは、
     `finish'コマンドがアクティブなブレイクポイントを残さないという点です。
     最下位のスタック・フレームにおいて引数なしで
     `break'コマンドを実行した場合、
     そのときに停止していた箇所に次に到達したときに、
     GDBはユーザ・プログラムを停止させます。 これは、
     ループの内部では便利でしょう。

     GDBは通常、 実行を再開したときに、
     最低でも1命令が実行されるまでの間は、
     ブレイクポイントの存在を無視します。 そうでなければ、
     ブレイクポイントで停止した後、
     そのブレイクポイントを無効にしない限り、
     先へ進めないことになってしまいます。 この規則は、
     ユーザ・プログラムが停止したときに、
     既にそのブレイクポイントが存在したか否かにかかわらず、
     適用されます。

`break ... if COND'
     CONDで指定される条件式付きでブレイクポイントを設定します。
     そのブレイクポイントに達すると、 必ず条件式CONDが評価されます。
     評価結果がゼロでない場合、 すなわち、 評価結果が真である場合のみ、
     ユーザ・プログラムを停止します。 `...'の部分には、
     これまでに説明してきた停止箇所を指定するための引数のいずれかが入ります
     （`...'は省略も可能です）。
     ブレイクポイントの条件式の詳細については、 *Note Break conditions:
     Conditions。

`tbreak ARGS'
     プログラムを1回だけ停止させるブレイクポイントを設定します。
     ARGSの部分は`break'コマンドと同様であり、
     ブレイクポイントも同じように設定されますが、
     `tbreak'により設定されたブレイクポイントは、
     プログラムが最初にそこで停止した後に自動的に削除されます。 *Note
     Disabling breakpoints: Disabling。

`hbreak ARGS'
     ハードウェアの持つ機能を利用したブレイクポイントを設定します。
     ARGSの部分は`break'コマンドと同様であり、
     ブレイクポイントも同じように設定されますが、
     `hbreak'により設定されるブレイクポイントは、
     ハードウェアによるサポートを必要とします。
     ターゲット・ハードウェアによっては、
     このような機能を持たないものもあるでしょう。 これの主な目的は、
     EPROM/ROMコードのデバッグであり、
     ユーザはある命令にブレイクポイントを設定するのに、
     その命令を変更する必要がありません。 これは、 SPARClite
     DSUの提供するトラップ発生機能と組み合わせて使用することができます。
     DSUは、 デバッグ・レジスタに割り当てられた
     データ・アドレスまたは命令アドレスをプログラムがアクセスすると、
     トラップを発生させます。
     ハードウェアの提供するブレイクポイント・レジスタは、
     データ・ブレイクポイントを2つまでしか取れないので、
     3つ以上使用しようとすると、 GDBはそれを拒絶します。
     このような場合、
     不要になったハードウェア・ブレイクポイントを削除または無効化してから、
     新しいハードウェア・ブレイクポイントを設定してください。 *Note
     Break conditions: Conditions。

`thbreak ARGS'
     ハードウェアの機能を利用して、
     プログラムを1回だけ停止させるブレイクポイントを設定します。
     ARGSの部分は`hbreak'コマンドと同様であり、
     ブレイクポイントも同じように設定されます。 しかし、
     `tbreak'コマンドの場合と同様、
     最初にプログラムがそこで停止した後に、
     このブレイクポイントは自動的に削除されます。 また、
     `hbreak'コマンドの場合と同様、
     このブレイクポイントはハードウェアによるサポートを必要とするものであり、
     ターゲット・ハードウェアによっては、
     そのような機能がないこともあるでしょう。 *Note Disabling
     breakpoints: Disabling。 また、 *Note Break conditions:
     Conditions。

`rbreak REGEX'
     REGEXで指定される正規表現にマッチするすべての関数にブレイクポイントを設定します。
     このコマンドは、
     正規表現にマッチしたすべての関数に無条件ブレイクポイントを設定し、
     設定されたすべてのブレイクポイントの一覧を表示します。
     設定されたブレイクポイントは、
     `break'コマンドで設定されたブレイクポイントと同様に扱われます。
     他のすべてのブレイクポイントと同様の方法で、 削除、 無効化、
     および条件の設定が可能です。

     C++プログラムのデバッグにおいて、
     あるオーバーロードされたメンバ関数が、
     特別なクラスだけが持つメンバ関数というわけではない場合、
     そのメンバ関数にブレイクポイントを設定するのに、
     `rbreak'コマンドは便利です。

`info breakpoints [N]'
`info break [N]'
`info watchpoints [N]'
     設定された後、 削除されていない、 すべてのブレイクポイント、
     ウォッチポイント、 キャッチポイントの一覧を表示します。
     個々のブレイクポイントについて、 以下の情報が表示されます。

    _ブレイクポイント番号_

    _タイプ_
          ブレイクポイント、 ウォッチポイント、 または、
          キャッチポイント

    _廃棄_
          ブレイクポイントに次に到達したときに、
          無効化または削除されるべくマークされているか否かを示します。

    _有効／無効_
          有効なブレイクポイントを`y'、
          有効でないブレイクポイントを`n'で示します。

    _アドレス_
          ユーザ・プログラム内のブレイクポイントの位置をメモリ・アドレスとして示します。

    _対象_
          ユーザ・プログラムのソース内におけるブレイクポイントの位置を、
          ファイル名および行番号で示します。

     ブレイクポイントが条件付きのものである場合、 `info
     break'コマンドは、 そのブレイクポイントに関する情報の次の行に、
     その条件を表示します。 ブレイクポイント・コマンドがあれば、
     続いてそれが表示されます。

     `info
     break'コマンドに引数としてブレイクポイント番号Nが指定されると、
     その番号に対応するブレイクポイントだけが表示されます。
     コンビニエンス変数`$_'、 および、
     `x'コマンドのデフォルトの参照アドレスには、
     一覧の中で最後に表示されたブレイクポイントのアドレスが設定されます
     （*note Examining memory: Memory.）。

     `info break'コマンドは、
     ブレイクポイントに到達した回数を表示します。 これは、
     `ignore'コマンドと組み合わせると便利です。 まず、
     `ignore'コマンドによってブレイクポイントへの到達をかなりの回数無視するよう設定します。
     プログラムを実行し、 `info
     break'コマンドの出力結果から何回ブレイクポイントに到達したかを調べます。
     再度プログラムを実行し、
     今度は前回の実行時に到達した回数より1だけ少ない回数だけ無視するように設定します。
     こうすることで、
     前回の実行時にそのブレイクポイントに最後に到達したときと同じ状態でプログラムを停止させることが簡単にできます。

   GDBでは、
ユーザ・プログラム内の同一箇所に何度でもブレイクポイントを設定することができます。
これは、 くだらないことでも、 無意味なことでもありません。
設定されるブレイクポイントが条件付きのものである場合、
これはむしろ有用です （*note Break conditions: Conditions.）。

   GDB自身が、
特別な目的でユーザ・プログラム内部にブレイクポイントを設定することがあります。
例えば、 （Cプログラムにおける） `longjmp'を適切に処理するためなどです。
これらの内部的なブレイクポイントには`-1'から始まる負の番号が割り当てられます。
`info breakpoints'コマンドは、
このようなブレイクポイントを表示しません。

   これらのブレイクポイントは、 GDBの保守コマンド`maint info
breakpoints'で表示することができます。

`maint info breakpoints'
     `info breakpoints'コマンドと同様の形式で呼び出され、
     ユーザが明示的に設定したブレイクポイントと、
     GDBが内部的な目的で使用しているブレイクポイントの両方を表示します。
     内部的なブレイクポイントは、 負のブレイクポイント番号で示されます。
     タイプ欄にブレイクポイントの種類が表示されます。

    `breakpoint'
          明示的に設定された普通のブレイクポイント

    `watchpoint'
          明示的に設定された普通のウォッチポイント

    `longjmp'
          `longjmp'が呼び出されたときに正しくステップ処理ができるように、
          内部的に設定されたブレイクポイント

    `longjmp resume'
          `longjmp'のターゲットとなる箇所に内部的に設定されたブレイクポイント

    `until'
          GDBの`until'コマンドで一時的に使用される内部的なブレイクポイント

    `finish'
          GDBの`finish'コマンドで一時的に使用される内部的なブレイクポイント



File: gdb-ja.info,  Node: Set Watchpoints,  Next: Set Catchpoints,  Prev: Set Breaks,  Up: Breakpoints

5.1.2 ウォッチポイントの設定
----------------------------

ウォッチポイントを設定することで、 ある式の値が変化したときに、
プログラムの実行を停止させることができます。 その値の変更が、
プログラムのどの部分で行われるかをあらかじめ知っている必要はありません。

   システムによって、
ウォッチポイントがソフトウェアによって実装されていることもあれば、
ハードウェアによって実装されていることもあります。 GDBは、
ユーザ・プログラムをシングル・ステップ実行して、
そのたびに変数の値をテストすることによって、
ソフトウェア・ウォッチポイントを実現しています。 これは、
通常の実行と比較すると、 何百倍も遅くなります。 （それでも、
プログラムのどの部分が問題を発生させたのか全く手掛りのない誤りを見つけることができるのであれば、
十分価値のあることかもしれません）。

   HP-UXやLinuxのようなシステム上のGDBには、
ハードウェア・ウォッチポイントのサポートも組み込まれています。
これを使用すれば、 ユーザ・プログラムの実行が遅くなることはありません。

`watch EXPR'
     EXPRで指定される式に対してウォッチポイントを設定します。
     プログラムが式の値を書き換えるときに、
     GDBはプログラムの実行を停止させます。

`rwatch EXPR'
     EXPRで指定される対象が読み込みアクセスされるときにプログラムを停止させるウォッチポイントを設定します。
     2つめのウォッチポイントとして設定するのであれば、
     1つめのウォッチポイントも`rwatch'コマンドで設定されていなければなりません。

`awatch EXPR'
     EXPRで指定される対象が読み込みアクセス、
     書き込みアクセスされるときにプログラムを停止させるウォッチポイントを設定します。
     2つめのウォッチポイントとして設定するのであれば、
     1つめのウォッチポイントも`awatch'コマンドで設定されていなければなりません。

`info watchpoints'
     ウォッチポイント、 ブレイクポイント、
     キャッチポイントの一覧を表示します。 これは、 `info
     break'と同じです。

   GDBは、 可能であれば、 "ハードウェア・ウォッチポイント"を設定します。
ハードウェア・ウォッチポイントをセットした場合は高速な実行が可能であり、
デバッガは、 変更を引き起こした命令のところで、
値の変更を報告することができます。
ハードウェア・ウォッチポイントを設定できない場合、 GDBは、
ソフトウェア・ウォッチポイントを設定します。 これは、 実行速度も遅く、
値の変更は、 その変更が実際に発生した後に、
その変更を引き起こした命令のところではなく、
1つ後ろの文のところで報告されます

   `watch'コマンドを実行すると、
ハードウェア・ウォッチポイントの設定が可能な場合には、 GDBは、
以下のような報告を行います。

     Hardware watchpoint NUM: EXPR

SPARClite DSUは、 デバッグ・レジスタに割り当てられた
データ・アドレスや命令アドレスにプログラムがアクセスすると、
トラップを発生させます。 データ・アドレスについては、
DSUが`watch'コマンドを支援しています。 しかし、
ハードウェアの提供するブレイクポイント・レジスタは、
データ・ウォッチポイントを2つまでしか取れず、
その2つは同じ種類のウォッチポイントでなければなりません。 例えば、
2つのウォッチポイントを、 両方とも`watch'コマンドで設定すること、
両方とも`rwatch'コマンドで設定すること、 *あるいは*、
両方とも`awatch'コマンドで設定することは可能ですが、
それぞれを異なるコマンドで設定することはできません。
異なる種類のウォッチポイントを同時に設定しようとしても、
コマンドの実行をGDBが拒否します。 このような場合、
使用しないウォッチポイント・コマンドを削除または無効化してから、
新しいウォッチポイント・コマンドを設定してください。

   `print'や`call'を使用して関数を対話的に呼び出すと、
それまでにセットされていたウォッチポイントはいずれも、
GDBが別の種類のブレイクポイントに到達するか、 あるいは、
関数の呼び出しが終了するまでの間は、 効果を持たなくなります。

     _注意:_ マルチスレッド・プログラムでは、
     ウォッチポイントの有用性は限定されます。
     現在のウォッチポイントの実装では、 GDBは、 _単一スレッドの中_
     でしか式の値を監視することができません。
     カレント・スレッドの処理の結果としてのみ、
     その式の値が変更されること （かつ、
     他のスレッドがカレント・スレッドにはならないこと） が確実であれば、
     通常どおり、 ウォッチポイントを使用することができます。 しかし、
     カレント・スレッド以外のスレッドが式の値を変更することがあると、
     GDBは、 その変更に気付かないかもしれません。


File: gdb-ja.info,  Node: Set Catchpoints,  Next: Delete Breaks,  Prev: Set Watchpoints,  Up: Breakpoints

5.1.3 キャッチポイントの設定
----------------------------

"キャッチポイント"を使用することによって、
C++例外や共用ライブラリのローディングのような、
ある種のプログラム・イベントが発生したときに、
デバッガを停止させることができます。 キャッチポイントを設定するには、
`catch'コマンドを使用します。

`catch EVENT'
     EVENTで指定されるイベントが発生したときに 停止します。 EVENTは、
     以下のいずれかです。
    `throw'
          C++例外の発生。

    `catch'
          C++例外のキャッチ。

    `exec'
          `exec'の呼び出し。 現在これは、
          HP-UXにおいてのみ利用可能です。

    `fork'
          `fork'の呼び出し。 現在これは、
          HP-UXにおいてのみ利用可能です。

    `vfork'
          `vfork'の呼び出し。 現在これは、
          HP-UXにおいてのみ利用可能です。

    `load'
    `load LIBNAME'
          任意の共用ライブラリの動的なローディング、 あるいは、
          LIBNAMEで指定されるライブラリのローディング。 現在これは、
          HP-UXにおいてのみ利用可能です。

    `unload'
    `unload LIBNAME'
          動的にロードされた任意の共用ライブラリのアンローディング、
          あるいは、 LIBNAMEで指定されるライブラリのアンローディング。
          現在これは、 HP-UXにおいてのみ利用可能です。

`tcatch EVENT'
     1回だけ停止させるキャッチポイントを設定します。
     最初にイベントが捕捉された後に、
     キャッチポイントは自動的に削除されます。

   カレントなキャッチポイントの一覧を表示するには、 `info
break'コマンドを使用します。

   現在、 GDBにおけるC++の例外処理 （`catch throw'と`catch catch'）
にはいくつかの制限があります。

   * 関数を対話的に呼び出すと、 GDBは通常、
     その関数が実行を終了したときに、 ユーザに制御を戻します。 しかし、
     その関数呼び出しが例外を発生させると、
     ユーザへ制御を戻すメカニズムが実行されないことがあります。
     この場合、 ユーザ・プログラムは、 アボートするか、 あるいは、
     ブレイクポイントへの到達、 GDBが監視しているシグナルの受信、
     そのプログラム自体の終了などのイベントが発生するまで、
     継続実行されることになります。 これは、
     例外に対するキャッチポイントを設定してある場合にもあてはまります。
     対話的な関数呼び出しの間は、
     例外に対するキャッチポイントは無効化されています。

   * 対話的に例外を発生させることはできません。

   * 対話的に例外ハンドラを組み込むことはできません。

   `catch'コマンドが、
例外処理をデバッグする手段としては最適なものではないような場合もあります。
どこで例外が発生したのかを正確に知りたい場合、
例外ハンドラが呼び出される_前_にプログラムを停止させた方がよいでしょう。
なぜなら、
スタック・ポインタの調整が行われる前のスタックの状態を見ることができるからです。
例外ハンドラの内部にブレイクポイントを設定してしまうと、
どこで例外が発生したのかを調べるのは簡単ではないでしょう。

   例外ハンドラが呼び出される直前で停止させるには、
実装に関する知識が若干必要になります。 GNU C++の場合、 以下のようなANSI
Cインターフェイスを持つ
`__raise_exception'というライブラリ関数を呼び出すことで例外を発生させます。

         /* ADDRは例外識別子が格納される領域
            IDは例外識別子 */
         void __raise_exception (void **ADDR, void *ID);

スタック・ポインタの調整が行われる前に、
すべての例外をデバッガにキャッチさせるには、
`__raise_exception'にブレイクポイントを設定します （*note Breakpoints;
watchpoints; and exceptions: Breakpoints.）。

   IDの値に依存する条件を付けたブレイクポイント （*note Conditions:
(Break conditions)Conditions.） を使用することで、
特定の例外が発生したときにだけユーザ・プログラムを停止させることができます。
複数の条件付きブレイクポイントを設定することで、
複数の例外の中のどれかが発生したときにユーザ・プログラムを停止させることもできます。


File: gdb-ja.info,  Node: Delete Breaks,  Next: Disabling,  Prev: Set Catchpoints,  Up: Breakpoints

5.1.4 ブレイクポイントの削除
----------------------------

ブレイクポイント、 ウォッチポイント、
キャッチポイントがプログラムを1回停止させた後、
同じところで再びプログラムを停止させたくない場合、
それらを取り除くことがしばしば必要になります。 これが、
ブレイクポイントの"削除"と呼ばれるものです。
削除されたブレイクポイントはもはや存在しなくなり、
それが存在したという記録も残りません。

   `clear'コマンドを使用する場合、 ブレイクポイントを、
それがプログラム内部のどこに存在するかを指定することによって削除します。
`delete'コマンドの場合は、 ブレイクポイント番号を指定することで、
個々のブレイクポイント、 ウォッチポイント、
キャッチポイントを削除することができます。

   ブレイクポイントで停止した後、 先へ進むために、
そのブレイクポイントを削除する必要はありません。
ユーザが実行アドレスを変更することなく継続実行する場合、
最初に実行される命令に設定されているブレイクポイントを、
GDBは自動的に無視します。

`clear'
     選択されているスタック・フレーム内において次に実行される命令に設定されているブレイクポイントを削除します
     （*note Selecting a frame: Selection.）。
     最下位にあるフレームが選択されている場合、
     ユーザ・プログラムが停止した箇所に設定されているブレイクポイントを削除するのに便利な方法です。

`clear FUNCTION'
`clear FILENAME:FUNCTION'
     FUNCTIONで指定される関数のエントリに設定されているブレイクポイントを削除します。

`clear LINENUM'
`clear FILENAME:LINENUM'
     指定された行、 または、
     その行内に記述されたコードに設定されたブレイクポイントを削除します。

`delete [breakpoints] [BNUMS...]'
     引数で指定された番号を持つブレイクポイント、 ウォッチポイント、
     キャッチポイントを削除します。 引数が指定されない場合、
     すべてのブレイクポイントを削除します （`set confirm
     off'コマンドが事前に実行されていない場合、 GDBは、
     削除してもよいかどうか確認を求めてきます）。 このコマンドの省略形は
     `d'です。


File: gdb-ja.info,  Node: Disabling,  Next: Conditions,  Prev: Delete Breaks,  Up: Breakpoints

5.1.5 ブレイクポイントの無効化
------------------------------

ブレイクポイント、 ウォッチポイント、
キャッチポイントを削除するのではなく、
"無効化"したい場合もあるでしょう。 無効化によって、 ブレイクポイントは、
それがあたかも削除されたかのように機能しなくなりますが、
後に再度"有効化"することができるよう、
そのブレイクポイントに関する情報は記憶されます。

   ブレイクポイント、 ウォッチポイント、 キャッチポイントは、
`enable'コマンドと`disable'コマンドによって有効化、 無効化されます。
これらのコマンドには、
引数として1つ以上のブレイクポイント番号を指定することも可能です。
指定すべき番号が分からない場合は、 `info break'コマンド、 または、
`info watch'コマンドによってブレイクポイント、 ウォッチポイント、
キャッチポイントの一覧を表示させてください。

   ブレイクポイント、 ウォッチポイント、 キャッチポイントは、
有効／無効という観点から見て、 4つの異なる状態を持つことができます。

   * 有効。 ブレイクポイントはユーザ・プログラムを停止させます。
     `break'コマンドで設定されたブレイクポイントの初期状態はこの状態です。

   * 無効。
     ブレイクポイントはユーザ・プログラムの実行に影響を与えません。

   * 1回有効。 ブレイクポイントはユーザ・プログラムを停止させますが、
     停止後、 そのブレイクポイントは無効状態になります。
     `tbreak'コマンドで設定されたブレイクポイントの初期状態はこの状態です。

   * 1回有効（削除）。
     ブレイクポイントはユーザ・プログラムを停止させますが、 停止直後に、
     そのブレイクポイントは完全に削除されます。

   以下のコマンドを使用することで、 ブレイクポイント、
ウォッチポイント、 キャッチポイントの有効化、 無効化が可能です。

`disable [breakpoints] [BNUMS...]'
     指定されたブレイクポイントを無効化します。
     番号が1つも指定されない場合は、
     すべてのブレイクポイントが無効化されます。
     無効化されたブレイクポイントは何ら影響力を持ちませんが、
     そのブレイクポイントに関する情報まで削除されるわけではありません。
     そのブレイクポイントを無視する回数、 ブレイクポイント成立の条件、
     ブレイクポイント・コマンドなどのオプションは、
     後にそのブレイクポイントが有効化される場合に備えて、
     記憶されています。 `disable'コマンドは
     `dis'と省略することができます。

`enable [breakpoints] [BNUMS...]'
     指定されたブレイクポイント （または、
     すべての定義済みブレイクポイント） を有効化します。
     有効化されたブレイクポイントは、
     再びユーザ・プログラムを停止させることができるようになります。

`enable [breakpoints] once BNUMS...'
     指定されたブレイクポイントを一時的に有効化します。
     このコマンドで有効化されたブレイクポイントはどれも、
     最初にプログラムを停止させた直後に、 GDBによって無効化されます。

`enable [breakpoints] delete BNUMS...'
     1回だけプログラムを停止させ、 その直後に削除されるような設定で、
     指定されたブレイクポイントを有効化します。
     このコマンドで有効化されたブレイクポイントはどれも、
     最初にプログラムを停止させた直後に、 GDBによって削除されます。

   `tbreak'コマンド （*note Setting breakpoints: Set Breaks.）
で設定されたブレイクポイントを除き、
ユーザによって設定されたブレイクポイントの初期状態は有効状態です。
その後、 ユーザが上記のコマンドのいずれかを使用した場合に限り、
無効化されたり有効化されたりします （`until'コマンドは、
独自にブレイクポイントを設定、 削除することができますが、
ユーザの設定した他のブレイクポイントの状態は変更しません。 *note
Continuing and stepping: Continuing and Stepping.）。


File: gdb-ja.info,  Node: Conditions,  Next: Break Commands,  Prev: Disabling,  Up: Breakpoints

5.1.6 ブレイクポイントの成立条件
--------------------------------

最も単純なブレイクポイントは、
指定された箇所にプログラムが到達するたびに、
プログラムの実行を停止させます。
ブレイクポイントに対して"条件"を指定することも可能です。 ここで、
「条件」とは、
プログラムが記述された言語で表現された真偽値を表す式のことです （*note
Expressions: Expressions.）。
条件付きのブレイクポイントにプログラムが到達するたびに、
その式が評価されます。 そして、 その結果が_真_であった場合だけ、
プログラムは停止します。

   これは、
プログラムの正当性を検査するために診断式を使用するのとは逆になります。
診断式の場合は、 成立しないとき、 すなわち条件が偽であるときに、
プログラムを停止させます。
C言語でASSERTという診断式をテストするためには、
しかるべきブレイクポイントに`! ASSERT'という条件を設定します。

   ウォッチポイントに対して条件を設定することもできます。
もともとウォッチポイントは、 ある式の値を検査するものですから、
これは必要ないかもしれません。 しかし、
ある変数の新しい値がある特定の値に等しいか否かを検査するのは条件式のほうに任せて、
ウォッチポイントの対象そのものは単にその変数の名前にしてしまうという設定の方が簡単でしょう。

   ブレイクポイントの成立条件に副作用を持たせたり、
場合によってはプログラム内部の関数を呼び出させたりすることもできます。
プログラムの進行状況をログに取る関数を呼び出したり、
特別なデータ構造をフォーマットして表示するユーザ定義の関数を使用したい場合などに便利です。
この効果は、
同じアドレスに有効なブレイクポイントが別に設定されていない限り、
完全に予測可能です （別のブレイクポイントが設定されていると、
GDBはこのブレイクポイントを先に検出し、
他のブレイクポイントで設定した条件式をチェックすることなくプログラムを停止させてしまうかもしれません）。
あるブレイクポイントに到達したときに、
副作用を持つ処理を実行させるためには、
ブレイクポイント・コマンドの方がより便利であり、 より柔軟でしょう
（*note Breakpoint command lists: Break Commands.）。

   ブレイクポイントの成立条件は、 ブレイクポイントを設定する際に、
`break'コマンドの引数に`if'を使用することによって、 設定できます。
*Note Setting breakpoints: Set Breaks。 ブレイクポイントの成立条件は、
`condition'コマンドによっていつでも変更できます。 `watch'コマンドは、
`if'キーワードを認識しません。
ウォッチポイントに対して条件を追加設定する唯一の方法は、
`condition'コマンドを使うことです。

`condition BNUM EXPRESSION'
     BNUMで指定される番号のブレイクポイント、 ウォッチポイント、
     キャッチポイントの成立条件として、 EXPRESSIONを指定します。
     条件を設定した後、 番号BNUMのブレイクポイントは、
     EXPRESSIONの値が真 （C言語の場合はゼロ以外の値） であるときのみ、
     ユーザ・プログラムを停止させます。
     `condition'コマンドを使用すると、
     GDBはただちにEXPRESSIONの構文の正当性、 および、
     EXPRESSIONの中で使用されるシンボル参照の、
     ブレイクポイントのコンテキストにおける有効性をチェックします。
     しかし、 `condition'コマンドが実行されるときに、
     EXPRESSIONの値がGDBによって実際に評価されるわけではありません。
     *Note Expressions: Expressions。

`condition BNUM'
     BNUMで指定される番号のブレイクポイントから条件を削除します。
     実行後、 それは通常の無条件ブレイクポイントになります。

   ブレイクポイント成立条件の特別なものに、
ブレイクポイントに到達した回数がある数に達したときにプログラムを停止させるというものがあります。
これは大変便利なので、
それを実現するための特別な方法が提供されています。 それは、
ブレイクポイントの"通過カウント" （ignore count） を使用する方法です。
すべてのブレイクポイントは、
通過カウントと呼ばれる整数値を持っています。 ほとんどの場合、
この通過カウントの値はゼロであり、 何ら影響力を持ちません。 しかし、
通過カウントとして正の値を持つブレイクポイントに到達すると、
ユーザ・プログラムはそこで停止せず、
単に通過カウントの値を1減少させて処理を継続します。 したがって、
通過カウントがNであると、
ユーザ・プログラムがそのブレイクポイントに到達した回数がN以下の間は、
そのブレイクポイントにおいてプログラムは停止しません。

`ignore BNUM COUNT'
     BNUMで指定される番号のブレイクポイントの通過カウントをCOUNTで指定される値に設定します。
     ブレイクポイントへの到達回数がCOUNT以下の間、
     ユーザ・プログラムは停止しません。 この間、 GDBは、
     通過カウントの値を1減少させる以外には何もしません。

     次にブレイクポイントに到達したときにプログラムを停止させるには、
     COUNTにゼロを指定してください。

     ブレイクポイントで停止した後に`continue'コマンドを使用して実行を再開する場合、
     `ignore'コマンドを使用することなく、
     直接`continue'コマンドの引数に通過カウントを指定することができます。
     *Note Continuing and stepping: Continuing and Stepping。

     ブレイクポイントが通過カウントとして正の値を持ち、 かつ、
     成立条件を持つ場合、 成立条件はチェックされません。
     通過カウントが0に達すると、 GDBは成立条件のチェックを再開します。

     `$foo-- <= 0'のように、
     評価のたびに値の減少するコンビニエンス変数を使用した評価式によって、
     通過カウントと同様の効果を達成することができます。 *Note
     Convenience variables: Convenience Vars。

   通過カウントは、 ブレイクポイント、 ウォッチポイント、
キャッチポイントに適用されます。


File: gdb-ja.info,  Node: Break Commands,  Next: Breakpoint Menus,  Prev: Conditions,  Up: Breakpoints

5.1.7 ブレイクポイント・コマンド・リスト
----------------------------------------

ブレイクポイント （あるいは、 ウォッチポイント、 キャッチポイント）
に対して、
それによってプログラムが停止したときに実行される一連のコマンドを指定することができます。
例えば、 ある特定の式の値を表示したり、
他のブレイクポイントを有効化したりできると便利なこともあるでしょう。

`commands [BNUM]'
`... COMMAND-LIST ...'
`end'
     BNUMで指定される番号を持つブレイクポイントに対して一連のコマンドを指定します。
     コマンド自体は、 次の行以下に記述します。
     コマンドの記述を終了するには、 `end'だけから成る1行を記述します。

     ブレイクポイントからすべてのコマンドを削除するには、
     `commands'行に続いて （コマンドを1つも指定せずに）
     `end'を記述します。

     引数BNUMが指定されない場合、 `commands'は、
     最後に設定されたブレイクポイント、 ウォッチポイント、
     キャッチポイントを対象とします
     （最後に到達したブレイクポイントではありません）。

   COMMAND-LISTの記述中は、 <RET>キーが持つ、
最後に実行されたコマンドを繰り返し実行する機能は無効です。

ブレイクポイント・コマンドを使用してプログラムの実行を再開することができます。
`continue'、 `step'、 または、
実行を再開させるその他の任意のコマンドを使用してください。

   コマンド・リストの中で、
実行を再開するコマンドの後に記述されているものは無視されます。
というのは、 プログラムが実行を再開すると
（たとえそれが`next'コマンドや`step'コマンドによるものであっても）
別のブレイクポイントに到達する可能性があり、
そのブレイクポイントがコマンド・リストを持っていると、
どちらのリストを実行するべきかあいまいになるからです。

   コマンド・リストの先頭に指定されたコマンドが`silent'であると、
ブレイクポイントで停止したときに通常出力されるメッセージは表示されません。
これは、
ある特定のメッセージを出力して実行を継続するようなブレイクポイントを設定するのに望ましいでしょう。
コマンド・リスト中の後続のコマンドがどれもメッセージを出力しない場合、
ブレイクポイントに到達したことをユーザに示す情報は何も表示されないことになります。
`silent'はブレイクポイント・コマンド・リストの先頭においてのみ意味を持ちます。

   `echo'、 `output'、 `printf'の各コマンドを使用することで、
細かく管理された出力を表示することができます。 これらのコマンドは、
`silent'指定のブレイクポイントで使うと便利です。 *Note Commands for
controlled output: Output。

   例えば、 ブレイクポイント・コマンドを使用して、
`foo'へのエントリにおいて `x'が正の値を持つときに、
その値を表示するには以下のようにします。

     break foo if x>0
     commands
     silent
     printf "x is %d\n",x
     cont
     end

   ブレイクポイント・コマンドの1つの応用として、
あるバグの持つ影響を取り除いて、
他のバグを見つけるためにテストを継続することができます。
誤りのある行の次の行にブレイクポイントを設定し、
その条件の中で誤りの発生を検査し、
ブレイクポイント・コマンドの中で修正の必要な変数に正しい値を割り当てます。
コマンド・リストの最後には`continue'コマンドを記述して、
プログラムが停止しないようにします。 また、
プログラムの先頭には`silent'コマンドを記述し、
何も出力されないようにします。 以下に例を挙げます。

     break 403
     commands
     silent
     set x = y + 4
     cont
     end


File: gdb-ja.info,  Node: Breakpoint Menus,  Prev: Break Commands,  Up: Breakpoints

5.1.8 ブレイクポイント・メニュー
--------------------------------

プログラミング言語によっては （特にC++の場合）、
異なるコンテキストにおいて使用するために、
同一の関数名を複数回定義することが可能です。 これは、
"オーバーローディング"と呼ばれます。
関数名がオーバーロードされている場合、 `break FUNCTION'だけでは、
どこにブレイクポイントを設定したいのかをGDBに正しく指定するのに十分ではありません。
このような場合には、
ブレイクポイントを設定したい関数がどれであるかを正確に指定するために、
`break FUNCTION(TYPES)'のような形式を使用することができます。
このような形式を使用しないと、
GDBは候補となりえるブレイクポイントの一覧を番号付きのメニューとして表示し、
プロンプト`>'によってユーザの選択を待ちます。 先頭の2つの選択肢は常に、
`[0] cancel'と`[1] all'です。 `1'を入力すると、
候補となるすべての関数のそれぞれの定義に対してブレイクポイントを設定します。
また、 `0'を入力すると、 新たにブレイクポイントを設定することなく
`break'コマンドを終了します。

   例えば、 以下に示すセッションの抜粋は、
オーバーロードされたシンボル`String::after'に対してブレイクポイントを設定しようとした場合を示しています。
ここでは、 この関数名を持つ関数定義の中から3つを選択しています。

     (gdb) b String::after
     [0] cancel
     [1] all
     [2] file:String.cc; line number:867
     [3] file:String.cc; line number:860
     [4] file:String.cc; line number:875
     [5] file:String.cc; line number:853
     [6] file:String.cc; line number:846
     [7] file:String.cc; line number:735
     > 2 4 6
     Breakpoint 1 at 0xb26c: file String.cc, line 867.
     Breakpoint 2 at 0xb344: file String.cc, line 875.
     Breakpoint 3 at 0xafcc: file String.cc, line 846.
     Multiple breakpoints were set.
     Use the "delete" command to delete unwanted
      breakpoints.
     (gdb)


File: gdb-ja.info,  Node: Continuing and Stepping,  Next: Signals,  Prev: Breakpoints,  Up: Stopping

5.2 継続実行とステップ実行
==========================

"継続実行"とは、 ユーザ・プログラムの実行を再開して、
それが正常に終了するまで実行させることを指します。 一方、
"ステップ実行"とは、
ユーザ・プログラムを1「ステップ」だけ実行することを指します。
ここで「ステップ」とは、 （使用されるコマンドによって）
1行のソース・コードを指すこともありますし、
1マシン命令を指すこともあります。
継続実行の場合でもステップ実行の場合でも、 ブレイクポイントやシグナル
が原因となって、
正常終了する前にユーザ・プログラムが停止することがあります
（シグナルによってプログラムが停止した場合、 実行を再開するには
`handle'コマンドまたは`signal 0' コマンドを使用するとよいでしょう。
*Note Signals: Signals） 。

`continue [IGNORE-COUNT]'
`c [IGNORE-COUNT]'
`fg [IGNORE-COUNT]'
     ユーザ・プログラムが最後に停止した箇所から、
     プログラムの実行を再開します。
     停止箇所に設定されているブレイクポイントは無視されます。
     オプションの引数IGNORE-COUNTによって、
     停止箇所のブレイクポイントを無視する回数を指定することができます。
     これは`ignore'コマンドと似た効果を持ちます （*note Break
     conditions: Conditions.）。

     引数IGNORE-COUNTは、
     ユーザ・プログラムがブレイクポイントによって停止した場合にのみ意味を持ちます。
     これ以外の場合には、 `continue'コマンドへの引数は無視されます。

     `c'および`fg'は、 簡便さのためだけに提供されている同義コマンドで、
     `continue'コマンドと全く同様の動作をします。

   別の箇所で実行を再開するには、 呼び出し関数に戻る`return'コマンド
（*note Returning from a function: Returning.）、 または、
ユーザ・プログラム内の任意の箇所へ移動する`jump'コマンド （*note
Continuing at a different address: Jumping.） を使用することができます。

   ステップ実行を使用する典型的なテクニックは、
問題があると思われる関数やプログラム部分の先頭にブレイクポイント (*note
Breakpoints; watchpoints; and catchpoints: Breakpoints.)  を設定し、
ブレイクポイントで停止するまでプログラムを実行させた後、
問題が再現するまで、 関連しそうな変数の値を調べながら、
疑わしい部分を1行ずつ実行することです。

`step'
     異なるソース行に到達するまでユーザ・プログラムを継続実行した後、
     プログラムを停止させ、 GDBに制御を戻します。
     このコマンドの省略形は`s'です。

          _注意:_
          デバッグ情報なしでコンパイルされた関数の内部にいるときに`step'コマンドを使用すると、
          デバッグ情報付きの関数に達するまでプログラムの実行は継続されます。
          同様に、
          `step'コマンドがデバッグ情報なしでコンパイルされた関数の内部へ入って、
          停止することはありません。
          デバッグ情報を持たない関数の内部でステップ実行を行うには、
          後述の`stepi'コマンドを使用してください。

     `step'コマンドは、
     ソース・コード行の最初の命令においてのみ停止するようになりました。
     これにより、 以前のバージョンで発生していた、
     `switch'文や`for'文などにおいて複数回停止してしまうという問題が回避されています。
     同じ行の中にデバッグ情報を持つ関数への呼び出しがあると、
     `step'コマンドは続けて停止します。

     さらに、 `step'コマンドは、
     サブルーチンが行番号情報を持つ場合に限り、
     サブルーチンの内部に入り込むようになりました。
     サブルーチンが行番号情報を持たない場合、
     `step'コマンドは`next'コマンドと同様の動作をします。 これにより、
     MIPSマシン上で`cc
     -gl'を使用した場合に発生していた問題が回避されています。
     以前のバージョンでは、
     サブルーチンが何らかのデバッグ情報を持っていれば、
     その内部に入り込んでいました。

`step COUNT'
     `step'コマンドによるステップ実行をCOUNT回繰り返します。
     ステップ実行をCOUNT回繰り返し終わる前に、
     ブレイクポイントに到達する か、 あるいは、
     ステップ実行とは関連のないシグナルが発生した 場合には、
     ただちにステップ実行を中断して停止します。

`next [COUNT]'
     カレントな （最下位の） スタック・フレーム上において、
     ソース・コード上の次の行まで実行します。
     これは`step'コマンドと似ていますが、 `next'コマンドは、
     ソース・コード上に関数呼び出しが存在すると、
     その関数を停止することなく最後まで実行します。
     プログラムが停止するのは、
     `next'コマンドを実行したときと同一のスタック・フレーム上において、
     ソース・コード上の異なる行まで実行が継続されたときです。
     このコマンドの省略形は`n'です。

     引数COUNTは、 `step'コマンドの場合と同様、 繰り返し回数です。

     `next'コマンドは、
     ソース・コード行の最初の命令においてのみ停止するようになりました。
     これにより、 以前のバージョンで発生していた、
     `switch'文や`for'文などにおいて複数回停止してしまうという問題が回避されています。

`finish'
     選択されているスタック・フレーム上の関数が復帰するまで、
     実行を継続します。 戻り値があれば、 それを表示します。

     `return'コマンド （*note Returning from a function: Returning.）
     と比較してみてください。

`until'
`u'
     カレントなスタック・フレーム上において、
     カレント行よりも後ろにある行に到達するまで実行を継続します。
     このコマンドは、
     ループ内において複数回ステップ実行をするのを回避するために使用されます。
     これは`next'コマンドに似ていますが、 唯一の相違点は、
     `until'コマンドによってジャンプ命令が実行された場合、
     プログラム・カウンタの値がジャンプ命令のアドレスより大きくなるまで、
     プログラムが継続実行されるという点です。

     これは、
     ステップ実行によってループ内の最後の行に到達した後に`until'コマンドを実行することで、
     ループから抜け出るまでプログラムを継続実行させることができるということを意味しています。
     これに対して、 ループ内の最後の行で`next'コマンドを実行すると、
     プログラムはループの先頭に戻ってしまうので、
     ループ内の処理を繰り返すことを余儀なくされます。

     `until'コマンドの実行により、
     プログラムがカレントなスタック・フレームから抜け出ようとすると、
     そこで`until'コマンドはプログラムを停止します。

     実行されるマシン・コードの順序がソース行の順序と一致しない場合、
     `until'コマンドは直観にいくらか反するような結果をもたらすかもしれません。
     例えば、 以下に挙げるデバッグ・セッションからの抜粋では、 `f'
     （`frame'） コマンドによって、
     プログラムが`206'行めにおいて停止していることが示されています。
     ところが、 `until'コマンドを実行すると、
     `195'行めで停止してしまいます。

          (gdb) f
          #0  main (argc=4, argv=0xf7fffae8) at m4.c:206
          206                 expand_input();
          (gdb) until
          195             for ( ; argc > 0; NEXTARG) {

     これは、 コンパイラが、 実行の効率を高めるために、 C言語では
     `for'ループ本体の前に記述されているループ終了のための条件判定を、
     ループの先頭ではなく末尾で行うコードを生成したためです。
     この判定式にまで処理が進んだとき、
     `until'コマンドはあたかもループの先頭に戻ったかのように見えます。
     しかしながら、 実際のマシン・コードのレベルでは、
     前の命令に戻ったわけではありません。

     引数のない`until'コマンドは、
     1命令ごとのステップ実行によって実現されるため、 引数付きの
     `until'コマンドに比べて処理性能が劣ります。

`until LOCATION'
`u LOCATION'
     LOCATIONで指定される箇所に到達するか、
     カレントなスタック・フレームを抜け出るまで、
     ユーザ・プログラムを継続実行します。
     LOCATIONは`break'コマンドの受け付ける形式の引数です （*note
     Setting breakpoints: Set Breaks.）。
     この形式による`until'コマンドはブレイクポイントを使用するため、
     引数のない`until'コマンドより処理性能が優れています。

`stepi'
`si'
     1マシン命令を実行した後、停止してデバッガに戻ります。

     マシン命令単位でステップ実行する場合、 `display/i
     $pc'を使用すると便利なことがしばしばあります。 これは、
     ユーザ・プログラムが停止するたびに、
     次に実行される命令をGDBに自動的に表示させます。 *Note Automatic
     display: Auto Display。

     引数として、 `step'コマンドと同様、 繰り返し回数を取ります。

`nexti'
`ni'
     1マシン命令を実行しますが、 それが関数の呼び出しである場合は、
     関数から復帰するまで実行を継続します。

     引数として、`next'コマンドと同様、 繰り返し回数を取ります。


File: gdb-ja.info,  Node: Signals,  Next: Thread Stops,  Prev: Continuing and Stepping,  Up: Stopping

5.3 シグナル
============

シグナルは、 プログラム内で発生する非同期イベントです。
オペレーティング・システムによって、
使用可能なシグナルの種類が定義され、
それぞれに名前と番号が割り当てられます。 例えば、 UNIXにおいては、
割り込み （通常は、`Ctrl'キーを押しながら`C'を押す）
を入力したときにプログラムが受信する `SIGINT'、
その使用領域からかけ離れたメモリ域を参照したときにプログラムが受信する`SIGSEGV'、
アラームのタイムアウト時に発生する
（プログラムからアラームを要求した場合にのみ発生する）
`SIGALRM'シグナルなどがあります。

   `SIGALRM'など、 いくつかのシグナルは、
プログラムの正常な機能の一部です。 `SIGSEGV'などの他のシグナルは、
エラーを意味します。 これらのシグナルは、
プログラムが事前にそれを処理する何らかの方法を指定しないと、 "致命的"な
（プログラムを即座に終了させる） ものとなります。
`SIGINT'はユーザ・プログラム内部のエラーを意味するものではありませんが、
通常は致命的なものであり、
割り込みの目的であるプログラムの終了を実現することができます。

   GDBは、
ユーザ・プログラム内部における任意のシグナル発生を検出することができます。
ユーザは、 個々のシグナルの発生時に何を実行するかを、
GDBに対して事前に指定することができます。

   通常GDBは、 `SIGALRM'のようなエラーではないシグナルを無視するよう
（これらのシグナルがユーザ・プログラムの中で持っている役割を妨害することのないよう）
設定されています。 その一方で、
エラーのシグナルが発生した場合にはすぐにユーザ・プログラムを停止させるよう設定されています。
これらの設定は`handle'コマンドによって変更することができます。

`info signals'
     すべてのシグナルを一覧にして表示します。 また、
     個々のシグナルについて、
     GDBがそれをどのように処理するよう設定されているかを表示します。
     このコマンドを使用して、
     定義済みのすべてのシグナルのシグナル番号を知ることができます。

     `info handle'は、 `info signals'に対して設定された新しい別名です。

`handle SIGNAL KEYWORDS...'
     GDBがSIGNALで指定されるシグナルを処理する方法を変更します。
     SIGNALには、 シグナル番号またはシグナル名称
     （先頭の`SIG'は省略可能） を指定します。
     キーワードKEYWORDSによって、 どのように変更するかを指定します。

`handle'コマンドが受け付けるキーワードには省略形を使用することができます。
省略しない場合、 キーワードは以下のようになります。

`nostop'
     GDBに対して、
     このシグナルが発生してもユーザ・プログラムを停止しないよう指示します。
     GDBは、
     シグナルを受信したことをメッセージ出力によってユーザに通知することができます。

`stop'
     GDBに対して、
     このシグナルが発生するとユーザ・プログラムを停止するよう指示します。
     これは、 `print'キーワードを暗黙のうちに含みます。

`print'
     GDBに対して、
     このシグナルが発生するとメッセージを表示するよう指示します。

`noprint'
     GDB に対して、
     このシグナルが発生したことを知らせないよう指示します。 これは、
     `nostop'キーワードを暗黙のうちに含みます。

`pass'
     GDBに対して、
     このシグナルの発生をユーザ・プログラムが検出できるようにするよう指示します。
     ユーザ・プログラムはシグナルを処理することができます。
     致命的で処理できないシグナルが発生した場合、
     ユーザ・プログラムは停止するかもしれません。

`nopass'
     GDBに対して、
     このシグナルの発生をユーザ・プログラムが検出できないようにするよう指示します。

   シグナルによってユーザ・プログラムが停止した場合、
実行を継続するまでそのシグナルは検出されません。 _その時点において_、
そのシグナルに対して`pass'キーワードが有効であれば、
ユーザ・プログラムは、 実行継続時にシグナルを検出します。 言い換えれば、
GDBがシグナルの発生を報告してきたとき、
`handle'コマンドに`pass'キーワードまたは`nopass'キーワードを指定することで、
実行を継続したときにプログラムにそのシグナルを検出させるか否かを制御することができます。

   また、 `signal'コマンドを使用することによって、
ユーザ・プログラムがシグナルを検出できないようにしたり、
通常は検出できないシグナルを検出できるようにしたり、
あるいは任意の時点で任意のシグナルをユーザ・プログラムに検出させたりすることができます。
例えば、
ユーザ・プログラムが何らかのメモリ参照エラーによって停止した場合、
ユーザは、 さらに実行を継続しようとして、
問題のある変数に正しい値を設定して継続実行しようとするかもしれません。
しかし、 実行継続直後に検出される致命的なシグナルのために、
おそらくユーザ・プログラムはすぐに終了してしまうでしょう。
このようなことを回避したければ、
`signal 0'コマンドによって実行を継続することができます。 *Note Giving
your program a signal: Signaling。


File: gdb-ja.info,  Node: Thread Stops,  Prev: Signals,  Up: Stopping

5.4 マルチスレッド・プログラムの停止と起動
==========================================

ユーザ・プログラムが複数のスレッド （*note Debugging programs with
multiple threads: Threads.） を持つ場合、
すべてのスレッドにブレイクポイントを設定するか、
特定のスレッドにブレイクポイントを設定するかを選択することができます。

`break LINESPEC thread THREADNO'
`break LINESPEC thread THREADNO if ...'
     LINESPECはソース行を指定します。 記述方法はいくつかありますが、
     どの方法を使っても結果的にはソース行を指定することになります。

     `break'コマンドに修飾子`thread THREADNO'を使用することで、
     ある特定のスレッドがこのブレイクポイントに到達したときだけGDBがプログラムを停止するよう、
     指定することができます。 ここでTHREADNOは、
     GDBによって割り当てられるスレッド識別番号で、 `info
     threads'コマンドによる出力の最初の欄に表示されるものです。

     ブレイクポイントを設定する際に`thread THREADNO'を指定しなければ、
     そのブレイクポイントはユーザ・プログラム内部の_すべて_のスレッドに適用されます。

     条件付きのブレイクポイントに対しても`thread'識別子を使用することができます。
     この場合、 以下のように`thread
     THREADNO'をブレイクポイント成立条件の前に記述してください。

          (gdb) break frik.c:13 thread 28 if bartab > lim


いかなる理由によるのであれGDB配下においてユーザ・プログラムが停止した場合、
カレント・スレッドだけではなく、 _すべて_の実行スレッドが停止します。
これにより、 知らないうちに状態の変化が発生することを心配することなく、
スレッドの切り替えも含めて、
プログラム全体の状態を検査することができます。

   逆に、 プログラムの実行を再開したときには、
_すべて_のスレッドが実行を開始します。 これは、
`step'コマンドや`next'コマンドによる_シングル・ステップ実行の場合でも同様_です。

   特にGDBは、
すべてのスレッドの歩調を合わせてシングル・ステップ実行することはできません。
スレッドのスケジューリングは、
デバッグ対象のマシンのオペレーティング・システムに依存する
（GDBが管理するわけではない） ので、
カレント・スレッドがシングル・ステップの実行を完了する前に、
他のスレッドは複数の文を実行してしまうかもしれません。 また、
プログラムが停止するとき、
他のスレッドは2つの文の間の境界のところでぴったり停止するよりも、
文の途中で停止してしまう方が一般的です。

   また、 継続実行やステップ実行の結果、
プログラムが別のスレッド内で停止してしまうこともありえます。
最初のスレッドがユーザの要求した処理を完了する前に、
他のスレッドがブレイクポイントに到達した場合、 シグナルを受信した場合、
例外が発生した場合には、 常にこのようなことが発生します。

   OSによっては、 OSスケジューラをロックすることによって、
ただ1つのスレッドだけが実行されるようにすることができます。

`set scheduler-locking MODE'
     スケジューラのロッキング・モード（locking mode）を設定します。
     `off'の場合は、 ロックのメカニズムは機能せず、 任意の時点において、
     どのスレッドも実行される可能性を持ちます。 `on'の場合は、
     再始動（resume）されるスレッドの優先順位が低い場合には、
     カレント・スレッドだけが実行を継続することができます。
     `step'モードでは、
     シングル・ステップ実行のための最適化が行われます。
     ステップ実行をしている間、
     他のスレッドが「プロンプトを横取りする」ことがないよう、
     カレント・スレッドに占有権が与えられます。 また、
     ステップ実行をしている間、 他のスレッドはきわめて稀にしか
     （あるいは、 まったく） 実行するチャンスを与えられません。
     `next'コマンドによって関数呼び出しの次の行まで処理を進めると、
     他のスレッドが実行される可能性は高くなります。 また、 `continue'、
     `until'、 `finish'のようなコマンドを使用すると、 他のスレッドは
     完全に自由に実行されることができます。 しかし、
     そのタイムスライスの中でブレイクポイントに到達しない限り、
     他のスレッドが、 デバッグの対象となっているスレッドから、
     GDBプロンプトを横取りすることはありません。

`show scheduler-locking'
     スケジューラの現在のロッキング・モードを表示します。


File: gdb-ja.info,  Node: Stack,  Next: Source,  Prev: Stopping,  Up: Top

6 スタックの検査
****************

ユーザ・プログラムが停止したとき、 まず最初に、 どこで停止したのか、
そして、 どのようにしてそこに到達したのかを知る必要があるでしょう。

   ユーザ・プログラムが関数呼び出しを行うたびに、
その呼び出しに関する情報が生成されます。 その情報には、
ユーザ・プログラム内においてその呼び出しが発生した場所、
関数呼び出しの引数、
呼び出された関数内部のローカル変数などが含まれます。 その情報は、
"スタック・フレーム"と呼ばれるデータ・ブロックに保存されます。
スタック・フレームは、
"呼び出しスタック"と呼ばれるメモリ域に割り当てられます。

   ユーザ・プログラムが停止すると、
スタックを検査するGDBコマンドを使用して、
この情報をすべて見ることができます。

   GDBは1つのスタック・フレームを"選択"していて、
多くのGDBコマンドはこの選択されたフレームを暗黙のうちに参照します。
特に、 GDBに対してユーザ・プログラム内部の変数の値を問い合わせると、
GDBは選択されたフレームの内部においてその値を探そうとします。
関心のあるフレームを選択するための特別なGDBコマンドが提供されています。
*Note Selecting a frame: Selection。

   ユーザ・プログラムが停止すると、
GDBはその時点において実行中のフレームを自動的に選択し、 `frame'コマンド
（*note Information about a frame: Frame Info.） のように、
そのフレームに関する情報を簡潔に表示します。

* Menu:

* Frames::                      スタック・フレーム
* Backtrace::                   バックトレース
* Selection::                   フレームの選択
* Frame Info::                  フレームに関する情報
* Alpha/MIPS Stack::            Alpha/MIPSマシンの関数スタック


File: gdb-ja.info,  Node: Frames,  Next: Backtrace,  Prev: Stack,  Up: Stack

6.1 スタック・フレーム
======================

呼び出しスタックは、 "スタック・フレーム"、
または短縮して"フレーム"と呼ばれる、 連続した小部分に分割されます。
個々のフレームは、 ある関数に対する1回の呼び出しに関連するデータです。
フレームには、 関数への引数、 関数のローカル変数、
関数の実行アドレスなどの情報が含まれます。

   ユーザ・プログラムが起動されたとき、
スタックには`main'関数のフレームが1つ存在するだけです。 これは、
"初期"フレームまたは「"最上位のフレーム"」と呼ばれます。
関数が呼び出されるたびに、 新たにフレームが作成されます。
関数が復帰すると、
その関数を呼び出したときに生成されたフレームが取り除かれます。
関数が再帰的に呼び出される場合、
1つの関数に対して多くのフレームが生成されるということもありえます。
実際に実行中の関数に対応するフレームは、
「"最下位のフレーム"」と呼ばれます。 これは、
存在するすべてのスタック・フレームの中で、
最も新しく作成されたものです。

   ユーザ・プログラムの内部においては、
スタック・フレームはアドレスによって識別されます。
スタック・フレームは多くのバイトから構成され、
それぞれがそれ自身のアドレスを持っています。
そのアドレスがフレームのアドレスとなるような1バイトを選択する慣習的な方法を、
すべての種類のコンピュータが提供しています。 通常、
あるフレーム内部で実行中は、
そのフレームのアドレスが"フレーム・ポインタ・レジスタ"と呼ばれるレジスタに格納されています。

   GDBは、 既存のスタック・フレームのすべてに番号を割り当てます。
最下位のフレームは0で、 それを呼び出したフレームは1となります。 以下、
最下位のフレームを起点として、 順番に値を割り当てていきます。
これらの番号はユーザ・プログラム内部には実際には存在しません。
これらの番号は、
GDBコマンドでスタック・フレームを指定することができるように、
GDBによって割り当てられたものです。

   コンパイラによっては、
スタック・フレームを使用しなくても実行可能なように関数をコンパイルする方法を提供しているものもあります
（例えば、 `gcc'のオプション`-fomit-frame-pointer'を指定すると、
フレームを持たない関数が生成されます）。 これは、
フレームをセットアップする時間を節約するために、
頻繁に利用されるライブラリ関数に対してしばしば適用されます。
これらの関数の呼び出しを処理するためにGDBが提供する機能は限られています。
最下位のフレームの関数呼び出しがスタック・フレームを持たない場合、
GDBは、 あたかもそれが通常どおりに番号0のフレームを持つものとみなして、
関数呼び出しの連鎖を跡づけることができるようにします。 しかしながら、
最下位以外のスタック位置に存在する、 フレームを持たない関数に対しては、
GDBは特別な処置を取りません。

`frame ARGS'
     `frame'コマンドによって、
     あるスタック・フレームから別のスタック・フレームに移動し、
     選択したスタック・フレームを表示させることができます。 ARGSは、
     フレームのアドレスまたはスタック・フレーム番号です。
     引数なしで実行すると、
     `frame'コマンドはカレントなスタック・フレームを表示します。

`select-frame'
     `select-frame'コマンドによって、 フレームを表示することなく、
     あるスタック・フレームから別のスタック・フレームに移動することができます。
     これは、 `frame'コマンドから、 表示処理を取り除いたものです。


File: gdb-ja.info,  Node: Backtrace,  Next: Selection,  Prev: Frames,  Up: Stack

6.2 バックトレース
==================

バックトレースとは、
ユーザ・プログラムが現在いる箇所にどのようにして到達したかを示す要約情報です。
複数のフレームが存在する場合、 1フレームの情報を1行に表示します。
現在実行中のフレーム （番号0のフレーム） を先頭に、
それを呼び出したフレーム （番号1のフレーム） を次行に、 以降、
同様にスタックをさかのぼって情報を表示します。

`backtrace'
`bt'
     全スタックのバックトレースを表示します。
     スタック内のすべてのフレームが、 1行に1フレームずつ表示されます。

     システムの割り込み文字 （通常は、`Ctrl'キーを押しながら`C'を押す）
     によって、 いつでもバックトレースを停止することができます。

`backtrace N'
`bt N'
     引数のない`backtrace'コマンドと似ていますが、
     最下位のフレームから数えてN個のフレームだけが表示されます。

`backtrace -N'
`bt -N'
     引数のない`backtrace'コマンドと似ていますが、
     最上位のフレームから数えてN個のフレームだけが表示されます。

   `backtrace'の別名としては、 ほかに`where'や`info stack'
（省略形は`info s'） があります。

   `backtrace'コマンドの出力結果の各行に、
フレーム番号と関数名が表示されます。 `set print address
off'コマンドを実行していなければ、
プログラム・カウンタの値も表示されます。
`backtrace'コマンドの出力結果では、 関数への引数に加えて、
ソース・ファイル名や行番号も表示されます。 プログラム・カウンタが、
行番号で指定される行の最初のコードを指している場合、
その値は省略されます。

   以下に`backtrace'の例を示します。 これは、 `bt 3'の出力であり、
したがって最下位のフレームから3フレームが表示されています。

     #0  m4_traceon (obs=0x24eb0, argc=1, argv=0x2b8c8)
         at builtin.c:993
     #1  0x6e38 in expand_macro (sym=0x2b600) at macro.c:242
     #2  0x6840 in expand_token (obs=0x0, t=177664, td=0xf7fffb08)
         at macro.c:71
     (More stack frames follow...)

番号0のフレームを表示する行の先頭には、
プログラム・カウンタの値がありません。 これは、
`builtin.c'の`993'行めの最初のコードにおいて
ユーザ・プログラムが停止したことを表わしています。


File: gdb-ja.info,  Node: Selection,  Next: Frame Info,  Prev: Backtrace,  Up: Stack

6.3 フレームの選択
==================

スタックやユーザ・プログラム内の他のデータを調べるためのほとんどのコマンドは、
それが実行された時点において選択されているスタック・フレーム上で動作します。
以下に、 スタック・フレームを選択するためのコマンドを列挙します。
どのコマンドも、
それによって選択されたスタック・フレームに関する簡単な説明を最後に表示します。

`frame N'
`f N'
     番号Nのフレームを選択します。 最下位の （現在実行中の）
     フレームが番号0のフレーム、
     最下位のフレームを呼び出したフレームが番号1のフレーム、
     以下同様となります。
     最も大きい番号を持つフレームは`main'のフレームです。

`frame ADDR'
`f ADDR'
     アドレスADDRのフレームを選択します。
     スタック・フレームの連鎖がバグのために破壊されてしまって、
     GDBがすべてのフレームに正しく番号を割り当てられないような場合に、
     この方法が役に立ちます。 さらに、
     ユーザ・プログラムが複数のスタックを持ち、
     スタックの切り替えを行うような場合にも有効です。

     SPARCアーキテクチャでは、 フレームを任意に選択するには、
     フレーム・ポインタ、
     スタック・ポインタの2つのアドレスを`frame'に指定する必要があります。

     MIPS、 Alphaの両アーキテクチャでは、 スタック・ポインタ、
     プログラム・カウンタの2つのアドレスが必要です。

     29kアーキテクチャでは、 レジスタ・スタック・ポインタ、
     プログラム・カウンタ、
     メモリ・スタック・ポインタの3つのアドレスが必要です。

`up N'
     スタックをNフレームだけ上へ移動します。 Nが正の値の場合、
     最上位のフレームに向かって移動します。 これは、
     より大きいフレーム番号を持ち、
     より長く存在しているフレームへの移動です。 Nのデフォルト値は、
     0です。

`down N'
     スタックをNフレームだけ下へ移動します。 Nが正の値の場合、
     最下位のフレームに向かって移動します。 これは、
     より小さいフレーム番号を持ち、
     より最近作成されたフレームへの移動です。 Nのデフォルト値は1です。
     `down'の省略形は`do'です。

   これらのコマンドはいずれも、
最後にフレームに関する情報を2行で表示します。 1行めには、 フレーム番号、
関数名、 引数、 ソース・ファイル名、
そのフレーム内において実行停止中の行番号が表示されます。 2行めには、
実行停止中のソース行が表示されます。

   以下に、 例を示します。

     (gdb) up
     #1  0x22f0 in main (argc=1, argv=0xf7fffbf4, env=0xf7fffbfc)
         at env.c:10
     10              read_input_file (argv[i]);

   この情報が表示された後で、 `list'コマンドを引数なしで実行すると、
フレーム内で実行停止中の行を中心に10行のソース行が表示されます。 *Note
Printing source lines: List。

`up-silently N'
`down-silently N'
     これら2つのコマンドは、 それぞれ、 `up'コマンド、
     `down'コマンドの変種です。 相違点は、 ここに挙げた2つのコマンドが、
     新しいフレームに関する情報を表示することなく実行されるという点にあります。
     これらは、 情報の出力が不必要で邪魔ですらある、
     GDBのコマンド・スクリプトの中での使用を主に想定したものです。


File: gdb-ja.info,  Node: Frame Info,  Next: Alpha/MIPS Stack,  Prev: Selection,  Up: Stack

6.4 フレームに関する情報
========================

既に挙げたもの以外にも、
選択されたフレームに関する情報を表示するコマンドがいくつかあります。

`frame'
`f'
     このコマンドは、 引数なしで実行されると、
     別のフレームを選択するのではなく、
     その時点において選択中のフレームに関する簡単な説明を表示します。
     このコマンドの省略形は`f'です。 引数付きの場合、
     このコマンドはスタック・フレームを選択するのに使用されます。 *Note
     Selecting a frame: Selection。

`info frame'
`info f'
     このコマンドは、 選択されたフレームに関する詳細な情報を表示します。
     表示される情報には、 以下のようなものがあります。

        * フレームのアドレス

        *
          1つ下位の（選択されたフレームによって呼び出された）フレームのアドレス

        * 1つ上位の（選択されたフレームを呼び出した）フレームのアドレス

        * 選択されたフレームに対応するソース・コードを記述した言語

        * フレームの引数のアドレス

        *
          退避されているプログラム・カウンタ（呼び出し側フレームの実行アドレス）

        * 退避されているレジスタ

     これらの詳細な情報は、 何か問題が発生して、
     スタックの形式が通常の慣習に合致しなくなった場合に、 役に立ちます。

`info frame ADDR'
`info f ADDR'
     アドレスADDRのフレームに関する詳細な情報を、
     そのフレームを選択することなく表示します。 このコマンドによって、
     その時点において選択されていたフレームとは異なるフレームが選択されてしまうことはありません。
     このコマンドでは、 `frame'コマンドに指定するのと同様のアドレスを
     （アーキテクチャによっては複数） 指定する必要があります。 *Note
     Selecting a frame: Selection。

`info args'
     選択中のフレームの引数を、 1行に1つずつ表示します。

`info locals'
     選択中のフレームのローカル変数を、 1行に1つずつ表示します。
     これらはすべて、 選択中のフレームの実行箇所においてアクセス可能な
     （静的変数または自動変数として宣言された） 変数です。

`info catch'
     選択中のスタック・フレームの実行箇所においてアクティブな状態にある、
     すべての例外ハンドラの一覧を表示します。
     他の例外ハンドラを参照したい場合は、 関連するフレームに
     （`up'コマンド、 `down'コマンド、 `frame'コマンドを使用して）
     移動してから、 `info catch'を実行します。 *Note Setting
     catchpoints: Set Catchpoints。


File: gdb-ja.info,  Node: Alpha/MIPS Stack,  Prev: Frame Info,  Up: Stack

6.5 MIPS/Alphaマシンの関数スタック
==================================

AlphaベースのコンピュータとMIPSベースのコンピュータは、
変わったスタック・フレームを使用しています。 そのため、
関数の先頭を見つけるために、
GDBはときどきオブジェクト・コードを逆方向に検索する必要があります。

   応答時間を改善するために （特に、 このような検索を実行するのに、
速度の遅いシリアル回線を使用するほかない、
組み込みアプリケーションの場合）、
以下に列挙するコマンドを使用して検索量を制限するとよいでしょう。

`set heuristic-fence-post LIMIT'
     関数の先頭を検索するためにGDBが検査するバイト数を、
     最高でLIMITバイトに制限します。 LIMITに0 （デフォルト）
     を指定すると、 無制限に検索することを意味します。
     LIMITに0以外の値を指定すると、
     その値が大きければ大きいほど検索バイト数も多くなり、
     したがって検索の実行により長い時間がかかります。

`show heuristic-fence-post'
     現在の検索制限値を表示します。

これらのコマンドは、 GDBが、 Alphaプロセッサ上、 または、
MIPSプロセッサ上においてプログラムをデバッグするよう構成されている場合に
_のみ_使用することができます。


File: gdb-ja.info,  Node: Source,  Next: Data,  Prev: Stack,  Up: Top

7 ソース・ファイルの検査
************************

GDBは、
ユーザ・プログラムのソース・コードの一部を表示することができます。
これは、 プログラムの中に記録されているデバッグ情報によって、
そのプログラムをビルドするのに使用されたソース・ファイルを
GDBが知ることができるからです。 ユーザ・プログラムが停止すると、
GDBは自発的にプログラムが停止した行を表示します。 同様に、
ユーザがあるスタック・フレーム （*note Selecting a frame: Selection.）
を選択すると、
そのフレームにおいて実行が停止している行をGDBは表示します。
明示的にコマンドを使用することで、
ソース・ファイルの他の部分を表示することも可能です。

   GNU Emacsインターフェイス経由でGDBを使用しているユーザは、
Emacsの提供する機能を使ってソース・ファイルを参照する方を好むかもしれません。
これについては、 *Note Using GDB under GNU Emacs: Emacs。

* Menu:

* List::                        ソース行の表示

* Search::                      ソース・ファイル内の検索

* Source Path::                 ソース・ディレクトリの指定
* Machine Code::                ソースとマシン・コード


File: gdb-ja.info,  Node: List,  Next: Search,  Prev: Source,  Up: Source

7.1 ソース行の表示
==================

ソース・ファイル内の行を表示するには、 `list'コマンド （省略形は`l'）
を使用します。 デフォルトでは、 10行が表示されます。
ソース・ファイルのどの部分を表示するかを指定する方法がいくつかあります。

   最もよく使われる`list'コマンドの形式を以下に示します。

`list LINENUM'
     現在のソース・ファイルの行番号LINENUMを中心に、
     その前後の行を表示します。

`list FUNCTION'
     関数FUNCTIONの先頭を中心に、 その前後の行を表示します。

`list'
     ソース・ファイル行の続きを表示します。
     既に表示された最後の行が`list'コマンドによって表示されたのであれば、
     その最後の行の次の行以降が表示されます。 しかし、
     既に表示された最後の行が、 スタック・フレーム （*note Examining
     the Stack: Stack.） の表示の一部として1行だけ表示されたのであれば、
     その行の前後の行が表示されます。

`list -'
     前回表示された行の前に位置する行を表示します。

   `list'コマンドを上記の形式のいずれかによって実行すると、
GDBはデフォルトでは10行のソース行を表示します。 これは`set
listsize'コマンドによって変更することができます。

`set listsize COUNT'
     `list'コマンドで表示される行数をCOUNTに設定します
     （`list'コマンドの引数で他の値が明示的に指定された場合は、
     この設定は効力を持ちません）。

`show listsize'
     `list'コマンドが表示する行数を表示します。

   `list'コマンドを実行後、
<RET>キーによって`list'コマンドを実行した場合、 引数は破棄されます。
したがって、 これは単に`list'と入力して実行したのと同じことになります。
同じ行が繰り返し表示されるよりも、 この方が役に立つでしょう。 ただし、
引数`-'は例外となります。 この引数は繰り返し実行の際にも維持されるので、
繰り返し実行することで、
ソース・ファイルの内容がさかのぼって表示されていきます。

   一般的には、 `list'コマンドは、 ユーザによって0個、 1個、
または2個の"行指定"（"linespec"）が与えられることを期待しています。
ここで行指定とは、 ソース行を指定するものです。
いくつかの記述方法がありますが、
いずれも結果的には何らかのソース行を指定するものです。
`list'コマンドの引数として使用できる引数の完全な説明を以下に示します。

`list LINESPEC'
     LINESPECによって指定される行を中心に、 その前後の行を表示します。

`list FIRST,LAST'
     FIRST行からLAST行までを表示します。 両引数はいずれも行指定です。

`list ,LAST'
     LAST行までを表示します。

`list FIRST,'
     FIRST行以降を表示します。

`list +'
     最後に表示された行の次の行以降を表示します。

`list -'
     最後に表示された行の前の行以前を表示します。

`list'
     前述のとおり。

   以下に、 ソースの特定の1行を指定する方法を示します。 これは、
いずれも行指定です。

`NUMBER'
     現在のソース・ファイルの行番号NUMBERの行を指定します。
     `list'コマンドの引数に2つの行指定がある場合、 2つめの行指定は、
     最初の行指定と同一のソース・ファイルを指定します。

`+OFFSET'
     最後に表示された行からOFFSETで指定される行数だけ下にある行を指定します。
     2つの行指定を引数として持つ`list'コマンドにおいて、
     これが2つめの行指定として使用される場合、
     最初の行指定からOFFSETで指定される行数だけ下の行を指定します。

`-OFFSET'
     最後に表示された行からOFFSETで指定される行数だけ上にある行を指定します。

`FILENAME:NUMBER'
     ソース・ファイルFILENAMEの行番号NUMBERの行を指定します。

`FUNCTION'
     関数FUNCTIONの本体の先頭行を指定します。 例えばC言語では、 左括弧
     （`{'） のある行を指します。

`FILENAME:FUNCTION'
     ファイルFILENAME内の関数FUNCTIONの本体を開始する左括弧 （`{'）
     のある行を指定します。
     異なるソース・ファイルの中に同一の名前の関数が複数ある場合にのみ、
     あいまいさを回避するために、
     関数名とともにファイル名を指定する必要があります。

`*ADDRESS'
     プログラム・アドレスADDRESSを含む行を指定します。
     ADDRESSには任意の式を指定することができます。


File: gdb-ja.info,  Node: Search,  Next: Source Path,  Prev: List,  Up: Source

7.2 ソース・ファイル内の検索
============================

カレントなソース・ファイル内において正規表現による検索を行うためのコマンドが2つあります。

`forward-search REGEXP'
`search REGEXP'
     `forward-search REGEXP'コマンドは、
     最後に`list'コマンドによって表示された行の1つ下の行から、
     1行ずつ正規表現REGEXPによる検索を行います。
     正規表現にマッチするものが見つかると、 その行を表示します。
     `search REGEXP'という同義のコマンドを使うこともできます。
     コマンド名は、 省略して`fo'とすることができます。

`reverse-search REGEXP'
     `reverse-search REGEXP'コマンドは、
     最後に`list'コマンドによって表示された行の1つ上の行から、
     1行ずつ逆方向に向かって正規表現REGEXPによる検索を行います。
     正規表現にマッチするものが見つかると、 その行を表示します。
     コマンド名は、 省略して`rev'とすることができます。


File: gdb-ja.info,  Node: Source Path,  Next: Machine Code,  Prev: Search,  Up: Source

7.3 ソース・ディレクトリの指定
==============================

実行形式プログラムは、
それがコンパイルされたソース・ファイルの名前だけを記録して、
ソース・ファイルの存在するディレクトリ名を記録しないことがあります。
また、 ディレクトリ名が記録された場合でも、
コンパイル時とデバッグ時との間に、
そのディレクトリが移動してしまっている可能性があります。 GDBは、
ソース・ファイルを検索すべきディレクトリの一覧を持っています。 これは、
"ソース・パス"と呼ばれます。 GDBは、
ソース・ファイルが必要なときにはいつでも、 それが見つかるまで、
このリストの中のすべてのディレクトリを、
リストの中に記述されている順に探します。 実行ファイルのサーチ・パスは、
この目的では_使用されない_ことに気をつけてください。
またカレントな作業ディレクトリも、
それがたまたまソース・パスの中にある場合を除けば、
この目的で使用されることはありません。

   GDBがソース・パスの中でソース・ファイルを見つけることができない場合、
プログラムがディレクトリ名を記録してあれば、
そのディレクトリも検索されます。
ソース・パスにディレクトリの指定がなく、
コンパイルされたディレクトリの名前も記録されていない場合、
GDBは最後の手段としてカレント・ディレクトリを探します。

   ソース・パスを空にした場合、 または、 再調整した場合、
ソース・ファイルを見つけた場所や個々の行のファイル内の位置のような、
GDBが内部でキャッシュしている情報は消去されます。

   GDBを起動した時点では、
ソース・パスにはディレクトリの指定がありません。
ディレクトリをソース・パスに追加するには、
`directory'コマンドを使用してください。

`directory DIRNAME ...'

`dir DIRNAME ...'
     ディレクトリDIRNAMEをソース・パスの先頭に追加します。
     個々のディレクトリをコロン`:'または空白で区切ることによって、
     複数のディレクトリをこのコマンドに渡すことができます。
     ソース・パスの中に既に存在するディレクトリを指定することもできます。
     この場合、 そのディレクトリの、
     ソース・パスの中での位置が前に移動するので、
     GDBはそのディレクトリの中を以前よりも早く検索することになります。

     （コンパイル時のディレクトリが記録されていれば）
     それを指すのに文字列`$cdir'を使うことができます。 また、
     カレントな作業ディレクトリを指すには、
     文字列`$cwd'を使うことができます。 `$cwd'と`.' （ピリオド）
     とは同じではありません。 前者は、
     GDBセッション内においてカレントな作業ディレクトリが変更された場合、
     変更されたディレクトリを指します。 これに対して後者は、
     ソース・パスへの追加を行ったときに、
     その時点におけるカレント・ディレクトリに展開されてしまいます。

`directory'
     ソース・パスの内容を再び空にします。 ソース・パスを空にする前に、
     確認を求めてきます。

`show directories'
     ソース・パスを表示します。
     ソース・パスに含まれるディレクトリ名を見ることができます。

   ソース・パスの中に、
不要となってしまったディレクトリが混在していると、
GDBが誤ったバージョンのソースを見つけてしまい、
混乱をもたらすことがあります。 以下の手順によって、
正常な状態にすることができます。

  1. ソース・パスを空にするために、
     `directory'コマンドを引数なしで実行します。

  2. ソース・パス中に含めたいディレクトリが組み込まれるよう、
     `directory'コマンドに適切な引数を指定して実行します。
     すべてのディレクトリを、
     1回のコマンド実行で追加することができます。


File: gdb-ja.info,  Node: Machine Code,  Prev: Source Path,  Up: Source

7.4 ソースとマシン・コード
==========================

`info line'コマンドを使用してソース行をプログラム・アドレスに
（あるいは、 プログラム・アドレスをソース行に）
対応付けすることができます。 また、 `disassemble'コマンドを使用して、
あるアドレス範囲をマシン命令として表示することもできます。 GNU
Emacsモードで実行されている場合、 現在の`info line'コマンドは、
指定された行を示す矢印を表示します。 また、 `info line'コマンドは、
アドレスを16進形式だけではなくシンボリック形式でも表示します。

`info line LINESPEC'
     ソース行LINESPECに対応するコンパイル済みコードの開始アドレス、
     終了アドレスを表示します。 `list'コマンド （*note Printing source
     lines: List.）
     が理解できる任意の形式によってソース行を指定することができます。

   例えば、 `info line'コマンドによって、
関数`m4_changequote'の最初の行に対応するオブジェクト・コードの位置を知ることができます。

     (gdb) info line m4_changecom
     Line 895 of "builtin.c" starts at pc 0x634c and ends at 0x6350.

また、 （LINESPECの形式として`*ADDR'を使用することで）
ある特定のアドレスがどのソース行に含まれているのかを問い合わせることができます。

     (gdb) info line *0x63ff
     Line 926 of "builtin.c" starts at pc 0x63e4 and ends at 0x6404.

   `info line'の実行後、 `x'コマンドのデフォルト・アドレスは、
その行の先頭アドレスに変更されます。 これにより、
マシン・コードの調査を開始するには`x/i'を実行するだけで十分となります
（*note Examining memory: Memory.）。 また、
このアドレスはコンビニエンス変数`$_'の値として保存されます （*note
Convenience variables: Convenience Vars.）。

`disassemble'
     この特殊コマンドは、
     あるメモリ範囲をマシン命令としてダンプ出力します。
     デフォルトのメモリ範囲は、
     選択されたフレームにおいてプログラム・カウンタが指している箇所を含む関数です。
     このコマンドに引数を1つ渡すと、
     それはプログラム・カウンタ値を指定することになります。 GDBは、
     その値が指す箇所を含んでいる関数をダンプ出力します。
     2つの引数を渡すと、 ダンプ出力するアドレス範囲
     （1つめのアドレスは含まれますが、 2つめのアドレスは含まれません）
     を指定することになります。

   以下の例は、 あるアドレス範囲のHP PA-RISC
2.0コードを逆アセンブルした結果を示しています。

     (gdb) disas 0x32c4 0x32e4
     Dump of assembler code from 0x32c4 to 0x32e4:
     0x32c4 <main+204>:      addil 0,dp
     0x32c8 <main+208>:      ldw 0x22c(sr0,r1),r26
     0x32cc <main+212>:      ldil 0x3000,r31
     0x32d0 <main+216>:      ble 0x3f8(sr4,r31)
     0x32d4 <main+220>:      ldo 0(r31),rp
     0x32d8 <main+224>:      addil -0x800,dp
     0x32dc <main+228>:      ldo 0x588(r1),r26
     0x32e0 <main+232>:      ldil 0x3000,r31
     End of assembler dump.

   アーキテクチャによっては、
一般に使用される命令ニーモニックを複数持つものや、
異なる構文を持つものがあります。

`set assembly-language INSTRUCTION-SET'
     `disassemble'コマンドまたは`x/i'コマンドによってプログラムの逆アセンブルを行う際に使用する
     命令セットを選択します。

     現在のところ、 このコマンドは、 Intel
     x86ファミリに対してのみ定義されています。 INSTRUCTION-SETは、
     `i386'と`i8086'のいずれかにセットすることができます。
     デフォルトは`i386'です。


File: gdb-ja.info,  Node: Data,  Next: Languages,  Prev: Source,  Up: Top

8 データの検査
**************

ユーザ・プログラムの中のデータを調べる通常の方法は、 `print'コマンド
（省略形は`p'）、 またはそれと同義のコマンドである
`inspect'コマンドを使用することです。 これは、
ユーザ・プログラムが記述された言語 （*note Using GDB with Different
Languages: Languages.） による式を評価し、 その値を出力するものです。

`print EXP'
`print /F EXP'
     EXPは （ソース言語による） 式です。 デフォルトでは、 EXPの値は、
     EXPのデータ型にとって適切な形式で表示されます。
     `/F'を指定することで、 他の形式を選択することも可能です。
     `/F'のFは形式を指定する文字です。 *note Output formats: Output
     Formats.。

`print'
`print /F'
     EXPを省略すると、 GDBは"値ヒストリ" （*note Value history: Value
     History.） の最後の値を再表示します。 これは、
     同じ値を異なる形式で調べるのに便利です。

   データを調べるためのより低レベルの方法は、
`x'コマンドを使うことです。 これは、
指定されたアドレスのメモリ上のデータを、
指定された形式で表示するものです。 *Note Examining memory: Memory。

   型に関する情報に関心があるとき、 また、 構造体 やクラス
のフィールドがどのように宣言されているかという点に関心があるときは、
`print'コマンドではなく`ptype EXP'コマンドを使用してください。 *Note
Examining the Symbol Table: Symbols。

* Menu:

* Expressions::                 式
* Variables::                   プログラム変数
* Arrays::                      人工配列
* Output Formats::              出力フォーマット
* Memory::                      メモリの調査
* Auto Display::                自動表示
* Print Settings::              表示設定
* Value History::               値ヒストリ
* Convenience Vars::            コンビニエンス変数
* Registers::                   レジスタ

* Floating Point Hardware::     浮動小数ハードウェア


File: gdb-ja.info,  Node: Expressions,  Next: Variables,  Prev: Data,  Up: Data

8.1 式
======

`print'コマンド、 および、 ほかの多くのGDBコマンドは、 式を受け取って、
その値を評価します。
ユーザの使用しているプログラミング言語によって定義されている定数、
変数、 演算子は、 いずれもGDBにおける式の中で有効です。 これには、
条件式、 関数呼び出し、 キャスト、 文字列定数が含まれます。 しかし、
プリプロセッサの`#define'コマンドによって定義されるシンボルは、
残念ながら含まれません。

   現在のGDBは、 ユーザの入力する式において配列定数をサポートします。
その構文は、 {ELEMENT, ELEMENT...}です。 例えば、 コマンド`print {1, 2,
3}'を使用して、
ターゲット・プログラム内で`malloc()'によって獲得されたメモリ内に配列を作成することができます。

   C言語は大変広汎に使用されているので、
このマニュアルの中で示される例の中の式はC言語で記述されています。
他の言語での式の使い方に関する情報については、 *Note Using GDB with
Different Languages: Languages。

   この節では、
プログラミング言語によらずGDBの式で使用できる演算子を説明します。

   キャストは、 C言語のみならず、 すべての言語でサポートされています。
これは、 メモリ内のあるアドレスにある構造体を調べるのに、
数値をポインタにキャストするのが大変便利であるからです。

   プログラミング言語によらず共通に使用可能な演算子に加えて、
GDBは以下の演算子をサポートしています。

`@'
     `@'は、 メモリの一部を配列として処理するための2項演算子です。
     詳細については、 *Note Artificial arrays: Arrays。

`::'
     `::'によって、 それを定義している関数またはファイルを特定して、
     変数を指定することができます。 *Note Program variables: Variables。

`{TYPE} ADDR'
     ADDRで示されるメモリ上のアドレスに格納されている、
     TYPEで示される型のオブジェクトを参照します。 ADDRには、
     評価結果が整数値またはポインタになるような任意の式を指定することができます
     （ただし、 2項演算子の前後には、
     キャストを使う場合と同様の括弧が必要です）。 これは、
     ADDRの位置に通常存在するデータの型がいかなるものであろうとも、
     使用することができます。


File: gdb-ja.info,  Node: Variables,  Next: Arrays,  Prev: Expressions,  Up: Data

8.2 プログラム変数
==================

最も一般的に使用される式は、 ユーザ・プログラム内部の変数名です。

   式の中の変数は、 選択されたスタック・フレーム （*note Selecting a
frame: Selection.） 内において解釈されます。 これは、
以下の2つのいずれかとなります。

   * グローバル変数 （または、 ファイル・スコープの静的変数）

あるいは

   * プログラム言語のスコープ規則によって、
     そのフレームの実行中の箇所から可視の変数

つまり、 以下の例において、 ユーザ・プログラムが関数`foo'を実行中は、
変数`a'を調べたり使用したりすることができますが、
変数`b'を使用したり調べたりすることができるのは、
`b'が宣言されているブロックの内部をユーザ・プログラムが実行中である場合に限られます。

     foo (a)
          int a;
     {
       bar (a);
       {
         int b = test ();
         bar (b);
       }
     }

   ただし、 これには1つ例外があります。
特定の1ソース・ファイルをスコープとする変数や関数は、
たとえ現在の実行箇所がそのファイルの中ではなくても、
参照することができます。 しかし、 このような変数または関数が
（異なるソース・ファイル中に）
同じ名前で複数個存在するということがありえます。 このような場合、
その名前を参照すると予期できない結果をもたらします。
2つのコロンを並べる記法によって、
特定の関数またはファイルの中の静的変数を指定することができます。

     FILE::VARIABLE
     FUNCTION::VARIABLE

ここでFILEまたはFUNCTIONは、 静的変数VARIABLEのコンテキスト名です。
ファイル名の場合は、 引用符を使用することによって、
GDBがファイル名を確実に1つの単語として解釈するようにさせることができます。
例えば、
ファイル`f2.c'の中で定義されたグローバル変数`x'の値を表示するには、

     (gdb) p 'f2.c'::x

のようにします。

   このような`::'の用途が、
これと非常によく似ているC++における`::'の用途と衝突することは非常に稀です。
GDBは、
式の内部においてC++のスコープ解釈演算子の使用もサポートしています。

     _注意:_ ときどき、
     新しいスコープに入った直後やスコープから出る直前に、
     関数内部の特定の箇所から見ると、
     ローカル変数の値が正しくないように見えることがあります。
   マシン命令単位でステップ実行を行っているときに、
このような問題を経験することがあるかもしれません。 これは、
ほとんどのマシンでは、 （ローカル変数定義を含む）
スタック・フレームのセットアップに複数の命令が必要となるからです。
マシン命令単位でステップ実行を行う場合、
スタック・フレームが完全に構築されるまでの間は、
変数の値が正しくないように見えることがあります。
スコープから出るときには、 スタック・フレームを破棄するのに、
通常複数のマシン命令が必要とされます。
それらの命令群の中をステップ実行し始めた後には、
ローカル変数の定義は既に存在しなくなっているかもしれません。

   このようなことは、 コンパイラが重要な最適化を実施する場合にも、
発生する可能性があります。
常に正確な値が見えることを確実にするためには、 コンパイルの際に、
すべての最適化を行わないようにします。


File: gdb-ja.info,  Node: Arrays,  Next: Output Formats,  Prev: Variables,  Up: Data

8.3 人工配列
============

メモリ内に連続的に配置されている同一型のオブジェクトを表示することが役に立つことがよくあります。
配列の一部や動的にサイズの決定される配列にアクセスするのに、
そこへのポインタしかプログラム内部に存在しないような場合です。

   これは、 2項演算子`@'を使用して、
連続したメモリ範囲を"人工配列"として参照することで可能です。
`@'の左側のオペランドは、 参照したい配列の最初の要素で、 かつ、
1個のオブジェクトでなければなりません。 また、 右側のオペランドは、
その配列の中の参照したい部分の長さでなければなりません。 結果は、
その要素がすべて左側の引数と同型である配列の値です。
第1の要素は左側の引数そのものです。 第2の要素は、
第1の要素を保持するメモリ域の直後のメモリ上から取られます。
これ以降の要素も同様です。 以下に例を示します。
プログラムが以下のようになっているとしましょう。

     int *array = (int *) malloc (len * sizeof (int));

以下を実行することで、 `array'の内容を表示することができます。

     p *array@len

   `@'の左側のオペランドは、
メモリ上に実在するものでなければなりません。
このような方法で`@'によって作成された配列の値は、
配列の添字付けの見地からは他の配列と同様に振る舞い、
式の中で使用された場合は強制的にポインタとして扱われます。 人工配列は、
一度表示された後、 値ヒストリ （*note Value history: Value History.）
を通して式の中に現れることがよくあります。

   人工配列を作成するもう1つの方法は、 キャストを使用することです。
これによって、 ある値を配列として解釈し直します。 この値は、
メモリ上に実在するものでなくてもかまいません。
     (gdb) p/x (short[2])0x12345678
     $1 = {0x1234, 0x5678}

   ユーザの便宜を考慮して、 （例えば、 `(TYPE[])VALUE'のように）
配列の長さが省略された場合 その値を満たすサイズを
（`sizeof(VALUE)/sizeof(TYPE)'のように） GDBが計算します。
     (gdb) p/x (short[])0x12345678
     $2 = {0x1234, 0x5678}

   ときには、 人工配列の機構では十分でないことがあります。
かなり複雑なデータ構造では、
関心のある要素が連続的に並んでいないことがあります。 例えば、
配列の中のポインタの値に関心がある場合です。
このような状況において役に立つ回避策の1つに、
関心のある値のうち最初のものを表示する式の中のカウンタとしてコンビニエンス変数
（*note Convenience variables: Convenience Vars.） を使用し、
<RET>キーによってその式を繰り返し実行することです。 例えば、
構造体へのポインタの配列`dtab'があり、
個々の構造体のフィールド`fv'の値に関心があるとしましょう。 以下に、
この場合の例を示します。

     set $i = 0
     p dtab[$i++]->fv
     <RET>
     <RET>
     ...


File: gdb-ja.info,  Node: Output Formats,  Next: Memory,  Prev: Arrays,  Up: Data

8.4 出力フォーマット
====================

デフォルトでは、 GDBはデータの型にしたがって値を表示します。 ときには、
これが望ましくない場合もあります。 例えば、
数値を16進で表示したい場合やポインタを10進で表示したい場合があるでしょう。
あるいは、
メモリ内のある特定のアドレスのデータを文字列や命令として表示させたい場合もあるでしょう。
このようなことをするためには、
値を表示するときに"出力フォーマット"を指定します。

   出力フォーマットの最も単純な使用方法は、
既に評価済みの値の表示方法を指定することです。 これは、
`print'コマンドの最初の引数をスラッシュとフォーマット文字で開始することで行います。
サポートされているフォーマット文字は、 以下のとおりです。

`x'
     値を整数値とみなし、 16進で表示します。

`d'
     値を符号付き10進の整数値として表示します。

`u'
     値を符号なし10進の整数値として表示します。

`o'
     値を8進の整数値として表示します。

`t'
     値を2進の整数値として表示します。 `t'はtwoを省略したものです。 (1)

`a'
     値を、 16進の絶対アドレス、 および、
     そのアドレスより前にあるシンボルのうち最も近い位置にあるものからのオフセット・アドレスとして表示します。
     このフォーマットを使用することで、 未知のアドレスがどこに
     （どの関数の中に） あるのかを知ることができます。

          (gdb) p/a 0x54320
          $3 = 0x54320 <_initialize_vx+396>

`c'
     値を整数値とみなし、 文字定数として表示します。

`f'
     値を浮動小数点数値とみなし、 典型的な浮動小数点の構文で出力します。

   例えば、 プログラム・カウンタの値を16進数で表示する （*note
Registers::） には、 以下を実行してください。

     p/x $pc

スラッシュの前にはスペースが必要ではないことに注意してください。
これは、 GDBのコマンド名にはスラッシュを含めることができないからです。

   値ヒストリの最後の値を異なる形式で再表示するには、
`print'コマンドに対して式を指定せずにフォーマットだけを指定して実行します。
例えば、 `p/x'を実行すると最後の値を16進で再表示します。

   ---------- Footnotes ----------

   (1) 原注：フォーマット文字`b'は使用できません。
フォーマット文字は`x'コマンドでも共通して使用されますが、
`x'コマンドでは、 `b'はbyteの省略形として使用されているためです。 *Note
Examining memory: Memory。


File: gdb-ja.info,  Node: Memory,  Next: Auto Display,  Prev: Output Formats,  Up: Data

8.5 メモリの調査
================

コマンド`x' （examineのx） を使用することで、
ユーザ・プログラム内のデータ型にかかわらず、
メモリ上の値をいくつかの形式で調べることができます。

`x/NFU ADDR'
`x ADDR'
`x'
     メモリ上の値を調べるには`x'コマンドを使用してください。

   N、 F、 Uはいずれも、
どれだけのメモリをどのようにフォーマットして表示するかを指定するための、
必須ではないパラメータです。 ADDRは、
メモリの表示を開始するアドレスを指定する式です。
NFUの部分にデフォルトを使用するのであれば、
スラッシュ`/'は必要ありません。 いくつかのコマンドによって、
ADDRに対して便利なデフォルト値を指定することができます。

N（繰り返し回数）
     繰り返し回数は10進の整数値です。 デフォルトは1です。 これによって、
     （単位Uの） メモリをどれだけ表示するかを指定します。

F（表示フォーマット）
     表示フォーマットには、
     `print'コマンドによって使用されるフォーマット、
     `s'（NULL文字で終了する文字列）、 `i'（マシン命令）
     のいずれかを指定します。 初期状態では、 デフォルトは`x' （16進）
     です。 デフォルトは、
     `x'コマンドまたは`print'コマンドを実行するたびに変更されます。

U（メモリ・サイズの単位）
     単位の大きさは以下のいずれかになります。

    `b'
          バイト

    `h'
          ハーフ・ワード（2バイト）

    `w'
          ワード（4バイト）--これが初期状態のデフォルトです。

    `g'
          ジャイアント・ワード（8バイト）

     `x'コマンド実行時に単位の大きさを指定するたびに、 その大きさが、
     次に`x'コマンドを実行する際のデフォルトになります
     （フォーマット`s'および `i'については、
     単位の大きさは無視されます。 これらについては、 通常、
     単位の大きさを指定しません）。

ADDR（表示を開始するアドレス）
     ADDRは、 GDBにメモリの表示を開始させたいアドレスです。 この式は、
     必ずしもポインタ値を持つ必要はありません
     （ポインタ値を持つことも可能です）。 これは常に、
     メモリ内のある1バイトを指す整数値のアドレスとして解釈されます。
     式に関する詳細については、 *Note Expressions: Expressions。
     ADDRのデフォルトは通常、
     最後に調べられたアドレスの次のアドレスになります。 しかし、
     ほかのコマンドによってもデフォルトのアドレスが設定されます。
     該当するコマンドは、 `info breakpoints' （デフォルトは、
     最後に表示されたブレイクポイントのアドレスに設定されます）、 `info
     line' （デフォルトは、 行の先頭アドレスに設定されます）、
     および`print'コマンド （メモリ内の値を表示するのに使用した場合）
     です。

   例えば、 `x/3uh 0x54320'は、 先頭アドレス`0x54320'から始めて、
メモリ上の3個のハーフ・ワード （`h'） の値を、 符号なし10進整数値
（`u'） としてフォーマットして表示するよう求める要求です。 また、
`x/4xw $sp'は、 スタック・ポインタ （`$sp'については、 *note
Registers::） の上位4ワード （`w'） のメモリの内容を16進 （`x'）
で表示します。

単位の大きさを示す文字と出力フォーマットを指定する文字とは異なるので、
単位の大きさとフォーマットのどちらが前にくるべきかを記憶しておく必要はありません。
どちらを先に記述しても動作します。
`4xw'という出力指定と`4wx'という出力指定とは、 全く同一の意味を持ちます
（ただし、 繰り返し回数Nは最初に指定しなければなりません。
`wx4'ではうまく動きません）。

   単位の大きさUは、 フォーマット`s'および`i'については無視されますが、
繰り返し回数Nを使用したいことがあるかもしれません。 例えば、
`3i'はオペランドも含めて3つのマシン命令を表示したいということを指定しています。
`disassemble'コマンドは、 マシン命令を調べる別の方法を提供してくれます。
*Note Source and machine code: Machine Code。

   `x'コマンドへの引数のデフォルトはすべて、
`x'コマンドを使用してメモリ上を連続的に参照するために最少の情報だけを指定すればよいように設計されています。
例えば、 `x/3i ADDR'によってマシン命令を調べた後、 `x/7'とするだけで、
続く7個のマシン命令を調べることができます。
<RET>キーによって`x'コマンドを繰り返し実行する場合は、
前回の繰り返し回数Nが再度使用されます。 その他の引数も、
後続の`x'コマンド使用時のデフォルトになります。

   `x'コマンドによって表示されるアドレスや内容は、
値ヒストリに保存されません。 これらの数がしばしば膨大になり、
邪魔になるからです。 その代わりにGDBは、
これらの値をコンビニエンス変数`$_'および`$__'の値として、
後続の式の内部で使用できるようにします。 `x'コマンドを実行後、
最後に調べられたアドレスは、
コンビニエンス変数`$_'の値として式の中で使用することができます。 また、
GDBによって調べられたそのアドレスの内容は、
コンビニエンス変数`$__'の値として使用可能です。

   `x'コマンドに繰り返し回数が指定されている場合、 保存されるのは、
最後に表示されたメモリ単位のアドレスとその内容です。 これは、
最後の出力行にいくつかのメモリ単位が表示されている場合は、
最後に表示されたアドレス値と一致しません。


File: gdb-ja.info,  Node: Auto Display,  Next: Print Settings,  Prev: Memory,  Up: Data

8.6 自動表示
============

ある1つの式の値を （それがどのように変化するかを見るために）
頻繁に表示したい場合は、 その式を"自動表示リスト"に加えて、
ユーザ・プログラムが停止するたびに、
GDBがその値を表示するようにするとよいでしょう。
リストに加えられた個々の式には、
それを識別するための番号が割り当てられます。
ある式をリストから削除する際に、 その番号を指定します。 自動表示は、
例えば以下のように表示されます。

     2: foo = 38
     3: bar[5] = (struct hack *) 0x3804

ここでは、 項目番号、 式、 および、 その式の現在の値が表示されます。
`x'コマンドや`print'コマンドによって手動で表示を要求する場合と同様、
好みの出力フォーマットを指定することができます。 実は、
`display'コマンドは、 ユーザのフォーマットの指定の詳細度によって、
`print'コマンドと`x'コマンドのいずれを使用するかを決定しています。
単位の大きさが指定された場合や、
`x'コマンドでしかサポートされていない2つのフォーマット （`i'と`s'）
のいずれかが指定された場合には、 `x'コマンドが使用されます。
それ以外の場合は、 `print'コマンドが使用されます。

`display EXP'
     ユーザ・プログラムが停止するたびに表示される式のリストに、
     式EXPを追加します。 *Note Expressions: Expressions。

     コマンドの実行後に<RET>キーを押しても、
     `display'コマンドは繰り返し実行されません。

`display/FMT EXP'
     FMTの部分に、 大きさや繰り返し回数は指定せず、
     出力フォーマットだけを指定した場合は、
     式EXPを自動表示リストに追加して、 出力時のフォーマットが常に、
     指定されたフォーマットFMTになるよう調整します。 *Note Output
     formats: Output Formats。

`display/FMT ADDR'
     FMTの部分に`i'、 `s'を指定した場合、 あるいは、 単位の大きさ、
     単位の数を指定した場合は、
     ユーザ・プログラムが停止するたびに調べるメモリ・アドレスとして式ADDRを追加します。
     ここで「調べる」というのは、 実際には`x/FMT
     ADDR'を実行することを意味します。 *Note Examining memory: Memory。

   例えば、 `display/i $pc'は、 ユーザ・プログラムが停止するたびに、
次に実行されるマシン命令を見るのに便利です （`$pc'は、
プログラム・カウンタを指すのに一般に使用される名前です。 *note
Registers::）。

`undisplay DNUMS...'
`delete display DNUMS...'
     表示すべき式のリストから、
     項目番号DNUMSに対応する要素を削除します。

     `undisplay'コマンドを実行後に<RET>キーを押しても、
     コマンドは再実行されません （仮に再実行されてしまうとすると、 `No
     display number ...'というエラーになるだけです）。

`disable display DNUMS...'
     項目番号DNUMSの表示を不可にします。
     表示不可にされた表示項目は自動的には表示されませんが、
     削除されたわけではありません。 後に、
     表示可能にすることができます。

`enable display DNUMS...'
     項目番号DNUMSの表示を可能にします。 これにより、
     表示不可が指定されるまで、 式の自動表示が再度有効になります。

`display'
     リスト上の式のカレントな値を表示します。 これは、
     ユーザ・プログラムが停止したときに実行されるのと同一の処理です。

`info display'
     自動的に表示されるよう設定された式のリストを表示します。
     個々の式の項目番号は表示されますが、 値は表示されません。
     このリストには、 表示不可になっている式も含まれ、
     そのことが分かるようにマーク付けされています。 また、
     表示されるリストには、
     その時点ではアクセスできない自動変数を参照しているために、
     その時点では値を表示することのできない式も含まれます。

   表示される式がローカル変数への参照を含む場合、
そのローカル変数がセットアップされているコンテキストの範囲外では、
その式は無意味です。 このような式は、
その中の変数の1つでも定義されないコンテキストが実行開始されると表示不可になります。
例えば、 引数`last_char'を取る関数の内部で`display
last_char'コマンドを実行すると、
その関数の内部でユーザ・プログラムが実行を停止し続ける間は、
GDBはこの引数を表示します。 ほかの箇所
（`last_char'という変数が存在しない箇所） で停止したときには、
自動的に表示不可となります。
次にユーザ・プログラムが`last_char'が意味を持つ箇所で停止したときには、
再びその式の表示を可能にすることができます。


File: gdb-ja.info,  Node: Print Settings,  Next: Value History,  Prev: Auto Display,  Up: Data

8.7 表示設定
============

GDBは、 配列、 構造体、
シンボルをどのように表示するかを制御するための方法を提供しています。

これらの設定は、どのプログラミング言語で記述されたプログラムのデバッグにも便利です。

`set print address'
`set print address on'
     これによりGDBは、 メモリ・アドレスの内容を表示する場合でも、
     スタック・トレース、 構造体の値、 ポインタの値、
     ブレイクポイントなどの位置を示すアドレスを表示します。
     デフォルトは`on'です。 例として、 `set print address
     on'のときのスタック・フレームの表示結果を示します。

          (gdb) f
          #0  set_quotes (lq=0x34c78 "<<", rq=0x34c88 ">>")
              at input.c:530
          530         if (lquote != def_lquote)

`set print address off'
     アドレスの内容を表示するときには、 そのアドレスを表示しません。
     例えば、 `set print address
     off'のときに前の例と同一のスタック・フレームを表示すると、
     以下のようになります。

          (gdb) set print addr off
          (gdb) f
          #0  set_quotes (lq="<<", rq=">>") at input.c:530
          530         if (lquote != def_lquote)

     `set print address off'を使用することで、
     GDBのインターフェイスからマシンに依存する表示を取り除くことができます。
     例えば、 `print address off'を指定してあれば、
     ポインタ引数の有無にかかわらず、
     すべてのマシン上において同一のバックトレース情報を得るはずです。

`show print address'
     アドレスが表示されるか否かを示します。

   GDBがシンボリックなアドレスを表示する際には通常、
そのアドレスの前にある最も近い位置のシンボルと、
そのシンボルからのオフセットを表示します。
そのシンボルによってアドレスが一意に決まらない場合 （例えば、
単一のファイル内でのみ有効な名前である場合） には、
確認の必要があるかもしれません。 1つの方法は、 例えば`info line
*0x4537'のように、 `info line'コマンドを実行することです。 または、
シンボリックなアドレスを表示するときに、
一緒にソース・ファイルや行番号を表示するようGDBを設定する方法もあります。

`set print symbol-filename on'
     シンボリックな形式のアドレスの表示において、
     そのシンボルのソース・ファイル名と行番号を表示するようGDBに通知します。

`set print symbol-filename off'
     シンボルのソース・ファイル名と行番号を表示しません。これがデフォルトです。

`show print symbol-filename'
     シンボリックな形式でのアドレス表示において、
     GDBがそのシンボルのソース・ファイル名と行番号を表示するか否かを示します。

シンボルのソース・ファイル名と行番号を表示するのが役に立つもう1つの状況として、
コードを逆アセンブルする場合があります。 GDBが、
個々の命令に対応する行番号とソース・ファイルを表示してくれます。

   また、 アドレスをシンボリック形式で表示させるのは、 そのアドレスと、
そのアドレスより前にあるシンボルのうち、
そのアドレスに最も近い位置にあるものとの間が適度に接近している場合に限定させたい
こともあるもでしょう。

`set print max-symbolic-offset MAX-OFFSET'
     アドレスと、
     そのアドレスより前にある最も近いシンボルの間のオフセットがMAX-OFFSET未満のときのみ、
     そのアドレスをシンボリックな形式で表示するようGDBに通知します。
     デフォルトは0で、 これはGDBに対して、
     アドレスより前にシンボルがある場合には、
     常にそのアドレスをシンボリックな形式で表示するよう通知します。

`show print max-symbolic-offset'
     GDBがシンボリックなアドレスを表示する上限となる、
     最大のオフセット値を問い合わせます。

   あるポインタがどこを指しているか定かではない場合には、 `set print
symbol-filename on'を試みてください。 こうすれば、 `p/a
POINTER'を使用して、
そのポインタが指している変数の名前とソース・ファイル上の位置が分かります。
これは、 アドレスをシンボリック形式で解釈します。 例えば以下の例では、
ある変数`ptt'がファイル`hi2.c'内で定義された別の変数`t'を指していることを、
GDBが教えてくれています。

     (gdb) set print symbol-filename on
     (gdb) p/a ptt
     $4 = 0xe008 <t in hi2.c>

     _注意:_ ローカル変数を指すポインタについては、 たとえ適切な`set
     print'オプションが有効になっていても、
     `p/a'はそのポインタによって参照される変数のシンボル名やファイル名を表示しません。

   異なる種類のオブジェクトについては、
他の設定によって表示方法が制御されます。

`set print array'
`set print array on'
     配列をきれいに表示します。 このフォーマットは読むのには便利ですが、
     より多くのスペースを取ります。 デフォルトは`off'です。

`set print array off'
     配列を詰め込み形式で表示します。

`show print array'
     配列の表示方法として、
     詰め込み形式ときれいな形式のどちらが選択されているかを示します。

`set print elements NUMBER-OF-ELEMENTS'
     GDBによって表示される配列の要素の数に上限を設定します。
     GDBが大きな配列を表示している際に、 表示された要素の数が`set print
     elements'コマンドで設定された数に達すると、
     そこで表示が停止されます。 この上限は、
     文字列の表示にも適用されます。
     NUMBER-OF-ELEMENTSに0をセットすると、 要素は無制限に表示されます。

`show print elements'
     大きな配列を表示する際にGDBが表示する要素数を示します。 0の場合、
     表示される要素数に制限はありません。

`set print null-stop'
     最初にNULLが検出された時点で、 GDBに文字配列の表示を停止させます。
     これは、
     大きな配列が実際には短い文字列しか含んでいないときに役に立ちます。

`set print pretty on'
     構造体を表示する際に、
     インデントされた形式で1行に1メンバずつGDBに表示させます。
     以下に例を示します。

          $1 = {
            next = 0x0,
            flags = {
              sweet = 1,
              sour = 1
            },
            meat = 0x54 "Pork"
          }

`set print pretty off'
     構造体を詰め込み形式でGDBに表示させます。 以下に例を示します。

          $1 = {next = 0x0, flags = {sweet = 1, sour = 1}, \
          meat = 0x54 "Pork"}

     これがデフォルトの形式です。

`show print pretty'
     GDBが、
     構造体を表示するのにどちらの形式を使用しているかを示します。

`set print sevenbit-strings on'
     7ビット文字だけを使用して表示します。
     このオプションがセットされていると、 GDBは
     （文字列内または単一文字内の）
     8ビット文字を`\'NNNという表記法で表示します。 この設定は、英語
     （ASCII） 環境において、
     文字の最上位ビットをマーカや「メタ」ビットとして使用する場合に最適です。

`set print sevenbit-strings off'
     8ビット文字を表示します。
     これにより文字セットの使用が国際的になります。
     これがデフォルトです。

`show print sevenbit-strings'
     GDBが7ビット文字だけを表示するか否かを示します。

`set print union on'
     GDBに対して、
     構造体の中に含まれている共用体を表示するよう通知します。 これが、
     デフォルトの設定です。

`set print union off'
     GDBに対して、
     構造体の中に含まれている共用体を表示しないよう通知します。

`show print union'
     GDBに対して、
     構造体の中に含まれている共用体を表示するか否かを問い合わせます。

     例えば、 以下のように宣言されている場合、

          typedef enum {Tree, Bug} Species;
          typedef enum {Big_tree, Acorn, Seedling} Tree_forms;
          typedef enum {Caterpillar, Cocoon, Butterfly}
                        Bug_forms;

          struct thing {
            Species it;
            union {
              Tree_forms tree;
              Bug_forms bug;
            } form;
          };

          struct thing foo = {Tree, {Acorn}};

     `set print union on'が有効な場合、 `p
     foo'は以下のような表示を行います。

          $1 = {it = Tree, form = {tree = Acorn, bug = Cocoon}}

     また、 `set print union off'が有効な場合、 `p
     foo'は以下のような表示を行います。

          $1 = {it = Tree, form = {...}}

以下の設定は、 C++プログラムをデバッグしているときに関係があります。

`set print demangle'
`set print demangle on'
     C++のシンボル名を、
     型セーフ（type-safe）なリンクのためにアセンブラ、
     リンカに渡されるエンコードされた （mangled） 形式ではなく、
     ソースに記述された形式で表示します。 デフォルトは`on'です。

`show print demangle'
     C++のシンボル名が、 エンコードされた （mangled） 形式、 ソース
     （demangled） 形式のいずれの形式で表示されるかを示します。

`set print asm-demangle'
`set print asm-demangle on'
     C++のシンボル名を、
     命令の逆アセンブル時のようにアセンブラ・コードで表示しているときにも、
     エンコードされた （mangled） 形式ではなく、
     ソース形式で表示します。 デフォルトは`off'です。

`show print asm-demangle'
     アセンブラ・コードの表示において、 C++シンボル名をエンコードされた
     （mangled） 形式、 ソース （demangled）
     形式のいずれの形式で表示するかを示します。

`set demangle-style STYLE'
     C++シンボル名を表現するために様々なコンパイラによって使用される
     いくつかのエンコーディング方式の中から1つを選択します。
     現在STYLEとして選択可能であるのは、以下のとおりです。

    `auto'
          GDBがユーザ・プログラムを解析してデコーディング方式を決定することを許します。

    `gnu'
          GNU
          C++（`g++'）エンコーディング・アルゴリズムに基づいてデコードします。
          これが、 デフォルトです。

    `hp'
          HP ANSI
          C++（`aCC'）エンコーディング・アルゴリズムに基づいてデコードします。

    `lucid'
          Lucid
          C++（`lcc'）エンコーディング・アルゴリズムに基づいてデコードします。

    `arm'
          `C++ Annotated Reference
          Manual'に記述されているアルゴリズムを使用してデコードします。
          *注意:* この設定だけでは、
          `cfront'によって生成された実行モジュールをデバッグするのに十分ではありません。
          これを可能にするためには、 GDBをさらに拡張する必要があります。

     STYLEを指定しないと、 指定可能なフォーマットの一覧が表示されます。

`show demangle-style'
     C++シンボルをデコードするのに現在使用されているエンコーディング方式を示します。

`set print object'
`set print object on'
     オブジェクトへのポインタを表示する際に、
     仮想関数テーブルを使用して、 _宣言_された型ではなく、
     オブジェクトの_実際_の （派生された） 型を表示します。

`set print object off'
     仮想関数テーブルは参照せず、
     オブジェクトの宣言された型だけを表示します。
     これがデフォルトの設定です。

`show print object'
     オブジェクトの実際の型と宣言された型のどちらが表示されるかを示します。

`set print static-members'
`set print static-members on'
     C++のオブジェクトを表示する際、 静的メンバを表示します。
     デフォルトは`on'です。

`set print static-members off'
     C++のオブジェクトを表示する際、 静的メンバを表示しません。

`show print static-members'
     C++の静的メンバが表示されるか否かを示します。

`set print vtbl'
`set print vtbl on'
     C++の仮想関数テーブルをきれいな形式で表示します。
     デフォルトは`off'です。

`set print vtbl off'
     C++の仮想関数テーブルをきれいな形式で表示しません。

`show print vtbl'
     C++の仮想関数テーブルをきれいな形式で表示するか否かを示します。


File: gdb-ja.info,  Node: Value History,  Next: Convenience Vars,  Prev: Print Settings,  Up: Data

8.8 値ヒストリ
==============

`print'コマンドにより表示された値は、 GDBの "値ヒストリ"に保存されます。
これによりユーザは、 これらの値をほかの式の中で参照することができます。
値は、 シンボル・テーブルが （例えば、
`file'コマンドや`symbol-file'コマンドにより）
再読み込みされるか破棄されるまで、 維持されます。
シンボル・テーブルが変更されると、 値ヒストリが破棄されるのは、
その中の値が、
シンボル・テーブル内で定義されている型を参照しているかもしれないからです。

   表示される値は"ヒストリ番号"を与えられ、
この番号によって参照することができます。
この番号は1から始まる連続した整数です。 `print'コマンドは、
値に割り当てられたヒストリ番号を、 値の前に`$NUM =
'という形で表示します。 ここで、 NUMがそのヒストリ番号です。

   値ヒストリの中の任意の値を参照するには、
`$'に続けてヒストリ番号を指定します。
`print'コマンドが出力に付加するラベルは、
ユーザにこのことを知らせるためのものです。 `$'単体では、
ヒストリ内の最も新しい値を参照し、 `$$'はその1つ前の値を参照します。
`$$N'は、 最新のものから数えてN番目の値を参照します。
`$$2'は`$$'の1つ前の値を参照し、 `$$1'は`$$'と同一、
`$$0'は`$'と同一です。

   例えば、 ユーザがたった今、 構造体へのポインタを表示し、
今度はその構造体の内容を見たいと考えているとしましょう。 この場合は、

     p *$

を実行すれば十分です。

   また、 連結された構造体があり、
そのメンバの`next'が次の構造体を指すポインタであるとすると、
次の構造体の内容を表示するには、

     p *$.next

とします。

   このように連結された構造体を次々に表示するには、
このコマンドを繰り返し実行すればよく、 それは<RET>キーによって可能です。

   このヒストリは、 式ではなく、
値を記録するという点に注意してください。 `x'の値が4のときに、
以下のコマンドを実行すると、
`print'コマンドによって値ヒストリに記録される値は、
`x'の値が変化したにもかかわらず4のままです。

     print x
     set x=5

`show values'
     値ヒストリ内の最新の10個の値を、 項目番号付きで表示します。
     これは、 `p $$9'を10回実行するようなものですが、 両者の違いは、
     `show values'がヒストリを変更しないという点にあります。

`show values N'
     値ヒストリ内の項目番号Nを中心に、 その前後の10個の値を表示します。

`show values +'
     値ヒストリ内の値のうち最後に表示されたものの直後にある10個の値を表示します。
     値が存在しない場合には、 何も表示されません。

   `show values N'を繰り返し実行するのに<RET>キーを押すことは、 `show
values +'を実行するのと全く同じ結果をもたらします。


File: gdb-ja.info,  Node: Convenience Vars,  Next: Registers,  Prev: Value History,  Up: Data

8.9 コンビニエンス変数
======================

GDBの"コンビニエンス変数"は、 GDBの中にある値を保持しておいて、
それを後に参照するという目的で使用することができます。 これらの変数は、
GDB内部においてのみ存在するものです。
それらはユーザ・プログラムの中に存在するものではなく、
コンビニエンス変数を設定してもユーザ・プログラムの実行には直接影響を与えません。
したがって、 ユーザはこれを自由に使用することができます。

   コンビニエンス変数名は、 先頭が`$'で始まります。 `$'で始まる名前は、
あらかじめ定義されたマシン固有のレジスタ名 （*note Registers::）
と一致しない限り、 コンビニエンス変数の名前として使用することができます
（これに対して、 値ヒストリの参照名では`$'に続けて_番号_を記述します。
*Note Value history: Value History）。

   ユーザ・プログラムの中で変数に値を設定するのと同じように、
代入式を使用してコンビニエンス変数に値を保存することができます。
例えば、
`object_ptr'が指すオブジェクトが保持する値を`$foo'に保存するには、
以下のようにします。

     set $foo = *object_ptr

   コンビニエンス変数は、 最初に使用されたときに生成されますが、
新しい値を割り当てるまで、 その値は空 （`void'） です。 値は、
いつでも代入することによって変更可能です。

   コンビニエンス変数には決まった型はありません。
コンビニエンス変数には、
既に異なる型のデータが割り当てられている場合でも、
構造体や配列を含めた任意の型のデータを割り当てることができます。
コンビニエンス変数は、 式として使用される場合には、
その時点における値の型を持ちます。

`show convenience'
     それまでに使用されたコンビニエンス変数とその値の一覧を表示します。
     省略形は、 `show con'です。

   コンビニエンス変数の1つの使い方に、
インクリメントされるカウンタや先へ進んでいくポインタとしての使い方があります。
例えば、
構造体配列の中の連続する要素のあるフィールドの値を表示したい場合、
以下のコマンドを<RET>キーで繰り返し実行します。

     set $i = 0
     print bar[$i++]->contents

GDBによって、 いくつかのコンビニエンス変数が自動的に作成され、
役に立ちそうな値が設定されます。

`$_'
     `$_'変数には、
     `x'コマンドによって最後に調べられたアドレスが自動的に設定されます
     （*note Examining memory: Memory.）。
     `x'コマンドによって調べられるデフォルトのアドレスを提供する他のコマンドも、
     `$_'にそのアドレスを設定します。 このようなコマンドには、 `info
     line'や`info breakpoint'があります。 `$_'の型は、
     `x'コマンドによって設定された場合は`$__'の型へのポインタであり、
     それ以外の場合は`void *'です。

`$__'
     `$__'変数には、
     `x'コマンドによって最後に調べられたアドレス位置にある値が自動的に設定されます。
     型は、 データが表示されたフォーマットに適合するように選択されます。

`$_exitcode'
     `$_exitcode'変数には、
     デバッグされているプログラムが終了した際の終了コードが自動的に設定されます。


File: gdb-ja.info,  Node: Registers,  Next: Floating Point Hardware,  Prev: Convenience Vars,  Up: Data

8.10 レジスタ
=============

マシン・レジスタの内容は、 先頭が`$'で始まる名前を持つ変数として、
式の中で参照することができます。 レジスタの名前は、
マシンによって異なります。 `info registers'コマンドを使用することで、
そのマシンで使用されているレジスタの名前を知ることができます。

`info registers'
     （選択されたスタック・フレームにおける）
     浮動小数点レジスタを除くすべてのレジスタの名前と値を表示します。

`info all-registers'
     浮動小数点レジスタも含めてすべてのレジスタの名前と値を表示します。

`info registers REGNAME ...'
     指定されたレジスタREGNAMEの 訴対化された値（"relativized"
     value）を表示します。 以下に詳しく述べるように、 レジスタの値は、
     通常は、 選択されたスタック・フレームと関係を持つ相対的な値です。
     REGNAMEには、
     ユーザの使用しているマシン上において有効な任意のレジスタの値が設定可能です。
     先頭の`$'は、 あってもなくてもかまいません。

   GDBは、
そのマシン・アーキテクチャが持つレジスタの正規のニーモニックと衝突しない限り、
ほとんどのマシン上 （の式の中） において利用可能な、
4つの「標準的」なレジスタ名を持っています。 レジスタ名`$pc'と`$sp'は、
プログラム・カウンタ・レジスタとスタック・ポインタを指すために使われます。
`$fp'は、
カレントなスタック・フレームへのポインタを保持するレジスタを指すために使われます。
`$ps'は、 プロセッサの状態を保持するレジスタを指すために使われます。
例えば、 プログラム・カウンタの値を16進数で表示するには、
以下のように実行します。

     p/x $pc

また、 次に実行される命令を表示するには、 以下のように実行します。

     x/i $pc

さらに、 スタック・ポインタ (1) に4を加えるには、
以下のように実行します。

     set $sp += 4

   可能な場合にはいつでも、
これら4つの標準的なレジスタ名が使用可能です。
ユーザのマシンが異なる正規のニーモニックを使用している場合でも、
名前の衝突さえ起こらなければ、 使用可能です。 `info
registers'コマンドにより、 正規名を見ることができます。 例えば、
SPARC上で `info registers'コマンドを実行すると、
プロセッサ・ステータス・レジスタは`$psr'と表示されますが、
このレジスタを`$ps'として参照することもできます。

   レジスタがこの方法で調べられるとき、
GDBは普通のレジスタの内容を常に整数値とみなします。 マシンによっては、
浮動小数点値以外を保持できないレジスタを持つものがあります。
このようなレジスタは、 浮動小数点値を持つものとみなされます。
普通のレジスタの内容を浮動小数点値として参照する方法はありません
（`print/f $REGNAME'により、
浮動小数点値として値を_表示する_ことはできます）。

   レジスタには、
rawとvirtualの2つの異なるデータ形式を取るものがあります。 これは、
オペレーティング・システムによってレジスタの内容が保存されるときのデータ形式が、
ユーザ・プログラムが通常認識しているものと同じではないことを意味しています。
例えば、 68881浮動小数点コプロセッサのレジスタの値は常にextended
（raw）形式で保存されていますが、 C言語によるプログラムは通常double
（virtual）形式を想定しています。 このような場合、 GDBは通常
（ユーザ・プログラムにとって意味のある形式である）
virtual形式だけを扱いますが、 `info
registers'コマンドはデータを両方の形式で表示してくれます。

   通常、 レジスタの値は、 選択されたスタック・フレーム （*note
Selecting a frame: Selection.） と関係を持つ相対的な値です。 これは、
ユーザにレジスタの値として見えるものは、
選択されたフレームから呼び出されているすべてのスタック・フレームが終了し、
退避されたレジスタの値が復元されたときに、
そのレジスタが持つであろう値です。
ハードウェア・レジスタの本当の値を知りたければ、 最下位のフレームを
（`frame 0'で） 選択しなければなりません。

   しかし、 GDBは、 コンパイラが生成したコードから、
どこにレジスタが保存されているかを推論する必要があります。
退避されていないレジスタがある場合や、
GDBが退避されたレジスタを見つけることができない場合は、
どのスタック・フレームを選択していても結果は同じです。

`set rstack_high_address ADDRESS'
     AMD 29000ファミリ・プロセッサでは、
     レジスタは「レジスタ・スタック」と呼ばれるところに退避されます。
     GDBには、 このスタックの大きさを知ることはできません。 通常 GDBは、
     スタックは十分に大きいと想定します。 このために、
     実際には存在しないメモリ位置を、
     GDBが参照してしまうことがありえます。 必要であれば、 `set
     rstack_high_address'コマンドによってレジスタ・スタックの最終アドレスを指定することによって、
     この問題を回避することができます。
     引数はアドレスでなければなりません。 `0x'を先頭に記述することで、
     アドレスを16進数で指定することができます。

`show rstack_high_address'
     AMD
     29000ファミリ・プロセッサにおけるレジスタ・スタックのカレントな上限を表示します。

   ---------- Footnotes ----------

   (1) 原注：これは、 スタックがメモリの下位方向に伸長するマシン
（最近のほとんどのマシンがそうです） 上において、
スタックから1ワードを取り除く方法です。 これは、
最下位のスタック・フレームが選択されていることを想定しています。
これ以外のスタック・フレームが選択されているときには、
`$sp'に値を設定することは許されません。
マシン・アーキテクチャに依存することなくスタックからフレーム全体を取り除くには、
`return'を使用します。 *Note Returning from a function: Returning。


File: gdb-ja.info,  Node: Floating Point Hardware,  Prev: Registers,  Up: Data

8.11 浮動小数ハードウェア
=========================

構成によっては、 GDBは浮動小数ハードウェアの状態について、
より詳しい情報を提供することができます。

`info float'
     浮動小数ユニットに関するハードウェア依存の情報を表示します。
     浮動小数チップの種類によって、 表示内容やレイアウトは変わります。
     現在、 `info
     float'はARMマシンとx86マシンにおいてサポートされています。


File: gdb-ja.info,  Node: Languages,  Next: Symbols,  Prev: Data,  Up: Top

9 異なる言語の使用
******************

異なるプログラミング言語であっても共通点があるのが普通ですが、
その表記法が全く同様であるということはめったにありません。 例えば、
ポインタ `p'の指す値を取り出す方法は、 ANSI Cでは`*p'ですが、
Modula-2では`p^'です。 値の表現方法 （および表示方法）
もまた異なります。 16進数は、 Cでは`0x1ae'のようになりますが、
Modula-2では`1AEH'のようになります。

いくつかの言語については、 言語固有の情報がGDBに組み込まれており、
これにより、
プログラムを記述した言語を使って上記のような操作を記述したり、
プログラムを記述した言語の構文にしたがってGDBに値を出力させることができます。
式を記述するのに使用される言語を、 "作業言語"と呼びます。

* Menu:

* Setting::                     ソース言語の切り替え
* Show::                        言語の表示

* Checks::                      型と範囲のチェック

* Support::                     サポートされる言語


File: gdb-ja.info,  Node: Setting,  Next: Show,  Prev: Languages,  Up: Languages

9.1 ソース言語の切り替え
========================

作業言語を制御する方法は2つあります。 GDBに自動的に設定させる方法と、
ユーザが手作業で選択する方法です。 どちらの目的でも、 `set
language'コマンドを使用することができます。 起動時のデフォルトでは、
GDBが言語を自動的に設定するようになっています。 作業言語は、
ユーザの入力する式がどのように解釈されるか、 あるいは、
値がどのように表示されるかを決定します。

   この作業言語とは別に、
GDBの認識しているすべてのソース・ファイルには、
それ自体の作業言語があります。
オブジェクト・ファイルのフォーマットによっては、
ソース・ファイルの記述言語を示す情報を、
コンパイラが書き込んでいることがあるかもしれません。 しかし、
ほとんどの場合、 GDBはファイル名から言語を推定します。
ソース・ファイルの言語の種類が、 C++シンボル名がデコード （demangle）
されるか否かを制御します。 これにより`backtrace'は、 個々のフレームを、
その対応する言語にしたがって適切に表示することができます。 GDBの中から、
ソース・ファイルの言語を設定することはできません。

   他の言語で記述されたソースからCのソースを生成する、
`cfront'や`f2c'のようなプログラムをユーザが使用する場合には、
このことが問題となるでしょう。 このような場合には、
生成されるCの出力に`#line'指示子を使用するよう、
そのプログラムを設定してください。 こうすることによって、 GDBは、
元になったプログラムのソース・コードが記述された言語を正しく知ることができ、
生成されたCのコードではなく、 元になったソース・コードを表示します。

* Menu:

* Filenames::                   ファイル拡張子と言語
* Manually::                    手作業による作業言語の設定
* Automatically::               GDBによるソース言語の推定


File: gdb-ja.info,  Node: Filenames,  Next: Manually,  Prev: Setting,  Up: Setting

9.1.1 ファイル拡張子と言語のリスト
----------------------------------

ソース・ファイル名が以下のいずれかの拡張子を持つ場合、
GDBはその言語を以下に示すものと推定します。

`.c'
     Cソース・ファイル

`.C'
`.cc'
`.cp'
`.cpp'
`.cxx'
`.c++'
     C++ソース・ファイル

`.f'
`.F'
     Fortranソース・ファイル

`.ch'
`.c186'
`.c286'
     CHILLソース・ファイル

`.mod'
     Modula-2ソース・ファイル

`.s'
`.S'
     アセンブラ言語のソース・ファイル。 この場合、
     実際の動作はほとんどC言語と同様ですが、 ステップ実行時に、
     関数呼び出しのための事前処理部をGDBはスキップしません。

   さらに、 言語に対してファイル名の拡張子を関連付けすることも可能です。
*Note Displaying the language: Show。


File: gdb-ja.info,  Node: Manually,  Next: Automatically,  Prev: Filenames,  Up: Setting

9.1.2 作業言語の設定
--------------------

GDBに言語を自動的に設定させる場合、
ユーザのデバッグ・セッションとユーザのプログラムにおいて、
式は同様に解釈されます。

   もしそうしたければ、 言語を手作業で設定することもできます。
そのためには、 コマンド`set language LANG'を実行します。 ここで、
LANGは、 `c'や`modula-2' のような言語名です。
サポートされている言語のリストは、 `set
language'で表示させることができます。

   言語を手作業で設定すると、 GDBは、
作業言語を自動的に更新することができなくなります。 このことは、
作業言語がソースの言語と同一ではなく、 かつ、
ある式がどちらの言語でも有効でありながら、
その意味が異なるような状況でプログラムをデバッグしようとしたときに、
混乱をもたらす可能性があります。 例えば、
カレントなソース・ファイルがC言語で記述されていて、
GDBがそれをModula-2として解析している場合に、

     print a = b + c

のようなコマンドを実行すると、
その結果は意図したものとは異なるものになるでしょう。 これはC言語では、
`b'と`c'とを加算して、 その結果を`a'に入れるということを意味し、
表示される結果は、 `a'の値となります。 Modula-2では、
これは`a'と`b+c'の結果を比較して`BOOLEAN'型の値を出力することを意味します。


File: gdb-ja.info,  Node: Automatically,  Prev: Manually,  Up: Setting

9.1.3 GDBによるソース言語の推定
-------------------------------

GDBに作業言語を自動的に設定させるには、 `set language local'または`set
language auto'を使用します。 この場合、 GDBは作業言語を推定します。
つまり、 ユーザ・プログラムが
（通常はブレイクポイントに達することによって）
あるフレーム内部で停止したとき、 GDBは、
そのフレーム内の関数に対して記録されている言語を作業言語として設定します。
フレームの言語が不明の場合 （つまり、
そのフレームに対応する関数またはブロックが、
既知ではない拡張子を持つソース・ファイルにおいて定義されている場合）、
カレントな作業言語は変更されず、 GDBは警告メッセージを出力します。

   このようなことは、
全体がただ1つの言語で記述されているほとんどのプログラムにおいては
不要であると思われるでしょう。 しかし、
あるソース言語で記述されたプログラム・モジュールやライブラリは、
他のソース言語で記述されたメイン・プログラムから使用することができます。
このような場合に`set language auto'を使用することで、
作業言語を手作業で設定する必要がなくなります。


File: gdb-ja.info,  Node: Show,  Next: Checks,  Prev: Setting,  Up: Languages

9.2 言語の表示
==============

   以下のコマンドは、 作業言語、 および、
ソース・ファイルの記述言語を知りたいときに役に立ちます。

`show language'
     カレントな作業言語を表示します。 `print'コマンドなどによって
     ユーザ・プログラム内部の変数を含む式を作成したり評価したりするには、
     このコマンドによって示される言語を使用します。

`info frame'
     選択されているフレームのソース言語を表示します。
     このフレームの中の識別子を使用すると、
     この言語が作業言語になります。
     このコマンドにより表示される他の情報について知りたい場合は、 *Note
     Information about a frame: Frame Info。

`info source'
     選択されているソース・ファイルのソース言語を表示します。
     このコマンドにより表示される他の情報のことを知りたい場合は、 *Note
     Examining the Symbol Table: Symbols。

   普通ではない状況においては、
標準のリストに含まれない拡張子を持つソース・ファイルがあるかもしれません。
この場合には、
その拡張子を特定の言語に明示的に関連付けすることができます。

`set extension-language .EXT LANGUAGE'
     拡張子.EXTを持つソース・ファイルは、 ソース言語LANGUAGE
     によって記述されているものと想定するよう設定します。

`info extensions'
     すべてのファイル拡張子と、
     その拡張子に関連付けされた言語を一覧表示します。


File: gdb-ja.info,  Node: Checks,  Next: Support,  Prev: Show,  Up: Languages

9.3 型と範囲のチェック
======================

     _注意:_ 現在のリリースでは、
     型チェックと範囲チェックを行うGDBコマンドは組み込まれていますが、
     それらは実際には何も実行しません。 このセクションでは、
     これらのコマンドが本来持つべく意図されている機能について記述してあります。

   いくつかの言語は、 一連のコンパイル時チェック、
実行時チェックによって、
一般によく見られるエラーの発生を防ぐように設計されています。
これらのチェックには、 関数や演算子への引数の型のチェックや、
数学的操作の結果のオーバーフローを実行時に確実に検出することなどが含まれています。
このようなチェックは、 型の不一致を排除したり、
ユーザ・プログラムの実行時に範囲エラーをチェックしたりすることによって、
コンパイル後のプログラムの正しさを確かなものにするのに役に立ちます。

   GDBは、 ユーザが望むのであれば、
上記のような条件のチェックを行います。
GDBはユーザ・プログラムの文をチェックすることはしませんが、 例えば、
`print'コマンドによる評価を目的としてGDBに直接入力された式をチェックすることはできます。
作業言語の場合と同様に、 GDBが自動的にチェックを行うか否かを、
ユーザ・プログラムのソース言語によって決定することもできます。
サポートされている言語のデフォルトの設定については、 *Note Supported
languages: Support。

* Menu:

* Type Checking::               型チェックの概要
* Range Checking::              範囲チェックの概要


File: gdb-ja.info,  Node: Type Checking,  Next: Range Checking,  Prev: Checks,  Up: Checks

9.3.1 型チェックの概要
----------------------

いくつかの言語、 例えばModula-2などは、 強く型付けされています。
これは、 演算子や関数への引数は正しい型でなくてはならず、
そうでない場合にはエラーが発生するということを意味しています。
このようなチェックは、
型の不一致のエラーが実行時に問題を発生させるのを防いでくれます。
例えば、 1+2は

     1 + 2 => 3
ですが、1+2.3は
     error--> 1 + 2.3

のようにエラーになります。

   第2の例がエラーになるのは、
`CARDINAL'型の1は`REAL'型の2.3と型の互換性がないからです。

   GDBコマンドの中で使われる式については、
ユーザがGDBの型チェック機能に対して、
以下のような指示を出すことができます。

   * チェックを行わない

   * あらゆる不一致をエラーとして扱い、式を破棄する

   * 型の不一致が発生したときには警告メッセージを出力するだけで、
     式の評価を実行する

   最後の指示が選択された場合、
GDBは上記の第2の（エラー）例のような式でも評価しますが、
その際には警告メッセージを出力します。

   型チェックをしないよう指示した場合でも、
型に関係のある原因によってGDBが式の評価ができなくなる場合がありえます。
例えば、 GDBは`int'の値と`struct foo'の値を加算する方法を知りません。
こうした特定の型エラーは、 使用されている言語に起因するものではなく、
この例のように、
そもそも評価することが意味をなさないような式に起因するものです。

   個々の言語は、 それが型に関してどの程度厳密であるかを定義しています。
例えば、 Modula-2とCはいずれも、
算術演算子への引数としては数値を要求します。 Cでは、
列挙型とポインタは数値として表わすことができますので、
これらは算術演算子への正当な引数となります。
特定の言語に関する詳細については、 *Note Supported languages: Support。

   GDBは、
型チェック機能を制御するためのコマンドをさらにいくつか提供しています。

`set check type auto'
     カレントな作業言語に応じて、 型チェックを実行する、 または、
     実行しないよう設定します。 個々の言語のデフォルトの設定については、
     *Note Supported languages: Support。

`set check type on'
`set check type off'
     カレントな作業言語のデフォルトの設定を無視して、
     型チェックを実行する、 または、 実行しないよう設定します。
     その設定が言語のデフォルトと一致しない場合は、
     警告メッセージが出力されます。
     型チェックを実行するよう設定されているときの式の評価において型の不一致が発生した場合には、
     GDBはメッセージを出力して式の評価を終了させます。

`set check type warn'
     型チェック機能に警告メッセージを出力させますが、
     式の評価自体は常に実行するよう試みさせます。 式の評価は、
     他の原因のために不可能になる場合もあります。 例えば、
     GDBには数値と構造体の加算はできません。

`show type'
     型チェック機能のカレントな設定と、
     GDBがそれを自動的に設定しているか否かを表示します。


File: gdb-ja.info,  Node: Range Checking,  Prev: Type Checking,  Up: Checks

9.3.2 範囲チェックの概要
------------------------

いくつかの言語 （例えば、 Modula-2） では、
型の上限を超えるとエラーになります。 このチェックは、
実行時に行われます。 このような範囲チェックは、
計算結果がオーバーフローしたり、
配列の要素へのアクセス時に使うインデックスが配列の上限を超えたりすることがないことを確実にすることによって、
プログラムの正しさを確かなものにすることを意図したものです。

   GDBコマンドの中で使う式については、
範囲エラーの扱いを以下のいずれかにするよう GDBに指示することができます。

   * 範囲エラーを無視する

   * 範囲エラーを常にエラーとして扱い、 式を破棄する

   * 警告メッセージを出力するだけで、 式を評価する

   範囲エラーは、 数値がオーバフローした場合、
配列インデックスの上限を超えた場合、
どの型のメンバでもない定数が入力された場合に発生します。 しかし、
言語の中には、 数値のオーバフローをエラーとして扱わないものもあります。
C言語の多くの実装では、 数学的演算によるオーバフローは、
結果の値を「一巡」させて小さな値にします。 例えば、 Mが整数値の最大値、
Sが整数値の最小値とすると、

     M + 1 => S

になります。

   これも個々の言語に固有な性質であり、 場合によっては、
個々のコンパイラやマシンに固有な性質であることもあります。
特定の言語に関する詳細については、 *Note Supported languages: Support。

   GDBは、
範囲チェック機能を制御するためのコマンドをさらにいくつか提供しています。

`set check range auto'
     カレントな作業言語に応じて、 範囲チェックを実行する、 または、
     実行しないよう設定します。 個々の言語のデフォルトの設定については、
     *Note Supported languages: Support。

`set check range on'
`set check range off'
     カレントな作業言語のデフォルトの設定を無視して、
     範囲チェックを実行する、 または、 実行しないよう設定します。
     設定が言語のデフォルトとは異なる場合は、
     警告メッセージが出力されます。 範囲エラーが発生した場合は、
     メッセージが表示され、 式の評価は終了させられます。

`set check range warn'
     GDBの範囲チェック機能が範囲エラーを検出した場合、
     メッセージを出力し、 式の評価を試みます。 例えば、 プロセスが、
     自分の所有していないメモリをアクセスした場合
     （多くのUnixシステムで典型的に見られる例です） など、
     他の理由によって式の評価が不可能な場合があります。

`show range'
     範囲チェック機能のカレントな設定と、
     それがGDBによって自動的に設定されているのか否かを表示します。


File: gdb-ja.info,  Node: Support,  Prev: Checks,  Up: Languages

9.4 サポートされる言語
======================

   GDBは、 C、 C++、 Fortran、 Chill、 アセンブリ言語、
Modula-2をサポートしています。 いくつかのGDBの機能は、
使用されている言語にかかわらず、 式の中で使用できます。 GDBの`@'演算子、
`::'演算子、 および`{type}addr' （*note Expressions: Expressions.） は、
サポートされている任意の言語において使用することができます。

   次節以降で、
個々のソース言語がGDBによってどの程度までサポートされているのかを詳しく説明します。
これらの節は、
言語についてのチュートリアルやリファレンスとなることを意図したものではありません。
むしろ、 GDBの式解析機能が受け付ける式や、
異なる言語における正しい入出力フォーマットのリファレンス・ガイドとしてのみ役に立つものです。
個々の言語については良い書籍が数多く出ています。
言語についてのリファレンスやチュートリアルが必要な場合は、
これらの書籍を参照してください。

* Menu:

* C::                           C/C++
* Modula-2::                    Modula-2


File: gdb-ja.info,  Node: C,  Next: Modula-2,  Up: Support

9.4.1 C/C++
-----------

   CとC++は密接に関連しているので、
GDBの機能の多くは両方の言語に適用できます。このようなものについては、2つの言語を一緒に議論します。

   C++のデバッグ機能は、
C++コンパイラとGDBによって協同で実装されています。 したがって、
C++のコードを効率よくデバッグするには、 GNU `g++'、 HP ANSI
C++コンパイラ（`aCC'）などの、 サポートされているC++コンパイラで、
C++のプログラムをコンパイルする必要があります。

   GNU C++を使用する場合、 最高の結果を引き出すには、
stabsデバッグ・フォーマット を使用してください。
`g++'のコマンドライン・オプション`-gstabs'、 または、
`-gstabs+'によって、 このフォーマットを明示的に選択することができます。
詳細については、 *Note Options for Debugging Your Program or GNU CC:
(gcc.info)Debugging Options.  の部分を参照してください。

* Menu:

* C Operators::                 C/C++演算子
* C Constants::                 C/C++定数
* Cplus expressions::           C++式
* C Defaults::                  C/C++のデフォルト設定

* C Checks::                    C/C++の型チェックと範囲チェック

* Debugging C::                 GDBとC
* Debugging C plus plus::       C++用のGDB機能


File: gdb-ja.info,  Node: C Operators,  Next: C Constants,  Up: C

9.4.1.1 C/C++演算子
...................

   演算子は、 特定の型の値に対して定義されなければなりません。 例えば、
`+'は数値に対しては定義されていますが、
構造体に対しては定義されていません。 演算子は、
型のグループに対して定義されることがよくあります。

   C/C++に対しては、以下の定義が有効です。

   * _整数型_には、 任意の記憶クラス指定子を持つ`int'が含まれます。
     `char'、 `enum'も整数型です。

   * _浮動小数点型_には、 `float'と`double'が含まれます。

   * _ポインタ型_には、 型TYPEに対して`(TYPE
     *)'により定義されるすべての型が含まれます。

   * _スカラ型_には、 上記のすべてが含まれます。

以下の演算子がサポートされています。
これらは優先順位の低いものから順に並べられています。

`,'
     カンマ、 あるいは、 順序付けの演算子です。
     カンマによって区切られたリストの中の式は、
     左から右の順で評価されます。 最後に評価された式の結果が、
     式全体の評価結果になります。

`='
     代入。 代入された値が、 代入式の値になります。
     スカラ型に対して定義されています。

`OP='
     `A OP= B'という形式の式において使用され、
     `A = A OP B'に変換されます。 `OP='と`='は、
     同一の優先順位を持ちます。 OPには、 `|'、 `^'、 `&'、 `<<'、 `>>'、
     `+'、 `-'、 `*'、 `/'、 `%'の各演算子が使用できます。

`?:'
     3項演算子です。 `A ? B : C'は、 Aが真であればB、
     偽であればCとみなすことができます。 Aは整数型でなければなりません。

`||'
     論理ORです。 整数型に対して定義されています。

`&&'
     論理ANDです。 整数型に対して定義されています。

`|'
     ビットごとのORです。 整数型に対して定義されています。

`^'
     ビットごとの排他的ORです。 整数型に対して定義されています。

`&'
     ビットごとのANDです。 整数型に対して定義されています。

`==、!='
     等価、 および、 不等価です。 スカラ型に対して定義されています。
     これらの式の値は、 偽のときはゼロであり、
     真のときはゼロ以外の値となります。

`<、>、<=、>='
     未満、 超過、 以下、 以上です。 スカラ型に対して定義されています。
     これらの式の値は、 偽のときはゼロであり、
     真のときはゼロ以外の値となります。

`<<、>>'
     左シフト、 右シフトです。 整数型に対して定義されています。

`@'
     GDBの「人工配列」演算子です （*note Expressions: Expressions.）。

`+、-'
     加算および減算です。 整数型、 浮動小数点型、
     ポインタ型に対して定義されています。

`*、/、%'
     乗算、 除算、 剰余です。 乗算と除算は、
     整数型と浮動小数点型に対して定義されています。 剰余は、
     整数型に対して定義されています。

`++, --'
     インクリメント、 デクリメントです。 変数の前にある場合は、
     式の中でその変数が使用される前に実行されます。
     変数の後ろにある場合は、 変数の値が使用された後に実行されます。

`*'
     ポインタの間接参照です。 ポインタ型に対して定義されています。
     `++'と同一の優先度を持ちます。

`&'
     アドレス参照演算子です。変数に対して定義されています。
     `++'と同一の優先順位を持ちます。

     C++のデバッグでは、
     C++言語そのものにおいては許されていないような`&'の使用法を、
     GDBは実装しています。 C++の （`&REF'により宣言される）
     参照変数が格納されているアドレスを調べるのに、 `&(&REF)'
     （あるいは、 もしそうしたいのであれば単に`&&REF'）
     を使用することができます。

`-'
     マイナス（負）です。 整数型と浮動小数点型に対して定義されています。
     `++'と同一の優先順位を持ちます。

`!'
     論理NOTです。 整数型に対して定義されています。
     `++'と同一の優先順位を持ちます。

`~'
     ビットごとのNOT （補数） 演算子です。
     整数型に対して定義されています。 `++'と同一の優先順位を持ちます。

`., ->'
     構造体のメンバ、
     ポインタの指す構造体のメンバをそれぞれ指定する演算子です。 便宜上、
     GDBは両者を同一のものとして扱い、 格納されている型情報をもとに、
     ポインタによる間接参照の必要性を判断します。 構造体 （`struct'）
     および共用体 （`union'） に対して定義されています。

`[]'
     配列のインデックスです。 `A[I]'は、
     `*(A+I)'として定義されています。 `->'と同一の優先順位を持ちます。

`()'
     関数のパラメータ・リストです。 `->'と同一の優先順位を持ちます。

`::'
     C++のスコープ解決演算子です。 構造体（`struct'）、
     共用体（`union'）、 クラス（`class'）に対して定義されています。

`::'
     2重コロンはまた、 GDBのスコープ演算子 も 表わします （*note
     Expressions: Expressions.）。
     上記の`::'と同一の優先順位を持ちます。

* Menu:

* C Constants::


File: gdb-ja.info,  Node: C Constants,  Next: Cplus expressions,  Prev: C Operators,  Up: C

9.4.1.2 C/C++定数
.................

   GDBでは、 以下のような方法によって、
C/C++の定数を表わすことができます。

   * 整数型定数は、 数字の連続したものです。 8進数定数は、 先頭の`0'
     （ゼロ） により指定されます。 16進数定数は、
     先頭の`0x'または`0X'により指定されます。 定数は、 文字`l' （エル）
     により終わることもあります。 この場合、
     定数が`long'型の値として扱われるべきことを意味します。

   * 浮動小数点型定数は、 連続した数字、 その後ろに小数点、
     さらにその後ろに数字という形式です。 場合によっては、
     最後に指数部が付くこともあります。 指数部は、
     `e[[+]|-]NNN'という形式を取ります。 ここで、
     NNNは連続した数字です。 `+'は、 正の指数を示す記号で、
     必ずしも必要ではありません。

   * 列挙型定数は、 列挙識別子、
     またはそれに対応する整数値より構成されます。

   * 文字型定数は、 単一引用符 （`''） によって囲まれた単一の文字、
     あるいは、 その文字に対応する序数 （通常は、 ASCII値） です。
     引用符の中の単一文字は、
     文字または"エスケープ・シーケンス"によって表わすことができます。
     エスケープ・シーケンスには2つの表記方法があります。
     第1の形式は`\NNN'で、 NNNはその文字の序数を表わす8進数です。
     第2の形式は`\X'で、 `X'はあらかじめ定義された特別な文字です。
     例えば、 `\n'は改行を表わします。

   * 文字列型定数は、 連続した文字定数が2重引用符 （`"'）
     で囲まれたものです。

   * ポインタ型定数は、 整数値です。 定数へのポインタを、
     Cの`&'演算子を使用して記述することができます。

   * 配列定数は、 括弧`{'と`}'で囲まれ、 カンマで区切られたリストです。
     例えば、 `{1,2,3}'は3つの整数値を要素として持つ配列です。 `{{1,2},
     {3,4}, {5,6}}'は、 3×2の配列です。 また、 `{&"hi", &"there",
     &"fred"}'は3つのポインタを要素として持つ配列です。

* Menu:

* Cplus expressions::
* C Defaults::

* C Checks::

* Debugging C::


File: gdb-ja.info,  Node: Cplus expressions,  Next: C Defaults,  Prev: C Constants,  Up: C

9.4.1.3 C++式
.............

   GDBが持っている、 式を処理する機能は、
C++のほとんどの式を解釈することができます。

     _注意:_ GDBは、 適切なコンパイラが使用されている場合のみ、
     C++のコードをデバッグすることができます。 典型的な例を挙げると、
     C++のデバッグでは、
     シンボル・テーブルの中の追加的なデバッグ情報に依存するため、
     特別なサポートが必要になるということがあります。
     使用されるコンパイラが、 a.out、 MIPS ECOFF、 RS/6000 XCOFF、
     ELFを、
     シンボル・テーブルに対するstabs拡張付きで生成することができるのであれば、
     以下に列挙する機能を使用することができます （GNU CCの場合は、
     `-gstabs'オプションを使用して明示的にstabsデバッグ拡張を要求することができます）。
     一方、 オブジェクト・コードのフォーマットが、
     標準COFFやELFのDWARFである場合には、
     GDBの提供するほとんどのC++サポートは機能_しません_。

  1. メンバ関数の呼び出しが許されます。
     以下のような式を使用することができます。

          count = aml->GetOriginal(x, y)

  2. メンバ関数が （選択されたスタック・フレームの中で）
     アクティブな場合、 入力された式は、
     そのメンバ関数と同一の名前空間を利用することができます。 すなわち、
     GDBは、 C++と同様の規則にしたがって、
     クラス・インスタンスへのポインタ`this'への暗黙の参照を許します。

  3. オーバーロードされた関数を呼び出すことができます。 GDBは、
     正しい定義の関数呼び出しを決定します。 ただし、
     制限が一点あります。
     実際に呼び出したい関数が要求する型の引数を使用しなければなりません。
     GDBは、
     コンストラクタやユーザ定義の型演算子を必要とするような変換を実行しません。

  4. GDBは、 C++の参照変数として宣言された変数を理解します。
     C++のソース・コードで参照変数を使用するのと同一の方法で、
     参照変数を式の中で使用することができます。
     参照変数は自動的に間接参照されます。

     GDBがフレームを表示する際に表示されるパラメータ一覧の中では、
     参照変数の値は （他の変数とは異なり） 表示されません。 これにより、
     表示が雑然となることを回避できます。 というのは、
     参照変数は大きい構造体に対して使用されることが多いからです。
     参照変数の _アドレス_は、 `set print address off'を指定しない限り、
     常に表示されます。

  5. GDBはC++の名前解決演算子`::'をサポートしています。
     プログラム中と同様に、 式の中でこれを使用することができます。
     あるスコープが別のスコープの中で定義されることがありえるため、
     必要であれば`::'を繰り返し使用することができます。 例えば、
     `SCOPE1::SCOPE2::NAME'という具合です。 GDBはまた、
     CおよびC++のデバッグにおいて、
     ソース・ファイルを指定することで名前のスコープを解決することを許します
     （*note Program variables: Variables.）。


File: gdb-ja.info,  Node: C Defaults,  Next: C Checks,  Prev: Cplus expressions,  Up: C

9.4.1.4 C/C++のデフォルト
.........................

   GDBが自動的に型チェックや範囲チェックの設定を行うことを許すと、
作業言語がCやC++に変更されるときにはいつも、
それらの設定はデフォルトで`off'になります。 これは、
作業言語を選択したのがユーザであってもGDBであっても同様です。

   GDBが自動的に言語の設定を行うことを許すと、 GDBは、 名前が`.c'、
`.C'、 `.cc'などで終わるソース・ファイルを認識していて、
これらのファイルからコンパイルされたコードの実行を開始するときに、
作業言語をCまたはC++に設定します。 詳細については、 *Note Having GDB
infer the source language: Automatically。


File: gdb-ja.info,  Node: C Checks,  Next: Debugging C,  Prev: C Defaults,  Up: C Constants

9.4.1.5 C/C++の型チェックと範囲チェック
.......................................

デフォルトでは、 GDBがCやC++の式を解析するときには、
型チェックは行われません。 しかし、 ユーザが型チェックを有効にすると、
GDBは以下の条件が成立するときに、
2つの変数の型が一致しているとみなします。

   * 2つの変数が構造を持ち、 同一の構造体タグ、 共用体タグ、
     または列挙型タグを持つ。

   * 2つの変数が同一の型名を持つ、 あるいは、
     `typedef'によって同一の型に宣言されている型を持つ。


   範囲チェックは、 onに設定されている場合、
数学的演算において実行されます。 配列のインデックスは、
それ自体は配列ではないポインタのインデックスとして使用されることが多いため、
チェックされません。


File: gdb-ja.info,  Node: Debugging C,  Next: Debugging C plus plus,  Prev: C Checks,  Up: C

9.4.1.6 GDBとC
..............

   `set print union'コマンドと`show print union'コマンドは共用体型
（`union'） に適用されます。 `on'に設定されると、 構造体 （`struct'）
やクラス （`class'） の内部にある共用体 （`union'）
はすべて表示されます。 `on'でない場合、 それは`{...}'と表示されます。

   `@'オペレータは、
ポインタとメモリ割り当て関数によって作られた動的配列のデバッグに役に立ちます。
*Note Expressions: Expressions。

* Menu:

* Debugging C plus plus::


File: gdb-ja.info,  Node: Debugging C plus plus,  Prev: Debugging C,  Up: C

9.4.1.7 C++用のGDB機能
......................

   GDBのコマンドの中には、
C++を使用しているときに特に役に立つものがあり、 また、
C++専用に特に設計されたものがあります。 以下に、 その要約を示します。

`breakpoint menus'
     名前がオーバーロードされている関数の内部にブレイクポイントを設定したい場合、
     関心のある関数定義を指定するのに、
     GDBのブレイクポイント・メニューが役に立ちます。 *Note Breakpoint
     menus: Breakpoint Menus。

`rbreak REGEX'
     あるオーバーロードされたメンバ関数が、
     特別なクラスだけが持つメンバ関数というわけではない場合、
     そのメンバ関数にブレイクポイントを設定するのに、
     正規表現によるブレイクポイントの設定が役に立ちます。 *Note Setting
     breakpoints: Set Breaks。

`catch throw'
`catch catch'
     C++の例外処理をデバッグするのに使用します。 *Note Setting
     catchpoints: Set Catchpoints。

`ptype TYPENAME'
     型TYPENAMEに関して、継承関係などの情報を表示します。 *Note
     Examining the Symbol Table: Symbols。

`set print demangle'
`show print demangle'
`set print asm-demangle'
`show print asm-demangle'
     コードをC++のソースとして表示する場合と、
     逆アセンブル処理の結果を表示する場合に、
     C++のシンボルをソース形式で表示するか否かを制御します。 *Note
     Print settings: Print Settings。

`set print object'
`show print object'
     オブジェクトの型を表示する際に、 派生した （実際の）
     型と宣言された型のどちらを表示するかを選択します。 *Note Print
     settings: Print Settings。

`set print vtbl'
`show print vtbl'
     仮想関数テーブルの表示形式を制御します。 *Note Print settings:
     Print Settings。

`オーバーロードされたシンボル名'
     オーバーロードされたシンボルを宣言するのに
     C++において使用されるのと同一の表記法を使用して、
     オーバーロードされたシンボル定義のうち、
     特定のものを指定することができます。
     単にSYMBOLと入力するのではなく、
     `SYMBOL(TYPES)'と入力してください。
     GDBコマンドラインの単語補完機能を使用して、
     利用可能な選択肢を一覧表示させたり、
     型のリストを完結させたりすることができます。
     この機能の使用方法の詳細については、 *Note Command completion:
     Completion。


File: gdb-ja.info,  Node: Modula-2,  Prev: C,  Up: Support

9.4.2 Modula-2
--------------

Modula-2をサポートするために開発されたGDBの拡張機能は、 （現在開発中の）
GNU Modula-2コンパイラによって生成されたコードだけをサポートします。
他のModula-2コンパイラは現在サポートされていません。
他のModula-2コンパイラが生成した実行形式モジュールをデバッグしようとすると、
おそらく、
GDBが実行モジュールのシンボル・テーブルを読み込もうとしたところでエラーになるでしょう。

* Menu:

* M2 Operators::                組み込み演算子
* Built-In Func/Proc::          組み込み関数と組み込みプロシージャ
* M2 Constants::                Modula-2定数
* M2 Defaults::                 Modula-2デフォルト設定
* Deviations::                  標準Modula-2との差異
* M2 Checks::                   Modula-2の型チェックと範囲チェック
* M2 Scope::                    スコープ演算子`::'と`.'
* GDB/M2::                      GDBとModula-2


File: gdb-ja.info,  Node: M2 Operators,  Next: Built-In Func/Proc,  Prev: Modula-2,  Up: Modula-2

9.4.2.1 Modula-2演算子
......................

演算子は、 特定の型の値に対して定義されなければなりません。 例えば、
`+'は数値に対して定義され、 構造体に対しては定義されません。 演算子は、
型のグループに対して定義されることがよくあります。 Modula-2においては、
以下の定義が有効です。

   * _整数型_は、 `INTEGER'、 `CARDINAL'、 およびそのサブ範囲
     （subrange） から成ります。

   * _文字型_は、 `CHAR'とそのサブ範囲から成ります。

   * _浮動小数点型_は、 `REAL'から成ります。

   * _ポインタ型_は、 `POINTER TO TYPE'
     のように宣言された任意の型から成ります。

   * _スカラ型_は、 上記のすべての型から成ります。

   * _集合型_は、 `SET'、 `BITSET'から成ります。

   * _ブール型_は、 `BOOLEAN'から成ります。

以下の演算子がサポートされています。 ここでは、
優先順位の低いものから順に並べています。

`,'
     関数の引数の区切り記号、 または、
     配列のインデックスの区切り記号です。

`:='
     代入です。 VAR `:=' VALUEの値は VALUEです。

`<、>'
     未満、 超過です。 整数型、 浮動小数点型、
     列挙型に対して定義されています。

`<=、>='
     整数型、 浮動小数点型、 列挙型に対しては、 以下、
     以上を表わします。 集合型に対しては、 集合の包含関係を表わします。
     `<'と同一の優先順位を持ちます。

`=、<>、#'
     スカラ型に対して定義されている等価および2種類の不等価です。
     `<'と同一の優先順位を持ちます。 GDBスクリプトの中では、
     `#'がスクリプトのコメント記号でもあるため、
     不等価としては`<>'だけが使用可能です。

`IN'
     集合のメンバを表わします。 集合型、
     およびそのメンバの型に対して定義されています。
     `<'と同一の優先順位を持ちます。

`OR'
     ブール型のOR （disjunction） です。
     ブール型に対して定義されています。

`AND、&'
     ブール型のAND （conjunction） です。
     ブール型に対して定義されています。

`@'
     GDBの「人工配列」演算子です （*note Expressions: Expressions.）。

`+、-'
     整数型、 浮動小数点型に対しては、 加算、 減算を表わします。
     集合型に対しては、 和集合 （union）、 差集合 （difference）
     を表わします。

`*'
     整数型、 浮動小数点型に対しては、 乗算を表わします。
     集合型に対しては、 積集合 （intersection） を表わします。

`/'
     浮動小数点型に対しては、 除算を表わします。 集合型に対しては、
     対称的差集合 （symmetric difference） を表わします。
     `*'と同一の優先順位を持ちます。

`DIV、MOD'
     整数型の除算における商と剰余を表わします。
     整数型に対して定義されています。 `*'と同一の優先順位を持ちます。

`-'
     マイナス（負）です。 `INTEGER'、
     `REAL'型のデータに対して定義されています。

`^'
     ポインタの間接参照です。 ポインタ型に対して定義されています。

`NOT'
     ブール型のNOTです。 ブール型に対して定義されています。
     `^'と同一の優先順位を持ちます。

`.'
     `RECORD'フィールドの区切り記号です。
     `RECORD'データに対して定義されます。
     `^'と同一の優先順位を持ちます。

`[]'
     配列のインデックスを指定します。
     `ARRAY'型のデータに対して定義されています。
     `^'と同一の優先順位を持ちます。

`()'
     プロシージャの引数リストを指定します。
     `PROCEDURE'オブジェクトに対して定義されています。
     `^'と同一の優先順位を持ちます。

`::、.'
     GDBおよびModula-2のスコープ指定演算子です。

     _注意:_ 集合、 および集合に対する操作は、
     まだサポートされていません。 このため、 GDBは`IN'演算子、
     あるいは、 集合に対して`+'、 `-'、 `*'、 `/'、 `='、 `<>'、 `#'、
     `<='、 `>='のいずれかの演算子が使用された場合、
     これをエラーとして扱います。


File: gdb-ja.info,  Node: Built-In Func/Proc,  Next: M2 Constants,  Prev: M2 Operators,  Up: Modula-2

9.4.2.2 組み込み関数と組み込みプロシージャ
..........................................

Modula-2では、 いくつかの組み込みプロシージャ、
組み込み関数が使用できます。 これらの説明にあたり、
以下のメタ変数を使用します。

A
     `ARRAY'型の変数を表わします。

C
     `CHAR'型の定数、 または変数を表わします。

I
     整数型の変数、 または定数を表わします。

M
     集合に属する識別子を表わします。 通常、
     同一関数の中でメタ変数Sとともに使用されます。 Sの型は、 `SET OF
     MTYPE'でなければなりません （ここでのMTYPEはMの型です）。

N
     整数型または浮動小数点型の、 変数または定数を表わします。

R
     浮動小数点型の変数または定数を表わします。

T
     型を表わします。

V
     変数を表わします。

X
     多くの型の中の1つの型の、 変数または定数を表わします。
     詳細については、 関数の説明の部分を参照してください。

   また、 すべてのModula-2の組み込みプロシージャは、
以下に説明する値を返します。

`ABS(N)'
     値Nの絶対値を返します。

`CAP(C)'
     Cが小文字であれば、 それを大文字にして返します。
     Cが小文字でなければ、 Cをそのまま返します。

`CHR(I)'
     序数がIである文字を返します。

`DEC(V)'
     変数Vの値から1を引きます。 新しい値を返します。

`DEC(V,I)'
     変数Vの値からIで示される値を引きます。 新しい値を返します。

`EXCL(M,S)'
     集合Sから要素Mを取り除きます。 新しい集合を返します。

`FLOAT(I)'
     整数値Iに等しい浮動小数点値を返します。

`HIGH(A)'
     配列Aの最後の要素のインデックスを返します。

`INC(V)'
     変数Vの値に1を加えます。 新しい値を返します。

`INC(V,I)'
     変数Vの値にIで示される値を加えます。 新しい値を返します。

`INCL(M,S)'
     集合Sに要素Mが存在しない場合、 要素Mを追加します。
     新しい集合を返します。

`MAX(T)'
     型Tの最大値を返します。

`MIN(T)'
     型Tの最小値を返します。

`ODD(I)'
     Iが奇数であればブール型の`TRUE'を返します。

`ORD(X)'
     引数の序数値を返します。 例えば、 文字の序数値は、
     （ASCII文字セットをサポートするマシン上では） そのASCII値です。
     ここでXは、 整数型、 文字型、
     列挙型のような順序を持つ型でなければなりません。

`SIZE(X)'
     引数のサイズを返します。 Xは変数または型のいずれかです。

`TRUNC(R)'
     Rの整数部を返します。

`VAL(T,I)'
     型Tのメンバのうち、 その序数値がIであるものを返します。

     _注意:_ 集合、 および集合に対する操作はまだサポートされていません。
     したがって、 `INCL'プロシージャ、 `EXCL'プロシージャを使用すると、
     GDBはエラーとして扱います。


File: gdb-ja.info,  Node: M2 Constants,  Next: M2 Defaults,  Prev: Built-In Func/Proc,  Up: Modula-2

9.4.2.3 定数
............

GDBでは、 Modula-2の定数を以下のような方法で表現することができます。

   * 整数型の定数は、 単に数字が連続したものです。
     式の中で使用された場合、 定数は、
     式の他の部分と互換性のある型を持つものとみなされます。
     16進数の整数は末尾に`H'を付加することで、 また、
     8進数の整数は末尾に`B'を付加することで指定されます。

   * 浮動小数点型の定数は、 連続した数字、 その後ろに小数点、
     さらにその後ろに連続した数字が続くものです。 場合によっては、
     この後ろに指数部を指定することができます。
     指数部の形式は`E[+|-]NNN'で、
     `[+|-]NNN'の部分で希望する指数を指定します。
     浮動小数点型定数のすべての数字は、
     有効な10進数値でなければなりません。

   * 文字型定数は、
     単一引用符（`''）または2重引用符（`"'）で囲まれた単一文字より成ります。
     文字型定数は、 その文字の序数値 （通常はASCII値）
     の後ろに`C'を付加することで表現することもできます。

   * 文字列型定数は、
     単一引用符（`''）または2重引用符（`"'）で囲まれた連続する文字から成ります。
     C言語のスタイルでのエスケープ・シーケンスも使用できます。
     エスケープ・シーケンスに関する簡単な説明については、 *Note C and
     C++ constants: C Constants。

   * 列挙型定数は、 列挙識別子から成ります。

   * ブール型定数は、 識別子`TRUE'および`FALSE'から成ります。

   * ポインタ型定数は、 整数値だけから成ります。

   * 集合型定数は、 まだサポートされていません。


File: gdb-ja.info,  Node: M2 Defaults,  Next: Deviations,  Prev: M2 Constants,  Up: Modula-2

9.4.2.4 Modula-2デフォルト
..........................

型チェックと範囲チェックがGDBにより自動的に設定される場合、
作業言語がModula-2に変わるたびに、
それらはデフォルトで`on'に設定されます。 これは、
作業言語を選択したのがユーザであろうとGDBであろうと同様です。

   GDBに自動的に言語を設定させると、
ファイル名の末尾が`.mod'であるファイルからコンパイルされたコードに入るたびに、
作業言語はModula-2に設定されます。 詳細については、 *Note Having GDB
set the language automatically: Automatically。


File: gdb-ja.info,  Node: Deviations,  Next: M2 Checks,  Prev: M2 Defaults,  Up: Modula-2

9.4.2.5 標準Modula-2との差異
............................

Modula-2プログラムのデバッグを容易にするために2、
3の修正が施されています。 これは主に、
型に対する厳密性を緩めることによって実現されています。

   * 標準Modula-2とは異なり、
     ポインタ型定数は整数値から作成することができます。 これにより、
     デバッグ中にポインタ変数の値を変更することができるようになります
     （標準Modula-2では、
     ポインタ変数に格納されている実際のアドレスを知ることはできません。
     ポインタ変数内のアドレスは、 他のポインタ変数、 または、
     ポインタを返す式を直接的に代入することによってのみ修正することができます）。

   * 表示不可の文字を表わすのに、
     C言語のエスケープ・シーケンスを文字列や文字において使用することができます。
     GDBはこれらのエスケープ・シーケンスを埋め込んだまま文字列を表示します。
     表示不可の単一文字は、 `CHR(NNN)'という形式で表示されます。

   * 代入演算子 （`:='） は、 右側の引数の値を返します。

   * すべての組み込みプロシージャは、 引数を修正し、
     _さらに_それを返します。


File: gdb-ja.info,  Node: M2 Checks,  Next: M2 Scope,  Prev: Deviations,  Up: Modula-2

9.4.2.6 Modula-2の型チェックと範囲チェック
..........................................

     _注意:_ GDBは現在のところ、 型チェック、
     範囲チェックをまだ実装していません。

   GDBは、 以下のいずれかの条件が成立するとき、
2つのModula-2変数の型が等しいとみなします。

   * 2つの型が、 `TYPE T1 =
     T2'文によって等しいと宣言されている型である。

   * 2つの型が同一行において宣言されている （注：これはGNU
     Modula-2コンパイラにおいては正しいのですが、
     他のコンパイラにおいては正しくない可能性があります）。

   型チェックが有効である限り、
等しくない型の変数を組み合わせようとする試みはすべてエラーとなります。

   範囲チェックは、 数学的操作、 代入、 配列のインデックス境界、
およびすべての組み込み関数、 組み込みプロシージャにおいて実行されます。


File: gdb-ja.info,  Node: M2 Scope,  Next: GDB/M2,  Prev: M2 Checks,  Up: Modula-2

9.4.2.7 スコープ演算子`::'と`.'
...............................

Modula-2のスコープ演算子 （`.'） とGDBのスコープ演算子 （`::'）
との間には2、 3の微妙な相違点があります。
この2つは似た構文を持っています。


     MODULE . ID
     SCOPE :: ID

ここで、 SCOPEはモジュール名またはプロシージャ名、
MODULEはモジュール名、 IDはユーザ・プログラムの中で宣言された任意の
（異なるモジュール以外の） 識別子です。

   `::'演算子を使用すると、
GDBはSCOPEによって指定されたスコープにおいて識別子IDを探します。
指定されたスコープにおいてそれを見つけることができないと、
GDBはSCOPEによって指定されたスコープを包含するすべてのスコープを探します。

   `.'演算子を使用すると、 GDBはカレントなスコープにおいて、
MODUEによって指定された定義モジュールから取り込まれた、
IDによって指定される識別子を探します。 この演算子では、
識別子IDが定義モジュールMODULEから取り込まれていない場合やMODULEにおいてIDが識別子でない場合は、
エラーになります。


File: gdb-ja.info,  Node: GDB/M2,  Prev: M2 Scope,  Up: Modula-2

9.4.2.8 GDBとModula-2
.....................

GDBコマンドの中には、
Modula-2プログラムのデバッグにはほとんど役に立たないものがいくつかあります。
`set print'、 `show print'の5つのサブ・コマンド`vtbl'、 `demangle'、
`asm-demangle'、 `object'、 `union'はC/C++にのみ適用されます。
最初の4つはC++に適用され、 最後の1つはCの共用体 （`union'）
に適用されます。 これらは、
Modula-2において直接類似するものが存在しません。

   `@'演算子 （*note Expressions: Expressions.） は、
どの言語においても使用することができますが、
Modula-2においてはあまり役に立ちません。 この演算子は、
"動的配列"のデバッグを支援することを目的とするものですが、
C/C++では作成できる動的配列は、 Modula-2では作成できません。 しかし、
整数値定数によってアドレスを指定することができるので、
`{TYPE}ADREXP'は役に立ちます （*note Expressions: Expressions.）。

   GDBスクリプトの中では、
Modula-2の不等価演算子`#'はコメントの開始記号として解釈されます。
代わりに`<>'を使用してください。


File: gdb-ja.info,  Node: Symbols,  Next: Altering,  Prev: Languages,  Up: Top

10 シンボル・テーブルの検査
***************************

ここで説明するコマンドによって、
ユーザ・プログラムの中で定義されているシンボル情報 （変数名、 関数名、
型名） に関する問い合わせを行うことができます。
この情報はユーザ・プログラムのテキストに固有のもので、
プログラムの実行時に変わるものではありません。 GDBはこの情報を、
ユーザ・プログラムのシンボル・テーブルの中、 または、
GDB起動時に指定されたファイル （*note Choosing files: File Options.）
の中で見つけるか、 ファイル管理コマンド （*note Commands to specify
files: Files.） の実行によって見つけます。

   ときには、 参照する必要のあるシンボルの中に、
GDBが通常は単語の区切り文字として扱う文字が含まれていることがあるかもしれません。
特に多いのが、 他のソース・ファイルの中の静的変数を参照する場合です
（*note Program variables: Variables.）。 ファイル名は、
オブジェクト・ファイルの中にデバッグ・シンボルとして記録されていますが、
GDBは通常、 典型的なファイル名、 例えば`foo.c'を解析して、 3つの単語
`foo'、 `.'（ピリオド）、 `c'であるとみなします。
GDBが`foo.c'を単一のシンボルであると認識できるようにするには、
それを単一引用符で囲みます。 例えば、

     p 'foo.c'::x

は、 `x'の値をファイル`foo.c'のスコープの中で検索します。

`info address SYMBOL'
     SYMBOLで指定されるシンボルのデータがどこに格納されているかを示します。
     レジスタ変数の場合は、 それがどのレジスタに入っているかを示します。
     レジスタ変数ではないローカル変数の場合は、
     その変数が常に格納されている位置の、
     スタック・フレーム内におけるオフセット値を表示します。

     `print &SYMBOL'との相違に注意してください。 `print
     &SYMBOL'はレジスタ変数に対しては機能しませんし、
     スタック内のローカル変数に対して実行すると、
     その変数のカレントなインスタンスの存在するアドレスそのものが表示されます。

`whatis EXP'
     式EXPのデータ型を表示します。 EXPは実際には評価されず、
     EXP内の副作用を持つ操作 （例えば、代入や関数呼び出し）
     は実行されません。 *Note Expressions: Expressions。

`whatis'
     値ヒストリの最後の値である `$'のデータ型を表示します。

`ptype TYPENAME'
     データ型TYPENAMEの説明を表示します。 TYPENAMEは型の名前です。
     Cで記述されたコードの場合は、 `class CLASS-NAME'、 `struct
     STRUCT-TAG'、 `union UNION-TAG'、 `enum
     ENUM-TAG'という形式を取ることができます。

`ptype EXP'
`ptype'
     式EXPの型に関する説明を表示します。
     単に型の名前を表示するだけではなく、
     詳細な説明も表示するという点で、 `ptype'は`whatis'と異なります。

     例えば、 変数宣言

          struct complex {double real; double imag;} v;

     に対して、 `whatis'、
     `ptype'はそれぞれ以下のような出力をもたらします。

          (gdb) whatis v
          type = struct complex
          (gdb) ptype v
          type = struct complex {
              double real;
              double imag;
          }

     `whatis'と同様、 引数なしで`ptype'を使用すると、
     値ヒストリの最後の値である`$'の型を参照することになります。

`info types REGEXP'
`info types'
     その名前がREGEXPで指定される正規表現にマッチするすべての型
     （あるいは、 引数を指定しなければ、
     ユーザ・プログラム中のすべての型） の簡単な説明を表示します。
     個々の型の完全な名前は、
     それ自体が1つの完全な行を構成するものとみなして、 マッチされます。
     したがって、 `i type value'は、 ユーザ・プログラムの中で、
     その名前が文字列`value'を含むすべての型に関する情報を表示し、 `i
     type ^value$'は、
     名前が`value'そのものである型に関する情報だけを表示します。

     このコマンドは`ptype'とは2つの点で異なります。
     まず第1に`whatis'と同様、 詳細な情報を表示しません。 第2に、
     型が定義されているすべてのソース・ファイルを一覧表示します。

`info source'
     カレントなソース・ファイル、 すなわち、
     カレントな実行箇所を含む関数のソース・ファイルの、
     ファイル名とそれが記述された言語の名前を表示します。

`info sources'
     ユーザ・プログラムのソース・ファイルのうち、
     デバッグ情報の存在するものすべての名前を、
     2つの一覧にして表示します。 2つの一覧とは、
     シンボルが既に読み込まれたファイルの一覧と、
     後に必要なときにシンボルが読み込まれるファイルの一覧です。

`info functions'
     すべての定義済み関数の名前とデータ型を表示します。

`info functions REGEXP'
     その名前がREGEXPで指定される正規表現にマッチする部分を持つすべての定義済み関数の名前とデータ型を表示します。
     したがって、 `info fun step'は、
     その名前が文字列`step'を含むすべての関数を見つけ、 `info fun
     ^step'は、 名前が文字列`step'で始まるすべての関数を見つけます。

`info variables'
     関数の外部で宣言されているすべての変数 （つまり、
     ローカル変数を除く変数） の名前とデータ型を表示します。

`info variables REGEXP'
     その名前が正規表現REGEXPにマッチする部分を持つすべての
     （ローカル変数を除く） 変数の名前とデータ型を表示します。

     いくつかのシステムにおいては、
     ユーザ・プログラムの停止・再起動を伴うことなく、
     そのユーザ・プログラムを構成する個々のオブジェクト・ファイルを更新することができます。
     例えば、 VxWorksでは、
     欠陥のあるオブジェクト・ファイルを再コンパイルして、
     実行を継続することができます。
     このようなマシン上でプログラムを実行しているのであれば、
     自動的に再リンクされたモジュールのシンボルをGDBに再ロードさせることができます。

    `set symbol-reloading on'
          ある特定の名前を持つオブジェクト・ファイルが再検出されたときに、
          対応するソース・ファイルのシンボル定義を入れ替えます。

    `set symbol-reloading off'
          同じ名前を持つオブジェクト・ファイルを再検出したときに、
          シンボル定義を入れ替えません。 これがデフォルトの状態です。
          モジュールの自動再リンクを許しているシステム上でプログラムを実行しているのでない場合は、
          `symbol-reloading'の設定はoffのままにするべきです。
          さもないと、 （異なるディレクトリやライブラリの中にある）
          同じ名前を持ついくつかのモジュールを含むような大きなプログラムをリンクする際に、
          GDB はシンボルを破棄してしまうかもしれません。

    `show symbol-reloading'
          `symbol-reloading'のカレントな設定 （`on'または`off'）
          を表示します。

`maint print symbols FILENAME'
`maint print psymbols FILENAME'
`maint print msymbols FILENAME'
     デバッグ・シンボル・データのダンプをファイルFILENAMEの中に書き込みます。
     これらのコマンドは、
     GDBのシンボル読み込みコードをデバッグするのに使われています。
     デバッグ・データを持つシンボルだけがダンプに含まれます。 `maint
     print symbols'を使用すると、 GDBは、
     完全な詳細情報を入手済みのすべてのシンボルの情報をダンプに含めます。
     つまり、 ファイルFILENAMEには、
     GDBがそのシンボルを読み込み済みのファイルに対応するシンボルが反映されます。
     `info sources'コマンドを使用することで、
     これらのファイルがどれであるかを知ることができます。
     代わりに`maint print psymbols'を使用すると、 GDB
     が部分的にしか知らないシンボルに関する情報もダンプの中に含まれます。
     これは、 GDBがざっと読みはしたものの、
     まだ完全には読み込んでいないファイルに定義されているシンボルに関する情報です。
     最後に`maint print msymbols'では、
     GDBが何らかのシンボル情報を読み込んだオブジェクト・ファイルから、
     最小限必要とされるシンボル情報がダンプされます。
     GDBがどのようにしてシンボルを読み込むかについては、 *Note Commands
     to specify files: Files.  （の`symbol-file'の説明の部分）
     を参照してください。


File: gdb-ja.info,  Node: Altering,  Next: GDB Files,  Prev: Symbols,  Up: Top

11 実行の変更
*************

ユーザ・プログラムの中に誤りのある箇所を見つけると、
その明らかな誤りを訂正することで、
その後の実行が正しく行われるかどうかを知りたくなるでしょう。
GDBにはプログラムの実行に変化を与える機能があり、
これを使って実験することで、 その答を知ることができます。

   例えば、 変数やメモリ上のある箇所に新しい値を格納すること、
ユーザ・プログラムにシグナルを送ること、
ユーザ・プログラムを異なるアドレスで再起動すること、
関数が完全に終了する前に呼び出し元に戻ることなどが可能です。

* Menu:

* Assignment::                  変数への代入
* Jumping::                     異なるアドレスにおける処理継続

* Signaling::                   ユーザ・プログラムへのシグナルの通知

* Returning::                   関数からの復帰
* Calling::                     ユーザ・プログラム関数の呼び出し
* Patching::                    ユーザ・プログラムへのパッチ適用


File: gdb-ja.info,  Node: Assignment,  Next: Jumping,  Prev: Altering,  Up: Altering

11.1 変数への代入
=================

ある変数の値を変更するには、 代入式を評価します。 *Note Expressions:
Expressions。 例えば、

     print x=4

は、 変数`x'に値4を格納してから、 その代入式の値 （すなわち4）
を表示します。 サポートされている言語の演算子の詳細情報については、
*Note Using GDB with Different Languages: Languages。

   代入の結果を表示させることに関心がなければ、
`print'コマンドの代わりに`set'コマンドを使用してください。
実際のところ`set'コマンドは、 式の値が表示もされず、 値ヒストリ （*note
Value history: Value History.） にも入らないということを除けば、
`print'コマンドと同等です。 式は、
その結果の入手だけを目的として評価されます。

   `set'コマンドの引数となる文字列の先頭の部分が、
`set'コマンドのサブ・コマンドの名前と一致してしまうような場合には、
ただの`set'コマンドではなく`set variable'コマンドを使用してください。
このコマンドは、 サブ・コマンドを持たないという点を除けば、
`set'コマンドと同等です。 例えば、
ユーザ・プログラムに`width'という変数がある場合、 `set
width=13'によってこの変数に値を設定しようとするとエラーになります。
これは、 GDBが`set width'というコマンドを持っているためです。

     (gdb) whatis width
     type = double
     (gdb) p width
     $4 = 13
     (gdb) set width=47
     Invalid syntax in expression.

ここで不正な表現となっているのは、 もちろん`=47'の部分です。
プログラム内の変数`width'に値を設定するには、 以下のようにしてください。

     (gdb) set var width=47

   GDBは、 代入時の暗黙の型変換をC言語よりも多くサポートしています。
整数値を自由にポインタ型変数に格納できますし、 その逆もできます。 また、
任意の構造体を、 同じサイズの別の構造体、 または、
より小さいサイズの別の構造体に変換することができます。

   メモリ上の任意の箇所に値を格納するには、
指定されたアドレスにおいて指定された型の値を生成するために、
`{...}'を使用します （*note Expressions: Expressions.）。
例えば`{int}0x83040'は、
メモリ・アドレス`0x83040'を整数値として参照します （メモリ上における、
ある特定のサイズと表現を示唆しています）。 また、

     set {int}0x83040 = 4

は、 そのメモリ・アドレスに値4を格納します。


File: gdb-ja.info,  Node: Jumping,  Next: Signaling,  Prev: Assignment,  Up: Altering

11.2 異なるアドレスにおける処理継続
===================================

通常、 ユーザ・プログラムを継続実行するには、
`continue'コマンドを使用して、 停止した箇所から継続実行させます。
以下のコマンドを使用することで、
ユーザが選択したアドレスにおいて実行を継続させることができます。

`jump LINESPEC'
     LINESPECで指定される行において、 実行を再開します。
     その行にブレイクポイントが設定されている場合には、
     実行は再びすぐに停止します。 LINESPECの形式については、 *Note
     Printing source lines: List。 一般的な慣例として、
     `jump'コマンドは、 `tbreak'コマンドと組み合わせて使用されます。
     *Note Setting breakpoints: Set Breaks。

     `jump'コマンドは、 カレントなスタック・フレーム、
     スタック・ポインタ、 メモリ内の任意の箇所の内容、
     プログラム・カウンタを除くレジスタの内容を変更しません。
     LINESPECで指定される行が、
     現在実行されている関数とは異なる関数の中にある場合、
     それら2つの関数が異なるパターンの引数やローカル変数を期待していると、
     奇妙な結果が発生するかもしれません。 このため、 指定された行が、
     現在実行されている関数の中にない場合、
     `jump'コマンドは実行の確認を求めてきます。 しかし、
     ユーザがプログラムのマシン言語によるコードを熟知していたとしても、
     奇妙な結果の発生することが予想されます。

`jump *ADDRESS'
     ADDRESSで指定されるアドレスにある命令から、 実行を再開します。

   レジスタ`$pc'に新しい値を設定することで、
`jump'コマンドとほとんど同等の効果を実現することができます。
両者の違いは、 レジスタ`$pc'に値を設定しただけでは、
ユーザ・プログラムの実行は再開されないという点にあります。
ユーザが実行を_継続するとき_に、
プログラムが実行を再開するアドレスが変更されるだけです。 例えば、

     set $pc = 0x485

を実行すると、
次に`continue'コマンドやステップ実行を行うコマンドが実行されるとき、
ユーザ・プログラムが停止したアドレスにある命令ではなく、
アドレス`0x485'にある命令から実行されることになります。 *Note
Continuing and stepping: Continuing and Stepping。

   `jump'コマンドが最も一般的に使用されるのは、
既に実行されたプログラム部分を、
さらに多くのブレイクポイントを設定した状態で再実行する場合でしょう。
これにより、 実行される処理の内容をさらに詳しく調べることができます。


File: gdb-ja.info,  Node: Signaling,  Next: Returning,  Prev: Jumping,  Up: Altering

11.3 ユーザ・プログラムへのシグナルの通知
=========================================

`signal SIGNAL'
     実行を停止した箇所からユーザ・プログラムを再開させますが、
     すぐにSIGNALで指定されるシグナルを通知します。 SIGNALには、
     シグナルの名前または番号を指定できます。 例えば、
     多くのシステムにおいて、 `signal 2'と`signal SIGINT'はどちらも、
     割り込みシグナルを通知する方法です。

     一方、 SIGNALが0であれば、
     シグナルを通知することなく実行を継続します。
     ユーザ・プログラムがシグナルのために停止し、 通常であれば、
     `continue'コマンドによって実行を再開するとそのシグナルを検知してしまうような場合に便利です。
     `signal 0'を実行すると、
     プログラムはシグナルを受信することなく実行を再開します。

     `signal'を実行した後、 <RET>キーを押しても、
     繰り返し実行は行われません。

   `signal'コマンドを実行することは、
シェルから`kill'ユーティリティを実行するのと同じではありません。
`kill'によってシグナルを送ると、
GDBはシグナル処理テーブルによって何をするべきかを決定します （*note
Signals::）。 一方、 `signal'コマンドは、
ユーザ・プログラムに直接シグナルを渡します。


File: gdb-ja.info,  Node: Returning,  Next: Calling,  Prev: Signaling,  Up: Altering

11.4 関数からの復帰
===================

`return'
`return EXPRESSION'
     `return'コマンドによって、
     呼び出されている関数の実行をキャンセルすることができます。
     式EXPRESSIONを引数に指定すると、
     その値が関数の戻り値として使用されます。

   `return'を実行すると、 GDBは選択されているスタック・フレーム
（および、 その下位にあるすべてのフレーム） を破棄します。
破棄されたフレームは、
実行を完結する前に復帰したのだと考えればよいでしょう。
戻り値を指定したいのであれば、
その値を`return'への引数として渡してください。

   このコマンドは、 選択されているスタック・フレーム （*note Selecting
a frame: Selection.）、 および、
その下位にあるすべてのフレームをポップして、
もともと選択されていたフレームを呼び出したフレームを、
最下位のフレームにします。 つまり、
そのフレームが選択されることになります。 指定された値は、
関数から戻り値を返すのに使用されるレジスタに格納されます。

   `return'コマンドは実行を再開しません。 関数から復帰した直後の状態で、
プログラムを停止したままにします。 これに対して、 `finish'コマンド
（*note Continuing and stepping: Continuing and Stepping.）は、
選択されているスタック・フレームが自然に復帰するまで、 実行を再開、
継続します。


File: gdb-ja.info,  Node: Calling,  Next: Patching,  Prev: Returning,  Up: Altering

11.5 プログラム関数の呼び出し
=============================

`call EXPR'
     `void'型の戻り値を表示することなく、 式EXPRを評価します。

   ユーザ・プログラムの中からある関数を呼び出したいが、
void型の戻り値を出力させたくない場合、
この`print'コマンドの変種を使用することができます。
`void'型でない戻り値は表示され、 値ヒストリに保存されます。

   A29Kでは、 ユーザに制御される変数`call_scratch_address'によって、
GDBがデバッグ対象の関数を呼び出すときに使用するスクラッチ領域が指定されます。
通常はスクラッチ領域をスタック上に置きますが、
この方法は命令空間とデータ空間を別々に持つシステム上では機能しないため、
これが必要になります。


File: gdb-ja.info,  Node: Patching,  Prev: Calling,  Up: Altering

11.6 プログラムへのパッチ適用
=============================

デフォルトでは、 GDBはユーザ・プログラムの実行コードを持つファイル
（あるいは、 コア・ファイル） を書き込み不可の状態でオープンします。
これにより、
マシン・コードを誤って変更してしまうことを防ぐことができます。 しかし、
ユーザ・プログラムのバイナリに意図的にパッチを適用することもできなくなってしまいます。

   バイナリにパッチを適用したいのであれば、 `set
write'コマンドによって明示的にそのことを指定することができます。
例えば、 内部的なデバッグ・フラグを立てたり、
緊急の修正を行いたいということがあるでしょう。

`set write on'
`set write off'
     `set write on'を指定すると、 GDBは実行ファイル やコア・ファイル
     を、 読み込み、 書き込みともに可能な状態でオープンします。 `set
     write off' （デフォルト） を指定すると、
     GDBはこれらのファイルを読み込みしかできない状態でオープンします。

     既にファイルをロード済みの場合、 `set write'の設定を変更後、
     その変更を反映させるためには、 （`exec-file'コマンド 、
     `core-file'コマンド を使用して）、
     そのファイルを再ロードしなければなりません。

`show write'
     実行ファイル 、コア・ファイル が、
     読み込みだけではなく書き込みもできる状態でオープンされる設定になっているか否かを表示します。


File: gdb-ja.info,  Node: GDB Files,  Next: Targets,  Prev: Altering,  Up: Top

12 GDBファイル
**************

GDBはデバッグ対象となるプログラムのファイル名を知っている必要があります。
これは、 プログラムのシンボル・テーブルを読み込むためでもあり、 また、
プログラムを起動するためでもあります。
過去に生成されたコア・ダンプをデバッグするには、
GDBにコア・ダンプ・ファイルの名前を教えてやらなければなりません。

* Menu:

* Files::                       ファイルを指定するコマンド
* Symbol Errors::               シンボル・ファイル読み込み時のエラー


File: gdb-ja.info,  Node: Files,  Next: Symbol Errors,  Prev: GDB Files,  Up: GDB Files

12.1 ファイルを指定するコマンド
===============================

実行ファイルやコア・ダンプ・ファイルの名前を指定したい場合があります。
これは通常、 GDBの起動コマンドへの引数を利用して、 起動時に行います
（*note Getting In and Out of GDB: Invocation.）。

ときには、 GDBのセッション中に、
異なるファイルに切り替える必要がでてくることがあります。 あるいは、
GDBを起動するときに、
使いたいファイルの名前を指定するのを忘れたということもあるかもしれません。
このような場合に、 新しいファイルを指定するGDBコマンドが便利です。

`file FILENAME'
     FILENAMEで指定されるプログラムをデバッグ対象にします。
     そのプログラムは、
     シンボル情報とメモリ内容を獲得するために読み込まれます。 また、
     ユーザが`run'コマンドを使用したときに実行されます。
     ユーザがディレクトリを指定せず、
     そのファイルがGDBの作業ディレクトリに見つからない場合、
     シェルが実行すべきファイルを探すときと同様、 GDBは、
     ファイルを探すべきディレクトリのリストとして環境変数`PATH'の値を使用します。
     `path'コマンドによって、 GDB、 ユーザ・プログラムの両方について、
     この変数の値を変更することができます。

     ファイルをメモリにマップすることのできるシステムでは、
     補助的なファイル`FILENAME.syms'に、
     ファイルFILENAMEのシンボル・テーブル情報が格納されることがあります。
     このような場合、 GDBは、
     `FILENAME.syms'というファイルからシンボル・テーブルをメモリ上にマップすることで、
     起動に要する時間を短くします。 詳細については、
     （以下に説明する`file'コマンド、 `symbol-file'コマンド、
     `add-symbol-file'コマンドを実行する際にコマンドライン上で使用可能な）
     ファイル・オプションの`-mapped'、
     `-readnow'の説明を参照してください。

`file'
     `file'コマンドを引数なしで実行すると、 GDBは実行ファイル、
     シンボル・テーブルに関して保持している情報をすべて破棄します。

`exec-file [ FILENAME ]'
     実行するプログラムがFILENAMEで指定されるファイル内に存在する
     （ただし、 シンボル・テーブルはそこには存在しない）
     ということを指定します。 GDBは、 必要であれば、
     ユーザ・プログラムの存在場所を見つけるために、
     環境変数`PATH'を使用します。 FILENAMEを指定しないと、
     実行ファイルに関して保持している情報を破棄するよう指示したことになります。

`symbol-file [ FILENAME ]'
     FILENAMEで指定されるファイルからシンボル・テーブル情報を読み込みます。
     必要な場合には`PATH'が検索されます。 同一のファイルから、
     シンボル・テーブルと実行プログラムの両方を獲得する場合には、
     `file'コマンドを使用してください。

     `symbol-file'を引数なしで実行すると、
     GDBがユーザ・プログラムのシンボル・テーブルに関して持っている情報は消去されます。

     `symbol-file'コマンドが実行されると、
     それまでGDBが保持していたコンビニエンス変数、 値ヒストリ、
     すべてのブレイクポイント、 自動表示式は破棄されます。 その理由は、
     これらの情報の中に、
     GDBが破棄した古いシンボル・テーブルのデータの一部である、
     シンボルやデータ型を記録する内部データへのポインタが含まれているかもしれないからです。

     `symbol-file'を一度実行した後に<RET>キーを押しても、
     `symbol-file'の実行は繰り返されません。

     GDBは、 特定の環境用に構成されると、
     その環境において生成される標準フォーマットのデバッグ情報を理解するようになります。
     GNUコンパイラを使うこともできますし、
     ローカルな環境の規約に従う他のコンパイラを使用することもできます。
     通常は、
     GNUコンパイラを使用しているときに最高の結果を引き出すことができます。
     例えば`gcc'を使用すると、
     最適化されたコードに対してデバッグ情報を生成することができます。

     COFFを使用する古いSVR3システムを除外すれば、
     ほとんどの種類のオブジェクト・ファイルでは、
     `symbol-file'コマンドを実行しても、 通常は、
     ただちにシンボル・テーブルの全体が読み込まれるわけではありません。
     実際に存在するソース・ファイルとシンボルを知るために、
     シンボル・テーブルを素早く調べるだけです。 詳細な情報は、
     後にそれが必要になったときに、
     一度に1ソース・ファイルずつ読み込まれます。

     2段階に分けて読み込むという手法は、
     GDBの起動時間の短縮を目的としています。 ほとんどの場合、
     このような手法が採用されているということに気付くことはありません。
     せいぜい、
     特定のソース・ファイルに関するシンボル・テーブルの詳細が読み込まれている間、
     たまに停止するくらいです （もしそうしたいのであれば、 `set
     verbose'コマンドを使うことによって、
     このようにして停止しているときにはメッセージを表示させることもできます。
     *Note Optional warnings and messages: Messages/Warnings）。

     COFFについては、 まだこの2段階方式を実装していません。
     シンボル・テーブルが COFFフォーマットで格納されている場合、
     `symbol-file'コマンドはシンボル・テーブル・データの全体をただちに読み込みます。
     COFFのstabs拡張フォーマット（stabs-in-COFF）では、
     デバッグ情報が実際にはstabsフォーマットの内部に存在するため、
     2段階方式が実装されていることに注意してください。

`symbol-file FILENAME [ -readnow ] [ -mapped ]'
`file FILENAME [ -readnow ] [ -mapped ]'
     GDBが確実にシンボル・テーブル全体を保持しているようにしたいのであれば、
     シンボル・テーブル情報を読み込む任意のコマンド実行時に
     `-readnow'オプションを使用することで、
     2段階によるシンボル・テーブル読み込み方式を使わないようにさせることができます。

     `mmap'システム・コールによるファイルのメモリへのマッピングがシステム上において有効な場合、
     もう1つのオプション `-mapped'を使って、 GDBに対して、
     再利用可能なファイルの中にユーザ・プログラムのシンボルを書き込ませることができます。
     後のGDBデバッグ・セッションは、 （プログラムに変更がない場合）
     実行プログラムからシンボル・テーブルを読み込むのに時間を費やすことなく、
     この補助シンボル・ファイルからシンボル情報をマップします。
     `-mapped'オプションを使用することは、
     コマンドライン・オプション`-mapped'を指定してGDBを起動するのと同じ効果を持ちます。

     補助シンボル・ファイルがユーザ・プログラムのシンボル情報をすべて確実に持つように、
     両方のオプションを同時に指定することもできます。

     MYPROGという名前のプログラムの補助シンボル・ファイルは、
     `MYPROG.syms'という名前になります。 このファイルが存在すると、
     （それが、 対応する実行ファイルよりも新しい限り）
     ユーザがMYPROGをデバッグしようとすると、
     GDBは常にそのファイルを使おうとします。
     特別なオプションやコマンドは必要ありません。

     `.syms'ファイルは、 GDBを実行したホスト・マシンに固有のものです。
     それは、
     GDB内部におけるシンボル・テーブルの正確なイメージを保持しています。
     複数のホスト・プラットフォーム間で共用することはできません。

`core-file [ FILENAME ]'
     「メモリ上のイメージ」として使用されるコア・ダンプ・ファイルの存在場所を指定します。
     伝統的に、 コア・ファイルは、
     それを生成したプロセスのアドレス空間の一部だけを保持しています。
     GDBは、 実行ファイルそのものにアクセスすることによって、
     保持されていない部分を獲得することができます。

     `core-file'を引数なしで実行すると、
     コア・ファイルを一切使用しないことを指定したことになります。

     ユーザ・プログラムが実際にGDBの管理下で実行中の場合は、
     コア・ファイルは無視されることに注意してください。 したがって、
     ある時点までユーザ・プログラムを実行させた後に、
     コア・ファイルをデバッグしたくなったような場合、
     プログラムを実行しているサブ・プロセスを終了させなければなりません。
     サブ・プロセスの終了は、 `kill'コマンドで行います （*note Killing
     the child process: Kill Process.）。

`add-symbol-file FILENAME ADDRESS'
`add-symbol-file FILENAME ADDRESS [ -readnow ] [ -mapped ]'
     `add-symbol-file'コマンドは、
     FILENAMEで指定されるファイルから追加的なシンボル・テーブル情報を読み込みます。
     FILENAMEで指定されるファイルが （何か別の方法によって）
     実行中のプログラムの中に動的にロードされた場合に、
     このコマンドを使用します。 ADDRESSは、
     ファイルがロードされたメモリ・アドレスでなければなりません。
     GDBは独力でこのアドレスを知ることはできません。
     ADDRESSは式として指定することもできます。

     FILENAMEで指定されるファイルのシンボル・テーブルは、
     もともと`symbol-file'コマンドによって読み込まれたシンボル・テーブルに追加されます。
     `add-symbol-file'コマンドは何回でも使用することができます。
     新たに読み込まれたシンボル・テーブルのデータは、
     古いデータに追加されていきます。
     古いシンボル・データをすべて破棄するには、
     `symbol-file'コマンドを使用してください。

     `add-symbol-file'コマンドを実行した後に<RET>キーを押しても、
     `add-symbol-file'コマンドは繰り返し実行されません。

     `symbol-file'コマンドと同様、
     `-mapped'オプションと`-readnow'オプション使用して、
     FILENAMEで指定されるファイルのシンボル・テーブル情報をGDBがどのように管理するかを変更することができます。

`add-shared-symbol-file'
     `add-shared-symbol-file'コマンドは、 Motorola 88k用のHarris'
     CXUXオペレーティング・システム上でのみ使用することができます。
     GDBは自動的に共有ライブラリを探しますが、
     GDBがユーザの共有ライブラリを見つけてくれない場合には、
     `add-shared-symbol-file'コマンドを実行できます。
     このコマンドは引数を取りません。

`section'
     `section'コマンドは、
     実行ファイルのSECTIONセクションのベース・アドレスをADDRに変更します。
     これは、 （a.outフォーマットのように）
     実行ファイルがセクション・アドレスを保持していない場合や、
     ファイルの中で指定されているアドレスが誤っている場合に使うことができます。
     個々のセクションは、 個別に変更されなければなりません。 `info
     files'コマンドによって、
     すべてのセクションとそのアドレスを一覧表示することができます。

`info files'
`info target'
     `info files'と`info target'は同義です。 両方とも、
     カレント・ターゲット （*note Specifying a Debugging Target:
     Targets.） に関する情報を表示します。 表示される情報には、
     GDBが現在使用中の 実行ファイルやコア・ダンプ・ファイル の名前、
     シンボルがそこからロードされたファイルの名前を含みます。 `help
     target'コマンドは、 カレントなターゲットではなく、
     すべての可能なターゲットを一覧表示します。

   ファイルを指定するすべてのコマンドは、 引数として、
絶対パスによるファイル名と相対パスによるファイル名のどちらでも受け付けます。
GDBは、 常にファイル名を絶対パス名に変換して、
絶対パスの形で記憶します。

   GDBは、 HP-UX、 SunOS、 SVr4、 Irix 5、 IBM
RS/6000の共有ライブラリをサポートします。
ユーザが`run'コマンドを実行したり、 コア・ファイルを調べようとすると、
GDBは自動的に共有ライブラリからシンボル定義をロードします
（ユーザが`run'コマンドを発行するまでは、
共有ライブラリ内部の関数への参照があっても、
GDBにはそれを理解することができません。
コア・ファイルをデバッグしている場合は、 この限りではありません）。

`info share'
`info sharedlibrary'
     現在ロードされている共有ライブラリの名前を表示します。

`sharedlibrary REGEX'
`share REGEX'
     UNIXの正規表現にマッチするファイルに対応する、
     共有オブジェクト・ライブラリのシンボルをロードします。
     自動的にロードされるファイルと同様、
     ユーザ・プログラムによってコア・ファイルのために必要とされる共有ライブラリ、
     または
     `run'コマンド実行時に必要とされる共有ライブラリだけがロードされます。
     REGEXが省略されると、
     ユーザ・プログラムによって必要とされるすべての共有ライブラリがロードされます。


File: gdb-ja.info,  Node: Symbol Errors,  Prev: Files,  Up: GDB Files

12.2 シンボル・ファイル読み込み時のエラー
=========================================

シンボル・ファイルの読み込み中に、
GDBはときどき問題にぶつかることがあります。 例えば、
認識できないシンボル・タイプを見つけたり、
コンパイラの出力に既知の問題を発見することがあります。 デフォルトでは、
このようなエラーがあったことを、 GDBはユーザに知らせません。 なぜなら、
このようなエラーは比較的よく見られるものであり、
コンパイラのデバッグをしているような人々だけが関心を持つようなものだからです。
もし、
正しく構築されていないシンボル・テーブルに関する情報を見ることに関心があれば、
`set complaints'コマンドを使用することで、
何回問題が発生しようと個々のタイプの問題について1回だけメッセージを出力するよう指示することができますし、
また、
何回問題発生したかを見るためにより多くのメッセージを表示するよう指示することもできます
（*note Optional warnings and messages: Messages/Warnings.）。

   現在のバージョンで表示されるメッセージとその意味を以下に記します。

`inner block not inside outer block in SYMBOL'
     シンボル情報は、 シンボルのスコープの先頭と末尾の位置を示します
     （例えば、 ある関数の先頭、 あるいは、 ブロックの先頭など）。
     このエラーは、 内側のスコープのブロックが、
     外側のスコープのブロックに完全に包含されていないことを意味しています。

     GDBは、
     内側のブロックが外側のブロックと同一のスコープを持つものとして扱うことで、
     この問題を回避します。
     外側のブロックが関数でない場合には、エラー・メッセージの
     SYMBOLの部分が``(don't know)''のように表示されることがあります。

`block at ADDRESS out of order'
     シンボルのスコープとなるブロックに関する情報は、
     アドレスの低い方から昇順に並んでいなければなりません。
     このエラーは、 そうなっていないということを示しています。

     GDBはこの問題を回避することはせず、
     読み込もうとしているソース・ファイルのシンボルを見つけるのに支障が出ます
     （`set verbose on'を指定することで、
     どのソース・ファイルが関係しているかを知ることができます。 *Note
     Optional warnings and messages: Messages/Warnings）。

`bad block start address patched'
     シンボルのスコープとなるブロックに関する情報の中の開始アドレスが、
     1つ前のソース行のアドレスより小さい値です。 これは、 SunOS 4.1.1
     （および、 それ以前のバージョン）
     のCコンパイラで発生することが分かっています。

     GDBは、
     シンボルのスコープとなるブロックが1つ前のソース行から始まるものとして扱うことによって、
     この問題を回避します。

`bad string table offset in symbol N'
     シンボル番号Nのシンボルが持っている文字列テーブルへのポインタが、
     文字列テーブルのサイズを超える値です。

     GDBは、
     このシンボルが`foo'という名前を持つものとみなすことによって、
     この問題を回避します。 この結果、
     多くのシンボルが`foo'という名前を持つことになってしまうと、
     他の問題が発生する可能性があります。

`unknown symbol type `0xNN''
     シンボル情報の中に、
     どのようにして読み取ればよいのかGDBには分からないような、
     新しいデータ型が含まれています。
     `0xNN'は理解できなかったシンボルの型を16進数で表わしたものです。

     GDBは、 このようなシンボル情報を無視することによって、
     このエラーを回避します。 通常、
     プログラムのデバッグを行うことは可能になりますが、
     ある特定のシンボルにアクセスすることができなくなります。
     このような問題にぶつかり、 それをデバッグしたいのであれば、
     `gdb'自身を使って`gdb'をデバッグすることができます。 この場合、
     シンボル`complain'にブレイクポイントを設定し、
     関数`read_dbx_symtab'まで実行してから、
     `*bufp'によってシンボルを参照します。

`stub type has NULL name'
     GDBは、 ある構造体 またはクラス
     に関する完全な定義を見つけることができませんでした。

`const/volatile indicator missing (ok if using g++ v1.x), got...'
     あるC++のメンバ関数に関するシンボル情報に、
     より新しいコンパイラを使用した場合には生成されるいくつかの情報が欠けています。

`info mismatch between compiler and debugger'
     GDBは、 コンパイラが生成した型の指定を解析できませんでした。


File: gdb-ja.info,  Node: Targets,  Next: Controlling GDB,  Prev: GDB Files,  Up: Top

13 デバッグ・ターゲットの指定
*****************************

"ターゲット"とは、 ユーザ・プログラムが持つ実行環境を指します。
多くの場合、 GDBはユーザ・プログラムと同一のホスト環境上で実行されます。
この場合には、 `file'コマンドや`core'コマンドを実行すると、
その副作用としてデバッグ・ターゲットが指定されます。 例えば、
物理的に離れた位置にあるホスト・マシン上でGDBを実行したい場合や、
シリアル・ポート経由でスタンドアロン・システムを制御したい場合、
または、
TCP/IP接続を利用してリアルタイム・システムを制御したい場合などのように、
より多くの柔軟性が必要とされる場合、
`target'コマンドを使うことによって、
GDBに設定されたターゲットの種類の中から1つを指定することができます
（*note Commands for managing targets: Target Commands.）。

* Menu:

* Active Targets::              アクティブ・ターゲット
* Target Commands::             ターゲットを管理するコマンド

* Byte Order::                  ターゲットのバイト・オーダの選択
* Remote::                      リモート・デバッグ


File: gdb-ja.info,  Node: Active Targets,  Next: Target Commands,  Prev: Targets,  Up: Targets

13.1 アクティブ・ターゲット
===========================

ターゲットには3つのクラスがあります。 プロセス、コア・ファイル、
そして、 実行ファイルです。 GDBは同時に、 1クラスにつき1つ、
全体で最高で3つまでアクティブなターゲットを持つことができます。
これにより、 （例えば）
コア・ファイルに対して行ったデバッグ作業を破棄することなく、
プロセスを起動してその動作を調べることができます。

   例えば、 `gdb a.out'を実行すると、
実行ファイル`a.out'が唯一のアクティブなターゲットになります。
コア・ファイル （おそらくは、
前回実行したときにクラッシュしてコア・ダンプしたもの）
を併せて指定すると、 GDBは2つのターゲットを持ち、
メモリ・アドレスを知る必要がある場合には、
それを知るために2つのターゲットを並行して使用します。 この場合、
まずコア・ファイルを参照し、 次に実行ファイルを参照します。
（典型的には、 これら2つのクラスのターゲットは相互に補完的です。
というのも、 コア・ファイルには、
プログラムが持っている変数などの読み書き可能なメモリ域の内容とマシン・ステータスだけがあり、
実行ファイルには、
プログラムのテキストと初期化されたデータだけがあるからです）。

`run'コマンドを実行すると、
ユーザの実行ファイルはアクティブなプロセス・ターゲットにもなります。
プロセス・ターゲットがアクティブな間は、
メモリ・アドレスを要求するすべてのGDBコマンドは、
プロセス・ターゲットを参照します。
アクティブなコア・ファイル・ターゲットや
実行ファイル・ターゲットの中のアドレスは、
プロセス・ターゲットがアクティブな間は、 隠された状態になります。

新しいコア・ファイル・ターゲットや実行ファイル・ターゲットを選択するには、
`core-file'コマンドや`exec-file'コマンドを使用します （*note Commands
to specify files: Files.）。
既に実行中のプロセスをターゲットとして指定するには、
`attach'コマンドを使用します （*note Debugging an already-running
process: Attach.）。


File: gdb-ja.info,  Node: Target Commands,  Next: Byte Order,  Prev: Active Targets,  Up: Targets

13.2 ターゲットを管理するコマンド
=================================

`target TYPE PARAMETERS'
     GDBのホスト環境をターゲット・マシン
     またはターゲット・プロセスに接続します。 ターゲットとは、
     典型的には、 デバッグ機能と通信するためのプロトコルを指します。
     引数TYPEによって、
     ターゲット・マシンの種類またはプロトコルを指定します。

     PARAMETERSはターゲット・プロトコルによって解釈されるものですが、
     典型的には、 接続すべきデバイス名やホスト名、 プロセス番号、
     ボーレートなどが含まれます。

     `target'コマンドを実行した後に<RET>キーを押しても、
     `target'コマンドは再実行されません。

`help target'
     利用可能なすべてのターゲットの名前を表示します。
     現在選択されているターゲットを表示させるには、 `info
     target'コマンドまたは`info files'コマンドを使用します （*note
     Commands to specify files: Files.）。

`help target NAME'
     ある特定のターゲットに関する説明を表示します。
     選択時に必要となるパラメータも表示されます。

`set gnutarget ARGS'
     GDBは、
     自分で持っているライブラリBFDを使用してユーザ・ファイルを読み込みます。
     GDBは、 "実行ファイル"、 "コア・ファイル"、
     ".oファイル"のどれを自分が読み込んでいるのかを知っています。
     しかし、 `set gnutarget'コマンドを使用して、
     ファイルのフォーマットを指定することもできます。
     ほとんどの`target'コマンドとは異なり、
     `gnutarget'における`target'は、 マシンではなくプログラムです。

     _注意:_ `set gnutarget'でファイル・フォーマットを指定するには、
     実際のBFD名を知っている必要があります。

     *Note Commands to specify files: Files。

`show gnutarget'
     `gnutarget'がどのようなファイル・フォーマットを読むよう設定されているかを表示させるには、
     `show gnutarget'コマンドを使用します。
     `gnutarget'を設定していない場合、
     個々のファイルのフォーマットをGDBが自動的に決定します。 この場合、
     `show gnutarget'を実行すると `The current BDF target is "auto"'
     と表示されます。

   以下に、 一般的なターゲットをいくつか示します （GDBの構成によって、
利用可能であったり利用不可であったりします）。

`target exec PROGRAM'
     実行ファイルです。 `target exec PROGRAM'は`exec-file
     PROGRAM'と同じです。

`target core FILENAME'
     コア・ダンプ・ファイルです。 `target core FILENAME'は`core-file
     FILENAME'と同じです。

`target remote DEV'
     GDB固有のプロトコルによる、 リモートのシリアル・ターゲットです。
     引数DEVによって、 接続を確立するために使用するシリアル装置
     （例えば、 `/dev/ttya'） を指定します。 *Note Remote debugging:
     Remote。 `target remote'は、
     `load'コマンドもサポートするようになりました。 これは、
     スタブをターゲット・システム上に持っていく方法が別にあり、 かつ、
     ダウンロードが実行されたときに破壊されないようなメモリ域にそれを置くことができる場合にのみ役に立ちます。

`target sim'
     CPUシミュレータです。 *Note Simulated CPU Target: Simulator。

   以下のターゲットはすべて、 特定のCPUに固有のものであり、
特定の構成においてのみ利用可能です。

`target abug DEV'
     M68K用のABug ROMモニタです。

`target adapt DEV'
     A29K用のAdaptモニタです。

`target amd-eb DEV SPEED PROG'
     シリアル回線により接続されている、 リモートのPCに組み込まれたAMD
     EB29Kボードです。 `target remote'の場合と同様、
     DEVはシリアル装置です。
     SPEEDによって回線速度を指定することができます。 PROGは、
     デバッグ対象となるプログラムをPC上のDOSから見た場合の名前です。
     *Note The EBMON protocol for AMD29K: EB29K Remote。

`target array DEV'
     Array Tech LSI33K RAIDコントローラ・ボードです。

`target bug DEV'
     MVME187（m88k）ボード上で動作するBUGモニタです。

`target cpu32bug DEV'
     CPU32（M68K）ボード上で動作するCPU32BUGモニタです。

`target dbug DEV'
     Motorola ColdFire用のdBUG ROMモニタです。

`target ddb DEV'
     Mips Vr4300用のNEC DDBモニタです。

`target dink32 DEV'
     PowerPC用のDINK32 ROMモニタです。

`target e7000 DEV'
     日立H8、 SH用のE7000エミュレータです。

`target es1800 DEV'
     M68K用のES-1800エミュレータです。

`target est DEV'
     CPU32（M68K）ボード上で動作するEST-300 ICEモニタです。

`target hms DEV'
     ユーザのホストにシリアル回線で接続された日立のSH、 H8/300、
     H8/500ボードです。 特別なコマンドである`device'と`speed'によって、
     使用されるシリアル回線と通信速度を制御します。 *Note GDB and
     Hitachi Microprocessors: Hitachi Remote。

`target lsi DEV'
     Mips用のLSI ROMモニタです。

`target m32r DEV'
     三菱M32R/D ROMモニタです。

`target mips DEV'
     Mips用のIDT/SIM ROMモニタです。

`target mon960 DEV'
     Intel i960用のMON960モニタです。

`target nindy DEVICENAME'
     Nindy Monitorにより制御されるIntel 960ボードです。
     DEVICENAMEは、接続に使用するシリアル装置の名前です。
     例えば`/dev/ttya'です。 *Note GDB with a remote i960 (Nindy):
     i960-Nindy Remote。

`target nrom DEV'
     NetROM ROMエミュレータです。 このターゲットは、
     ダウンロードのみサポートしています。

`target op50n DEV'
     OKI HPPAボード上で動作するOP50Nモニタです。

`target pmon DEV'
     Mips用のPMON ROMモニタです。

`target ppcbug DEV'

`target ppcbug1 DEV'
     PowerPC用のPPCBUG ROMモニタです。

`target r3900 DEV'
     東芝R3900 Mips用のDensan DVE-R3900 ROMモニタです。

`target rdi DEV'
     RDIライブラリ・インターフェイスを経由したARM Angelモニタです。

`target rdp DEV'
     ARM Demonモニタです。

`target rom68k DEV'
     M68K IDPボード上で動作するROM 68Kモニタです。

`target rombug DEV'
     OS/9000用のROMBUG ROMモニタです。

`target sds DEV'
     （MotorolaのADSなどの） PowerPCボード上で動作するSDSモニタです。

`target sparclite DEV'
     ロードするためだけの目的で使用される、
     富士通のsparcliteボードです。 プログラムをデバッグするためには、
     さらに別のコマンドを使用しなければなりません。 一例を挙げると、
     GDBの標準的なリモート・プロトコルを使用する target remote DEVです。

`target sh3 DEV'

`target sh3e DEV'
     日立SH-3、 SH-3Eターゲット・システムです。

`target st2000 DEV SPEED'
     Tandem STDBUGプロトコルを実行しているTandem ST2000電話交換機です。
     DEVは、 ST2000のシリアル回線に接続されている装置の名前です。
     SPEEDは通信回線の速度です。
     GDBがST2000にTCPまたはTelnetで接続するよう構成されている場合、
     引数は使用されません。 *Note GDB with a Tandem ST2000: ST2000
     Remote。

`target udi KEYWORD'
     AMD UDIプロトコルを使用するRemote AMD29Kターゲットです。
     引数KEYWORDが、 使用する29Kボードまたはシミュレータを指定します。
     *Note The UDI protocol for AMD29K: UDI29K Remote。

`target vxworks MACHINENAME'
     TCP/IPで接続されたVxWorksシステムです。 引数MACHINENAMEは、
     ターゲット・システムのマシン名またはIPアドレスです。 *Note GDB and
     VxWorks: VxWorks Remote。

`target w89k DEV'
     Winbond HPPAボード上で動作するW89Kモニタです。


   GDBの構成によって、 利用可能なターゲットも異なるものになります。
構成次第で、 ターゲットの数は多くなったり少なくなったりします。

   多くのリモート・ターゲットでは、 接続に成功すると、
実行プログラムのコードをダウンロードすることが必要となります。

`load FILENAME'
     構成によってGDBに組み込まれたリモート・デバッグ機能によっては、
     `load'コマンドが使用可能になります。 これが利用可能な場合、
     実行ファイルFILENAMEが （例えば、
     ダウンロードやダイナミック・リンクによって）
     リモート・システム上でデバッグできるようになることを意味します。
     また、 `load'コマンドは`add-symbol-file'コマンドと同様、
     ファイルFILENAMEのシンボル・テーブルをGDB内に記録します。

     GDBが`load'コマンドを提供していない場合、 それを実行しようとすると
     「`You can't do that when your target is ...'」
     というエラー・メッセージが表示されます。

     実行ファイルの中で指定されたアドレスに、 ファイルはロードされます。
     オブジェクト・ファイルのフォーマットによっては、
     プログラムをリンクするときに、
     ファイルをロードするアドレスを指定できるものもあります。
     これ以外のフォーマット （例えば、 a.out） では、
     オブジェクト・ファイルのフォーマットによって固定的にアドレスが指定されます。

     VxWorksで`load'コマンドを実行すると、
     FILENAMEで指定される実行ファイルがカレントなターゲット・システム上で動的にリンクされ、
     シンボルがGDBに追加されます。

     Intel 960ボードのNindyインターフェイスでは、
     `load'コマンドはFILENAMEで指定されるファイルを960側にダウンロードし、
     そのシンボルをGDBに追加します。

     日立のSH、 H8/300、 H8/500ボード （*note GDB and Hitachi
     Microprocessors: Hitachi Remote.）
     に対するリモート・デバッグを選択すると、
     `load'コマンドはユーザ・プログラムを日立ボードにダウンロードし、
     （`file'コマンドと同様）
     ユーザのホスト・マシン上のGDBのカレントなターゲット実行ファイルとしてオープンします。

     `load'コマンドを実行した後に<RET>キーを押しても、
     `load'コマンドは繰り返し実行されません。


File: gdb-ja.info,  Node: Byte Order,  Next: Remote,  Prev: Target Commands,  Up: Targets

13.3 ターゲットのバイト・オーダの選択
=====================================

MIPS、 PowerPC、 Hitachi SHなどのプロセッサは、 ビッグ・エンディアン、
リトル・エンディアンのどちらのバイト・オーダでも実行することができます。
通常は、 実行ファイルまたはシンボルの中に、
エンディアン種別を指定するビットがあるので、
どちらを使用するかを気にする必要はありません。 しかし、
GDBの認識しているプロセッサのエンディアン種別を手作業で調整することができれば、
便利なこともあるでしょう。

`set endian big'
     GDBに対して、
     ターゲットはビッグ・エンディアンであると想定するよう指示します。

`set endian little'
     GDBに対して、
     ターゲットはリトル・エンディアンであると想定するよう指示します。

`set endian auto'
     GDBに対して、
     実行ファイルに関連付けされているバイト・オーダを使用するよう指示します。

`show endian'
     GDBが認識している、
     ターゲットの現在のバイト・オーダ種別を表示します。


   これらのコマンドは、
ホスト上でのシンボリック・データの解釈を調整するだけであり、
ターゲット・システムに対しては全く何の影響も持たないということに注意してください。


File: gdb-ja.info,  Node: Remote,  Prev: Byte Order,  Up: Targets

13.4 リモート・デバッグ
=======================

通常の方法でGDBを実行させることのできないマシン上で実行中のプログラムをデバッグするには、
リモート・デバッグ機能を使うのが便利です。 例えば、
オペレーティング・システムのカーネルのデバッグや、
フル機能を持つデバッガを実行するのに十分な機能を持つ汎用的なオペレーティング・システムを持たない小規模なシステムでのデバッグでは、
ユーザはリモート・デバッグ機能を使うことになるかもしれません。

   GDBは、 その構成によっては、
特別なシリアル・インターフェイスやTCP/IPインターフェイスを持ち、
これを特定のデバッグ・ターゲット用に使用することができます。 さらに、
GDBには汎用的なシリアル・プロトコルが組み込まれており
（GDB固有のもので、
特定のターゲット・システムに固有なものではありません）、
リモート・スタブを作成すれば、 これを使用することができます。
リモート・スタブとは、
GDBと通信するためにリモート・システム上で動作するコードです。

   GDBの構成によっては、
他のリモート・ターゲットが利用可能な場合もあります。
利用可能なリモート・ターゲットを一覧表示させるには、 `help
target'コマンドを使用します。

* Menu:


* Remote Serial::               GDBリモート・シリアル・プロトコル

* i960-Nindy Remote::		GDBとリモートi960（Nindy）

* UDI29K Remote::               AMD29K用のUDIプロトコル
* EB29K Remote::		AMD29K用のEBMONプロトコル

* VxWorks Remote::		GDBとVxWorks

* ST2000 Remote::               GDBとTandem ST2000

* Hitachi Remote::              GDBと日立のマイクロ・プロセッサ

* MIPS Remote::			GDBとMIPSボード

* Sparclet Remote::             GDBとSparcletボード

* Simulator::                   シミュレートされたCPUターゲット


File: gdb-ja.info,  Node: Remote Serial,  Next: i960-Nindy Remote,  Up: Remote

13.4.1 GDBリモート・シリアル・プロトコル
----------------------------------------

他のマシン上で実行中のプログラムをデバッグするには
（"ターゲット"・マシンをデバッグするには）、
そのプログラムを単独で実行するために通常必要となる事前条件をすべて整える必要があります。
例えば、 Cのプログラムの場合、

  1.
     Cの実行環境をセットアップするためのスタートアップ・ルーチンが必要です。
     これは通常`crt0'のような名前を持っています。
     スタートアップ・ルーチンは、
     ハードウェアの供給元から提供されることもありますし、
     ユーザが自分で書かなければならないこともあります。

  2. ユーザ・プログラムからのサブルーチン呼び出しをサポートするために、
     入出力の管理などを行うCのサブルーチン・ライブラリが必要になるかもしれません。

  3. ユーザ・プログラムを他のマシンに持っていく手段、
     例えばダウンロード・プログラムが必要です。
     これはハードウェアの供給元から提供されることが多いのですが、
     ハードウェアのドキュメントをもとにユーザが自分で作成しなければならないこともあります。

次に、ユーザ・プログラムがシリアル・ポートを使って、GDBを実行中のマシン
（"ホスト"・マシン） と通信できるように準備します。
一般的には、以下のような形になります。

_ホスト上では：_
     GDBは既にこのプロトコルの使い方を理解しています。
     他の設定がすべて終了した後、 単に`target
     remote'コマンドを使用するだけです （*note Specifying a Debugging
     Target: Targets.）。

_ターゲット上では：_
     ユーザ・プログラムに、
     GDBリモート・シリアル・プロトコルを実装した特別なサブルーチンを
     いくつかリンクする必要があります。
     これらのサブルーチンを含むファイルは、
     "デバッグ・スタブ"と呼ばれます。

     特定のリモート・ターゲットでは、
     ユーザ・プログラムにスタブをリンクする代わりに、
     `gdbserver'という補助プログラムを使うこともできます。
     詳細については、 *Note Using the `gdbserver' program: Server。

   デバッグ・スタブはリモート・マシンのアーキテクチャに固有のものです。
例えば、
SPARCボード上のプログラムをデバッグするには`sparc-stub.c'を使います。

   以下に実際に使えるスタブを列挙します。 これらは、
GDBとともに配布されています。

`i386-stub.c'
     Intel 386アーキテクチャ、 およびその互換アーキテクチャ用です。

`m68k-stub.c'
     Motorola 680x0アーキテクチャ用です。

`sh-stub.c'
     日立SHアーキテクチャ用です。

`sparc-stub.c'
     SPARCアーキテクチャ用です。

`sparcl-stub.c'
     富士通SPARCLITEアーキテクチャ用です。


   GDBとともに配布されるREADMEファイルには、
新しく追加された他のスタブのことが記されているかもしれません。

* Menu:

* Stub Contents::       スタブの提供する機能
* Bootstrapping::       スタブに対する必須作業
* Debug Session::       ここまでのまとめ
* Protocol::            通信プロトコルの概略

* Server::		gdbserverプログラムの使用

* NetWare::		gdbserve.nlmプログラムの使用


File: gdb-ja.info,  Node: Stub Contents,  Next: Bootstrapping,  Up: Remote Serial

13.4.1.1 スタブの提供する機能
.............................

各アーキテクチャ用のデバッグ・スタブは、 3つのサブルーチンを提供します。

`set_debug_traps'
     このルーチンは、
     ユーザ・プログラムが停止したときに`handle_exception'が実行されるよう設定します。
     ユーザ・プログラムは、
     その先頭付近でこのサブルーチンを明示的に呼び出さなければなりません。

`handle_exception'
     これが中心的な仕事をする部分ですが、
     ユーザ・プログラムはこれを明示的には呼び出しません。
     セットアップ・コードによって、 トラップが発生したときに
     `handle_exception'が実行されるよう設定されます。

     ユーザ・プログラムが実行中に （例えば、ブレイクポイントで）
     停止すると、 `handle_exception'が制御権を獲得し、
     ホスト・マシン上のGDBとの通信を行います。 これが、
     通信プロトコルが実装されている部分です。 `handle_exception'は、
     ターゲット・マシン上でGDBの代理として機能します。 それはまず、
     ユーザ・プログラムの状態に関する情報を要約して送ることから始めます。
     次に、 GDBが必要とする情報を入手して転送する処理を継続します。
     これは、
     ユーザ・プログラムの実行を再開させるようなGDBコマンドが実行されるまで続きます。
     そのようなコマンドが実行されると、 `handle_exception'は、
     制御をターゲット・マシン上のユーザ・コードに戻します。

`breakpoint'
     ユーザ・プログラムにブレイクポイントを持たせるには、
     この補助的なサブルーチンを使います。 特定の状況においては、
     これがGDBが制御を獲得する唯一の方法です。 例えば、
     ユーザのターゲット・マシンに割り込みを発生させるボタンのようなものがあれば、
     このサブルーチンを呼び出す必要はありません。
     割り込みボタンを押すことで、 制御は`handle_exception'に、
     つまり事実上GDBに渡されます。 マシンによっては、
     シリアル・ポートから文字を受け取るだけでトラップが発生することもあります。
     このような場合には、
     ユーザ・プログラム自身から`breakpoint'を呼び出す必要はなく、
     ホストのGDBセッションから`target
     remote'を実行するだけで制御を得ることができます。

     これらのどのケースにも該当しない場合、 あるいは、
     デバッグ・セッションの開始箇所としてあらかじめ決めてあるところでユーザ・プログラムが停止することを
     単に確実にしたいのであれば、 `breakpoint'を呼び出してください。


File: gdb-ja.info,  Node: Bootstrapping,  Next: Debug Session,  Prev: Stub Contents,  Up: Remote Serial

13.4.1.2 スタブに対する必須作業
...............................

GDBとともに配布されるデバッグ用スタブは、
特定のチップのアーキテクチャ用にセットアップされたものですが、
デバッグのターゲット・マシンに関してそれ以外の情報は持っていません。

   まず最初に、
どのようにしてシリアル・ポートと通信するかをスタブに教えてやる必要があります。

`int getDebugChar()'
     シリアル・ポートから単一文字を読み込むサブルーチンとしてこれを書きます。
     これは、 ターゲット・システム上の `getchar'と同一かもしれません。
     これら2つを区別したい場合を考慮して、 異なる名前が使われています。

`void putDebugChar(int)'
     シリアル・ポートに単一文字を書き込むサブルーチンとしてこれを書きます。
     これは、 ターゲット・システム上の `putchar'と同一かもしれません。
     これら2つを区別したい場合を考慮して、 異なる名前が使われています。

   実行中のユーザ・プログラムをGDBが停止できるようにしたいのであれば、
割り込み駆動型のシリアル・ドライバを使用して、 `^C' （control-C文字、
すなわち`\003'） を受信したときに停止するよう設定する必要があります。
GDBはこの文字を使って、
リモート・システムに対して停止するよう通知します。

デバッグ・ターゲットが適切なステータス情報をGDBに対して返せるようにするためには、
おそらく標準のスタブを変更する必要があるでしょう。 最も美しくなく、
しかし最も手っ取り早くこれを実現する方法は、
ブレイクポイント命令を実行することです （この方法が「美しくない」のは、
GDBが`SIGINT'ではなく`SIGTRAP'を報告してくる点にあります）。

   ユーザが提供する必要のあるルーチンには、
ほかに以下のようなものがあります。

`void exceptionHandler (int EXCEPTION_NUMBER, void *EXCEPTION_ADDRESS)'
     例外処理テーブルにEXCEPTION_ADDRESSを組み込むよう、
     この関数を書きます。 ユーザがこれを提供しなければならないのは、
     スタブにはターゲット・システム上の例外処理テーブルがどのようなものになるかを知る手段がないからです
     （例えば、 プロセッサのテーブルはROM上にあり、
     その中のエントリがRAM上のテーブルを指す、
     という形になっているかもしれません）。 EXCEPTION_NUMBER
     は例外番号で、 これは変更される必要があります。 例外番号の意味は、
     アーキテクチャに依存します （例えば、 0による除算、
     境界を無視したメモリ・アクセス等は、
     異なる番号によって表わされるかもしれません）。
     この例外が発生したとき、
     制御は直接EXCEPTION_ADDRESSに渡されなければならず、 また、
     プロセッサの状態 （スタック、レジスタなど）
     はプロセッサ例外が発生したときの状態と同じでなければなりません。
     したがって、
     EXCEPTION_ADDRESSに到達するのにジャンプ命令を使用したいのであれば、
     サブルーチン・ジャンプではなく、
     ただのジャンプ命令を使わなければなりません。

     386では、
     ハンドラが実行されているときに割り込みがマスクされるよう、
     EXCEPTION_ADDRESSは割り込みゲートとして組み込まれる必要があります。
     そのゲートは特権レベル0 （最も高いレベル） でなければなりません。
     SPARC用のスタブや68k用のスタブは、
     `exceptionHandler'の助けを借りなくても自分で割り込みをマスクすることができます。

`void flush_i_cache()'
     （sparc、 sparcliteのみ）
     ターゲット・マシンに命令キャッシュがある場合、
     それをフラッシュするようこのサブルーチンを書きます。
     命令キャッシュがない場合には、
     このサブルーチンは何もしないものになるかもしれません。

     命令キャッシュを持つターゲット・マシン上のGDBは、
     ユーザ・プログラムが安定した状態にあることが
     この関数によって保証されることを必要とします。

また、次のライブラリ・ルーチンが使用可能であることを確かめなければなりません。

`void *memset(void *, int, int)'
     あるメモリ領域に既知の値を設定する標準ライブラリ関数`memset'です。
     フリーの`libc.a'を持っていれば、 そこに`memset'があります。
     フリーの`libc.a'がなければ、
     `memset'をハードウェアの供給元から入手するか、
     自分で作成する必要があります。

   GNU Cコンパイラを使っていないのであれば、
他の標準ライブラリ・サブルーチンも必要になるかもしれません。 これは、
スタブによっても異なりますが、 一般的にスタブは、
`gcc'がインライン・コードとして生成する共通ライブラリ・サブルーチンを使用する可能性があります。


File: gdb-ja.info,  Node: Debug Session,  Next: Protocol,  Prev: Bootstrapping,  Up: Remote Serial

13.4.1.3 ここまでのまとめ
.........................

要約すると、 ユーザ・プログラムをデバッグする準備が整った後、
以下の手順に従わなければなりません。

  1. 下位レベルのサポート・ルーチンがあることを確認します （*note What
     you must do for the stub: Bootstrapping.）。
          `getDebugChar', `putDebugChar',
          `flush_i_cache', `memset', `exceptionHandler'.

  2. ユーザ・プログラムの先頭付近に以下の行を挿入します。

          set_debug_traps();
          breakpoint();

  3. 680x0のスタブに限り、
     `exceptionHook'という変数を提供する必要があります。 通常は、
     以下のように使います。

          void (*exceptionHook)() = 0;

     しかし、 `set_debug_traps'が呼び出される前に、
     ユーザ・プログラム内のある関数を指すようこの変数を設定すると、
     トラップ （例えば、 バス・エラー）
     で停止した後にGDBが処理を継続実行するときに、
     その関数が呼び出されます。 `exceptionHook'によって指される関数は、
     1つの引数付きで呼び出されます。 それは、 `int'型の例外番号です。

  4. ユーザ・プログラム、
     ターゲット・アーキテクチャ用のGDBデバッグ・スタブ、
     サポート・サブルーチンをコンパイルしリンクします。

  5.
     ターゲット・マシンとGDBホストとの間がシリアル接続されていることを確認します。
     また、 ホスト上のシリアル・ポートの名前を調べます。

  6. ターゲット・マシンにユーザ・プログラムをダウンロードし （あるいは、
     製造元の提供する手段によってターゲット・マシンにユーザ・プログラムを持っていき）、
     起動します。

  7. リモート・デバッグを開始するには、 ホスト・マシン上でGDBを実行し、
     リモート・マシン上で実行中のプログラムを実行ファイルとして指定します。
     これにより、
     ユーザ・プログラムのシンボルとテキスト域の内容を見つける方法がGDBに通知されます。

     次に`target remote'コマンドを使って通信を確立します。 引数には、
     シリアル回線に接続された装置名または
     （通常はターゲットと接続されたシリアル回線を持つ端末サーバの）
     TCPポートを指定することで、
     ターゲット・マシンとの通信方法を指定します。 例えば、
     `/dev/ttyb'という名前の装置に接続されているシリアル回線を使うには、

          target remote /dev/ttyb

     とします。

     TCP接続を使うには、 `HOST:PORT'という形式の引数を使用します。
     例えば、
     `manyfarms'という名前の端末サーバのポート2828に接続するには、

          target remote manyfarms:2828

     とします。

ここまでくると、 データの値の調査、 変更、
リモート・プログラムのステップ実行、
継続実行に通常使用するすべてのコマンドを使用することができます。

   リモート・プログラムの実行を再開し、 デバッグするのをやめるには、
`detach'コマンドを使います。

   GDBがリモート・プログラムを待っているときにはいつでも、 割り込み文字
（多くの場合 <C-C>） を入力すると、
GDBはそのプログラムを停止しようとします。
これは成功することも失敗することもありますが、 その成否は、
リモート・システムのハードウェアやシリアル・ドライバにも依存します。
割り込み文字を再度入力すると、 GDBは以下のプロンプトを表示します。

     Interrupted while waiting for the program.
     Give up (and stop debugging it)?  (y or n)

   ここで`y'を入力すると、
GDBはリモート・デバッグ・セッションを破棄します
（後になって再実行したくなった場合には、 接続するために`target
remote'を再度使用します）。 `n'を入力すると、
GDBは再び待ち状態になります。


File: gdb-ja.info,  Node: Protocol,  Next: Server,  Prev: Debug Session,  Up: Remote Serial

13.4.1.4 通信プロトコル
.......................

GDBとともに提供されるスタブ・ファイルは、
ターゲット側の通信プロトコルを実装します。
そしてGDB側の通信プロトコルは、
GDBのソース・ファイル`remote.c'に実装されています。 通常は、
これらのサブルーチンに通信処理を任せて、 詳細を無視することができます
（独自のスタブ・ファイルを作成するときでも、 詳細については無視して、
既存のスタブ・ファイルをもとにして作成を始めることができます。
`sparc-stub.c'が最もよく整理されており、
したがって最も読みやすくなっています）。

   しかし、 場合によっては、
プロトコルについて何かを知る必要が出てくることもあるでしょう。 例えば、
ターゲット・マシンにシリアル・ポートが1つしかなく、
GDBに対して送られてきたパケットを検出したときに、
ユーザ・プログラムが何か特別なことをするようにしたい場合です。

   （単一文字による確認メッセージを除く）
すべてのGDBコマンドとそれに対する応答は、
チェックサムを含むパケットとして送信されます。 パケットは、
文字`$'で始まり、 文字`#'に2桁のチェックサム値が続いて終わります。

     $PACKET INFO#CHECKSUM

ここで、 CHECKSUMはPACKET
INFOのすべての文字の値を合計したものを256で割った余りとして計算されます。

   ホスト・マシンまたはターゲット・マシンがパケットを受信したとき、
最初に期待される応答は確認メッセージです。 これは単一文字で、
（パッケージが正しく受信されたことを示す） `+'または （再送要求を示す）
`-'です。

   ホスト （GDB） がコマンドを送信し、 ターゲット
（ユーザ・プログラムに組み込まれたデバッグ・スタブ）
が応答としてデータを送信します。
ターゲットは、ユーザ・プログラムが停止したときにも、
データを送信します。

   コマンド・パケットは最初の文字で区別されます。
最初の文字がコマンドの種類を表わします。

   以下に、 現在サポートされているコマンドをいくつか列挙します
（コマンドの完全なリストについては`gdb/remote.c'を参照してください）。

`g'
     CPUレジスタの値を要求します。

`G'
     CPUレジスタの値を設定します。

`mADDR,COUNT'
     ADDRで示される位置からCOUNTで示されるバイト数を読み込みます。

`MADDR,COUNT:...'
     ADDRで示される位置からCOUNTで示されるバイト数を書き込みます。

`c'
`cADDR'
     カレントなアドレス （ADDRが指定されているのであれば、
     それによって指定されるアドレスから） 実行を再開します。

`s'
`sADDR'
     プログラム・カウンタの指すカレントな箇所から
     （ADDRが指定されているのであれば、
     それによって指定されるアドレスから）
     ターゲット・プログラムを1命令だけステップ実行します。

`k'
     ターゲット・プログラムを終了させます。

`?'
     最後に受信したシグナルを報告します。
     GDBのシグナル処理コマンドを利用できるように、
     デバッグ・スタブの中のある関数が、
     CPUトラップを対応するPOSIXシグナル値として報告してきます。

`T'
     リモートのスタブに対して、
     GDBがシングル・ステップ処理や条件付きブレイクポイントに関する迅速な決定を下すのに必要となる
     レジスタの情報だけを送信するようにさせます。 これによって、
     ステップ実行中の1命令ごとにすべてのレジスタの情報を入手する必要がなくなります。

     現在のGDBは、
     レジスタへのライト・スルー・キャッシュを実装していて、
     ターゲットが実行された場合のみ、 レジスタを再度読み込みます。

   シリアル接続に問題がある場合には、 `set
remotedebug'コマンドを使うことができます。 これによりGDBは、
シリアル回線経由でリモート・マシンとの間で送受信したすべてのパケットを報告するようになります。
パケット・デバッグ用の情報はGDBの標準出力ストリームに表示されます。
`set remotedebug off'によってこの設定が解除され、 `show
remotedebug'によって現在の設定が表示されます。

