-*- coding: utf-8 -*-
START-INFO-DIR-ENTRY
* m4(ja): (m4-ja).		A powerful macro processor.
END-INFO-DIR-ENTRY

   This file documents the GNU `m4' utility.

   Copyright (C) 1989, 1990, 1991, 1992, 1993, 1994 Free Software
Foundation, Inc.

   Permission is granted to make and distribute verbatim copies of this
manual provided the copyright notice and this permission notice are
preserved on all copies.

   Permission is granted to copy and distribute modified versions of
this manual under the conditions for verbatim copying, provided that
the entire resulting derived work is distributed under the terms of a
permission notice identical to this one.

   Permission is granted to copy and distribute translations of this
manual into another language, under the above conditions for modified
versions, except that this permission notice may be stated in a
translation approved by the Foundation.


File: m4-ja.info,  Node: Top,  Next: Preliminaries,  Prev: (dir),  Up: (dir)

GNU `m4'
********

GNU `m4'はUNIXに古くからあるマクロプロセッサの実装です。
SVR4版とほぼ互換性がありますが、いくつかの機能が拡張がされています
(たとえば、9個を超える位置パラメータをマクロで扱うことができます)。
`m4'にはマクロの展開機能に加え、ファイルのインクルード、
シェルコマンドの実行、計算、その他のための関数も組み込まれています。
Autoconfで`configure'スクリプトを生成するにはGNU `m4'が
必要ですが、そのスクリプトを実行するときには必要ありません。

   Rene' SeindalがGNU `m4'を最初に書きました。 続いて、Franc,ois
Pinardやその他のインターネット上のボランティアたちが
変更を行ないました。これらの人たちの氏名および電子メールアドレスは、
GNU `m4'の配布用アーカイブファイルに含まれている`THANKS'ファイルに
すべて記載されています。

   本GNU `m4'はリリース1.4です。 現在すでに安定していることを考えると、
今後のリリースではバグの修正や速度の向上、ドキュメントの改善だけを
するべきでしょう。しかし...

   `m4'の実用性をさらに増す思われる、試験的なある機能(*note
Changeword::) を使うと、`m4'において何が"単語"（word）として
認識されるかを決めている規則を変更できるようになります。
この機能を試してみたい人は、
     ./configure --enable-changeword
   としてコンパイル時にこの機能が組み込まれるようにしてください。
現在の実装では`m4'の動作がかなり遅くなってしまうので、
これをそのまま採用するには抵抗があります。
したがって将来この機能が削除されるということも考えられるので、
まだこの機能に依存した使い方はしないでください。

* Menu:

* Preliminaries::               序論
* Syntax::                      字句・構文解析の規則

* Macros::                      マクロを呼び出す方法
* Definitions::                 新たにマクロを定義する方法
* Conditionals::                条件分岐、ループ、再帰

* Debugging::                   マクロや入力をデバッグする方法

* Input Control::               入力制御
* File Inclusion::              ファイルのインクルード
* Diversions::                  出力の切替え（divert）と逆切替え（undivert）

* Text handling::               テキスト操作用の組み込みマクロ
* Arithmetic::                  計算用の組み込みマクロ
* UNIX commands::               UNIXコマンド実行用の組み込みマクロ
* Miscellaneous::               その他の組み込みマクロ
* Frozen files::                凍結状態（frozen state）の高速ロード

* Compatibility::               他の版のm4との互換性
* Concept index::               さまざまな概念の索引
* Macro index::                 m4マクロすべての索引

 --- The Detailed Node Listing ---

序論

* Intro::                       `m4'序説
* History::                     `m4'の由来

* Invoking m4::                 `m4'の起動(オプション一覧)
* Bugs::                        問題やバグへの対処方法
* Manual::                      このマニュアルの読み方

字句・構文解析の規則

* Names::                       入力トークン: マクロ名
* Quoted strings::              入力トークン: クォートされた文字列
* Other tokens::                入力トークン: その他
* Comments::                    m4への入力中のコメント

マクロを呼び出す方法

* Invocation::                  マクロの呼び出し
* Inhibiting Invocation::       マクロの呼び出しを抑制する
* Macro Arguments::             マクロの引数
* Quoting Arguments::           マクロの引数をクォートする
* Macro expansion::             マクロの展開

新たにマクロを定義する方法

* Define::                      新しいマクロを定義する
* Arguments::                   マクロの引数
* Pseudo Arguments::            マクロの疑似引数
* Undefine::                    マクロの削除
* Defn::                        マクロ名の変更
* Pushdef::                     マクロの一時的な再定義

* Indir::                       マクロの間接的な呼び出し
* Builtin::                     組み込みマクロの間接的な呼び出し

条件分岐、ループ、再帰

* Ifdef::                       マクロが定義済みかを判定する
* Ifelse::                      If-else 構文と多重分岐
* Loops::                       m4におけるループと再帰

マクロや入力をデバッグする方法

* Dumpdef::                     マクロの定義を表示する
* Trace::                       マクロの呼び出しをトレースする
* Debug Levels::                デバッグ出力の制御
* Debug Output::                デバッグ出力の保存

入力制御

* Dnl::                         空白（whitespace）を入力から削除する
* Changequote::                 引用符（quote characters）の変更
* Changecom::                   コメントデリミタ（comment delimiters）の変更
* Changeword::                  単語（word）の字句構造を変更する
* M4wrap::                      入力の一部を入力が終るまで保存（save）しておく

ファイルのインクルード

* Include::                     名前を指定してファイルをインクルードする
* Search Path::                 インクルードするファイルのサーチ

出力の切替え（divert）と逆切替え（undivert）

* Divert::                      出力を切替える（divert）
* Undivert::                    出力を逆切替えする（undivert）
* Divnum::                      出力切替え先番号（diversion number）
* Cleardiv::                    出力切替え先のテキストを破棄する

テキスト操作用の組み込みマクロ

* Len::                         文字列の長さを計算する
* Index::                       部分文字列で検索する
* Regexp::                      正規表現で検索する
* Substr::                      部分文字列を抽出する
* Translit::                    文字の置換
* Patsubst::                    正規表現でテキストの置換をする
* Format::                      文字列を(printf風に)フォーマットする

計算用の組み込みマクロ

* Incr::                        インクリメント演算子とデクリメント演算子
* Eval::                        整数式を計算する

UNIXコマンド実行用の組み込みマクロ

* Syscmd::                      単一のコマンドを実行する
* Esyscmd::                     コマンドの出力を読む
* Sysval::                      終了コード
* Maketemp::                    一時ファイル用の名前を生成する

その他の組み込みマクロ

* Errprint::                    エラーメッセージを表示する
* M4exit::                      m4を終了させる

他の版の`m4'との互換性

* Extensions::                  GNU m4で拡張された機能
* Incompatibilities::           System V m4にあってGNU m4にない機能
* Other Incompat::              その他の非互換性


File: m4-ja.info,  Node: Preliminaries,  Next: Syntax,  Prev: Top,  Up: Top

1 序論
******

この章ではGNU `m4'とは何か、その由来、このマニュアルの読み方と
使い方、`m4'を起動する方法、バグを報告する方法などを説明します。
マニュアルの続きを読むにあたっての助言をもってこの章は終ります。

   ここから後の章では`m4'言語の全機能を詳しく説明します。

* Menu:

* Intro::                       `m4'序説
* History::                     `m4'の由来
* Invoking m4::                 `m4'の起動(オプション一覧)
* Bugs::                        問題やバグへの対処方法
* Manual::                      このマニュアルの読み方


File: m4-ja.info,  Node: Intro,  Next: History,  Prev: Preliminaries,  Up: Preliminaries

1.1 `m4'序説
============

マクロを展開しながら入力を出力へコピーするという意味で、`m4'は
マクロプロセッサだと言えます。マクロには`m4'に最初から組み込まれて
いる組み込み（builtin）マクロと、ユーザが自分で定義するユーザ定義
（user-defined）マクロの2種類があります。マクロは何個でも引数を
取ることができます。`m4'には単なるマクロの展開機能に加え、
ファイルのインクルード、UNIXコマンドの実行、整数演算、さまざまな方法での
テキスト操作、再帰、その他のための関数がそろっています。
`m4'はコンパイラのフロントエンドとして、またマクロプロセッサ
そのものとしても使うことができます。

`m4'マクロプロセッサは、ほとんどすべてのUNIXで利用することができます。
通常その存在に気づいているのは、ほんのわずかな人たちだけです。
しかし実際に気づいた人たちは往々にして熱心なユーザとなります。 GNU
Autoconfで`configure'スクリプトを_生成_するにはGNU `m4'が
必要なため、GNU Autoconfの人気が高まったのがきっかけとなってGNU `m4'を
インストールする人が増えました。もっとも、そういう人が自分で`m4'の
プログラミングをすることは無いでしょう。GNU `m4'はわずかな違いを除けば
System V, Release 3 版とほぼ互換性があります。 詳細は*Note
Compatibility::を参照してください。

   ユーザの中には`m4'中毒になってしまった人たちもいます。
そういう人たちは最初は簡単なことに`m4'を使い、徐々に複雑な`m4'マクロ
の書き方を習得しながら、大きなこと大きなことへと挑戦していくのです。
いちど病みつきになってしまえば、簡単な問題を解くためにさえ洗練された
`m4'アプリケーションを書こうとして、実際の仕事よりも自分の`m4'スクリプト
のデバッグに多くの時間をさくことになるのです。
熱中しやすいプログラマーは`m4'で健康を損なうおそれがあるので注意しましょう。


File: m4-ja.info,  Node: History,  Next: Invoking m4,  Prev: Intro,  Up: Preliminaries

1.2 `m4'の由来
==============

ここに記されている歴史に関する覚え書きはきわめて不完全なものであり、
なんら権威あるものでもありません。事情に通じている方は、どうかこの節を
ふさわしいものにするのを手伝ってください。

   `GPM'は`m4'の重要な祖先です。 C. Stratchey: "A General Purpose Macro
generator", Computer Journal 8,3 (1965), pp. 225 ff を参照してください。
`GPM'は、David Gries classic "Compiler Construction for Digital
Computers"でも簡潔に説明されています。

   `GPM'は_純粋_だったのに対して、
`m4'は実生活にまつわる本物の複雑さを扱うことを意図したものでした。
そのため、たとえばマクロは前もって宣言しなくても認識されるようになり、
改行文字などの空白（whitespace）をスキップするのは簡単になり、多くの
構成要素が借り物ではなく内蔵されるようになりました。

   もともと`m4'はRational FORTRANプリプロセッサすなわち`ratfor'
(`cpp'に相当)のエンジンでした。


File: m4-ja.info,  Node: Invoking m4,  Next: Bugs,  Prev: History,  Up: Preliminaries

1.3 `m4'の起動(オプション一覧)
==============================

`m4'コマンドを起動するときの形式は次のようになります。

     `m4' [OPTION...] [MACRO-DEFINITIONS...] [INPUT-FILE...]

   オプションは、短いオプション名を使うときは`-'で始め、
長いオプション名を使うときは`--'で始めます。 長いオプション名は、
そのオプションだと明確に特定できる先頭部分を書くだけで十分です。
`m4'は次のオプションを受けつけます。

`--version'
     プログラムのバージョン番号を標準出力に出力し、
     INPUT-FILESはいっさい読まずに、ただちに`m4'の実行を終了します。

`--help'
     ヘルプ情報の要約を標準出力へ出力し、
     INPUT-FILESはいっさい読まずに、ただちに`m4'の実行を終了します。

`-G'
`--traditional'
     System V版と比べて、この実装で拡張された機能をすべて抑制します。
     これらの一覧は*Note Compatibility::を参照してください。

`-E'
`--fatal-warnings'
     すべての警告（warning）を致命的なものと見なし、
     最初の警告が発行された時点で`m4'の実行を停止し終了します。

`-dFLAGS'
`--debug=FLAGS'
     デバッグ・レベルをFLAGSに設定します。
     デバッグ・レベルはデバッグ用関数が表示する情報の形式と量の制御に使われます。
     FLAGSの形式と意味についての詳細は*Note Debug
     Levels::を参照してください。

`-lNUM'
`--arglength=NUM'
     マクロをトレースすることによって生じる出力の量を制限します。
     詳細は*Note Debug Levels::を参照してください。

`-oFILE'
`--error-output=FILE'
     デバッグやトレースの出力を名前が指定されたファイルへ
     リダイレクト（redirect）します。
     エラーメッセージは通常どおり標準エラー出力へ出力します。
     詳細は*Note Debug Output::を参照してください。

`-IDIR'
`--include=DIR'
     インクルード指定されたファイルが現在の作業ディレクトリ （current
     working directory）で見つからない場合に、`m4'がDIRを
     探すようにします。詳細は*Note Search Path::を参照してください。

`-e'
`--interactive'
     起動時に`m4'を対話的な状態（interactive）にします。
     これは、すべての出力をバッファリング無しで行ない、
     割り込み（interrupt）を無視するということを意味します。

`-s'
`--synclines'
     Cプリプロセッサやそれに類するツールで使うための同期情報を含む行を
     生成します。これは`m4'をコンパイラのフロントエンドとして使う
     ときなどに便利です。ソースファイル名と行番号の情報は、`#line
     LINENUM "FILENAME"'という形式の指令（directive）によって表され、
     出力の途中へ必要に応じて挿入されます。この指令（directive）は次の
     行が入力ファイルFILENAMEの第LINENUM行そのものであるか、
     もしくはその行の展開によるものであることを意味します。
     `"FILENAME"'の部分は、ファイル名が前の指令（directive）と
     変わらない場合はしばしば省かれます。

     このような同期指令は、必ずそれ自身で完全な一行に対してのみ与えられます。
     ある出力行の途中に同期情報の食い違いがあるときは、
     対応する同期指令の出力は次の行へと持ち越されます。

`-P'
`--prefix-builtins'
     `m4'の内部に登録されている_すべて_の組み込みマクロの名前を
     接頭辞`m4_'が付いたものに変更します。
     このオプションを使ったときには、たとえば`define'の代わりに
     `m4_define'、`__file__'の代わりに`m4___file__'と書かなければ
     なりません。

`-WREGEXP'
`--word-regexp=REGEXP'
     マクロ名の字句構成規則を指定します。
     このオプションは試験的なものであり、 このオプションを含まないGNU
     `m4'の実装も存在する可能性があります。 (*note Changeword::)

`-HN'
`--hashsize=N'
     シンボルを表引きするための内部ハッシュテーブルの項目数をNにします。
     この数は素数にするべきです。デフォルトは509項目です。
     極端に多くのマクロを定義しないかぎり、この値を増やす必要は無いはずです。

`-LN'
`--nesting-limit=N'
     入れ子になったマクロの呼び出しをN段階に制限し、
     この制限を超えたときは、プログラムの実行を停止します。
     指定がない状態では、入れ子は250段階に制限されています。

     このオプションの正確な効力は、動的な再帰構造というよりは、
     テキスト上での入れ子構造に対して発揮されるものだと理解したほうが
     より正しいでしょう。
     このオプションは、機械的な方法で`m4'への複雑な入力を生成したときに
     役に立ったという例もありますが、大部分のユーザにとっては無用の長物でしょう。
     目障りだということになったときは、
     このオプションは(まだ試験段階です)削除されてしまうかも知れません。

     このオプションを使っても、再走査(rescanning)による無限ループを抜け出す
     ことは_できません_。その一方で、再走査ループは必ずしもメモリや
     スタック領域を大量に消費するわけではありません。
     再走査ループをうまく使えば、複雑で時間のかかる処理を`m4'に
     やらせることができます。
     この領域に制限をもうけるのは、`m4'の能力を弱めてしまうことになるでしょう。
     異常な使い方の例はいくらでもあります。
     `define(`a', `a')a'はもっとも単純なものの例です (しかし*note
     Compatibility::)。 GNU
     `m4'がこのようなケースを検出するのを期待するのは、
     コンパイラシステムが無限ループを検出し、診断メッセージをだすのを
     期待することに似ています。つまり、決定不能ではないとしても、
     一般にとても_ハード_な問題です。

`-Q'
`--quiet'
`--silent'
     マクロの呼び出しで、引数が不足していたり余分にあるときの警告を抑制します。

`-B'
`-S'
`-T'
     これらのオプションはSystem V版`m4'との互換性のために存在しますが、
     この実装では何の効果もありません。

`-NN'
`--diversions=N'
     これらのオプションはGNU
     `m4'の以前のバージョンとの互換性のためだけに
     存在し、同時に使うことができる出力切替え先（diversion）の数を制御するために
     使われていました。現在は固定された制限値がなくなったので、
     何の働きもしません。


   `-D'や`-U'オプションを使うと、コマンドライン上でマクロを定義したり
削除したりすることができます。これらは次の形式をとります。

`-DNAME'
`-DNAME=VALUE'
`--define=NAME'
`--define=NAME=VALUE'
     どの入力ファイルを読むよりも前に、NAMEをシンボルテーブルに
     登録します。`=VALUE'が省略されたときは、値は空文字列として
     解釈します。VALUEはどんな文字列でもよく、したがって、マクロは入力内で
     定義するときと同じように引数を取るものとして定義することもできます。

`-UNAME'
`--undefine=NAME'
     NAMEのすでに定義された意味を削除します。
     当然、この方法で削除できるのは定義済みのマクロだけです。

`-tNAME'
`--trace=NAME'
     NAMEを未定義として、しかしトレースが行われるように、シンボルテーブルへ
     登録します。
     その結果、このマクロは定義された時点からトレースされるようになります。

`-FFILE'
`--freeze-state FILE'
     実行が終了すると、凍結状態（frozen state）の内容を指定されたFILE
     (*note Frozen files::)へ書き出します。

`-RFILE'
`--reload-state FILE'
     実行の前に、指定された凍結ファイルFILE (*note Frozen files::)から
     内部状態を復元します。


   コマンドライン上の残りの引数は、入力ファイルの名前として解釈します。
ファイル名の指定がないときは、標準入力から読み込みます。
ファイル名`-'は、標準入力を意味するものとして解釈します。

   入力ファイルは、指定された順番に読み込みます。
標準入力は1度しか読むことができませんので、ファイル名`-'は
コマンドライン上で1度しか使えません。


File: m4-ja.info,  Node: Bugs,  Next: Manual,  Prev: Invoking m4,  Up: Preliminaries

1.4 問題やバグへの対処方法
==========================

GNU `m4'に関して問題が起こったり、バグと思われることを見つけたときは、
ぜひ、それを報告してください。
バグを報告する前に、実際にそれが本物のバグなのか確かめてください。
注意深くドキュメントを読み直して、あなたのしようとしたことが
実際にできると本当に書いてあるか確かめてください。
もし、ある事ができるのかどうか明確でないときは、それも報告してください。
それはドキュメントのバグです。

   バグを報告したり、自分で直そうとする前に、
そのバグを発現させる、できるだけ小さな入力ファイルを作れないか試してください。
作ることができたときは、その入力ファイルと`m4'が出す正確な結果を
私たちに送ってください。
また、あなたはどうなるはずだと思ったのかも添えてください。
これは、問題の原因が実はドキュメントにあるものなのか判断するのに役立ちます。

   問題を正確に把握したら、電子メールを(インターネット)
`bug-m4@gnu.org'または(UUCP)
`mit-eddie!prep.ai.mit.edu!bug-gnu-utils'へ送ってください。
あなたが使っている`m4'のバージョン番号も書いてください、 コマンド`m4
--version'で調べられます。

   バグの報告以外の提案もいつでも歓迎します。
ドキュメントの不明確なところや分かりにくい機能についての質問があれば、
それも送ってください。


File: m4-ja.info,  Node: Manual,  Prev: Bugs,  Up: Preliminaries

1.5 このマニュアルの読み方
==========================

このマニュアルには`m4'の入力と出力の例がたくさん含まれており、
入力、出力および`m4'からのエラーメッセージを区別するための
簡単な表記法が用いられています。
これらの例は通常の文章とは間隔をあけて、
固定幅フォントで次のように表示されます。

     This is an example of an example!

   入力と出力を区別するため、`m4'からの出力にはすべて`=>'が、
エラーメッセージにはすべて`error-->'が先頭につきます。
したがって次のようになります。

     Example of input line (入力行の例)
     =>Output line from m4 (m4からの出力行の例)
     error-->and an error message (エラーメッセージの例)

   `m4'に最初から定義されているマクロの説明をするときは、
引数に分かりやすい名前をつけたマクロ呼び出しのプロトタイプを示します。
これは次のようになります。

     regexp(STRING, REGEXP, opt REPLACEMENT)

   `m4'ではマクロの引数はすべて文字列ですが、
数字、ファイル名、正規表現としてなど特別な解釈のされかたをするものもあります。

   3番目の引数の前にある`opt'は、この引数が省略可能であることを
表しています。省略したときは、空文字列として解釈されます。
引数リストの最後にある省略記号(`...')は、その後にいくつでも引数を
続けてよいことを示してます。


File: m4-ja.info,  Node: Syntax,  Next: Macros,  Prev: Preliminaries,  Up: Top

2 字句・構文解析の規則
**********************

`m4'は入力を読み込むと、それを"トークン"（token）に分割します。
トークン（token）は名前（name）、クォートされた文字列(quoted string)、
それらの構成要素にはならない単独の文字のどれか1つの種類に属します。
また、`m4'への入力にはコメントを含めることができます。

* Menu:

* Names::                       入力トークン: マクロ名
* Quoted strings::              入力トークン: クォートされた文字列
* Other tokens::                入力トークン: その他
* Comments::                    m4への入力中のコメント


File: m4-ja.info,  Node: Names,  Next: Quoted strings,  Prev: Syntax,  Up: Syntax

2.1 入力トークン: マクロ名
==========================

名前（name）はアルファベット、数字、`_'(アンダースコア)
を自由に並べたもののうち、先頭の文字が数字でないものです。
名前にマクロの定義が存在するときは、マクロの呼び出しとして認識され、
展開の対象となります(*note Macros::)。

   正しい名前（name）の例を挙げると`foo', `_tmp',
`name01'などがあります。


File: m4-ja.info,  Node: Quoted strings,  Next: Other tokens,  Prev: Names,  Up: Syntax

2.2 入力トークン: クォートされた文字列
======================================

クォートされた文字列（quoted string）は、
引用符``'と`''に囲まれた文字列のうち、
文字列の内部で開始引用符``'と終了引用符`''の数が釣り合っているものです。
クォートされた文字列（quoted string）のトークンとしての値は、
いちばん外側にある引用符を一対だけ取った文字列です。 したがって、

     `'

   の値は空文字列です。そして、

     ``quoted''

   の値は次の文字列になります。

     `quoted'

   引用符を表す文字は、組み込みマクロ`changequote'を使って、
いつでも替えることができます。 詳細は*Note
Changequote::を参照してください。


File: m4-ja.info,  Node: Other tokens,  Next: Comments,  Prev: Quoted strings,  Up: Syntax

2.3 入力トークン: その他
========================

名前（name）とクォートされた文字列（quoted string）の構成要素にならない
文字はすべて、それ自身で一つのトークンとなります。


File: m4-ja.info,  Node: Comments,  Prev: Other tokens,  Up: Syntax

2.4 コメント
============

`m4'では通常`#'と改行文字で区切られた部分がコメントとなります。
これらコメントデリミタ（comment delimiters）の間にあるすべての文字は
処理の対象とならず無視されます。 しかし、コメントデリミタ（comment
delimiters）を含むコメント全体は、 出力へそのまま流されて行きます。
つまり`m4'においてコメントは破棄_されません_。

   コメントを入れ子にすることはできません。したがって、`#'の後の
最初の改行文字でコメントは終りとなります。
コメント開始文字をクォートすることによって、
コメント開始文字としての働きを抑制できます。

   コメントデリミタ（comment delimiters）は組み込みマクロ`changecom'を
使って、いつでも好きな文字列に変更できます。 詳細は*Note
Changecom::を参照してください。


File: m4-ja.info,  Node: Macros,  Next: Definitions,  Prev: Syntax,  Up: Top

3 マクロを呼び出す方法
**********************

この章ではマクロの呼び出し、マクロの引数、マクロの展開が行われる過程
について説明します。

* Menu:

* Invocation::                  マクロの呼び出し
* Inhibiting Invocation::       マクロの呼び出しを抑制する
* Macro Arguments::             マクロの引数
* Quoting Arguments::           マクロの引数をクォートする
* Macro expansion::             マクロの展開


File: m4-ja.info,  Node: Invocation,  Next: Inhibiting Invocation,  Prev: Macros,  Up: Macros

3.1 マクロの呼び出し
====================

マクロを呼び出すときの形式には次のものがあります。

     name

これは引数を伴わないマクロの呼び出しです。

     name(arg1, arg2, ..., argN)

これはN個の引数を伴うマクロの呼び出しです。
マクロはいくつでも引数を取ることができます。
すべての引数は文字列ですが、
マクロによって引数の解釈のしかたが違うことがあります。

   開きカッコ`('は、
スペースを入れずにNAMEの_直後に_書かなければいけません。
そうしないと、そのマクロは引数なしで呼び出されてしまいます。

   引数なしでマクロを呼び出すためには、カッコを付けては_いけません_。
たとえば、

     name()

これは、空の文字列を1つだけ引数として持つマクロの呼び出しであり、
引数を伴わないマクロの呼び出しではありません。


File: m4-ja.info,  Node: Inhibiting Invocation,  Next: Macro Arguments,  Prev: Invocation,  Up: Macros

3.2 マクロの呼び出しを抑制する
==============================

先行するマクロプロセッサ(Stratcheyの`GPM'など)に比べて、
`m4'言語の革新的なところは、
先頭に特別な文字をつけて書くといったことをしなくても、マクロの呼び出しを識別できる能力です。
この機能は多くの場合において便利なのですが、
ときには不必要なマクロの呼び出しの原因となることがあります。
そこで、GNU `m4'には名前（name）がマクロの呼び出しとして認識されるのを
抑制するいくつかの機構やテクニックがあります。

   まず、多くの組み込みマクロは引数なしで呼び出しても意味がないので、
それらの名前の直後に開きカッコがないときは、組み込みマクロは呼び出されません。
これによって、`include'や`eval'がマクロとして認識されてしまう
といったよくあるケースに対処できます。 後ほど、この文書に出てくる
"このマクロは引数を与えたときだけ認識されます"という文は、
この動作を意味します。

   また、コマンドオプション(`--prefix-builtins', または`-P')
を使うと、組み込みマクロを呼び出すときは、
その名前の先頭に`m4_'をつけなければ認識されなくなります。
たとえば`m4_dnl'や、さらには`m4_m4exit'と 書かなければならなくなります。
ちなみに、このオプションはユーザ定義のマクロには何の効果ももちません。

   `changeword'機能がコンパイル時に組み込まれた`m4'を
使用しているときは、マクロ名の認識に使われる字句構成規則をはるかに柔軟に
指定することができます。
この規則は組み込みマクロとユーザ定義マクロ両方の名前に作用します。
この試験的な機能の詳細は*Note Changeword::を参照してください。

   もちろん、ある名前がマクロの呼び出しとして認識されるのを防ぐ、
もっとも単純な方法は、その名前をクォートする(引用符で囲む)ことです。
この節の残り部分では、クォートすることがマクロの呼び出しにどのように
影響するのか、またマクロの呼び出しを抑制するには
それをどのように使えばよいのかを、もうすこし詳しく見ていきます。

マクロの呼び出しを抑制したいときは名前全体をクォートするのが普通ですが、
名前の数文字をクォートするだけでも同じ効果があります。
また、空文字列をクォートするだけでもよいのですが、
この場合は名前の_内部_でないと効果はありません。たとえば、

     `divert'
     `d'ivert
     di`ver't
     div`'ert

これらの結果はすべて文字列`divert'となりますが、

     `'divert
     divert`'

こちらは両方とも組み込みマクロ`divert'が呼ばれます。

   マクロを評価して生じた出力は常に再走査（rescan）されます。
次の例では、`m4'に`substr(abcde, 3, 2)'を入力として
与えたときと同様に、文字列`de'が生成されます。

     define(`x', `substr(ab')
     define(`y', `cde, 3, 2)')
     x`'y

   クォートされた文字列（quoted
string）の両端にあるクォートされていない文字列は、
マクロ名として認識される対象となります。
次の例では、空文字列をクォートすることによって
`dnl'マクロが認識されるようになります。

     define(`macro', `di$1')
     macro(v)`'dnl

もし引用符がなかったら、
文字列`divdnl'とそれに続く改行文字が生成されるだけでしょう。

クォートすることで、マクロ展開による文字列とその周囲の文字を連結したものが
マクロの名前として認識されるのを防ぐことができます。たとえば、

     define(`macro', `di$1')
     macro(v)`ert'

この入力からは、文字列`divert'が生み出されます。
もし引用符がなければ、組み込みマクロ`divert'が呼びだされるでしょう。


File: m4-ja.info,  Node: Macro Arguments,  Next: Quoting Arguments,  Prev: Inhibiting Invocation,  Up: Macros

3.3 マクロの引数
================

ある名前（name）が認識され、その名前に対するマクロの定義が存在するとき、
それはマクロとして展開されます。

   その名前の直後に開きカッコ`('があるときは、
引数をすべて集めてから、マクロが呼び出されます。
足りない引数があるときは、空文字列が与えられたものとして解釈されます。
余分な引数は無視されます。

   組み込みマクロの呼び出しで引数の数が不足しているとき、通常なら`m4'は
警告を発しますが、コマンドラインオプション`-Q'を使えば、
この警告を抑制できます。
ユーザ定義マクロに対する引数の個数チェックはありません。

引数の収集が行われているときでも、通常と同じようにマクロの展開は行われます。
そして展開後のテキストに出現した、コンマ、引用符、
カッコなどはすべて個々の引数の定義に寄与します。 したがってFOOが`, b,
c'に展開されるとき、 次のマクロの呼び出し、

     bar(a foo, d)

   は、4つの引数、`a ', `b', `c', `d' を伴うマクロの呼び出しとなります。
なぜ最初の引数に空白（whitespace）が含まれているのか理解するには、
引数の前にある空白はすべて削除されるのに対して、引数の後ろにある空白は
削除されないことを覚えておくとよいでしょう。


File: m4-ja.info,  Node: Quoting Arguments,  Next: Macro expansion,  Prev: Macro Arguments,  Up: Macros

3.4 マクロの引数をクォートする
==============================

個々の引数の前にある、クォートされていない空白（whitespace）は削除されます。
各引数の内部では、
クォートされていないカッコはすべて対になっていなければなりません。
たとえば、FOOがマクロのとき、

     foo(() (`(') `(')

   これはひとつの引数を伴ったマクロの呼び出しで、
その引数の値は`() (() ('です。

   引数自体がマクロ展開の対象になって欲しいのでない限り、
マクロへの引数はすべてクォートするのが普通です。
したがって、上記のカッコを含む例の`正しい'書き方は次のようになります。

     foo(`() (() (')

しかし、ときにはいくつかの引数をクォートしないでおく必要がある場合もあり、
また、そうすることに何ら問題はありません。
ただ、注意を怠ると人生がすこしばかり厳しいものになるだけです。


File: m4-ja.info,  Node: Macro expansion,  Prev: Quoting Arguments,  Up: Macros

3.5 マクロの展開
================

マクロの呼び出しが引数を伴うときはその収集が行われたあと、
マクロは展開されます。
そして展開後のテキストは入力に(クォートされずに)戻され、
そして再び読み込まれます(再走査)。
したがって、マクロを1つ呼び出したことで得られたテキストの中に、
完全なマクロの呼び出しやその一部が含まれている場合、
そこから更に多くのマクロが呼ばれることもあるわけです。

   非常に簡単な例を挙げると、FOOが`bar'へ展開され、 BARが`Hello
world'へ展開されるとすると、入力

     foo

は最初に`bar'へ展開された後、再び走査が行われ `Hello
world'へ展開されます。


File: m4-ja.info,  Node: Definitions,  Next: Conditionals,  Prev: Macros,  Up: Top

4 新たにマクロを定義する方法
****************************

マクロはいくつかの異なる方法で定義、再定義、削除することができます。
また現在の定義を失うことなく一時的にマクロを再定義しておいて、
後で元の定義に戻すこともできます。

* Menu:

* Define::                      新しいマクロを定義する
* Arguments::                   マクロの引数
* Pseudo Arguments::            マクロの疑似引数
* Undefine::                    マクロの削除
* Defn::                        マクロ名の変更
* Pushdef::                     マクロの一時的な再定義

* Indir::                       マクロの間接的な呼び出し
* Builtin::                     組み込みマクロの間接的な呼び出し


File: m4-ja.info,  Node: Define,  Next: Arguments,  Prev: Definitions,  Up: Definitions

4.1 マクロの定義方法
====================

通常はマクロを定義したり再定義するときは、
組み込みマクロ`define'を使います。

     define(NAME [, EXPANSION])

これはNAMEがEXPANSIONに展開されるように定義します。
もしEXPANSIONが与えられなかったときは、空文字列だと見なされます。

   `define'は展開されると消滅します。

   次の例では、マクロFOOが`Hello World.'に展開されるように
定義しています。

     define(`foo', `Hello world.')
     =>
     foo
     =>Hello world.

   出力に空行がある理由は、マクロ定義の直後にある改行文字が
定義の一部分ではないので、出力にそのままコピーされるためです。
これは`dnl'マクロを使うことで避けることができます。 詳しくは*Note
Dnl::を参照してください。

   マクロ`define'は引数を与えたときだけ認識されます。


File: m4-ja.info,  Node: Arguments,  Next: Pseudo Arguments,  Prev: Define,  Up: Definitions

4.2 マクロの引数
================

マクロは引数を取ることができます。N番目の引数は展開用テキストの中では
`$n'として書き示され、マクロが展開されるときにN番目の 実引数（actual
argument）に置き換えられます。
次の例は2つの引数を取るマクロです。2つの引数の順番を単に交換します。

     define(`exch', `$2, $1')
     =>
     exch(arg1, arg2)
     =>arg2, arg1

   これは`define'への引数の順番を逆にしたいときなどに使えます。

     define(`exch', `$2, $1')
     =>
     define(exch(``expansion text'', ``macro''))
     =>
     macro
     =>expansion text

   二重になった引用符の説明については*Note Quoting
Arguments::を参照してください。

   GNU `m4'では`$'に続く数字は複数の桁でもよいので、
マクロはいくつでも引数を取ることができます。
これと違いUNIXの`m4'では1桁の数字しか認識されません。

特殊なケースとして、0番目の引数`$0'は常に現在展開されているマクロの名前
となります。

     define(`test', ``Macro name: $0'')
     =>
     test
     =>Macro name: test

   クォートされたテキストを展開後のテキストに含めたい時は、
クォートは入れ子にできることを思い出しましょう。したがって、

     define(`foo', `This is macro `foo'.')
     =>
     foo
     =>This is macro foo.

展開されたテキストに含まれる`foo'は、 クォートされた文字列（quoted
string）であり名前（name）ではないので、 再走査によって展開は_されず_、
引用符がはぎ取られるだけです(*note Syntax::)。


File: m4-ja.info,  Node: Pseudo Arguments,  Next: Undefine,  Prev: Arguments,  Up: Definitions

4.3 マクロの特殊な引数
======================

与えられた実引数（actual
arguments）の個数や全ての実引数をまとめて表すための
特別な表記方法があります。

   マクロを呼び出すときに与えられた実引数の個数は、
展開用テキストの中で`$#'として表します。
したがって与えられた実引数の個数を表示するマクロは次のようになります。

     define(`nargs', `$#')
     =>
     nargs
     =>0
     nargs()
     =>1
     nargs(arg1, arg2, arg3)
     =>3

   展開用テキストの中で`$*'という表記をすることで、
全ての実引数を(クォートはせずに)コンマで区切ったものを表すことができます。

     define(`echo', `$*')
     =>
     echo(arg1,    arg2, arg3 , arg4)
     =>arg1,arg2,arg3 ,arg4

   引数をそれぞれクォートしなければならないことがよくありますが、
そんなときは`$@'という表記を使います。
これは各引数がクォートされることを除けば`$*'と同じです。

     define(`echo', `$@')
     =>
     echo(arg1,    arg2, arg3 , arg4)
     =>arg1,arg2,arg3 ,arg4

   引用符はどこに行ったのでしょうか? もちろん展開後のテキストを
再走査したときに`m4'が食べてしまったのです。
違いを見るために、次のようにしてみましょう。

     define(`echo1', `$*')
     =>
     define(`echo2', `$@')
     =>
     define(`foo', `This is macro `foo'.')
     =>
     echo1(foo)
     =>This is macro This is macro foo..
     echo2(foo)
     =>This is macro foo.

これが理解できないときは*Note Trace::を参照してください。

   展開用テキストに記号`$'が存在し、それに続く部分が`m4'に理解できる
ものでないときは、`$'は他のテキストと同じように
マクロ展開後のテキストへ単にコピーされます。

     define(`foo', `$$$ hello $$$')
     =>
     foo
     =>$$$ hello $$$

   マクロを`$12'などに展開させたいときは、
`$'の後に一組の引用符を置きます。
これによって、`m4'がその`$'記号を引数への参照だと解釈してまうのを
防ぐことができます。


File: m4-ja.info,  Node: Undefine,  Next: Defn,  Prev: Pseudo Arguments,  Up: Definitions

4.4 マクロの削除
================

`undefine'を使えばマクロの定義を削除することができます。

     undefine(NAME)

これによってマクロNAMEが削除されます。
展開されてしまうのを防ぐためにマクロの名前は必ずクォートしなくてはなりません。

   `undefine'は展開されると消滅します。

     foo
     =>foo
     define(`foo', `expansion text')
     =>
     foo
     =>expansion text
     undefine(`foo')
     =>
     foo
     =>foo

   NAMEがマクロとして定義されていなくても問題はありません。
その場合、`undefine'は何もしません。

   `undefine'は引数を与えたときだけ認識されます。


File: m4-ja.info,  Node: Defn,  Next: Pushdef,  Prev: Undefine,  Up: Definitions

4.5 マクロ名の変更
==================

すでに定義済みのマクロの名前を替えることができます。
それには組み込みマクロ`defn'が必要となります。

     defn(NAME)

これはNAMEの_定義をクォートしたもの_に展開されます。
引数が定義済みのマクロでないときは展開されると消滅します。

   NAMEがユーザ定義マクロの場合、
クォートされた定義とは単にクォートされた展開用テキストのことです。
NAMEが組み込みマクロの場合、
展開後のテキストは、`m4'の内部にある組み込みマクロの定義を指す
特殊なトークンとなります。 このトークンは、`define' (および `pushdef')
の第2引数としてのみ意味を持ち、その他の文脈では無視されます。

   通常の使用方法は、次の例で`undefine'の名前を`zap'に換える方法を
見るのが一番分かりやすいでしょう。

     define(`zap', defn(`undefine'))
     =>
     zap(`undefine')
     =>
     undefine(`zap')
     =>undefine(zap)

   このように`defn'はユーザ定義マクロの定義や
組み込みマクロの定義をコピーするために使うことができます。
たとえ元のマクロが削除されても、もう一方の名前を使って
定義にアクセスすることができます。

   `defn'は引数を与えたときだけ認識されます。


File: m4-ja.info,  Node: Pushdef,  Next: Indir,  Prev: Defn,  Up: Definitions

4.6 マクロの一時的な再定義
==========================

あるマクロを一時的に再定義しておき、後で元の定義に戻すことができます。 それには`define'と`undefine'に良く似た、
組み込みマクロ`pushdef'と`popdef'を使います。

     pushdef(NAME [, EXPANSION])
     popdef(NAME)

これらのマクロはスタック（stack）に似た仕組みで機能します。
`pushdef'は、あるマクロを一時的に再定義します。
このときNAMEの前の定義は、新しい定義によって置き換えられる前に
保存されます。もし前の定義が存在しない場合は、
`pushdef'は`define'とまったく同じように機能します。

あるマクロに複数の定義が存在する場合(その中の一つだけがアクセス可能です)、
`popdef'を使って一番上の定義を削除することができます。
前の定義が無い場合、`popdef'は`undefine'のように機能します。

     define(`foo', `Expansion one.')
     =>
     foo
     =>Expansion one.
     pushdef(`foo', `Expansion two.')
     =>
     foo
     =>Expansion two.
     popdef(`foo')
     =>
     foo
     =>Expansion one.
     popdef(`foo')
     =>
     foo
     =>foo

   `define'によって、複数の定義を持つマクロを再定義したときは、
一番上の定義が新しい定義で_置き換え_られます。
`undefine'によって定義を削除するときは、
一番上のもの一つだけではなく、_すべて_の定義が削除されます。

     define(`foo', `Expansion one.')
     =>
     foo
     =>Expansion one.
     pushdef(`foo', `Expansion two.')
     =>
     foo
     =>Expansion two.
     define(`foo', `Second expansion two.')
     =>
     foo
     =>Second expansion two.
     undefine(`foo')
     =>
     foo
     =>foo

   `pushdef'と`defn'を使えば、組み込みマクロを一時的に再定義することが
できます。

   マクロ`pushdef'と`popdef'は引数を与えたときだけ認識されます。


File: m4-ja.info,  Node: Indir,  Next: Builtin,  Prev: Pushdef,  Up: Definitions

4.7 マクロの間接的な呼び出し
============================

`indir'を使うと、どんなマクロでも間接的に呼び出すことができます。

     indir(NAME, ...)

`indir'はマクロNAMEを残りの引数と共に呼び出します。
これを"不正な"名前を持つマクロを呼ぶのに使うことができます(`define'
はそういう名前でも定義できます。)

     define(`$$internal$macro', `Internal macro (name `$0')')
     =>
     $$internal$macro
     =>$$internal$macro
     indir(`$$internal$macro')
     =>Internal macro (name $$internal$macro)

   ここでの要点は、大きなマクロパッケージで、
間違って呼ばれてしまうことのないマクロを定義できるということです。
それらは組み込みマクロ`indir'によって_だけ_呼びだすことができます。


File: m4-ja.info,  Node: Builtin,  Prev: Indir,  Up: Definitions

4.8 組み込みマクロの間接的な呼び出し
====================================

`builtin'を使えば、組み込みマクロを間接的に呼び出すことができます。

     builtin(NAME, ...)

これは組み込みマクロNAMEを、残りの引数と共に呼び出します。
たとえNAMEに本来の定義を隠している別の定義が与えられていても、
本来の定義を呼び出します。

   マクロ`builtin'は引数を与えたときだけ認識されます。


File: m4-ja.info,  Node: Conditionals,  Next: Debugging,  Prev: Definitions,  Up: Top

5 条件分岐、ループ、再帰
************************

単純なテキストに展開されるようなマクロだけでは、
引数を取ることができるとしても、十分ではありません。
実行時に下される判断にもとづいて、
異なる展開がおこなわれるようなマクロが必要でしょう。
たとえば、何らかの条件構文が必要です。
また、ある処理を何回も繰り返したり、条件が真の間だけ繰り返したりするために、
ある種のループ構文も必要でしょう。

* Menu:

* Ifdef::                       マクロが定義済みかを判定する
* Ifelse::                      If-else 構文と多重分岐
* Loops::                       m4におけるループと再帰


File: m4-ja.info,  Node: Ifdef,  Next: Ifelse,  Prev: Conditionals,  Up: Conditionals

5.1 マクロが定義済みかを判定する
================================

`m4'には2つの異なる条件構文が組み込まれています。 その1つは`ifdef'です。

     ifdef(NAME, STRING-1, opt STRING-2)

これにより、あるマクロが定義されているかどうかをテストできるようになります。
NAMEがマクロとして定義されていれば `ifdef'はSTRING-1に展開され、
そうでないときはSTRING-2に展開されます。 STRING-2が省略されたときは
(通常の規則に従い)空文字列として解釈されます。

     ifdef(`foo', ``foo' is defined', ``foo' is not defined')
     =>foo is not defined
     define(`foo', `')
     =>
     ifdef(`foo', ``foo' is defined', ``foo' is not defined')
     =>foo is defined

   マクロ`ifdef'は引数を与えたときだけ認識されます。


File: m4-ja.info,  Node: Ifelse,  Next: Loops,  Prev: Ifdef,  Up: Conditionals

5.2 文字列の比較
================

もう一方の条件構文`ifelse'はずっと強力です。
与える引数の個数によって長いコメントの挿入のためや、
if-else構文、多重分岐などとして使うことができます。

     ifelse(COMMENT)
     ifelse(STRING-1, STRING-2, EQUAL, opt NOT-EQUAL)
     ifelse(STRING-1, STRING-2, EQUAL, ...)

`ifelse'に1つだけ引数を与えた場合、
それは単に捨てられて、何も出力されません。
これは`dnl'を何度も使わずにブロックコメントを
挿入するために良く使われる、`m4'におけるイディオムです。 GNU
`m4'ではこの特殊な使用法が認められているので、
引数が足りないことに対する警告はこのケースでは発せられません。

   `ifelse'に3つ、または4つの引数を与えて呼び出すと、
STRING-1とSTRING-2が(文字毎に比べて)等しければ EQUALに展開されます。
等しくなければNOT-EQUALに展開されます。

     ifelse(foo, bar, `true')
     =>
     ifelse(foo, foo, `true')
     =>true
     ifelse(foo, bar, `true', `false')
     =>false
     ifelse(foo, foo, `true', `false')
     =>true

   また`ifelse'には4つ以上の引数を与えることができます。
この場合、`ifelse'は伝統的なプログラミング言語における`case'文や
`switch'文と同じように機能します。
STRING-1とSTRING-2が等しければ`ifelse'はEQUALに
展開され、等しくなければ最初の3つの引数が捨てられたあと、
まったくおなじ手続きが繰り返されます。例で示したほうがいいでしょう。

     ifelse(foo, bar, `third', gnu, gnats, `sixth', `seventh')
     =>seventh

   もちろん、通常はこれらの例よりもうすこし高度な使い方をするでしょう。
`ifelse'のよくある使い方のひとつは、さまざまな種類のループ処理を
実装するマクロの中で使用する場合です。

   マクロ`ifelse'は引数を与えたときだけ認識されます。


File: m4-ja.info,  Node: Loops,  Prev: Ifelse,  Up: Conditionals

5.3 ループと再帰
================

`m4'ではループ処理が直接的にはサポートされていませんが、
再帰的なマクロを定義することはできます。
使用しているハードウェアとオペレーティングシステムによるもの以外、
再帰の深さに制限はありません。

   ループ処理は再帰とすでに説明した条件構文を使うことで実現できます。

   マクロの実引数を反復処理するときには組み込みマクロ`shift'を
使うことができます。

     shift(...)

このマクロは任意の個数の引数を受け取り、
最初の引数を除く残りの引数をそれぞれクォートしてから、
それらをコンマで区切ったものに展開します。

     shift(bar)
     =>
     shift(foo, bar, baz)
     =>bar,baz

   `shift'を使った次の例では引数の順番を逆にするマクロを定義しています。

     define(`reverse', `ifelse($#, 0, , $#, 1, ``$1'',
     			  `reverse(shift($@)), `$1'')')
     =>
     reverse
     =>
     reverse(foo)
     =>foo
     reverse(foo, bar, gnats, and gnus)
     =>and gnus, gnats, bar, foo

   それほど興味深いマクロではありませんが、
`shift'と`ifelse'そして再帰を使えばループ処理をどんなに簡単に
実現できるか示しています。

   次に挙げるのは、単純なforループを実現するマクロの例です。
単純な数え上げのためなどに使えます。

     forloop(`i', 1, 8, `i ')
     =>1 2 3 4 5 6 7 8

   それぞれの引数は順に、反復変数（iteration variable）の名前、
開始値、終了値、そして反復するたびに展開されるテキストです。
このマクロにおいて、マクロ`i'はループ処理の内部でだけ定義されています。
`i'が以前に値を持っていた場合は、ループが終ればまたその値にもどります。

   `forloop'は次のように入れ子にすることもできます。

     forloop(`i', 1, 4, `forloop(`j', 1, 8, `(i, j) ')
     ')
     =>(1, 1) (1, 2) (1, 3) (1, 4) (1, 5) (1, 6) (1, 7) (1, 8)
     =>(2, 1) (2, 2) (2, 3) (2, 4) (2, 5) (2, 6) (2, 7) (2, 8)
     =>(3, 1) (3, 2) (3, 3) (3, 4) (3, 5) (3, 6) (3, 7) (3, 8)
     =>(4, 1) (4, 2) (4, 3) (4, 4) (4, 5) (4, 6) (4, 7) (4, 8)
     =>

   `forloop'マクロはとても簡潔に実装することができます。
`forloop'マクロ自体は単なるラッパー(wrapper)で、
第1引数が持つ元の定義を保存してから、内部マクロ`_forloop'を呼び、
再び保存しておいた第1引数の定義を再確立します。

マクロ`_forloop'は第4引数を一度展開し、これで反復が終りかどうか調べます。
もし終りでなければ、反復変数を(すでに定義済みのマクロ`incr'を使って)
1増やしてから、自分自身を再帰的に呼び出します。

   `forloop'の実際の実装は次のようになります:

     define(`forloop',
            `pushdef(`$1', `$2')_forloop(`$1', `$2', `$3', `$4')popdef(`$1')')
     define(`_forloop',
            `$4`'ifelse($1, `$3', ,
     		   `define(`$1', incr($1))_forloop(`$1', `$2', `$3', `$4')')')

   注意深い引用符の使い方に注目してください。
マクロの引数でクォートされていないのは3つだけで、
それぞれに固有の理由があります。これら3つの引数がクォート
されていないのはなぜか、その_理由_を見つけてください、
これらがクォートされていると、どうなるのかも確かめてみてください。

   これら2つのマクロは便利ではありますが、
一般の使用に耐えるほど堅牢ではありません。
開始値が終了値より小さい場合や、第1引数が名前でなかった場合など、
初歩的なエラー対策さえ欠いています。
これら不備の訂正は、読者への課題として残しておきます。


File: m4-ja.info,  Node: Debugging,  Next: Input Control,  Prev: Conditionals,  Up: Top

6 マクロや入力をデバッグする方法
********************************

`m4'のマクロを書いていると、
(たいていのプログラミング言語の場合と同様に)
往々にしてそれらは思ったようには動いてくれないものです。
`m4'にはデバッグを支援するしくみがいくつか存在します。

* Menu:

* Dumpdef::                     マクロの定義を表示する
* Trace::                       マクロの呼び出しをトレースする
* Debug Levels::                デバッグ出力の制御
* Debug Output::                デバッグ出力の保存


File: m4-ja.info,  Node: Dumpdef,  Next: Trace,  Prev: Debugging,  Up: Debugging

6.1 マクロの定義を表示する
==========================

ある名前（name）が展開されるとどうなるのか調べたいときは、
組み込みマクロ`dumpdef'を使用することができます。

     dumpdef(...)

このマクロは任意の個数の引数を取ります。
引数を与ずに呼びだすと、既知の名前すべての定義を表示します。
それ以外の場合は与えた引数の定義を表示します。
出力は標準エラー出力に直接行われます。

   `dumpdef'は展開されると消滅します。

     define(`foo', `Hello world.')
     =>
     dumpdef(`foo')
     error-->foo:	`Hello world.'
     =>
     dumpdef(`define')
     error-->define:	<define>
     =>

   最後の例は組み込みマクロの定義が表示される様子です。

   表示の詳細を調整するための情報については*Note Debug
Levels::を参照してください。


File: m4-ja.info,  Node: Trace,  Next: Debug Levels,  Prev: Dumpdef,  Up: Debugging

6.2 マクロの呼び出しをトレースする
==================================

組み込みマクロ`traceon'と`traceoff'を使うと、マクロの呼び出しと
展開をトレース（trace）することができます。

     traceon(...)
     traceoff(...)

`traceon'と`traceoff'を引数なしで呼ぶと、
すべての定義済みのマクロに対してトレースがそれぞれオンまたはオフとなります。
引数を指定した場合、その名前のマクロに対してだけ作用します。

   `traceon'と`traceoff'は展開されると消滅します。

   トレース中のマクロが呼ばれるたびに、
そのマクロの呼び出しに関する情報が引数の収集が終ったあとに表示されます。
マクロの呼び出しが展開後に消滅しないときは展開の結果が表示されます。
出力は標準エラー出力へ直接行われます。

     define(`foo', `Hello World.')
     =>
     define(`echo', `$@')
     =>
     traceon(`foo', `echo')
     =>
     foo
     error-->m4trace: -1- foo -> `Hello World.'
     =>Hello World.
     echo(gnus, and gnats)
     error-->m4trace: -1- echo(`gnus', `and gnats') -> ``gnus',`and gnats''
     =>gnus,and gnats

   ダッシュ(-)の間にある数字は展開の深さを表します。
たいていは最も外側のレベルでの展開を表す1となりますが、
クォートされていないマクロの呼び出しを引数が含む場合には増えていきます。

   表示の詳細を調整するための情報については*Note Debug
Levels::を参照してください。


File: m4-ja.info,  Node: Debug Levels,  Next: Debug Output,  Prev: Trace,  Up: Debugging

6.3 デバッグ出力の制御
======================

`m4'に`-d'オプションを与えることにより、
これまでの節に記載されているマクロを使ったときに表示される情報の詳しさを
制御します。

   このオプションに続けて次のうち1つまたは複数のフドグを指定します。

`t'
     今回起動する`m4'におけるマクロの呼び出しを全てトレースします。

`a'
     マクロの呼び出しに伴う実引数を表示します。
     `t'フラグと共に指定したときは全てのマクロの呼び出しが対象となりますが、
     それ以外の場合は`traceon'マクロによってトレースしているマクロだけが
     対象となります。

`e'
     マクロの呼び出しが展開後に消滅しない場合、展開後のテキストを表示します。
     `t'フラグと共に指定したときは全てのマクロの呼び出しが対象となりますが、
     それ以外の場合は`traceon'マクロによってトレースしているマクロだけが
     対象となります。

`q'
     実引数やマクロの展開後のテキストを表示するときに現在の引用符でクォートします。

`c'
     ひとつのマクロの呼び出しにつき複数のトレース行を表示します。
     マクロが認識された時点で引数を集める前に1行表示し、
     引数を集め終った後に2行目を、
     マクロの呼び出しが完了したあとに3行目を表示します。

`x'
     トレースの各出力行にマクロの呼び出し毎に異なる`識別番号(id)'を加えます。
     これは上記の`c'フラグを使うときに便利です。

`f'
     トレースの各出力行に、現在の入力ファイルの名前を表示します。

`l'
     トレースの各出力行に、現在の入力行番号を表示します。

`p'
     指定した名前のファイルをパスサーチ機構(*note Search Path::)を使って
     見つけたときは、実際に使われるファイル名を表示します。

`i'
     現在の入力ファイルが替わるたびに、ファイル名と入力行番号を表示します。

`V'
     上記すべてのフラグを表す簡略表記です。

   `-d'オプションに何もフラグを指定しない場合、
デフォルトで`aeq'が使われます。
前2つの節にある例は、これらデフォルトのフラグを使うことを想定しています。

組み込みマクロ`debugmode'を使うと、実行時にデバッグ出力のフォーマットを
制御できます。

     debugmode(opt FLAGS)

引数FLAGSは上に列挙されている文字をいくつか指定します。
特殊なケースとして引数を`+'で始めると、
それらのフラグが現在のデバッグフラグ群に追加されます。
また引数を`-'で始めると現在のデバッグフラグ群から削除されます。
引数をまったく与えない場合、デバッグフラグは(`-d'を与えない場合と同様に)
すべてゼロに設定されます。
引数として空文字列を与えるとフラグはデフォルトの値にリセットされます。


File: m4-ja.info,  Node: Debug Output,  Prev: Debug Levels,  Up: Debugging

6.4 デバッグ出力の保存
======================

デバッグとトレースの出力は、`m4'に`-o'オプションを与えるか
組み込みマクロ`debugfile'を使うことで、
ファイルにリダイレクト（redirect）することができます。

     debugfile(opt FILENAME)

このマクロにより、ここから後に発生するデバッグとトレースの出力は
すべてFILENAMEへ送られます。
FILENAMEが空文字列のときはデバッグとトレースの出力は捨てられます。
`debugfile'が引数無しで呼ばれたときは、デバッグとトレースの出力は
標準エラー出力へ送られます。


File: m4-ja.info,  Node: Input Control,  Next: File Inclusion,  Prev: Debugging,  Up: Top

7 入力制御
**********

この章では`m4'への入力を制御するための、さまざまな組み込みマクロを
説明します。

* Menu:

* Dnl::                         入力中の空白（whitespace）を削除する
* Changequote::                 引用符（quote characters）を変更する
* Changecom::                   コメントデリミタ（comment delimiters）を変更する
* Changeword::                  単語（word）の字句構造を変更する
* M4wrap::                      入力の一部を入力が終るまで保存（save）しておく


File: m4-ja.info,  Node: Dnl,  Next: Changequote,  Prev: Input Control,  Up: Input Control

7.1 入力中の空白（whitespace）を削除する
========================================

組み込みマクロ`dnl'は最初の改行文字までにある文字をすべて読み込んでから
改行文字も含めてそれらを捨てます。

     dnl

次の例のように`define'の呼び出しの後に続く改行を取り除くために、
`define'と一緒によく使います。

     define(`foo', `Macro `foo'.')dnl A very simple macro, indeed.
     foo
     =>Macro foo.

   コメントの扱かわれ方とは対照的に(*note Comments::)、
次の改行までの入力が改行を含めて捨てられます。

通常`dnl'の後ろには、行末もしくはその他の空白（whitespace）が続きます。
GNU `m4'は`dnl'に続いて開きカッコがあるとき、
それを警告する診断メッセージを出します。
この場合`dnl'は閉じカッコを探しながら、引数をすべて集めて処理します。
この引数の収集に起因する副作用はすべて発生します。
このとき`dnl'は何も出力せず、閉じカッコのあとに続く次の改行までの入力は、
それがどの行にあっても、改行を含めてやはり捨てられます。


File: m4-ja.info,  Node: Changequote,  Next: Changecom,  Prev: Dnl,  Up: Input Control

7.2 引用符（quote characters）を変更する
========================================

デフォルトの引用符は組み込みマクロ`changequote'によって変更できます。

     changequote(opt START, opt END)

STARTは新しい開始引用符でENDは新しい終了引用符です。
もし欠けている引数があるときは、デフォルトの引用符(``' と `'')
がその欠けている引数の代わりに使用されます。

   `changequote'は展開されると消滅します。

     changequote([, ])
     =>
     define([foo], [Macro [foo].])
     =>
     foo
     =>Macro foo.

   適切な文字がないときはSTARTやENDを好きな長さにしてかまいません。

     changequote([[, ]])
     =>
     define([[foo]], [[Macro [[[foo]]].]])
     =>
     foo
     =>Macro [foo].

   引用符を両方とも空文字列にすると、事実上クォート機構が無効になり、
テキストをクォートする方法が無くなります。

     define(`foo', `Macro `FOO'.')
     =>
     changequote(, )
     =>
     foo
     =>Macro `FOO'.
     `foo'
     =>`Macro `FOO'.'

   `changequote'を使って現在の引用符を替えない限り、
終了引用符と対になっていない開始引用符を含む文字列をクォートする
方法は`m4'には存在しません。

   入力に含まれる名前と混同されてしまうので、
どちらの引用符も記号でない普通の文字や`_' (アンダースコア)で
始めるべきではありません。そうした場合はクォート機構が無効になります。


File: m4-ja.info,  Node: Changecom,  Next: Changeword,  Prev: Changequote,  Up: Input Control

7.3 コメントデリミタ（comment delimiters）を変更する
====================================================

デフォルトのコメントデリミタ（comment delimiters）は
組み込みマクロ`changecom'で変更できます。

     changecom(opt START, opt END)

STARTが新しいコメント開始デリミタ（start-comment delimiter）で、
ENDが新しいコメント終了デリミタ（end-comment delimiter）です。
欠けている引数があるときは、デフォルトのコメント区切り記号 (`#' と
改行文字)がその欠けている引数の代わりに使用されます。
コメント区切り記号は任意の長さにすることができます。

   `changecom'は展開されると消滅します。

     define(`comment', `COMMENT')
     =>
     # A normal comment
     =># A normal comment
     changecom(`/*', `*/')
     =>
     # Not a comment anymore
     =># Not a COMMENT anymore
     But: /* this is a comment now */ while this is not a comment
     =>But: /* this is a comment now */ while this is not a COMMENT

あたかもクォートされた文字列であるかのようにコメントが出力にコピーされている
様子に注目してください。
コメント内部のテキストが展開されるようにしたいときは、
コメント開始デリミタをクォートしてください。

   引数なしで`changecom'を呼ぶとコメント機構が完全に無効になります。

     define(`comment', `COMMENT')
     =>
     changecom
     =>
     # Not a comment anymore
     =># Not a COMMENT anymore


File: m4-ja.info,  Node: Changeword,  Next: M4wrap,  Prev: Changecom,  Up: Input Control

7.4 単語（word）の字句構造を変更する
====================================

     マクロ`changeword'とそれに関連する機能すべてが実験段階にあります。
     GNU `m4'をインストールする際
     `configure'に`--enable-changeword'オプションを与えたときだけ
     この機能を使用することができます。
     これから先、この機能が変更されたり、削除されてしまうことさえありえます。
     したがって、_この機能に依存した使い方はしないで下さい_。
     この機能について意見を寄せていただくときは
     バグを報告するときと同じ方法で行ってください。

   `m4'によって処理されるファイルは、クォートされた文字列、
単語(潜在的なマクロ名)、そして単純なトークン(その他の単一の文字すべて)
に分割されます。 初めに単語は次の正規表現によって定義されています。

     [_a-zA-Z][_a-zA-Z0-9]*

   `changeword'を使えばこの正規表現を変更できます。
たとえば数字が詰まったファイルに置換をかけたい場合など、
`m4'の字句構成規則を緩めると便利なときもあるでしょう。

     changeword(`[_a-zA-Z0-9]+')
     define(1, 0)
     =>1

   字句構成規則を厳しくすると
組み込みマクロのうちいくつかが使えなくなってしまうことが多いので、
緩める場合ほど便利にはなりません。
次の例のように、間違って組み込みマクロを呼んでしまうのを避けるために
使うことはできるでしょう。

     define(`_indir', defn(`indir'))
     changeword(`_[_a-zA-Z0-9]*')
     esyscmd(foo)
     _indir(`esyscmd', `ls')

   `m4'は単語を一文字ずつ組み立てていくので、
`changeword'に渡すことができる正規表現には制限があります。
それは、もし指定した正規表現が`foo'を受理するのなら
その正規表現は`f'と`fo'も受理するものでなければならないというものです。

   `changeword'には、もう一つ機能があります。
指定した正規表現の中にカッコ`\('
`\)'でくくられた部分表現が1つ以上存在する
場合、最初のカッコでくくられた部分表現の外側にあるテキストが、
シンボルを表引きする前に捨てられます。

     changecom(`/*', `*/')
     changeword(`#\([_a-zA-Z0-9]*\)')
     #esyscmd(ls)

   こうすると、`m4'はすべてのマクロの呼び出しの先頭に
`#'記号を必要とするようになるので、
`m4'でシェルスクリプトを処理するときに
`shift'コマンドが`m4'に飲み込まれてしまわないようにできます。
また種々の一般的な単語を失うことなくプレーンテキストを
処理できるようになります。

   `m4'のマクロ置換はテキストに基づいていますが、
TeXのものはトークンに基づいています。
`changeword'によって、この違いを浮き彫りにすることができます。
たとえば次の例は同じアイデアをTeXと`m4'で表現したものです。 初めはTeX
バージョンからです。

     \def\a{\message{Hello}}
     \catcode`\@=0
     \catcode`\\=12
     @a

つぎに`m4'バージョンです。

     define(a, `errprint(`Hello')')
     changeword(`@\([_a-zA-Z0-9]*\)')
     @a

   TeXの例において、最初の行はマクロ`a'が`Hello'メッセージを
表示するように定義しています。
2行目は<\>の代わりに<@>をエスケープ文字として使えるように
定義しています。
3行目は<\>をエスケープ文字ではなく通常の表示可能文字として
定義しています。 4行目はマクロ`a'を呼び出しています。
したがって、このファイルに対してTeXを走らせると
`Hello'メッセージを表示します。

   `m4'の例を`m4'に与えると`errprint(Hello)'を表示します。
この理由はTeXはマクロが_定義されたとき_にマクロ定義の字句解析
を行うのに対し、`m4'は単純にテキストを保存しておき、
字句解析は実際にマクロが_使われる_まで後回しにするからです。

   `changeword'を使用すると、
`m4'の速度が7倍ほど遅くなることに注意してください。


File: m4-ja.info,  Node: M4wrap,  Prev: Changeword,  Up: Input Control

7.5 入力の保存（save）
======================

通常の入力が終りになるまで、テキストを`保存（save）'しておくことができます。
保存されたテキストは通常の入力が終った段階で`m4'に再び読み込まれます。
通常この機能は一時ファイルの削除など正常終了前に行うクリーンアップ動作を
開始するために使われます。

   入力テキストを保存するためには組み込みマクロ`m4wrap'を使います。

     m4wrap(STRING, ...)

STRINGと残りの引数は入力が終端に達したときに再び読み込まれるように
安全な場所に保存されます。

     define(`cleanup', `This is the `cleanup' actions.
     ')
     =>
     m4wrap(`cleanup')
     =>
     This is the first and last normal input line.
     =>This is the first and last normal input line.
     ^D
     =>This is the cleanup actions.

保存されている入力は通常の入力が終端に達したときだけ再び読み込まれます。
`m4'を終了するために`m4exit'が使われたときは再読み込みは行われません。

   保存されたテキストの中で`m4wrap'を呼びだしても差し支えありませんが、
そのとき保存されたテキストが再読み込みされる順番は決まっていません。
`m4wrap'が再帰的に使われていない場合、
保存された各テキストはそれぞれが保存されたのと逆の順番(LIFO--last in,
first out)で再読み込みが行われます。


File: m4-ja.info,  Node: File Inclusion,  Next: Diversions,  Prev: Input Control,  Up: Top

8 ファイルのインクルード
************************

`m4'では入力のどこででも名前を指定してファイルをインクルード
（include）することができます。

* Menu:

* Include::                     名前を指定してファイルをインクルードする
* Search Path::                 インクルードするファイルのサーチ


File: m4-ja.info,  Node: Include,  Next: Search Path,  Prev: File Inclusion,  Up: File Inclusion

8.1 名前を指定してファイルをインクルードする
============================================

`m4'にはファイルをインクルードするための組み込みマクロが2つあります。

     include(FILENAME)
     sinclude(FILENAME)

どちらもFILENAMEという名前のファイルを`m4'に読み込ませます。
そのファイルの終りに達すると以前の入力ファイルから入力を再開します。

   したがって`include'と`sinclude'は展開後に FILENAMEの内容となります。

   `include'に指定したファイルが存在しないとエラーとなります。
ファイルが存在しないときのエラーメッセージを避けたいときは
`sinclude'を使います。
`sinclude'は、もしファイルが存在すればそのファイルをインクルードし、
存在しなければ消滅します。

     include(`no-such-file')
     =>
     error-->30.include:2: m4: Cannot open no-such-file: No such file or directory
     sinclude(`no-such-file')
     =>

   これ以降ファイル`incl.m4'の内容は仮に以下のものだとします。
     Include file start
     foo
     Include file end

通常、ファイルのインクルードはファイルの内容を入力ストリームに挿入するために
使用されます。 インクルードされたファイルの内容は`m4'によって読まれ、
そのファイルに含まれるマクロの呼び出しは展開されます。

     define(`foo', `FOO')
     =>
     include(`incl.m4')
     =>Include file start
     =>FOO
     =>Include file end
     =>

   `include'と`sinclude'がファイルの内容に展開されることを利用して、
ファイル全体に作用するマクロを定義することができます。
次の例では`bar'が`incl.m4'の内容に展開されるように定義しています。

     define(`bar', include(`incl.m4'))
     =>
     This is `bar':  >>>bar<<<
     =>This is bar:  >>>Include file start
     =>foo
     =>Include file end
     =><<<

   もっとも、これは`include'のよくある使い方とは言えません。
なぜならファイルにはクォート、コンマ、カッコといった
`m4'のパーサ（parser）の働き方に干渉するものがランダムに含まれている可能性が
あるからです。

組み込みマクロ`include'と`sinclude'は引数を与えたときだけ認識されます。


File: m4-ja.info,  Node: Search Path,  Prev: Include,  Up: File Inclusion

8.2 インクルードするファイルのサーチ
====================================

GNU `m4'ではインクルード対象のファイルが現在の作業ディレクトリ
（current working directory）とは別のディレクトリにあっても
かまいません。

ファイルが現在の作業ディレクトリで見つからずファイル名が絶対ファイル名
（absolute file name）でないとき、GNU `m4'は指定されたサーチパス
（search path）を使ってそのファイルを探します。
最初に`-I'オプションで指定された各ディレクトリの中を
コマンドラインに書かれている順番に探します。
次に環境変数`M4PATH'が設定されているときは、
それをコロン(:)で区切られたディレクトリのリストとして解釈し、
それらの中を順に探します。

   インクルードファイルの自動サーチがトラブルの原因となったときは、
`p'デバッグフラグ(*note Debug Levels::)が問題の切り分けに
役立つでしょう。


File: m4-ja.info,  Node: Diversions,  Next: Text handling,  Prev: File Inclusion,  Up: Top

9 出力の切替え（divert）と逆切替え（undivert）
**********************************************

出力切替え（diversions）は出力を一時的に保存しておく方法です。
`m4'では好きなときに出力を一時ファイルへ切替え（divert）ておき、
後で再び出力ストリームへと逆切替え（"undiverted"）することができます。

切り替え先番号は0から数え上げます。切替え先0は通常の出力ストリームです。
同時に存在できる切替え先の数はそれらの記述に費されるメモリの量によって
主に制限を受けます。これはGNU `m4'が切替え先の情報とそこへの出力を
できればメモリに置いておこうとするためです。そして全ての切替え先の分を
あわせたもののために使えるメモリ量には制限があります(現在は512Kです)。
この最大値を超えそうになったときは、一番大きな切替え先の内容を入れるために
一時ファイルが作られ、その分のメモリが他の切替え先のために開放されます。
したがって理論上は切替え先の数が利用可能なファイルディスクリプタの数
によって制限されることもありえます。

* Menu:

* Divert::                      出力を切替える（divert）
* Undivert::                    出力を逆切替え（undivert）する
* Divnum::                      出力切替え先番号（diversion number）
* Cleardiv::                    出力切替え先のテキストを破棄する


File: m4-ja.info,  Node: Divert,  Next: Undivert,  Prev: Diversions,  Up: Diversions

9.1 出力を切替える（divert）
============================

出力は`divert'を使って切替えます。

     divert(opt NUMBER)

NUMBERは使用する切替え先です。
NUMBERを省略したときはゼロとして解釈されます。

   `divert'は展開されると消滅します。

   `m4'への入力がすべて処理されると、
その時点で存在するすべての切替え先が自動的に番号の順で逆切替え（undivert）
されて、そこにたまっていたテキストが出力されます。

     divert(1)
     This text is diverted.
     divert
     =>
     This text is not diverted.
     =>This text is not diverted.
     ^D
     =>
     =>This text is diverted.

   同じ引数で`divert'を何回か呼び出すと、
切替え先にある以前のテキストは上書きされずに、
新しいテキストが以前のテキストの後に追加されてゆきます。

   存在するはずのない切替え先へ出力を切替えるとそこから後の出力は
単に捨てられます。
よくある不要な出力の例はマクロ定義の後にある改行です。
次はそれらを避ける方法です。

     divert(-1)
     define(`foo', `Macro `foo'.')
     define(`bar', `Macro `bar'.')
     divert
     =>

   これは`m4'でのプログラミングで広く使われている慣用句のひとつです。


File: m4-ja.info,  Node: Undivert,  Next: Divnum,  Prev: Divert,  Up: Diversions

9.2 出力を逆切替え（undivert）する
==================================

切替え先に出力されたテキスト（diverted text）は組み込みマクロ
`undivert'を使って明示的に逆切替え（undivert）することができます。

     undivert(opt NUMBER, ...)

このマクロは引数で指定された切替え先を、指定された順に逆切替えして出力します。
引数が与えられなかったときは、すべての切替え先を番号順に逆切替えします。

   `undivert'は展開されると消滅します。

     divert(1)
     This text is diverted.
     divert
     =>
     This text is not diverted.
     =>This text is not diverted.
     undivert(1)
     =>
     =>This text is diverted.
     =>

   最後にある2つの空行に注目してください。
最後のものは`undivert(1)'に続く改行によるもので、
前のものはなんと`divert(1)'に続く改行によるものです。
切替え先のテキストはしばしばこのような空行で始まります。

   切替え先のテキスト（diverted text）は逆切替え(undiverted)されると、
`m4'によって再走査_されずに_、
現在の出力(切替え先)に直接コピーされます。
したがってある切替え先（diversion）へ出力中に、
逆切替え（undivert）しても問題ありません。

   逆切替えをすると、その切替え先にあるテキストは破棄されるので
切替え先のテキストを取り出せるのは1回だけです。

     divert(1)
     This text is diverted first.
     divert(0)undivert(1)dnl
     =>
     =>This text is diverted first.
     undivert(1)
     =>
     divert(1)
     This text is also diverted but not appended.
     divert(0)undivert(1)dnl
     =>
     =>This text is also diverted but not appended.

   現在の切替え先（current diversion）を逆切替え（undivert）
しようとしても黙殺されます。

   GNU `m4'では名前を指定したファイルを逆切替え（undivert）
することができます。数字以外の引数を与えると、その名前をもつファイルの
内容が現在の出力(切替え先)に解釈されずにコピーされます。
これによって組み込みマクロ`include'の機能が補完されます(*note
Include::)。
次の例で違いを説明します。ファイル`foo'の内容は`bar'だとします。

     define(`bar', `BAR')
     =>
     undivert(`foo')
     =>bar
     =>
     include(`foo')
     =>BAR
     =>


File: m4-ja.info,  Node: Divnum,  Next: Cleardiv,  Prev: Undivert,  Up: Diversions

9.3 出力切替え先番号（diversion number）
========================================

組み込みマクロ`divnum'は現在の切替え先（current
diversion）の番号に展開されます。

     divnum


     Initial divnum
     =>Initial 0
     divert(1)
     Diversion one: divnum
     divert(2)
     Diversion two: divnum
     divert
     =>
     ^D
     =>
     =>Diversion one: 1
     =>
     =>Diversion two: 2

逆切替えされて出力されるテキスト自身が切替え先に出力されてしまうのを防ぐため
に最後にある引数無しの`divert'の呼び出しが必要です。


File: m4-ja.info,  Node: Cleardiv,  Prev: Divnum,  Up: Diversions

9.4 出力切替え先のテキストを破棄する
====================================

出力を切替えているときは切替え先のテキストが実際に
必要となるかどうかは分からないことがよくあります。
テキストが溜っている切替え先は入力が終りに達した段階で
メインの出力ストリームにすべて出力されるので、
切替え先にたまっているテキストを破棄するためのなんらかの手段が必要です。
すべての切替え先のテキストを破棄したいときは
`m4'への入力を`divert(-1)'とそれに続く明示的な`undivert'
で終えるのが最も簡単でしょう。

     divert(1)
     Diversion one: divnum
     divert(2)
     Diversion two: divnum
     divert(-1)
     undivert
     ^D

このとき出力はいっさいありません。

   特定の切替え先のテキストは次のマクロで消去できます。

     define(`cleardivert',
     `pushdef(`_num', divnum)divert(-1)undivert($@)divert(_num)popdef(`_num')')
     =>

   `undivert'と同じように呼び出しますが、
その効果は引数として与えられた切替え先のテキストを消去することです。
(このマクロにはひどいバグがあります!
それを見つけて直せるか挑戦してみてください。)


File: m4-ja.info,  Node: Text handling,  Next: Arithmetic,  Prev: Diversions,  Up: Top

10 テキスト操作用の組み込みマクロ
*********************************

`m4'には部分文字列の抽出、検索、置換など様々な方法でテキストを
操作するための組み込みマクロがあります。

* Menu:

* Len::                         文字列の長さを計算する
* Index::                       部分文字列を検索する
* Regexp::                      正規表現で検索する
* Substr::                      部分文字列を抽出する
* Translit::                    文字の置換
* Patsubst::                    正規表現でテキストの置換をする
* Format::                      文字列を(printf風に)フォーマットする


File: m4-ja.info,  Node: Len,  Next: Index,  Prev: Text handling,  Up: Text handling

10.1 文字列の長さを計算する
===========================

文字列の長さは`len'で数えられます。

     len(STRING)

このマクロはSTRINGの長さを表す10進数に展開されます。

     len()
     =>0
     len(`abcdef')
     =>6

   組み込みマクロ`len'は引数を与えたときだけ認識されます。


File: m4-ja.info,  Node: Index,  Next: Regexp,  Prev: Len,  Up: Text handling

10.2 部分文字列を検索する
=========================

部分文字列の検索は`index'で行います。

     index(STRING, SUBSTRING)

このマクロはSTRINGの中でSUBSTRINGが最初に出現する
位置のインデックスに展開されます。
STRINGの先頭にある文字のインデックスは0です。
SUBSTRINGがSTRINGに含まれないとき、 `index'は`-1'に展開されます。

     index(`gnus, gnats, and armadillos', `nat')
     =>7
     index(`gnus, gnats, and armadillos', `dag')
     =>-1

   組み込みマクロ`index'は引数を与えたときだけ認識されます。


File: m4-ja.info,  Node: Regexp,  Next: Substr,  Prev: Index,  Up: Text handling

10.3 正規表現で検索する
=======================

正規表現の検索は組み込みマクロ`regexp'で行います。

     regexp(STRING, REGEXP, opt REPLACEMENT)

このマクロはREGEXPでSTRINGの中を検索します。 正規表現の構文はGNU
Emacsのものと同じです。 *Note Syntax of Regular Expressions:
(emacs)Regexps.

   REPLACEMENTを省略すると、`regexp'はSTRINGの中で
REGEXPに最初にマッチした部分のインデックスに展開されます。
REGEXPがSTRINGのどこにもマッチしない場合は-1に展開されます。

     regexp(`GNUs not Unix', `\<[a-z]\w+')
     =>5
     regexp(`GNUs not Unix', `\<Q\w*')
     =>-1

   REPLACEMENTを与えたときは、`regexp'はこの引数の値に展開されます。
このときREPLACEMENTに含まれる`\N'はREGEXP中の
N番目のカッコでくくられた部分式にマッチしたテキストに置き換えられ、
`\&'は正規表現全体にマッチしたテキストに置き換えられます。

     regexp(`GNUs not Unix', `\w\(\w+\)$', `*** \& *** \1 ***')
     =>*** Unix *** nix ***

   組み込みマクロ`regexp'は引数を与えたときだけ認識されます。


File: m4-ja.info,  Node: Substr,  Next: Translit,  Prev: Regexp,  Up: Text handling

10.4 部分文字列を抽出する
=========================

部分文字列は`substr'を使って抽出します。

     substr(STRING, FROM, opt LENGTH)

このマクロはSTRINGのインデックスFROMから始まるLENGTH文字分
の部分文字列に展開されます。
LENGTHを省いたときはSTRINGの最後までになります。
文字列の最初のインデックスは常に0です。

     substr(`gnus, gnats, and armadillos', 6)
     =>gnats, and armadillos
     substr(`gnus, gnats, and armadillos', 6, 5)
     =>gnats

   組み込みマクロ`substr'は引数を与えたときだけ認識されます。


File: m4-ja.info,  Node: Translit,  Next: Patsubst,  Prev: Substr,  Up: Text handling

10.5 文字の置換
===============

文字の置き換えは`translit'で行います。

     translit(STRING, CHARS, REPLACEMENT)

STRINGの各文字のうちCHARSに出て来る文字をそれぞれ
REPLACEMENT中で同じ位置にある文字に置き換えたものに展開されます。

   REPLACEMENTがCHARSより短いときは
余分な文字は展開後のテキストから削除されます。
REPLACEMENTを省略すると展開後のテキストは
STRINGからCHARSに含まれる文字すべてを削除したものになります。

   CHARSとREPLACEMENTのどちらにも文字範囲を含めることができます。
たとえば`a-z' (すべての小文字アルファベット)や `0-9'
(すべての数字)などです。
CHARSやREPLACEMENTにダッシュ`-'そのものを含めるときは
最初か最後に置いてください。

   範囲の最後の文字が最初の文字より`小さい'場合もエラーではありません。
そういうケースでは範囲が逆に広がります。
つまり`9-0'は文字列`9876543210'を意味します。

     translit(`GNUs not Unix', `A-Z')
     =>s not nix
     translit(`GNUs not Unix', `a-z', `A-Z')
     =>GNUS NOT UNIX
     translit(`GNUs not Unix', `A-Z', `z-a')
     =>tmfs not fnix

   最初の例は大文字のアルファベットをすべて削除します。
2番目の例は小文字を大文字に変換します。
3番目の例は大文字すべてを小文字に変換しながら`反転'させます。
使用頻度は最初の2つの例のほうがはるかに高いです。

   組み込みマクロ`translit'は引数を与えたときだけ認識されます。


File: m4-ja.info,  Node: Patsubst,  Next: Format,  Prev: Translit,  Up: Text handling

10.6 正規表現でテキストの置換をする
===================================

文字列の全置換（global substitution）は`patsubst'で行います。

     patsubst(STRING, REGEXP, opt REPLACEMENT)

STRING中でREGEXPにマッチする部分を探し、
それらをすべてREPLACEMENTに置換します。 正規表現の構文はGNU
Emacsのものと同じです。

   STRINGの中でREGEXPに適合するどの箇所にも含まれない部分は展開後の
テキストにそのまま残ります。 マッチする箇所が見つかるたびに、
サーチはそのマッチした箇所の終りから続行されます。
したがってSTRING内のある文字が2回置換されることは決してありません。
REGEXPが長さ0の文字列にマッチしたときは、
無限ループを避けるためサーチの開始位置は1文字前に進められます。

   置き換えが行われるときは、REPLACEMENTに含まれる`\N'を
REGEXP内のカッコでくくられたN番目の部分式にマッチしたテキスト
に置き換え、`\&'を正規表現全体にマッチしたテキストに置き換えたものが
展開後のテキストに挿入されます。

   引数REPLACEMENTは省略することができます。
そのときはREGEXPにマッチしたテキストは削除されます。

     patsubst(`GNUs not Unix', `^', `OBS: ')
     =>OBS: GNUs not Unix
     patsubst(`GNUs not Unix', `\<', `OBS: ')
     =>OBS: GNUs OBS: not OBS: Unix
     patsubst(`GNUs not Unix', `\w*', `(\&)')
     =>(GNUs)() (not)() (Unix)
     patsubst(`GNUs not Unix', `\w+', `(\&)')
     =>(GNUs) (not) (Unix)
     patsubst(`GNUs not Unix', `[A-Z][a-z]+')
     =>GN not

   次はもうすこし現実的な例です。
文字列の中にマクロ`upcase'と`downcase'の呼び出しを挿入することで、
単独の単語または文全体をキャピタライズ（capitalize）します。

     define(`upcase', `translit(`$*', `a-z', `A-Z')')dnl
     define(`downcase', `translit(`$*', `A-Z', `a-z')')dnl
     define(`capitalize1',
          `regexp(`$1', `^\(\w\)\(\w*\)', `upcase(`\1')`'downcase(`\2')')')dnl
     define(`capitalize',
          `patsubst(`$1', `\w+', `capitalize1(`\&')')')dnl
     capitalize(`GNUs not Unix')
     =>Gnus Not Unix

   組み込みマクロ`patsubst'は引数を与えたときだけ認識されます。


File: m4-ja.info,  Node: Format,  Prev: Patsubst,  Up: Text handling

10.7 書式付き出力
=================

書式付き出力は`format'を使って行うことができます。

     format(FORMAT-STRING, ...)

このマクロはC言語の関数`printf'とよく似た動作をします。
最初の引数は書式指定文字列で`%'指定を含めることができます。
`format'は展開されると書式付の文字列になります。

   2, 3の例を使って説明するのが一番でしょう。

     define(`foo', `The brown fox jumped over the lazy dog')
     =>
     format(`The string "%s" is %d characters long', foo, len(foo))
     =>The string "The brown fox jumped over the lazy dog" is 38 characters long

   *Note Loops::で定義されている`forloop'マクロを使って
表形式の出力をするときは`format'を次のように使うことができます。

     forloop(`i', 1, 10, `format(`%6d squared is %10d
     ', i, eval(i**2))')
     =>     1 squared is	    1
     =>     2 squared is	    4
     =>     3 squared is	    9
     =>     4 squared is	   16
     =>     5 squared is	   25
     =>     6 squared is	   36
     =>     7 squared is	   49
     =>     8 squared is	   64
     =>     9 squared is	   81
     =>    10 squared is	  100

   組み込みマクロ`format'はANSI Cの`printf'関数をモデルとしており、
次の標準的な`%'指定をサポートしています: `c', `s', `d', `o', `x', `X',
`u', `e', `E', `f'。 またフィールド幅と精度指定、モディファイア `+',
`-', ` ', `0', `#', `h', `l'をサポートしています。
`printf'の動作について更に詳しいことは C
ライブラリマニュアルを見てください。


File: m4-ja.info,  Node: Arithmetic,  Next: UNIX commands,  Prev: Text handling,  Up: Top

11 計算用の組み込みマクロ
*************************

`m4'にはCに似た文法の整数演算機構が組み込まれています。
また、単純なインクリメントとデクリメント操作のための組み込みマクロが手軽な
省略記法として用意されています。

* Menu:

* Incr::                        インクリメント演算子とデクリメント演算子
* Eval::                        整数式を計算する


File: m4-ja.info,  Node: Incr,  Next: Eval,  Prev: Arithmetic,  Up: Arithmetic

11.1 インクリメント演算子とデクリメント演算子
=============================================

整数のインクリメントとデクリメントは組み込みマクロ`incr'と`decr'
によってサポートされています。

     incr(NUMBER)
     decr(NUMBER)

NUMBERの数値を1だけ増やした値、または1だけ減らした値に展開されます。

     incr(4)
     =>5
     decr(7)
     =>6

   組み込みマクロ`incr'および`decr'は引数を与えたときだけ認識されます。


File: m4-ja.info,  Node: Eval,  Prev: Incr,  Up: Arithmetic

11.2 整数式を計算する
=====================

整数式は`eval'を使って計算します。

     eval(EXPRESSION, opt RADIX, opt WIDTH)

このマクロはEXPRESSIONの値に展開されます。

   式（expression）には次の演算子を含めることができます。
リストは優先順位の高い順に並んでいます。

`-'
     単項差（unary minus）

`**'
     累乗（exponentiation）

`*  /  %'
     積（multiplication）、商（division）、剰余（modulo）

`+  -'
     和（addition）、差（subtraction）

`<<  >>'
     左シフト（shift left）、右シフト（shift right）

`==  !=  >  >=  <  <='
     関係演算子（relational operator）

`!'
     論理否定（logical negation）

`~'
     ビットごとの論理否定（bitwise negation）

`&'
     ビットごとの論理積（bitwise and）

`^'
     ビットごとの排他的論理和（bitwise exclusive-or）

`|'
     ビットごとの論理和（bitwise or）

`&&'
     論理積（logical and）

`||'
     論理和（logical or）

   累乗（exponentiation）を除いたすべての演算子は左結合（left
associative）をします。

   `m4'の実装には`^'を累乗（exponentiation）演算子の代用として使うもの
が多くありますが、`^'をビットごとの排他的論理和（bitwise exclusive-or）
に使っている実装も多くあります。GNU `m4'では、かつて`^'は累乗を行う
演算子でしたが、動作の変更を行い、現在はビットごとの排他的論理和を行う
演算子になっています。

   特別な接頭辞（prefix）がついていない数字は10進数となります。
`0'のみの接頭辞は8進数の始まりを表します。
`0x'は16進数の始まりを表します。 `0b'は2進数の始まりを表します。
`0r'は1から36までの任意の基数で表現した数字の始まりを表します。
`0r'の後には10進数で表現した基数、コロン（:）、
および数値を表す数字列を続けなくてはなりません。
いずれの基数で表すにしても数字としては`0', `1', `2',
...を使い、`9'から上は`a', `b' ... `z'までを 数字として使います。
アルファベットの大文字と小文字は基数を表す接頭辞および数値を表す数字列のなかで
区別なく使用することができます。

   部分式をグループ化するために必要なときはカッコを使うことができます。
関係演算子は関係が真のときは`1'を返し、偽のときは`0'を返します。

   `eval'の使用例をいくつか次に挙げます。

     eval(-3 * 5)
     =>-15
     eval(index(`Hello world', `llo') >= 0)
     =>1
     define(`square', `eval(($1)**2)')
     =>
     square(9)
     =>81
     square(square(5)+1)
     =>676
     define(`foo', `666')
     =>
     eval(`foo'/6)
     error-->51.eval:14: m4: Bad expression in eval: foo/6
     =>
     eval(foo/6)
     =>111

最後から2番目の例が示しているように`eval'がマクロ名を勝手に展開することはありません。
例えそれらが有効な式(もしくは有効な式の一部)に展開されるにしてもです。
したがって全てのマクロは`eval'に渡される前に展開済である必要があります。

   RADIXを指定すると展開後のテキストではその基数が使われます。
デフォルトの基数は10です。
`eval'の結果は常に符号付き（signed）の値であると解釈されます。
引数WIDTHは最低限の出力幅を指定します。
展開後のテキストが要求された幅になるように
結果には0が埋め草（zero-padded）として付加されます。

     eval(666, 10)
     =>666
     eval(666, 11)
     =>556
     eval(666, 6)
     =>3030
     eval(666, 6, 10)
     =>0000003030
     eval(-666, 6, 10)
     =>-000003030

   RADIXは36より大きくてはいけないことに注意してください。

   組み込みマクロ`eval'は引数を与えたときだけ認識されます。


File: m4-ja.info,  Node: UNIX commands,  Next: Miscellaneous,  Prev: Arithmetic,  Up: Top

12 UNIXコマンド実行用の組み込みマクロ
*************************************

UNIXコマンドを`m4'内部から呼び出すための組み込みマクロが
`m4'にはいくつか存在します。

* Menu:

* Syscmd::                      単一のコマンドを実行する
* Esyscmd::                     コマンドの出力を読む
* Sysval::                      終了コード
* Maketemp::                    一時ファイル用の名前を生成する


File: m4-ja.info,  Node: Syscmd,  Next: Esyscmd,  Prev: UNIX commands,  Up: UNIX commands

12.1 単一のコマンドを実行する
=============================

`syscmd'を使えば任意のシェルコマンドを実行することができます。

     syscmd(SHELL-COMMAND)

シェルコマンドとしてSHELL-COMMANDを実行します。

   `syscmd'は展開後、SHELL-COMMANDからの出力には_ならず_に
消滅します。SHELL-COMMANDからの出力やエラーメッセージは
`m4'には読み込まれません。
コマンドの出力を処理する必要があるときは*Note
Esyscmd::を参照してください。

   コマンドの実行に先立ち、`m4'は自分の出力バッファをフラッシュします。
SHELL-COMMANDにおけるデフォルトの標準入力、標準出力、
および標準エラー出力は`m4'のものと同じです。

   `syscmd'は引数を与えたときだけ認識されます。


File: m4-ja.info,  Node: Esyscmd,  Next: Sysval,  Prev: Syscmd,  Up: UNIX commands

12.2 コマンドの出力を読む
=========================

UNIXコマンドの出力を`m4'に読み込ませたいときは
`esyscmd'を使ってください。

     esyscmd(SHELL-COMMAND)

このマクロはシェルコマンドSHELL-COMMANDの標準出力の内容に展開されます。

   `m4'はコマンドの実行に先立ち自分の出力バッファをフラッシュします。
SHELL-COMMANDのデフォルトの標準入力および標準エラー出力は
`m4'のものと同じになります。
SHELL-COMMANDのエラー出力は展開テキストの一部にはなりません  —
`m4'のエラー出力と一緒に出てくるでしょう。

   次の例ではGNU `m4'ディストリビューションの`checks'ディレクトリ
にいると仮定します。

     define(`vice', `esyscmd(grep Vice ../COPYING)')
     =>
     vice
     =>  Ty Coon, President of Vice
     =>

   `esyscmd'の展開によるテキストの後ろに改行がついている様子に
注意してください。

   `esyscmd'は引数を与えたときだけ認識されます。


File: m4-ja.info,  Node: Sysval,  Next: Maketemp,  Prev: Esyscmd,  Up: UNIX commands

12.3 終了コード
===============

シェルコマンドの実行が成功したか調べるときは `sysval'を使ってください。

     sysval

このマクロは`syscmd'や`esyscmd'で実行した最後のシェルコマンドの
終了ステータス（exit status）に展開されます。

     syscmd(`false')
     =>
     ifelse(sysval, 0, zero, non-zero)
     =>non-zero
     syscmd(`true')
     =>
     sysval
     =>0


File: m4-ja.info,  Node: Maketemp,  Prev: Sysval,  Up: UNIX commands

12.4 一時ファイル用の名前を生成
===============================

`syscmd'や`esyscmd'に指定されたコマンドが出力やその他の目的で
一時ファイルを必要とすることもあるでしょう。
一時ファイルの名前を生成するために組み込みマクロ`maketemp'が用意されています。

     maketemp(TEMPLATE)

このマクロはTEMPLATEを元に作られる、現時点で存在しないファイルの名前に
展開されます。TEMPLATEは文字列`XXXXXX'で終らなければなりません。
この6つの`X'はファイル名をユニークにするために`m4'のプロセスidを含む
何らかの文字列によって置き換えられます。

     maketemp(`/tmp/fooXXXXXX')
     =>/tmp/fooa07346
     maketemp(`/tmp/fooXXXXXX')
     =>/tmp/fooa07346

例にあるように`maketemp'を複数回呼び出すと同じ文字列に展開されることが
あります。これは選択の基準がファイルが存在するかどうかだからです。
最初のファイルが作成されていないうちに、`maketemp'を次に呼び出すと、
2つの`maketemp'マクロの呼び出しは同じ名前に展開される可能性があります。

   `maketemp'は引数を与えたときだけ認識されます。


File: m4-ja.info,  Node: Miscellaneous,  Next: Frozen files,  Prev: UNIX commands,  Up: Top

13 その他の組み込みマクロ
*************************

この章では、これまでのどの章にも分類できない様々な組み込みマクロを説明します。

* Menu:

* Errprint::                    エラーメッセージを表示する
* M4exit::                      m4を終了させる


File: m4-ja.info,  Node: Errprint,  Next: M4exit,  Prev: Miscellaneous,  Up: Miscellaneous

13.1 エラーメッセージを表示する
===============================

エラーメッセージは`errprint'を使って表示することができます。

     errprint(MESSAGE, ...)

このマクロが行うのはMESSAGEと残りの引数を標準エラー出力に表示する
ことだけです。

   `errprint'は展開されると消滅します。

     errprint(`Illegal arguments to forloop
     ')
     error-->Illegal arguments to forloop
     =>

   末尾の改行は自動的に印字され_ません_。したがって例にあるように
引数の一部として与えなければなりません。
(BSDフレーバーの`m4'は`errprint'呼び出しごとに改行を1つ末尾に
付加します。)

   エラーの場所を特定するためには、組み込みユーティリティマクロが2つ用意
されています。

     __file__
     __line__

これらは現在の入力ファイルの名前をクォートしたものと
そのファイル内での現在の入力行番号に展開されます。

     errprint(`m4:'__file__:__line__: `Input error
     ')
     error-->m4:56.errprint:2: Input error
     =>


File: m4-ja.info,  Node: M4exit,  Prev: Errprint,  Up: Miscellaneous

13.2 `m4'を終了させる
=====================

すべての入力を読み込んでしまう前に`m4'を終了したいときは
`m4exit'を使うことができます。

     m4exit(opt CODE)

このマクロはCODEを終了コード（exit code）として`m4'を終了させます。
CODEを省略したときは終了コードは0になります。

     define(`fatal_error', `errprint(`m4: '__file__: __line__`: fatal error: $*
     ')m4exit(1)')
     =>
     fatal_error(`This is a BAD one, buster')
     error-->m4: 57.m4exit: 5: fatal error: This is a BAD one, buster

   この例ではFATAL_ERRORマクロが呼び出された後、`m4'は終了コード1で
終了します。このマクロはエラー終了だけを行うためのものです、なぜなら通常の
終了手続き、例えば出力切替え先のテキスト（diverted text）の逆切替え
（undivert）や保存されているテキスト(*note M4wrap::)の再読み込みなどが
行われないからです。


File: m4-ja.info,  Node: Frozen files,  Next: Compatibility,  Prev: Miscellaneous,  Up: Top

14 凍結状態（frozen state）の高速ロード
***************************************

何百もの定義やその他の手間がかかる初期化をまとめた共通の基盤を土台として、
その上にさらに大きな`m4'アプリケーションをいくつも構築していくことが
できます。通常はその共通の基盤を1つ以上のファイルに格納しておいて`m4'を
起動するたびにユーザの入力ファイル名の前にそれらのファイル名を羅列するか、
ユーザの入力ファイルから`include'します。

   巨大なアプリケーションの共通基盤を何度も何度も繰り返し読み込むのは
時間がかかることでしょう。`m4'には大きな共通基盤を使う
アプリケーションの開始時間をスピードアップするための機構が用意されて
います。ユーザが次のコマンドラインを繰り返し使うとします。

     m4 base.m4 input.m4

ここで`input.m4'は起動のたびにいろいろな内容を持ち、
`base.m4'はかなり固定的な内容を持っているとします。
こういうときは、次のようにした方がいいでしょう。

     m4 -F base.m4f base.m4

このように一度実行しておき、必要になるたびに次のように実行します。

     m4 -R base.m4f input.m4

最初の`-F'オプションを含んでいる呼び出しは`base.m4'を読んで実行
することで、さまざまなアプリケーションマクロの定義やその他の初期化を
行います。入力ファイル`base.m4'の処理が完全に終ってから、 GNU
`m4'は凍結（"frozen"）ファイルを`base.m4f'として生成します。
このファイルは`m4'の内部状態のある種のスナップショットとなっています。

   後者の`-R'オプションを含んでいる呼び出しでは、どの入力ファイルが
読み込まれるよりも_前_に、`base.m4f'から`m4'のメモリの内部状態を
リロード（reload）しておくことができます。
このようにして、まっさらな状態の`m4'から始めるかわりに
前もって起動しておいたときの状態へと効率的に復帰したあとで入力を読み込み
ます。この例では`base.m4'を新たに読んだときと効果は同じですが、それを
ずっと速く行うことができます。

   `m4'の1回の起動で作ったり読み込んだりできる凍結ファイルはそれぞれ
1つだけです。 一度に2つの凍結ファイルの内容を回復することはできません。
しかし`-R'と`-F'オプションを同時につかうことで、凍結ファイルを
すこしずつ更新していくことはできます。例えば多少の注意を払う事で、次のコマンドは、

     m4 file1.m4 file2.m4 file3.m4 file4.m4

最終的にこれと同じ出力が段段と蓄積されていくような、次の一連の
コマンド列に分けることができるでしょう。

     m4 -F file1.m4f file1.m4
     m4 -R file1.m4f -F file2.m4f file2.m4
     m4 -R file2.m4f -F file3.m4f file3.m4
     m4 -R file3.m4f file4.m4

   多少の注意を払う必要があるというのは、これがどんな場合にもうまく動く
ようにするためのあらゆる対策がこうじられているわけではないからです。
とりわけ、マクロのトレース属性には対応していませんし`changeword'の
現在の設定に関してもそうです。`m4'のいくつかのオプションが1度目で
使用されて、次は使用されなかった場合にどのように作用するかも完全には検討
されていません。一方で`pushdef'された定義のスタックが正しく扱われる
ことは保証されています。また`undefine'された定義、組み込みマクロの
名前変更、引用符やコメント記号の変更についても同じく正しい動作が保証され
ています。

   `m4'の実行が凍結されるとき、実行終了時に起こる自動的な出力の
逆切替え（undiversion）は抑制されます。そのかわり全ての正の番号をもつ
出力切替え先の内容は凍結ファイルに保存されます。使用中の出力切替え先の
番号も伝えられます。

リロード（reload）しようとしている凍結ファイルがカレントディレクトリに
ある必要はありません。凍結ファイルを探す方法はインクルードファイル
（`include'）の場合と同じです。(*note Search Path::)

   凍結ファイルは複数のアーキテクチャで共有することができます。
1つのマシンで凍結ファイルを作り、それを他のマシンで使うときは2番目の
マシンで同じか新しいバージョンのGNU `m4'を使っているのなら確実です。
凍結ファイルは単純な(編集可能な)テキストファイルで、アルファベット大文字
で始まり改行文字(<NL>)で終る指令から成り立っています。指令があるはず
の場所に`#'があるときはコメント行の始まりとなり、空行とあわせて無視
されます。次の説明ではLENGTHは常に対応するSTRINGを参照します。
数字は常に10進数で表されます。指令の一覧です。

`V NUMBER <NL>'
     凍結ファイルのフォーマットを確認します。 NUMBERは1のはずです。

`C LENGTH1 , LENGTH2 <NL> STRING1 STRING2 <NL>'
     STRING1とSTRING2を開始コメントと終了コメント文字列として使います。

`Q LENGTH1 , LENGTH2 <NL> STRING1 STRING2 <NL>'
     STRING1とSTRING2を開始クォートと終了クォート文字列として使います。

`F LENGTH1 , LENGTH2 <NL> STRING1 STRING2 <NL>'
     `pushdef'を使い、STRING1が組み込みマクロとして名前STRING2を
     もつ関数に展開されるように定義します。

`T LENGTH1 , LENGTH2 <NL> STRING1 STRING2 <NL>'
     `pushdef'を使い、STRING1がテキストSTRING2に展開される
     ように定義します。

`D NUMBER, LENGTH <NL> STRING <NL>'
     番号NUMBERを出力切替え先番号として選択し、それを現在の出力切替え先
     （current diversion）にし、STRINGをその出力切替え先にコピーします。
     NUMBERは存在しない出力切替え先を表す負数にすることができます。
     現在の出力切替え先の選択だけをしたいときは、STRINGを空文字列にして、
     このコマンドを使います。出力切替え先番号NUMBERとして0を使うと、
     リロード時にSTRINGが標準出力へ出力されるでしょう、しかし`m4'内部
     からそのようにこのコマンドが生成されることはありません。



File: m4-ja.info,  Node: Compatibility,  Next: Concept index,  Prev: Frozen files,  Up: Top

15 他の版の`m4'との互換性
*************************

この章では`m4'の本実装とUNIXとりわけSystem V, Release 3における実装
との相違点を説明します。

* Menu:

* Extensions::                  GNU m4で拡張された機能
* Incompatibilities::           System V m4にあってGNU m4にない機能
* Other Incompat::              その他の非互換性


File: m4-ja.info,  Node: Extensions,  Next: Incompatibilities,  Prev: Compatibility,  Up: Compatibility

15.1 GNU `m4'で拡張された機能
=============================

本バージョンの`m4'にはSystem V `m4'に存在しない機能が いくつかあります。
これらの追加された機能はコマンドラインオプション`-G'を使うことで、
他のコマンドラインオプションによってくつがえされない限り、すべて抑制されます。

   * マクロの引数を表す`$'N表記において、
     Nは複数の数字を含むことができますが、 System V
     `m4'は1つの数字しか受けつけません。 これによりGNU
     `m4'ではマクロが引数を9つだけでなく
     いくつでも取ることができます。(*note Arguments::)

   * `include'と`sinclude'でインクルードされるファイルは、
     作業ディレクトリで見つからないときは指定されたサーチパスのなかから
     捜し出されます。サーチパスは`-I'オプションと環境引数`M4PATH'で
     指定します。(*note Search Path::)

   * `undivert'への引数は数字以外でもよく、
     そのときはその名前を持つファイルを解釈しないまま出力に含めます。
     (*note Undivert::)

   * 書式付き出力が、Cのライブラリ関数`printf'をモデルとした
     組み込みマクロ`format'を通じてサポートされています。(*note
     Format::)

   * 正規表現を使った探索とテキストの置換が 組み込みマクロ`regexp'
     (*note Regexp::)と `patsubst' (*note
     Patsubst::)によってサポートされています。

   * シェルコマンドの出力を`esyscmd' (*note Esyscmd::)で
     `m4'に読み込むことができます。

   * `builtin' (*note Builtin::)により任意の組み込みマクロへ
     間接的にアクセスできます。

   * `indir' (*note Indir::)を通じてマクロを間接的に呼び出せます。

   * 組み込みマクロ`__file__'と`__line__' (*note Errprint::)
     を通じて現在の入力ファイルの名前と現在の入力行番号へアクセスできます。

   * `dumpdef'とマクロトレースの出力書式を `debugmode' (*note Debug
     Levels::)で制御することができます。

   * トレースとデバッグの出力先を`debugfile' (*note Debug Output::)
     で制御可能です。

   上記の拡張に加えGNU `m4'には次のコマンドラインオプションが
実装されています — `-F', `-G', `-I', `-L', `-R', `-V', `-W', `-d',
`-l', `-o', `-t'。 これらオプションの説明は*Note Invoking
m4::を参照してください。

   またGNU `m4'のデバッグとトレース機構は
他バージョンの`m4'にあるものより遥かに大規模です。


File: m4-ja.info,  Node: Incompatibilities,  Next: Other Incompat,  Prev: Extensions,  Up: Compatibility

15.2 System V `m4' にあってGNU `m4'にない機能
=============================================

System Vバージョンの`m4'にはGNU `m4'にまだ実装されていない
機能がいくつかあります。

   * System V `m4'は`defn'への複数の引数をサポートしています。 GNU
     `m4'はこれを実装していません。
     この機能の有用性が筆者には不明確です。


File: m4-ja.info,  Node: Other Incompat,  Prev: Incompatibilities,  Up: Compatibility

15.3 その他の非互換性
=====================

System Vバージョンの`m4'と本実装との間には他にいくつか非互換な部分
があります。

   *
     テキストが出力切替え先（diversion）に送られるときのときの同期行の実装が
     GNU `m4'とSystem V `m4'では異なります。 GNU
     `m4'はテキストが出力切替え先に送られるときに同期行を出力しますが、
     System V
     `m4'ではこれが、出力切替え先のテキストが引き戻されるときになります。

     問題は出力切替え先に送られる、または送られていたテキストに
     どの行番号とファイル名をつけ加えるかです。 System V
     `m4'は出力切替え先に送られていたすべてのテキストが
     `undivert'の呼び出しを含むソース行によって生成されたと見なしますが、
     GNU
     `m4'は出力切替え先に送られる時にテキストが生成されたと見なします。

     筆者は同期行オプションを使うのは大抵`m4'をコンパイラのフロントエンド
     として使うときだと考えます。
     もし出力切替え先に送られた行がコンパイラエラーを引き起こしたら、
     エラーメッセージは出力切替え先のテキストが挿入しなおされた場所ではなく、
     出力切替え先に送られた場所をおそらく指し示すべきでしょう。

   * GNU `m4'は自己参照的な定義を防ごうとはしません。

          define(`x', `x')
          define(`x', `x ')

     `x'が`x'を返すように定義することに、本質的に間違っているところは
     ありません。
     間違っているのはクォートされていない`x'を展開することです。
     他のプログラミング言語で変数を使うのと同じように、
     `m4'で文字列を保持するためにマクロ使い、
     さらにそれを次のようにチェックする人もいるでしょう:

          ifelse(defn(`HOLDER'), `VALUE', ...)

     このような場合、マクロが自分自身の名前を保持するのを禁止するのは
     余計なお世話でしょう。 もちろん、これはGNU
     `m4'ユーザが自分で首をくくるためのロープを
     放置しておくことにはなります!  再走査によるハング（hang）は、
     伝統的なプログラミング言語において無限ループに対するときのような、
     注意深いプログラミングによって避けることができるでしょう。

   * GNU `m4'は`-G'オプション無しだと、
     `__gnu__'が空行に展開されるように定義します。

     UNIX システム上においてGNU `m4'は`-G'オプションをつけると
     マクロ`__unix__'、つけないときはマクロ`unix'を定義します。
     両方とも空文字列に展開されます。


File: m4-ja.info,  Node: Concept index,  Next: Macro index,  Prev: Compatibility,  Up: Top

Concept index
*************

 [index ]
* Menu:

* Arguments to macros:                   Arguments.           (line   6)
* arguments to macros:                   Macro Arguments.     (line   6)
* arguments to macros, special:          Pseudo Arguments.    (line   6)
* arguments, quoted macro:               Quoting Arguments.   (line   6)
* arithmetic:                            Arithmetic.          (line   6)
* builtins, indirect call of:            Builtin.             (line   6)
* call of builtins, indirect:            Builtin.             (line   6)
* call of macros, indirect:              Indir.               (line   6)
* changing comment delimiters:           Changecom.           (line   6)
* changing the quote delimiters:         Changequote.         (line   6)
* characters, translating:               Translit.            (line   6)
* command line, filenames on the:        Invoking m4.         (line 182)
* command line, macro definitions on the: Invoking m4.        (line 148)
* command line, options:                 Invoking m4.         (line  10)
* commands, exit code from UNIX:         Sysval.              (line   6)
* commands, running UNIX:                UNIX commands.       (line   6)
* comment delimiters, changing:          Changecom.           (line   6)
* comments:                              Comments.            (line   6)
* comments, copied to output:            Changecom.           (line  30)
* comparing strings:                     Ifelse.              (line   6)
* compatibility:                         Compatibility.       (line   6)
* conditionals:                          Ifdef.               (line   6)
* controlling debugging output:          Debug Levels.        (line   6)
* counting loops:                        Loops.               (line  43)
* debugging output, controlling:         Debug Levels.        (line   6)
* debugging output, saving:              Debug Output.        (line   6)
* decrement operator:                    Incr.                (line   6)
* defining new macros:                   Definitions.         (line   6)
* definitions, displaying macro:         Dumpdef.             (line   6)
* deleting macros:                       Undefine.            (line   6)
* deleting whitespace in input:          Dnl.                 (line   6)
* discarding diverted text:              Cleardiv.            (line   6)
* displaying macro definitions:          Dumpdef.             (line   6)
* diversion numbers:                     Divnum.              (line   6)
* diverted text, discarding:             Cleardiv.            (line   6)
* diverting output to files:             Divert.              (line   6)
* dumping into frozen file:              Frozen files.        (line   6)
* error messages, printing:              Errprint.            (line   6)
* evaluation, of integer expressions:    Eval.                (line   6)
* executing UNIX commands:               UNIX commands.       (line   6)
* exit code from UNIX commands:          Sysval.              (line   6)
* exiting from m4:                       M4exit.              (line   6)
* expansion of macros:                   Macro expansion.     (line   6)
* expansion, tracing macro:              Trace.               (line   6)
* expressions, evaluation of integer:    Eval.                (line   6)
* extracting substrings:                 Substr.              (line   6)
* fast loading of frozen files:          Frozen files.        (line   6)
* file inclusion <1>:                    File Inclusion.      (line   6)
* file inclusion:                        Undivert.            (line  57)
* filenames, on the command line:        Invoking m4.         (line 182)
* files, diverting output to:            Divert.              (line   6)
* files, names of temporary:             Maketemp.            (line   6)
* forloops:                              Loops.               (line  43)
* formatted output:                      Format.              (line   6)
* frozen files for fast loading:         Frozen files.        (line   6)
* GNU extensions <1>:                    Regexp.              (line   6)
* GNU extensions <2>:                    Indir.               (line   6)
* GNU extensions <3>:                    Esyscmd.             (line   6)
* GNU extensions <4>:                    Format.              (line   6)
* GNU extensions <5>:                    Arguments.           (line  28)
* GNU extensions <6>:                    Extensions.          (line   6)
* GNU extensions <7>:                    Debug Levels.        (line  60)
* GNU extensions <8>:                    Patsubst.            (line   6)
* GNU extensions <9>:                    Debug Output.        (line   6)
* GNU extensions <10>:                   Frozen files.        (line   6)
* GNU extensions <11>:                   Search Path.         (line   6)
* GNU extensions <12>:                   Undivert.            (line  57)
* GNU extensions:                        Builtin.             (line   6)
* GNU拡張 <1>:                           Extensions.          (line   6)
* GNU拡張 <2>:                           Frozen files.        (line   6)
* GNU拡張 <3>:                           Esyscmd.             (line   6)
* GNU拡張 <4>:                           Format.              (line   6)
* GNU拡張 <5>:                           Patsubst.            (line   6)
* GNU拡張 <6>:                           Regexp.              (line   6)
* GNU拡張 <7>:                           Undivert.            (line  57)
* GNU拡張 <8>:                           Search Path.         (line   6)
* GNU拡張 <9>:                           Debug Output.        (line   6)
* GNU拡張 <10>:                          Debug Levels.        (line  60)
* GNU拡張 <11>:                          Builtin.             (line   6)
* GNU拡張 <12>:                          Indir.               (line   6)
* GNU拡張:                               Arguments.           (line  28)
* included files, search path for:       Search Path.         (line   6)
* inclusion, of files <1>:               File Inclusion.      (line   6)
* inclusion, of files:                   Undivert.            (line  57)
* increment operator:                    Incr.                (line   6)
* indirect call of builtins:             Builtin.             (line   6)
* indirect call of macros:               Indir.               (line   6)
* initialization, frozen states:         Frozen files.        (line   6)
* input tokens:                          Syntax.              (line   6)
* input, saving:                         M4wrap.              (line   6)
* integer arithmetic:                    Arithmetic.          (line   6)
* integer expression evaluation:         Eval.                (line   6)
* length of strings:                     Len.                 (line   6)
* lexical structure of words:            Changeword.          (line   6)
* loops:                                 Loops.               (line  11)
* loops, counting:                       Loops.               (line  43)
* m4を終了させる:                        M4exit.              (line   6)
* macro definitions, on the command line: Invoking m4.        (line 148)
* macro expansion, tracing:              Trace.               (line   6)
* macro invocation:                      Invocation.          (line   6)
* macros, arguments to <1>:              Arguments.           (line   6)
* macros, arguments to:                  Macro Arguments.     (line   6)
* macros, displaying definitions:        Dumpdef.             (line   6)
* macros, expansion of:                  Macro expansion.     (line   6)
* macros, how to define new:             Definitions.         (line   6)
* macros, how to delete:                 Undefine.            (line   6)
* macros, how to rename:                 Defn.                (line   6)
* macros, indirect call of:              Indir.               (line   6)
* macros, quoted arguments to:           Quoting Arguments.   (line   6)
* macros, recursive:                     Loops.               (line   6)
* macros, special arguments to:          Pseudo Arguments.    (line   6)
* macros, temporary redefinition of:     Pushdef.             (line   6)
* messages, printing error:              Errprint.            (line   6)
* multibranches:                         Ifelse.              (line  34)
* names:                                 Names.               (line   6)
* options, command line:                 Invoking m4.         (line  10)
* output, diverting to files:            Divert.              (line   6)
* output, formatted:                     Format.              (line   6)
* output, saving debugging:              Debug Output.        (line   6)
* pattern substitution:                  Patsubst.            (line   6)
* printing error messages:               Errprint.            (line   6)
* quote delimiters, changing the:        Changequote.         (line   6)
* quoted macro arguments:                Quoting Arguments.   (line   6)
* quoted string:                         Quoted strings.      (line   6)
* recursive macros:                      Loops.               (line   6)
* redefinition of macros, temporary:     Pushdef.             (line   6)
* regular expressions <1>:               Patsubst.            (line   6)
* regular expressions:                   Regexp.              (line   6)
* reloading a frozen file:               Frozen files.        (line   6)
* renaming macros:                       Defn.                (line   6)
* running UNIX commands:                 UNIX commands.       (line   6)
* saving debugging output:               Debug Output.        (line   6)
* saving input:                          M4wrap.              (line   6)
* search path for included files:        Search Path.         (line   6)
* special arguments to macros:           Pseudo Arguments.    (line   6)
* strings, length of:                    Len.                 (line   6)
* substitution by regular expression:    Patsubst.            (line   6)
* substrings, extracting:                Substr.              (line   6)
* temporary filenames:                   Maketemp.            (line   6)
* temporary redefinition of macros:      Pushdef.             (line   6)
* tokens:                                Syntax.              (line   6)
* tracing macro expansion:               Trace.               (line   6)
* translating characters:                Translit.            (line   6)
* undefining macros:                     Undefine.            (line   6)
* UNIX commands, exit code from:         Sysval.              (line   6)
* UNIX commands, running:                UNIX commands.       (line   6)
* UNIXコマンドの実行:                    UNIX commands.       (line   6)
* UNIXコマンドの終了コード:              Sysval.              (line   6)
* words, lexical structure of:           Changeword.          (line   6)
* インクリメント演算子:                  Incr.                (line   6)
* インクルードファイルのサーチパス:      Search Path.         (line   6)
* エラーメッセージの表示:                Errprint.            (line   6)
* クォートされたマクロの引数:            Quoting Arguments.   (line   6)
* クォートされた文字列:                  Quoted strings.      (line   6)
* コメント:                              Comments.            (line   6)
* コメントデリミタを変更:                Changecom.           (line   6)
* コマンドライン, オプション:            Invoking m4.         (line  10)
* コマンドライン上でマクロを定義:        Invoking m4.         (line 148)
* コマンドライン上のファイル名:          Invoking m4.         (line 182)
* デクリメント演算子:                    Incr.                (line   6)
* デバッグ出力の制御:                    Debug Levels.        (line   6)
* デバッグ出力を保存:                    Debug Output.        (line   6)
* トークン:                              Syntax.              (line   6)
* ループ:                                Loops.               (line  11)
* ループの回数を数える:                  Loops.               (line  43)
* パターンマッチ:                        Patsubst.            (line   6)
* ファイルのインクルード <1>:            File Inclusion.      (line   6)
* ファイルのインクルード:                Undivert.            (line  57)
* マクロの引数:                          Macro Arguments.     (line   6)
* マクロの呼び出し:                      Invocation.          (line   6)
* マクロの定義を表示:                    Dumpdef.             (line   6)
* マクロの展開:                          Macro expansion.     (line   6)
* マクロの展開をトレース:                Trace.               (line   6)
* マクロの特殊な引数:                    Pseudo Arguments.    (line   6)
* マクロの名前をかえる方法:              Defn.                (line   6)
* マクロを一時的に再定義:                Pushdef.             (line   6)
* マクロを間接的に呼び出す:              Indir.               (line   6)
* マクロを削除する方法:                  Undefine.            (line   6)
* マクロを新しく定義する方法:            Definitions.         (line   6)
* マクロへの引数 <1>:                    Macro Arguments.     (line   6)
* マクロへの引数:                        Arguments.           (line   6)
* マクロ呼び出し:                        Invocation.          (line   6)
* 一時ファイル名:                        Maketemp.            (line   6)
* 引数:                                  Macro Arguments.     (line   6)
* 引用符で囲まれた文字列:                Quoted strings.      (line   6)
* 引用符で括られた文字列:                Quoted strings.      (line   6)
* 引用符を変更:                          Changequote.         (line   6)
* 計算, 演算:                            Arithmetic.          (line   6)
* 互換性:                                Compatibility.       (line   6)
* 再帰的なマクロ:                        Loops.               (line   6)
* 出力にコピーされるコメント:            Changecom.           (line  30)
* 出力をファイルへ切替える（divert）:    Divert.              (line   6)
* 出力切替え先のテキストを破棄する:      Cleardiv.            (line   6)
* 出力切替え先番号（diversion number）:  Divnum.              (line   6)
* 書式付き出力:                          Format.              (line   6)
* 条件構文:                              Ifdef.               (line   6)
* 整数演算:                              Arithmetic.          (line   6)
* 整数式の計算:                          Eval.                (line   6)
* 整数式の評価:                          Eval.                (line   6)
* 正規表現:                              Regexp.              (line   6)
* 正規表現で置換:                        Patsubst.            (line   6)
* 組み込みマクロを間接的に呼び出す:      Builtin.             (line   6)
* 多重分岐:                              Ifelse.              (line  34)
* 単語の字句構造:                        Changeword.          (line   6)
* 凍結状態（frozen state）の高速ロード:  Frozen files.        (line   6)
* 入力の空白を削除:                      Dnl.                 (line   6)
* 入力を保存:                            M4wrap.              (line   6)
* 入力トークン:                          Syntax.              (line   6)
* 部分文字列を切り出す:                  Substr.              (line   6)
* 部分文字列を抽出:                      Substr.              (line   6)
* 文字の置き換え:                        Translit.            (line   6)
* 文字の置換:                            Translit.            (line   6)
* 文字列の長さ:                          Len.                 (line   6)
* 文字列の比較:                          Ifelse.              (line   6)
* 名前:                                  Names.               (line   6)


File: m4-ja.info,  Node: Macro index,  Prev: Concept index,  Up: Top

Macro index
***********

参照先は組み込みマクロが最初に紹介されている場所だけです。
索引では始めや終りに`__'のある名前はそれらが取り除かれています。

 [index ]
* Menu:

* builtin:                               Builtin.              (line  6)
* changecom:                             Changecom.            (line  6)
* changequote:                           Changequote.          (line  6)
* changeword:                            Changeword.           (line  6)
* debugfile:                             Debug Output.         (line  6)
* debugmode:                             Debug Levels.         (line 60)
* decr:                                  Incr.                 (line  6)
* define:                                Define.               (line  6)
* defn:                                  Defn.                 (line  6)
* divert:                                Divert.               (line  6)
* divnum:                                Divnum.               (line  6)
* dnl:                                   Dnl.                  (line  6)
* dumpdef:                               Dumpdef.              (line  6)
* errprint:                              Errprint.             (line  6)
* esyscmd:                               Esyscmd.              (line  6)
* eval:                                  Eval.                 (line  6)
* file:                                  Errprint.             (line 28)
* format:                                Format.               (line  6)
* gnu:                                   Other Incompat.       (line 50)
* ifdef:                                 Ifdef.                (line  6)
* ifelse:                                Ifelse.               (line  6)
* include:                               Include.              (line  6)
* incr:                                  Incr.                 (line  6)
* index:                                 Index.                (line  6)
* indir:                                 Indir.                (line  6)
* len:                                   Len.                  (line  6)
* line:                                  Errprint.             (line 28)
* m4exit:                                M4exit.               (line  6)
* m4wrap:                                M4wrap.               (line  6)
* maketemp:                              Maketemp.             (line  6)
* patsubst:                              Patsubst.             (line  6)
* popdef:                                Pushdef.              (line  6)
* pushdef:                               Pushdef.              (line  6)
* regexp:                                Regexp.               (line  6)
* shift:                                 Loops.                (line 13)
* sinclude:                              Include.              (line  6)
* substr:                                Substr.               (line  6)
* syscmd:                                Syscmd.               (line  6)
* sysval:                                Sysval.               (line  6)
* traceoff:                              Trace.                (line  6)
* traceon:                               Trace.                (line  6)
* translit:                              Translit.             (line  6)
* undefine:                              Undefine.             (line  6)
* undivert:                              Undivert.             (line  6)
* unix:                                  Other Incompat.       (line 53)



Tag Table:
Node: Top987
Node: Preliminaries7172
Node: Intro7782
Node: History9476
Node: Invoking m410423
Node: Bugs17310
Node: Manual18574
Node: Syntax19818
Node: Names20446
Node: Quoted strings20886
Node: Other tokens21585
Node: Comments21854
Node: Macros22628
Node: Invocation23113
Node: Inhibiting Invocation23917
Node: Macro Arguments27077
Node: Quoting Arguments28259
Node: Macro expansion29112
Node: Definitions29762
Node: Define30504
Node: Arguments31329
Node: Pseudo Arguments32775
Node: Undefine34637
Node: Defn35299
Node: Pushdef36443
Node: Indir38168
Node: Builtin38932
Node: Conditionals39375
Node: Ifdef40038
Node: Ifelse40826
Node: Loops42503
Node: Debugging45633
Node: Dumpdef46208
Node: Trace47013
Node: Debug Levels48357
Node: Debug Output50747
Node: Input Control51314
Node: Dnl51884
Node: Changequote52887
Node: Changecom54236
Node: Changeword55638
Node: M4wrap58984
Node: File Inclusion60228
Node: Include60615
Node: Search Path62620
Node: Diversions63472
Node: Divert64733
Node: Undivert65895
Node: Divnum67990
Node: Cleardiv68601
Node: Text handling69683
Node: Len70344
Node: Index70707
Node: Regexp71289
Node: Substr72336
Node: Translit72936
Node: Patsubst74296
Node: Format76326
Node: Arithmetic77802
Node: Incr78245
Node: Eval78742
Node: UNIX commands81976
Node: Syscmd82459
Node: Esyscmd83194
Node: Sysval84113
Node: Maketemp84565
Node: Miscellaneous85601
Node: Errprint85945
Node: M4exit86939
Node: Frozen files87811
Node: Compatibility92854
Node: Extensions93278
Node: Incompatibilities95491
Node: Other Incompat95925
Node: Concept index98186
Node: Macro index114026

End Tag Table
