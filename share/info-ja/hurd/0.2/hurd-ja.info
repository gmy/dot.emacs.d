-*- coding: utf-8 -*-
INFO-DIR-SECTION Kernel
START-INFO-DIR-ENTRY
* Hurd: (hurd).                 Using and programming the Hurd kernel servers.
END-INFO-DIR-ENTRY

   Copyright (C) 1994-1998 Free Software Foundation, Inc.

   Permission is granted to make and distribute verbatim copies of this
manual provided the copyright notice and this permission notice are
preserved on all copies.

   Permission is granted to copy and distribute modified versions of
this manual under the conditions for verbatim copying, provided also
that the entire resulting derived work is distributed under the terms
of a permission notice identical to this one.

   Permission is granted to copy and distribute translations of this
manual into another language, under the above conditions for modified
versions.


File: hurd-ja.info,  Node: Top,  Next: Introduction,  Up: (dir)

The GNU Hurd
************

This file documents the GNU Hurd kernel component.  This edition of the
documentation was last updated for version 0.2 of the Hurd.

* Menu:

* Introduction::                このマニュアルの使い方。
* Installing::                  Setting up Hurd software on your computer.
* Bootstrap::                   Turning a computer into a Hurd machine.
* Foundations::                 Hurdを通して使われている基本的な特徴。
* Input and Output::            I/Oチャネルの読み書き。
* Files::                       Regular file and directory nodes.
* Special Files::               Files with unusual Unix-compatible semantics.
* Stores::                      Generalized units of storage.
* Stored Filesystems::          物理的なメディアのためのファイルシステム。
* Twisted Filesystems::         既存データに対する新しい階層の提供。
* Distributed Filesystems::     異なるマシン間でのファイル共有。
* Networking::                  Interconnecting with other machines.
* Terminal Handling::           Helping people interact with the Hurd.
* Running Programs::            Program execution and process management.
* Authentication::              Verifying user and server privileges.
* Index::                       Guide to concepts, functions, and files.

 --- The Detailed Node Listing ---

Introduction

* Audience::                    このマニュアルが書かれる対象の人々。
* Features::                    Hurdをインストールし使用する理由。
* Overview::                    Hurdの基本的なアーキテクチャ。
* History::                     Hurdがいかにして生まれたか。
* Copying::                     Hurdはフリー・ソフトウェアである。

Installing

* Binary Distributions::        Obtaining ready-to-run GNU distributions.
* Cross-Compiling::             Building GNU from its source code.

Bootstrap

* Bootloader::                  Starting the microkernel, or other OSes.
* Server Bootstrap::            Waking up the Hurd.
* Shutdown::                    Letting the Hurd get some rest.

Server Bootstrap

* Invoking serverboot::         Starting a set of interdependent servers.
* Boot Scripts::                Describing server bootstrap relationships.
* Invoking boot::               Running a Hurd under another Hurd.

Foundations

* Threads Library::             あらゆるHurdサーバとライブラリは
                                マルチスレッド化されている。
* Microkernel Object Library::  マイクロカーネル・オブジェクト・モデル(MOM)。
* Ports Library::               サーバのport受信権の管理。
* Integer Hash Library::        整数を鍵としたハッシュ表。
* Misc Library::                GNU Cライブラリにすぐに入るもの。
* Bug Address Library::         Hurdのバグを報告する場所。

Ports Library

* Buckets and Classes::         port編成の基本単位。
* Port Rights::                 port権の`libports'との間での移動。
* Port Metadata::               port関連の情報の管理。
* Port References::             漏曳や欠失に対する保護。
* RPC Management::              RPC操作のロックと割り込み。

Input and Output

* Iohelp Library::              I/Oの認証とロックの管理。
* Pager Library::               マルチスレッド化された外部ページャの実装。
* I/O Interface::               RPCに基く入出力チャネル。

Iohelp Library

* I/O Users::                   ユーザ認証の管理。
* Conch Management::            非難された共有I/Oの実装。

Pager Library

* Pager Management::            外部ページャへの高水準なインターフェース。
* Pager Callbacks::             ユーザが定義しなければならない関数。

I/O Interface

* I/O Object Ports::            I/Oオブジェクトへのポートの働き方。
* Simple Operations::           read、writeやseek。
* Open Modes::                  操作の一部に影響する状態ビット。
* Asynchronous I/O::            I/Oが可能な時の通知のされ方。
* Information Queries::         `io_stat'と`io_server_version'
                                  の実装法。
* Mapped Data::                 I/Oオブジェクトのデータを参照するメモリ・
                                  オブジェクトの入手。

Files

* Translators::                 Extending the Hurd filesystem hierarchy.
* Trivfs Library::              Implementing single-file translators.
* Fshelp Library::              Miscellaneous generic filesystem routines.
* File Interface::              File ports implement the file interface.
* Filesystem Interface::        Translator control interface.

Translators

* Invoking settrans::           Declaring how a node should be translated.
* Invoking showtrans::          Displaying how nodes are translated.
* Invoking mount::              Unix-compatible active filesystem translators.
* Invoking fsysopts::           Modifying translation parameters at runtime.

Trivfs Library

* Trivfs Startup::              Writing a simple trivfs-based translator.
* Trivfs Callbacks::            Mandatory user-defined trivfs functions.
* Trivfs Options::              Optional user-defined trivfs functions.
* Trivfs Ports::                Managing control and protid ports.

Fshelp Library

* Passive Translator Linkage::  Invoking passive translators.
* Active Translator Linkage::   Managing active translators.
* Fshelp Locking::              Implementing file locking.
* Fshelp Permissions::          Standard file access permission policies.
* Fshelp Misc::                 Useful standalone routines.

File Interface

* File Overview::               Basic concepts for the file interface.
* Changing Status::             Changing the owner (etc.) of a file.
* Program Execution::           Executing files.
* File Locking::                Implementing the `flock' call.
* File Frobbing::               Other active calls on files.
* Opening Files::               Looking up files in directories.
* Modifying Directories::       Creating and deleting nodes.
* Notifications::               File and directory change callbacks.
* File Translators::            How to set and get translators.

Stores

* Store Library::               An abstract interface to storage systems.

Store Library

* Store Arguments::             Parsing store command-line arguments.
* Store Management::            Creating and manipulating stores.
* Store I/O::                   Reading and writing data to stores.
* Store Classes::               Ready-to-use storage backends.
* Store RPC Encoding::          Transferring store descriptors via RPC.

Stored Filesystems

* Repairing Filesystems::       軽いファイルシステム・クラッシュからの回復。
* Linux Extended 2 FS::         ポピュラーなLinuxファイルシステム・フォーマット。
* BSD Unix FS::                 BSD Unix 4.xのFast File System。
* ISO-9660 CD-ROM FS::          標準的なCD-ROMフォーマット。
* Diskfs Library::              新しいファイルシステム・サーバの実装。

Diskfs Library

* Diskfs Startup::              stored（FIXME-J:ストアード？）ファイルシステムの初期化。
* Diskfs Arguments::            コマンドライン引数の解析。
* Diskfs Globals::              グローバルな振る舞いの変更。
* Diskfs Node Management::      割り当て、リファレンス・カウンティング、I/O、
                                  キャッシング、その他のディスク・ノード・ルーチン。
* Diskfs Callbacks::            必須のユーザ定義diskfs関数。
* Diskfs Options::              任意選択のユーザ定義diskfs関数。
* Diskfs Internals::            diskfsの細部の再実装。

Distributed Filesystems

* File Transfer Protocol::      FTPベースの分散ファイルシステム。
* Network File System::         SunのNFS: 出来は悪いが、よく使われているファイルシステム。

File Transfer Protocol

* FTP Connection Library::      Managing remote FTP server connections.

Networking

* Socket Interface::            Network communication I/O protocol.

Authentication

* Auth Interface::              Auth ports implement the auth interface.

Auth Interface

* Auth Protocol::               Bidirectional authentication.


File: hurd-ja.info,  Node: Introduction,  Next: Installing,  Prev: Top,  Up: Top

1 導入
******

GNU Hurd(1)はGNUプロジェクトがUnixカーネルを置き換える
ものである。HurdはMachマイクロカーネルの上で動作するサーバの集まりであり、
通常Unixカーネルや(Linuxのような)似たようなカーネルによって実装されてい
る、ファイル・システム、ネットワーク・プロトコル、ファイル・アクセス制御
やその他の機能を実装している。

* Menu:

* Audience::                    このマニュアルが書かれる対象の人々。
* Features::                    Hurdをインストールし使用する理由。
* Overview::                    Hurdの基本的なアーキテクチャ。
* History::                     Hurdがいかにして生まれたか。
* Copying::                     Hurdはフリー・ソフトウェアである。

   ---------- Footnotes ----------

   (1) "Hurd"という名前は、"Hird of Unix-Replacing
Daemons"を表す。"Hird"という名前は、"Hurd of Interfaces Representing
Depth"を表す。


File: hurd-ja.info,  Node: Audience,  Next: Features,  Up: Introduction

1.1 読者
========

このマニュアルはHurdを使ったり、管理したり、プログラミングしたりすること
に興味を持っているすべての人に役立つようにもくろまれている。

もしあなたがエンド・ユーザで、Hurdを走らせるための助けを探しているなら、
このマニュアルの最初の数章でHurdワークステーションをインストールし、開始
し、そしてシャットダウンするための基本的な部分を記述している。もし特定の
プログラムの助けが必要なら、このマニュアルを使う最善の方法は、索引からそ
れを見付けて直接その適切な節に向かうことである。また、`PROGRAM
--help'を走らせてみると良い。それはPROGRAMに対する簡潔な使用法のメッ
セージを表示するだろう (*note Foundations::)。

このマニュアルの残りはHurdサーバとそれらの実装に関する技術的な議論であり、
Hurdの変更方法を学びたいと思うまで役には立たないだろう。

このマニュアルはサブシステムに従って構成されており、それぞれの章はそのサ
ブシステムに関連するユーティリティやサーバの説明から始まっている。もしあ
なたがシステム管理者で、例えば、Hurdネットワーキング・サブシステムについ
てもっと学びたいなら、ネットワーキングの章 (*note Networking::)まで飛ば
して、関連したユーティリティやサーバを拾い読みして良い。

Hurdサーバの変更の仕方や新しいサーバの書き方に興味があるプログラマはHurd
が移植されているマイクロカーネル(現在はGNU Machだけ)について学び、
*Note
Foundations::を読むことから始めるべきだ。そして、すでに存在するサー
バやそれらが使用するライブラリについて読むことで、あなたが関心のあるサブ
システムに習熟するべきだ。この時点で、存在するHurdサーバのソース・コード
を勉強し、それらがHurdライブラリをいかにして使用しているかを理解できるは
ずだ。

熟練の最終段階はHurdライブラリが実装するRPC(1)インターフェースを学ぶことだ。それぞ
れの章の最後の節では、そのサブシステムで使われているどのHurdインターフェー
スについても記述している。与えられたサブシステムを理解してしまったなら、
Hurdライブラリを改善し、あなた自身のインターフェースを設計し、新しいサブ
システムを実装するのに、あなたは適任の立場にいるだろう。

   ---------- Footnotes ----------

   (1) Remote Procedure
Call。もし訊く必要があるなら、あなたはHurdプログラミングを出来るようにな
る前に作業を予定してしまっている。


File: hurd-ja.info,  Node: Features,  Next: Overview,  Prev: Audience,  Up: Introduction

1.2 特徴
========

Hurdは地球に知られている最も進歩したオペレーティング・システムでは(まだ)
ないが、たくさんの誘惑的な特徴を持っている。

それはフリー・ソフトウェアである
     誰もがそれをGNU General Public License (*note
     Copying::)の下で使用し、変
     更し、再配布することができる。HurdはGNUシステムの一部であり、それはGPLで
     認可された完全なオペレーティング・システムである。

それは互換性がある
     Hurdは慣れ親しんだプログラミングやユーザ環境を提供する。どの点に対しても、
     Hurdは現代的なUnixライクのカーネルである。HurdはGNU
     Cライブラリを使用し、 その開発はANSI/ISO、BSD、POSIX、Single
     Unix、SVID、そしてX/Openのような 標準を厳密に追いかけている。

それは生き残るように構築されている
     他の有名なカーネル・ソフトウェアと違い、Hurdはその設計を汚さずに進化でき
     るような、オブジェクト指向の構造を持っている。この構造はHurdを全体的に書
     き直さなくても重大な再設計や変更に耐えられるようにするのに役立つだろう。

それはscalableである
     単一プロセッサと対称マルチプロセッサの両方で効率的に動作するように、Hurd
     の実装は積極的にマルチスレッド化されている。Hurdのインターフェースは透過
     的なネットワーク・クラスタ("collectives")が可能なように設計されてい
     る。この機能はまだ実装されていないが。

それは拡張性がある
     Hurdはカーネル・ハッカーになる方法を学んだり、カーネルの技術の新しい発想
     を実装するのに魅力的なプラットホームである。そのシステムのあらゆる部分が
     変更され、拡張されるように設計されている。

それは安定である
     新しいHurdカーネルの構成要素を開発し試験するために、(偶発的でもなく)マシ
     ンを再起動せずに行うことが可能である。あなた自身のカーネル構成要素を動作
     させることは他のユーザには干渉しないので、特別なシステム特権は必要とされ
     ない。カーネル拡張の仕組みは設計により安全である。あなたの変更に権限を与
     えたり、あなたがシステム管理者だったりしない限り、その変更を他のユーザに
     押しつけることは不可能である。

それは存在する
     Hurdは直ちに動作する現実のソフトウェアである。それは研究プロジェクトや提
     案ではない。それを使ったり開発したりできるようになるまで全く待たなくて良
     いのだ。


File: hurd-ja.info,  Node: Overview,  Next: History,  Prev: Features,  Up: Introduction

1.3 概観
========

FIXME: overview of basic Hurd architecture, FAQish in nature


File: hurd-ja.info,  Node: History,  Next: Copying,  Prev: Overview,  Up: Introduction

1.4 歴史
========

Richard Stallman (RMS)は完全でフリーなオペレーティング・システムを作成す
るためのプロジェクトとして、1983年にGNUを発足した。GNU宣言の文章では、原
始的なカーネルがあると彼は言っていた。1986年2月の最初のGNUsletterで、GNU
のカーネルはTRIXであると彼は言っているが、それはマサチューセッツ工科大学
で開発された。

   1986年の12月までは、Free Software Foundation (FSF)は
"TRIXに必要な変更 の作業を始めた" [Gnusletter, Jan,
1987]。その後ちょっとして、FSFは "カー
ネギーメロン大学のRashid教授とMachカーネルの開発を彼らと共に作業すること
について取り決めること" を始めた [Gnusletter, June, 1987]。その文章は、
FSFがTRIXを直さなければならないよりも、誰か他の人の作品を使いたがってい
たことを暗示している。

   [Gnusletter, Feb.
1988]において、"バークレーUnixの部分が置き換えられた
後に..."、Machを受け取り、バークレーSpriteファイルシステムをその上
に乗せることをRMSが話していた。

   六ヶ月後、FSFは
"もし我々がMachを手に入れられないなら、TRIXかバークレー
のSpriteを使うだろう"と言っている。ここで、彼らはSpriteを単なるファイル
システムではなく、完全なカーネルの選択として提出する。

   1990年の1月に、彼らは "我々はどんなカーネルの仕事も行っていない。まだ
Machを使用することを望むときに、今カーネル・プロジェクトを発足することは
我々には意味がない"と言っている [Gnusletter, Jan. 1990]。1991年まで何も
重要なことは起きない。そのときもっと詳細な計画が公表される。

     "我々はなおMachの上で走る多重プロセス・カーネルに興味がある。CMUの弁護
     士は現在、我々が配布できる配布条件でMachをリリースできるかどうか決定して
     いる。もし彼らがそうすると決めれば、我々はおそらく作業を開始するだろう。
     CMUはMachと同じtermで利用できる、Poeと名付けられた単一サーバの部分的な
     Unixエミュレータを持っている。それはいくぶん遅くて最小限の機能を提供して
     いる。我々は多分完全な機能を提供するようにPoeを拡張することから始めるだ
     ろう。後で多重プロセスに分割されたモジュール方式のエミュレータを持つこと
     を望んでいる。" [Gnusletter, Jan. 1991]。

   RMSはHurdとLinuxの関係を
`http://www.gnu.org/software/hurd/hurd-and-linux.html'で説明してお
り、そこではFSFは1990年にHurdを開発し始めたと彼は言及している。
[Gnusletter, Nov. 1991]により、(Machの上で走る)HurdはGNUの公式カーネルで
ある。


File: hurd-ja.info,  Node: Copying,  Prev: History,  Up: Introduction

1.5 GNU General Public License
==============================

                         Version 2, June 1991

     Copyright (C) 1989, 1991 Free Software Foundation, Inc.  675
     Mass Ave, Boston, MA 02111-1307, USA

     Everyone is permitted to copy and distribute verbatim copies
     of this license document, but changing it is not allowed.

Preamble
--------

The licenses for most software are designed to take away your freedom
to share and change it.  By contrast, the GNU General Public License is
intended to guarantee your freedom to share and change free
software--to make sure the software is free for all its users.  This
General Public License applies to most of the Free Software
Foundation's software and to any other program whose authors commit to
using it.  (Some other Free Software Foundation software is covered by
the GNU Library General Public License instead.)  You can apply it to
your programs, too.

   When we speak of free software, we are referring to freedom, not
price.  Our General Public Licenses are designed to make sure that you
have the freedom to distribute copies of free software (and charge for
this service if you wish), that you receive source code or can get it
if you want it, that you can change the software or use pieces of it in
new free programs; and that you know you can do these things.

   To protect your rights, we need to make restrictions that forbid
anyone to deny you these rights or to ask you to surrender the rights.
These restrictions translate to certain responsibilities for you if you
distribute copies of the software, or if you modify it.

   For example, if you distribute copies of such a program, whether
gratis or for a fee, you must give the recipients all the rights that
you have.  You must make sure that they, too, receive or can get the
source code.  And you must show them these terms so they know their
rights.

   We protect your rights with two steps: (1) copyright the software,
and (2) offer you this license which gives you legal permission to copy,
distribute and/or modify the software.

   Also, for each author's protection and ours, we want to make certain
that everyone understands that there is no warranty for this free
software.  If the software is modified by someone else and passed on, we
want its recipients to know that what they have is not the original, so
that any problems introduced by others will not reflect on the original
authors' reputations.

   Finally, any free program is threatened constantly by software
patents.  We wish to avoid the danger that redistributors of a free
program will individually obtain patent licenses, in effect making the
program proprietary.  To prevent this, we have made it clear that any
patent must be licensed for everyone's free use or not licensed at all.

   The precise terms and conditions for copying, distribution and
modification follow.

    TERMS AND CONDITIONS FOR COPYING, DISTRIBUTION AND MODIFICATION
  0. This License applies to any program or other work which contains a
     notice placed by the copyright holder saying it may be distributed
     under the terms of this General Public License.  The "Program",
     below, refers to any such program or work, and a "work based on
     the Program" means either the Program or any derivative work under
     copyright law: that is to say, a work containing the Program or a
     portion of it, either verbatim or with modifications and/or
     translated into another language.  (Hereinafter, translation is
     included without limitation in the term "modification".)  Each
     licensee is addressed as "you".

     Activities other than copying, distribution and modification are
     not covered by this License; they are outside its scope.  The act
     of running the Program is not restricted, and the output from the
     Program is covered only if its contents constitute a work based on
     the Program (independent of having been made by running the
     Program).  Whether that is true depends on what the Program does.

  1. You may copy and distribute verbatim copies of the Program's
     source code as you receive it, in any medium, provided that you
     conspicuously and appropriately publish on each copy an appropriate
     copyright notice and disclaimer of warranty; keep intact all the
     notices that refer to this License and to the absence of any
     warranty; and give any other recipients of the Program a copy of
     this License along with the Program.

     You may charge a fee for the physical act of transferring a copy,
     and you may at your option offer warranty protection in exchange
     for a fee.

  2. You may modify your copy or copies of the Program or any portion
     of it, thus forming a work based on the Program, and copy and
     distribute such modifications or work under the terms of Section 1
     above, provided that you also meet all of these conditions:

       a. You must cause the modified files to carry prominent notices
          stating that you changed the files and the date of any change.

       b. You must cause any work that you distribute or publish, that
          in whole or in part contains or is derived from the Program
          or any part thereof, to be licensed as a whole at no charge
          to all third parties under the terms of this License.

       c. If the modified program normally reads commands interactively
          when run, you must cause it, when started running for such
          interactive use in the most ordinary way, to print or display
          an announcement including an appropriate copyright notice and
          a notice that there is no warranty (or else, saying that you
          provide a warranty) and that users may redistribute the
          program under these conditions, and telling the user how to
          view a copy of this License.  (Exception: if the Program
          itself is interactive but does not normally print such an
          announcement, your work based on the Program is not required
          to print an announcement.)

     These requirements apply to the modified work as a whole.  If
     identifiable sections of that work are not derived from the
     Program, and can be reasonably considered independent and separate
     works in themselves, then this License, and its terms, do not
     apply to those sections when you distribute them as separate
     works.  But when you distribute the same sections as part of a
     whole which is a work based on the Program, the distribution of
     the whole must be on the terms of this License, whose permissions
     for other licensees extend to the entire whole, and thus to each
     and every part regardless of who wrote it.

     Thus, it is not the intent of this section to claim rights or
     contest your rights to work written entirely by you; rather, the
     intent is to exercise the right to control the distribution of
     derivative or collective works based on the Program.

     In addition, mere aggregation of another work not based on the
     Program with the Program (or with a work based on the Program) on
     a volume of a storage or distribution medium does not bring the
     other work under the scope of this License.

  3. You may copy and distribute the Program (or a work based on it,
     under Section 2) in object code or executable form under the terms
     of Sections 1 and 2 above provided that you also do one of the
     following:

       a. Accompany it with the complete corresponding machine-readable
          source code, which must be distributed under the terms of
          Sections 1 and 2 above on a medium customarily used for
          software interchange; or,

       b. Accompany it with a written offer, valid for at least three
          years, to give any third party, for a charge no more than your
          cost of physically performing source distribution, a complete
          machine-readable copy of the corresponding source code, to be
          distributed under the terms of Sections 1 and 2 above on a
          medium customarily used for software interchange; or,

       c. Accompany it with the information you received as to the offer
          to distribute corresponding source code.  (This alternative is
          allowed only for noncommercial distribution and only if you
          received the program in object code or executable form with
          such an offer, in accord with Subsection b above.)

     The source code for a work means the preferred form of the work for
     making modifications to it.  For an executable work, complete
     source code means all the source code for all modules it contains,
     plus any associated interface definition files, plus the scripts
     used to control compilation and installation of the executable.
     However, as a special exception, the source code distributed need
     not include anything that is normally distributed (in either
     source or binary form) with the major components (compiler,
     kernel, and so on) of the operating system on which the executable
     runs, unless that component itself accompanies the executable.

     If distribution of executable or object code is made by offering
     access to copy from a designated place, then offering equivalent
     access to copy the source code from the same place counts as
     distribution of the source code, even though third parties are not
     compelled to copy the source along with the object code.

  4. You may not copy, modify, sublicense, or distribute the Program
     except as expressly provided under this License.  Any attempt
     otherwise to copy, modify, sublicense or distribute the Program is
     void, and will automatically terminate your rights under this
     License.  However, parties who have received copies, or rights,
     from you under this License will not have their licenses
     terminated so long as such parties remain in full compliance.

  5. You are not required to accept this License, since you have not
     signed it.  However, nothing else grants you permission to modify
     or distribute the Program or its derivative works.  These actions
     are prohibited by law if you do not accept this License.
     Therefore, by modifying or distributing the Program (or any work
     based on the Program), you indicate your acceptance of this
     License to do so, and all its terms and conditions for copying,
     distributing or modifying the Program or works based on it.

  6. Each time you redistribute the Program (or any work based on the
     Program), the recipient automatically receives a license from the
     original licensor to copy, distribute or modify the Program
     subject to these terms and conditions.  You may not impose any
     further restrictions on the recipients' exercise of the rights
     granted herein.  You are not responsible for enforcing compliance
     by third parties to this License.

  7. If, as a consequence of a court judgment or allegation of patent
     infringement or for any other reason (not limited to patent
     issues), conditions are imposed on you (whether by court order,
     agreement or otherwise) that contradict the conditions of this
     License, they do not excuse you from the conditions of this
     License.  If you cannot distribute so as to satisfy simultaneously
     your obligations under this License and any other pertinent
     obligations, then as a consequence you may not distribute the
     Program at all.  For example, if a patent license would not permit
     royalty-free redistribution of the Program by all those who
     receive copies directly or indirectly through you, then the only
     way you could satisfy both it and this License would be to refrain
     entirely from distribution of the Program.

     If any portion of this section is held invalid or unenforceable
     under any particular circumstance, the balance of the section is
     intended to apply and the section as a whole is intended to apply
     in other circumstances.

     It is not the purpose of this section to induce you to infringe any
     patents or other property right claims or to contest validity of
     any such claims; this section has the sole purpose of protecting
     the integrity of the free software distribution system, which is
     implemented by public license practices.  Many people have made
     generous contributions to the wide range of software distributed
     through that system in reliance on consistent application of that
     system; it is up to the author/donor to decide if he or she is
     willing to distribute software through any other system and a
     licensee cannot impose that choice.

     This section is intended to make thoroughly clear what is believed
     to be a consequence of the rest of this License.

  8. If the distribution and/or use of the Program is restricted in
     certain countries either by patents or by copyrighted interfaces,
     the original copyright holder who places the Program under this
     License may add an explicit geographical distribution limitation
     excluding those countries, so that distribution is permitted only
     in or among countries not thus excluded.  In such case, this
     License incorporates the limitation as if written in the body of
     this License.

  9. The Free Software Foundation may publish revised and/or new
     versions of the General Public License from time to time.  Such
     new versions will be similar in spirit to the present version, but
     may differ in detail to address new problems or concerns.

     Each version is given a distinguishing version number.  If the
     Program specifies a version number of this License which applies
     to it and "any later version", you have the option of following
     the terms and conditions either of that version or of any later
     version published by the Free Software Foundation.  If the Program
     does not specify a version number of this License, you may choose
     any version ever published by the Free Software Foundation.

 10. If you wish to incorporate parts of the Program into other free
     programs whose distribution conditions are different, write to the
     author to ask for permission.  For software which is copyrighted
     by the Free Software Foundation, write to the Free Software
     Foundation; we sometimes make exceptions for this.  Our decision
     will be guided by the two goals of preserving the free status of
     all derivatives of our free software and of promoting the sharing
     and reuse of software generally.

                                NO WARRANTY
 11. BECAUSE THE PROGRAM IS LICENSED FREE OF CHARGE, THERE IS NO
     WARRANTY FOR THE PROGRAM, TO THE EXTENT PERMITTED BY APPLICABLE
     LAW.  EXCEPT WHEN OTHERWISE STATED IN WRITING THE COPYRIGHT
     HOLDERS AND/OR OTHER PARTIES PROVIDE THE PROGRAM "AS IS" WITHOUT
     WARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING, BUT
     NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
     FITNESS FOR A PARTICULAR PURPOSE.  THE ENTIRE RISK AS TO THE
     QUALITY AND PERFORMANCE OF THE PROGRAM IS WITH YOU.  SHOULD THE
     PROGRAM PROVE DEFECTIVE, YOU ASSUME THE COST OF ALL NECESSARY
     SERVICING, REPAIR OR CORRECTION.

 12. IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN
     WRITING WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MAY
     MODIFY AND/OR REDISTRIBUTE THE PROGRAM AS PERMITTED ABOVE, BE
     LIABLE TO YOU FOR DAMAGES, INCLUDING ANY GENERAL, SPECIAL,
     INCIDENTAL OR CONSEQUENTIAL DAMAGES ARISING OUT OF THE USE OR
     INABILITY TO USE THE PROGRAM (INCLUDING BUT NOT LIMITED TO LOSS OF
     DATA OR DATA BEING RENDERED INACCURATE OR LOSSES SUSTAINED BY YOU
     OR THIRD PARTIES OR A FAILURE OF THE PROGRAM TO OPERATE WITH ANY
     OTHER PROGRAMS), EVEN IF SUCH HOLDER OR OTHER PARTY HAS BEEN
     ADVISED OF THE POSSIBILITY OF SUCH DAMAGES.

                      END OF TERMS AND CONDITIONS
How to Apply These Terms to Your New Programs
---------------------------------------------

If you develop a new program, and you want it to be of the greatest
possible use to the public, the best way to achieve this is to make it
free software which everyone can redistribute and change under these
terms.

   To do so, attach the following notices to the program.  It is safest
to attach them to the start of each source file to most effectively
convey the exclusion of warranty; and each file should have at least
the "copyright" line and a pointer to where the full notice is found.

     ONE LINE TO GIVE THE PROGRAM'S NAME AND AN IDEA OF WHAT IT DOES.
     Copyright (C) 19YY  NAME OF AUTHOR

     This program is free software; you can redistribute it and/or
     modify it under the terms of the GNU General Public License
     as published by the Free Software Foundation; either version 2
     of the License, or (at your option) any later version.

     This program is distributed in the hope that it will be useful,
     but WITHOUT ANY WARRANTY; without even the implied warranty of
     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
     GNU General Public License for more details.

     You should have received a copy of the GNU General Public License
     along with this program; if not, write to the Free Software
     Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.

   Also add information on how to contact you by electronic and paper
mail.

   If the program is interactive, make it output a short notice like
this when it starts in an interactive mode:

     Gnomovision version 69, Copyright (C) 19YY NAME OF AUTHOR
     Gnomovision comes with ABSOLUTELY NO WARRANTY; for details
     type `show w'.  This is free software, and you are welcome
     to redistribute it under certain conditions; type `show c'
     for details.

   The hypothetical commands `show w' and `show c' should show the
appropriate parts of the General Public License.  Of course, the
commands you use may be called something other than `show w' and `show
c'; they could even be mouse-clicks or menu items--whatever suits your
program.

   You should also get your employer (if you work as a programmer) or
your school, if any, to sign a "copyright disclaimer" for the program,
if necessary.  Here is a sample; alter the names:

     Yoyodyne, Inc., hereby disclaims all copyright
     interest in the program `Gnomovision'
     (which makes passes at compilers) written
     by James Hacker.

     SIGNATURE OF TY COON, 1 April 1989
     Ty Coon, President of Vice

   This General Public License does not permit incorporating your
program into proprietary programs.  If your program is a subroutine
library, you may consider it more useful to permit linking proprietary
applications with the library.  If this is what you want to do, use the
GNU Library General Public License instead of this License.


File: hurd-ja.info,  Node: Installing,  Next: Bootstrap,  Prev: Introduction,  Up: Top

2 Installing
************

Before you can use the Hurd on your favorite machine, you'll need to
install all of its software components.  Currently, the Hurd only runs
on Intel i386-compatible architectures (such as the Pentium), using the
GNU Mach microkernel.

   If you have unsupported hardware or a different microkernel, you will
not be able to run the Hurd until all the required software has been
"ported" to your architecture.  Porting is an involved process which
requires considerable programming skills, and is not recommended for the
faint-of-heart.  If you have the talent and desire to do a port, contact
<bug-hurd@gnu.org> in order to coordinate the effort.

* Menu:

* Binary Distributions::        Obtaining ready-to-run GNU distributions.
* Cross-Compiling::             Building GNU from its source code.


File: hurd-ja.info,  Node: Binary Distributions,  Next: Cross-Compiling,  Up: Installing

2.1 Binary Distributions
========================

By far the easiest and best way to install the Hurd is to obtain a GNU
binary distribution.  Even if you plan on recompiling the Hurd itself,
it is best to start off with an already-working GNU system so that you
can avoid having to reboot every time you want to test a program.

   You can get GNU from a friend under the conditions allowed by the GNU
GPL (*note Copying::).  Please consider sending a donation to the Free
Software Foundation so that we can continue to improve GNU software.

   You can also FTP the complete GNU system from your closest GNU
mirror, or `ftp://ftp.gnu.org/pub/gnu/'.  The GNU binary distribution is
available in a subdirectory called `gnu-N.M', where N.M is the version
of the Hurd that this GNU release corresponds to (0.2 at the time of
this writing).  Again, please consider donating to the Free Software
Foundation.

   The format of the binary distribution is prone to change, so this
manual does not describe the details of how to install GNU.  The
`README' file distributed with the binary distribution gives you
complete instructions.

   After you follow all the appropriate instructions, you will have a
working GNU/Hurd system.  If you have used Linux-based GNU systems or
other Unix-like systems before, the Hurd will look quite familiar.  You
should play with it for a while, referring to this manual only when you
want to learn more about the Hurd.  Have fun!

   If the Hurd is your first introduction to the GNU operating system,
then you will need to learn more about GNU in order to be able to use
it.  You should talk to friends who are familiar with GNU, in order to
find out about classes, online tutorials, or books which can help you
learn more about GNU.

   If you have no friends who are already using GNU, you can find some
useful starting points at the GNU web site, `http://www.gnu.org/'.  You
can also send e-mail to <help-hurd@gnu.org>, to contact fellow Hurd
users.  You can join this mailing list by sending a request to
<help-hurd-request@gnu.org>.


File: hurd-ja.info,  Node: Cross-Compiling,  Prev: Binary Distributions,  Up: Installing

2.2 Cross-Compiling
===================

Another way to install the Hurd is to use an existing operating system
in order to compile all the required Hurd components from source code.
This is called "cross-compiling", because it is done between two
different platforms.

   _This process is not recommended unless you are porting the Hurd to
a new platform._  Cross-compiling the Hurd to a platform which already
has a binary distribution is a tremendous waste of time... it is
frequently necessary to repeat steps over and over again, and you are
not even guaranteed to get a working system.  Please, obtain a GNU
binary distribution (*note Binary Distributions::), and use your time to
do more useful things.  If you are capable of cross-compiling, then you
are definitely skilled enough to make more useful (and creative)
modifications to the GNU system.

   If you are interested in porting the Hurd to a new platform, you
should send e-mail to the <bug-hurd@gnu.org> mailing list in order to
coordinate your efforts.  People on that list will give you advice on
what to look out for, as well as helping you find other people who are
interested in working on the same port.


File: hurd-ja.info,  Node: Bootstrap,  Next: Foundations,  Prev: Installing,  Up: Top

3 Bootstrap
***********

Bootstrapping is the procedure by which your machine loads the
microkernel and transfers control to the Hurd servers.(1)

* Menu:

* Bootloader::                  Starting the microkernel, or other OSes.
* Server Bootstrap::            Waking up the Hurd.
* Shutdown::                    Letting the Hurd get some rest.

   ---------- Footnotes ----------

   (1) The term "bootstrapping" refers to a Dutch legend about a boy
who was able to fly by pulling himself up by his bootstraps.  In
computers, this term refers to any process where a simple system
activates a more complicated system.


File: hurd-ja.info,  Node: Bootloader,  Next: Server Bootstrap,  Up: Bootstrap

3.1 Bootloader
==============

The "bootloader" is the first software that runs on your machine.  Many
hardware architectures have a very simple startup routine which reads a
very simple bootloader from the beginning of the internal hard disk,
then transfers control to it.  Other architectures have startup
routines which are able to understand more of the contents of the hard
disk, and directly start a more advanced bootloader.

   Currently, "GRUB"(1) is the preferred GNU bootloader.  GRUB provides
advanced functionality, and is capable of loading several different
kernels (such as Linux, DOS, and the *BSD family).

   From the standpoint of the Hurd, the bootloader is just a mechanism
to get the microkernel running and transfer control to `serverboot'.
You will need to refer to your bootloader and microkernel documentation
for more information about the details of this process.

   ---------- Footnotes ----------

   (1) The GRand Unified Bootloader, available from
`http://www.uruk.org/grub/'.


File: hurd-ja.info,  Node: Server Bootstrap,  Next: Shutdown,  Prev: Bootloader,  Up: Bootstrap

3.2 Server Bootstrap
====================

The `serverboot' program is responsible for loading and executing the
rest of the Hurd servers.  Rather than containing specific instructions
for starting the Hurd, it follows general steps given in a
user-supplied boot script.

   To bootstrap the Hurd, the microkernel must start this program as its
first task, and to pass it appropriate arguments.  `serverboot' may
also be invoked while the Hurd is already running, which allows users to
start their own complete sub-Hurds (*note Invoking boot::).

* Menu:

* Invoking serverboot::         Starting a set of interdependent servers.
* Boot Scripts::                Describing server bootstrap relationships.
* Invoking boot::               Running a Hurd under another Hurd.


File: hurd-ja.info,  Node: Invoking serverboot,  Next: Boot Scripts,  Up: Server Bootstrap

3.2.1 Invoking `serverboot'
---------------------------

The `serverboot' program has the following synopsis:

     serverboot -SWITCH... [[HOST-PORT DEVICE-PORT] ROOT-NAME]

   Each SWITCH is a single character, out of the following set:

`a'
     Prompt the user for the ROOT-NAME, even if it was already supplied
     on the command line.

`d'
     Prompt the user to strike a key after the boot script has been
     read.

`q'
     Prompt the user for the name of the boot script.  By default, use
     `ROOT-NAME:/boot/servers.boot'.

   All the SWITCHES are put into the `${boot-args}' script variable.

   HOST-PORT and DEVICE-PORT are integers which represent the
microkernel host and device ports, respectively (and are used to
initialize the `${host-port}' and `${device-port}' boot script
variables).  If these ports are not specified, then `serverboot'
assumes that the Hurd is already running, and fetches the current ports
from the procserver (FIXME xref).

   ROOT-NAME is the name of the microkernel device that should be used
as the Hurd bootstrap filesystem.  `serverboot' uses this name to
locate the boot script (described above), and to initialize the
`${root-device}' script variable.


File: hurd-ja.info,  Node: Boot Scripts,  Next: Invoking boot,  Prev: Invoking serverboot,  Up: Server Bootstrap

3.2.2 Boot Scripts
------------------

FIXME: finish


File: hurd-ja.info,  Node: Invoking boot,  Prev: Boot Scripts,  Up: Server Bootstrap

3.2.3 Invoking `boot'
---------------------

The `boot' program is used to start a set of core Hurd servers while
another Hurd is already running.  You will rarely need to do this, and
it currently requires superuser privileges (to access the host
privileged port), but it is interesting to note that it can be done.

   Usually, you would make changes to only one server, and simply tell
your programs to use it in order to test out your changes.  This
process can be applied even to the core servers.  However, some changes
have far-reaching effects, and so it is nice to be able to test those
effects without having to reboot the machine.

   The `boot' program has the following synopsis:

     boot [OPTION]... BOOT-SCRIPT ROOT-STORE

   BOOT-SCRIPT is the name of the boot script (*note Boot Scripts::).
ROOT-STORE is the store that is used as the root partition (*note Store
Library::).

   Here are the steps you can follow to test out a new set of servers:

  1. Create a new root partition and initialize it with your favorite
     filesystem format.  The `boot' program uses libstore, so you can
     use any valid store as your root, with any options that libstore
     recognizes:

          $ dd if=/dev/zero of=my-partition bs=1024 count=80
          $ mke2fs ./my-partition

     It is better to use a raw partition, if possible.  With a raw
     partition, the sub-Hurd doesn't depend on its parent for anything
     except the default pager.

  2. Copy the core servers, C library, and any of your modified
     programs onto the new partition:

          $ settrans -c ./my-root /hurd/ext2fs `pwd`/my-partition
          $ (cd my-root && tar -zxf ../my-files.tar.gz)

  3. Use some clever shadowfs hacks (FIXME xref) to mirror the rest of
     your programs under the modified partition.  Copying them will
     work, too, if you don't like shadowfs.

  4. Create a boot script on the new partition, in `/boot/servers.boot'.

  5. Make your root filesystem read-only for the parent Hurd, to
     prevent any conflicts:

          $ settrans -g ./my-root
          $ settrans -c ./my-root /hurd/ext2fs -r `pwd`/my-partition

  6. Run `boot' on your new partition:

          $ boot -D ./my-root ./my-root/boot/servers.boot ./my-partition

   Note that sharing microkernel devices between the two running Hurds
may cause conflicts, so don't get any funny ideas.  When you're finished
testing your new Hurd, then you can run the `halt' or `reboot' programs
to return control to the parent Hurd.

   If you're satisfied with your new Hurd, you can arrange for your
bootloader to start it, and reboot your machine.  Then, you'll be in a
safe place to overwrite your old Hurd with the new one, and reboot back
to your old configuration (with the new Hurd servers).


File: hurd-ja.info,  Node: Shutdown,  Prev: Server Bootstrap,  Up: Bootstrap

3.3 Shutdown
============

FIXME: finish


File: hurd-ja.info,  Node: Foundations,  Next: Input and Output,  Prev: Bootstrap,  Up: Top

4 基礎
******

あらゆるHurdプログラムは以下の付加的な引数を受け取る。

`--help'
     簡潔な使い方のメッセージを表示し、終了する。このメッセージはプログラムの
     解説書を読むことの代わりではなく、プログラムが理解する特定のコマンドライ
     ンのオプションについて思い出すのに役に立つのである。

`--version'
     プログラムのバージョン情報を出力し、終了する。

この章の残りで、Hurdをプログラマに対して紹介する。もしあなたがプログラマ
でないなら、この章はあなたには大して意味がない... 特定のHurdプログラ
ムの記述まで飛ばすことを考えるべきだ (*note Audience::)。

Hurdのユーティリティやサーバを書くための有用なツールの組を提供するために、
Hurdの配布にはたくさんのライブラリが含まれている。これらのライブラリのい
くつかはHurdにだけではなく、一般的にマイクロカーネルに基くプログラムを書
くのに役立つ。これらの基本的なライブラリは理解するのに難しくはなく、それ
らは良い開始点である。なぜなら、Hurdの残りの部分は非常に激しくそれらに頼っ
ているからだ。

* Menu:

* Threads Library::             あらゆるHurdサーバとライブラリは
                                マルチスレッド化されている。
* Microkernel Object Library::  マイクロカーネル・オブジェクト・モデル(MOM)。
* Ports Library::               サーバのport受信権の管理。
* Integer Hash Library::        整数を鍵としたハッシュ表。
* Misc Library::                GNU Cライブラリにすぐに入るもの。
* Bug Address Library::         Hurdのバグを報告する場所。


File: hurd-ja.info,  Node: Threads Library,  Next: Microkernel Object Library,  Up: Foundations

4.1 スレッド・ライブラリ
========================

マイクロカーネルや土台となるハードウェアのよって提供される多重処理の能力
を十分に利用するために、Hurdサーバやライブラリは全て積極的にマルチスレッ
ド化されている。Hurdのスレッド・ライブラリ、`libthreads'はデフォル
トのHurdスレッドの実装を含み、それは`<cthreads.h>'で宣言されている。

現在(1998年4月)、Hurdはcthreadsを使っているが、それはすでにCMUによって完
全に解説されている。最後には、それはPOSIX pthreadsを使うように移行される
だろう。それはたくさんのところで解説されている。

   (GNU
Cライブラリを含む)Hurd配布物の中の個々のライブラリは完全にスレッド・
セーフで、Hurdサーバ自身は積極的にマルチスレッド化されている。


File: hurd-ja.info,  Node: Microkernel Object Library,  Next: Ports Library,  Prev: Threads Library,  Up: Foundations

4.2 マイクロカーネル・オブジェクト・ライブラリ
==============================================

一般に尋ねられる質問はHurdはMachマイクロカーネルのOpen Groupのバージョン
に移植されているかどうかだ。その答えは"いいえ"だ。

   現在(1998年4月)、Hurdは非常にGNU
Machマイクロカーネルに依存しており、そ れはユタ大学のMach
4から派生している。しかしながら、Hurdの開発者はMachの
限界をあまりにも気にし過ぎている。

   `libmom'はHurdを他のメッセージ通信式マイクロカーネルに移植できるよ
うにするために必要とされるいくつかの段階のうち最初のものである。
"MOM"は"Microkernel Object Model"を表し、一般的なメッセージ通信
式マイクロカーネルによって提供される基本的なサービスの抽象概念である。そ
れはHurdサーバとCライブラリがマイクロカーネルに依存したカーネル呼び出し
を行わないでいいように、必要な隔離を行うだろう。

   でも、現在では、`libmom'はまだ発展中であり、完全にHurdに組み込まれ
るにはいくらか時間がかかるだろう。


File: hurd-ja.info,  Node: Ports Library,  Next: Integer Hash Library,  Prev: Microkernel Object Library,  Up: Foundations

4.3 portのライブラリ
====================

portはカーネルによって所有される通信路である。

portは別々の送信権と受信権を持ち、それらはカーネルを通してタスクからタ
スクへ譲られても良い。port権はUnixのファイル記述子と似ている。それらは
カーネル呼び出しを行うときにportを識別するのに使われるタスク毎の整数で
ある。送信権はRPCリクエストをportに遅るために必要で、受信権はRPCリクエ
ストに応対するために必要である。受信権は単一の"portset"に集めら
れても良く、それは有用な構成単位として役に立つ。

   単一スレッドのRPCクライアントでは、portを管理し類別することは難しい処
理ではない。しかしながら、複雑なマルチスレッドのサーバでは、portset
を管理するのにより抽象的なインターフェースを持つことは、サーバの抽象的な
データを管理することと同様、役に立つのである。

   Hurdのportのライブラリ、`libports'はその必要性を満たす。
`libports'関数は`<hurd/ports.h>'で宣言されている。

* Menu:

* Buckets and Classes::         port編成の基本単位。
* Port Rights::                 port権の`libports'との間での移動。
* Port Metadata::               port関連の情報の管理。
* Port References::             漏曳や欠失に対する保護。
* RPC Management::              RPC操作のロックと割り込み。


File: hurd-ja.info,  Node: Buckets and Classes,  Next: Port Rights,  Up: Ports Library

4.3.1 BucketとClass
-------------------

`libports'の"bucket"はただのportの組と、いくらかの抽象データ
とロックだけである。`libports'関数の全てはbucketに対して操作する。

 -- Function: struct port_bucket * ports_create_bucket (void)
     新しい、空のbucketを作って返す。

   portの"class"は個々のportの集まりで、それは簡便に扱うことができ、
解放ルーチンを強制している。bucketとclassはまったくorthogonalである。
classのportが全て同じbucketに入っている必要性はなく、bucketのportが
全て同じclassに入っている必要性もない。

 -- Function: struct port_class ports_create_class
          (void (*CLEAN_ROUTINE) (void *PORT),
          void (*DROPWEAK_ROUTINE) (void *PORT))
     新しいport classを作って返す。もし非ゼロなら、CLEAN_ROUTINEはこの
     classの割り当てられたportオブジェクトが破壊されるときにそれぞれに対して
     呼び出されるだろう。もし非ゼロなら、DROPWEAK_ROUTINEは弱い参照が減
     少するようにリクエストするときに呼び出されるだろう。(もし
     DROPWEAK_ROUTINEがnullなら、弱い参照と強い参照はこのclassのportに
     対して等価だろう。)

少なくとも一つのbucketとclassを作ってしまったら、新しいportを作り、これ
らのbucketに収めて良い。あなたのアプリケーションの必要性に依存して、port
の生成に対して少数の異なる関数がある。

 -- Function: error_t ports_create_port (struct port_class *CLASS,
          struct port_bucket *BUCKET, size_t SIZE, void *RESULT)
     CLASSとBUCKETの新しいportを作り、RESULTに入れて返す。
     SIZEバイトがport構造体とユーザが定義するプライベートなデータを保持
     するために割り当てられるだろう。

 -- Function: error_t ports_create_port_noinstall
          (struct port_class *CLASS, struct port_bucket *BUCKET,
          size_t SIZE, void *RESULT)
     実際にはportをBUCKETの根底にあるportsetに入れられないことを除いて、
     `ports_create_port'とちょうど同じである。これはportが完全に初期化さ
     れる前にport権が配られなければならない場合に使われることを意図されている。
     この呼び出しを使うと、portを初期化し終わりportsetにあなた自身がそれを入
     れるまで、そのportにRPCサービスが起こらないことが保証される。

 -- Function: error_t ports_import_port (struct port_class *CLASS,
          struct port_bucket *BUCKET, mach_port_t PORT, size_t SIZE,
          void *RESULT)
     存在する_受信_権に対し、新しいport構造体を作ってRESULTに返す。
     BUCKET、SIZE、そしてCLASS引数は `ports_create_port'と同様である。


File: hurd-ja.info,  Node: Port Rights,  Next: Port Metadata,  Prev: Buckets and Classes,  Up: Ports Library

4.3.2 port権
------------

以下の関数はport受信権をport構造体との間で移動する。

 -- Function: void ports_reallocate_port (void *PORT)
     現在PORTと結び付いている受信権を破棄し、新しい受信権を割り当てる。

 -- Function: void ports_reallocate_from_external (void *PORT,
          mach_port_t RECEIVE)
     現在PORTと結び付いている受信権を破棄し、RECEIVEを新しい受信
     権として指定する。

 -- Function: void ports_destroy_right (void *PORT)
     現在PORTと結び付いている受信権を破棄する。この呼び出しの後に、
     `ports_reallocate_port'と`ports_reallocate_from_external'は使
     えない。

 -- Function: mach_port_t ports_claim_right (void *PORT)
     現在PORTと結び付いている受信権を返す。PORTに対する効果は
     受信権自体には影響しないことを除いて`ports_destroy_right'と同じであ
     る。マルチスレッド化されているサーバでは、このportがportsetから除かれる
     前にメッセージがすでにキューから除かれているかもしれないことに注意せよ。
     そのようなメッセージからは`EOPNOTSUPP'エラーを得るであろう。

 -- Function: error_t ports_transfer_right (void *TOPT, void *FROMPT)
     FROMPTからTOPTへ受信権を移す。(あたかも
     `ports_destory_right'が呼ばれたように)FROMPTは破棄された権利
     を持つようになり、(あたかも`ports_reallocate_from_external'が呼ばれ
     たよう)TOPTの古い権利は破棄される。

 -- Function: mach_port_t ports_get_right (void *PORT)
     PORTと結び付いている受信権の名前を返す。ユーザは責任を持って、この
     名前から普通の送信権を作らねばならない。


File: hurd-ja.info,  Node: Port Metadata,  Next: Port References,  Prev: Port Rights,  Up: Ports Library

4.3.3 portの抽象データ
----------------------

`libports'関数のそれぞれへのPORT引数が`void *'であって `struct
port_info *'ではないことを指摘するのは重要だ。これは任意の
抽象的な情報をあなたの`libports'に管理されるportへ追加できるために
行われている。単に最初の要素が`struct port_info'であるような、あな
た自身の構造体を定義すれば、どんな`libports'関数へもPORT引数
としてこれらの構造体へのポインタを使うことができる。

以下の関数はあなた自身があつらえたport構造体に収められる抽象データを管理
するのに役立つ。

 -- Function: void * ports_lookup_port (struct port_bucket *BUCKET,
          mach_port_t PORT, struct port_class *CLASS)
     PORTを探し、参照を割り当てて、結び付いているport構造体を返す。この
     呼び出しが失敗すると、ゼロを返す。もしBUCKETが非ゼロなら、それは検
     索するためのbucketを指定する。そうでなければ全てのbucketが検索されるだろ
     う。もしCLASSが非ゼロなら、PORTがCLASSにないなら検索が
     失敗するだろう。

 -- Function: error_t ports_bucket_iterate (struct port_bucket *BUCKET,
          error_t (*FUN) (void *PORT))
     BUCKETの各portに対し一度だけFUNを呼び出す。


File: hurd-ja.info,  Node: Port References,  Next: RPC Management,  Prev: Port Metadata,  Up: Ports Library

4.3.4 portの参照
----------------

これらの関数はport情報構造体がもはや必要とされていないときに限り解放され
るように、portへの参照を管理する。`libports'にいつportへの参照が変
化するかを教えるのは、あなたの責任である。

 -- Function: void ports_port_ref (void *PORT)
     PORTへの強い参照を割り当てる。

 -- Function: void ports_port_deref (void *PORT)
     PORTへの強い参照を減少させる。

 -- Function: void ports_no_senders (void *PORT,
          mach_port_mscount_t MSCOUNT)
     ユーザは送信元不在通知を受け取ろうとすることに責任がある。やって来たとき
     には、そのメッセージが送られたPORTに対して、その通知からの
     MSCOUNTを与えてこのルーチンを呼び出しなさい。

 -- Function: int ports_count_class (struct port_class *CLASS)
     CLASSに新しいportを生成するのを妨げる。現在CLASSにあるportの
     数を返す。

 -- Function: int ports_count_bucket (struct port_bucket *BUCKET)
     BUCKETに新しいportを生成するのを妨げる。現在BUCKETにあるport
     の数を返す。

 -- Function: void ports_enable_class (struct port_class *CLASS)
     (`ports_count_class'によって妨げられた)中断されたport生成を続けるこ
     とを許可する。

 -- Function: void ports_enable_bucket (struct port_bucket *BUCKET)
     (`ports_count_bucket'によって妨げられた)中断されたport生成を続けるこ
     とを許可する。

   弱い参照はDROPWEAK_ROUTINEがnullであるport classでは強い参照を同じ
なので、それほど使用されない。*Note Buckets and Classes::。

 -- Function: void ports_port_ref_weak (void *PORT)
     PORTへの弱い参照を割り当てる。

 -- Function: void ports_port_deref_weak (void *PORT)
     PORTへの弱い参照を減少させる。


File: hurd-ja.info,  Node: RPC Management,  Prev: Port References,  Up: Ports Library

4.3.5 RPCの操作
---------------

`libports'関数の残りはRPC操作を制御することにささげられる。これらの
関数は頑健なサーバを構築するために必要とされるlockingやthread
cancellationを全て行うのに役立つ。

 -- Typedef: typedef int (* ports_demuxer_type )
          (mach_msg_header_t *INP, mach_msg_header_t *OUTP)
     MiGのdemuxerルーチンの型。

 -- Function: error_t ports_begin_rpc (void *PORT, mach_msg_id_t MSG_ID,
          struct rpc_info *INFO)
     RPCがPORT上で開始しているときにこれを呼び出す。INFOは呼び出
     し元で割り当てられるべきで、動的な状態を保持するのに使われるだろう。この
     RPCが放棄されれば、`EDIED'を返す。そうでなければゼロを返す。

 -- Function: void ports_end_rpc (void *PORT, struct rpc_info *INFO)
     RPCが終えられているときにこれを呼び出す。引数は対になる
     `ports_begin_rpc'の呼び出しに渡されたものと一致しなければならない。

 -- Function: void ports_manage_port_operations_one_thread
          (struct port_bucket *BUCKET, ports_demuxer_type DEMUXER,
          int TIMEOUT)
     BUCKETのportへの操作を処理し始め、それぞれのやって来るメッセージに
     対しDEMUXERを呼び出す。TIMEOUTが非ゼロでTIMEOUTミリ秒
     の間メッセージが受け取られないと返る。たった一つのスレッドだけ(呼び出し
     スレッド)を使う。

 -- Function: void ports_manage_port_operations_multithread
          (struct port_bucket *BUCKET, ports_demuxer_type DEMUXER,
          int THREAD_TIMEOUT, int GLOBAL_TIMEOUT, void (*HOOK) (void))
     BUCKETのportへの操作を処理し始め、それぞれのやって来るメッセージに
     対しDEMUXERを呼び出す。GLOBAL_TIMEOUTが非ゼロで
     GLOBAL_TIMEOUTミリ秒の間メッセージを受け取られないと返る。他のport
     での緩慢さが原因でどのportも飢餓状態にならないように、やって来るメッセー
     ジを処理するのに必要なだけスレッドを生成する。もしTHREAD_TIMEOUTが
     非ゼロなら、個々のスレッドはTHREAD_TIMEOUT(1)ミリ秒の間
     やって来るメッセージを処理しなかったら死んでいくだろう。もしnullでないな
     ら、HOOKは、新しいスレッドが作られる後にすぐ、それぞれに対して呼び
     出されるだろう。

 -- Function: error_t ports_inhibit_port_rpcs (void *PORT)
     PORTへのどの未処理のRPCにも割り込む。全ての未処理のRPCが終わるのを
     待ち、そしてこのportで始まるどの新しいRPCでも妨げる。

 -- Function: error_t ports_inhibit_class_rpcs (struct port_class *CLASS)
     `ports_inhibit_port_rpcs'に似ているが、CLASSの全てのportに影
     響する。

 -- Function: error_t ports_inhibit_bucket_rpcs
          (struct port_bucket *BUCKET)
     `ports_inhibit_port_rpcs'に似ているが、BUCKETの全てのportに影
     響する。

 -- Function: error_t ports_inhibit_all_rpcs (void)
     `ports_inhibit_port_rpcs'に似しているが、ありとあらゆるportに影響する。

 -- Function: void ports_resume_port_rpcs (void *PORT)
     このPORTに対する以前の`ports_inhibit_port_rpcs'の効果を元に戻
     し、妨げられたRPCを続けることを許可する。

 -- Function: void ports_resume_class_rpcs (struct port_class *CLASS)
     このCLASSに対する以前の`ports_inhibit_class_rpcs'の効果を元に
     戻す。

 -- Function: void ports_resume_bucket_rpcs (struct port_bucket *BUCKET)
     このBUCKETに対する以前の`ports_inhibit_bucket_rpcs'の効果を元
     に戻す。

 -- Function: void ports_resume_all_rpcs (void)
     以前の`ports_inhibit_all_rpcs'の効果を元に戻す。

 -- Function: void ports_interrupt_rpcs (void *PORT)
     PORTで進行中のどのRPCも(`thread_cancel'を使って)中止する。

 -- Function: int ports_self_interrupted (void)
     もし現在のスレッドのRPCが`ports_interrupt_rpcs'で割り込まれたなら、
     非ゼロを返し、割り込みフラグを取り除く。

 -- Function: error_t ports_interrupt_rpc_on_notification (void *OBJECT,
          struct rpc_info *RPC, mach_port_t PORT, mach_msg_id_t WHAT)
     WHATにあるもののいづれかがPORTに対して起きたなら、
     `hurd_cancel'がRPCのスレッド上で呼ばれるように手配する。
     RPCはOBJECT上のRPCであるべきだ。

 -- Function: error_t ports_interrupt_self_on_notification (void *OBJECT,
          mach_port_t PORT, mach_msg_id_t WHAT)
     もしPORTがWHATという条件で通知を受けたら、`hurd_cancel'
     が、それはOBJECT上のRPCであるべきだが、現在のスレッド上で呼ばれる
     ように手配する。

 -- Function: error_t ports_interrupt_self_on_port_death (void *OBJECT,
          mach_port_t PORT)
     WHATが`MACH_NOTIFY_DEAD_NAME'に設定されて
     `ports_interrupt_self_on_notification'を呼ぶのと同じである。

 -- Function: void ports_interrupt_notified_rpcs (void *OBJECT,
          mach_port_t PORT, mach_msg_id_t WHAT)
     そのようにリクエストしているOBJECT上のどのRPCにも割り込む。

 -- Function: void ports_dead_name (void *OBJECT, mach_port_t PORT)
     WHATが`MACH_NOTIFY_DEAD_NAME'に設定されて
     `ports_interrupt_notified_rpcs'を呼ぶのと同じである。

   ---------- Footnotes ----------

   (1) 訳注: 原文では
LOCAL_TIMEOUTとなっているが間違いだと思われる。要確認。


File: hurd-ja.info,  Node: Integer Hash Library,  Next: Misc Library,  Prev: Ports Library,  Up: Foundations

4.4 整数ハッシュ・ライブラリ
============================

`libihash'は任意の要素データ型に対して、整数を鍵としたハッシュ表を
提供する。この種のハッシュ表は疎らな配列やバッファ・キャッシュを実装する
ときに頻繁に使われる。

   以下の関数は`<hurd/ihash.h>'で宣言されている。

 -- Function: error_t ihash_create (ihash_t *HT)
     整数ハッシュ表を生成し、それをHTに返す。もしメモリ割り当てエラーが
     起きれば、`ENOMEM'が返され、そうでなければゼロである。

 -- Function: void ihash_free (ihash_t HT)
     HTとそれが消費している全ての資源を解放する。

 -- Function: void ihash_set_cleanup (ihash_t HT,
          void (*CLEANUP) (void *VALUE, void *ARG), void *ARG)
     HTの要素を後始末する関数をCLEANUPに設定し、その二つ目の引数
     をARGに設定する。その後上書きされたり削除される、あらゆる要素
     VALUEに対して、ARGを二番目の引数としてCLEANUPが呼び出
     されるだろう。

 -- Function: error_t ihash_add (ihash_t HT, int ID, void *ITEM,
          void ***LOCP)
     整数鍵IDの下にITEMをハッシュ表HTに加える。LOCPは
     ITEMに位置するポインタのアドレスである。もしnullでなければ、
     LOCPは`void **'型の変数を指しているべきで、
     `ihash_locp_remove'の引数として使われて良いポインタで埋められるだろ
     う。LOCPによって指された変数はこの呼び出しとその要素が削除されると
     きの間のいつかに上書きされるかもしれない。だからその値を他の場所に隠して
     おき、その隠しておいた値を`ihash_locp_remove'で使おうと考えることは
     できない。もしメモリ割り当てエラーが起きると、`ENOMEM'が返され、そ
     うでなければゼロが返る。

 -- Function: void * ihash_find (ihash_t HT, int ID)
     ハッシュ表HTで鍵IDで項目を探して返す。指定された項目が存在し
     なければnullを返す。

 -- Function: error_t ihash_iterate (ihash_t HT,
          error_t (*FUN) (void *VALUE))
     HTのあらゆる要素に関数FUNを呼び出す。FUNの唯一の引数、
     VALUEはそのハッシュ表に収められている値へのポインタである。もし
     FUNが非ゼロをいつか返せば、繰り返すのを止め、`ihash_iterate'
     はその値を返し、そうでなければそれは(最後には)0を返す。

 -- Function: int ihash_remove (ihash_t HT, int ID)
     HTからIDの鍵に伴う項目を削除する。もしそのような要素がなかっ
     たら、ゼロを返し、そうでなければ非ゼロを返す。

 -- Function: void ihash_locp_remove (ihash_t HT, void **HT_LOCP)
     ハッシュ表HTからLOCPにある項目を削除する。LOCPは
     `ihash_add'への以前の呼び出しから返されたのと同じものである。この呼
     び出しは`ihash_remove'より速いはずだ。その呼び出しが成功するのに、
     後始末が行われていない場合には、HTがnullで良い。


File: hurd-ja.info,  Node: Misc Library,  Next: Bug Address Library,  Prev: Integer Hash Library,  Up: Foundations

4.5 雑多なライブラリ
====================

GNU CライブラリはHurdの必要性を満たすように絶えず発展している。しかしな
がら、Cライブラリは非常に安定している必要があるので、新しい関数のインター
フェースを注意深く指定し、完全にそれらを試験することなく、それらを加える
のは無責任である。

   Hurdの配布には`libshouldbeinlibc'と呼ばれるライブラリが含まれ、それ
はGNU Cライブラリへ追加するための試験をする基盤として役に立つ。関数の一
部はHurd開発者によってそれに加えられ、それ以外は公式のCライブラリに移動するというように、このライブラリは流動的である。

これらの関数は(それらのヘッダ・ファイル以外は)現在解説されていないが、こ
れらの関数がGNU Cライブラリの一部となるときに、完全な解説が *Note The
GNU C Library Reference Manual: (libc)Top, に加えられるだろう。


File: hurd-ja.info,  Node: Bug Address Library,  Prev: Misc Library,  Up: Foundations

4.6 バグの宛先ライブラリ
========================

`libhurdbugaddr'は単一の変数を定義するためだけに存在する。

 -- Variable: char * argp_program_bug_address
     `argp_program_bug_address'はデフォルトのHurdバグ報告用e-mailアドレ
     スで、<bug-hurd@gnu.org>である。この宛先は標準的なHurdサーバやユー
     ティリティのいづれかが`--help'オプションを使って起動されたときにユー
     ザに示される。


File: hurd-ja.info,  Node: Input and Output,  Next: Files,  Prev: Foundations,  Up: Top

5 入力と出力
************

GNU Hurdのほとんど全てのサーバで相互に作用するために使われているので、
I/Oサブシステムに伴う特定のプログラムやサーバはない。それはI/Oチャネルを
読んだり書いたりするための能力を提供しており、I/OチャネルはGNU Cライブラ
リにおけるファイルやソケットの記述子の土台となる実装である。

* Menu:

* Iohelp Library::              I/Oの認証とロックの管理。
* Pager Library::               マルチスレッド化された外部ページャの実装。
* I/O Interface::               RPCに基く入出力チャネル。


File: hurd-ja.info,  Node: Iohelp Library,  Next: Pager Library,  Up: Input and Output

5.1 iohelpライブラリ
====================

`<hurd/iohelp.h>'ファイルは低水準のI/Oの実装に役立つ、いくつかの関
数を宣言している。ほとんどのHurdサーバはこれらの関数を直接呼び出さないが、
それらはHurdのファイルシステムやネットワーキング支援ライブラリのいくらか
で使われている。`libiohelp'は`libthreads'を必要とする。

* Menu:

* I/O Users::                   ユーザ認証の管理。
* Conch Management::            非難された共有I/Oの実装。


File: hurd-ja.info,  Node: I/O Users,  Next: Conch Management,  Up: Iohelp Library

5.1.1 I/Oのユーザ
-----------------

ほとんどのI/Oサーバはある種のユーザ認証確認を実装する必要がある。その過
程を容易にするために、単一の`struct iouser'にidvecの組(FIXME: xref to C
library)を要約するいくつかの関数を持つ。

 -- Function: struct iouser * iohelp_create_iouser (struct idvec *UIDS,
          struct idvec *GIDS)
     指定されたUIDSとGIDSに対し新しいIOUSERを生成する。

 -- Function: struct iouser * iohelp_dup_iouser (struct iouser *IOUSER)
     IOUSERの複製を返す。

 -- Function: void iohelp_free_iouser (struct iouser *IOUSER)
     IOUSERへの参照を解放する。

   I/O再認証は信頼される第三者として認証サーバを伴ういくぶん複雑なプロト
コルである (*note Auth Protocol::)。駄目な実装の危険性を減らすために、
I/O再認証は`iohelp_reauth'関数に要約されている。

 -- Function: struct iouser * iohelp_reauth (auth_t AUTHSERVER,
          mach_port_t REND_PORT, mach_port_t NEWRIGHT,
          int PERMIT_FAILURE)
     再認証の処理を管理し、新しいIOUSERを返す。AUTHSERVERはI/Oサー
     バの認証portである。ユーザによって提供される待ち合わせのportは
     REND_PORTである。

     もし処理が完了できなければ、PERMIT_FAILUREが非ゼロでなければゼロを
     返す。もしPERMIT_FAILUREが非ゼロで、処理が失敗したなら、識別子を持
     たないIOUSERを返す。ユーザに送られる新しいportはNEWRIGHTであ る。


File: hurd-ja.info,  Node: Conch Management,  Prev: I/O Users,  Up: Iohelp Library

5.1.2 conchの管理
-----------------

"conch"は共有メモリI/Oサブシステムの心臓部にある。いくつかのHurdライ
ブラリは共有I/Oを実装し、だから`libiohelp'はconch管理を容易にする関
数を含む。

共有I/Oに関するものはどれでも解説されていない。なぜなら、それは十分な性
能には必要なく、RPCインターフェースはもっと単純だからだ (*note I/O
Interface::)。新しいライブラリやサーバが共有I/Oを実装するのは役に立たない。


File: hurd-ja.info,  Node: Pager Library,  Next: I/O Interface,  Prev: Iohelp Library,  Up: Input and Output

5.2 ページャ・ライブラリ
========================

"外部ページャ" ("XP")マイクロカーネル・インターフェースはハード
ウェアのページ・フォールトをRPCリクエストに変換することによって、アプリ
ケーションがメモリ・オブジェクトにbacking storeを提供できるようにする。
外部ページャはmemory-mapped I/O(*note Mapped Data::)とstored filesystem
(*note Stored Filesystems::)に必要とされる。

外部ページャのインターフェースは非常に複雑なので、Hurdページャ・ライブラ
リはマルチスレッド化された外部ページャを作ることを目的とする関数を含む。
`libpager'は`<hurd/pager.h>'で宣言され、スレッドとportライブラ
リだけを必要とする。

* Menu:

* Pager Management::            外部ページャへの高水準なインターフェース。
* Pager Callbacks::             ユーザが定義しなければならない関数。


File: hurd-ja.info,  Node: Pager Management,  Next: Pager Callbacks,  Up: Pager Library

5.2.1 ページャの管理
--------------------

ページャ・ライブラリはマルチスレッド化されたページャを実現するために
`struct pager'データ型を定義する。ページャを生成するための一般的な
手続きは、*Note Pager
Callbacks::で列挙される関数を定義し、ページャがアク
セスするportのための`libports' bucketを確保し、少なくとも一つの新し
い`struct pager'を`pager_create'で生成することである。

 -- Function: struct pager * pager_create
          (struct user_pager_info *U_PAGER, struct port_bucket *BUCKET,
          boolean_t MAY_CACHE,
          memory_object_copy_strategy_t COPY_STRATEGY)
     新しいページャを生成する。ページャは(`libports'を使って、
     BUCKETに)それのために生成されたportを持つようになり、直ちにリクエ
     ストを受け付ける準備が整うだろう。U_PAGERはその後の
     `pager_find_address'への呼び出しに提供されるだろう。ページャは一つ
     のユーザ参照を生成させるだろう。MAY_CACHEとCOPY_STRATEGYは
     MEMORY_OBJECT_READYに対するものと同じ、これらの属性の元の値である。
     ユーザは関連したportのライブラリ関数を使用してページャへの参照を生成して
     よい。エラーでnullを返し、`errno'を設定する。

   制御をページャ・ライブラリに引き渡す準備が整うと、`pager_demuxer'を
portのDEMUXERとして使ってBUCKET上で
`ports_manage_port_operations_multithread'を呼び出すべきだ。これは
全ての外部ページャRPCを処理し、必要なとき、あなたのページャコールバック
を起動するだろう。

 -- Function: int pager_demuxer (mach_msg_header_t *INP,
          mach_msg_header_t *OUTP)
     ページャのportにやって来る`libports'メッセージをdemultiplexする。

以下の関数はページャ・ライブラリの本体であり、ページャの機能へのすっきり
したインターフェースを提供する。

 -- Function: void pager_sync (struct pager *PAGER, int WAIT)
 -- Function: void pager_sync_some (struct pager *PAGER,
          vm_address_t START, vm_size_t LEN, int WAIT)
     ページャPAGERからそのbacking storeへデータを書き込む。WAITが
     設定されている場合に限り、その全ての書き込みが完了するまで待つ。

     `pager_sync'は全てのデータを書き込む。`pager_sync_some'は
     STARTで始まるデータをLENバイトだけ書き込む。

 -- Function: void pager_flush (struct pager *PAGER, int WAIT)
 -- Function: void pager_flush_some (struct pager *PAGER,
          vm_address_t START, vm_size_t LEN, int WAIT)
     カーネルからページャPAGERのデータをフラッシュし、未処理の遅らされ
     たコピーを強制する。WAITが設定されている場合に限り、全てのページが
     フラッシュされるまで待つ。

     `pager_flush'は全てのデータをフラッシュする。
     `pager_flush_some'はSTARTで始まるデータをLENバイトだけ
     フラッシュする。

 -- Function: void pager_return (struct pager *PAGER, int WAIT)
 -- Function: void pager_return_some (struct pager *PAGER,
          vm_address_t START, vm_size_t LEN, int WAIT)
     カーネルからページャPAGERのデータをフラッシュし、未処理の遅らされ
     たコピーを強制する。WAITが設定されている場合に限り、全てのページが
     フラッシュされるまで待つ。カーネルに修正をwrite backさせる。

     `pager_return'は全てのデータをフラッシュして復元する。
     `pager_return_some'はSTARTで始まるデータをLENバイトだけ
     フラッシュして復元する。

 -- Function: void pager_offer_page (struct pager *PAGER, int PRECIOUS,
          int WRITELOCK, vm_offset_t PAGE, vm_address_t BUF)
     データのページをカーネルに提供する。PRECIOUSが設定されていると、こ
     のページはいつか将来にページ・アウトされ、そうでなければカーネルによって
     外されるかもしれない。もしそのページが現在コアにあると、カーネルはこの呼
     び出しを無視するかもしれない。

 -- Function: void pager_change_attributes (struct pager *PAGER,
          boolean_t MAY_CACHE,
          memory_object_copy_strategy_t COPY_STRATEGY, int WAIT)
     ページャPAGERの土台となるメモリ・オブジェクトの属性を変更する。
     MAY_CACHEとCOPY_STRATEGY引数は
     `memory_object_change_attributes'に対するものと同様である。
     WAITが設定されている場合に限り、カーネルが完了を報告するまで待つ。

 -- Function: void pager_shutdown (struct pager *PAGER)
     ページャの終了を強制する。これが返った後、ページャへのページング・リクエ
     ストはもはや受理されず、ページャは解放されるだろう。最初に完了する現在未
     処理のページング・リクエストがあるなら、本当の解放は非同期的に起きるだろ
     う(1)。

 -- Function: error_t pager_get_error (struct pager *P, vm_address_t ADDR)
     Return the error code of the last page error for pager P at
     address ADDR.(2)

 -- Function: error_t pager_memcpy (struct pager *PAGER,
          memory_object_t MEMOBJ, vm_offset_t OFFSET, void *OTHER,
          size_t *SIZE, vm_prot_t PROT)
     Try to copy `*SIZE' bytes between the region OTHER points to and
     the region at OFFSET in the pager indicated by PAGER and MEMOBJ.
     If PROT is `VM_PROT_READ', copying is from the pager to OTHER; if
     PROT contains `VM_PROT_WRITE', copying is from OTHER into the
     pager.  `*SIZE' is always filled in the actual number of bytes
     successfully copied.  Returns an error code if the pager-backed
     memory faults; if there is no fault, returns zero and `*SIZE' will
     be unchanged.

   These functions allow you to recover the internal `struct pager'
state, in case the `libpager' interface doesn't provide an operation
you need:

 -- Function: struct user_pager_info * pager_get_upi (struct pager *P)
     Return the `struct user_pager_info' associated with a pager.

 -- Function: mach_port_t pager_get_port (struct pager *PAGER)
     Return the port (receive right) for requests to the pager.  It is
     absolutely necessary that a new send right be created from this
     receive right.

   ---------- Footnotes ----------

   (1) 訳注: XXX

   (2) Note that this function will be deleted when the Mach pager
interface is fixed to provide this information.


File: hurd-ja.info,  Node: Pager Callbacks,  Prev: Pager Management,  Up: Pager Library

5.2.2 Pager Callbacks
---------------------

Like several other Hurd libraries, `libpager' depends on you to
implement application-specific callback functions.  You _must_ define
the following functions:

 -- Function: error_t pager_read_page (struct user_pager_info *PAGER,
          vm_offset_t PAGE, vm_address_t *BUF, int *WRITE_LOCK)
     For pager PAGER, read one page from offset PAGE.  Set `*BUF' to be
     the address of the page, and set `*WRITE_LOCK' if the page must be
     provided read-only.  The only permissable error returns are `EIO',
     `EDQUOT', and `ENOSPC'.

 -- Function: error_t pager_write_page (struct user_pager_info *PAGER,
          vm_offset_t PAGE, vm_address_t BUF)
     For pager PAGER, synchronously write one page from BUF to offset
     PAGE.  In addition, `vm_deallocate' (or equivalent) BUF.  The only
     permissable error returns are `EIO', `EDQUOT', and `ENOSPC'.

 -- Function: error_t pager_unlock_page (struct user_pager_info *PAGER,
          vm_offset_t ADDRESS)
     A page should be made writable.

 -- Function: error_t pager_report_extent (struct user_pager_info *PAGER,
          vm_address_t *OFFSET, vm_size_t *SIZE)
     This function should report in `*OFFSET' and `*SIZE' the minimum
     valid address the pager will accept and the size of the object.

 -- Function: void pager_clear_user_data (struct user_pager_info *PAGER)
     This is called when a pager is being deallocated after all extant
     send rights have been destroyed.

 -- Function: void pager_dropweak (struct user_pager_info *P)
     This will be called when the ports library wants to drop weak
     references.  The pager library creates no weak references itself,
     so if the user doesn't either, then it is alright for this
     function to do nothing.


File: hurd-ja.info,  Node: I/O Interface,  Prev: Pager Library,  Up: Input and Output

5.3 I/O Interface
=================

The I/O interface facilities are described in `<hurd/io.defs>'.  This
section discusses only RPC-based I/O operations.(1)

* Menu:

* I/O Object Ports::            How ports to I/O objects work.
* Simple Operations::           Read, write, and seek.
* Open Modes::                  State bits that affect pieces of operation.
* Asynchronous I/O::            How to be notified when I/O is possible.
* Information Queries::         How to implement `io_stat' and
                                  `io_server_version'.
* Mapped Data::                 Getting memory objects referring to the
                                  data of an I/O object.

   ---------- Footnotes ----------

   (1) The latter portion of `<hurd/io.defs>' and all of
`<hurd/shared.h>' describe how to implement shared-memory I/O
operations.  However, shared I/O has been deprecated.  *Note Conch
Management::, for more details.


File: hurd-ja.info,  Node: I/O Object Ports,  Next: Simple Operations,  Up: I/O Interface

5.3.1 I/O Object Ports
----------------------

The I/O server must associate each I/O port with a particular set of
uids and gids, identifying the user who is responsible for operations on
the port.  Every port to an I/O server should also support either the
file protocol (*note File Interface::) or the socket protocol (*note
Socket Interface::); naked I/O ports are not allowed.

   In addition, the server associates with each port a default file
pointer, a set of open mode bits, a pid (called the "owner"), and some
underlying object which can absorb data (for write) or provide data (for
read).

   The uid and gid sets associated with a port may not be visibly shared
with other ports, nor may they ever change.  The server must fix the
identification of a set of uids and gids with a particular port at the
moment of the port's creation.  The other characteristics of an I/O port
may be shared with other users.  The I/O server interface does not
generally specify in what way servers may share these other
characteristics are shared (with the exception of the deprecated
`O_ASYNC' interface); however, the file and socket interfaces make
further requirements about what sharing is expected and prohibited from
occurring.

   In general, users get send rights to I/O ports by some mechanism
that is external to the I/O protocol.  (For example fileservers give
out I/O ports in response to the `dir_lookup' and `fsys_getroot' calls.
Socket servers give out ports in response to the `socket_create' and
`socket_accept' calls.)  However, the I/O protocol provides methods of
obtaining new ports that refer to the same underlying object as another
port.  In response to all of these calls, all underlying state
(including, but not limited to, the default file pointer, open mode
bits, and underlying object) must be shared between the old and new
ports.  In the following descriptions of these calls, the term
"identical" means this kind of sharing.  All these calls must return
send rights to a newly-constructed Mach port.

   The `io_duplicate' call simply returns another port which is
identical to an existing port and has the same uid and gid set.

   The `io_restrict_auth' call returns another port, identical to the
provided port, but which has a smaller associated uid and gid set.  The
uid and gid sets of the new port are the intersection of the set on the
existing port and the lists of uids and gids provided in the call.

   Users use the `io_reauthenticate' call when they wish to have an
entirely new set of uids or gids associated with a port.  In response to
the `io_reauthenticate' call, the server must create a new port, and
then make the call `auth_server_authenticate' to the auth server.  The
rendezvous port for the `auth_server_authenticate' call is the I/O port
to which was made the `io_reauthenticate' call.  The server provides
the REND_INT parameter to the auth server as a copy from the
corresponding parameter in the `io_reauthenticate' call.  The I/O
server also gives the auth server a new port; this must be a newly
created port identical to the old port.  The authserver will return the
set of uids and gids associated with the user, and guarantees that the
new port will go directly to the user that possessed the associated
authentication port.  The server then identifies the new port given out
with the specified ID's.


File: hurd-ja.info,  Node: Simple Operations,  Next: Open Modes,  Prev: I/O Object Ports,  Up: I/O Interface

5.3.2 Simple Operations
-----------------------

Users write to I/O ports by calling the `io_write' RPC.  They specify
an OFFSET parameter; if the object supports writing at arbitrary
offsets, the server should honour this parameter.  If -1 is passed as
the offset, then the server should use the default file pointer.  The
server should return the amount of data which was successfully written.
If the operation was interrupted after some but not all of the data
was written, then it is considered to have succeeded and the server
should return the amount written.  If the port is not an I/O port at
all, the server should reply with the error `EOPNOTSUPP'.  If the port
is an I/O port, but does not happen to support writing, then the
correct error is `EBADF'.

   Users read from I/O ports by calling the `io_read' RPC.  They
specify the amount of data they wish to read and the offset.  The offset
has the same meaning as for `io_write' above.  The server should return
the data that was read.  If the call is interrupted after some data has
been read (and the operation is not idempotent) then the server should
return the amount read, even if less than the amount requested.  The
server should return as much data as possible, but never more than
requested by the user.  If there is no data, but there might be later,
the call should block until data becomes available.  Indicate
end-of-file conditions by returning zero bytes.  If the call is
interrupted after some data has been read, but the call is idempotent,
then the server may return `EINTR' rather than actually filling the
buffer (taking care that any modifications of the default file pointer
have been reversed).  Preferably, however, servers should return data.

   There are two categories of objects: seekable and non-seekable.
Seekable objects must accept arbitrary offset parameters in the
`io_read' and `io_write' calls, and to implement the `io_seek' call.
Nonseekable objects must ignore the offset parameters to `io_read' and
`io_write', and should return `ESPIPE' to the `io_seek' call.

   On seekable objects, `io_seek' changes the default file pointer for
reads and writes.  (*Note File Positioning: (libc)File Positioning, for
the interpretation of the WHENCE and OFFSET arguments.)  It returns the
new offset as modified by `io_seek'.

   The `io_readable' interface returns the amount of data which can be
immediately read.  For the special technical meaning of "immediately",
see *Note Asynchronous I/O::.


File: hurd-ja.info,  Node: Open Modes,  Next: Asynchronous I/O,  Prev: Simple Operations,  Up: I/O Interface

5.3.3 Open Modes
----------------

The server associates each port with a set of bits that affect its
operation.  The `io_set_all_openmodes' call modifies these bits and the
`io_get_openmodes' call returns them.  In addition, the
`io_set_some_openmodes' and `io_clear_some_openmodes' do an atomic
read/modify/write of the openmodes.

   The `O_APPEND' bit, when set, changes the behaviour of `io_write'
when it uses the default file pointer on seekable objects.  When
`io_write' is done on a port with the `O_APPEND' bit set, is must set
the file pointer to the current file size before doing the write (which
would then increment the file pointer as usual).  The "current file
size" is the smallest offset which returns end-of-file when provided to
`io_read'.  The server must atomically bind this update to the actual
data write with respect to other users of `io_read', `io_write', and
`io_seek'.

   The `O_FSYNC' bit, when set, guarantees that `io_write' will not
return until data is fully written to the underlying medium.

   The `O_NONBLOCK' bit, when set, prevents read and write from
blocking.  They should copy such data as is immediately available.  If
no data is immediately available they should return `EWOULDBLOCK'.

   The definition of "immediately" is more-or-less server-dependent.
Some servers, notably stored filesystem servers (*note Stored
Filesystems::), regard all data as immediately available.  The one
criterion is that something which must happen "immediately" may not
wait for any user-synchronizable event.

   The `O_ASYNC' bit is deprecated; its use is documented in the
following section.  This bit must be shared between all users of the
same underlying object.


File: hurd-ja.info,  Node: Asynchronous I/O,  Next: Information Queries,  Prev: Open Modes,  Up: I/O Interface

5.3.4 Asynchronous I/O
----------------------

Users may wish to be notified when I/O can be done without blocking;
they use the `io_async' call to indicate this to the server.  In the
`io_async' call the user provides a port on which will the server
should send `sig_post' messages as I/O becomes possible.  The server
must return a port which will be the reference port in the `sig_post'
messages.  Each `io_async' call should generate a new reference port.
(FIXME: xref the C library manual for information on how to send
sig_post messages.)

   The server then sends one `SIGIO' signal to each registered async
user everytime I/O becomes possible.  I/O is possible if at least one
byte can be read or written immediately.  The definition of
"immediately" must be the same as for the implementation of the
`O_NONBLOCK' flag (*note Open Modes::).  In addition, every time a user
calls io_read or io_write on a non-seekable object, or at the default
file pointer on a seekable object, another signal should be sent to
each user if I/O is still possible.

   Some objects may also define "urgent" conditions.  Such servers
should send the `SIGURG' signal to each registered async user anytime an
urgent condition appears.  After any RPC that has the possibility of
clearing the urgent condition, the server should again send the signal
to all registered users if the urgent condition is still present.

   A more fine-grained mechanism for doing async I/O is the `io_select'
call.  The user specifies the kind of access desired, and a send-once
right.  If I/O of the kind the user desires is immediately possible,
then the server should return so indicating, and destroy the send-once
right.  If I/O is not immediately possible, the server should save the
send-once right, and send a `select_done' message as soon as I/O
becomes immediately possible.  Again, the definition of "immediately"
must be the same for `io_select', `io_async', and `O_NONBLOCK' (*note
Open Modes::).

   For compatibility with 4.2 and 4.3 BSD, the I/O interface provides a
deprecated feature (known as "icky async I/O").  The calls
`io_mod_owner' and `io_get_owner' to set the "owner" of the object,
providing either a pid or a pgrp (if the value is negative).  This
implies that only one process at a time can do icky I/O on a given
object.  Whenever the I/O server is sending `sig_post' messages to all
the `io_async' users, if the `O_ASYNC' bit is set, the server should
also send a signal to the owning pid/pgrp.  The ID port for this call
should be different from all the `io_async' ID ports given to users.
Users may find out what ID port the server uses for this by calling
`io_get_icky_async_id'.


File: hurd-ja.info,  Node: Information Queries,  Next: Mapped Data,  Prev: Asynchronous I/O,  Up: I/O Interface

5.3.5 Information Queries
-------------------------

Users may call `io_stat' to find out information about the I/O object.
Most of the fields of a `struct stat' are meaningful only for files.
All objects, however, must support the fields `st_fstype', ST_FSID,
ST_INO, ST_ATIME, ST_ATIME_USEC, ST_MTIME_USER, ST_CTIME,
ST_CTIME_USEC, and ST_BLKSIZE.

   ST_FSTYPE, ST_FSID, and ST_INO must be unique for the underlying
object across the entire system.

   ST_ATIME and ST_ATIME_USEC hold the seconds and microseconds,
respectively, of the system clock at the last time the object was read
with `io_read'.

   ST_MTIME and ST_MTIME_USEC hold the second and microseconds,
respectively, of the system clock at the last time the object was
written with `io_write'.

   Other appropriate operations may update the ATIME and the MTIME as
well; both the file and socket interfaces specify such operations.

   ST_CTIME and ST_CTIME_USEC hold the seconds and microseconds,
respectively, of the system clock at the last time permanent meta-data
associated with the object was changed.  The exact operations which
couse such an update are server-dependent, but must include the
creation of the object.

   The server is permitted to delay the actual update of these times
until stat is called; before the server stores the times on permanent
media (if it ever does so) it should update them if necessary.

   ST_BLKSIZE gives the optimal I/O size in bytes for `io_read' and
`io_write'; users should endeavor to read and write amounts which are
multiples of the optimal size, and to use offsets which are multiples
of the optimal size

   In addition, objects which are seekable should set ST_SIZE to the
current file size as in the description of the `O_APPEND' flag (*note
Open Modes::).

   The ST_UID and ST_GID fields are unrelated to the "owner" as
described above for icky async I/O.

   Users may find out the version of the server they are talking to by
calling `io_server_version'; this should return strings and integers
describing the version number of the server, as well as its name.


File: hurd-ja.info,  Node: Mapped Data,  Prev: Information Queries,  Up: I/O Interface

5.3.6 Mapped Data
-----------------

Servers may optionally implement the `io_map' call.  The ports returned
by `io_map' must implement the external pager kernel interface (*note
Pager Library::) and be suitable as arguments to `vm_map'.

   Seekable objects must allow access from zero up to (but not
including) the current file size as described for `O_APPEND' (*note
Open Modes::).  Whether they provide access beyond such a point is
server-dependent; in addition, the meaning of accessing a non-seekable
object is server-dependent.


File: hurd-ja.info,  Node: Files,  Next: Special Files,  Prev: Input and Output,  Up: Top

6 Files
*******

A file is traditionally thought of as a quantity of disk storage.  In
the Hurd, files are an extension of the I/O interface, but they do not
necessarily correspond to disk storage.

   Every file in the Hurd is represented by a port, which is connected
to the server that manages the file.  When a client wants to operate on
a file, it makes RPC requests via a file port to its server process,
which is commonly called a "translator".

* Menu:

* Translators::                 Extending the Hurd filesystem hierarchy.
* Trivfs Library::              Implementing single-file translators.
* Fshelp Library::              Miscellaneous generic filesystem routines.
* File Interface::              File ports implement the file interface.
* Filesystem Interface::        Translator control interface.


File: hurd-ja.info,  Node: Translators,  Next: Trivfs Library,  Up: Files

6.1 Translators
===============

The Hurd filesystem allows you to set translators on any file or
directory that you own.  A "translator" is any Hurd server which
provides the basic filesystem interface.  Translated nodes are somewhat
like a cross between Unix symbolic links and mount points.

   Whenever a program tries to access the contents of a translated node,
the filesystem server redirects the request to the appropriate
translator (starting it if necessary).  Then, the new translator
services the client's request.  The GNU C library makes this behaviour
seamless from the client's perspective, so that standard Unix programs
behave correctly under the Hurd.

   Translators run with the priviledges of the translated node's
_owner_, so they cannot be used to compromise the security of the
system.  This also means that _any_ user can write their own
translators, and provide other users with arbitrary
filesystem-structured data, regardless of the data's actual source.
Other chapters in this manual describe existing translators, and how you
can modify them or write your own.

   The standard Hurd filesystem servers are constantly evolving to
provide innovative features that users want.  Here are a few examples of
existing translators:

   * Disk-based filesystem formats, such as `ext2fs', `ufs', and
     `isofs' (*note Stored Filesystems::).

   * Network filesystems, such as `nfs' and `ftpfs' (*note Distributed
     Filesystems::).

   * Single files with dynamic content, such as a `~/.plan' which is
     automatically updated every time somebody fingers your account.

   * Filesystem nodes can serve as naming points for standard Hurd
     servers, even if they are unrelated to the filesystem.  For
     example, `pflocal' implements the filesystem interfaces, but it
     also provides a special Unix-domain socket RPC interface (FIXME
     xref).  Programs can fetch a port to this translator simply by
     calling `file_name_lookup' (FIXME xref) on `/servers/socket/1'(1)
     then use Unix socket-specific RPC's on that port.

   This section focuses on the generic programs that need to be
understood in order to use existing translators.  Many other parts of
this manual describe how you can write your own translators.

* Menu:

* Invoking settrans::           Declaring how a node should be translated.
* Invoking showtrans::          Displaying how nodes are translated.
* Invoking mount::              Unix-compatible active filesystem translators.
* Invoking fsysopts::           Modifying translation parameters at runtime.

   ---------- Footnotes ----------

   (1) The number 1 corresponds to the `PF_LOCAL' C library socket
domain constant.


File: hurd-ja.info,  Node: Invoking settrans,  Next: Invoking showtrans,  Up: Translators

6.1.1 Invoking `settrans'
-------------------------

The `settrans' program allows you to set a translator on a file or
directory.  By default, the passive translator is set (see the
`--passive' option).

   The `settrans' program has the following synopsis:

     settrans [OPTION]... NODE [TRANSLATOR ARG...]

where TRANSLATOR is the absolute filename of the new translator
program.  Each ARG is passed to TRANSLATOR when it starts.  If
TRANSLATOR is not specified, then `settrans' clears the existing
translator rather than setting a new one.

   `settrans' accepts the following options:

`-a'
`--active'
     Set NODE's active translator.  "Active translators" are started
     immediately and are not persistent: if the system is rebooted then
     they are lost.

`-c'
`--create'
     Create NODE as a zero-length file if it doesn't already exist.

`-L'
`--dereference'
     If NODE is already translated, stack the new translator on top of
     it (rather than replacing the existing translator).

`--help'
     Display a brief usage message, then exit.

`-p'
`--passive'
     Set NODE's passive translator.  "Passive translators" are only
     activated by the underlying filesystem when clients try to use the
     NODE, and they shut down automatically after they are no longer
     active in order to conserve system resources.

     Passive translators are stored on the underlying filesystem media,
     and so they persist between system reboots.  Not all filesystems
     support passive translators, due to limitations in their
     underlying media...  consult the filesystem-specific documentation
     to see if they are supported.

     If you are setting the passive translator, and NODE already has an
     active translator, then the following options apply:

    `-g'
    `--goaway'
          Tell the active translator to go away.  In this case, the
          following additional options apply:

         `-f'
         `--force'
               If the active translator doesn't go away, then force it.

         `-S'
         `--nosync'
               Don't flush its contents to disk before terminating.

         `-R'
         `--recursive'
               Shut down all of the active translator's children, too.

    `-k'
    `--keep-active'
          Leave the existing active translator running.  The new
          translator will not be started unless the active translator
          has stopped.

`-P'
`--pause'
     When starting an active translator, prompt and wait for a newline
     on standard input before completing the startup handshake.  This
     is useful when debugging a translator, as it gives you time to
     start the debugger.

`-t SEC'
`--timeout=SEC'
     If the translator does not start up in SEC seconds (the default is
     60), then return an error; if SEC is 0, then never timeout.

`--version'
     Output program version information and exit.

`-x'
`--exclusive'
     Only set the translator if there is none already.

   FIXME: finish


File: hurd-ja.info,  Node: Invoking showtrans,  Next: Invoking mount,  Prev: Invoking settrans,  Up: Translators

6.1.2 Invoking `showtrans'
--------------------------


File: hurd-ja.info,  Node: Invoking mount,  Next: Invoking fsysopts,  Prev: Invoking showtrans,  Up: Translators

6.1.3 Invoking `mount'
----------------------


File: hurd-ja.info,  Node: Invoking fsysopts,  Prev: Invoking mount,  Up: Translators

6.1.4 Invoking `fsysopts'
-------------------------


File: hurd-ja.info,  Node: Trivfs Library,  Next: Fshelp Library,  Prev: Translators,  Up: Files

6.2 Trivfs Library
==================

Certain translators do not need to be very complex, because they
represent a single file rather than an entire directory hierarchy.  The
trivfs library, which is declared in `<hurd/trivfs.h>', does most of
the work of implementing this kind of translator.  This library requires
the iohelp and ports libraries.

* Menu:

* Trivfs Startup::              Writing a simple trivfs-based translator.
* Trivfs Callbacks::            Mandatory user-defined trivfs functions.
* Trivfs Options::              Optional user-defined trivfs functions.
* Trivfs Ports::                Managing control and protid ports.


File: hurd-ja.info,  Node: Trivfs Startup,  Next: Trivfs Callbacks,  Up: Trivfs Library

6.2.1 Trivfs Startup
--------------------

In order to use the trivfs library, you will need to define the
appropriate callbacks (*note Trivfs Callbacks::).  As with all Hurd
servers, your trivfs-based translator should first parse any
command-line options, in case the user is just asking for help.  Trivfs
uses argp (*note Argp: (libc)Argp.)  for parsing command-line arguments.

   Your translator should redefine the following functions and
variables as necessary, and then call `argp_parse' with the relevant
arguments:

 -- Variable: extern struct argp * trivfs_runtime_argp
     If this is defined or set to an argp structure, it will be used by
     the default `trivfs_set_options' to handle runtime options parsing.
     Redefining this is the normal way to add option parsing to a trivfs
     program.

 -- Function: error_t trivfs_set_options (struct trivfs_control *FSYS,
          char *ARGZ, size_t ARGZ_LEN)
     Set runtime options for FSYS to ARGZ and ARGZ_LEN.  The default
     definition for this routine simply uses TRIVFS_RUNTIME_ARGP
     (supplying FSYS as the argp input field).

 -- Function: error_t trivfs_append_args (struct trivfs_control *FSYS,
          char **ARGZ, size_t *ARGZ_LEN)
     Append to the malloced string `*ARGZ' of length `*ARGZ_LEN' a
     NUL-separated list of the arguments to this translator.

   After your translator parses its command-line arguments, it should
fetch its bootstrap port by using `task_get_bootstrap_port'.  If this
port is `MACH_PORT_NULL', then your program wasn't started as a
translator.  Otherwise, you can use the bootstrap port to create a new
control structure (and advertise its port) with `trivfs_startup':

 -- Function: error_t trivfs_startup (mach_port_t BOOTSTRAP, int FLAGS,
          struct port_class *CONTROL_CLASS,
          struct port_bucket *CONTROL_BUCKET,
          struct port_class *PROTID_CLASS,
          struct port_bucket *PROTID_BUCKET,
          struct trivfs_control **CONTROL)
 -- Function: error_t trivfs_create_control (mach_port_t BOOTSTRAP,
          struct port_class *CONTROL_CLASS,
          struct port_bucket *CONTROL_BUCKET,
          struct port_class *PROTID_CLASS,
          struct port_bucket *PROTID_BUCKET,
          struct trivfs_control **CONTROL)
     `trivfs_startup' creates a new trivfs control port, advertises it
     to the underlying node BOOTSTRAP with `fsys_startup', returning
     the results of this call, and places its control structure in
     `*CONTROL'.  `trivfs_create_control' does the same thing, except
     it doesn't advertise the control port to the underlying node.
     CONTROL_CLASS and CONTROL_BUCKET are passed to `libports' to
     create the control port, and PROTID_CLASS and PROTID_BUCKET are
     used when creating ports representing opens of this node; any of
     these may be zero, in which case an appropriate port class/bucket
     is created.  If CONTROL is non-null, the trivfs control port is
     returned in it.  FLAGS (a bitmask of the appropriate `O_*'
     constants) specifies how to open the underlying node.

   If you did not supply zeros as the class and bucket arguments to
`trivfs_startup', you will probably need to use the trivfs port
management functions (*note Trivfs Ports::).

   Once you have successfully called `trivfs_startup', and have a
pointer to the control structure stored in, say, the FSYS variable, you
are ready to call one of the `ports_manage_port_operations_*' functions
using `FSYS->pi.bucket' and `trivfs_demuxer'.  This will handle any
incoming filesystem requests, invoking your callbacks when necessary.

 -- Function: int trivfs_demuxer (mach_msg_header_t *INP,
          mach_msg_header_t *OUTP)
     Demultiplex incoming `libports' messages on trivfs ports.

   The following functions are not usually necessary, but they allow
you to use the trivfs library even when it is not possible to turn
message-handling over to `trivfs_demuxer' and `libports':

 -- Function: struct trivfs_control * trivfs_begin_using_control
          (mach_port_t PORT)
 -- Function: struct trivfs_protid * trivfs_begin_using_protid
          (mach_port_t PORT)
     These functions can be used as `intran' functions for a MiG port
     type to have the stubs called with either the control or protid
     pointer.

 -- Function: void trivfs_end_using_control (struct trivfs_control *PORT)
 -- Function: void trivfs_end_using_protid (struct trivfs_protid *PORT)
     These can be used as `destructor' functions for a MiG port type,
     to have the stubs called with the control or protid pointer.

 -- Function: error_t trivfs_open (struct trivfs_control *FSYS,
          struct iouser *USER, unsigned FLAGS, mach_port_t REALNODE,
          struct trivfs_protid **CRED)
     Return a new protid (that is, a port representing an open of this
     node) pointing to a new peropen in CRED, with REALNODE as the
     underlying node reference, with the given identity, and open flags
     in FLAGS.  CNTL is the trivfs control object.

 -- Function: error_t trivfs_protid_dup (struct trivfs_protid *CRED,
          struct trivfs_protid **DUP)
     Return a duplicate of CRED in DUP, sharing the same peropen and
     hook.  A non-null protid HOOK indicates that
     TRIVFS_PEROPEN_CREATE_HOOK created this protid (*note Trivfs
     Options::).

 -- Function: error_t trivfs_set_atime (struct trivfs_control *CNTL)
 -- Function: error_t trivfs_set_mtime (struct trivfs_control *CNTL)
     Call these to set atime or mtime for the node to the current time.


File: hurd-ja.info,  Node: Trivfs Callbacks,  Next: Trivfs Options,  Prev: Trivfs Startup,  Up: Trivfs Library

6.2.2 Trivfs Callbacks
----------------------

Like several other Hurd libraries, `libtrivfs' requires that you define
a number of application-specific callback functions and configuration
variables.  You _must_ define the following variables and functions:

 -- Variable: extern int trivfs_fstype
 -- Variable: extern int trivfs_fsid
     These variables are returned in the ST_FSTYPE and ST_FSID fields
     of `struct stat'.  TRIVFS_FSTYPE should be chosen from the
     `FSTYPE_*' constants found in `<hurd/hurd_types.h>'.

 -- Variable: extern int trivfs_allow_open
     Set this to some bitwise OR combination of `O_READ', `O_WRITE',
     and `O_EXEC'; trivfs will only allow opens of the specified modes.

 -- Variable: extern int trivfs_support_read
 -- Variable: extern int trivfs_support_write
 -- Variable: extern int trivfs_support_exec
     Set these to nonzero if trivfs should allow read, write, or
     execute of the file.  These variables are necessary because
     TRIVFS_ALLOW_OPEN is used only to validate opens, not actual
     operations.

 -- Function: void trivfs_modify_stat (struct trivfs_protid *CRED,
          struct stat *STBUF)
     This should modify a `struct stat' (as returned from the underlying
     node) for presentation to callers of `io_stat'.  It is permissable
     for this function to do nothing, but it must still be defined.

 -- Function: error_t trivfs_goaway (struct trivfs_control *CNTL,
          int FLAGS)
     This function is called when someone wants the filesystem CNTL to
     go away.  FLAGS are from the set `FSYS_GOAWAY_*' found in
     `<hurd/hurd_types.h>'.


File: hurd-ja.info,  Node: Trivfs Options,  Next: Trivfs Ports,  Prev: Trivfs Callbacks,  Up: Trivfs Library

6.2.3 Trivfs Options
--------------------

The functions and variables described in this subsection already have
default definitions in `libtrivfs', so you are not forced to define
them; rather, they may be redefined on a case-by-case basis.

 -- Variable: extern struct port_class * trivfs_protid_portclasses[]
 -- Variable: extern int trivfs_protid_nportclasses
 -- Variable: extern struct port_class * trivfs_cntl_portclasses[]
 -- Variable: extern int trivfs_cntl_nportclasses
     If you define these, they should be vectors (and the associated
     sizes) of port classes that will be translated into control and
     protid pointers for passing to RPCs, in addition to those passed
     to or created by `trivfs_create_control' (or `trivfs_startup') will
     automatically be recognized.

 -- Variable: error_t (* trivfs_check_open_hook )
          (struct trivfs_control *CNTL, struct iouser *USER, int FLAGS)
     If this variable is set, it is called every time an open happens.
     USER and FLAGS are from the open; CNTL identifies the node being
     opened.  This call need not check permissions on the underlying
     node.  This call can block as necessary, unless `O_NONBLOCK' is
     set in FLAGS.  Any desired error can be returned, which will be
     reflected to the user and prevent the open from succeeding.

 -- Variable: error_t (* trivfs_protid_create_hook )
          (struct trivfs_protid *PROT)
 -- Variable: error_t (* trivfs_peropen_create_hook )
          (struct trivfs_peropen *PEROP)
     If these variables are set, they is called every time a new protid
     or peropen structure is created and initialized.

 -- Variable: void (* trivfs_protid_destroy_hook )
          (struct trivfs_protid *PROT)
 -- Variable: void (* trivfs_peropen_destroy_hook )
          (struct trivfs_peropen *PEROP)
     If these variables is set, they are called every time a protid or
     peropen structure is about to be destroyed.

 -- Variable: error_t (* trivfs_getroot_hook )
          (struct trivfs_control *CNTL, mach_port_t REPLY_PORT,
          mach_msg_type_name_t REPLY_PORT_TYPE, mach_port_t DOTDOT,
          uid_t *UIDS, u_int NUIDS, uid_t *GIDS, u_int NGIDS,
          int FLAGS, retry_type *DO_RETRY, char *RETRY_NAME,
          mach_port_t *NODE, mach_msg_type_name_t *NODE_TYPE)
     If this variable is set, it is called by `trivfs_S_fsys_getroot'
     before any other processing takes place; if the return value is
     `EAGAIN', normal trivfs getroot processing continues, otherwise the
     RPC returns with that return value.


File: hurd-ja.info,  Node: Trivfs Ports,  Prev: Trivfs Options,  Up: Trivfs Library

6.2.4 Trivfs Ports
------------------

If you choose to allocate your own trivfs port classes and buckets, the
following functions may come in handy:

 -- Function: error_t trivfs_add_port_bucket (struct port_bucket **BUCKET)
     Add the port bucket `*BUCKET' to the list of dynamically allocated
     port buckets; if `*BUCKET' is zero, an attempt is made to allocate
     a new port bucket, which is then stored in `*BUCKET'.

 -- Function: void trivfs_remove_port_bucket (struct port_bucket *BUCKET)
     Remove the previously added dynamic port bucket BUCKET, freeing it
     if it was allocated by `trivfs_add_port_bucket'.

 -- Function: error_t trivfs_add_control_port_class
          (struct port_class **CLASS)
 -- Function: error_t trivfs_add_protid_port_class
          (struct port_class **CLASS)
     Add the port class `*CLASS' to the list of control or protid port
     classes recognized by trivfs; if `*CLASS' is zero, an attempt is
     made to allocate a new port class, which is stored in `*CLASS'.

 -- Function: void trivfs_remove_control_port_class
          (struct port_class *CLASS)
 -- Function: void trivfs_remove_protid_port_class
          (struct port_class *CLASS)
     Remove the previously added dynamic control or protid port class
     CLASS, freeing it if it was allocated by
     `trivfs_add_control_port_class' or `trivfs_add_protid_port_class'.

   Even if you do not use the above allocation functions, you may still
be able to use the default trivfs cleanroutines:

 -- Function: void trivfs_clean_cntl (void *PORT)
 -- Function: void trivfs_clean_protid (void *PORT)
     These functions should be installed as `libports' cleanroutines for
     control port classes and protid port classes, respectively.


File: hurd-ja.info,  Node: Fshelp Library,  Next: File Interface,  Prev: Trivfs Library,  Up: Files

6.3 Fshelp Library
==================

The fshelp library implements various things that are generic to most
implementors of the file protocol.  It presumes that you are using the
iohelp library as well.  `libfshelp' is divided into separate
facilities which may be used independently.  These functions are
declared in `<hurd/fshelp.h>'.

* Menu:

* Passive Translator Linkage::  Invoking passive translators.
* Active Translator Linkage::   Managing active translators.
* Fshelp Locking::              Implementing file locking.
* Fshelp Permissions::          Standard file access permission policies.
* Fshelp Misc::                 Useful standalone routines.


File: hurd-ja.info,  Node: Passive Translator Linkage,  Next: Active Translator Linkage,  Up: Fshelp Library

6.3.1 Passive Translator Linkage
--------------------------------

These routines are self-contained and start passive translators,
returning the control port.  They do not require multithreading or the
ports library.

 -- Typedef: typedef error_t (* fshelp_open_fn_t ) (int FLAGS,
          file_t *NODE, mach_msg_type_name_t *NODE_TYPE)
     A callback used by the translator starting functions, which should
     be a function that given some open flags, opens the appropiate
     file, and returns the node port.

 -- Function: error_t fshelp_start_translator_long
          (fshelp_open_fn_t UNDERLYING_OPEN_FN, char *NAME, char *ARGZ,
          int ARGZ_LEN, mach_port_t *FDS,
          mach_msg_type_name_t FDS_TYPE, int FDS_LEN,
          mach_port_t *PORTS, mach_msg_type_name_t PORTS_TYPE,
          int PORTS_LEN, int *INTS, int INTS_LEN, int TIMEOUT,
          fsys_t *CONTROL)
     Start a passive translator NAME with arguments ARGZ (length
     ARGZ_LEN).  Initialize the initports to PORTS (length PORTS_LEN),
     the initints to INTS (length INTS_LEN), and the file descriptor
     table to FDS (length FDS_LEN).  Return the control port in
     `*CONTROL'.  If the translator doesn't respond or die in TIMEOUT
     milliseconds (if TIMEOUT is greater than zero), return an
     appropriate error.  If the translator dies before responding,
     return `EDIED'.

 -- Function: error_t fshelp_start_translator
          (fshelp_open_fn_t UNDERLYING_OPEN_FN, char *NAME, char *ARGZ,
          int ARGZ_LEN, int TIMEOUT, fsys_t *CONTROL)
     Same as `fshelp_start_translator_long', except the initports and
     ints are copied from our own state, FD[2] is copied from our own
     stderr, and the other fds are cleared.


File: hurd-ja.info,  Node: Active Translator Linkage,  Next: Fshelp Locking,  Prev: Passive Translator Linkage,  Up: Fshelp Library

6.3.2 Active Translator Linkage
-------------------------------

These routines implement the linkage to active translators needed by
any filesystem which supports them.  They require the threads library
and use the passive translator routines above, but they don't require
the ports library at all.

   This interface is complex, because creating the ports and state
necessary for `start_translator_long' is expensive.  The caller to
`fshelp_fetch_root' should not need to create them on every call, since
usually there will be an existing active translator.

 -- Function: void fshelp_transbox_init (struct transbox *TRANSBOX,
          struct mutex *LOCK, void *COOKIE)
     Initialize a transbox, which contains state information for active
     translators.

 -- Typedef: typedef error_t (* fshelp_fetch_root_callback1_t )
          (void *COOKIE1, void *COOKIE2, uid_t *UID, gid_t *GID,
          char **ARGZ, size_t *ARGZ_LEN)
     This routine is called by `fshelp_fetch_root' to fetch more
     information.  Return the owner and group of the underlying
     translated file in `*UID' and `*GID'; point `*ARGZ' at the entire
     passive translator specification for the file (setting `*ARGZ_LEN'
     to the length).  If there is no passive translator, then return
     `ENOENT'.  COOKIE1 is the cookie passed in `fshelp_transbox_init'.
     COOKIE2 is the cookie passed in the call to `fshelp_fetch_root'.

 -- Typedef: typedef error_t (* fshelp_fetch_root_callback2_t )
          (void *COOKIE1, void *COOKIE2, int FLAGS,
          mach_port_t *UNDERLYING,
          mach_msg_type_name_t *UNDERLYING_TYPE)
     This routine is called by `fshelp_fetch_root' to fetch more
     information.  Return an unauthenticated node for the file itself in
     `*UNDERLYING' and `*UNDERLYING_TYPE' (opened with FLAGS).  COOKIE1
     is the cookie passed in `fshelp_transbox_init'.  COOKIE2 is the
     cookie passed in the call to `fshelp_fetch_root'.

 -- Function: error_t fshelp_fetch_root (struct transbox *TRANSBOX,
          void *COOKIE, file_t DOTDOT, struct iouser *USER, int FLAGS,
          fshelp_fetch_root_callback1_t CALLBACK1,
          fshelp_fetch_root_callback2_t CALLBACK2, retry_type *RETRY,
          char *RETRYNAME, mach_port_t *ROOT)
     Fetch the root from TRANSBOX.  DOTDOT is an unauthenticated port
     for the directory in which we are looking; USER specifies the ids
     of the user responsible for the call.  FLAGS are as for
     `dir_pathtrans' (but `O_CREAT' and `O_EXCL' are not meaningful and
     are ignored).  The transbox lock (as set by
     `fshelp_transbox_init') must be held before the call, and will be
     held upon return, but may be released during the operation of the
     call.

 -- Function: int fshelp_translated (struct transbox *BOX)
     Return true if and only if there is an active translator on this
     box.

 -- Function: error_t fshelp_set_active (struct transbox *BOX,
          fsys_t NEWACTIVE, int EXCL)
     Atomically replace the existing active translator port for this
     box with NEWACTIVE.  If EXCL is non-zero then don't modify an
     existing active transbox; return `EBUSY' instead.

 -- Function: error_t fshelp_fetch_control (struct transbox *BOX,
          mach_port_t *CONTROL)
     Fetch the control port to make a request on it.  It's a bad idea
     to use `fsys_getroot' with the result; use `fshelp_fetch_root'
     instead.

 -- Function: void fshelp_drop_transbox (struct transbox *BOX)
     Clean transbox state so that deallocation or reuse is possible.


File: hurd-ja.info,  Node: Fshelp Locking,  Next: Fshelp Permissions,  Prev: Active Translator Linkage,  Up: Fshelp Library

6.3.3 Fshelp Locking
--------------------

The `flock' call is in flux, as the current Hurd interface (as of
version 0.2) is not suitable for implementing the POSIX record-locking
semantics.


File: hurd-ja.info,  Node: Fshelp Permissions,  Next: Fshelp Misc,  Prev: Fshelp Locking,  Up: Fshelp Library

6.3.4 Fshelp Permissions
------------------------

These functions are designed to aid with user permission checking.  It
is a good idea to use these routines rather than to roll your own, so
that Hurd users see consistent handling of file and directory permission
bits.

 -- Function: error_t fshelp_isowner (struct stat *ST,
          struct iouser *USER)
     Check to see whether USER should be considered the owner of the
     file identified by ST.  If so, return zero; otherwise return an
     appropriate error code.

 -- Function: error_t fshelp_access (struct stat *ST, int OP,
          struct iouser *USER)
     Check to see whether the user USER can operate on the file
     identified by ST.  OP is one of `S_IREAD', `S_IWRITE', and
     `S_IEXEC'.  If the access is permitted, return zero; otherwise
     return an appropriate error code.

 -- Function: error_t fshelp_checkdirmod (struct stat *DIR,
          struct stat *ST, struct iouser *USER)
     Check to see whether USER is allowed to modify DIR with respect to
     existing file ST.  If there is no existing file, then ST should be
     set to zero.  If the access is permissable return zero; otherwise
     return an appropriate error code.


File: hurd-ja.info,  Node: Fshelp Misc,  Prev: Fshelp Permissions,  Up: Fshelp Library

6.3.5 Fshelp Misc
-----------------

The following functions are completely standalone:

 -- Function: error_t fshelp_delegate_translation (char *SERVER_NAME,
          mach_port_t REQUESTOR, char **ARGV)
     Try to hand off responsibility from a translator to the server
     located on the node SERVER_NAME.  REQUESTOR is the translator's
     bootstrap port, and ARGV is the command line.  If SERVER_NAME is
     null, then a name is concocted by appending `argv[0]' to
     `_servers'.

 -- Function: error_t fshelp_exec_reauth (int SUID, uid_t UID, int SGID,
          gid_t GID, auth_t AUTH, error_t (*GET_FILE_IDS)
          (struct idvec *UIDS, struct idvec *GIDS), mach_port_t *PORTS,
          mach_msg_type_number_t NUM_PORTS, mach_port_t *FDS,
          mach_msg_type_number_t NUM_FDS, int *SECURE)
     If SUID or SGID is true, adds UID and/or GID respectively to the
     authentication in `PORTS[INIT_PORT_AUTH]', and replaces it with
     the result.  All the other ports in PORTS and FDS are then
     reauthenticated, using any privileges available through AUTH.  If
     the auth port in `PORTS[INIT_PORT_AUTH]' is bogus, and
     GET_FILE_IDS is non-null, it is called to get a list of uids and
     gids from the file to use as a replacement.  If SECURE is non-null
     and any added ids are new, then the variable it points to is set
     to nonzero, otherwise zero.  If either the uid or gid case fails,
     then the other may still apply.

 -- Function: error_t fshelp_get_identity (struct port_bucket *BUCKET,
          ino_t FILENO, mach_port_t *PT)
     Return an identity port in `*PT' for the node numbered FILENO,
     suitable for returning from `io_identity'; exactly one send right
     must be created from the returned value.  FILENO should be the
     same value returned as the FILENO out-parameter in `io_identity',
     and in the enclosing directory (except for mount points), and in
     the `st_ino' stat field.  BUCKET should be a `libports' port
     bucket; fshelp requires the caller to make sure port operations
     (for no-senders notifications) are used.

 -- Function: error_t fshelp_return_malloced_buffer (char *BUF,
          size_t LEN, char **RBUF, mach_msg_type_number_t *RLEN)
     Put data from the malloced buffer BUF, LEN bytes long, into RBUF
     (which is RLEN bytes long), suitable for returning from an RPC.
     If LEN is greater than zero, BUF is freed, regardless of whether
     an error is returned or not.

 -- Function: error_t fshelp_set_options (struct argp *ARGP, int FLAGS,
          char *ARGZ, size_t ARGZ_LEN, void *INPUT)
     Invoke `argp_parse' in the standard way, with data from ARGZ and
     ARGZ_LEN.

 -- Function: void fshelp_touch (struct stat *ST, unsigned WHAT,
          volatile struct mapped_time_value *MAPTIME)
     Change the stat times of NODE as indicated by WHAT to the current
     time.  WHAT is a bitmask of one or more of the `TOUCH_ATIME',
     `TOUCH_MTIME', and `TOUCH_CTIME' constants.


File: hurd-ja.info,  Node: File Interface,  Next: Filesystem Interface,  Prev: Fshelp Library,  Up: Files

6.4 File Interface
==================

This section documents the interface for operating on files.

* Menu:

* File Overview::               Basic concepts for the file interface.
* Changing Status::             Changing the owner (etc.) of a file.
* Program Execution::           Executing files.
* File Locking::                Implementing the `flock' call.
* File Frobbing::               Other active calls on files.
* Opening Files::               Looking up files in directories.
* Modifying Directories::       Creating and deleting nodes.
* Notifications::               File and directory change callbacks.
* File Translators::            How to set and get translators.


File: hurd-ja.info,  Node: File Overview,  Next: Changing Status,  Up: File Interface

6.4.1 File Overview
-------------------

The file interface is a superset of the I/O interface (*note I/O
Interface::).  Servers which provide the file interface are required to
support the I/O interface as well.  All objects reachable in the
filesystem are expected to provide the file interface, even if they do
not contain data.  (The `trivfs' library makes it easy to do so for
ordinary sorts of cases.  *Note Trivfs Library::.)

   The interface definitions for the file interface are found in
`<hurd/fs.defs>'.

   Files have various pieces of status information which are returned by
`io_stat' (*note Information Queries::).  Most of this status
information can be directly changed by various calls in the file
interface; some of it should vary implicitly as the contents of the file
change.

   Many of these calls have general rules associated with them
describing how security and privilege should operate.  The `diskfs'
library (*note Diskfs Library::) implements these rules for stored
filesystems.  These rules have also been implemented in the fshelp
library (*note Fshelp Library::).  Trivfs-based servers generally have
no need to implement these rules at all.

   In special cases, there may be a reason to implement a different
security check from that specified here, or to implement a call to do
something slightly different.  But such cases must be carefully
considered; make sure that you will not confuse innocent user programs
through excessive cleverness.

   If some operation cannot be implemented (for example, `chauthor'
over FTP), then the call should return `EOPNOTSUPP'.  If it is merely
difficult to implement a call, it is much better to figure out a way to
implement it as a series of operations rather than returning errors to
the user.


File: hurd-ja.info,  Node: Changing Status,  Next: Program Execution,  Prev: File Overview,  Up: File Interface

6.4.2 Changing Status
---------------------

There are several RPCs available for users to change much of the status
information associated with a file.  (The information is returned by the
`io_stat' RPC; see *Note Information Queries::.)

   All these operations are restricted to root and the owner of the
file.  When attempted by another user, they should return `EPERM'.

   The `file_chown' RPC changes the owner and group of the file.  Only
root should be able to change the owner, and changing the group to a
group the caller is not in should also be prohibited.  Violating either
of these conditions should return `EPERM'.

   The `file_chauthor' RPC changes the author of the file.  It should
be legitimate to change the author to any value without restriction.

   The `file_chmod' RPC changes the file permission mode bits.

   The `file_chflags' RPC changes the flags of the file.  It should be
legitimate to change the flags to any value without restriction.  No
standard meanings have been assigned to the flags yet, but we intend to
do so.  Do not assume that the flags format we choose will map
identically to that of some existing filesystem format.

   The `file_utimes' RPC changes the ATIME and MTIME of the file.
Making this call must cause the CTIME to be updated as well, even if no
actual change to either the MTIME or the ATIME occurs.

   The `file_set_size' RPC is special; not only does it change the
status word specifing the size of the file, but it also changes the
actual contents of the file.  If the file size is being reduced it
should release secondary storage associated with the previous contents
of the file.  If the file is being extended, the new region added to the
file must be zero-filled.  Unlike the other RPCs in this section,
`file_set_size' should be permitted to any user who is allowed to write
the file.


File: hurd-ja.info,  Node: Program Execution,  Next: File Locking,  Prev: Changing Status,  Up: File Interface

6.4.3 Program Execution
-----------------------

Execution of programs on the Hurd is done through fileservers with the
`file_exec' RPC.  The fileserver is expected to verify that the user is
allowed to execute the file, make whatever modifications to the ports
are necessary for setuid execution, and then invoke the standard
execserver found on `/servers/exec'.

   This section specifically addresses what fileservers are expected to
do, with minimal attention to the other parts of the process.  *Note
Running Programs::, for more general information.

   The file must be opened for execution; if it is not, `EBADF' should
be returned In addition, at least one of the execute bits must be on.  A
failure of this check should result in `EACCES'--not `ENOEXEC'.  It is
not proper for the fileserver ever to respond to the `file_exec' RPC
with `ENOEXEC'.

   If either the setuid or setgid bits are set, the server needs to
construct a new authentication handle with the additional new ID's.
Then all the ports passed to `file_exec' need to be reauthenticated
with the new handle.  If the fileserver is unable to make the new
authentication handle (for example, because it is not running as root)
it is not acceptable to return an error; in such a case the server
should simply silently fail to implement the setuid/setgid semantics.

   If the setuid/setgid transformation adds a new uid or gid to the
user's authentication handle that was not previously present (as
opposed to merely reordering them) then the `EXEC_SECURE' and
`EXEC_NEWTASK' flags should both be added in the call to `exec_exec'.

   The server then needs to open a new port onto the executed file which
will not share any file pointers with the port the user passed in,
opened with `O_READ'.  Finally, all the information (mutated
appropriately for setuid/setgid) should be sent to the execserver with
`exec_exec'.  Whatever error code `exec_exec' returns should returned
to the caller of `file_exec'.


File: hurd-ja.info,  Node: File Locking,  Next: File Frobbing,  Prev: Program Execution,  Up: File Interface

6.4.4 File Locking
------------------

The `flock' call is in flux, as the current Hurd interface (as of
version 0.2) is not suitable for implementing the POSIX record-locking
semantics.

   You should ignore the `file_lock' and `file_lock_stat' calls until
the new record-locking interface is implemented.


File: hurd-ja.info,  Node: File Frobbing,  Next: Opening Files,  Prev: File Locking,  Up: File Interface

6.4.5 File Frobbing
-------------------

FIXME: Other active calls on files

   `file_sync'

   `file_getfh'

   `file_getlinknode'

   `file_check_access'

   These manipulate meta-information:

   `file_reparent'

   `file_statfs'

   `file_syncfs'

   `file_getcontrol'

   `file_get_storage_info'

   `file_get_fs_options'


File: hurd-ja.info,  Node: Opening Files,  Next: Modifying Directories,  Prev: File Frobbing,  Up: File Interface

6.4.6 Opening Files
-------------------

FIXME: Looking up files in directories

   `dir_lookup'

   `dir_readdir'


File: hurd-ja.info,  Node: Modifying Directories,  Next: Notifications,  Prev: Opening Files,  Up: File Interface

6.4.7 Modifying Directories
---------------------------

FIXME: Creating and deleting nodes

   `dir_mkfile'

   `dir_mkdir'

   `dir_rmdir'

   `dir_unlink'

   `dir_link'

   `dir_rename'


File: hurd-ja.info,  Node: Notifications,  Next: File Translators,  Prev: Modifying Directories,  Up: File Interface

6.4.8 Notifications
-------------------

FIXME: File and directory change callbacks

   File change notifications are not yet implemented, but directory
notifications are.

   `file_notice_changes'

   `dir_notice_changes'


File: hurd-ja.info,  Node: File Translators,  Prev: Notifications,  Up: File Interface

6.4.9 File Translators
----------------------

FIXME: How to set and get translators

   `file_set_translator'

   `file_get_translator'

   `file_get_translator_cntl'


File: hurd-ja.info,  Node: Filesystem Interface,  Prev: File Interface,  Up: Files

6.5 Filesystem Interface
========================

The filesystem interface (described in `<hurd/fsys.defs>') is supported
by translator control ports.

   FIXME: finish


File: hurd-ja.info,  Node: Special Files,  Next: Stores,  Prev: Files,  Up: Top

7 Special Files
***************

In Unix, any file that does not act as a general-purpose unit of storage
is called a "special file".  These are FIFOs, Unix-domain sockets, and
device nodes.  In the Hurd, there is no need for the "special file"
distinction, since they are implemented by translators, just as regular
files are.

   Nevertheless, the Hurd maintains this distinction, in order to
provide backward-compatibility for Unix programs (which do not know
about translators).  Studying the implementation of Hurd special files
is a good way to introduce the idea of translators to people who are
familiar with Unix.

   This chapter does not discuss `/dev/zero' or any of the
microkernel-based devices, since these are translated by the generalized
storeio server (FIXME xref).

   FIXME: finish

7.1 fifo
========

7.2 ifsock
==========

7.3 magic
=========

7.4 null
========

FIXME: a chapter on libtreefs and libdirmgt will probably go here


File: hurd-ja.info,  Node: Stores,  Next: Stored Filesystems,  Prev: Special Files,  Up: Top

8 Stores
********

A "store" is a fixed-size block of storage, which can be read and
perhaps written to.  A store is more general than a file: it refers to
any type of storage such as devices, files, memory, tasks, etc.  Stores
can also be representations of other stores, which may be combined and
filtered in various ways.

* Menu:

* Store Library::               An abstract interface to storage systems.

8.1 storeinfo, storecat, storeread
==================================

8.2 storeio
===========

FIXME: finish


File: hurd-ja.info,  Node: Store Library,  Up: Stores

8.3 Store Library
=================

The store library (which is declared in `<hurd/store.h>') implements
many different backends which support the store abstraction.  Hurd
programs use `libstore' so that new storage types can be implemented
with minimum impact.

* Menu:

* Store Arguments::             Parsing store command-line arguments.
* Store Management::            Creating and manipulating stores.
* Store I/O::                   Reading and writing data to stores.
* Store Classes::               Ready-to-use storage backends.
* Store RPC Encoding::          Transferring store descriptors via RPC.


File: hurd-ja.info,  Node: Store Arguments,  Next: Store Management,  Up: Store Library

8.3.1 Store Arguments
---------------------

FIXME: describe startup sequence

 -- Structure: struct store_parsed
     The result of parsing a store, which should be enough information
     to open it, or return the arguments.

 -- Structure: struct store_argp_params { struct store_parsed *RESULT;
          const char *DEFAULT_TYPE;
          const struct store_class *const *CLASSES; }
     This is the structure used to pass args back and forth from
     STORE_ARGP.  RESULT is the resulting parsed result.  If
     `--store-type' isn't specified, then DEFAULT_TYPE should be used
     as the store type; zero is equivalent to `"query"'.  CLASSES is
     set of classes used to validate store types and argument syntax.

 -- Variable: extern struct argp store_argp
     This is an argument parser that may be used for parsing a simple
     command line specification for stores.  The accompanying input
     parameter must be a pointer to a `struct store_argp_params'.

 -- Function: void store_parsed_free (struct store_parsed *PARSED)
     Free all resources used by PARSED.

 -- Function: error_t store_parsed_open
          (const struct store_parsed *PARSED, int FLAGS,
          struct store **STORE)
     Open the store specified by PARSED, and return it in STORE.

 -- Function: error_t store_parsed_append_args
          (const struct store_parsed *PARSED, char **ARGZ,
          size_t *ARGZ_LEN)
     Add the arguments used to create PARSED to ARGZ and ARGZ_LEN.

 -- Function: error_t store_parsed_name
          (const struct store_parsed *PARSED, char **NAME)
     Make an option string describing PARSED, and return it in malloced
     storage in NAME.


File: hurd-ja.info,  Node: Store Management,  Next: Store I/O,  Prev: Store Arguments,  Up: Store Library

8.3.2 Store Management
----------------------

The following functions provide basic management of stores:

 -- Function: error_t store_create (file_t SOURCE, int FLAGS,
          const struct store_class *const *CLASSES,
          struct store **STORE)
     Return a new store in STORE, which refers to the storage
     underlying SOURCE.  CLASSES is used to select classes specified by
     the provider; if zero, STORE_STD_CLASSES is used.  FLAGS is set
     with `store_set_flags', with the exception of `STORE_INACTIVE',
     which merely indicates that no attempt should be made to activate
     an inactive store; if `STORE_INACTIVE' is not specified, and the
     store returned for SOURCE is inactive, an attempt is made to
     activate it (failure of which causes an error to be returned).  A
     reference to SOURCE is created (but may be destroyed with
     `store_close_source').

     It is usually better to use a specific store open or create
     function such as `store_open' (*note Store Classes::), since they
     are tailored to the needs of a specific store.  Generally, you
     should only use `store_create' if you are defining your own store
     class, or you need options that are not provided by a more
     specific store creation function.

 -- Function: void store_close_source (struct store *STORE)
     If STORE was created using `store_create', remove the reference to
     the source from which it was created.

 -- Function: void store_free (struct store *STORE)
     Clean up and deallocate STORE's underlying stores.

 -- Structure: struct store_run { off_t START, LENGTH; }
     A `struct store_run' represents a contiguous region in a store's
     address range.  These are used to designate active portions of a
     store.  If START is -1, then the region is a "hole" (it is
     zero-filled and doesn't correspond to any real addresses).

 -- Function: error_t store_set_runs (struct store *STORE,
          const struct store_run *RUNS, size_t NUM_RUNS)
     Set STORE's current runs list to (a copy of) RUNS and NUM_RUNS.

 -- Function: error_t store_set_children (struct store *STORE,
          struct store *const *CHILDREN, size_t NUM_CHILDREN)
     Set STORE's current children to (a copy of) CHILDREN and
     NUM_CHILDREN (note that just the vector CHILDREN is copied, not
     the actual children).

 -- Function: error_t store_children_name (const struct store *STORE,
          char **NAME)
     Try to come up with a name for the children in STORE, combining
     the names of each child in a way that could be used to parse them
     with `store_open_children'.  This is done heuristically, and so
     may not succeed.  If a child doesn't have a name, `EINVAL' is
     returned.

 -- Function: error_t store_set_name (struct store *STORE,
          const char *NAME)
     Sets the name associated with STORE to a copy of NAME.

 -- Function: error_t store_set_flags (struct store *STORE, int FLAGS)
     Add FLAGS to STORE's currently set flags.

 -- Function: error_t store_clear_flags (struct store *STORE, int FLAGS)
     Remove FLAGS from STORE's currently set flags.

 -- Function: error_t store_set_child_flags (struct store *STORE,
          int FLAGS)
     Set FLAGS in all children of STORE, and if successful, add FLAGS
     to STORE's flags.

 -- Function: error_t store_clear_child_flags (struct store *STORE,
          int FLAGS)
     Clear FLAGS in all children of STORE, and if successful, remove
     FLAGS from STORE's flags.

 -- Function: int store_is_securely_returnable (struct store *STORE,
          int OPEN_FLAGS)
     Returns true if STORE can safely be returned to a user who has
     accessed it via a node using OPEN_FLAGS, without compromising
     security.

 -- Function: error_t store_clone (struct store *FROM, struct store **TO)
     Return a copy of FROM in TO.

 -- Function: error_t store_remap (struct store *SOURCE,
          const struct store_run *RUNS, size_t NUM_RUNS,
          struct store **STORE)
     Return a store in STORE that reflects the blocks in RUNS and
     RUNS_LEN from source; SOURCE is consumed, but not RUNS.  Unlike
     the `store_remap_create' function, this may simply modify SOURCE
     and return it.


File: hurd-ja.info,  Node: Store I/O,  Next: Store Classes,  Prev: Store Management,  Up: Store Library

8.3.3 Store I/O
---------------

The following functions allow you to read and modify the contents of a
store:

 -- Function: error_t store_map (const struct store *STORE,
          vm_prot_t PROT, mach_port_t *MEMOBJ)
     Return a memory object paging on STORE.

 -- Function: error_t store_read (struct store *STORE, off_t ADDR,
          size_t AMOUNT, void **BUF, size_t *LEN)
     Read AMOUNT bytes from STORE at ADDR into BUF and LEN (which
     follows the usual Mach buffer-return semantics) to STORE at ADDR.
     ADDR is in BLOCKS (as defined by `STORE->block_size').  Note that
     LEN is in bytes.

 -- Function: error_t store_write (struct store *STORE, off_t ADDR,
          void *BUF, size_t LEN, size_t *AMOUNT)
     Write LEN bytes from BUF to STORE at ADDR.  Returns the amount
     written in AMOUNT (in bytes).  ADDR is in BLOCKS (as defined by
     `STORE->block_size').


File: hurd-ja.info,  Node: Store Classes,  Next: Store RPC Encoding,  Prev: Store I/O,  Up: Store Library

8.3.4 Store Classes
-------------------

The store library comes with a number of standard store class
implementations:

 -- Variable: extern const struct store_class *const store_std_classes[]
     This is a null-terminated vector of the standard store classes
     implemented by `libstore'.

   If you are building your own class vectors, the following function
may be useful:

 -- Variable: error_t store_concat_class_vectors
          (struct store_class **CV1, struct store_class **CV2,
          struct store_class ***CONCAT)
     Concatenate the store class vectors in CV1 and CV2, and return a
     new (malloced) vector in CONCAT.

8.3.4.1 `query' store
.....................

 -- Variable: extern const struct store_class store_query_class
     This store is a virtual store which queries a filesystem node, and
     delegates control to an appropriate store class.

 -- Function: error_t store_open (const char *NAME, int FLAGS,
          const struct store_class *const *CLASSES,
          struct store **STORE)
     Open the file NAME, and return a new store in STORE, which refers
     to the storage underlying it.  CLASSES is used to select classes
     specified by the provider; if it is zero, then STORE_STD_CLASSES
     is used.  FLAGS is set with `store_set_flags'.  A reference to the
     open file is created (but may be destroyed with
     `store_close_source').

8.3.4.2 `typed_open' store
..........................

 -- Variable: extern const struct store_class store_typed_open_class
     This store is special in that it doesn't correspond to any specific
     store functions, rather it provides a way to interpret character
     strings as specifications for other stores.

 -- Function: error_t store_typed_open (const char *NAME, int FLAGS,
          const struct store_class *const *CLASSES,
          struct store **STORE)
     Open the store indicated by NAME, which should consist of a store
     type name followed by a `:' and any type-specific name, returning
     the new store in STORE.  CLASSES is used to select classes
     specified by the type name; if it is zero, STORE_STD_CLASSES is
     used.

 -- Function: error_t store_open_children (const char *NAME, int FLAGS,
          const struct store_class *const *CLASSES,
          struct store ***STORES, size_t *NUM_STORES)
     Parse multiple store names in NAME, and open each individually,
     returning all in the vector STORES, and the number in NUM_STORES.
     The syntax of NAME is a single non-alphanumeric separator
     character, followed by each child store name separated by the same
     separator; each child name is `TYPE:NAME' notation as parsed by
     `store_typed_open'.  If every child uses the same `TYPE:' prefix,
     then it may be factored out and put before the child list instead
     (the two notations are differentiated by whether or not the first
     character of NAME is alphanumeric).

8.3.4.3 `device' store
......................

 -- Variable: extern const struct store_class store_device_class
     This store is a simple wrapper for a microkernel device driver.(1)

 -- Function: error_t store_device_open (const char *NAME, int FLAGS,
          struct store **STORE)
     Open the device named NAME, and return the corresponding store in
     STORE.

 -- Function: error_t store_device_create (device_t DEVICE, int FLAGS,
          struct store **STORE)
     Return a new store in STORE referring to the microkernel device
     DEVICE.  Consumes the DEVICE send right.

8.3.4.4 `file' store
....................

 -- Variable: extern const struct store_class store_file_class
     This store reads and writes the contents of a Hurd file.

 -- Function: error_t store_file_open (const char *NAME, int FLAGS,
          struct store **STORE)
     Open the file NAME, and return the corresponding store in STORE.

 -- Function: error_t store_file_create (file_t FILE, int FLAGS,
          struct store **STORE)
     Return a new store in STORE referring to the file FILE.  Unlike
     `store_create', this will always use file I/O, even it would be
     possible to be more direct.  This may work in more cases, for
     instance if the file has holes.  Consumes the FILE send right.

8.3.4.5 `task' store
....................

 -- Variable: extern const struct store_class store_task_class
     This store provides access to the contents of a microkernel task.

 -- Variable: error_t store_task_open (const char *NAME, int FLAGS,
          struct store **STORE)
     Open the task NAME (NAME should be the task's pid), and return the
     corresponding store in STORE.

 -- Variable: error_t store_task_create (task_t TASK, int FLAGS,
          struct store **STORE)
     Return a new store in STORE referring to the task TASK, consuming
     the TASK send right.

8.3.4.6 `zero' store
....................

 -- Variable: extern const struct store_class store_zero_class
     Reads to this store always return zero-filled buffers, no matter
     what has been written into it.  This store corresponds to the Unix
     `/dev/zero' device node.

 -- Function: error_t store_zero_create (off_t SIZE, int FLAGS,
          struct store **STORE)
     Return a new zero store SIZE bytes long in STORE.

8.3.4.7 `copy' store
....................

 -- Variable: extern const struct store_class store_copy_class
     This store provides a temporary copy of another store.  This is
     useful if you want to provide writable data, but do not wish to
     modify the underlying store.  All changes to a copy store are lost
     when it is closed.

 -- Function: error_t store_copy_open (const char *NAME, int FLAGS,
          const struct store_class *const *CLASSES,
          struct store **STORE)
     Open the copy store NAME (which consists of another store class
     name, a `:', and a name for the store class to open) and return the
     corresponding store in STORE.  CLASSES is used to select classes
     specified by the type name; if it is zero, STORE_STD_CLASSES is
     used.

 -- Function: error_t store_copy_create (struct store *FROM, int FLAGS,
          struct store **STORE)
     Return a new store in STORE which contains a snapshot of the
     contents of the store FROM; FROM is consumed.

 -- Function: error_t store_buffer_create (void *BUF, size_t BUF_LEN,
          int FLAGS, struct store **STORE)
     Return a new store in STORE which contains the memory buffer BUF,
     of length BUF_LEN.  BUF must be allocated with `vm_allocate', and
     will be consumed.

8.3.4.8 `gunzip' store
......................

 -- Variable: extern const struct store_class store_gunzip_class
     This store provides transparent GNU zip decompression of a
     substore.  Unfortunately, this store is currently read-only.

 -- Variable: error_t store_gunzip_open (const char *NAME, int FLAGS,
          const struct store_class *const *CLASSES,
          struct store **STORE)
     Open the gunzip store NAME (which consists of another store class
     name, a `:', and a name for that store class to open), and return
     the corresponding store in STORE.  CLASSES is used to select
     classes specified by the type name; if it is zero,
     STORE_STD_CLASSES is used.

 -- Variable: error_t store_gunzip_create (struct store *FROM, int FLAGS,
          struct store **STORE)
     Return a new store in STORE which contains a snapshot of the
     uncompressed contents of the store FROM; FROM is consumed.
     BLOCK_SIZE is the desired block size of the result.

8.3.4.9 `concat' store
......................

 -- Variable: extern const struct store_class store_concat_class
     This class provides a linear concatenation storage mode.  It
     creates a new virtual store which consists of several different
     substores appended to one another.

     This mode is designed to increase storage capacity, so that when
     one substore is filled, new data is transparently written to the
     next substore.  Concatenation requires robust hardware, since a
     failure in any single substore will wipe out a large section of
     the data.

 -- Function: error_t store_concat_open (const char *NAME, int FLAGS,
          const struct store_class *const *CLASSES,
          struct store **STORE)
     Return a new store that concatenates the stores created by opening
     all the individual stores described in NAME; for the syntax of
     NAME, see `store_open_children'.

 -- Function: error_t store_concat_create (struct store * const *STORES,
          size_t NUM_STORES, int FLAGS, struct store **STORE)
     Return a new store in STORE that concatenates all the stores in
     STORES (NUM_STORES of them).  The stores in STORES are consumed;
     that is, they will be freed when this store is freed.  The STORES
     _array_, however, is copied, and so should be freed by the caller.

8.3.4.10 `ileave' store
.......................

 -- Variable: extern const struct store_class store_ileave_class
     This class provides a RAID-0(2) storage mode (also called "disk
     striping").  It creates a new virtual store by interleaving the
     contents of several different substores.

     This RAID mode is designed to increase storage performance, since
     I/O will probably occur in parallel if the substores reside on
     different physical devices.  Interleaving works best with
     evenly-yoked substores... if the stores are different sizes, some
     space will be not be used at the end of the larger stores; if the
     stores are different speeds, then I/O will have to wait for the
     slowest store; if some stores are not as reliable as others,
     failures will wipe out every Nth storage block, where N is the
     number of substores.

 -- Function: error_t store_ileave_create (struct store * const *STRIPES,
          size_t num_stripes, off_t INTERLEAVE, int FLAGS,
          struct store **STORE)
     Return a new store in STORE that interleaves all the stores in
     STRIPES (NUM_STRIPES of them) every INTERLEAVE bytes; INTERLEAVE
     must be an integer multiple of each stripe's block size.  The
     stores in STRIPES are consumed; that is, they will be freed when
     this store is freed.  The STRIPES _array_, however, is copied, and
     so should be freed by the caller.

8.3.4.11 `mvol' store
.....................

 -- Variable: extern const struct store_class store_mvol_class
     This store provides access to multiple volumes using a
     single-volume device.  One use of this store would be to provide a
     store which consists of multiple floppy disks when there is only a
     single disk drive.  It works by remapping a single linear address
     range to multiple address ranges, and keeping track of the
     currently active range.  Whenever a request maps to a range that
     is not active, a callback is made in order to switch to the new
     range.

     This class is not included in STORE_STD_CLASSES, because it
     requires an application-specific callback.

 -- Function: error_t store_mvol_create (struct store *PHYS, error_t
          (*SWAP_VOLS) (struct store *STORE, size_t NEW_VOL,
          ssize_t OLD_VOL), int FLAGS, struct store **STORE)
     Return a new store in STORE that multiplexes multiple physical
     volumes from PHYS as one larger virtual volume.  SWAP_VOLS is a
     function that will be called whenever reads or writes refer to a
     block which is not on addressable on the currently active volume.
     PHYS is consumed.

8.3.4.12 `remap' store
......................

 -- Variable: extern const struct store_class store_remap_class
     This store translates I/O requests into different addresses on a
     different store.

 -- Function: error_t store_remap_create (struct store *SOURCE,
          const struct store_run *RUNS, size_t NUM_RUNS, int FLAGS,
          struct store **STORE)
     Return a new store in STORE that reflects the blocks in RUNS and
     RUNS_LEN from SOURCE; SOURCE is consumed, but RUNS is not.  Unlike
     the `store_remap' function, this function always operates by
     creating a new store of type `remap' which has SOURCE as a child,
     and so may be less efficient than store_remap for some types of
     stores.

   ---------- Footnotes ----------

   (1) It is important to note that device drivers are not provided by
the Hurd, but by the underlying microkernel.  Hurd `devices' are just
storeio-translated nodes which make the microkernel device drivers obey
Hurd semantics.  If you wish to implement a new device driver, you will
need to consult the appropriate microkernel documentation.

   (2) RAID is a "Redundant Array of Independent Disks", which refers
to the idea of using several disks in parallel in order to achieve
increased capacity, redundancy and/or performance.


File: hurd-ja.info,  Node: Store RPC Encoding,  Prev: Store Classes,  Up: Store Library

8.3.5 Store RPC Encoding
------------------------

The store library also provides some functions which help transfer
stores between tasks via RPC:

 -- Structure: struct store_enc
     This structure is used to hold the various bits that make up the
     representation of a store for transmission via RPC.  See
     `<hurd/hurd_types.h>' for an explanation of the encodings for the
     various storage types.

 -- Function: void store_enc_init (struct store_enc *ENC,
          mach_port_t *PORTS, mach_msg_type_number_t NUM_PORTS,
          int *INTS, mach_msg_type_number_t NUM_INTS, off_t *OFFSETS,
          mach_msg_type_number_t NUM_OFFSETS, char *DATA,
          mach_msg_type_number_t DATA_LEN)
     Initialize ENC.  The given vector and sizes will be used for the
     encoding if they are big enough (otherwise new ones will be
     automatically allocated).

 -- Function: void store_enc_dealloc (struct store_enc *ENC)
     Deallocate storage used by the fields in ENC (but nothing is done
     with ENC itself).

 -- Function: void store_enc_return (struct store_enc *ENC,
          mach_port_t **PORTS, mach_msg_type_number_t *NUM_PORTS,
          int **INTS, mach_msg_type_number_t *NUM_INTS,
          off_t **OFFSETS, mach_msg_type_number_t *NUM_OFFSETS,
          char **DATA, mach_msg_type_number_t *DATA_LEN)
     Copy out the parameters from ENC into the given variables suitably
     for returning from a `file_get_storage_info' RPC, and deallocate
     ENC.

 -- Function: error_t store_return (const struct store *STORE,
          mach_port_t **PORTS, mach_msg_type_number_t *NUM_PORTS,
          int **INTS, mach_msg_type_number_t *NUM_INTS,
          off_t **OFFSETS, mach_msg_type_number_t *NUM_OFFSETS,
          char **DATA, mach_msg_type_number_t *DATA_LEN)
     Encode STORE into the given return variables, suitably for
     returning from a `file_get_storage_info' RPC.

 -- Function: error_t store_encode (const struct store *STORE,
          struct store_enc *ENC)
     Encode STORE into ENC, which should have been prepared with
     `store_enc_init', or return an error.  The contents of ENC may
     then be returned as the value of `file_get_storage_info'; if for
     some reason this can't be done, `store_enc_dealloc' may be used to
     deallocate the mmemory used by the unsent vectors.

 -- Function: error_t store_decode (struct store_enc *ENC,
          const struct store_class *const *CLASSES,
          struct store **STORE)
     Decode ENC, either returning a new store in STORE, or an error.
     CLASSES the mapping from Hurd storage class ids to store classes;
     if it is zero, STORE_STD_CLASSES is used.  If nothing else is to
     be done with ENC, its contents may then be freed using
     `store_enc_dealloc'.

 -- Function: error_t store_allocate_child_encodings
          (const struct store *STORE, struct store_enc *ENC)
     Calls the `allocate_encoding' method in each child store of STORE,
     propagating any errors.  If any child does not have such a method,
     `EOPNOTSUPP' is returned.

 -- Function: error_t store_encode_children (const struct store *STORE,
          struct store_enc *ENC)
     Calls the encode method in each child store of STORE, propagating
     any errors.  If any child does not hae such a method, `EOPNOTSUPP'
     is returned.

 -- Function: error_t store_decode_children (struct store_enc *ENC,
          int NUM_CHILDREN, const struct store_class *const *CLASSES,
          struct store **CHILDREN)
     Decodes NUM_CHILDREN from ENC, storing the results into successive
     positions in CHILDREN.

 -- Function: error_t store_with_decoded_runs (struct store_enc *ENC,
          size_t NUM_RUNS, error_t (*FUN)
          (const struct store_run *RUNS, size_t NUM_RUNS))
     Call FUN with the vector RUNS of length NUM_RUNS extracted from
     ENC.

 -- Function: error_t store_std_leaf_allocate_encoding
          (const struct store *STORE, struct store_enc *ENC)
 -- Function: error_t store_std_leaf_encode (const struct store *STORE,
          struct store_enc *ENC)
     Standard encoding used for most data-providing (as opposed to
     filtering) store classes.

 -- Typedef: typedef error_t (* store_std_leaf_create_t
          )(mach_port_t PORT, int FLAGS, size_t BLOCK_SIZE,
          const struct store_run *RUNS, size_t NUM_RUNS,
          struct store **STORE)
     Creation function used by `store_std_leaf_decode'.

 -- Function: error_t store_std_leaf_decode (struct store_enc *ENC,
          store_std_leaf_create_t CREATE, struct store **STORE)
     Decodes the standard leaf encoding which is common to various
     builtin formats, and calls CREATE to actually create the store.


File: hurd-ja.info,  Node: Stored Filesystems,  Next: Twisted Filesystems,  Prev: Stores,  Up: Top

9 Stored（FIXME-J:ストアード？）ファイルシステム
************************************************

Stored（FIXME-J:ストアード？）ファイルシステムにより、
ユーザはハード・ディスク、 フロッピ・ディスク、
CD-ROMのようなランダム・アクセス可能なメディアをターゲットにして、
パーシステント(永続的)なデータをセーブしたりロードしたりすることができる。
Stored（FIXME-J:ストアード？）ファイルシステムは、
スタンドアロンなワークステーションをbootstrap（FIXME-J:ブートストラップ？）する場合にも必要になる。

* Menu:

* Repairing Filesystems::       軽いファイルシステム・クラッシュからの回復。
* Linux Extended 2 FS::         ポピュラーなLinuxファイルシステム・フォーマット。
* BSD Unix FS::                 BSD Unix 4.xのFast File System。
* ISO-9660 CD-ROM FS::          標準的なCD-ROMフォーマット。
* Diskfs Library::              新しいファイルシステム・サーバの実装。


File: hurd-ja.info,  Node: Repairing Filesystems,  Next: Linux Extended 2 FS,  Up: Stored Filesystems

9.1 ファイルシステムの修復
==========================

FIXME: finish


File: hurd-ja.info,  Node: Linux Extended 2 FS,  Next: BSD Unix FS,  Prev: Repairing Filesystems,  Up: Stored Filesystems

9.2 Linux Extended 2 FS
=======================

FIXME: finish


File: hurd-ja.info,  Node: BSD Unix FS,  Next: ISO-9660 CD-ROM FS,  Prev: Linux Extended 2 FS,  Up: Stored Filesystems

9.3 BSD Unix FS
===============

FIXME: finish


File: hurd-ja.info,  Node: ISO-9660 CD-ROM FS,  Next: Diskfs Library,  Prev: BSD Unix FS,  Up: Stored Filesystems

9.4 ISO-9660 CD-ROM FS
======================

FIXME: finish


File: hurd-ja.info,  Node: Diskfs Library,  Prev: ISO-9660 CD-ROM FS,  Up: Stored Filesystems

9.5 Diskfsライブラリ
====================

diskfsライブラリは`<hurd/diskfs.h>'に宣言されており、
stored（FIXME-J:ストアード？）ファイルシステムの実装に係わる多くの仕事を行っている。
`libdiskfs'は、
threads、ports、iohelp、fshelp、storeの各ライブラリを必要とする。
diskfsを使おうと試みる前に、
これらすべてのライブラリのことを理解するべきである。 また、
pagerライブラリについても熟知しているべきである(*note Pager Library::)。

   昔からのしがらみで、
stored（FIXME-J:ストアード？）ファイルシステムを実装するライブラリは`libstorefs'ではなく`libdiskfs'と呼ばれている。
しかしながら、 diskfsはI/Oを行うのにstoreライブラリを使っているので、
ブロック単位にアドレス付けされるものでさえあれば、
どのような記憶デバイス上に実装されているファイルシステムにとっても有用なものであるということを覚えておいていただきたい。

   diskfsのコールバック・インターフェイスは単純ではないので、
stored（FIXME-J:ストアード？）ファイルシステムを実装するのは手の込んだ作業となる可能性がある。
本当のところは、 ゼロから書き始めようとするよりも、
既存のファイルシステム・サーバのうち類似のもののソース・コードを調べて、
それを例として模倣するのが最も良いのである。

* Menu:

* Diskfs Startup::              stored（FIXME-J:ストアード？）ファイルシステムの初期化。
* Diskfs Arguments::            コマンドライン引数の解析。
* Diskfs Globals::              グローバルな振る舞いの変更。
* Diskfs Node Management::      割り当て、リファレンス・カウンティング、
                                  キャッシング、その他のディスク・ノード・ルーチン。
* Diskfs Callbacks::            必須のユーザ定義diskfs関数。
* Diskfs Options::              任意選択のユーザ定義diskfs関数。
* Diskfs Internals::            diskfsの細部の再実装。


File: hurd-ja.info,  Node: Diskfs Startup,  Next: Diskfs Arguments,  Up: Diskfs Library

9.5.1 Diskfsスタートアップ
--------------------------

このサブセクションでは、
ファイルシステム・サーバを実装する際の一般的なステップの概要を示す。
これはチュートリアルというよりはむしろ、
読者が記憶を新たにするのを助けたり、
解説を提供したりしようとするものである。

   ファイルシステム・サーバが最初にしなければならないのは、
コマンドライン引数を解析することである (*note Diskfs Arguments::)。
その後に、 それがブートストラップ・ファイルシステムであれば、
標準出力ストリームと標準エラー・ストリームをコンソールにリダイレクトして、
エラー・メッセージが失われることがないようにしなければならない。

 -- Function: void diskfs_console_stdio (void)
     エラー・メッセージがユーザに見えるようにコンソールへリダイレクトする。

   以下に、
サーバの初期化処理の残りの部分で呼出されるであろう関連する関数のリストを示す。
繰り返しになるが、
これらの関数がどのように使われるべきであるかという点に関してなにか疑問があるなら、
既に動いているファイルシステムの実装を参照するべきである。

 -- Function: error_t diskfs_init_diskfs (void)
     引数の解析後に、ライブラリを初期化するためにこの関数を呼出す。
     diskfsオプションの解析が終了したら、
     他の任意のdiskfs関数を呼出す前に、
     この関数を呼出さなければならない。

 -- Function: void diskfs_spawn_first_thread (void)
     (`diskfs_root_node'の設定を除く)
     フォーマット固有のすべての初期化処理の完了後にこの関数を呼出す。
     この時点で、 ページャを起動する準備ができているはずである。

 -- Function: mach_port_t diskfs_startup_diskfs (mach_port_t BOOTSTRAP,
          int FLAGS)
     ファイルシステムの初期化が完全に終了した後にこの関数を呼出す。
     これは、 新しいファイルシステムcontrol
     port（FIXME-J:コントロール・ポート、制御ポート？）のことを親ファイルシステムに通知するためである。
     もしBOOTSTRAPがセットされていれば、
     diskfsはそのポートに対して適宜`fsys_startup'を呼出し、
     その呼出しによって返されたREALNODEを返す。
     BOOTSTRAPがセットされていなければ、
     この関数は`diskfs_start_bootstrap'を呼出し、
     `MACH_PORT_NULL'を返す。 (O_*の集合の要素を値として取る)FLAGSは、
     REALNODEをどのようにオープンするかを指定する。

   以下の関数を直接呼出す必要はないはずである。 なぜなら、
`diskfs_startup_diskfs'が必要に応じてこの関数を呼出してくれるからである。

 -- Function: void diskfs_start_bootstrap (void)
     このファイルシステムがあたかもブートストラップ・ファイルシステムであるかのように、
     Hurdのbootstrap
     sequence（FIXME-J:ブートストラップ・シーケンス？）を開始する。
     この関数を呼出す前に、
     ファイルシステムの初期化処理はすべて完了していなければならない。


File: hurd-ja.info,  Node: Diskfs Arguments,  Next: Diskfs Globals,  Prev: Diskfs Startup,  Up: Diskfs Library

9.5.2 Diskfs引数
----------------

以下の関数は、 argp (*note Argp: (libc)Argp.)  を使って、
標準的なdiskfsコマンドライン引数と実行時引数の解析処理を実装している。

 -- Function: error_t diskfs_set_options (char *ARGZ, size_t ARGZ_LEN)
     ARGZとARGZ_LENにより指定される実行時オプションを解析して実行する。
     認識できないオプションがあれば`EINVAL'が返される。
     このルーチンのデフォルトの定義では、
     `diskfs_runtime_argp'を使用して実行時オプションが解析される。

 -- Function: error_t diskfs_append_args (char **ARGZ, unsigned *ARGZ_LEN)
     mallocされた領域にある、 長さ`*ARGZ_LEN'の文字列`*ARGZ'の末尾に、
     このトランスレータに渡された引数をNULで区切られたリストにしたものを追加する。
     このルーチンのデフォルトの定義では、
     単に`diskfs_append_std_options'が呼出される。

 -- Function: error_t diskfs_append_std_options (char **ARGZ,
          unsigned *ARGZ_LEN)
     標準的なdiskfsオプション状態を説明する情報とともに、
     NULで区切られたオプションをARGZの_末尾に追加_し、
     ARGZ_LENの値を適宜増加させる。 `diskfs_get_options'とは異なり、
     ARGZとARGZ_LENには既にまともな値が入っていなければならない点に注意すること。

 -- Variable: struct argp * diskfs_runtime_argp
     これが定義されているか、 もしくは、
     argp構造体を指すようセットされていると、
     デフォルトの`diskfs_set_options'が実行時オプションの解析処理にこれを使うことになる。
     デフォルトの定義では、
     `diskfs_std_runtime_argp'へのポインタとして初期化されている。

 -- Variable: const struct argp diskfs_std_runtime_argp
     標準的なdiskfs実行時オプション用のargp。
     `diskfs_runtime_argp'のデフォルトの定義はこれを指す。 ただし、
     ユーザがこれを独自のargpにつなぐよう再定義することは可能である。

 -- Variable: const struct argp diskfs_startup_argp
     標準的なdiskfsコマンドライン引数用のargp構造体。 ユーザは、
     コマンドラインを解析するためにこれを使用して`argp_parse'を呼出すこともできるし、
     これを独自のargp構造体の末尾につなぐこともできる。 また、
     これを完全に無視することもできる。

 -- Variable: const struct argp diskfs_store_startup_argp
     標準的なdiskfsコマンドライン引数用、 および、 store
     specification（FIXME-J:指定、仕様？）用のargp構造体。
     結果として作成される`struct
     store_parsed'構造体を返すべき場所のアドレスが、
     `argp_parse'への入力引数として渡されなければならない。 FIXME xref
     the declaration for STORE_ARGP.


File: hurd-ja.info,  Node: Diskfs Globals,  Next: Diskfs Node Management,  Prev: Diskfs Arguments,  Up: Diskfs Library

9.5.3 Diskfsグローバル関数、グローバル変数
------------------------------------------

以下の関数や変数は、 このライブラリの全般的な振舞いを制御する。
あなたの書くコールバック関数はこれらを参照する必要があるかもしれないが、
これらを変更したり再定義したりする必要はないはずである。

 -- Variable: mach_port_t diskfs_default_pager
 -- Variable: mach_port_t diskfs_exec_ctl
 -- Variable: mach_port_t diskfs_exec
 -- Variable: auth_t diskfs_auth_server_port
     これらはそれぞれ、 デフォルト・ページャ、 execserverのcontrol
     port（FIXME-J:コントロール・ポート、制御ポート？）、
     execserverそれ自身、 authserverへのsend
     rights（FIXME-J:センド・ライト？）である。

 -- Variable: mach_port_t diskfs_fsys_identity
     ファイルシステムの`io_identity' identity
     port（FIXME-J:アイデンティティ・ポート？）。

 -- Variable: char ** diskfs_argv
     デフォルトの引数パーサによりセットされた、
     diskfsの起動コマンドライン。
     あなたが引数パーサを使わないのであれば、
     これを自分でセットすること。 これはprocserverに与えるために、
     ブートストラップ・ファイルシステムによってのみ使用される。

 -- Variable: char * diskfs_boot_flags
     ブートストラップ・ファイルシステムの場合、
     カーネルから渡されたコマンドライン・オプション。
     ブートストラップ・ファイルシステムでない場合は、
     この２つのケースを区別するのに使えるようゼロが入る。

 -- Variable: struct rwlock diskfs_fsys_lock
     ファイルシステム・レベルの操作を行っている間はこのロックを保有すること。
     特に害のない操作を行うユーザは単にreader
     lock（FIXME-J）を保有するだけで良いが、
     他のスレッドに悪影響を及ぼす可能性のある操作ではwriter
     lock（FIXME-J）を保有するべきである。

 -- Variable: volatile struct mapped_time_value * diskfs_mtime
     diskfsルーチンによって使用されている現在のシステム時刻。 これは、
     Cのライブラリ関数`maptime_read'によって`struct
     timeval'に変換される(FIXME xref)。

 -- Variable: int diskfs_synchronous
     すべての操作が同期的に行われなければならない場合のみ真となる。
     これがセットされている場合、
     アロケーション（FIXME-J:割当て？）情報が永遠に同期されるようにするのはフォーマット固有のコードの責任である。
     これ以外のことはフォーマット非依存のコードにより実行される。

 -- Function: error_t diskfs_set_sync_interval (int INTERVAL)
     INTERVAL秒ごとにファイルシステムに対してsync（FIXME-J）を実行するため、
     スレッドを生成する。 INTERVALがゼロの場合は、
     スレッドの生成を行わない。
     スレッドの生成時にエラーが発生した場合は、 エラー値が返される。
     エラーが発生しなかった場合はゼロが返される。
     ２回目以降の呼出し時にも新しいスレッドが生成され、
     古いスレッドは(最終的には)取り除かれる。
     いずれにしろ古いスレッドはこれ以上sync（FIXME-J）を実行することはない。

 -- Variable: spin_lock_t diskfs_node_refcnt_lock
     ページャのリファレンス・カウント・ロック。

 -- Variable: int diskfs_readonly
     ファイルシステムが現在書込み可能であればゼロがセットされる。

 -- Function: error_t diskfs_set_readonly (int READONLY)
     アクティブなファイルシステムのモードを、 読込みのみ可能なモード、
     もしくは、 書込み可能なモードに変更する。
     同時に現在のモードを反映するようグローバル変数DISKFS_READONLYをセットする。
     エラーが返された場合は、 何も変更されていない。
     このルーチンを呼出している間は、
     DISKFS_FSYS_LOCKを保有していなければならない。

 -- Function: int diskfs_check_readonly (void)
     ファイルシステムに書込みを行う操作の前に、
     そのファイルシステムが読込みのみ可能かどうかをチェックする。
     読込みのみ可能であればゼロ以外の値を返し、
     そうでなければゼロを返す。

 -- Function: error_t diskfs_remount (void)
     すべてのin-core（FIXME-J）データ構造をディスクから再度読込む。
     この関数の呼出しは、
     DISKFS_READONLYが真である場合しか成功することはありえない。
     このルーチンを呼出している間は、
     DISKFS_FSYS_LOCKを保有していなければならない。

 -- Function: error_t diskfs_shutdown (int FLAGS)
     ファイルシステムをシャットダウンする。 FLAGSの意味は、
     `fsys_shutdown'の場合と同様である。


File: hurd-ja.info,  Node: Diskfs Node Management,  Next: Diskfs Callbacks,  Prev: Diskfs Globals,  Up: Diskfs Library

9.5.4 Diskfsノード管理
----------------------

すべてのファイルやディレクトリはdiskfs"ノード"である。 以下の関数は、
あなたの書いたdiskfsコールバックがノードやノードへのreference（FIXME-J:リファレンス、参照？）を管理するのを支援してくれるものである。

 -- Function: void diskfs_drop_node (struct node *NP)
     ノードNPはもはやreference（FIXME-J:リファレンス、参照？）を持たないので、
     すべてをクリーンな（FIXME-J）状態にする。
     DISKFS_NODE_REFCNT_LOCKは保有されていなければならず、
     この関数から復帰する際に解放される。
     NPはロックされていなければならない。

 -- Function: void diskfs_node_update (struct node *NP, int WAIT)
     `NP->dn_stat'の情報を使用して、 disk
     fields（FIXME-J:ディスク・フィールド？）をセットする。
     必要であればctime、atime、mtimeを更新する。 WAITが真であれば、
     物理的なメディアの更新が完全に終了するまで復帰しない。

 -- Function: void diskfs_nref (struct node *NP)
     ノードNPに対してhard reference（FIXME-J）を追加する。 ノードにhard
     reference（FIXME-J）があらかじめ存在しない場合、
     そのノードをロックすることはできない (なぜなら、
     ロックを保有するためにはhard
     reference（FIXME-J）を保有していなければならないのであるから)。

 -- Function: void diskfs_nput (struct node *NP)
     ノードNPのロックを解除し、 hard reference（FIXME-J）を解放する。
     これが最後のhard reference（FIXME-J）であり、 かつ、
     そのファイルに対するリンクが存在しなければ、 light
     reference（FIXME-J）を除去するよう要求する。

 -- Function: void diskfs_nrele (struct node *NP)
     NPのhard reference（FIXME-J）を解放する。
     NPが何者かによってロックされていれば、 これが最後のhard
     reference（FIXME-J）であることはありえない (なぜなら、
     ロックを保有するためにはhard
     reference（FIXME-J）を保有していなければならないのであるから)。
     これが最後のhard reference（FIXME-J）であり、 かつ、
     リンクが存在しなければ、 light
     reference（FIXME-J）を除去するよう要求する。

 -- Function: void diskfs_nref_light (struct node *NP)
     ノードに対してlight reference（FIXME-J）を追加する。

 -- Function: void diskfs_nput_light (struct node *NP)
     ノードNPのロックを解除し、 light reference（FIXME-J）を解放する。

 -- Function: void diskfs_nrele_light (struct node *NP)
     NPに対するlight reference（FIXME-J）を解放する。
     NPが何者かによってロックされていれば、
     これが最後のreference（FIXME-J:リファレンス、参照？）であることはありえない
     (なぜなら、 ロックを保有するためにはhard
     reference（FIXME-J）を保有していなければならないのであるから)。

 -- Function: error_t diskfs_node_rdwr (struct node *NP, char *DATA,
          off_t OFF, size_t AMT, int DIRECTION, struct protid *CRED,
          size_t *AMTREAD)
     これは、
     ファイルの読み書きを行う場合や自動的なファイル・サイズの拡張が必要である場合に、
     他のファイルシステム・ルーチンから呼出されるものである。
     NPは読み書きされるノードであり、 ロックされていなければならない。
     DATAの指すデータがファイルに書込まれたり、 あるいは、
     ファイルから読込まれたデータがDATAの指す領域に書込まれたりする。
     OFFは、 I/Oが実際に行われるべきファイル中の場所を示す
     (負の値は許されない)。 AMTはDATAのサイズであり、
     どれだけのデータをコピーするべきかを示す。 DIRは、
     読込みの場合はゼロであり、 書込みの場合はゼロ以外の値である。
     CREDは、 アクセスを行っているユーザを示す
     (ファイルを拡張しようとする試みの正当性を判断するためだけに使われる)。
     読込みの場合、
     実際に読込まれたデータのサイズが`*AMTREAD'に入れられる。

 -- Function: void diskfs_notice_dirchange (struct node *DP,
          enum dir_changed_type TYPE, char *NAME)
     `dir_notice_changes'によってディレクトリDPに関するnotification（FIXME-J）を要求したユーザに対して、
     notification（FIXME-J）を送信する。
     変更の種類と変更により影響を受けた名前が、
     それぞれTYPEとNAMEである。 これは、
     `diskfs_direnter'、`diskfs_dirremove'、`diskfs_dirrewrite'、
     および、 そのディレクトリを変更する任意の関数から、
     その変更が完全に終了した後に呼出されるべきものである。

 -- Function: struct node * diskfs_make_node (struct disknode *DN)
     DNを物理的なdisknode（FIXME-J）とする新しいnode構造体を作成する。
     新しく作成されたノード（node）は、 hard
     reference（FIXME-J）を１個持ち、 light
     reference（FIXME-J）は持たない。

   以下のノード操作関数群は一般的には有用ではないが、
diskfs関数を再定義する必要がある場合には便利であるかもしれない。

 -- Function: error_t diskfs_create_node (struct node *DIR, char *NAME,
          mode_t MODE, struct node **NEWNODE, struct protid *CRED,
          struct dirstat *DS)
     新しいノードを作成し、 そのモードをMODEとする。
     MODEに`IFDIR'が含まれていれば、
     新しいディレクトリ中の`.'と`..'も初期化する。
     作成されたノードはNPPに入れて返す。 CREDは、
     この関数の呼出しに責任を負うユーザを識別する。
     NAMEがゼロ以外の値であれば、
     新しく作成されたノードをNAMEという名前でDIRにリンクする。 DSは、
     ノード作成のために事前に呼出された`diskfs_lookup'の結果である
     (DIRは、 `diskfs_lookup'の呼出し以降ロックされたままである)。
     DIRは、
     少なくともディスク・アロケーション（FIXME-J:割当て？）方針のヒントとして、
     常にこの関数に渡されなければならない。

 -- Function: void diskfs_set_node_times (struct node *NP)
     `NP->dn_set_ctime'がセットされていれば、
     しかるべく`NP->dn_stat.st_ctime'を変更する。
     atimeとmtimeについても同じような操作を行う。

 -- Function: struct node * diskfs_check_lookup_cache (struct node *DIR,
          char *NAME)
     キャッシュの中からDIRの中のNAMEを探す。
     既知の範囲でそのようなエントリが存在しなければゼロを返す。
     そのようなエントリが存在しないことが確実であれば-1を返す。
     これ以外の場合は、
     新しく割当てられたreference（FIXME-J:リファレンス、参照？）とともに、
     エントリに対応するNPを返す。

 -- Function: error_t diskfs_cached_lookup (int CACHE_ID,
          struct node **NPP)
     `*NPP'の中のCACHE_IDに対応するノードを返す。

 -- Function: void diskfs_enter_lookup_cache (struct node *DIR,
          struct node *NP, char *NAME)
     ノードNPは、 DIRの中でNAMEという名前で見つけられたものである。
     NPがNULLであれば、
     この名前のエントリがディレクトリの中に存在しないことが確認されたということを意味する。

 -- Function: void diskfs_purge_lookup_cache (struct node *DP,
          struct node *NP)
     ディレクトリDPの中のノードとしてNPを参照する、
     キャッシュ内のすべてのreference（FIXME-J:リファレンス、参照？）を除去する。


File: hurd-ja.info,  Node: Diskfs Callbacks,  Next: Diskfs Options,  Prev: Diskfs Node Management,  Up: Diskfs Library

9.5.5 Diskfsコールバック
------------------------

ほかのいくつかのHurdライブラリと同様、
`libdiskfs'もあなたがアプリケーション固有のコールバック関数を実装することをあてにしている。
あなたは以下の関数と変数を定義_しなければならない_。 また、
いくつかのdiskfsオプションのデフォルト値は、
良いファイルシステム・サポートを提供するためには変更するべきであるので、
*Note Diskfs Options::も参照するべきである。

 -- Structure: struct dirstat
     この型はあなたが定義しなければならない。 この型が、
     `diskfs_lookup'の呼出しから`diskfs_direnter'、`diskfs_dirremove'、`diskfs_dirrewrite'のいずれか１つの呼出しまでの間、
     情報を保有することになる。
     これらの呼出しが以下に説明するように機能するために十分な情報が、
     この型の中に保持されなければならない。

 -- Variable: size_t diskfs_dirstat_size
     これは`struct dirstat'のバイト単位のサイズでなければならない。

 -- Variable: int diskfs_link_max
     これは、
     １個のファイルに対して存在することのできるリンクの最大個数であり、
     正の整数でなければならない。 `dir_rename'の実装は、
     許されるリンク数がただの１個である場合に処理を成功させる方法を知らない。
     そのようなフォーマットの場合、
     あなたは自分で`dir_rename'を再実装する必要がある。

 -- Variable: int diskfs_maxsymlinks
     これは、
     １回の`dir_pathtrans'の呼出しでたどることのできるシンボリック・リンクの最大数を示す正の整数である。
     この値を超過すると、 `dir_pathtrans'は`ELOOP'を返すことになる。

 -- Variable: struct node * diskfs_root_node
     ここにはファイルシステムのルート・ノードをセットする。

 -- Variable: char * diskfs_server_name
     ここにはファイルシステム・サーバの名前をセットする。

 -- Variable: char * diskfs_server_version
     ここにはサーバのバージョンを示す文字列をセットする。

 -- Variable: char * diskfs_disk_name
     これは、
     このファイルシステムが解釈している特定のディスクを何らかの形で識別する文字列でなければならない。
     通常これは、 メッセージを表示したり、
     同一のファイルシステム・タイプの複数のインスタンスを区別するためにのみ使用される。
     このファイルシステムが外部メディアに一切アクセスしないのであれば、
     これをゼロとして定義する。

 -- Function: error_t diskfs_set_statfs (fsys_statfsbuf_t *STATFSBUF)
     ファイルシステムの現在の状態を反映するよう適切な値を`*STATFSBUF'にセットする。

 -- Function: error_t diskfs_lookup (struct node *DP, char *NAME,
          enum lookup_type TYPE, struct node **NP, struct dirstat *DS,
          struct protid *CRED)
 -- Function: error_t diskfs_lookup_hard (struct node *DP, char *NAME,
          enum lookup_type TYPE, struct node **NP, struct dirstat *DS,
          struct protid *CRED)
     あなたは`diskfs_lookup'を定義するべきではない。 なぜなら、
     これは単に`diskfs_lookup_hard'に対するラッパーに過ぎず、
     既に`libdiskfs'の中で定義されているからである。

     (ロックされている)ディレクトリDPの中で名前NAMEを捜し出す(ルックアップする)。
     TYPEは、 `LOOKUP'、`CREATE'、`RENAME'、`REMOVE'のいずれかである。
     CREDは、 呼出しを行ったユーザを識別する。

     名前NAMEが見つかればゼロを返し、 (NPの値がゼロ以外であれば)
     それに対応するノードを指すように`*NP'をセットする
     このノードはロックされなければならない。
     その名前が見つからない場合は`ENOENT'を返し、
     (NPの値がゼロ以外であれば) `*NP'にゼロをセットする。
     NPがゼロであれば、
     見つかったノードは一時的にであれロックされてはならない。
     (見つかったノードに対するパーミションのチェックがしばしば実行されなければならない)
     `REMOVE'と`RENAME'のためのルックアップの場合、
     NPは常にセットされる。

     DSの値がゼロ以外であれば、
     要求されたルックアップ種別TYPEによって振舞いが変わることになる。

    `LOOKUP'
          `diskfs_drop_dirstat'によって無視されるよう`*DS'をセットする。

    `CREATE'
          成功した場合は、
          `diskfs_drop_dirstat'によって無視されるよう`*DS'をセットする。
          失敗した場合は、
          将来の`diskfs_direnter'の呼出し用に`*DS'をセットする。

    `RENAME'
          成功した場合は、
          将来の`diskfs_dirrewrite'の呼出し用に`*DS'をセットする。
          失敗した場合は、
          将来の`diskfs_direnter'の呼出し用に`*DS'をセットする。

    `REMOVE'
          成功した場合は、
          将来の`diskfs_dirremove'の呼出し用に`*DS'をセットする。
          失敗した場合は、
          `diskfs_drop_dirstat'によって無視されるよう`*DS'をセットする。

     この関数の呼出し側は、 次の２つのことを保証する。 まず第１に、
     DSがゼロ以外であれば、 ディレクトリDPのロックが解除される前に、
     上にリストされた適切な呼出しが行われること、 もしくは、
     `diskfs_drop_dirstat'がDSを引数として呼出されることを保証する。
     第２に、 今回ルックアップ関数を呼出してから*DSを使用する
     (もしくは、破棄する) までの間に、
     このディレクトリに対してルックアップ関数は一切呼出されないことを保証する。

     あなたが`diskfs_rename_dir'、`diskfs_clear_directory'、`diskfs_init_dir'のライブラリ・バージョンを使うのであれば、
     `..'に対するルックアップでは、
     フラグ`SPEC_DOTDOT'がORされているかもしれない。
     要求されたルックアップ種別TYPEによっては、 これが特別な意味を持つ。

    `LOOKUP'
          復帰する前に、 DPのロックは解除されなければならず、 また、
          そのreference（FIXME-J:リファレンス、参照？）は除去されなければならない。

    `CREATE'
          `SPEC_DOTDOT'が与えられないことは保証されているので、
          このケースは無視してよい。

    `RENAME'
    `REMOVE'
          どちらの場合も、
          見つかったノード(`*NP')は既にロックされている。 したがって、
          それをさらにロックしたり、
          reference（FIXME-J:リファレンス、参照？）を追加したりしないこと。

     名前NAMEがディレクトリの中に存在しない場合は`ENOENT'を返す。
     NAMEが、 このファイルシステムのルートの`..'を指している場合は、
     `EAGAIN'を返す。 `EIO'を返すことが適切な場合には、 `EIO'を返す。

 -- Function: error_t diskfs_direnter (struct node *DP, char *NAME,
          struct node *NP, struct dirstat *DS, struct protid *CRED)
 -- Function: error_t diskfs_direnter_hard (struct node *DP, char *NAME,
          struct node *NP, struct dirstat *DS, struct protid *CRED)
     あなたは`diskfs_direnter'を定義するべきではない。 なぜなら、
     これは単に`diskfs_direnter_hard'に対するラッパーに過ぎず、
     既に`libdiskfs'の中で定義されているからである。

     ディレクトリDPにNAMEという名前でNPを追加する。 これは、 `CREATE'、
     もしくは、
     `RENAME'の`diskfs_lookup'呼出しが失敗した後にのみ呼出されることになる。
     DPは、 この`diskfs_lookup'の呼出し以降ロックされたままであり、
     DSの内容は、
     `diskfs_lookup'の呼出しによってセットされたままの状態である。
     また、 NPはロックされている。 CREDは、
     この関数の呼出しに責任を負うユーザを識別する
     (ディレクトリ拡張の正当性を判断するためだけに使われる)。

 -- Function: error_t diskfs_dirrewrite (struct node *DP,
          struct node *OLDNP, struct node *NP, char *NAME,
          struct dirstat *DS)
 -- Function: error_t diskfs_dirrewrite_hard (struct node *DP,
          struct node *NP, struct dirstat *DS)
     あなたは`diskfs_dirrewrite'を定義するべきではない。 なぜなら、
     これは単に`diskfs_dirrewrite_hard'に対するラッパーに過ぎず、
     既に`libdiskfs'の中で定義されているからである。

     これは、
     `RENAME'の`diskfs_lookup'呼出しが成功した後にのみ呼出されることになる。
     この呼出しにより、 ディレクトリDPに見つかった名前は、
     それが以前に参照していたノードに換わって、
     ノードNPを指すように変更されているはずである。 DPは、
     この`diskfs_lookup'の呼出し以降ロックされたままであり、
     DSの内容は、
     `diskfs_lookup'の呼出しによってセットされたままの状態である。
     また、 NPはロックされている。

     `diskfs_dirrewrite'については、 さらに追加仕様がある。 NAMEは、
     DPの中で以前参照されていたノードOLDNPに対応していた名前である。
     更新されるのはこのreference（FIXME-J:リファレンス、参照？）である。
     `DP->dirmod_reqs'がゼロ以外であれば、
     `diskfs_dirrewrite'は`diskfs_notice_dirchange'も呼出す。

 -- Function: error_t diskfs_dirremove (struct node *DP, struct node *NP,
          char *NAME, struct dirstat *DS)
 -- Function: error_t diskfs_dirremove_hard (struct node *DP,
          struct dirstat *DS)
     あなたは`diskfs_dirremove'を定義するべきではない。 なぜなら、
     これは単に`diskfs_dirremove_hard'に対するラッパーに過ぎず、
     既に`libdiskfs'の中で定義されているからである。

     これは、
     `REMOVE'の`diskfs_lookup'呼出しが成功した後にのみ呼出されることになる。
     この呼出しにより、
     ディレクトリDSに見つかった名前は削除されているはずである。 DPは、
     この`diskfs_lookup'の呼出し以降ロックされたままであり、
     DSの内容は、
     `diskfs_lookup'の呼出しによってセットされたままの状態である。

     `diskfs_dirremove'については、 さらに追加仕様がある。
     `DP->dirmod_reqs'がゼロ以外であれば、
     このルーチンは`diskfs_notice_dirchange'も呼出さなければならない。
     削除されるエントリは、 NAMEという名前を持ち、 NPを参照している。

 -- Function: error_t diskfs_drop_dirstat (struct node *DP,
          struct dirstat *DS)
     DSは、
     ディレクトリDPに対する`diskfs_lookup'の前回の呼出しによってセットされたものである。
     `diskfs_direnter'、`diskfs_dirrewrite'、`diskfs_dirremove'が以前に呼出されていなければ、
     この関数が呼出されることは保証されている。 この関数は、 `struct
     dirstat'により保持されているどのような状態も解放するべきである。
     DPは、 `diskfs_lookup'の呼出し以降ロックされたままの状態である。

 -- Function: void diskfs_null_dirstat (struct dirstat *DS)
     `diskfs_drop_dirstat'が無視するようにDSを初期化する。

 -- Function: error_t diskfs_get_directs (struct node *DP, int ENTRY,
          int N, char **DATA, u_int *DATACNT, vm_size_t BUFSIZ,
          int *AMT)
     ロックされたディレクトリ・ノードDPのENTRYから始まるN個のディレクトリ・エントリを返す。
     これらのエントリは、
     現在`*DATACNT'バイトの領域を指す`*DATA'に入れられる。
     このサイズが十分でない場合には、
     `*DATA'に対して`vm_allocate'を呼出す。 `*DATACNT'には、
     実際に使用された総サイズをセットする。
     AMTにはコピーされたエントリの数を入れる。 ただし、
     BUFSIZバイトを超えてコピーしないこと。 BUFSIZがゼロであれば、
     `*DATACNT'の上限はない。 Nが-1であれば、 AMTの上限はない。

 -- Function: int diskfs_dirempty (struct node *DP, struct protid *CRED)
     ロックされたディレクトリDPが空であれば、 ゼロ以外の値を返す。
     ユーザが、
     `diskfs_clear_directory'と`diskfs_init_directory'を再定義していなければ、
     「空」とは「`.'というラベルのエントリと`..'というラベルのエントリだけを持つ」という意味である。
     CREDは、 この呼出しを行ったユーザを識別する...
     そのディレクトリを探索することがこのユーザにはできない場合、
     このルーチンの呼出しは失敗しなければならない。

 -- Function: error_t diskfs_get_translator (struct node *NP,
          char **NAMEP, u_int *NAMELEN)
     (`diskfs_node_translated'が真であるような)
     ロックされたノードNPについて、 そのトランスレータの名前を捜し出す。
     新たにmallocにより獲得された領域にその名前を格納し、
     その名前全体の長さを`*NAMELEN'にセットする。

 -- Function: error_t diskfs_set_translator (struct node *NP, char *NAME,
          u_int NAMELEN, struct protid *CRED)
     ロックされたノードNPについて、
     そのトランスレータの名前としてNAMEの値を、 また、
     その名前のバイト長としてNAMELENの値を、 それぞれセットする。
     CREDは、 この関数の呼出しに責任を負うユーザを識別する。

 -- Function: error_t diskfs_truncate (struct node *NP, off_t SIZE)
     ロックされたノードNPの長さをSIZEバイトに切り詰める。
     NPの長さが既にSIZEバイト以下であれば、 何もしない。
     これがsymlink（FIXME-J:シンボリック・リンク？）である (かつ、
     `diskfs_shortcut_symlink'がセットされている) 場合は、
     `diskfs_create_symlink_hook'がリンクのターゲットをどこか別の場所にセットしている場合でも、
     そのsymlink（FIXME-J:シンボリック・リンク？）は除去されなければならない。

 -- Function: error_t diskfs_grow (struct node *NP, off_t SIZE,
          struct protid *CRED)
     ロックされたノードNPに対して割当てられたディスクを、
     少なくともSIZEバイト以上になるようサイズを拡張し、
     実際に割当てられたサイズを`NP->allocsize'にセットする。
     割当てられているサイズが既にSIZEバイトである場合には、 何もしない。
     CREDは、 この関数の呼出しに責任を負うユーザを識別する。

 -- Function: error_t diskfs_node_reload (struct node *NODE)
     この関数は、 ディスクに対して一切書込みを行うことなく、
     ディスクからノードNODEに固有なデータをすべて再読込みしなければならない。
     これは常に、 DISKFS_READONLYが真にセットされた状態で呼出される。

 -- Function: error_t diskfs_reload_global_state (void)
     この関数は、
     キャッシュされているすべてのグローバルな状態を無効にしなければならない。
     また、 ディスクに対して一切書込みを行うことなく、
     必要に応じてディスクからそれを再読込みしなければならない。
     これは常に、 DISKFS_READONLYを真にセットした状態で呼出される。
     常に、 この関数の呼出しに続いて、
     すべてのアクティブなノードに対して`diskfs_node_reload'が呼出されるので、
     この関数ではノード固有のデータを再読込みする必要はない。

 -- Function: error_t diskfs_node_iterate (error_t (*FUN)
          (struct node *NP))
     アクティブなノードNPの１つ１つについて、 FUNを呼出す。 ノードは、
     FUNの呼出しの間はロックされる。
     FUNが任意のノードについてゼロ以外の値を返した場合は、
     即座に処理を停止し、 その値を返す。

 -- Function: error_t diskfs_alloc_node (struct node *DP, mode_t MODE,
          struct node **NP)
     ロックされたディレクトリDPの中でモードMODEを持つノードとするために新しいノードを割当てる。
     ただし、 実際にそのモードをセットしたり、
     ディレクトリを変更したりすることはしない。 これらは、
     呼出し側によって行われるからである。
     このリクエストに責任を負うユーザは、
     CREDにより識別することができる。
     新しく割当てられたノードを`*NP'にセットする。

 -- Function: void diskfs_free_node (struct node *NP, mode_t MODE)
     ノードNPを解放する。
     (`NP->dn_stat.st_mode'がゼロであったものについては)
     ディスク上のコピーは既に`diskfs_node_update'によって同期が取られている。
     NPのかつてのモードがMODEである。

 -- Function: void diskfs_lost_hardrefs (struct node *NP)
     ロックされたノードNPは、 まだいくつかlight
     reference（FIXME-J）は持つものの、 ちょうど最後のhard
     reference（FIXME-J）を失ったところである。

 -- Function: void diskfs_new_hardrefs (struct node *NP)
     ロックされたノードNPはこれまでhard
     reference（FIXME-J）を持たなかったが、
     ちょうど１つ獲得したところである。 したがって、
     実際にユーザがいなくてもlight
     reference（FIXME-J）を持つことができるようになった。

 -- Function: void diskfs_try_dropping_softrefs (struct node *NP)
     ノードNPは、 まだいくつかlight reference（FIXME-J）は持つものの、
     ちょうど最後のhard reference（FIXME-J）を失ったところである。
     light reference（FIXME-J）に解放可能なものがあれば、
     それを解放するような手段を講じる。
     DISKFS_NODE_REFCNT_LOCKとNPはどちらもロックされている。
     この関数は、 `diskfs_lost_hardrefs'の後に呼出される。

 -- Function: void diskfs_node_norefs (struct node *NP)
     ノードNPはもはやreference（FIXME-J:リファレンス、参照？）を持たない。
     `*NP'が保持されるべきでなければ、
     それも含めてローカルな状態を解放する。
     DISKFS_NODE_REFCNT_LOCKは保有されている。

 -- Function: error_t diskfs_set_hypermetadata (int WAIT, int CLEAN)
     フォーマット固有のバッファにある、
     ページングされていないメタデータをディスクに書込む。 この書込みは、
     WAITの値がゼロであれば、 非同期に行われる。
     CLEANの値がゼロ以外であれば、
     この書込みが行われた後にファイルシステムは完全にクリーンな状態になり、
     ページングされていないメタデータがその事実を示すことができなければならない。

 -- Function: void diskfs_write_disknode (struct node *NP, int WAIT)
     `NP->dn_stat'の中の情報とそれに関連するフォーマット固有の情報をディスクに書込む。
     WAITが真であれば、
     物理的なメディアが完全に更新された後にはじめて復帰する。

 -- Function: void diskfs_file_update (struct node *NP, int WAIT)
     ファイルNPの内容とそれに関連するすべてのメタデータをディスクに書込む。
     一般にこれは、
     メタデータのほとんどの部分に関して`diskfs_node_update'を呼出すことになる。
     WAITが真であれば、
     物理的なメディアが完全に更新された後にはじめて復帰する。

 -- Function: mach_port_t diskfs_get_filemap (struct node *NP,
          vm_prot_t PROT)
     NPのファイル内容に対応するメモリ・オブジェクトのポート(send
     right（FIXME-J:センド・ライト？）)を返す。 PROTは、
     許容される最大限のアクセスを示す。 エラーが発生した場合には、
     `MACH_PORT_NULL'を返し、 `errno'をセットする。

 -- Function: struct pager * diskfs_get_filemap_pager_struct
          (struct node *NP)
     ロックされたノードNPに対してdiskfs_get_filemapが返したページャを参照する`struct
     pager *'を返す。 この戻り値は、
     `pager_memcpy'の引数として使うのに適している。

 -- Function: vm_prot_t diskfs_max_user_pager_prot (void)
     すべてのアクティブなユーザ・ページャに設定された最大限の`prot'パラメータ
     (`diskfs_get_filemap'の第２引数) のビットごとのORを返す。

 -- Function: int diskfs_pager_users (void)
     ユーザによって使用されているかもしれないエクスポートされたページャ・ポートが存在すればゼロ以外の値を返す。
     この関数がゼロを返すまでは、
     それ以上のページャの生成はブロックされるべきである。

 -- Function: void diskfs_sync_everything (int WAIT)
     すべてのページャをsync（FIXME-J）して、
     hypermetadata（FIXME-J:ハイパメタデータ？）を除き、
     ディスク上に存在するべきデータをすべて書込む。 WAITが真であれば、
     物理的なメディアが完全に更新された後にはじめて復帰する。

 -- Function: void diskfs_shutdown_pager (void)
     すべてのページャをシャットダウンする。
     これは一度始めると元に戻すことはできず、
     ファイルシステムが終了する時に実行される。


File: hurd-ja.info,  Node: Diskfs Options,  Next: Diskfs Internals,  Prev: Diskfs Callbacks,  Up: Diskfs Library

9.5.6 Diskfsオプション
----------------------

このサブセクションで説明する関数や変数には既に`libdiskfs'の中にデフォルトの実装があるため、
それらを再定義するよう強制されることはない。 ケース・バイ・ケースで、
それらを再定義しても構わない。

   オプション(任意選択)の変数はいずれも、 プログラムが起動したらすぐに
(例えば引数解析のようなdiskfs関数の呼出しを行うよりも前に)
値をセットしなければならない。

 -- Variable: int diskfs_hard_readonly
     ファイルシステムのメディアを決して書込み可能にすることができないのであれば、
     この変数にゼロ以外の値をセットするべきである。

 -- Variable: char * diskfs_extra_version
     -versionオプションが使われた際に表示されるべき追加的なバージョン情報をここにセットする。

 -- Variable: int diskfs_shortcut_symlink
     これは、
     ファイルシステム・フォーマットがショートカットのためのシンボリック・リンクtranslation(FIXME-J:翻訳、トランスレーション？)をサポートしている場合に限り、
     ゼロ以外の値を取るべきである。 ライブラリは、
     ユーザがこのノードの内容を直接読み書きできないことを保証する。
     ライブラリがこのような保証を行うのは、 symlink
     hook(FIXME-J:シンボリック・リンクをフックする、シンボリック・リンクのフック？)関数
     (`diskfs_create_symlink_hook'と`diskfs_read_symlink_hook')
     が`EINVAL'を返す場合か、
     それらの関数が定義されていない場合だけである。 たとえhook
     function(FIXME-J:フック関数？)が使われている場合でも、
     ライブラリは、
     `dn_stat.st_size'フィールドがsymlink(FIXME-J:シンボリック・リンク？)の長さであることを知っている。

 -- Variable: int diskfs_shortcut_chrdev
 -- Variable: int diskfs_shortcut_blkdev
 -- Variable: int diskfs_shortcut_fifo
 -- Variable: int diskfs_shortcut_ifsock
     これらの変数は、 ファイルシステム・フォーマットが、
     ショートカットのためのキャラクタ・デバイス・ノード、
     ブロック・デバイス・ノード、 FIFO、
     UNIXドメイン・ソケットのtranslation(FIXME-J:翻訳、ランスレーション？)をそれぞれサポートしている場合にのみ、
     ゼロ以外の値を取るべきである。

 -- Variable: int diskfs_default_sync_interval
     最初のdiskfsスレッドが（`diskfs_spawn_first_thread'の中で）起動された時に、
     この値を引数として`diskfs_set_sync_interval'が呼出される。
     この変数のデフォルトの値は30であり、 このデフォルトでは、
     ディスク・バッファは少なくとも30秒ごとにフラッシュされることになる。

 -- Function: error_t diskfs_validate_mode_change (struct node *NP,
          mode_t MODE)
 -- Function: error_t diskfs_validate_owner_change (struct node *NP,
          uid_t UID)
 -- Function: error_t diskfs_validate_group_change (struct node *NP,
          gid_t GID)
 -- Function: error_t diskfs_validate_author_change (struct node *NP,
          uid_t AUTHOR)
 -- Function: error_t diskfs_validate_flags_change (struct node *NP,
          int FLAGS)
 -- Function: error_t diskfs_validate_rdev_change (struct node *NP,
          dev_t RDEV)
     ノードNPが要求されたとおりに変更可能であればゼロを返す。
     これはすなわち、 NPのモードをMODEに、 オーナをUIDに、
     グループをGIDに、 author（FIXME-J：作成者？）をAUTHORに、
     フラグをFLAGSに、 ロー・デバイス番号をRDEVに、
     それぞれ変更可能である場合を指す。
     変更可能でない場合はエラー・コードを返す。

     モードやフラグをクリアすることは常に可能でなければならない。
     diskfsは、 これらをクリアする前に許可を求めることはしない。

 -- Function: void diskfs_readonly_changed (int READONLY)
     これは、
     ディスクが読込みのみ可能なモードから読み書き可能なモードに変更された時、
     あるいは、 その逆の変更が行われた時に呼出される。
     READONLYは新しい状態を表す
     （これはDISKFS_READONLYにも反映される）。
     ファイルシステムが書込み可能なものとなる場合、
     この関数は初期起動時にも呼出される。

 -- Variable: error_t (* diskfs_create_symlink_hook ) (struct node *NP,
          char *TARGET)
     この関数ポインタがゼロ以外の値である場合
     （かつ、`diskfs_shortcut_symlink'がセットされている場合）、
     symlink(FIXME-J:シンボリック・リンク？)をセットするためにその関数が呼出される。
     その関数が`EINVAL'を返した場合、 あるいは、
     そもそも関数がセットされていない場合、 通常の方式
     （すなわち、ファイル・データへの書込み） が使われる。
     これ以外のエラーが返された場合は、 そのエラーはユーザに返される。

 -- Variable: error_t (* diskfs_read_symlink_hook ) (struct node *NP,
          char *TARGET)
     この関数ポインタがゼロ以外の値である場合
     （かつ、`diskfs_shortcut_symlink'がセットされている場合）、
     symlink(FIXME-J:シンボリック・リンク？)の内容を読込むためにその関数が呼出される。
     その関数が`EINVAL'を返した場合、 あるいは、
     そもそも関数がセットされていない場合、 通常の方式
     （すなわち、ファイル・データの読込み） が使われる。
     これ以外のエラーが返された場合は、 そのエラーはユーザに返される。

 -- Function: error_t diskfs_rename_dir (struct node *FDP,
          struct node *FNP, char *FROMNAME, struct node *TDP,
          char *TONAME, struct protid *FROMCRED, struct protid *TOCRED)
     （FDPを親ディレクトリ・ノードとして持ち、
     そのディレクトリの中でFROMNAMEという名前を持つ）
     ディレクトリ・ノードFNPを、
     ディレクトリTDPの中でTONAMEという名前を持つように、 名前変更する。
     これらのノードはどれもロックされておらず、
     関数の復帰時にどれもロックされていてはならない。
     このルーチンはserialize（FIXME-J:シリアライズ？）されるので、
     再入可能である必要はない。
     ディレクトリがこのルーチン以外によって名前変更されることは決してない。
     FROMCREDはFDPとFNPに対して責任を負うユーザである。 また、
     TOCREDはTDPに対して責任を負うユーザである。 このルーチンは、
     `.'と`..'は普通の慣例どおり通常のリンクによって表されるものと想定している。
     あなたが実装するフォーマットにおいてこの想定が正しくない場合、
     あなたはこの関数を再定義しなければならない。

 -- Function: error_t diskfs_clear_directory (struct node *DP,
          struct node *PDP, struct protid *CRED)
     ディレクトリDPから`.'と`..'のエントリをクリア（FIXME-J:削除？）する。
     DPの親ディレクトリがPDPであり、
     この親ディレクトリに対して責任を負うユーザはCREDにより識別される。
     どちらのディレクトリもロックされていなければならない。
     このルーチンは、
     `.'と`..'は普通の慣例どおり通常のリンクによって表されるものと想定している。
     あなたが実装するフォーマットにおいてこの想定が正しくない場合、
     あなたはこの関数を再定義しなければならない。

 -- Function: error_t diskfs_init_dir (struct node *DP, struct node *PDP,
          struct protid *CRED)
     ロックされたノードDPは新規ディレクトリである。
     これに構造体（FIXME-J:構造？）を提供するために必要なリンクをすべて追加する。
     このノードの親ノードが（ロックされている）PDPである。
     このルーチンは、 PDPに対して`diskfs_lookup'を呼出さないこともある。
     この新規ディレクトリは、
     `diskfs_dirempty'の意味する範囲においてクリア（FIXME-J:？）でなければならない。
     このルーチンは、
     `.'と`..'は普通の慣例どおり通常のリンクによって表されるものと想定している。
     あなたが実装するフォーマットにおいてこの想定が正しくない場合、
     あなたはこの関数を再定義しなければならない。 CREDは、
     この関数呼出しをおこなったユーザを識別する。


File: hurd-ja.info,  Node: Diskfs Internals,  Prev: Diskfs Options,  Up: Diskfs Library

9.5.7 Diskfsの内部詳細
----------------------

このライブラリは以下の関数群もエクスポートしている。 ただし、
このライブラリが提供している他の関数群を再定義するのでなければ、
これらは一般的には有用ではない。

 -- Function: error_t diskfs_create_protid (struct peropen *PO,
          struct iouser *USER, struct protid **CRED)
     ユーザUSERを指すCREDの中の既存のperopen
     POに対応するprotidを作成して返す。
     ノード`PO->np'はロックされていなければならない。

 -- Function: error_t diskfs_start_protid (struct peropen *PO,
          struct protid **CRED)
     peropen POに対応する、
     ユーザ識別情報を持たないprotidをCREDの中に構築して返す。
     ノード`PO->np'はロックされていなければならない。

 -- Function: void diskfs_finish_protid (struct protid *CRED,
          struct iouser *USER)
     `diskfs_start_protid'により開始されたprotid
     CREDの構築を終了させる。 protidに組み込まれるユーザがUSERである。

 -- Function: void diskfs_protid_rele (void *ARG)
     protid
     CREDがもはやreference（FIXME-J:リファレンス、参照？）を持たなくなった時に呼出される。
     protidへのreference（FIXME-J:リファレンス、参照？）はポート管理ライブラリによって保守されるため、
     これはクリーンな（FIXME-J:？）ルーチンの一覧に含められる。
     ポート・ライブラリがこの構造体を解放する。

 -- Function: struct peropen * diskfs_make_peropen (struct node *NP,
          int FLAGS, struct peropen *CONTEXT)
     ノードNP上にオープン・フラグFLAGSを持つ新しいperopen構造体を作成して返す。
     `root_parent'、 `shadow_root'、
     `shadow_root_parent'の各フィールドの初期値は、
     CONTEXTがゼロ以外であればそこからコピーされる。
     CONTEXTがゼロであれば、 これらの値はいずれもゼロにセットされる。

 -- Function: void diskfs_release_peropen (struct peropen *PO)
     POに対するreference（FIXME-J:リファレンス、参照？）・カウントをデクリメントする。

 -- Function: error_t diskfs_execboot_fsys_startup (mach_port_t PORT,
          int FLAGS, mach_port_t CTL, mach_port_t *REAL,
          mach_msg_type_name_t *REALPOLY)
     この関数は、
     execserverのブートストラップのために`S_fsys_startup'により呼出される。
     execserverは本物のノードがなくても機能することができるので、
     このようなぺてんが可能である（FIXME-J:？）。
     引数は`<hurd/fsys.defs>'の中の`fsys_startup'と同様である。

 -- Function: int diskfs_demuxer (mach_msg_header_t *INP,
          mach_msg_header_t *OUTP)
     diskfsポートに対して入ってくる`libports'メッセージをdemultiplex（FIXME-J:？）する。

   diskfsライブラリは、
fs、io、fsys、interrupt、notifyの各インターフェイスをdemultiplex（FIXME-J:？）するための関数群も提供している。
すべてのサーバ・ルーチンは、 `diskfs_S_'という接頭辞を持つ。
これらのルーチンについては、
`file_t'型、もしくは、`io_t'型の`in'（入力）引数は、
スタブからは`struct protid *'として見える。


File: hurd-ja.info,  Node: Twisted Filesystems,  Next: Distributed Filesystems,  Prev: Stored Filesystems,  Up: Top

10 Twisted（FIXME-J:？）ファイルシステム
****************************************

Hurdでは、
ファイルシステムに対するリクエストをトランスレータが別のトランスレータへ転送することが可能であり、
これにより、 背後にあるデータが同一であっても、
それが複数の異なる見え方をするというような実装を実現することが可能になる。
この章で説明するトランスレータは、
データに対する直接的なアクセスを提供するものではない。 むしろ、
既存の物理的なファイルシステム・レイアウトを単純化するのに役立つ構成ツールである。

   これらのトランスレータは細心の注意を払って使うべきである。
さもないと、
ファイルシステムは厳密なツリー構造であってほしいと考えている人々に、
誤って害を与えることがあるかもしれない。(1)

   FIXME: finish

10.1 symlink, firmlink
======================

10.2 hostmux, usermux
=====================

10.3 shadowfs
=============

---------- Footnotes ----------

   (1)
ねじれ曲がったファイルシステムの迷路の中で迷子になってしまう、等々...


File: hurd-ja.info,  Node: Distributed Filesystems,  Next: Networking,  Prev: Twisted Filesystems,  Up: Top

11 分散ファイルシステム
***********************

分散ファイルシステムは、
何らかのネットワーク接続を使って別々のマシン間でファイルを共有するために設計されている。
そのデザインは、
stored（FIXME-J）ファイルシステムのデザインとは大きく異なっている(*note
Stored Filesystems::)。
ネットワークの遅延や障害といった問題に対処する必要があり、 また、
複数のファイル・サーバ間でやりとりされる複雑なauthentication（FIXME-J:認証？）プロトコルやreplication（FIXME-J）プロトコルを必要とする可能性もある。

* Menu:

* File Transfer Protocol::      FTPベースの分散ファイルシステム。
* Network File System::         SunのNFS: 出来は悪いが、よく使われているファイルシステム。


File: hurd-ja.info,  Node: File Transfer Protocol,  Next: Network File System,  Up: Distributed Filesystems

11.1 File Transfer Protocol
===========================

FIXME: finish

* Menu:

* FTP Connection Library::      Managing remote FTP server connections.

11.1.1 ftpcp, ftpdir
--------------------

11.1.2 ftpfs
------------


File: hurd-ja.info,  Node: FTP Connection Library,  Up: File Transfer Protocol

11.1.3 FTP Connection Library
-----------------------------

FIXME: finish


File: hurd-ja.info,  Node: Network File System,  Prev: File Transfer Protocol,  Up: Distributed Filesystems

11.2 Network File System
========================

FIXME: finish

11.2.1 nfsd
-----------

11.2.2 nfs
----------


File: hurd-ja.info,  Node: Networking,  Next: Terminal Handling,  Prev: Distributed Filesystems,  Up: Top

12 Networking
*************

FIXME: this subsystem is in flux

* Menu:

* Socket Interface::            Network communication I/O protocol.

12.1 pfinet
===========

12.2 pflocal
============

12.3 libpipe
============


File: hurd-ja.info,  Node: Socket Interface,  Up: Networking

12.4 Socket Interface
=====================

FIXME: net frobbing stuff may be added to socket.defs


File: hurd-ja.info,  Node: Terminal Handling,  Next: Running Programs,  Prev: Networking,  Up: Top

13 Terminal Handling
********************

FIXME: finish

13.1 term
=========

13.2 term.defs
==============


File: hurd-ja.info,  Node: Running Programs,  Next: Authentication,  Prev: Terminal Handling,  Up: Top

14 Running Programs
*******************

FIXME: finish

14.1 ps, w
==========

14.2 libps
==========

14.3 exec
=========

14.4 proc
=========

14.5 crash
==========


File: hurd-ja.info,  Node: Authentication,  Next: Index,  Prev: Running Programs,  Up: Top

15 Authentication
*****************

FIXME: finish

* Menu:

* Auth Interface::              Auth ports implement the auth interface.

15.1 addauth, rmauth, setauth
=============================

15.2 su, sush, unsu
===================

15.3 login, loginpr
===================

15.4 auth
=========


File: hurd-ja.info,  Node: Auth Interface,  Up: Authentication

15.5 Auth Interface
===================

FIXME: finish

* Menu:

* Auth Protocol::               Bidirectional authentication.


File: hurd-ja.info,  Node: Auth Protocol,  Up: Auth Interface

15.5.1 Auth Protocol
--------------------

FIXME: finish


File: hurd-ja.info,  Node: Index,  Prev: Authentication,  Up: Top

Index
*****

 [index ]
* Menu:

* /boot/servers.boot:                    Boot Scripts.        (line   6)
* appending disks:                       Store Classes.       (line 184)
* argp_program_bug_address:              Bug Address Library. (line   9)
* auth.defs:                             Auth Interface.      (line   6)
* concat store:                          Store Classes.       (line 184)
* concatenation, disk:                   Store Classes.       (line 184)
* conch:                                 Conch Management.    (line   6)
* copy store:                            Store Classes.       (line 133)
* cthreads.h:                            Threads Library.     (line   6)
* device drivers:                        Store Classes.       (line  72)
* device store:                          Store Classes.       (line  72)
* dirstat:                               Diskfs Callbacks.    (line  14)
* disk concatenation:                    Store Classes.       (line 184)
* disk striping:                         Store Classes.       (line 212)
* disk-based filesystems:                Stored Filesystems.  (line   6)
* diskfs.h:                              Diskfs Library.      (line   6)
* diskfs_alloc_node:                     Diskfs Callbacks.    (line 289)
* diskfs_append_args:                    Diskfs Arguments.    (line  16)
* diskfs_append_std_options:             Diskfs Arguments.    (line  23)
* diskfs_argv:                           Diskfs Globals.      (line  24)
* diskfs_auth_server_port:               Diskfs Globals.      (line  14)
* diskfs_boot_flags:                     Diskfs Globals.      (line  31)
* diskfs_cached_lookup:                  Diskfs Node Management.
                                                              (line 127)
* diskfs_check_lookup_cache:             Diskfs Node Management.
                                                              (line 118)
* diskfs_check_readonly:                 Diskfs Globals.      (line  79)
* diskfs_clear_directory:                Diskfs Options.      (line 122)
* diskfs_console_stdio:                  Diskfs Startup.      (line  19)
* diskfs_create_node:                    Diskfs Node Management.
                                                              (line  98)
* diskfs_create_protid:                  Diskfs Internals.    (line  12)
* diskfs_create_symlink_hook:            Diskfs Options.      (line  84)
* diskfs_default_pager:                  Diskfs Globals.      (line  11)
* diskfs_default_sync_interval:          Diskfs Options.      (line  46)
* diskfs_demuxer:                        Diskfs Internals.    (line  56)
* diskfs_dirempty:                       Diskfs Callbacks.    (line 227)
* diskfs_direnter:                       Diskfs Callbacks.    (line 139)
* diskfs_direnter_hard:                  Diskfs Callbacks.    (line 141)
* diskfs_dirremove:                      Diskfs Callbacks.    (line 182)
* diskfs_dirremove_hard:                 Diskfs Callbacks.    (line 184)
* diskfs_dirrewrite:                     Diskfs Callbacks.    (line 158)
* diskfs_dirrewrite_hard:                Diskfs Callbacks.    (line 160)
* diskfs_dirstat_size:                   Diskfs Callbacks.    (line  21)
* diskfs_disk_name:                      Diskfs Callbacks.    (line  46)
* diskfs_drop_dirstat:                   Diskfs Callbacks.    (line 203)
* diskfs_drop_node:                      Diskfs Node Management.
                                                              (line  10)
* diskfs_enter_lookup_cache:             Diskfs Node Management.
                                                              (line 131)
* diskfs_exec:                           Diskfs Globals.      (line  13)
* diskfs_exec_ctl:                       Diskfs Globals.      (line  12)
* diskfs_execboot_fsys_startup:          Diskfs Internals.    (line  48)
* diskfs_extra_version:                  Diskfs Options.      (line  19)
* diskfs_file_update:                    Diskfs Callbacks.    (line 343)
* diskfs_finish_protid:                  Diskfs Internals.    (line  24)
* diskfs_free_node:                      Diskfs Callbacks.    (line 298)
* diskfs_fsys_identity:                  Diskfs Globals.      (line  20)
* diskfs_fsys_lock:                      Diskfs Globals.      (line  37)
* diskfs_get_directs:                    Diskfs Callbacks.    (line 216)
* diskfs_get_filemap:                    Diskfs Callbacks.    (line 351)
* diskfs_get_filemap_pager_struct:       Diskfs Callbacks.    (line 358)
* diskfs_get_translator:                 Diskfs Callbacks.    (line 237)
* diskfs_grow:                           Diskfs Callbacks.    (line 259)
* diskfs_hard_readonly:                  Diskfs Options.      (line  15)
* diskfs_init_dir:                       Diskfs Options.      (line 133)
* diskfs_init_diskfs:                    Diskfs Startup.      (line  28)
* diskfs_link_max:                       Diskfs Callbacks.    (line  24)
* diskfs_lookup:                         Diskfs Callbacks.    (line  59)
* diskfs_lookup_hard:                    Diskfs Callbacks.    (line  62)
* diskfs_lost_hardrefs:                  Diskfs Callbacks.    (line 304)
* diskfs_make_node:                      Diskfs Node Management.
                                                              (line  87)
* diskfs_make_peropen:                   Diskfs Internals.    (line  36)
* diskfs_max_user_pager_prot:            Diskfs Callbacks.    (line 363)
* diskfs_maxsymlinks:                    Diskfs Callbacks.    (line  32)
* diskfs_mtime:                          Diskfs Globals.      (line  44)
* diskfs_new_hardrefs:                   Diskfs Callbacks.    (line 309)
* diskfs_node_iterate:                   Diskfs Callbacks.    (line 282)
* diskfs_node_norefs:                    Diskfs Callbacks.    (line 324)
* diskfs_node_rdwr:                      Diskfs Node Management.
                                                              (line  61)
* diskfs_node_refcnt_lock:               Diskfs Globals.      (line  65)
* diskfs_node_reload:                    Diskfs Callbacks.    (line 266)
* diskfs_node_update:                    Diskfs Node Management.
                                                              (line  17)
* diskfs_notice_dirchange:               Diskfs Node Management.
                                                              (line  78)
* diskfs_nput:                           Diskfs Node Management.
                                                              (line  30)
* diskfs_nput_light:                     Diskfs Node Management.
                                                              (line  49)
* diskfs_nref:                           Diskfs Node Management.
                                                              (line  23)
* diskfs_nref_light:                     Diskfs Node Management.
                                                              (line  46)
* diskfs_nrele:                          Diskfs Node Management.
                                                              (line  36)
* diskfs_nrele_light:                    Diskfs Node Management.
                                                              (line  52)
* diskfs_null_dirstat:                   Diskfs Callbacks.    (line 211)
* diskfs_pager_users:                    Diskfs Callbacks.    (line 367)
* diskfs_protid_rele:                    Diskfs Internals.    (line  28)
* diskfs_purge_lookup_cache:             Diskfs Node Management.
                                                              (line 137)
* diskfs_read_symlink_hook:              Diskfs Options.      (line  94)
* diskfs_readonly:                       Diskfs Globals.      (line  68)
* diskfs_readonly_changed:               Diskfs Options.      (line  74)
* diskfs_release_peropen:                Diskfs Internals.    (line  43)
* diskfs_reload_global_state:            Diskfs Callbacks.    (line 271)
* diskfs_remount:                        Diskfs Globals.      (line  85)
* diskfs_rename_dir:                     Diskfs Options.      (line 105)
* diskfs_root_node:                      Diskfs Callbacks.    (line  37)
* diskfs_runtime_argp:                   Diskfs Arguments.    (line  29)
* diskfs_S_*:                            Diskfs Internals.    (line  58)
* diskfs_server_name:                    Diskfs Callbacks.    (line  40)
* diskfs_server_version:                 Diskfs Callbacks.    (line  43)
* diskfs_set_hypermetadata:              Diskfs Callbacks.    (line 330)
* diskfs_set_node_times:                 Diskfs Node Management.
                                                              (line 112)
* diskfs_set_options:                    Diskfs Arguments.    (line  10)
* diskfs_set_readonly:                   Diskfs Globals.      (line  71)
* diskfs_set_statfs:                     Diskfs Callbacks.    (line  54)
* diskfs_set_sync_interval:              Diskfs Globals.      (line  55)
* diskfs_set_translator:                 Diskfs Callbacks.    (line 244)
* diskfs_shortcut_blkdev:                Diskfs Options.      (line  37)
* diskfs_shortcut_chrdev:                Diskfs Options.      (line  36)
* diskfs_shortcut_fifo:                  Diskfs Options.      (line  38)
* diskfs_shortcut_ifsock:                Diskfs Options.      (line  39)
* diskfs_shortcut_symlink:               Diskfs Options.      (line  22)
* diskfs_shutdown:                       Diskfs Globals.      (line  92)
* diskfs_shutdown_pager:                 Diskfs Callbacks.    (line 378)
* diskfs_spawn_first_thread:             Diskfs Startup.      (line  34)
* diskfs_start_bootstrap:                Diskfs Startup.      (line  55)
* diskfs_start_protid:                   Diskfs Internals.    (line  18)
* diskfs_startup_argp:                   Diskfs Arguments.    (line  41)
* diskfs_startup_diskfs:                 Diskfs Startup.      (line  40)
* diskfs_std_runtime_argp:               Diskfs Arguments.    (line  36)
* diskfs_store_startup_argp:             Diskfs Arguments.    (line  47)
* diskfs_sync_everything:                Diskfs Callbacks.    (line 372)
* diskfs_synchronous:                    Diskfs Globals.      (line  49)
* diskfs_truncate:                       Diskfs Callbacks.    (line 250)
* diskfs_try_dropping_softrefs:          Diskfs Callbacks.    (line 316)
* diskfs_validate_author_change:         Diskfs Options.      (line  59)
* diskfs_validate_flags_change:          Diskfs Options.      (line  61)
* diskfs_validate_group_change:          Diskfs Options.      (line  57)
* diskfs_validate_mode_change:           Diskfs Options.      (line  53)
* diskfs_validate_owner_change:          Diskfs Options.      (line  55)
* diskfs_validate_rdev_change:           Diskfs Options.      (line  63)
* diskfs_write_disknode:                 Diskfs Callbacks.    (line 338)
* disks, appending:                      Store Classes.       (line 184)
* disks, interleaving:                   Store Classes.       (line 212)
* ext2fs:                                Linux Extended 2 FS. (line   6)
* external pager (XP):                   Pager Library.       (line   6)
* file store:                            Store Classes.       (line  88)
* file_chauthor:                         Changing Status.     (line  18)
* file_chflags:                          Changing Status.     (line  23)
* file_chmod:                            Changing Status.     (line  21)
* file_chown:                            Changing Status.     (line  13)
* file_exec:                             Program Execution.   (line   6)
* file_lock:                             File Locking.        (line  10)
* file_lock_stat:                        File Locking.        (line  10)
* file_set_size:                         Changing Status.     (line  33)
* file_utimes:                           Changing Status.     (line  29)
* filesystems, disk-based:               Stored Filesystems.  (line   6)
* fs.defs:                               File Interface.      (line   6)
* fsck:                                  Repairing Filesystems.
                                                              (line   6)
* fshelp.h:                              Fshelp Library.      (line   6)
* fshelp_access:                         Fshelp Permissions.  (line  19)
* fshelp_checkdirmod:                    Fshelp Permissions.  (line  26)
* fshelp_delegate_translation:           Fshelp Misc.         (line  10)
* fshelp_drop_transbox:                  Active Translator Linkage.
                                                              (line  73)
* fshelp_exec_reauth:                    Fshelp Misc.         (line  21)
* fshelp_fetch_control:                  Active Translator Linkage.
                                                              (line  68)
* fshelp_fetch_root:                     Active Translator Linkage.
                                                              (line  47)
* fshelp_fetch_root_callback1_t:         Active Translator Linkage.
                                                              (line  24)
* fshelp_fetch_root_callback2_t:         Active Translator Linkage.
                                                              (line  36)
* fshelp_get_identity:                   Fshelp Misc.         (line  34)
* fshelp_isowner:                        Fshelp Permissions.  (line  13)
* fshelp_open_fn_t:                      Passive Translator Linkage.
                                                              (line  12)
* fshelp_return_malloced_buffer:         Fshelp Misc.         (line  45)
* fshelp_set_active:                     Active Translator Linkage.
                                                              (line  62)
* fshelp_set_options:                    Fshelp Misc.         (line  52)
* fshelp_start_translator:               Passive Translator Linkage.
                                                              (line  35)
* fshelp_start_translator_long:          Passive Translator Linkage.
                                                              (line  23)
* fshelp_touch:                          Fshelp Misc.         (line  57)
* fshelp_transbox_init:                  Active Translator Linkage.
                                                              (line  18)
* fshelp_translated:                     Active Translator Linkage.
                                                              (line  57)
* fsys.defs:                             Filesystem Interface.
                                                              (line   6)
* FTP:                                   File Transfer Protocol.
                                                              (line   6)
* ftpconn.h:                             FTP Connection Library.
                                                              (line   6)
* GRand Unified Bootloader:              Bootloader.          (line  13)
* GRUB:                                  Bootloader.          (line  13)
* gunzip store:                          Store Classes.       (line 162)
* halt:                                  Shutdown.            (line   6)
* ihash.h:                               Integer Hash Library.
                                                              (line   6)
* ihash_add:                             Integer Hash Library.
                                                              (line  28)
* ihash_create:                          Integer Hash Library.
                                                              (line  13)
* ihash_find:                            Integer Hash Library.
                                                              (line  39)
* ihash_free:                            Integer Hash Library.
                                                              (line  17)
* ihash_iterate:                         Integer Hash Library.
                                                              (line  44)
* ihash_locp_remove:                     Integer Hash Library.
                                                              (line  54)
* ihash_remove:                          Integer Hash Library.
                                                              (line  50)
* ihash_set_cleanup:                     Integer Hash Library.
                                                              (line  21)
* ileave store:                          Store Classes.       (line 212)
* interleaving disks:                    Store Classes.       (line 212)
* io.defs:                               I/O Interface.       (line   6)
* io_async:                              Asynchronous I/O.    (line   6)
* io_clear_some_openmodes:               Open Modes.          (line   6)
* io_duplicate:                          I/O Object Ports.    (line  41)
* io_get_icky_async_id:                  Asynchronous I/O.    (line  40)
* io_get_openmodes:                      Open Modes.          (line   6)
* io_get_owner:                          Asynchronous I/O.    (line  40)
* io_map:                                Mapped Data.         (line   6)
* io_mod_owner:                          Asynchronous I/O.    (line  40)
* io_read:                               Simple Operations.   (line  18)
* io_readable:                           Simple Operations.   (line  44)
* io_reauthenticate:                     I/O Object Ports.    (line  49)
* io_restrict_auth:                      I/O Object Ports.    (line  44)
* io_seek:                               Simple Operations.   (line  39)
* io_select:                             Asynchronous I/O.    (line  30)
* io_server_version:                     Information Queries. (line  48)
* io_set_all_openmodes:                  Open Modes.          (line   6)
* io_set_some_openmodes:                 Open Modes.          (line   6)
* io_stat:                               Information Queries. (line   6)
* io_write:                              Simple Operations.   (line   6)
* iohelp.h:                              Iohelp Library.      (line   6)
* iohelp_create_iouser:                  I/O Users.           (line  12)
* iohelp_dup_iouser:                     I/O Users.           (line  15)
* iohelp_fetch_shared_data:              Conch Management.    (line   6)
* iohelp_free_iouser:                    I/O Users.           (line  18)
* iohelp_get_conch:                      Conch Management.    (line   6)
* iohelp_handle_io_get_conch:            Conch Management.    (line   6)
* iohelp_handle_io_release_conch:        Conch Management.    (line   6)
* iohelp_initialize_conch:               Conch Management.    (line   6)
* iohelp_put_shared_data:                Conch Management.    (line   6)
* iohelp_reauth:                         I/O Users.           (line  27)
* iohelp_verify_user_conch:              Conch Management.    (line   6)
* isofs:                                 ISO-9660 CD-ROM FS.  (line   6)
* libdiskfs:                             Diskfs Library.      (line   6)
* libfshelp:                             Fshelp Library.      (line   6)
* libftpconn:                            FTP Connection Library.
                                                              (line   6)
* libhurdbugaddr:                        Bug Address Library. (line   6)
* libihash:                              Integer Hash Library.
                                                              (line   6)
* libiohelp:                             Iohelp Library.      (line   6)
* libmom:                                Microkernel Object Library.
                                                              (line   6)
* libpager:                              Pager Library.       (line   6)
* libports:                              Ports Library.       (line   6)
* libshouldbeinlibc:                     Misc Library.        (line   6)
* libstore:                              Store Library.       (line   6)
* libstorefs:                            Diskfs Library.      (line  14)
* libthreads:                            Threads Library.     (line   6)
* libtrivfs:                             Trivfs Library.      (line   6)
* linear concatenation:                  Store Classes.       (line 184)
* Microkernel Object Model:              Microkernel Object Library.
                                                              (line  14)
* MOM:                                   Microkernel Object Library.
                                                              (line  14)
* mom.h:                                 Microkernel Object Library.
                                                              (line   6)
* mvol store:                            Store Classes.       (line 240)
* NFS:                                   Network File System. (line   6)
* pager.h:                               Pager Library.       (line   6)
* pager_change_attributes:               Pager Management.    (line  80)
* pager_clear_user_data:                 Pager Callbacks.     (line  33)
* pager_create:                          Pager Management.    (line  17)
* pager_demuxer:                         Pager Management.    (line  34)
* pager_dropweak:                        Pager Callbacks.     (line  37)
* pager_flush:                           Pager Management.    (line  49)
* pager_flush_some:                      Pager Management.    (line  51)
* pager_get_error:                       Pager Management.    (line  92)
* pager_get_port:                        Pager Management.    (line 115)
* pager_get_upi:                         Pager Management.    (line 112)
* pager_memcpy:                          Pager Management.    (line  98)
* pager_offer_page:                      Pager Management.    (line  72)
* pager_read_page:                       Pager Callbacks.     (line  12)
* pager_report_extent:                   Pager Callbacks.     (line  29)
* pager_return:                          Pager Management.    (line  60)
* pager_return_some:                     Pager Management.    (line  62)
* pager_shutdown:                        Pager Management.    (line  86)
* pager_sync:                            Pager Management.    (line  40)
* pager_sync_some:                       Pager Management.    (line  42)
* pager_unlock_page:                     Pager Callbacks.     (line  25)
* pager_write_page:                      Pager Callbacks.     (line  19)
* ports.h:                               Ports Library.       (line   6)
* ports_begin_rpc:                       RPC Management.      (line  16)
* ports_bucket_iterate:                  Port Metadata.       (line  26)
* ports_claim_right:                     Port Rights.         (line  22)
* ports_count_bucket:                    Port References.     (line  27)
* ports_count_class:                     Port References.     (line  23)
* ports_create_bucket:                   Buckets and Classes. (line  10)
* ports_create_class:                    Buckets and Classes. (line  20)
* ports_create_port:                     Buckets and Classes. (line  33)
* ports_create_port_noinstall:           Buckets and Classes. (line  40)
* ports_dead_name:                       RPC Management.      (line 105)
* ports_demuxer_type:                    RPC Management.      (line  12)
* ports_destroy_right:                   Port Rights.         (line  17)
* ports_enable_bucket:                   Port References.     (line  35)
* ports_enable_class:                    Port References.     (line  31)
* ports_end_rpc:                         RPC Management.      (line  21)
* ports_get_right:                       Port Rights.         (line  35)
* ports_import_port:                     Buckets and Classes. (line  49)
* ports_inhibit_all_rpcs:                RPC Management.      (line  59)
* ports_inhibit_bucket_rpcs:             RPC Management.      (line  55)
* ports_inhibit_class_rpcs:              RPC Management.      (line  50)
* ports_inhibit_port_rpcs:               RPC Management.      (line  46)
* ports_interrupt_notified_rpcs:         RPC Management.      (line 102)
* ports_interrupt_rpc_on_notification:   RPC Management.      (line  85)
* ports_interrupt_rpcs:                  RPC Management.      (line  77)
* ports_interrupt_self_on_notification:  RPC Management.      (line  91)
* ports_interrupt_self_on_port_death:    RPC Management.      (line  97)
* ports_lookup_port:                     Port Metadata.       (line  18)
* ports_manage_port_operations_multithread: RPC Management.   (line  35)
* ports_manage_port_operations_one_thread: RPC Management.    (line  27)
* ports_no_senders:                      Port References.     (line  18)
* ports_port_deref:                      Port References.     (line  14)
* ports_port_deref_weak:                 Port References.     (line  45)
* ports_port_ref:                        Port References.     (line  11)
* ports_port_ref_weak:                   Port References.     (line  42)
* ports_reallocate_from_external:        Port Rights.         (line  13)
* ports_reallocate_port:                 Port Rights.         (line   9)
* ports_resume_all_rpcs:                 RPC Management.      (line  74)
* ports_resume_bucket_rpcs:              RPC Management.      (line  70)
* ports_resume_class_rpcs:               RPC Management.      (line  66)
* ports_resume_port_rpcs:                RPC Management.      (line  62)
* ports_self_interrupted:                RPC Management.      (line  80)
* ports_transfer_right:                  Port Rights.         (line  29)
* query store:                           Store Classes.       (line  25)
* RAID-0:                                Store Classes.       (line 212)
* reboot:                                Shutdown.            (line   6)
* remap store:                           Store Classes.       (line 265)
* serverboot:                            Server Bootstrap.    (line   6)
* servers.boot:                          Boot Scripts.        (line   6)
* settrans:                              Invoking settrans.   (line   6)
* socket.defs:                           Socket Interface.    (line   6)
* store.h:                               Store Library.       (line   6)
* store_allocate_child_encodings:        Store RPC Encoding.  (line  64)
* store_argp:                            Store Arguments.     (line  22)
* store_argp_params:                     Store Arguments.     (line  15)
* store_buffer_create:                   Store Classes.       (line 155)
* store_children_name:                   Store Management.    (line  54)
* store_clear_child_flags:               Store Management.    (line  77)
* store_clear_flags:                     Store Management.    (line  68)
* store_clone:                           Store Management.    (line  87)
* store_close_source:                    Store Management.    (line  30)
* store_concat_class:                    Store Classes.       (line 185)
* store_concat_class_vectors:            Store Classes.       (line  19)
* store_concat_create:                   Store Classes.       (line 204)
* store_concat_open:                     Store Classes.       (line 198)
* store_copy_class:                      Store Classes.       (line 134)
* store_copy_create:                     Store Classes.       (line 150)
* store_copy_open:                       Store Classes.       (line 142)
* store_create:                          Store Management.    (line  11)
* store_decode:                          Store RPC Encoding.  (line  56)
* store_decode_children:                 Store RPC Encoding.  (line  77)
* store_device_class:                    Store Classes.       (line  73)
* store_device_create:                   Store Classes.       (line  82)
* store_device_open:                     Store Classes.       (line  77)
* store_enc:                             Store RPC Encoding.  (line  10)
* store_enc_dealloc:                     Store RPC Encoding.  (line  25)
* store_enc_init:                        Store RPC Encoding.  (line  20)
* store_enc_return:                      Store RPC Encoding.  (line  33)
* store_encode:                          Store RPC Encoding.  (line  47)
* store_encode_children:                 Store RPC Encoding.  (line  70)
* store_file_class:                      Store Classes.       (line  89)
* store_file_create:                     Store Classes.       (line  97)
* store_file_open:                       Store Classes.       (line  93)
* store_free:                            Store Management.    (line  34)
* store_gunzip_class:                    Store Classes.       (line 163)
* store_gunzip_create:                   Store Classes.       (line 177)
* store_gunzip_open:                     Store Classes.       (line 169)
* store_ileave_class:                    Store Classes.       (line 213)
* store_ileave_create:                   Store Classes.       (line 230)
* store_is_securely_returnable:          Store Management.    (line  82)
* store_map:                             Store I/O.           (line  11)
* store_mvol_class:                      Store Classes.       (line 241)
* store_mvol_create:                     Store Classes.       (line 256)
* store_open:                            Store Classes.       (line  32)
* store_open_children:                   Store Classes.       (line  59)
* store_parsed:                          Store Arguments.     (line   9)
* store_parsed_append_args:              Store Arguments.     (line  37)
* store_parsed_free:                     Store Arguments.     (line  27)
* store_parsed_name:                     Store Arguments.     (line  41)
* store_parsed_open:                     Store Arguments.     (line  32)
* store_query_class:                     Store Classes.       (line  26)
* store_read:                            Store I/O.           (line  15)
* store_remap:                           Store Management.    (line  92)
* store_remap_class:                     Store Classes.       (line 266)
* store_remap_create:                    Store Classes.       (line 272)
* store_return:                          Store RPC Encoding.  (line  42)
* store_run:                             Store Management.    (line  37)
* store_set_child_flags:                 Store Management.    (line  72)
* store_set_children:                    Store Management.    (line  48)
* store_set_flags:                       Store Management.    (line  65)
* store_set_name:                        Store Management.    (line  62)
* store_set_runs:                        Store Management.    (line  44)
* store_std_classes:                     Store Classes.       (line  10)
* store_std_leaf_allocate_encoding:      Store RPC Encoding.  (line  88)
* store_std_leaf_create_t:               Store RPC Encoding.  (line  97)
* store_std_leaf_decode:                 Store RPC Encoding.  (line 101)
* store_std_leaf_encode:                 Store RPC Encoding.  (line  90)
* store_task_class:                      Store Classes.       (line 106)
* store_task_create:                     Store Classes.       (line 115)
* store_task_open:                       Store Classes.       (line 110)
* store_typed_open:                      Store Classes.       (line  50)
* store_typed_open_class:                Store Classes.       (line  43)
* store_with_decoded_runs:               Store RPC Encoding.  (line  83)
* store_write:                           Store I/O.           (line  22)
* store_zero_class:                      Store Classes.       (line 122)
* store_zero_create:                     Store Classes.       (line 128)
* striping, disk:                        Store Classes.       (line 212)
* task store:                            Store Classes.       (line 105)
* trivfs.h:                              Trivfs Library.      (line   6)
* trivfs_add_control_port_class:         Trivfs Ports.        (line  20)
* trivfs_add_port_bucket:                Trivfs Ports.        (line  10)
* trivfs_add_protid_port_class:          Trivfs Ports.        (line  22)
* trivfs_allow_open:                     Trivfs Callbacks.    (line  17)
* trivfs_append_args:                    Trivfs Startup.      (line  30)
* trivfs_begin_using_control:            Trivfs Startup.      (line  84)
* trivfs_begin_using_protid:             Trivfs Startup.      (line  86)
* trivfs_check_open_hook:                Trivfs Options.      (line  22)
* trivfs_clean_cntl:                     Trivfs Ports.        (line  38)
* trivfs_clean_protid:                   Trivfs Ports.        (line  39)
* trivfs_cntl_nportclasses:              Trivfs Options.      (line  14)
* trivfs_cntl_portclasses:               Trivfs Options.      (line  13)
* trivfs_create_control:                 Trivfs Startup.      (line  51)
* trivfs_demuxer:                        Trivfs Startup.      (line  76)
* trivfs_end_using_control:              Trivfs Startup.      (line  91)
* trivfs_end_using_protid:               Trivfs Startup.      (line  92)
* trivfs_fsid:                           Trivfs Callbacks.    (line  12)
* trivfs_fstype:                         Trivfs Callbacks.    (line  11)
* trivfs_getroot_hook:                   Trivfs Options.      (line  49)
* trivfs_goaway:                         Trivfs Callbacks.    (line  36)
* trivfs_modify_stat:                    Trivfs Callbacks.    (line  30)
* trivfs_open:                           Trivfs Startup.      (line  98)
* trivfs_peropen_create_hook:            Trivfs Options.      (line  33)
* trivfs_peropen_destroy_hook:           Trivfs Options.      (line  40)
* trivfs_protid_create_hook:             Trivfs Options.      (line  31)
* trivfs_protid_destroy_hook:            Trivfs Options.      (line  38)
* trivfs_protid_dup:                     Trivfs Startup.      (line 105)
* trivfs_protid_nportclasses:            Trivfs Options.      (line  12)
* trivfs_protid_portclasses:             Trivfs Options.      (line  11)
* trivfs_remove_control_port_class:      Trivfs Ports.        (line  28)
* trivfs_remove_port_bucket:             Trivfs Ports.        (line  15)
* trivfs_remove_protid_port_class:       Trivfs Ports.        (line  30)
* trivfs_runtime_argp:                   Trivfs Startup.      (line  17)
* trivfs_set_atime:                      Trivfs Startup.      (line 111)
* trivfs_set_mtime:                      Trivfs Startup.      (line 112)
* trivfs_set_options:                    Trivfs Startup.      (line  24)
* trivfs_startup:                        Trivfs Startup.      (line  45)
* trivfs_support_exec:                   Trivfs Callbacks.    (line  23)
* trivfs_support_read:                   Trivfs Callbacks.    (line  21)
* trivfs_support_write:                  Trivfs Callbacks.    (line  22)
* typed_open store:                      Store Classes.       (line  42)
* ufs:                                   BSD Unix FS.         (line   6)
* XP (external pager):                   Pager Library.       (line   6)
* zero store:                            Store Classes.       (line 121)



Tag Table:
Node: Top886
Node: Introduction8774
Ref: Introduction-Footnote-19553
Node: Audience9689
Ref: Audience-Footnote-111711
Node: Features11844
Node: Overview14034
Node: History14206
Node: Copying16497
Node: Installing35641
Node: Binary Distributions36556
Node: Cross-Compiling38717
Node: Bootstrap39987
Ref: Bootstrap-Footnote-140458
Node: Bootloader40695
Ref: Bootloader-Footnote-141707
Node: Server Bootstrap41789
Node: Invoking serverboot42661
Node: Boot Scripts43963
Node: Invoking boot44133
Node: Shutdown47000
Node: Foundations47122
Node: Threads Library48620
Node: Microkernel Object Library49390
Node: Ports Library50415
Node: Buckets and Classes51706
Node: Port Rights54142
Node: Port Metadata55720
Node: Port References56921
Node: RPC Management58615
Ref: RPC Management-Footnote-163376
Node: Integer Hash Library63455
Node: Misc Library66066
Node: Bug Address Library66938
Node: Input and Output67421
Node: Iohelp Library68019
Node: I/O Users68543
Node: Conch Management69915
Node: Pager Library70403
Node: Pager Management71277
Ref: Pager Management-Footnote-176919
Ref: Pager Management-Footnote-276937
Node: Pager Callbacks77053
Node: I/O Interface78924
Ref: I/O Interface-Footnote-179733
Node: I/O Object Ports79952
Node: Simple Operations83412
Node: Open Modes86016
Node: Asynchronous I/O87828
Node: Information Queries90624
Node: Mapped Data92827
Node: Files93454
Node: Translators94363
Ref: Translators-Footnote-197044
Node: Invoking settrans97129
Node: Invoking showtrans100220
Node: Invoking mount100391
Node: Invoking fsysopts100554
Node: Trivfs Library100696
Node: Trivfs Startup101443
Node: Trivfs Callbacks107047
Node: Trivfs Options108769
Node: Trivfs Ports111442
Node: Fshelp Library113263
Node: Passive Translator Linkage114031
Node: Active Translator Linkage115877
Node: Fshelp Locking119553
Node: Fshelp Permissions119872
Node: Fshelp Misc121197
Node: File Interface124274
Node: File Overview125066
Node: Changing Status126929
Node: Program Execution128901
Node: File Locking130991
Node: File Frobbing131411
Node: Opening Files131847
Node: Modifying Directories132080
Node: Notifications132388
Node: File Translators132732
Node: Filesystem Interface132991
Node: Special Files133248
Node: Stores134284
Node: Store Library134901
Node: Store Arguments135571
Node: Store Management137325
Node: Store I/O141638
Node: Store Classes142634
Ref: Store Classes-Footnote-1154917
Ref: Store Classes-Footnote-2155262
Node: Store RPC Encoding155451
Node: Stored Filesystems160224
Node: Repairing Filesystems161188
Node: Linux Extended 2 FS161363
Node: BSD Unix FS161552
Node: ISO-9660 CD-ROM FS161722
Node: Diskfs Library161901
Node: Diskfs Startup163694
Node: Diskfs Arguments166349
Node: Diskfs Globals168841
Node: Diskfs Node Management172968
Node: Diskfs Callbacks179535
Node: Diskfs Options197369
Node: Diskfs Internals204558
Node: Twisted Filesystems207430
Ref: Twisted Filesystems-Footnote-1208409
Node: Distributed Filesystems208487
Node: File Transfer Protocol209257
Node: FTP Connection Library209592
Node: Network File System209750
Node: Networking209975
Node: Socket Interface210304
Node: Terminal Handling210468
Node: Running Programs210680
Node: Authentication210953
Node: Auth Interface211346
Node: Auth Protocol211540
Node: Index211663

End Tag Table
