Info file: gnus-ja.info,    -*-Text-*-
produced by `texinfo-format-buffer'
from file `gnus-ja.texi'
using `texinfmt.el' version 2.41 of  1 Mar 2005.

Copyright (C) 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003,
2004, 2005, 2006 Free Software Foundation, Inc.

     Permission is granted to copy, distribute and/or modify this
     document under the terms of the GNU Free Documentation License,
     Version 1.2 or any later version published by the Free Software
     Foundation; with no Invariant Sections, with the Front-Cover
     texts being "A GNU Manual", and with the Back-Cover Texts as in
     (a) below.  A copy of the license is included in the section
     entitled "GNU Free Documentation License" in the Emacs manual.

     この文書を、フリーソフトウェア財団発行の GNU フリー文書利用許諾契
     約書第 1.2 版またはそれ以降の版が定める条件の下で複製、配布、ある
     いは変更することを許可します。変更不可部分は指定しません。“A GNU
     Manual”は表表紙テキスト、以下の (a) は裏表紙テキストです。この利
     用許諾契約書の複写は“Emacs manual”の「GNU フリー文書利用許諾契約
     書」という章に含まれています。

     (a) The FSF's Back-Cover Text is: "You have freedom to copy and
     modify this GNU Manual, like GNU software.  Copies published by
     the Free Software Foundation raise funds for GNU development."

     (a) FSF の裏表紙テキスト:「あなたにはこの GNU Manual を GNU ソフト
     ウェアのように複製したり変更する自由があります。複製はフリーソフト
     ウェア財団によって出版されました。(フリーソフトウェア財団は) GNU
     の開発のために必要な資金を集めています。」

     This document is part of a collection distributed under the GNU
     Free Documentation License.  If you want to distribute this
     document separately from the collection, you can do so by adding
     a copy of the license to the document, as described in section 6
     of the license.

     この文書は「GNU フリー文書利用許諾契約書」に基づいて配布された収集
     著作物の一部です。もしあなたがこの文書を収集著作物から分離して配布
     したいときは、契約書の第 6 章に記述されているように、文書に契約書
     の複写を付加することによって、行なうことができます。



INFO-DIR-SECTION Emacs
START-INFO-DIR-ENTRY
* Gnus-ja: (gnus-ja).           The newsreader Gnus (Japanese).
END-INFO-DIR-ENTRY





File: gnus-ja.info, Node: Score File Editing, Next: Adaptive Scoring, Prev: Score File Format, Up: Scoring

スコアファイルの編集
====================

普通はすべてのスコア命令を概略バッファーから発行しますが、手でそれらを
編集したくなることもあるかもしれないので、それのためのモードを用意して
います。

それは以下に列挙する命令を使えるように、少しカスタマイズしただけの
`emacs-lisp' モードです:

`C-c C-c'
     あなたが行なった変更を保存して概略バッファーに戻ります
     (`gnus-score-edit-done')。

`C-c C-d'
     現在の日付を数値の様式で挿入します
     (`gnus-score-edit-insert-date')。これはどのようなものだろうと考え
     ているのなら、これは本当に日の数値です。

`C-c C-p'
     適応スコアファイルは整形されずに保存されます。もしこれらのファイル
     の一つを読むつもりなら、まず "pretty print" (整形して印字) したい
     でしょう。この命令 (`gnus-score-pretty-print') がそれを行ないます。

このモードを使うには `M-x gnus-score-mode' とタイプして下さい。

`gnus-score-menu-hook' がスコアモードのバッファーで実行されます。

概略バッファーでは、`V f'、`V e' および `V t' のような命令でスコアファ
イルの編集を始めることができます。



File: gnus-ja.info, Node: Adaptive Scoring, Next: Home Score File, Prev: Score File Editing, Up: Scoring

適応スコア付け
==============

これらのスコア付けはあなたを憂鬱にさせてしまうかもしれないので、Gnus に
はこれらをすべて自動的に--まるで魔法でも使ったように作成する方法があり
ます。いやむしろ、人工無能によって、という方が正確かな。

記事を読んだとき、記事に既読の印を付けたとき、あるいは記事を削除したと
きに、その印を残しておいて下さい。グループから出るときに、Gnus はそれら
の印の辺りを嗅ぎ回り、何の印を見つけたかに応じてスコア要素を追加します。
この機能は `gnus-use-adaptive-scoring' を `t' か `(line)' に設定すると
有効になります。もしスコアを、表題に現れる個別の単語をもとに適応させた
ければ、この変数を `(word)' に設定して下さい。両方の適応方法を使いたけ
れば、この変数を `(word line)' に設定して下さい。

スコア付けの処理を完全に制御するために
`gnus-default-adaptive-score-alist' 変数をカスタマイズして下さい。例え
ば、こんな感じになるでしょう:

     (setq gnus-default-adaptive-score-alist
           '((gnus-unread-mark)
             (gnus-ticked-mark (from 4))
             (gnus-dormant-mark (from 5))
             (gnus-del-mark (from -4) (subject -1))
             (gnus-read-mark (from 4) (subject 2))
             (gnus-expirable-mark (from -1) (subject -1))
             (gnus-killed-mark (from -1) (subject -3))
             (gnus-kill-file-mark)
             (gnus-ancient-mark)
             (gnus-low-score-mark)
             (gnus-catchup-mark (from -1) (subject -1))))

ご覧のように、この連想リストの各要素は、キーとして印 (変数名か「実際の」
印すなわち文字のいずれか) を持ちます。このキーの後には任意の数のヘッダー
/スコアの組が続きます。もしそのキーの後にヘッダー/スコアの組が一つもな
ければ、そのキーが記事の印として付いている記事に対しては適応型スコア付
けは行なわれません。例えば上記の例では、`gnus-unread-mark' が付いている
記事は、適応型スコア付けのエントリーを持ちません。

各記事は一つしか印を持ち得ないので、それぞれの記事にはこれらの規則のう
ちの一つだけが適用されます。

`gnus-del-mark' を例に取りましょう--この連想リストでの意味は、この印
(すなわち `e' の印) が付いている記事はすべて、`From' ヘッダーをもと
に -4 下げられ `Subject' で -1 下げられるスコア・エントリーが追加されま
す。これをあなたの偏見に合わせて変更して下さい。

もし 10 個の記事に同じ subject で `gnus-del-mark' の印が付いていたとす
ると、この印に対する規則は十回適用されます。それはつまり、その subject
は -1 の十倍のスコアを得ます。その値は、私が大きく誤解していないかぎ
り -10 のはずです。

もし自動期限切れ消去 (メール) グループ (*Note Expiring Mail::) があれば、
既読記事にはすべて `E' 印が付けられます。これはおそらく適応型スコア付け
をちょっとばかりやりにくくするので、自動期限切れ消去と適応型スコア付け
は、一緒には現実にあまりうまくやっていけません。

スコアを付けられるヘッダーには `from', `subject', `message-id',
`references', `xref', `lines', `chars' および `date' があります。さらに
`followup' にもスコア付けができて、これは現在の記事の `Message-ID' を使っ
て `References' ヘッダーに合致、すなわちこれに続くスレッドに合致する適
応型スコア・エントリーを作成します。

この機構を使うならば、ときどき記事を既読にしてしまう小さな変更を避ける
ために、スコアファイルの `mark' アトムを何か小さい値--ひょっとする
と -300 くらいに設定しておくべきです。

適応型スコア付けを一週間かそこら使ってくると、Gnus はそれ相応に調教され、
あなたが何も言わなくても、あなたの好きな投稿者を強調し、あまり好きでは
ない投稿者を消去するようになるはずです。

どのグループにおいて適応型スコア付けを作動させるかは、スコアファイル
(*Note Score File Format::) を使うことによって制御できます。またこれを
使って、違ったグループに対して違った規則を使うようにもできます。

適応型スコア・エントリーは、グループ名に `gnus-adaptive-file-suffix' を
付加した名前のファイルに入れられます。ディフォルトは `ADAPT' です。

適応型スコアファイルは巨大になり得るので、人の手で編集されることは想定
されていません。`gnus-adaptive-pretty-print' が `nil' (ディフォルト) で
あると、それらのファイルは人に読めるような形式では書かれません。

適応型スコア付けを行なうときは、部分文字列一致やファジーな一致を行なっ
た方が、おそらくほとんどの場合において良い結果が得られるでしょう。しか
し、ヘッダーの一致する部分が短い場合、意図に反する動作をする可能性が大
きいので、`gnus-score-exact-adapt-limit' より短い長さしか一致しない場合
は完全一致が行なわれます。この変数が `nil' であれば、この問題が起こらな
いように常に完全一致が行なわれます。

上で述べたように、個別の単語ででもヘッダー全体ででも適応を行なうことが
できます。単語で適応を行なう場合には、それぞれの単語の事例が、ある印に
どんなスコアを加えるかを、`gnus-default-adaptive-word-score-alist' 変数
によって指定します。

     (setq gnus-default-adaptive-word-score-alist
           `((,gnus-read-mark . 30)
             (,gnus-catchup-mark . -10)
             (,gnus-killed-mark . -20)
             (,gnus-del-mark . -15)))

これがディフォルト値です。単語での適応を有効にすると、`gnus-read-mark'
の印が付いている記事の表題に現れるすべての単語が、スコアに 30 点追加す
るというスコア規則を生み出します。

`gnus-default-ignored-adaptive-words' のリストに現れる単語は無視されま
す。無視したい単語を追加したいときは、この変数ではなく
`gnus-ignored-adaptive-words' リストの方を使って下さい。

短い単語では適応型スコア付けを作動させるべきではないと思う人もいるでしょ
う。もしそうなら `gnus-adaptive-word-length-limit' に整数を設定すること
ができ、この数値より短い単語は無視されます。この変数のディフォルトは
`nil' です。

スコア付けが行なわれるとき、`gnus-adaptive-word-syntax-table' が実際に
使われるシンタックステーブルです。これは標準シンタックステーブルと似て
いますが、数字を単語の構成要素ではない文字だと認識します。

もし `gnus-adaptive-word-minimum' に数値が設定されていると、単語適応型
スコア付け処理において、記事のスコアがこの数値よりも小さくなることはあ
りません。ディフォルトは `nil' です。

`gnus-acaptive-word-no-group-words' が `t' に設定されていると、Gnus は
グループ名のすべての語について、単語適応型スコア付けをしません。ほとん
どの表題が `emacs' という語を含んでいる `comp.editors.emacs' のようなグ
ループで便利です。

この機構をしばらく使ってみた後で、規則を解析することによってあなたがど
んな単語が好きでどんな単語が嫌いかを診断する `gnus-psychoanalyze-user'
(利用者精神分析命令) を書いてみると良いかもしれません。いや、良くないか
な。

単語適応型スコア付けは高度に実験的なものなので、将来変更されるであろう
ことは心に留めておいて下さい。第一印象では、これは現状ではまったく使い
物にならないように思えます。これをもっと使えるようにするためには、(より
厳密な統計的手法を巻き込んで) さらなる作業が行なわれる必要があるでしょ
う。



File: gnus-ja.info, Node: Home Score File, Next: Followups To Yourself, Prev: Adaptive Scoring, Up: Scoring

ホームスコアファイル
====================

新しいスコアファイルエントリーが入れられるスコアファイルは、ホームスコ
アファイル "home score file" と呼ばれます。これは通常 (ディフォルトで)
そのグループ自身のためのスコアファイルになります。例えば
`gnu.emacs.gnus' 用のホームスコアファイルは `gnu.emacs.gnus.SCORE' です。

しかしながら、これはあなたのお望みではないかもしれません。たくさんのグ
ループの間で共通のホームスコアファイルを共有することはしばしば便利で
す--例えばすべての `emacs' グループが、ことによると同じホームスコアファ
イルを使うことができます。

これを制御する変数が `gnus-home-score-file' です。これは以下の値を取り
得ます:

  1. 文字列。この場合、このファイルがすべてのグループでホームスコアファ
     イルとして使用されます。

  2. 関数。この関数の結果がホームスコアファイルとして使用されます。この
     関数はグループの名前を引数として呼び出されます。

  3. リスト。このリストの要素は以下の値を取り得ます:

       1. `(REGEXP FILE-NAME)'。REGEXP がグループ名に合致すると、
          FILE-NAME がホームスコアファイルとして使用されます。

       2. 関数。この関数が `nil' 以外を返せば、その戻り値がホームスコア
          ファイルとして使用されます。グループ名が引数として関数に渡さ
          れます。

       3. 文字列。この文字列をホームスコアファイルとして使用します。

     このリストは、合致するものを探すために先頭から終りに向かってなぞら
     れます。

というわけで、単一のスコアファイルだけを使いたい場合は、以下のようにす
れば良いでしょう:

     (setq gnus-home-score-file
           "my-total-score-file.SCORE")

すべての `gnu' グループに対して `gnu.SCORE' を、すべての `rec' グループ
に対して `rec.SCORE' (等々) を使いたい場合は、このように設定することが
できます:

     (setq gnus-home-score-file
           'gnus-hierarchial-home-score-file)

これは利用者の便宜のために、あらかじめ提供されている関数です。他に以下
の関数があります:

`gnus-current-home-score-file'
     「現在の」標準スコアファイルを返します。これはスコア命令群に「最深」
     の合致するスコアファイルにエントリーを加えさせます。

`emacs' グループ用に一つのスコアファイルを、それとは別のものを `comp'
グループ用に用意する一方、他のすべてのグループではそれぞれ独自のスコア
ファイルを使うようにしたいなら、こんな設定で良いでしょう:

     (setq gnus-home-score-file
           ;; 正規表現 `"\\.emacs"' に合致するすべてのグループ
           '(("\\.emacs" "emacs.SCORE")
             ;; すべての comp グループを単一のスコアファイルで
             ("^comp" "comp.SCORE")))

`gnus-home-adapt-file' は `gnus-home-score-file' とまったく同じやり方で
動作しますが、代わりにこれで、何をホーム適応スコアファイルにするかを指
定します。すべての新しい適応ファイルエントリーは、この変数で指定される
ファイルに入れられ、同じ文法を使うことができます。

`gnus-home-score-file' と `gnus-home-adapt-file' を使うことに加えて、グ
ループパラメーター (*Note Group Parameters::) とトピックパラメーター
(*Note Topic Parameters::) を使っても、ほぼ同様のことを成し遂げることが
できます。グループ、トピックパラメーターはこの変数よりも優先されます。



File: gnus-ja.info, Node: Followups To Yourself, Next: Scoring On Other Headers, Prev: Home Score File, Up: Scoring

自分自身へのフォローアップ
==========================

Gnus は現在のバッファーから `Message-ID' ヘッダーを見つけ出すための二つ
の命令を提供します。そして Gnus は、他の記事の `References' ヘッダーに
あるこの `Message-ID' を使ってスコアを付けるためのスコア規則を追加しま
す。これは事実上、現在のバッファーにある記事に返答したすべての記事のス
コアを増加させます。これは、あなたが言ったことに人々が答えたら、それに
容易に気付かせてもらいたいときに、とても便利です。

`gnus-score-followup-article'
     これは、あなた自身の記事に直接フォローアップした記事にスコアを加え
     ます。

`gnus-score-followup-thread'
     これは、あなたの記事より「下」のスレッドに現れるすべての記事にスコ
     アを加えます。

これら二つの関数は、本来どちらも `message-sent-hook' のようなフックの中
で、例えばこのように使うためのものです:

     (add-hook 'message-sent-hook 'gnus-score-followup-thread)

自分の `Message-ID' をじっくりと眺めてみると、はじめの二〜三文字は常に
同じであることに気が付くでしょう。以下の二つは私のものです:

     <x6u3u47icf.fsf@eyesore.no>
     <x6sp9o7ibw.fsf@eyesore.no>

したがって、このマシンでは `x6' で「私」かどうかを見分けることができま
す。これは使えます--以下の規則は、私自身へのすべてのフォローアップのス
コアを上げるでしょう:

     ("references"
      ("<x6[0-9a-z]+\\.fsf\\(_-_\\)?@.*eyesore\\.no>"
       1000 nil r))

「あなたの」が最初の二文字になるか最初の三文字になるかは、システムに依
存します。



File: gnus-ja.info, Node: Scoring On Other Headers, Next: Scoring Tips, Prev: Followups To Yourself, Up: Scoring

他のヘッダーにスコアを付ける
============================

Gnus が「伝統的」なヘッダー ---`From', `Subject' など--にスコアを付ける
のはとても速いです。ですが、他のヘッダーにスコアを付けるには `head' の
スコアのための規則を書く必要があり、それは合致を探すために Gnus が毎回
バックエンドから単独の記事を取り寄せなければならないことを意味します。
これは大きなグループでは長い時間がかかります。

さて、これに関してニュースグループのためにできることは多くはありません
が、メールグループのためにはより優れた手段があります。*Note To From
Newsgroups:: の章でこの機構がどう働くかが詳しく説明されていますが、ここ
ではどうしたら `nnml' で `To' と `Cc' ヘッダーにスコアを付けることがで
きるかの調理の例を挙げましょう。

以下を `~/.gnus.el' ファイルに置いて下さい。

     (setq gnus-extra-headers '(To Cc Newsgroups Keywords)
           nnmail-extra-headers gnus-extra-headers)

Gnus を再起動して、`M-x nnml-generate-nov-databases' コマンドで `nnml'
の overview ファイルを作り直して下さい。たくさんのメールを持っていると、
これには長い時間がかかるでしょう。

そして `I e s p To RET <your name> RET' のようにすると、`To' と `Cc' ヘッ
ダーに“extra headers”としてスコアを付けることができます。

わかったかな? 簡単だよね。



File: gnus-ja.info, Node: Scoring Tips, Next: Reverse Scoring, Prev: Scoring On Other Headers, Up: Scoring

スコア付けの奥義
================

"クロスポスト"
     クロスポストのスコアを低くしたければ、合致させるべき行は `Xref' ヘッ
     ダーです。

          ("xref" (" talk.politics.misc:" -1000))

"複数のクロスポスト"
     ある数、例えば三つ以上のグループにクロスポストされている記事のスコ
     アを低くしたければ、

          ("xref"
            ("[^:\n]+:[0-9]+ +[^:\n]+:[0-9]+ +[^:\n]+:[0-9]+"
             -1000 nil r))

"本文への合致"
     これは一般的にはあまり良い考えではありません--とても長い時間がかか
     るからです。実際 Gnus は、それぞれの記事を個別にサーバーから取得し
     てこなければならないのです。でも、とにかくあなたはやりたいのでしょ
     うね。合致させるキーは三つ (`Head', `Body', `All') あるのですが、
     それぞれのスコアファイルで一つを選んで、それに固執すべきです。もし
     二つを使うと、それぞれの記事は *二回* 取得されてしまいます。もし
     `Head' でちょっとだけ、`Body' でもちょっとだけ合致させたい、という
     のであれば、素直に `All' を使って全部合致させて下さい。

"既読として印を付ける"
     ある一定の値より低いスコアを持つ記事には、おそらく既読の印を付けて
     しまいたくなるでしょう。これは `all.SCORE' ファイルに以下のものを
     入れておくことによって、最も簡単に実現できます。

          ((mark -100))

     同様のことを `expunge' で行なうことを考えても良いでしょう。

"否定文字クラス"
     もし `[^abcd]*' みたいなものを指定すると、期待外れの結果で終わるか
     もしれません。これは改行文字にも合致してしまうので、えーと、未知の
     ものまで引きずり出してしまうもしれません。代わりに `[^abcd\n]*' を
     使いましょう。



File: gnus-ja.info, Node: Reverse Scoring, Next: Global Score Files, Prev: Scoring Tips, Up: Scoring

逆スコア
========

もし、表題ヘッダーに `Sex with Emacs' という文字がある記事だけを残して、
その他の記事すべてを消去してしまいたければ、スコアファイルに以下のよう
なものを入れることができます:

     (("subject"
       ("Sex with Emacs" 2))
      (mark 1)
      (expunge 1))

これで `Sex with Emacs' に合致するすべての記事のスコアが上がって、残り
の記事には既読の印が付き、おまけにそれらは消去されるでしょう。



File: gnus-ja.info, Node: Global Score Files, Next: Kill Files, Prev: Reverse Scoring, Up: Scoring

グローバルスコアファイル
========================

間違いなく、他のニュースリーダーは「グローバル削除ファイル (global
kill file)」を持っています。それらは普通、すべてのグループに適用される、
利用者のホームディレクトリーに格納されている一つの削除ファイル以上の何
物でもありません。ふふん!  つまらない、低能なニュースリーダーだね。

私がここで話しているのはグローバルスコアファイルです。全世界の、あらゆ
る地域の利用者のスコアファイル。それはすべての国家を巨大な一つの幸せな
スコアファイル同盟に団結させる!  スコア天使!  新しい、でもテストされて
いない!

他人のスコアファイルを使うためにしなければならないのは、
`gnus-global-score-files' 変数を設定することがすべてです。それぞれのス
コアファイルにつき一つ、またはそれぞれのスコアファイルディレクトリーに
つき一つのエントリーになります。Gnus はどのスコアファイルをどのグループ
に使うのが適切であるかを自分で決定します。

例えはスコアファイル
`/ftp@ftp.gnus.org:/pub/larsi/ding/score/soc.motss.SCORE' および
`/ftp@ftp.some-where:/pub/score' ディレクトリーにあるすべてのスコアファ
イルを使いたければ、このように設定して下さい:

     (setq gnus-global-score-files
           '("/ftp@ftp.gnus.org:/pub/larsi/ding/score/soc.motss.SCORE"
             "/ftp@ftp.some-where:/pub/score/"))

単純でしょう?  ディレクトリー名は `/' で終わらなくてはなりません。これ
らのディレクトリーは、一般に Gnus を使う一回の期間中に一回だけしか読み
込まれません。もし遠隔ディレクトリーを手動で再読み込みすることが必要だ
と思ったら、`gnus-score-search-global-directories' 命令を使って下さい。

ただし、現時点ではこのオプションを使うと、グループに入るのがいくらか遅
くなります。(つまり--かなり、ですけど。)

他の人たちに使ってもらうためにスコアファイルを維持管理したくなったら、
単にあなたのスコアファイルを匿名 ftp に置いて、世界に公表して下さい。逆
行司会者になりましょう!  その後に続いて間違いなく起こる逆行司会者戦争、
すなわち人々の共感を勝ち取るための戦いに参加して、彼らのスコアファイル
に偽りの前提を使わせるように誘導するのです!  やったね!  これでネットは
救われる!

     `retro-' を「逆行」と訳しました。日本では「レトロ」を「古き善き時
     代の」のような肯定的な意味で使うことが少なくないのですが、ここでは
     本来の「時代に逆行した」「使えねー」のような意味で使っています。

以下に、逆行司会者なりたがりのための秘技をいくつか、即席で述べます:


   * 非常に多くの場所にクロスポストされている記事は間違いなく屑である。
   * 一個の不適切な記事を減点するには、`Message-ID' で減点する。
   * 特に素晴らしい投稿者たちは永続的な基準で加算して良い。
   * そのグループの憲章を無視した投稿を頻繁に繰り返す投稿者は、絶滅させ
     てしまって差し支えない。
   * `mark' と `expunge' アトムを設定し、汚らわしい記事を完全に葬り去る。

   * 期限切れ消去のスコア・エントリーを使って、ファイルの大きさを小さく
     抑える。もっとも、サイトによって古い記事を長期間保存するように、お
     そらく長い期限切れ消去の期間を取るでしょうけれども。

... 果たして他のニュースリーダーは、将来グローバルスコアファイルをサ
ポートするでしょうか?  *うふふ*。そう、どう考えてみたって、Blue Wave や
xrn や 1stReader とかいったニュースリーダーは、スコアをサポートするべき
ですね。今は固唾を飲んで見守ることにしましょうか?



File: gnus-ja.info, Node: Kill Files, Next: Converting Kill Files, Prev: Global Score Files, Up: Scoring

消去ファイル
============

Gnus はまだ、あのうざったい古い消去ファイルをサポートしています。実際消
去ファイルの項目はもう消してもよいのですが、それは Daniel Quinlan がス
コアファイルを考え出す前に私が書いたものなので、そのコードはまだ残して
あるのです。

要するに、消去処理はスコア処理よりもかなり (私に言わせれば *ものすごく
*) 遅いので、あなたの消去ファイルはスコアファイルに書き換えた方が良いか
もしれません。

いずれにせよ、消去ファイルは普通の `emacs-lisp' ファイルです。このファ
イルの中にはどんな形式でも入れることができます。つまり消去ファイルをグ
ループに入ったときに実行する一種の原始的なフック関数のように使うことが
できます。まあそれがあまりいい方法ではないとしてもね。

通常の消去ファイルは以下のようになります:

     (gnus-kill "From" "Lars Ingebrigtsen")
     (gnus-kill "Subject" "ding")
     (gnus-expunge "X")

これは私が書いたすべての記事に既読の印を付け、概略バッファーから印の付
いた記事を削除します。とっても便利です。あなたもそう思うでしょ。

他のプログラムではまったく違う消去ファイルの構文を使っています。Gnus は
`rn' の消去ファイルらしきものに出会うと、何とかそれを解釈しようとします。

GNUS 消去ファイルを編集するための二つの概略バッファー関数があります:

`M-k'
     このグループの消去ファイルを編集します
     (`gnus-summary-edit-local-kill')。

`M-K'
     一般消去ファイルを編集します (`gnus-summary-edit-global-kill')。

消去ファイルを編集する二つのグループモード関数があります:

`M-k'
     このグループの消去ファイルを編集します
     (`gnus-group-edit-local-kill')。

`M-K'
     一般消去ファイルを編集します (`gnus-group-edit-global-kill')。

消去ファイル変数:

`gnus-kill-file-name'
     `soc.motss' グループ用の消去ファイルは通常 `soc.motss.KILL' という
     名前です。このファイル名を得るためにグループ名に付加される接尾語は、
     `gnus-kill-file-name' 変数で与えられます。「グローバル」消去ファイ
     ルは (スコアファイルの意味での「グローバル」じゃないよ、もちろん)
     単に `KILL' という名前です。

`gnus-kill-save-kill-file'
     この変数が `nil' 以外であれば、Gnus は処理の後に消去ファイルを保存
     します。これは期限切れ消去を行なう消去を使っているときに必要です。

`gnus-apply-kill-hook'
     グループに消去ファイルを適用するために呼び出されるフック。これはディ
     フォルトでは `(gnus-apply-kill-file)' です。同じグループのためのス
     コアファイルがある場合に消去ファイルを無視したければ、このフックを
     `(gnus-apply-kill-file-unless-scored)' に設定して下さい。消去ファ
     イルを処理させたくなければ、この変数を `nil' に設定して下さい。

`gnus-kill-file-mode-hook'
     消去ファイルモードのバッファー内で呼び出されるフック。



File: gnus-ja.info, Node: Converting Kill Files, Next: Advanced Scoring, Prev: Kill Files, Up: Scoring

消去ファイルの変換
==================

あなたが古い消去ファイルをどっさり持っているのであれば、それらをスコア
ファイルに変換したくなるでしょう。もしそれらが「普通の」ものであれば、
`gnus-kill-to-score.el' パッケージを使うことができます。そうでなければ、
手で変換しなければならないでしょう。

消去ファイルからスコアファイルへの変換パッケージは、標準では Gnus には
含まれていません。
`http://www.stud.ifi.uio.no/~larsi/ding-various/gnus-kill-to-score.el'
から入手することができます。

あなたの消去ファイルが非常に複雑なのであれば--それに `gnus-kill' 形式以
外のものがたくさん含まれているのなら、それらを手で変換しなければならな
いでしょう。あるいは、単そのままにしておいて下さい。Gnus は以前と同様に
それらを使ってくれるでしょう。



File: gnus-ja.info, Node: Advanced Scoring, Next: Score Decays, Prev: Converting Kill Files, Up: Scoring

上級スコア付け
==============

表題や From ヘッダーにスコアを付けるのは十分素敵ですが、本当に興味があ
るのが、特定の表題に関してある人が言っていることだけだった場合はどうす
れば良いでしょう?  もしくは、A さんが B さんにフォローアップしていると
きは彼女が言っていることを読みたくないけれど、C さんにフォローアップし
ているときは何を言っているかを知りたいという場合は?

上級スコア規則を使えば、どんな複雑なスコアのパターンでも作成することが
できます。

* Menu:

* Advanced Scoring Syntax::     定義
* Advanced Scoring Examples::   どのように見えるか
* Advanced Scoring Tips::       それを最大限に利用する



File: gnus-ja.info, Node: Advanced Scoring Syntax, Next: Advanced Scoring Examples, Prev: Advanced Scoring, Up: Advanced Scoring

上級スコア付け構文
------------------

普通のスコア規則では、規則の最初の要素が文字列です。上級スコア付け規則
では、最初の要素はリストです。二番目の要素は、最初の要素が `nil' でない
値として評価されたときに適用されるスコアです。

これらのリストは三つの論理演算子、一つのリダイレクト演算子 (訳注: 本文
では間接演算子と表記されています)、および様々な合致演算子で構成すること
ができます。

論理演算子:

`&'
`and'
     この論理演算子は、それぞれの引数を順に評価して、ある評価の結果が
     `false' になったら停止します。すべての引数が `true' の値に評価され
     た場合、この演算子は `true' を返します。

`|'
`or'
     この論理演算子は、それぞれの引数を順に評価して、ある評価の結果が
     `true' になったら停止します。どの引数も `true' でなかったら、この
     演算子は `false' を返します。

`!'
`not'
`,A,'
     この論理演算子はたった一つの引数を取ります。その引数の値の論理否定
     を返します。

スコア付けされている現在の記事の先祖たちに対して、その引数群を適用する
「間接演算子」があります。例えば `1-' は、現在の記事の親にもスコア規則
を適用します。`2-' は現在の記事の祖父母にスコア規則を適用します。代わり
に `^^' を書くこともでき、`^' (caret==キャレット) の数でどのくらい祖先
の記事までさかのぼるかを示します。

最後に合致演算子があります。これらが本当の仕事をするものです。合致演算
子はヘッダー名の文字列で、その後に合致と合致の型が続きます。典型的な合
致演算子は `("form" "Lars Ingebrigtsen" s)' のようなものです。ヘッダー
名は単純なスコア付けをするときのものと同じで、合致の型も同じです。



File: gnus-ja.info, Node: Advanced Scoring Examples, Next: Advanced Scoring Tips, Prev: Advanced Scoring Syntax, Up: Advanced Scoring

上級スコア付けの例
------------------

以下の例はスコアファイルの規則であることに注意して下さい。それらを使っ
て完璧なスコアファイルを作るには、別の括弧の組でそれらを囲んで下さい。

Lars が Gnus に関して話をしているときに、彼によって書かれた記事のスコア
を増やしたいとしましょう:

     ((&
       ("from" "Lars Ingebrigtsen")
       ("subject" "Gnus"))
      1000)

ふん、簡単すぎるかな?

彼が長い記事を書くとき、時々何か素敵なことを言います:

     ((&
       ("from" "Lars Ingebrigtsen")
       (|
        ("subject" "Gnus")
        ("lines" 100 >)))
      1000)

しかし、彼が Reig Eigil Logge によって書かれたものに反応しているときは、
彼が書いたものを読みたくありません:

     ((&
       ("from" "Lars Ingebrigtsen")
       (1- ("from" "Reig Eigir Logge")))
      -100000)

Redmondo が消えた靴下について書いたときにフォローアップしたすべての人の
スコアが上げられますが、それは彼らが白い靴下について語っているときのみ
です。しかし Lars が靴下について話をしているときは、たいていあまりおも
しろくありません:

     ((&
       (1-
        (&
         ("from" "redmondo@.*no" r)
         ("body" "disappearing.*socks" t)))
       (! ("from" "Lars Ingebrigtsen"))
       ("body" "white.*socks"))
      1000)

大量の記事が流れているグループを読んでいて、返答にしか興味が無いとしま
しょう。そういう場合にやることは、"Re:"、"Fw:" または "Fwd:" で始まる表
題を持っていないすべての記事のスコアを下げて、返答の印で始まる表題を持っ
ている記事のすべての親のスコアを上げることです。

     ((! ("subject" "re:\\|fwd?:" r))
       -200)
     ((1- ("subject" "re:\\|fwd?:" r))
       200)

可能性は無限大です。



File: gnus-ja.info, Node: Advanced Scoring Tips, Prev: Advanced Scoring Examples, Up: Advanced Scoring

上級スコアのちょっとした秘訣
----------------------------

`&' と `|' 論理演算子は、無意味な処理を迂回する論理 (原典:
short-circuit logic) に基づいて動作します。すなわち、その処理の結果が明
らかになった時点で、引数を処理することを止めます。例えば `&' の引数の一
つが `false' に評価されると、残りの引数を評価する意味がありませんから。
これは遅い合致 (`body' や `header') を最後に持ってきて、速い合致
(`from' や `subject') を最初に持ってくるべきであることを示唆します。

間接演算子 (`1-' など) は、それらの引数をスレッドの一世代前に作用させま
す。次のようなことをすると:

     ...
     (1-
      (1-
       ("from" "lars")))
     ...

これは「現在の記事の祖父母の from ヘッダーでスコアを付ける」ということ
を意味します。間接演算子の処理はとても速いのですが、以下のやり方の方が:

     (1-
      (&
       ("from" "Lars")
       ("subject" "Gnus")))

次のものより良いです:

     (&
      (1- ("from" "Lars"))
      (1- ("subject" "Gnus")))



File: gnus-ja.info, Node: Score Decays, Prev: Advanced Scoring, Up: Scoring

スコアを減衰させる
==================

スコアは (特に適応スコアを使っていると) 際限無く膨れ上がる傾向があるこ
とに気が付くでしょう。スコアが大きくなりすぎると、それらはすべての意味
を失います--それらは単に最大値に達してしまうので、意味のある方法で使う
ことは難しくなります。

Gnus はこの問題の解決を助けるためにスコアを減衰させる機構を提供します。
スコアファイルが読み込まれて、`gnus-decay-scores' が `nil' ではないと、
Gnus はスコアファイルを減衰機構に通して、すべての永続でないスコア規則の
スコアを下げます。もし `gnus-decay-scores' が正規表現だったら、それに合
致するスコアファイルだけが扱われます。例えば *adaptive* スコアファイル
だけを減衰させるには、それを `\\.ADAPT\\'' に設定すれば良いでしょう。減
衰そのものは `gnus-decay-score-function' 関数によって実行され、ディフォ
ルトは `gnus-decay-score' です。以下はその関数の定義です:

     (defun gnus-decay-score (score)
       "Decay SCORE according to `gnus-score-decay-constant'
     and `gnus-score-decay-scale'."
       (let ((n (- score
                   (* (if (< score 0) -1 1)
                      (min (abs score)
                           (max gnus-score-decay-constant
                                (* (abs score)
                                   gnus-score-decay-scale)))))))
         (if (and (featurep 'xemacs)
                  ;; XEmacs' floor can handle only the floating point
                  ;; number below the half of the maximum integer.
                  (> (abs n) (lsh -1 -2)))
             (string-to-number
              (car (split-string (number-to-string n) "\\.")))
           (floor n))))

`gnus-score-decay-constant' はディフォルトで 3、
`gnus-score-decay-scale' は 0.05 です。これは以下のようなことを引き起こ
します:

  1. この関数が呼ばれたときに -3 から 3 の間のスコアは 0 に設定されます。

  2. 3 から 60 までの間の大きさのスコアは 3 減らされます。

  3. 60 より大きいスコアはスコアの 5% が減らされます。

もしこの減衰関数がお気に召さないなら、自分用の関数を書いて下さい。それ
は減衰させるべきスコアを唯一の引数として呼ばれ、新しいスコアを整数で返
さなければなりません。

Gnus は一日に一回スコアを減衰させようとします。例えば Gnus を四日間走ら
せていないと、Gnus はスコアを四回減衰させます。




File: gnus-ja.info, Node: Various, Next: The End, Prev: Scoring, Up: Top

いろいろ
********

* Menu:

* Process/Prefix::              多くの命令で使われる習慣
* Interactive::                 Gnus に多くの質問を尋ねさせる
* Symbolic Prefixes::           いくつかの Gnus の関数に選択権を提供する方法
* Formatting Variables::        バッファーの見栄えを指定することができる
* Window Layout::               Gnus の各バッファーのウィンドウを設定する
* Faces and Fonts::             フェースがどのように見えるかを変更する
* Compilation::                 Gnus を速くするには
* Mode Lines::                  モード行に情報を表示する
* Highlighting and Menus::      バッファーを素敵で心地よく見せる
* Buttons::                     たった十回たたいただけで腱鞘炎になる!
* Daemons::                     Gnus はあなたの裏で仕事をすることができる
* NoCeM::                       Spam や他の太りやすい食事を避ける方法
* Undo::                        いくつかの動作は元に戻すことができる
* Predicate Specifiers::        述語を設定する
* Moderation::                  あなたがモデレーターだったらどうするか
* Fetching a Group::            グループを読むためだけに Gnus を起動する
* Image Enhancements::          最新の Emacs/XEmacs は画像を表示できる
* Fuzzy Matching::              大きなひずんだ音 (big fuzz) って何?
* Thwarting Email Spam::        頼んでもいない広告メールを避ける方法
* Other modes::                 他のモードとの相互作用
* Various Various::             本当にいろいろなもの



File: gnus-ja.info, Node: Process/Prefix, Next: Interactive, Prev: Various, Up: Various

プロセス/接頭引数
=================

多くの関数、その中でも記事の移動、デコード、保存をするための関数は、
「プロセス/接頭引数の習慣」として知られているものを使います。

これは、利用者がどの記事に命令を実行したいかを見つけるための方法です。

それはこのような感じです:

数値接頭引数が N だったら、現在の記事を含めた次の N 個の記事に対して作
業を実行します。もし数値接頭引数が負だったら、現在の記事を含めた前の N
個の記事に対して作業を実行します。

`transient-mark-mode' が `nil' ではなく、リージョンが設定されていたら、
リージョンにあるすべての記事で作業が行なわれます。

数値接頭引数が無くても、いくつかの記事はプロセス印が付いている場合には、
プロセス印が付いている記事で作業が実行されます。

数値接頭引数やプロセス印の付いている記事が無い場合は、現在の記事でだけ
作業を実行します。

これは実際とても単純なのですが、びっくりされないためにも、はっきりさせ
ておく必要があります。

プロセス印に反応するコマンドは、現在プロセス印が付いている記事のリスト
をスタックに積んで、記事のすべてのプロセス印を消去します。前回の設定を
`M P y' で復旧させることができます (*Note Setting Process Marks::)。

多くの人々をぎょっとさせ、恐がらせると思われることの一つは、例えば `3
d' が、本当に `d' `d' `d' と同じことをすることです。それぞれの `d' (こ
れは現在の記事に既読の印を付けます) は、ディフォルトでは印を付けた後で
次の未読記事に移動するので、`3 d' は概略バッファーがどうなっていても、
次の三つの未読記事を既読にします。動作をもっと分かりやすくするには、
`gnus-summary-goto-unread' を `nil' に設定して下さい。

多くのコマンドはプロセス/接頭引数の習慣を使いません。それをしないすべて
のコマンドは、このマニュアルで明記されています。そういうコマンドにプロ
セス/接頭引数の習慣を適用するには、`M-&' コマンドを使って下さい。例えば、
そのグループのすべての記事を期限切れ消去可能として印を付けるには `M P
b M-& E' とします。



File: gnus-ja.info, Node: Interactive, Next: Symbolic Prefixes, Prev: Process/Prefix, Up: Various

利用者との相互作用
==================

`gnus-novice-user'
     この変数が `nil' でないのは、あなたは Usenet の世界の新参者か非常
     に慎重な人のどちらかだというです。これは本当に良いことです。何か危
     険なことをする前に、「本当にこれをしたいのですか?」というような質
     問を受けます。これはディフォルトでは `t' です。

`gnus-expert-user'
     この変数が `nil' でないと、あなたが Gnus から質問を受けることは滅
     多に無いでしょう。これは単純に、あなたがどんな変なことをしても、何
     をしているかをわかっていると見なします。

`gnus-interactive-catchup'
     `nil' でないと、グループに追いつく (catchup, 未読の記事を読んだこ
     とにしてしまう) 前に、確認を求めます。ディフォルトで `t' です。

`gnus-interactive-exit'
     Gnus を終了する前に確認を求めます。ディフォルトで `t' です。



File: gnus-ja.info, Node: Symbolic Prefixes, Next: Formatting Variables, Prev: Interactive, Up: Various

シンボルの接頭引数
==================

非常に多くの Emacs の命令が (数値) 接頭引数に反応します。例えば `C-u 4
C-f' はポイントを 4 文字先に移動し、`C-u 9 0 0 I s s p' は 900 のスコア
(永続、`Suject'、文字列の一部、という規則) を現在の記事に加えます。

これはすべて素敵で良いのですが、命令にもう少し追加の情報を与えたいとき
はどうすれば良いのでしょう?  えーと、たいていの命令がしていることは「生
の」接頭引数を何らかの特別な方法で解釈することです。例えば `C-u 0 C-x
C-s' は、現在の記事を保存するときにバックアップファイルを作らないで欲し
いことを意味します。でも、バックアップファイルを作らないで保存するのと
同時に、Emacs に閃光を放って、素敵な音楽を演奏して欲しいときはどうすれ
ば良いでしょう?  それができなくても、あなたは申し分なく幸せですね(?)。

私はそうではありません。そこで、私は二つめの接頭引数「シンボル接頭引数」
を加えました。接頭キーは `M-i' (`gnus-symbolic-argument') で、次に押さ
れる文字が値です。いくらでも `M-i' 接頭語を積み重ねることができます。
`M-i a C-M-u' は「`C-M-u' 命令にシンボル接頭引数 `a' を与える」というこ
とです。`M-i a M-i b C-M-u' は「`C-M-u' 命令にシンボル接頭引数 `a' `b'
を与える」ということです。趣旨はわかりましたね。

シンボル接頭引数を受け付けない命令にそれを打ち込んでも何も悪いことをし
ませんが、良いことも何もしません。現在のところ、あまり多くの関数がシン
ボル接頭引数を利用しているわけではありません。

Gnus がこれを実装しているやり方に興味があるなら、
*Note Extended Interactive:: を見て下さい。



File: gnus-ja.info, Node: Formatting Variables, Next: Window Layout, Prev: Symbolic Prefixes, Up: Various

書法仕様変数
============

このマニュアルを通して、おそらく `gnus-group-line-format' または
`gnus-summary-mode-line-format' のように呼ばれるたくさんの変数があるこ
とに気付いたでしょう。これらは Gnus が色々なバッファーでどのように行を
出力するかを制御します。非常にたくさんのものがあります。幸運なことに、
それらはすべて同じ構文を使うので、あまり嫌な目には会わないでしょう。

書法仕様 (format) 指定の例です (グループバッファーより):
`%M%S%5y: %(%g%)\n'。それは極めて醜く、たくさんのパーセント記号がい
たるところにあります。

* Menu:

* Formatting Basics::           書法仕様変数は基本的に書法指定文字列である
* Mode Line Formatting::        モード行の書法仕様変数に関するいくつかの規則
* Advanced Formatting::         色々な方法で出力を変化させる
* User-Defined Specs::          Gnus にあなた自身の関数を呼ばせる
* Formatting Fonts::            仕様を多彩で素敵に見せる
* Positioning Point::           操作の後でポイントを移動する
* Tabulation::                  出力の整列
* Wide Characters::             幅が広い文字を扱う

現在のところ Gnus は以下の書法仕様変数を使います:
`gnus-group-line-format', `gnus-summary-line-format',
`gnus-server-line-format', `gnus-topic-line-format',
`gnus-group-mode-line-format', `gnus-summary-mode-line-format',
`gnus-article-mode-line-format', `gnus-server-mode-line-format', および
`gnus-summary-pick-line-format'。

これらすべての書法仕様変数は任意の elisp 式であることもできます。その場
合、それらは要求される行に挿入するために `eval' (評価) されます。

Gnus は、あなたが自分用の書法仕様指定を作っているときに、手助けをする命
令を備えています。`M-x gnus-update-format' は現在の式を `eval' し、当の
仕様を更新し、行を生成するための Lisp 式を検査することができるバッファー
に移動します。



File: gnus-ja.info, Node: Formatting Basics, Next: Mode Line Formatting, Prev: Formatting Variables, Up: Formatting Variables

書法仕様の基本
--------------

それぞれの `%' の要素は、当のバッファーが作成されるときに何らかの文字列
や他のもので置き換えられます。`%5y' は「`y' 指定を挿入して、5 文字の場
所を得るために空白を詰め込みなさい」ということです。

普通の C や Emacs Lisp の書法仕様 (format) 文字列と同じように、`%' と書
法仕様の型の文字の間の数値修飾子は、常に少なくともその長さになるように、
出力に (空白文字などを)「詰め込み」ます。`%5y' はその場所が常に (少なく
とも) 5 文字の長さになるように、左に空白を詰め込みます。もし `%-5y' と
すれば、代わりに右側に詰め込みます。

特に広い幅の値に対して保護するために、その場所の長さを制限したいことも
あるでしょう。そのために `%4,6y' などと指定することができます。これは、
その場所は決して 6 文字を超える幅にはならず、かつ 4 文字より少ない幅に
もならないということです。

Gnus は `%&user-date;' のような、いくつかの拡張様式指示もサポートします。



File: gnus-ja.info, Node: Mode Line Formatting, Next: Advanced Formatting, Prev: Formatting Basics, Up: Formatting Variables

モード行書法仕様
----------------

モード行書法仕様変数 (例えば `gnus-summary-mode-line-format') は、以下
の二つの違い以外は、バッファー行に適応した書法仕様変数 (*Note
Formatting Basics::) と同じ規則に従います:

  1. 最後に改行 (`\n') があってはなりません。

  2. 特別な `%%b' 仕様をバッファー名を表示するために使うことができます。
     えーと、実はそれは仕様ではないのです---`%%' というものは、Emacs が
     `%b' を受け取って、そのモード行表示機能に「バッファー名を表示しな
     さい」と解釈させるために、単に書法仕様の処理系を無傷で通り抜けるこ
     とができるように `%' を囲う方法なのです。Emacs が理解するモード行
     指定の完全な一覧については、変数 `mode-line-format' の説明文を見て
     下さい。



File: gnus-ja.info, Node: Advanced Formatting, Next: User-Defined Specs, Prev: Mode Line Formatting, Up: Formatting Variables

上級書法仕様
------------

表示された領域を後で何らかの方法で処理するのは、しばしば役に立ちます。詰
め込み、制限、切り取り、および特定の値の抑制は、「チルダ修飾子」を使うこ
とによって実現することができます。よくあるチルダ仕様は、
`%~(cut 3)~(ignore "0")y' のように見えるでしょう。

これらは有効な修飾子です:

`pad'
`pad-left'
     領域の左側に、要求された長さになるまで空白を詰め込みます。

`pad-right'
     領域の右側に、要求された長さになるまで空白を詰め込みます。

`max'
`max-left'
     指定された長さになるように、文字列の左側を切り取ります。

`max-right'
     指定された長さになるように、文字列の右側を切り取ります。

`cut'
`cut-left'
     指定された数の文字を左側から切り落とします。

`cut-right'
     指定された数の文字を右側から切り落とします。

`ignore'
     領域が指定された値と等しい (equal) ならば、空文字列を返します。

`form'
     `@' 仕様が使われたときに、指定された式を領域の値として使います。

     これは例です:

          "~(form (current-time-string))@"

例を出してみましょう。概略モード行での `%o' 仕様は ISO0861 様式の凝縮さ
れた日付 (`19960809T230410' のようなもの) を返します。これはとても発音
しにくいので、世紀を表す数と時刻を削ぎ落として、6 文字の日付を残したい
と思います。それは `%~(cut-left 2)~(max-right 6)~(pad 6)o' となるでしょ
う。(切り落とし (cutting) は 最大幅の制限 (maxing) より先に行なわれるの
で、表示欄での見栄えを良くするために、日付が 6 文字より少なくならないこ
とを保証する詰め込み (padding) が必要になります。)

無視 (ignore) が最初に行なわれます。それから切り落とし (cutting)、次に
最大幅の制限 (maxing)、そして最後の操作である詰め込み (padding) が行な
われます。

もしあなたが、これらの上級参照をたくさん使っているなら、Gnus がとても遅
くなるのがわかるでしょう。これはあなたが行の外見に満足したときに `M-x
gnus-compile' を実行することによって、格段に速度低下を減らすことができ
ます。*Note Compilation::.



File: gnus-ja.info, Node: User-Defined Specs, Next: Formatting Fonts, Prev: Advanced Formatting, Up: Formatting Variables

利用者定義の指定
----------------

すべての仕様に、利用者が定義した `u' で始まる述語を挿入することができま
す。書法仕様文字列の次の文字は、アルファベットでなければなりません。
`%u' に続くアルファベットが `X' だったら、Gnus は関数
`gnus-user-format-function-'`X' を呼びます。関数には単一の引数が与えら
れますが、その引数の意味は関数がどのバッファーから呼ばれているかによっ
て変わります。関数は文字列を返さなければなりません。それは他の述語によっ
て生成される情報とまったく同じように、バッファーに挿入されます。関数は
意味の無い値と共に呼ばれる場合もあるので、それの対策をしておくべきです。

Gnus は利用者定義仕様を拡張した `%u&foo;' のような形式もサポートします。
この場合は `gnus-user-format-function-'`foo' という関数を呼び出します。

新しい関数を定義しなくても、ほとんど同じことをチルダ修飾子 (*Note
Advanced Formatting::) を使って達成できるでしょう。例です:

`%~(form (count-lines (point-min) (point)))@'

ここで与えられた式は評価されて現在の行番号をもたらし、それから挿入され
ます。



File: gnus-ja.info, Node: Formatting Fonts, Next: Positioning Point, Prev: User-Defined Specs, Up: Formatting Variables

書法仕様フォント
----------------

すべての書法仕様変数によって共有される、ハイライト (強調表示) のための
仕様があります。述語 `%(' と 述語 `%)' で囲まれたテキストには特別な
`mouse-face' 属性が与えられ、そこにマウスのポインターを置いたときに
(`gnus-mouse-face' によって) ハイライトされます。

述語 `%{' と 述語 `%}' で囲まれたテキストには、普通のフェー
スである `gnus-face-0' (ディフォルトで `bold') が与えられます。
`%{1' を使うと、代わりに `gnus-face-1' が与えられ、以下同様で
す。欲しいだけたくさんのフェースを作って下さい。同じこと
が `mouse-face' 仕様にも言えます。`hello' がマウスを置いたとき
に `gnus-mouse-face-3' でハイライトされるためには、
`%3(hello%)' とすれば良いでしょう。

述語 `%《' と 述語 `%》' で囲まれたテキストでは、特別な `balloon-help'
属性が `gnus-balloon-face-0' に設定されます。`%1《' とすると、
`gnus-balloon-face-1' が使われ、以下同様です。`gnus-balloon-face-*' 変
数は、文字列か文字列を返す関数を指すシンボルのどちらかでなければなりま
せん。この属性が設定されているテキストの上をマウスが通過すると、吹き出
しが現れて文字列を表示します。これの詳しい情報は *Note Tooltips:
(emacs)Tooltips, (GNU Emacs) または `balloon-help-mode' (XEmacs) の説明
を参照して下さい。(技術的な理由のために、ギィメ (guillemets) はこの節で
は `《' と `》' で近似されました。)

     訳注: guillemets (仏語) はギュメとも表記されます。実際に Gnus で有
     効なのは次の二つです:

          (string (make-char 'latin-iso8859-1 43)) ;; 《
          (string (make-char 'latin-iso8859-1 59)) ;; 》

     日本語の「」に当たるもので、口頭表現を表記したり、強調したい単語を
     囲む、何かからの引用部分を囲む、書物等のタイトルを記す等様々に使わ
     れます。

これはグループバッファーで使うことができる、もう一つの調理法です:

     ;; 三つのフェースを作ります。
     (setq gnus-face-1 'bold)
     (setq gnus-face-3 'italic)

     ;; 記事の数をボールドで緑のフェースにしたいので、
     ;; `my-green-bold' という新しいフェースを作ります。
     (copy-face 'bold 'my-green-bold)
     ;; 色を設定します。
     (set-face-foreground 'my-green-bold "ForestGreen")
     (setq gnus-face-2 'my-green-bold)

     ;; 新しい特製の書法仕様を設定します。
     (setq gnus-group-line-format
           "%M%S%3{%5y%}%2[:%] %(%1{%g%}%)\n")

あなたがこの案を使って、完全に読めなくて非常に下品な表示を作ることがで
きることを確信しています。楽しんで下さい!

`%(' 指定 (やその類のもの) は、モード行変数ではまったく意味をなさないこ
とに注意して下さい。



File: gnus-ja.info, Node: Positioning Point, Next: Tabulation, Prev: Formatting Fonts, Up: Formatting Variables

ポイントの移動
--------------

Gnus は通常ほとんどのバッファーで、ポイントを各行のあらかじめ決められた
場所に移動します。ディフォルトでは、ポイントは行の最初のコロンに移動し
ます。この振るまいは、三つの違う方法でカスタマイズすることができます。

また、コロンを行のどの場所にでも移動することができます。

コロンの位置にポイントを移動させるための関数を定義し直すことができます。
その関数は `gnus-goto-colon' と呼ばれています。

でも、行にコロンを含めたくないならば、これを扱うためのおそらく最も手ご
ろな方法は `%*' という述語を使うことです。あなたの行の書法仕様の定義に
`%*' を入れておけば、Gnus はそこにポイントを置きます。



File: gnus-ja.info, Node: Tabulation, Next: Wide Characters, Prev: Positioning Point, Up: Formatting Variables

整列
----

通常は、空白文字を詰め込んだり端を切り落とすことによって、文字列をディ
スプレイに並べることができます。でも大きさが違う異なる文字列を連結させ
る場合は、単に文字列を出力してしまうのがより手ごろであることが多いはず
で、しかしそうするとその後に続くテキストを並べるのに悩むことになります。

それを行なうために、Gnus は整列子 (tabulator) の仕様 `%=' を備えていま
す。これには二つの形式 "hard tabulators" および "soft tabulators" があ
ります。

`%50=' は文字列が 50桁までの場所を占めるように空白文字を詰め込みます。
もし挿入するテキストの末端が 50桁より後ろになる場合は何も挿入しません。
これは穏やか (soft) な整列子です。

`%-50=' もまた、文字列が 50桁までの場所を占めるように空白文字を詰め込み
ます。ですが、もし挿入するテキストの末端が 50桁より後ろになる場合は、
50桁より後ろになる過剰なテキストは削除されます。これは厳密 (hard) な整
列子です。



File: gnus-ja.info, Node: Wide Characters, Prev: Tabulation, Up: Formatting Variables

Wide Characters
---------------

多くの地域において、固定幅フォントは同じ幅の文字を持っています。しかし
いくつかの地域、よく知られている東アジアの国々では、ラテン文字と幅の広
い文字が混在して使われています。

整形において、Gnus は文字列が 10個の文字の幅だとしたら、スクリーンでも
10個分のラテン文字の幅になると仮定しますが、それは問題です。かの国々で
は、それは正しくありません。

それを救済するために、あなたは `gnus-use-correct-string-widths' を `t'
に設定することができます。これはバッファーの生成を遅くしますが、より美
しい結果を得ることができるでしょう。ディフォルト値は XEmacs では `t' で
すが Emacs では `nil' です。(訳注: 日本語などを Emacs で表示する場合に、
書法仕様によっては `t' にしないと概略バッファーの表示が不揃いになること
があります。)



File: gnus-ja.info, Node: Window Layout, Next: Faces and Fonts, Prev: Formatting Variables, Up: Various

ウィンドウの配置
================

いえ、X に関することはありませんから、おとなしくして下さい。

もし `gnus-use-full-window' が `nil' でないと、Gnus はすべての他のウィ
ンドウを消して、Emacs の画面全体を占有します。これはディフォルトで `t'
です。

この変数を `nil' に設定してもそれなりに動作しますが、問題もあります。危
険を覚悟の上で使って下さい。

`gnus-buffer-configuration' はそれぞれの Gnus のバッファーがどのくらい
の空間を与えられるべきかを現します。これはこの変数の抜粋です:

     ((group (vertical 1.0 (group 1.0 point)
                           (if gnus-carpal (group-carpal 4))))
      (article (vertical 1.0 (summary 0.25 point)
                             (article 1.0))))

これは連想リストです。「キー」は何らかの動作を名付けるためのシンボルで
す。例えば、グループバッファーを表示するときは、ウィンドウを設定するた
めの関数は `group' をキーとして使います。使用可能な名前の完全な一覧は下
に挙げられています。

「値」(すなわち「分割」) は、それぞれのバッファーがどれくらいの空間を占
めるべきかを指定します。`article' の分割を例に取ると

     (article (vertical 1.0 (summary 0.25 point)
                            (article 1.0)))

この「分割」は概略バッファーが画面の上の 25% を占めるべきで、それは記事
バッファーの上に配置されると言っています。お気づきのように、100% + 25%
は実際は 125% です (えぇ、皆さんの計算はこの様になったと思います。) し
かし、特別な数値 `1.0' は、残りのバッファーが必要なものを取り去った後に、
使用可能な残りの空間すべてを吸い取る、ということを合図するために使われ
ます。`1.0' の大きさを指定するバッファーは、一つの分割につき一つだけで
なくてはなりません。

ポイント (カーソル) は省略可能な三つ目の要素、`point' を持つバッファー
に置かれます。`frame' 分割では、`frame-focus' タグが含まれている枝葉の
分割を持っている副分割の、最後のもののフレームがフォーカスを得ることに
なります (`frame-focus' タグは、それを含んでいる枝葉リストにおいて、
`point' タグが無ければ三番目の、あれば四番目の要素になります。

次はもっと複雑な例です:

     (article (vertical 1.0 (group 4)
                            (summary 0.25 point)
                            (if gnus-carpal (summary-carpal 4))
                            (article 1.0)))

もし大きさの指定が浮動小数点数の代わりに整数だったなら、それは割合では
なく、どのくらい多くの行をバッファーが占めるべきかを指定するために使わ
れます。

もし「分割」が `eval' (評価) されるもののように見えるときは (正確に言う
と--分割の `car' が関数か原始関数 (subr) であるときは)、この分割は
`eval' されます。結果が `nil' でないなら、それは分割として用いられます。
これは、`gnus-carpal' が `nil' であれば三つのバッファーが、
`gnus-carpal' が `nil' でないなら、四つのバッファーが存在することになる
ということです。

まだ複雑ではないですって? それでは、大きさとしてこれを試してみて下さい:

     (article (horizontal 1.0
                  (vertical 0.5
                      (group 1.0)
                      (gnus-carpal 4))
                  (vertical 1.0
                      (summary 0.25 point)
                      (summary-carpal 4)
                      (article 1.0))))

おぉっと。二つのバッファーに謎の 100% タグが付いています。そして
`horizontal' って何でしょう?

もし分割の一つの最初の要素が `horizontal' であったなら、Gnus はウィンド
ウを水平に分割し、二つのウィンドウを横に並べます。これらのそれぞれの小
片の中では、あなたのやりたいことをすべて普通の流儀で行なうことができま
す。`horizontal' の後の数値は、この小片に画面のどれくらいの割合が与えら
れるかを指定します。

それぞれの分割では、100% のタグを持つ要素が *必ず* 一つある必要がありま
す。分割は決して正確ではないので、分割によって余ったすべての行を、この
バッファーが分捕ります。

もう少し形式的に、有効な分割がどのようになるかの定義を挙げておきましょ
う:

     split      = frame | horizontal | vertical | buffer | form
     frame      = "(frame " size *split ")"
     horizontal = "(horizontal " size *split ")"
     vertical   = "(vertical " size *split ")"
     buffer     = "(" buf-name " " size *[ "point" ] *[ "frame-focus"] ")"
     size       = number | frame-params
     buf-name   = group | article | summary ...

制限として、`frame' は最も上位階層の分割としてしか現れることができない
というものがあります。`form' は有効な分割を返す Emacs Lisp の式 (form)
でなければなりません。それぞれの分割は完全に再帰的で、任意の数の
`vertical' と `horizontal' 分割を含むことができます。

正しい大きさを見つけることは、少し複雑になります。どのウィンドウも
`gnus-window-min-height' (ディフォルトは 1) の文字の高さよりも小さくて
はならないし、少なくとも `gnus-window-min-width' (ディフォルトは 1) の
文字幅でなくてはなりません。Gnus は分割を適用する前にこれを強制しようと
試みます。もし標準の Emacs のウィンドウの幅/高さ制限を使いたいなら、こ
の二つの変数を `nil' にするだけで良いです。

Emacs の用語になじんでいないのなら、`horizontal' と `vertical' の分割は、
期待したものと反対の動作をするでしょう。`horizontal' 分割の中のウィンド
ウは横に並んで表示され、`vertical' 分割の中のウィンドウは上下に表示され
ます。

ウィンドウの配置に関して実験をしてみたいのであれば、良い方法は分割を引
数にして直接 `gnus-configure-frame' を呼ぶことです。これはバッファーを
分割するときにすべての実際の仕事をする関数です。下のものは五つのウィン
ドウを作るかなりばかげた設定です。二つをグループバッファーに、三つを記
事バッファーのために充てます。(だから、ばかげていると言ったでしょ。) も
し下の文を `評価' すると、普通の Gnus の経路を使わないで、すぐにそれが
どのように見えるかの直観を得ることができます。満足するまでそれで遊んで、
それから `gnus-add-configuration' を使って新しい作品をバッファー配置リ
ストに加えて下さい。

     (gnus-configure-frame
      '(horizontal 1.0
         (vertical 10
           (group 1.0)
           (article 0.3 point))
         (vertical 1.0
           (article 1.0)
           (horizontal 4
             (group 1.0)
             (article 10)))))

複数のフレームも欲しいかもしれません。問題ありません---`frame' 分割を使
うだけです:

     (gnus-configure-frame
      '(frame 1.0
              (vertical 1.0
                        (summary 0.25 point frame-focus)
                        (article 1.0))
              (vertical ((height . 5) (width . 15)
                         (user-position . t)
                         (left . -1) (top . 1))
                        (picon 1.0))))

この分割の結果は、最初の (もしくは「主たる」) フレームに見慣れた概略/記
事ウィンドウを配置し、小さな追加のフレームが picon を表示するために作ら
れます。ご覧の通り、普通の最上位階層の `1.0' の定の代わりに、それぞれの
追加の分割が大きさの指定として、フレームパラメーターの連想リストを持た
なければなりません (*Note Frame Parameters: (elisp)Frame Parameters.)。
XEmacs では、フレームプロパティーリストも使えます--例えば `(height 5
width 15 left -1 top 1)' がそのような plist です。
`gnus-buffer-configuration' で使うことができるすべてのキーの一覧は、そ
のディフォルト値で見つけることができます。

キー `message' は `gnus-group-mail' および
`gnus-summary-mail-other-window' の両方で使われることに注意して下さい。
もし二つを区別するほうが望ましいなら、このような物を使うことができます:

     (message (horizontal 1.0
                          (vertical 1.0 (message 1.0 point))
                          (vertical 0.24
                                    (if (buffer-live-p gnus-summary-buffer)
                                        '(summary 0.5))
                                    (group 1.0))))

良くある複数のフレーム分割の要望は、メールとニュースの作成には別のフレー
ムを使い、元のフレームはそのままに残すというものです。これの達成には、
以下のようなものでできます。

     (message
       (frame 1.0
              (if (not (buffer-live-p gnus-summary-buffer))
                  (car (cdr (assoc 'group gnus-buffer-configuration)))
                (car (cdr (assoc 'summary gnus-buffer-configuration))))
              (vertical ((user-position . t) (top . 1) (left . 1)
                         (name . "Message"))
                        (message 1.0 point))))

訳注: これを高度に発展させたものが
`http://www.jpl.org/elips/message-multiple-frames.el.gz' として入手でき
ます。使い方はファイルの冒頭に書かれています。

変数 `gnus-buffer-configuration' はとても長く複雑なので、単一の設定の変
更を簡単にするための関数があります: `gnus-add-configuration' です。例え
ば `article' の設定を変えたいのなら、次のようにできます:

     (gnus-add-configuration
      '(article (vertical 1.0
                    (group 4)
                    (summary .25 point)
                    (article 1.0))))

普通はこれらの `gnus-add-configuration' の呼び出しを `~/.gnus.el' ファ
イルに入れるか、何らかの起動時のフックに入れるでしょう--それらは Gnus
が読み込まれた後で実行されなければなりません。

もし分割の設定で指定されたすべてのウィンドウがすでに見えているのであれ
ば、Gnus はウィンドウの配置を変更しません。常に「正しい」ウィンドウ設定
を強制したいのであれば、`gnus-always-force-window-configuration' を
`nil' でない値に設定して下さい。

木表示 (*Note Tree Display::) を使っていて、木ウィンドウが垂直方向に次
の別のウィンドウで表示されるなら、ウィンドウの大きさが変更されることを
避けるために `gnus-tree-minimize-window' をいじるのが良いでしょう。


ウィンドウ配置の例
------------------

   * 左側を狭めてグループバッファーに。右側を分割して概略バッファー (上
     1/6) と記事バッファー (下) に。

          +---+---------+
          | G | Summary |
          | r +---------+
          | o |         |
          | u | Article |
          | p |         |
          +---+---------+

          (gnus-add-configuration
           '(article
             (horizontal 1.0
                         (vertical 25 (group 1.0))
                         (vertical 1.0
                                   (summary 0.16 point)
                                   (article 1.0)))))

          (gnus-add-configuration
           '(summary
             (horizontal 1.0
                         (vertical 25 (group 1.0))
                         (vertical 1.0 (summary 1.0 point)))))



File: gnus-ja.info, Node: Faces and Fonts, Next: Compilation, Prev: Window Layout, Up: Various

フェースとフォント
==================

かつてフォントとフェースをいじくるのは非常に難しかったのですが、今日で
は非常に簡単です。単に `M-x customize-face' とやって、変えたいフェース
を選び出して、標準のカスタマイズインターフェースを使って変更することが
できます。



File: gnus-ja.info, Node: Compilation, Next: Mode Lines, Prev: Faces and Fonts, Up: Various

コンパイル
==========

あの行書法仕様指定変数を覚えていますか? `gnus-summary-line-format',
`gnus-group-line-format' などなどです。さて、Gnus はこれらの変数が何で
あっても注意を払いますが、残念ながらそれらを変更すると大変重大な速度低
下を引き起こすことになります。(これらの変数のディフォルト値は、それらに
関連付けられたバイトコンパイルされた関数を持っていますが、利用者作成の
ものはもちろんそうではありません。)

これを改善するために、変数をいじくりまわして、(なんとなく) 満足したと感
じた後で、`M-x gnus-compile' を実行することができます。これは新しい指定
がバイトコンパイルされ、もう一度最高速度に復帰できるということです。
Gnus はこれらのバイトコンパイルされた指定を `.newsrc.eld' ファイルに保
存します。(もっとも利用者が定義した関数は、この関数によってコンパイルさ
れません--それらを `~/.gnus.el' ファイルに突っ込んでから、自分でそのファ
イルをバイトコンパイルしなければなりません。)



File: gnus-ja.info, Node: Mode Lines, Next: Highlighting and Menus, Prev: Compilation, Up: Various

モード行
========

`gnus-updated-mode-lines' はどのバッファーがそれらのモード行を常に最新
のものにしておくかを指定します。それはシンボルのリストです。使うことの
できるシンボルは `group', `article', `summary', `server', `browse',
`tree' などです。もし対応するシンボルが存在すると、Gnus は該当する情報
でモード行を更新します。この変数が `nil' ならば、画面の再描画はもっと速
いでしょう。

ディフォルトでは、Gnus は概略バッファーと記事バッファーのモード行に現在
の記事の情報を表示します。Gnus が表示したい情報 (例えば記事の表題) はし
ばしばモード行よりも長いことがあるので、どこかで切り落とされなければな
りません。変数 `gnus-mode-non-string-length' はその行の他の要素 (すなわ
ち情報でない部分) がどのくらいの長さであるかを指定します。もしモード行
に追加の要素を入れたなら、この変数を修正する必要があります:

     (add-hook 'display-time-hook
               (lambda () (setq gnus-mode-non-string-length
                                (+ 21
                                   (if line-number-mode 5 0)
                                   (if column-number-mode 4 0)
                                   (length display-time-string)))))

もしこの変数が `nil' であるなら (これがディフォルトですが)、モード行は
切り落とされず、詰め込みもされません。ディフォルトでは、バッファーの完
全なパーセント表示さえもモード行から追いやられる可能性もあるので、おそ
らく望ましい設定ではないことに注意して下さい。利用者が自分の設定に合う
ようにこの変数を適切に設定しなければなりません。



File: gnus-ja.info, Node: Highlighting and Menus, Next: Buttons, Prev: Mode Lines, Up: Various

ハイライトとメニュー
====================

変数 `gnus-visual' は Gnus を素敵にするたいていの方面の操作をします。
`nil' であると、Gnus はメニューを作ったり、素敵な色やフォントを使ったり
しようとしません。これはさらに `gnus-vis.el' ファイルを読み込むことも禁
止します。

この変数は有効にされている視覚的なプロパティーのリストであることができ
ます。以下の要素は有効で、ディフォルトですべて含まれています:

`group-highlight'
     グループバッファーでハイライト (強調表示) をします。
`summary-highlight'
     概略バッファーでハイライトをします。
`article-highlight'
     記事バッファーでハイライトをします。
`highlight'
     すべてのバッファーでハイライトをするようにします。
`group-menu'
     グループバッファーでメニューを作成します。
`summary-menu'
     概略バッファーでメニューを作成します。
`article-menu'
     記事バッファーでメニューを作成します。
`browse-menu'
     ブラウズバッファーでメニューを作成します。
`server-menu'
     サーバーバッファーでメニューを作成します。
`score-menu'
     スコアバッファーでメニューを作成します。
`menu'
     すべてのバッファーでメニューを作成します。

ですから、記事バッファーだけをハイライトしたくて、すべてのバッファーで
メニューを作りたい場合は、このようにすることができます:

     (setq gnus-visual '(article-highlight menu))

もしハイライトだけで、メニューの類は欲しくないときは、次のようにできま
す:

     (setq gnus-visual '(highlight))

`gnus-visual' が `t' であると、ハイライトとメニューはすべての Gnus のバッ
ファーで使用されます。

他のすべてのバッファーの外見に影響する総合的な変数は:

`gnus-mouse-face'
     これは Gnus でマウスのハイライトに使われるフェース (すなわちフォン
     ト) です。`gnus-visual' が `nil' であると、マウスハイライトはなさ
     れません。

まったく違ったメニューを作成するために、関連するフックがあります:

`gnus-article-menu-hook'
     記事モード (article mode) のメニューを作成した後に呼ばれるフックで
     す。

`gnus-group-menu-hook'
     グループモード (group mode) のメニューを作成した後に呼ばれるフック
     です。

`gnus-summary-menu-hook'
     概略モード (summary mode) のメニューを作成した後に呼ばれるフックで
     す。

`gnus-server-menu-hook'
     サーバーモード (server mode) のメニューを作成した後に呼ばれるフッ
     クです。

`gnus-browse-menu-hook'
     概観モード (browse mode) のメニューを作成した後に呼ばれるフックで
     す。

`gnus-score-menu-hook'
     スコアモード (score mode) のメニューを作成した後に呼ばれるフックで
     す。



File: gnus-ja.info, Node: Buttons, Next: Daemons, Prev: Highlighting and Menus, Up: Various

ボタン
======

最新流行のマウス "mouse" 装置が、近ごろではちゃんとした操作法を学びたが
らない若者やかっこいいこどもたちの間で大人気です。それでは私が Tops 20
システム上で Emacs を使っていた頃の、'89 年の夏を思い起こしてみましょう。
300 人の利用者が、一つのマシン上で、みんなが Simula コンパイラを走らせ
ていました。ああ、ばかばかしい!

ほんとうに。

さて、`gnus-carpal' を `t' に設定することによって、クリックするだけで何
でもできるボタンだらけのバッファーを Gnus に表示させることができます。
とっても簡単です、ほんとうに。指圧療法の先生に教えてあげて下さい (訳注:
carpal とは手首の骨のこと)。

`gnus-carpal-mode-hook'
     すべての手首モードバッファーで実行するフックです。

`gnus-carpal-button-face'
     ボタンに使われるフェースです。

`gnus-carpal-header-face'
     手首バッファーのヘッダーで使用されるフェースです。

`gnus-carpal-group-buffer-buttons'
     グループバッファーのボタンです。

`gnus-carpal-summary-buffer-buttons'
     概略バッファーのボタンです。

`gnus-carpal-server-buffer-buttons'
     サーバーバッファーのボタンです。

`gnus-carpal-browse-buffer-buttons'
     閲覧バッファーのボタンです。

すべての `buttons' 変数はリストです。これらのリストの要素は、その
`car' の項が表示される文を含んでいて、その `cdr' の項が関数シンボルになっ
ている cons セルか、もしくはただの文字列のどちらかです。



File: gnus-ja.info, Node: Daemons, Next: NoCeM, Prev: Buttons, Up: Various

デーモン
========

Gnus、それは (言い伝えによれば) かつて書かれたいかなるプログラムよりも
大きく、あなたがやって欲しいと思うさまざまな奇妙なことを、あなたのいな
いところで行なってくれるものです。例えば、あなたは時たま新着メールを
チェックしてもらいたいかもしれません。あるいは Emacs をしばらく放ってお
いたときすべてのサーバーの接続を切断してもらいたくなるかもしれません。
他にも何かそういったことです。

Gnus はさまざまな「ハンドラー」(処理を行なわせるためのもの) を定義する
ことによってそのようなことを可能にします。各ハンドラーは三つの要素から
成ります:「関数」、「時間」、「アイドル」(何もしていない状態を示すもの)
パラメーターです。

これは Emacs のアイドル状態が三十分続いたときに接続を切断するハンドラー
の例です:

     (gnus-demon-close-connections nil 30)

これは Emacs がアイドルのとき、一時間毎に PGP ヘッダーを走査するハンド
ラーです:

     (gnus-demon-scan-pgp 60 t)

この「時間」パラメーターと「アイドル」パラメーターは、奇妙かつ素晴らし
いやり方で一緒に動作します。基本的に「アイドル」が `nil' だったら、関数
は「時間」分毎に呼び出されます。

「アイドル」が `t' だったら、関数は Emacs がアイドルだったときに限って
「時間」分後に呼び出されます。したがって Emacs がアイドルにならなければ、
関数は呼び出されません。いったん Emacs がアイドル状態になると、この関数
は「時間」分毎に呼び出されます。

「アイドル」が数値で「時間」も数値だった場合、Emacs のアイドル状態が
「アイドル」分続いた場合に限って、「時間」分毎に関数が呼び出されます。

「アイドル」が数値で「時間」が `nil' だった場合、関数は Emacs のアイド
ル状態が「アイドル」分続く度に一度呼び出されます。

そして「時間」が文字列だった場合 (それは `07:31' のような形式でなければ
なりません)、関数は毎日その時刻の頃になると一度呼び出されます。もちろん
「アイドル」パラメーターによって動作が変わります。

(ここで「分」と言ったとき、それは実際には `gnus-demon-timestep' 秒のこ
とです。これはディフォルトでは 60 です。もしこの変数を変更すると、すべ
てのハンドラーの計時に影響を与えます。)

というわけで、ハンドラーを追加したければ、`~/.gnus.el' ファイルに以下の
ようなものを書き込めば良いでしょう:

     (gnus-demon-add-handler 'gnus-demon-close-connections 30 t)

このための既製の関数がいくつか作成されています:
`gnus-demon-add-nocem', `gnus-demon-add-disconnection',
`gnus-demon-add-nntp-close-connection',
`gnus-demon-add-scan-timestamps', `gnus-demon-add-rescan', および
`gnus-demon-add-scanmail' です。これらの機能を必要とするならば、単にこ
れらの関数を `~/.gnus.el' に入れて下さい。

`gnus-demon-handlers' に直接ハンドラーを追加した場合には、それを効かせ
るために `gnus-demon-init' を実行して下さい。すべてのデーモンを取り消す
には、`gnus-demon-cancel' 関数を使うことができます。

デーモンの追加をやりすぎるのはかなりマズいことです。すべてのサーバーか
らすべてのニュースとメールを二秒毎に調べまわす関数を付け加えたりするこ
とは、どんな立派なシステムからも確実に追い出される方法です。お行儀良く
しましょう。



File: gnus-ja.info, Node: NoCeM, Next: Undo, Prev: Daemons, Up: Various

NoCeM
=====

"Spam" とは、同じ記事を何回も何回も何回も投稿することです。Spam は悪い
ことです。Spam は凶悪です。

Spam はさまざまな反 spam 機関によって、通常一日かそこらで取り消しされま
す。通常これらの機関は、一緒に "NoCeM" メッセージも送り出します。
NoCeM" は“no see-'em”(彼らを見たくない) と発音され、意味はその名前の
通りです--これらのメッセージは気に触る記事を、つまり、消してしまいます。

どうせそれらの記事が取り消しされてしまうのなら、これらの NoCeM メッセー
ジは何に使われるのでしょう? あるサイトでは取り消しメッセージを重視しま
せん。また、あるサイトでは特定の数人からの取り消しメッセージだけを尊重
します。そこで、あなたは NoCeM メッセージを使いたくなるかもしれないわけ
です。これらは `alt.nocem.misc' ニュースグループで配布されています (訳
注: 他に `fj.news.lists.filters' や `news.lists.filters' などでも独自の
NoCeM メッセージが配布されています)。

Gnus はこのグループのメッセージを自動的に読み、解釈することができ、これ
で spam を消し去ります。

もちろん、これらをカスタマイズするための変数がいくつかあります:

`gnus-use-nocem'
     ものごとを始めさせるには、この変数を `t' に設定して下さい。ディフォ
     ルトでは `nil' です。

     この変数にグループレベルとして正の数値を設定することもできます。そ
     の場合、この値が `gnus' や `gnus-group-get-new-news' などのコマン
     ドの接頭引数として与えるグループレベル以下だったら、Gnus は新着
     ニュースをチェックするときに NoCeM メッセージを走査します。さもな
     ければ、それらのコマンドにグループレベルを与えると、Gnus は NoCeM
     メッセージを走査しません。例えば、メールグループで 1 か 2 を使って
     いてニュースグループのレベルがディフォルトのままだったら、3 が最も
     良い選択です。

`gnus-nocem-groups'
     Gnus はこのグループのリストから NoCeM メッセージを探します。ディフォ
     ルトは次の通りです:

          ("news.lists.filters" "news.admin.net-abuse.bulletins"
           "alt.nocem.misc" "news.admin.net-abuse.announce")

`gnus-nocem-issuers'
     NoCeM メッセージを発行する人はたくさんいます。このリストでは、誰の
     いうことに従いたいかを指定します。ディフォルトは次の通りです:

          ("Automoose-1" "clewis@ferret.ocunix.on.ca"
           "cosmo.roadkill" "SpamHippo" "hweede@snafu.de")

     彼らはみんな、立派で高潔な市民です。

     このリストに含められる有名な反 spam 家たちは
     `http://www.xs4all.nl/~rosalind/nocemreg/nocemreg.html' に載ってい
     ます。

     これらすべての人々の NoCeM メッセージに留意する必要はありません--
     言うことを聞きたい人だけで良いのです。また、それらの人たちからの
     NoCeM メッセージを、すべて受け入れる必要もありません。それぞれの
     NoCeM メッセージは、そのメッセージの厳密な (多少は厳密、たいていは
     そうでもない) 定義を与える種別 "type" ヘッダーを持っています。一般
     的な種別は `spam', `spew', `mmf', `binary', および `troll' です。
     これを指定するには、リストの中で `(発行者 条件...)' という要素を使
     う必要があります。それぞれの条件は、文字列 (使いたい種別に合致する
     正規表現) または `(not 文字列)' という形式のリスト (この場合の「文
     字列」は使いたくない種別に合致する正規表現) のどちらかです。

     例えば、Chris Lewis からの、`troll' メッセージ以外のすべての
     NoCeM メッセージを欲しい場合には、こうすれば良いでしょう:

          ("clewis@ferret.ocunix.on.ca" ".*" (not "troll"))

     一方、彼の `spam' と `spew' メッセージ以外は何も要らないのであれば、
     以下のようにできます:

          ("clewis@ferret.ocunix.on.ca" (not ".*") "spew" "spam")

     この指定は左から右に適用されます。

`gnus-nocem-verifyer'
     これは NoCeM 発行者が本人であることを検証する関数でなくてはなりま
     せん。ディフォルトは `pgg-verify' で、これは検証に成功したら
     非-`nil' を返し、そうでなければ (NoCeM メッセージが署名されていな
     い場合を含みます) `nil' を返します。もしこれが非常に遅くて、検証結
     果を気にしない (これはたぶん危険です) のであれば、この変数を
     `nil' にすることができます。

     以前、ディフォルトは Mailcrypt の関数である `mc-verify' でした。ま
     だそれを使うことができますが、PGP の公開鍵を GnuPG の鍵束に加える
     ことを厭わなければ、GnuPG とともに動作するディフォルトの関数に変え
     ることができます。

`gnus-nocem-directory'
     これは Gnus が NoCeM キャッシュファイルを保存する場所です。ディフォ
     ルトは `~/News/NoCeM/' です。

`gnus-nocem-expiry-wait'
     古い NoCeM 項目をキャッシュから消すまでの日数。ディフォルトは 15
     です。これを短くするほど Gnus は速くなりますが、古い spam を見るこ
     とになってしまうかもしれません。

`gnus-nocem-check-from'
     非-`nil' では、記事のボディーにある発行人の正当性を調べます。そう
     でない場合は、著者が正しい発行人でなくても気にせずに記事を取り込み
     ますが、もしあなたが正しい発行人を見分けられるならば、そうした方が
     とても速くなるでしょう。

`gnus-nocem-check-article-limit'
     すべての NoCeM グループにおけるチェックする記事の最大数を指定しま
     す (訳注: `nil' で無制限)。NoCeM グループは巨大になることがあり、
     そうなると処理がとても遅くなります。

NoCeM を使うと、もしかするとメモリ喰いになるかもしれません。あなたがた
くさんの生きたグループ (つまり購読あるいは非購読グループ) を持っている
と、Emacs のプロセスは大きくなってしまうでしょう。もしこれが問題であれ
ば、非購読のグループを全部 (あるいはその多くを) 消し去って (kill して)
しまうべきです (*Note Subscription Commands::)。



File: gnus-ja.info, Node: Undo, Next: Predicate Specifiers, Prev: NoCeM, Up: Various

やり直し
========

実行したことのやり直しができると、とても便利です。Emacs の普通のバッ
ファーでは十分に簡単です--単に `undo' ボタンを押すだけです。しかし
Gnus のバッファーでは、それは簡単ではありません。

Gnus がバッファー内に表示しているものは、Gnus にとってはまったく何の価
値もありません--これはみんな、利用者に奇麗に見えるようにデザインされて
いるただのデータなのです。`C-k' でグループバッファーからグループを消去
すると、その行は消え去りますが、それは実際の動作--当のグループを Gnus
の内部構造体から削除すること、の単なる副作用でしかありません。これらの
やり直しは、通常の Emacs の `undo' 関数では行なうことができません。

Gnus は利用者がすることを憶えておいて、利用者がすることの逆を行なうこと
によって、これを多少は救済しようとします。利用者が `undo' キーを押すと、
一段階または数段階前までの操作を元に戻すコードを実行します。しかし、す
べての操作が簡単に逆戻りできるわけではないので、現在 Gnus は、やり直し
可能なキーの機能を僅かしか提供していません。これらはグループの削除、グ
ループの貼り付け、およびグループの既読記事のリストの変更です。実際それ
だけです。将来はもっと機能が追加されるかもしれませんが、追加されるそれ
ぞれの機能は保存するべきデータを増やすので、決して Gnus は完全にやり直
し可能にはならないでしょう。

やり直し機能は `gnus-undo-mode' マイナーモードによって提供されます。こ
れは `gnus-use-undo' が `nil' 以外であれば使用され、これがディフォルト
です。`C-M-_' キーが `gnus-undo' 命令を実行します。これは通常の Emacs
の `undo' 命令にいくぶん似ているはずです。



