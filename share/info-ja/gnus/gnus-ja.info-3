Info file: gnus-ja.info,    -*-Text-*-
produced by `texinfo-format-buffer'
from file `gnus-ja.texi'
using `texinfmt.el' version 2.41 of  1 Mar 2005.

Copyright (C) 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003,
2004, 2005, 2006 Free Software Foundation, Inc.

     Permission is granted to copy, distribute and/or modify this
     document under the terms of the GNU Free Documentation License,
     Version 1.2 or any later version published by the Free Software
     Foundation; with no Invariant Sections, with the Front-Cover
     texts being "A GNU Manual", and with the Back-Cover Texts as in
     (a) below.  A copy of the license is included in the section
     entitled "GNU Free Documentation License" in the Emacs manual.

     この文書を、フリーソフトウェア財団発行の GNU フリー文書利用許諾契
     約書第 1.2 版またはそれ以降の版が定める条件の下で複製、配布、ある
     いは変更することを許可します。変更不可部分は指定しません。“A GNU
     Manual”は表表紙テキスト、以下の (a) は裏表紙テキストです。この利
     用許諾契約書の複写は“Emacs manual”の「GNU フリー文書利用許諾契約
     書」という章に含まれています。

     (a) The FSF's Back-Cover Text is: "You have freedom to copy and
     modify this GNU Manual, like GNU software.  Copies published by
     the Free Software Foundation raise funds for GNU development."

     (a) FSF の裏表紙テキスト:「あなたにはこの GNU Manual を GNU ソフト
     ウェアのように複製したり変更する自由があります。複製はフリーソフト
     ウェア財団によって出版されました。(フリーソフトウェア財団は) GNU
     の開発のために必要な資金を集めています。」

     This document is part of a collection distributed under the GNU
     Free Documentation License.  If you want to distribute this
     document separately from the collection, you can do so by adding
     a copy of the license to the document, as described in section 6
     of the license.

     この文書は「GNU フリー文書利用許諾契約書」に基づいて配布された収集
     著作物の一部です。もしあなたがこの文書を収集著作物から分離して配布
     したいときは、契約書の第 6 章に記述されているように、文書に契約書
     の複写を付加することによって、行なうことができます。



INFO-DIR-SECTION Emacs
START-INFO-DIR-ENTRY
* Gnus-ja: (gnus-ja).           The newsreader Gnus (Japanese).
END-INFO-DIR-ENTRY





File: gnus-ja.info, Node: To From Newsgroups, Next: Summary Buffer Mode Line, Prev: Summary Buffer Lines, Up: Summary Buffer Format

To From Newsgroups
------------------

いくつかのグループ (特にアーカイブグループ) では `From' ヘッダーはあま
り興味を引きません。そこのすべての記事はあなたによって書かれたものです
から。代わりに、`To' や `Newsgroups' ヘッダーの情報を表示するためには、
三つのことを決める必要があります: どの情報を集めるか, どこに表示するか,
いつ表示するか。

  1. 追加のヘッダーの情報は `gnus-extra-headers' により制御されます。こ
     れはヘッダーのシンボルのリストです。例えば:

          (setq gnus-extra-headers
                '(To Newsgroups X-Newsreader))

     これによって Gnus はこれらの三つのヘッダーを取得しようとし、後の容
     易な取得のためにヘッダー構造に保存します。

  2. これらの追加のヘッダーの値は `gnus-extra-function' 関数を通じて取
     得することができます。これは `X-Newsreader' ヘッダーを使う書式行の
     仕様です:

          "%~(form (gnus-extra-header 'X-Newsreader))@"

  3. `gnus-ignored-from-addresses' 変数はいつ `%f' 概略行仕様
     が `To', `Newsreader' や `From' ヘッダーを返せば良いかを
     決めます。この正規表現が `From' ヘッダーの内容と合致すると、
     `To' や `Newsreader' ヘッダーの値が代わりに使用されます。

     それらの `From' フィールドが入れ替わっている記事と、普通の記事を区
     別するために、概略行の `To' または `Newsgroups' ヘッダーに、ある文
     字列が前置されます。その文字列はディフォルトで、`To' には `-> ' が、
     `Newsgroups' には `=> ' が使われますが、`gnus-summary-to-prefix'
     と `gnus-summary-newsgroup-prefix' によって、それらの文字列をカス
     タマイズすることができます。

関連する変数は `nnmail-extra-headers' で、overview (NOV) ファイルを作る
際にいつ追加のヘッダーを含めるかを制御します。古い overview ファイルが
ある場合は、この変数を変更した後にサーバーバッファーに `^' で入って適切
なメールサーバー (例えば nnml) で `g' を押し、再生成する必要があります。

さらに `gnus-summary-line-format' 変数の `%n' 仕様を `%f' 仕様に変更す
ることによってデータを表示するように、Gnus に指示する必要があります。

要約すると、普通は以下のようなものを `~/.gnus.el' に置くことになります:

     (setq gnus-extra-headers
           '(To Newsgroups))
     (setq nnmail-extra-headers gnus-extra-headers)
     (setq gnus-summary-line-format
           "%U%R%z%I%(%[%4L: %-23,23f%]%) %s\n")
     (setq gnus-ignored-from-addresses
           "Your Name Here")

(上記の値は Gnus のディフォルト値です。あなたの役に立つように変えて下さ
い。)

ニュース管理人、またはニュース管理人を説得してサポートの追加をしてもら
おうと思っている利用者のみなさんへのご注意:

NOV ファイルの生成を制御できるメールグループでは、上記のことはたいてい
の場合役立ちます。しかし、管理人を説得して (特に INN の普通の実装におい
て) 以下のものを `overview.fmt' ファイルの最後に追加してもうらうことが
できれば、メールグループでの追加ヘッダーのようにそれを使うことができま
す。

     Newsgroups:full



File: gnus-ja.info, Node: Summary Buffer Mode Line, Next: Summary Highlighting, Prev: To From Newsgroups, Up: Summary Buffer Format

概略バッファーのモード行
------------------------

概略のモード行の様式も変更することができます (*Note Mode Line
Formatting::)。`gnus-summary-mode-line-format' を何でも好きなものに設定
して下さい。ディフォルトは `Gnus: %%b [%A] %Z' です。

以下はあなたが遊ぶことのできる要素たちです:

`G'
     グループ名。
`p'
     接頭語を取り除いた名前。
`A'
     現在の記事番号。
`z'
     現在の記事スコア。
`V'
     Gnus バージョン。
`U'
     そのグループでの未読記事の数。
`e'
     概略バッファーに表示されていない未読記事の数。
`Z'
     未読と未選択の記事の数とともに表される文字列で、未読かつ未選択の記
     事がある場合の `<%U(+%e) more>'、および未読記事のみの場合の `<%U
     more>' のどちらかです。
`g'
     短縮グループ名。例えば、`rec.arts.anime' は `r.a.anime' に短縮され
     ます。
`S'
     現在の記事の表題。
`u'
     利用者定義の仕様 (*Note User-Defined Specs::)。
`s'
     現在のスコアファイルの名前 (*Note Scoring::)。
`d'
     保留記事の数 (*Note Unread Articles::)。
`t'
     可視印付き記事の数 (*Note Unread Articles::)。
`r'
     その概略バッファーで記事を読んだ結果、既読の印が付いた記事の数。
`E'
     スコアファイルによって抹消された記事の数。



File: gnus-ja.info, Node: Summary Highlighting, Prev: Summary Buffer Mode Line, Up: Summary Buffer Format

概略のハイライト
----------------

`gnus-visual-mark-article-hook'
     このフックは記事を選択した後に実行されます。これは何らかの方法で記
     事をハイライトするように意図されています。`gnus-visual' が `nil'
     だったら実行されません。

`gnus-summary-update-hook'
     このフックは概略行が変化したときに呼ばれます。
     `gnus-visual' が `nil' だったら実行されません。

`gnus-summary-selected-face'
     これは概略バッファーでの現在の記事をハイライトするために使われる
     フェース (もしくは、ある人たちが「フォント」と呼ぶようなもの) です。

`gnus-summary-highlight'
     概略行はこの変数にしたがってハイライトされます。この変数は要素が
     `(FORM . FACE)' の形式のリストです。例えば、印付きの記事を斜体、高
     いスコアの記事を太字にしたければ、この変数を次のように設定すること
     ができます。

          (((eq mark gnus-ticked-mark) . italic)
           ((> score default) . bold))

     ご想像のとおり、FORM が `nil' でない値を返すと、FACE がその行に適
     用されます。



File: gnus-ja.info, Node: Summary Maneuvering, Next: Choosing Articles, Prev: Summary Buffer Format, Up: Summary Buffer

概略間の移動
============

すべての直接移動命令は数値接頭引数を受け付け、かなり期待どおりに動作す
るでしょう。

これらの命令はどれも記事を選択しません。

`G M-n'
`M-n'
     概略行の次の未読記事に移ります
     (`gnus-summary-next-unread-subject')。

`G M-p'
`M-p'
     概略行の前の未読記事に移ります
     (`gnus-summary-prev-unread-subject')。

`G g'
     記事番号を尋ね、その記事を表示せずに、その概略行に行きます
     (`gnus-summary-goto-subject')。

Gnus が次のグループ移動することを確認するためにキー入力を求めた場合、
`C-n' キーと `C-p' キーを使うことによって、実際にグループバッファーに戻
らなくても、次に読むグループを探すことができます。

概略の移動に関連した変数:

`gnus-auto-select-next'
     移動命令の一つ (`n' のような) を発したときに現在の記事の後に未読記
     事が無いと、Gnus は次のグループに移動することをうながします。この
     変数が `t' で次のグループが空っぽだったら、Gnus は概略モードを抜け
     てグループバッファーに戻ります。この変数が `t' でも `nil' でもなけ
     れば、Gnus はさらに次の未読記事があるグループを選択します。特別な
     場合として、この変数が `quietly' だったら、Gnus は確認をせずに次の
     グループを選択します。この変数が `almost-quietly' だった場合は、グ
     ループの一番最後の記事を読んでいたときに限って同じことが起こります。
     最後に、もしこの変数が `slightly-quietly' だったら、`Z n' 命令は確
     認をせずに次のグループに移ります。*Note Group Levels:: も参照して
     下さい。

`gnus-auto-select-same'
     `nil' でないと、すべての移動命令は現在の記事と同じ表題の記事に移動
     しようとします。(「同じ」はここでは「大体同じ」という意味かもしれ
     ません。詳細は `gnus-summary-gather-subject-limit' を見て下さい
     (*Note Customizing Threading::)。) 同じ表題の記事が無いときは、最
     初の未読記事に移動します。

     この変数は、スレッド表示を行なっているときはあまり役に立たないでしょ
     う。

`gnus-summary-check-current'
     これが `nil' ではない場合、すべての『未読』移動命令は、現在の記事
     が未読だったら次 (もしくは前) の記事に移動しません。代わりに、それ
     らは現在の記事を選びます。

`gnus-auto-center-summary'
     `nil' でないと、Gnus は概略バッファーでのポイントを常に真中に保ち
     ます。これをすると、とてもこぎれいになりますが、遅いネットワークに
     接続していたり、この Emacs らしくない流儀が好きになれないのであれ
     ば、この変数を `nil' にすることによって、普通の Emacs のスクロール
     にすることができます。これは概略バッファーの水平方向でポイントが真
     ん中になるようにする操作 (horizontal re-centering) も禁止してしま
     うので、非常に長いスレッドを読むときは不便かもしれません。

     この変数は数値でも構いません。その場合は、ウィンドウの先頭からその
     数の行だけ下がった位置に常にポイントがあるように制御されます。



File: gnus-ja.info, Node: Choosing Articles, Next: Paging the Article, Prev: Summary Maneuvering, Up: Summary Buffer

記事の選択
==========

* Menu:

* Choosing Commands::           記事を選択するための命令
* Choosing Variables::          これらの命令に影響を及ぼす変数



File: gnus-ja.info, Node: Choosing Commands, Next: Choosing Variables, Prev: Choosing Articles, Up: Choosing Articles

選択命令
--------

以下の移動コマンドはどれも数値接頭引数を受け付けません。それらはすべて、
記事を選択して表示します。

新しい記事を取り込んだり、グループを再表示したいときは *Note Exiting
the Summary Buffer:: を参照して下さい。

`SPACE'
     現在の記事、またはそれが既読だった場合は次の未読記事を選択します
     (`gnus-summary-next-page')。

     すでに記事ウィンドウを開いているときに再び `SPACE' を押すと、その記
     事はスクロールされます。これによって、ニュースグループ全体
     を `SPACE' だけで便利に通読することができます。
     *Note Paging the Article::.

`G n'
`n'
     次の未読記事に移動します (`gnus-summary-next-unread-article')。

`G p'
`p'
     前の未読記事に移動します (`gnus-summary-prev-unread-article')。

`G N'
`N'
     次の記事に移動します (`gnus-summary-next-article')。

`G P'
`P'
     前の記事に移動します (`gnus-summary-prev-article')。

`G C-n'
     同じ表題の次の記事に移動します (`gnus-summary-next-same-subject')。

`G C-p'
     同じ表題の前の記事に移動します (`gnus-summary-prev-same-subject')。

`G f'
`.'
     最初の未読記事に移動します (`gnus-summary-first-unread-article')。

`G b'
`,'
     最高スコアの未読記事に移動します
     (`gnus-summary-best-unread-article')。接頭引数が与えられると、ディ
     フォルトのスコアより大きいスコアを持つ最初の未読記事に移動します。

`G l'
`l'
     直前に読んだ記事に移動します (`gnus-summary-goto-last-article')。

`G o'
     概略の履歴 (history) から最後の記事を一つ取り出して選択します
     (`gnus-summary-pop-article')。この命令が上の命令と違うのは、`l' が
     最後の二つの記事の間を移動するだけなのに対して、これは好きなだけ前
     の記事を履歴から選び出すことができる点です。これに多少関係すること
     について、*Note Article Backlog:: を参照して下さい (これらの命令を
     たくさん使うのであれば)。

`G j'
`j'
     記事番号か `Message-ID' を尋ね、それからその記事に行きます
     (`gnus-summary-goto-article')。



File: gnus-ja.info, Node: Choosing Variables, Prev: Choosing Commands, Up: Choosing Articles

選ぶための変数
--------------

記事の移動と選択に関連するいくつかの変数:

`gnus-auto-extended-newsgroup'
     この変数が `nil' でないと、すべての移動命令は、記事が概略バッファー
     に表示されていない場合でも、前 (もしくは次) の記事に移動しようとし
     ます。その際 Gnus はサーバーから記事を取得して、記事バッファーに表
     示します。

`gnus-select-article-hook'
     このフックは記事が選択されたときに常に呼ばれます。ディフォルトは
     `nil' です。講読するそれぞれの記事をエージェントに保存させたい場合
     は、このフックに `gnus-agent-fetch-selected-article' を追加すれば
     良いでしょう。

`gnus-mark-article-hook'
     このフックは記事が選択されたときに常に呼ばれます。これは記事に既読
     の印を付けるために使われることを意図しています。ディフォルト値は
     `gnus-summary-mark-read-and-unread-as-read' で、ほとんどすべての読
     んだ記事の印を `gnus-read-mark' に変更します。この関数に影響されな
     い記事は、可視、保留、期限切れ消去可能記事だけです。未読記事に既読
     の印を付けたいだけであれば、代わりに
     `gnus-summary-mark-unread-as-read' を使うことができます。
     `gnus-low-score-mark' や `gnus-del-mark' (など) の印はそのまま残し
     ます。



File: gnus-ja.info, Node: Paging the Article, Next: Reply Followup and Post, Prev: Choosing Articles, Up: Summary Buffer

記事のスクロール
================

`SPACE'
     `SPACE' を押すと、現在の記事を一ページ先にスクロールします。記事の
     最後に行き着いた場合は次の記事を選択します
     (`gnus-summary-next-page')。

     `gnus-article-skip-boring' が非-`nil' で、かつ記事の残りに引用と署
     名しか無い場合、それはスキップされ、代わりに次の記事が表示されます。
     `gnus-article-boring-faces' で、つまらないと思うものをカスタマイズ
     することができます。どんなにうんざりするものでも、`C-M-v' を使うこ
     とによって、手動で記事のページを見ることはできます。

`DEL'
     現在の記事を一ページ前にスクロールします
     (`gnus-summary-prev-page')。

`RET'
     現在の記事を一行先にスクロールします (`gnus-summary-scroll-up')。

`M-RET'
     現在の記事を一行後ろへスクロールします
     (`gnus-summary-scroll-down')。

`A g'
`g'
     現在の記事を (再) 取得します。もし接頭引数が与えられると、現在の記
     事を取得しますが、記事をトリートメントする関数は実行しません。これ
     は、サーバーから来たままの『生の』記事をもたらします。

     接頭引数を与えると、手動で文字セットの操作を行なうことができます。
     `C-u 0 g cn-gb-2312 RET' により、メッセージはあたかも
     `cn-gb-2312' 文字セットでエンコードされたかのようにデコードされま
     す。以下のような設定を用意しておくと、`C-u 1 g' で同じ効果を得るこ
     とができます。

          (setq gnus-summary-show-article-charset-alist
                '((1 . cn-gb-2312)
                  (2 . big5)))

`A <'
`<'
     記事の最初までスクロールします。
     (`gnus-summary-beginning-of-article')。

`A >'
`>'
     記事の最後までスクロールします (`gnus-summary-end-of-article')。

`A s'
`s'
     記事バッファーでインクリメンタルサーチ (isearch) を行ないます
     (`gnus-summary-isearch-article')。

`h'
     記事バッファーを選択します (`gnus-summary-select-article-buffer')。



File: gnus-ja.info, Node: Reply Followup and Post, Next: Delayed Articles, Prev: Paging the Article, Up: Summary Buffer

返答、フォローアップ、投稿
==========================

* Menu:

* Summary Mail Commands::       メールを送る
* Summary Post Commands::       ニュースを送る
* Summary Message Commands::    他のメッセージ関連の命令
* Canceling and Superseding::



File: gnus-ja.info, Node: Summary Mail Commands, Next: Summary Post Commands, Prev: Reply Followup and Post, Up: Reply Followup and Post

概略でのメールの命令
--------------------

メールメッセージを作成するための命令:

`S r'
`r'
     現在の記事を書いた人に返答のメールを送ります
     (`gnus-summary-reply')。

`S R'
`R'
     現在の記事を書いた人に、元記事を含んだ返答のメールを出します
     (`gnus-summary-reply-with-original')。この命令はプロセス/接頭引数
     の習慣を使います。

`S w'
     現在の記事を書いた人に対して、広い返答 (wide reply) をします
     (`gnus-summary-wide-reply')。「広い返答」とはヘッダーの `To',
     `From', (もしくは `Reply-to') と `Cc') のすべての人に返答をするこ
     とです。`Mail-Followup-To' があれば、代わりにそれが使われます。

`S W'
     現在の記事に元記事を含んだ広い返答のメールを送ります
     (`gnus-summary-wide-reply-with-original')。この命令はプロセス/接頭
     引数の習慣を使います。

`S v'
     現在の記事を書いた人に対して、非常に広い返答 (very wide reply) を
     します (`gnus-summary-very-wide-reply')。「非常に広い返答」とは、
     プロセス/接頭引数で指定されたすべての記事のヘッダーの `To',
     `From', (もしくは `Reply-to') と `Cc') のすべての人に返答をするこ
     とです。この命令はプロセス/接頭引数の習慣を使います。

`S V'
     現在の記事に元記事を含んだ非常に広い返答のメールを送ります
     (`gnus-summary-very-wide-reply-with-original')。この命令はプロセス
     /接頭引数の習慣を使います。

`S B r'
     現在の記事を書いた人に対して返答をしますが `Reply-To' フィールドは
     無視します (`gnus-summary-reply-broken-reply-to')。メーリングリス
     トがそのリストを指す `Reply-To' を過って設定するためにこれが必要な
     のであれば、おそらくあなたは代わりに `broken-reply-to' グループパ
     ラメーターを設定する必要があります。そうすれば、ものごとは正しく働
     くようになるでしょう。*Note Group Parameters::.

`S B R'
     現在の記事を書いた人に対して元記事を含んだ返答をしますが
     `Reply-To' フィールドは無視します
     (`gnus-summary-reply-broken-reply-to-with-original')。

`S o m'
`C-c C-f'
     誰か他の人に現在の記事を転送します (`gnus-summary-mail-forward')。
     接頭引数が与えられない場合、メッセージは
     `message-forward-as-mime' および `message-forward-show-mml' の値に
     従ったやり方で転送されます。接頭引数が 1 だったら、デコードされた
     メッセージが直接埋め込まれた転送用のバッファーが作られます。2 だっ
     たら rfc822 形式の MIME パートが挿入されます。この場合、元のメッセー
     ジはデコードされません。3 ではデコードされた rfc822 形式の MIME パー
     トが挿入されます (実際に送信する際に再びエンコードされます)。接頭
     引数 4 では、1 の場合と同じ動作になります。接頭引数がこれら以外の
     場合には、`message-forward-as-mime' の値を一時的に反転して、接頭引
     数が与えられなかった場合と同じ動作を行ないます。ディフォルトでは、
     デコードされたメッセージが rfc822 形式の MIME パートとして生成され
     ます。

`S m'
`m'
     メールを作成します (`gnus-summary-mail-other-window')。ディフォル
     トでは現在のグループの投稿様式 (posting style) を使います。接頭引
     数が与えられると、それは使いません。もし接頭引数が 1 だったら、ど
     のグループの投稿様式を使うかを尋ねます。

`S i'
`i'
     ニュースを作成します (`gnus-summary-news-other-window')。ディフォ
     ルトでは現在のグループに投稿します。接頭引数が与えられると、現在の
     グループ名は使われません。もし接頭引数が 1 だったら、どのグループ
     に投稿するかを尋ねます。

     この関数は、たとえメールグループで使われたとしても、実際にはニュー
     スの様式を用意します。これは、メッセージを実際にはネットワーク経由
     で送らずに、メールグループに「投稿」するのに便利です; それらは当の
     グループに単に直接セーブされます。対応するバックエンドが投稿のため
     のメソッド (request-post method) を持っていなければなりませんが。

`S D b'
     メールを送ったのに、何らかの理由 (アドレスの間違い、転送の不調) で
     戻ってきたときに、この命令を使って戻ってきたメールをもう一回送るこ
     とができます (`gnus-summary-resend-bonced-mail')。メールバッファー
     にそのメールが現れて、そこでもう一度メールを送る前にヘッダーを編集
     することができます。この命令に接頭引数を与えると、戻ってきたメール
     が何か他のメールへの返答であった場合に、Gnus はそのメールを取得し
     て、それのヘッダーの精密調査ができるように画面に表示しようとします。
     ま、これはとてもよく失敗しますけど。

`S D r'
     上の命令と混同しないで下さい。`gnus-summary-resend-message' は現在
     のメッセージを送る宛先のアドレスの入力を促して、その場所にメールを
     送ります。メッセージのヘッダーは変更されません--しかし
     `Resent-To', `Resent-From' などの、たくさんのヘッダーが付け加えま
     す。これは、(おそらく) あなた自身を `To' 欄に書いた本人にもメール
     を送ってしまうということです。これは混乱を招くでしょう。ですから当
     然、あなたが本当に邪悪な人でなければ、これは使わないでしょう。

     この命令は主に、あなたがいくつかのメールアカウントを持っていて、自
     分自身の違ったアカウントにメールを転送したいときに用いられます。
     (もしあなたが `root' であり、`postmaster' でもあり、`root' 宛てに
     `postmaster' へのメールを受け取った場合は、それを `postmaster' に
     も再送する必要があるかもしれません。秩序がなければなりません!
     (Ordnung muss sein!))

     この命令はプロセス/接頭引数の習慣に従います (*Note
     Process/Prefix::)。

`S D e'
     一つ前のコマンドに似ていますが、再送する前にあたかも新しいメッセー
     ジのように編集することができます。

`S O m'
     現在の一連の記事 (*Note Decoding Articles::) の要約を作り、メール
     でその結果を送ります (`gnus-uu-digest-mail-forward')。この命令はプ
     ロセス/接頭引数の習慣に従います (*Note Process/Prefix::)。

`S M-c'
     現在の記事の書き手に、過剰なクロスポストへの苦情のメールを送ります
     (`gnus-summary-mail-crosspost-complaint')。

     この命令は、現在 Usenet に横行しているクロスポストの世界的流行に対
     して反撃を行なう手段として提供されています。これは変数
     `gnus-crosspost-complaint' を序文にして返答を作成します。この命令
     はプロセス/接頭引数の習慣 (*Note Process/Prefix::) に従い、それぞ
     れのメールを送る前に送信するかどうかの確認をします。

また *Note ヘッダー命令: (message-ja)Header Commands, にさらなる情報が
あります。



File: gnus-ja.info, Node: Summary Post Commands, Next: Summary Message Commands, Prev: Summary Mail Commands, Up: Reply Followup and Post

概略の投稿命令
--------------

ニュースの記事を投稿するための命令:

`S p'
`a'
     投稿するための記事を作成します (`gnus-summary-post-news')。ディフォ
     ルトでは現在のグループに投稿します。接頭引数が与えられると、現在の
     グループ名は使われません。もし接頭引数が 1 だったら、代わりに別の
     どのグループに投稿するかを尋ねます。

`S f'
`f'
     現在の記事のフォローアップを投稿します (`gnus-summary-followup')。

`S F'
`F'
     元記事を取り込んで、現在の記事にフォローアップをします
     (`gnus-summary-followup-with-original')。この命令はプロセス/接頭引
     数の習慣を用います。

`S n'
     メールのメッセージを受け取っていたとしても、現在の記事のフォローアッ
     プをニュースに投稿します (`gnus-summary-followup-to-mail')。この命
     令はプロセス/接頭引数の習慣を用います。

`S N'
     メールのメッセージを受け取っていたとしても、元記事を引用して、現在
     の記事のフォローアップをニュースに投稿します
     (`gnus-summary-followup-to-mail-with-original'). この命令はプロセ
     ス/接頭引数の習慣を用います。

`S o p'
     現在の記事をニュースグループに転送します
     (`gnus-summary-post-forward')。接頭引数が与えられない場合、メッセー
     ジは `message-forward-as-mime' および `message-forward-show-mml'
     の値に従ったやり方で転送されます。接頭引数が 1 だったら、デコード
     されたメッセージが直接埋め込まれた転送用のバッファーが作られます。
     2 だったら rfc822 形式の MIME パートが挿入されます。この場合、元の
     メッセージはデコードされません。3 ではデコードされた rfc822 形式の
     MIME パートが挿入されます (実際に送信する際に再びエンコードされま
     す)。接頭引数 4 では、1 の場合と同じ動作になります。接頭引数がこれ
     ら以外の場合には、`message-forward-as-mime' の値を一時的に反転して、
     接頭引数が与えられなかった場合と同じ動作を行ないます。ディフォルト
     では、デコードされたメッセージが rfc822 形式の MIME パートとして生
     成されます。

`S O p'
     現在の一連の記事を要約して、その結果をニュースグループに送ります
     (`gnus-uu-digest-post-forward')。この命令はプロセス/接頭引数の習慣
     を用います。

`S u'
     ファイルを uuencode して分割し、それらを連続して投稿します
     (`gnus-uu-post-news')。(*Note Uuencoding and Posting::)。

また *Note ヘッダー命令: (message-ja)Header Commands, にさらなる情報が
あります。



File: gnus-ja.info, Node: Summary Message Commands, Next: Canceling and Superseding, Prev: Summary Post Commands, Up: Reply Followup and Post

概略メッセージ命令
------------------

`S y'
     現在の記事を、すでに存在するメッセージ作成バッファーに貼り付けます
     (`gnus-summaryyank-message')。この命令は貼り付けたいメッセージバッ
     ファーの入力を促し、プロセス/接頭引数の習慣を理解します (*Note
     Process/Prefix::)。



File: gnus-ja.info, Node: Canceling and Superseding, Prev: Summary Message Commands, Up: Reply Followup and Post

記事を取り消す
--------------

何かを書いた後で、本当に、本当に、ほ ん と う にそれを投稿していなけれ
ばなぁと思ったことはありませんか。

えーと、メールは取り消すことはできないのですが、ニュースの投稿は取り消
すことができます。

取り消したい記事を見つけて下さい (取り消すことができるのは自分の記事だ
けです。変なことは試さないで下さい)。そして `C' か `S c' を押して下さい
(`gnus-summary-cancel-article')。あなたの記事が取り消されます--世界中の
機械があなたの記事を取り消します。この命令はプロセス/接頭引数の習慣を用
います (*Note Process/Prefix::)。

しかし注意して欲しいのは、すべてのサイトが取り消しを扱っているわけでは
ないことです。ですから、たいていのサイトが問題の記事を取り消しても、あ
ちこちであなたの記事は生き残るかもしれません。

Gnus は取り消すときに『現在』の選択方法を使います。標準の投稿方法を使い
たいのであれば、文字接頭引数 `a' を使って下さい (*Note Symbolic
Prefixes::)。

Gnus は `Cancel-Lock' ヘッダー (*Note ニュースを取り消す:
(message-ja)Canceling News.) を使って、あなただけがあなたのメッセージを
キャンセルできるようにします。

もし何か間違いをしたのに気付いて、訂正をしたいのであれば、「代替」
("superseding") 記事を投稿して元記事を置き換えることができます。

元記事のところへ移動して、`S s' を押して下さい
(`gnus-summary-supersede-article')。それを普通に送信する前に、記事を好
きなように編集することができます。

代替に関しても、取り消しと同じことが当てはまります。こちらの方がもっと
よく当てはまるかもしれません: いくつかのサイトは代替を受け付けません。
これらのサイトでは、ほとんど同じ記事を二回投稿したようになってしまいま
す。

もしさっき記事を投稿したばかりですぐに変更したくなった場合、記事が最初
にあなたのサイトに現れる前に取り消し/代替をするための巧妙な手段がありま
す。まず、投稿バッファー (`*sent ... *' のようになっています) に戻って
下さい。そこにはあなたがちょうど投稿した記事があり、すべてのヘッダーが
そのままあります。`Message-ID' ヘッダーを `Cancel' もしくは
`Supersedes' に変更して下さい。そして、いつもやっているように単に `C-c
C-c' を押して記事を送信して下さい。前の記事は取り消されるか置き換えられ
るでしょう。

ちょっと覚えておいて下さい: 'supersede' (代替) という語の中に 'c' は無
いということを。



File: gnus-ja.info, Node: Delayed Articles, Next: Marking Articles, Prev: Reply Followup and Post, Up: Summary Buffer

遅延記事
========

ときとして、あなたはメッセージの送信を先延ばしにしたいと思うことはありま
せんか。例えば、あなたが大切なだれかの誕生日を思い出すために、ちょうどそ
の日に届くメッセージを用意したいと思ったとしましょう。
`gnus-delay' パッケージはこれにうってつけです。設定は簡単です:

     (gnus-delay-initialize)

普段はメッセージを送信するのに Message モードで `C-c C-c' コマンドを使
いますよね。先延ばしにするには、代わりに `C-c C-j'
(`gnus-delay-article') を使って下さい。そうすると、どのくらい遅らせるか
を尋ねてきます。可能な返事は次の通りです:

   * 期間。整数と一つの文字で指定します。例えば `42d' は 42 日遅らせるこ
     とを意味します。使うことができる文字は `m' (分)、`h' (時)、
     `d' (日), `w' (週), `M' (月) および `Y' (年) です。

   * 日付。`YYYY-MM-DD' のような形式で指定します。メッセージの送信はその
     日の特定の時刻 (ディフォルトは 8 時) まで遅らせられます。
     `gnus-delay-default-hour' も参照して下さい。

   * 時刻。am/pm を含まない 24 時間制の、`hh:mm' の形式で与えます。送信
     されるのは今日のその時刻ですが、すでにその時刻を過ぎてしまっていた
     場合は翌日のその時刻になります。ですから、朝の 10 時に `11:15' を
     指定した場合は 1時間15分後に送信されることになります。しかし
     `9:20' を指定した場合は翌日の時刻を意味します。

`gnus-delay-article' の動作は、以下の数個の変数に影響されます:

`gnus-delay-default-hour'
     特定の日付を指定した場合に、メッセージがその日の何時に送信されるか
     を与えます。可能な値は 0 から 23 までの整数です。

`gnus-delay-default-delay'
     ディフォルトの遅延を与える文字列です。前述のどんな形式でも可能です。

`gnus-delay-group'
     遅延記事は、ドラフトサーバーのこのグループに期限が来るまで保管され
     ます。たぶんあなたはこれを変更する必要は無いでしょう。ディフォルト
     の値は `"delayed"' です。

`gnus-delay-header'
     それぞれの記事が送信される日時はヘッダーに記録されます。この変数は
     ヘッダー名の文字列です。たぶんあなたはこれを変更する必要は無いでしょ
     う。ディフォルトの値は `"X-Gnus-Delayed"' です。

送信の先延ばしはこんなふうに行なわれます: `gnus-delay-article' コマンド
で、あなたはどのくらい遅らせるかを指定します。Gnus はメッセージを送信す
る日時を計算して `X-Gnus-Delayed' ヘッダーに記録し、そのメッセージを
`nndraft:delayed' グループに納めます。

そして、あなたが新着ニュースを取得しようとするときはいつも、Gnus は送信
する期限に達した記事をそのグループで探して、それらを送信します。これに
は関数 `gnus-delay-send-queue' が使われます。ディフォルトではこの関数は
`gnus-get-new-news-hook' に追加されますが、もちろんあなたはこれを変更す
ることができます。おそらくあなたは、ドラフトの送信にデーモンを使いたい
と思うのではないでしょうか? それには、デーモンに関数
`gnus-delay-send-queue' を実行せよ、と言うだけで良いのです。

`gnus-delay-initialize'
     ディフォルトではこの関数は `gnus-delay-send-queue' の
     `gnus-get-new-news-hook' への追加を行ないます。ですが、これは第二
     オプション引数 `no-check' を受け付けます。もしそれが非-`nil' だっ
     たら `gnus-get-new-news-hook' は変更されません。第一オプション引数
     は無視されます。

     例えば `(gnus-delay-initialize nil t)' は何もしないことを意味しま
     す。あなたは遅延記事の送信にデーモンを使いたいのでしょうね。でも、
     それを設定することを忘れないで下さいね。:-)



File: gnus-ja.info, Node: Marking Articles, Next: Limiting, Prev: Delayed Articles, Up: Summary Buffer

記事に印を付ける
================

記事に付けられる印はいくつかあります。

記事の「購読度」(うひょーっ、何てすらばやしい造語だ!) を決定する印があ
ります。英字でない文字が一般に「未読」を意味するのに対して、英字の印は
一般に「既読」を意味します。

加えて、購読度に影響しない印もあります。

これらの印を操作する過剰なくらいの命令があります:

* Menu:

* Unread Articles::             未読記事への印
* Read Articles::               既読記事への印
* Other Marks::                 購読度に影響しない印
* Setting Marks::               印の付け方と消し方
* Generic Marking Commands::    印をどのようにカスタマイズするか
* Setting Process Marks::       後の実行のための記事の印の付け方



File: gnus-ja.info, Node: Unread Articles, Next: Read Articles, Prev: Marking Articles, Up: Marking Articles

未読記事
--------

以下の印は何らかの方法で記事に未読の (ような) 印を付けます。

`!'
     可視記事 (ticked) として印を付けます (`gnus-ticked-mark')。

     「可視記事」とは常に可視状態である記事のことです。おもしろいと思う
     記事があった場合や、読むのを先に延ばしたいときや、後で返答をしたい
     ときに、普通は可視印を付けます。しかし、記事は期限切れ消去されるこ
     ともあります (ニュースサーバー上の記事を消去するのはニュースサーバー
     のソフトウェアで、Gnus 自体は可視記事を期限切れ消去しません) ので、
     永遠に記事を保存しておきたい場合は、その記事を永続にする必要があり
     ます (*Note Persistent Articles::)。

`?'
     保留として印を付けます (`gnus-dormant-mark')。

     「保留記事」はフォローアップがあったときにだけ概略バッファーに現れ
     ます。フォローアップが無いときも表示させたいときは、`/ D' 命令を使っ
     て下さい (*Note Limiting::)。それ以外は (見えるかどうかは別にして)、
     可視記事 (ticked) と似たようなものです。

`SPACE'
     未読として印を付けます (`gnus-unread-mark')。

     「未読記事」は今までまったく読まれていない記事のことです。



File: gnus-ja.info, Node: Read Articles, Next: Other Marks, Prev: Unread Articles, Up: Marking Articles

既読記事
--------

以下のすべての印は記事に既読の印を付けます。

`r'
     利用者が手動で `d' 命令もしくはそれに類する手段を使って、既読の印
     を付けた記事です (`gnus-del-mark')。

`R'
     実際に読まれた記事 (`gnus-read-mark')。

`O'
     前回のセッションで既読の印を付けて、今は「古く」なってしまった記事。

`K'
     削除された印 (`gnus-killed-mark')。

`X'
     削除ファイルによって削除の印が付いた記事 (`gnus-kill-file-mark')。

`Y'
     低すぎるスコアのために既読の印が付いた記事
     (`gnus-low-score-mark')。

`C'
     キャッチアップによって既読の印が付いた記事 (`gnus-catchup-mark')。

`G'
     取り消された記事 (`gnus-canceled-mark')。

`F'
     SOUP されている記事 (`gnus-souped-mark')。*Note SOUP::.

`Q'
     まばらに参照された記事 (`gnus-sparse-mark')。
     *Note Customizing Threading::.

`M'
     重複抑制により既読の印の付いた記事 (`gnus-duplicate-mark')。
     *Note Duplicate Suppression::.

これらのすべての印は、本当にただ記事が既読として印が付いていることを意
味するだけです。適応スコアリングをしたときには違ったように解釈されます
けれど。

もう一つ、特別な印があります:

`E'
     期限切れ消去可能として印の付いた記事 (`gnus-expirable-mark')。

     記事を「期限切れ消去可能」として印を付ける (もしくは、自動的にその
     ように印を付ける) ことは、普通のグループではあまり意味がありませ
     ん--利用者はニュース記事の期限による削除を制御していません。しかし、
     例えばメールグループでは、「期限切れ消去可能」として印の付いた記事
     は、いつでも Gnus によって削除されることがあります。



File: gnus-ja.info, Node: Other Marks, Next: Setting Marks, Prev: Read Articles, Up: Marking Articles

他の印
------

記事が読まれたかどうかには関係しない印がいくつかあります。


   * 現在の記事にしおりを挟むことができます。あなたは猫のおしっこの習慣に関す
     る長い論文を読んでいて、それを読み終わる前に晩ご飯を食べに家に帰らなけれ
     ばならなかったとしましょう。そんなとき、記事にしおりを挟むことができます。
     次にその記事に出くわすと、Gnus はそのしおりのところへ移動するでしょう。
     *Note Setting Marks::.

   * 返信したかフォローアップした (つまり、答えた) すべての記事には、二
     桁目に `A' の印が付きます (`gnus-replied-mark')。

   * 転送したすべての記事には、二桁目に `F' の印が付きます
     (`gnus-forwarded-mark')。

   * 記事キャッシュに貯められている記事は、二桁目に `*' の印が付きます
     (`gnus-replied-mark')。*Note Article Caching::.

   * (何らかの方法によって; 必ずしも宗教的というわけではなく) 『救済さ
     れた』(原文は saved==保存された) 記事は、二桁目に `S' の印が付きま
     す (`gnus-saved-mark')。

     まだサーバーが利用者に見せていない記事は、二桁目に `N' の印が付き
     ます (`gnus-recent-mark')。たいていのサーバーはこの印をサポートせ
     ず、その場合は単に表示されません。`gnus-unseen-mark' と見比べて下
     さい。

   * まだ Gnus で読まれたことがない記事は、二桁目に `.' の印が付きます
     (`gnus-unseen-mark')。`gnus-recent-mark' と見比べて下さい。

   * Gnus エージェント (*Note Agent Basics::) を使っているとき、記事は
     unplugged (ネットワークから切り離されている状態) で見るためにダウ
     ンロードされるかもしれません。`%O' の仕様を使っていると、それらの
     記事にはその仕様に `+' の印が付きます。(変数
     `gnus-downloaded-mark' でどの文字を使うかを制御します。)

   * Gnus エージェント (*Note Agent Basics::) を使っているとき、いくつ
     かの記事はダウンロードされていないかもしれません。Unplugged (ネッ
     トワークから切り離されている状態) ではそのような記事を見ることがで
     きません。`%O' の仕様を使っていると、それらの記事にはその仕様に
     `-' の印が付きます。(変数 `gnus-undownloaded-mark' でどの文字を使
     うかを制御します。)

   * Gnus エージェント (*Note Agent Basics::) はいくつかの記事を自動的
     にダウンロードしますが、自動的にダウンロードされない記事にもダウン
     ロードのための明示的な印を付けることは可能です。そのような明示的に
     印が付けられた記事には、最初の桁に `%' の印が付きます。(変数
     `gnus-downloadable-mark' でどの文字を使うかを制御します。)

   * `%e' の仕様が使われると、スレッドがあるかどうかの印が
     `gnus-not-empty-thread-mark' または `gnus-empty-thread-mark' によっ
     て、三桁目に付きます。

   * 最後に「プロセス印」があります (`gnus-process-mark')。いろいろな種
     類の命令が、プロセス印があるとそれに対して実行されます。例えば `X
     u' (`gnus-uu-decode-uu') は、プロセス印の付いたすべての記事を
     uudecode して表示します。プロセス印の付いた記事は二桁目に `#' があ
     ります。

たいていのこれら『購読度と関係無い』印は、ディフォルトでは二桁目に現れ
ることに気付いたでしょう。では、キャッシュされていて、保存されていて、
返答した記事にプロセス印を付けた場合は、どうなるのでしょう?

たいしたことはありません。優先順位は次のようになっています: プロセス →
キャッシュ → 返答済み → 保存。ですから、ある記事がキャッシュに入って
いて返答されていた場合、キャッシュ印が見えるだけで、返答済み印は見えま
せん。



File: gnus-ja.info, Node: Setting Marks, Next: Generic Marking Commands, Prev: Other Marks, Up: Marking Articles

印を付ける
----------

すべての印を付けるための命令は、数値接頭引数を受け付けます。

`M c'
`M-u'
     現在の記事から、すべての購読度に関する印を消去します
     (`gnus-summary-clear-mark-forward')。要するに、記事に未読の印を付
     けます。

`M t'
`!'
     現在の記事に可視記事の印を付けます
     (`gnus-summary-tick-article-forward')。*Note Article Caching::.

`M ?'
`?'
     現在の記事に保留記事の印を付けます
     (`gnus-summary-mark-as-read-forward')。*Note Article Caching::.

`M d'
`d'
     現在の記事に既読の印を付けます
     (`gnus-summary-mark-as-read-forward')。

`D'
     現在の記事に既読の印を付け、前の行にポイントを移動します
     (`gnus-summary-mark-as-read-backward')。

`M k'
`k'
     現在の記事と同じ表題を持つすべての記事を既読として印を付け、次の未
     読記事を選択します (`gnus-summary-kill-same-subject-and-select')。

`M K'
`C-k'
     現在の記事と同じ表題を持つすべての記事を既読として印を付けます
     (`gnus-summary-kill-same-subject')。

`M C'
     すべての未読記事に既読の印を付けます (`gnus-summary-catchup')。

`M C-c'
     グループのすべての記事に--可視記事や保留記事でさえも、既読の印を付
     けます (`gnus-summary-catchup-all')。

`M H'
     現在のグループの、現在位置とそれ以前の記事を既読として印を付けます
     (`gnus-summary-catchup-to-here')。

`M h'
     現在のグループの、現在位置とそれ以降の記事を既読として印を付けます
     (`gnus-summary-catchup-from-here')。

`C-w'
     ポイントとマークの間の記事に既読の印を付けます
     (`gnus-summary-mark-region-as-read')。

`M V k'
     ディフォルトのスコア (もしくは数値接頭引数) よりも低いスコアの記事
     を削除します。

`M e'
`E'
     現在の記事を期限切れ消去可能として印を付けます
     (`gnus-summary-mark-as-expirable')。

`M b'
     現在の記事にしおりを設定します (`gnus-summary-set-bookmark')。

`M B'
     現在の記事のしおりを削除します (`gnus-summary-remobe-bookmark')。

`M V c'
     ディフォルトのスコア (もしくは数値接頭引数) よりも大きいスコアを持
     つ記事のすべての印を消去します (`gnus-summary-clar-above')。

`M V u'
     ディフォルトのスコア (もしくは数値接頭引数) よりも大きいスコアを持
     つすべての記事に可視印を付けます (`gnus-summary-tick-above')。

`M V m'
     印の入力を促し、ディフォルトのスコア (もしくは数値接頭引数) よりも
     大きなスコアを持つすべての記事にその印を付けます
     (`gnus-summary-mark-above')。

変数 `gnus-summary-goto-unread' は印が付けられた後にどのような動作がな
されるかを決定します。もし `nil' でないと、ポイントは次/前の未読記事に
移動します。もし `nil' であると、ポイントは一行上か下に行くだけです。特
別な場合として、この変数が `never' であると、すべての印を付ける命令と
(`SPACE' のような) 他の命令は次の記事が未読であろうが無かろうが次の記事
に移動します。ディフォルトは `t' です。



File: gnus-ja.info, Node: Generic Marking Commands, Next: Setting Process Marks, Prev: Setting Marks, Up: Marking Articles

Generic Marking Commands
------------------------

記事に可視の印を付ける命令 (`!') に、次の記事に移動してもらいたい人がい
ます。次の未読記事に移動してもらいたい人もいます。さらに、現在の記事に
留まっていてもらいたい人もいるでしょう。そして、前の (未読の) 記事に行っ
て欲しい人がいるとはまだ聞いたことはありませんが、そうしたいと思う人も
間違いなくいると思います。

この五つの動作を五つの違った印付け命令と掛け算すると、どの命令が何をす
べきかの非常に複雑な変数の組を持つことになります。

この窮地を脱するために、Gnus はこれらすべての違ったことをする命令を提供
します。これらは概略バッファーの `M M' マップにあります。すべてを見るた
めには `M M C-h' を入力して下さい--このマニュアルで一覧を出すには多過ぎ
ます。

これらの命令を直接使うことはできますが、ほとんどの利用者は概略モードの
キーマップを交換する方を好むでしょう。例えば、`!' 命令に次の未読記事の
代わりに次の記事に移動して欲しいとすると、このようなことができます:

     (add-hook 'gnus-summary-mode-hook 'my-alter-summary-map)
     (defun my-alter-summary-map ()
       (local-set-key "!" 'gnus-summary-put-mark-as-ticked-next))

もしくは、

     (defun my-alter-summary-map ()
       (local-set-key "!" "MM!n"))



File: gnus-ja.info, Node: Setting Process Marks, Prev: Generic Marking Commands, Up: Marking Articles

プロセス印を付ける
------------------

プロセス印は概略バッファーに `#' として表示され、他のコマンドで処理させ
る記事に印を付けるために使われます。例えば、四つの記事に印を付けてから
`*' コマンドを使うと、Gnus はそれら四つの記事をキャッシュに入れます。詳
しくは *Note Process/Prefix:: をどうぞ。

`M P p'
`#'
     現在の記事にプロセス印を付けます
     (`gnus-summary-mark-as-processable')。

`M P u'
`M-#'
     もし現在の記事にプロセス印があれば取り除きます
     (`gnus-summary-unmark-as-processable')。

`M P U'
     すべての記事からプロセス印を取り除きます
     (`gnus-summary-unmark-all-processable')。

`M P i'
     プロセス印の付いている記事とそうでない記事を逆にします
     (`gnus-uu-mark-by-regexp')。

`M P R'
     正規表現に合致する `Subject' ヘッダーを持つ記事に印を付けます
     (`gnus-uu-mark-by-regexp')。

`M P G'
     正規表現に合致する `Subject' ヘッダーを持つ記事から印を削除します
     (`gnus-uu-unmark-by-regexp')。

`M P r'
     領域にある記事に印を付けます (`gnus-uu-mark-region')。

`M P g'
     領域にある記事から印を削除します (`gnus-uu-unmark-region')。

`M P t'
     現在のスレッド (または副スレッド) のすべての記事に印を付けます
     (`gnus-uu-mark-thread')。

`M P T'
     現在のスレッド (または副スレッド) のすべての記事から印を取り除きま
     す (`gnus-uu-unamrk-thread')。

`M P v'
     接頭引数よりも大きなスコアを持つすべての記事に印を付けます
     (`gnus-uu-mark-over')。

`M P s'
     現在の一連の記事に印を付けます (`gnus-uu-mark-series')。

`M P S'
     すでにいくつか印の付いた記事を持つ一連の記事群すべてに印を付けます
     (`gnus-uu-mark-sparse')。

`M P a'
     一連の記事が出てくる順番にそれに属するすべての記事に印を付けます
     (`gnus-uu-mark-all')。

`M P b'
     バッファーのすべての記事を現れている順番に印を付けます
     (`gnus-uu-mark-buffer')。

`M P k'
     現在のプロセス印をスタックに積んで、すべての記事を無印にします
     (`gnus-summary-kill-process-mark')。

`M P y'
     スタックから前回のプロセス印を取り出して、それを復元します
     (`gnus-summary-yank-process-mark')。

`M P w'
     現在のプロセス印をスタックに積みます
     (`gnus-summary-save-process-mark')。

そして、記事の本文の内容に基づいてプロセス印を付けるやり方については、
*Note Searching for Articles:: の `&' 命令を参照して下さい。



File: gnus-ja.info, Node: Limiting, Next: Threading, Prev: Marking Articles, Up: Summary Buffer

制限をする
==========

現在グループにある記事の一部だけを表示するように概略バッファーを制限で
きれば便利なことがあります。多くの制限命令が持つ効果は、概略バッファー
から少し (もしくは多く) の記事を削除することです。

すべての制限命令はサーバーからすでに取得された記事の一部分に作用します。
これらの命令はどれもサーバーに追加の記事を要求しません。

`/ /'
`/ s'
     概略バッファーをいくつかの表題と合致するものだけに制限します
     (`gnus-summary-limit-to-subject')。接頭引数が与えられると、合致す
     る記事を除外します。

`/ a'
     概略バッファーを何人かの著者に合致するものだけに制限します
     (`gnus-summary-limit-to-author')。接頭引数が与えられると、合致する
     記事を除外します。

`/ R'
     概略バッファーをいくつかの受信者に合致する記事だけに制限します
     (`gnus-summary-limit-to-recipient')。接頭引数が与えられると、合致
     する記事を除外します。

`/ x'
     「追加」のヘッダーの一つに合致する記事に概略バッファーを制限します
     (*Note To From Newsgroups::) (`gnus-summary-limit-to-extra')。接頭
     引数が与えられると、合致する記事を除外します。

`/ u'
`x'
     概略バッファーを既読の印が付いていない記事に制限します
     (`gnus-summary-limit-to-unread')。接頭引数が与えられると、バッファー
     を完全に未読記事のみに制限します。これは、可視と保留の記事は含まれ
     ないということです。

`/ m'
     印を尋ねて、その印が付いている記事に制限します
     (`gnus-summary-limit-to-marks')。

`/ t'
     数値を尋ねて、概略バッファーをその日数より古い (もしくは同じ) 記事
     に制限します (`gnus-summary-limit-to-age')。接頭引数が与えられると、
     その数値の日よりも新しい記事に制限します。

`/ n'
     概略バッファーを現在の記事に制限します
     (`gnus-summary-limit-to-articles')。プロセス/接頭引数の習慣を使い
     ます (*Note Process/Prefix::)。

`/ w'
     前の制限をスタックから取り出して、復元します
     (`gnus-summary-pop-limit')。接頭引数を与えられると、すべての制限を
     スタックから取り出します。

`/ .'
     概略バッファーをまだ読まれたことが無い記事に制限します
     (`gnus-summary-limit-to-unseen')。

`/ v'
     概略バッファーをあるスコアと同じか、それより大きなスコアを持つ記事
     に制限します (`gnus-summary-limit-to-score')。

`/ p'
     概略バッファーを `display' グループパラメーターの述語を満足させる
     ように制限します (`gnus-summary-limit-to-display-predicate')。この
     述語に関する詳細は *Note Group Parameters:: を参照して下さい。

`/ r'
     概略バッファーを返信した記事だけに制限します
     (`gnus-summary-limit-to-replied')。接頭引数が与えられると、返信し
     た記事以外の記事に制限します。

`/ E'
`M S'
     すべての消去された記事を制限に含めます
     (`gnus-summary-limit-include-expunged')。

`/ D'
     すべての保留記事を制限に含めます
     (`gnus-summary-limit-include-dormant')。

`/ *'
     すべてのキャッシュに入っている記事を制限に含めます
     (`gnus-summary-limit-include-cached')。

`/ d'
     すべての保留記事を制限から除外します
     (`gnus-summary-limit-exclude-dormant')。

`/ M'
     すべての印付き記事を除外します
     (`gnus-summary-limit-exclude-marks')。

`/ T'
     現在のスレッドのすべての記事を制限に含めます
     (`gnus-summary-limit-include-thread')。

`/ c'
     子記事の無いすべての保留記事を制限から除外します
     (`gnus-summary-limit-exclude-childless-dormant')。

`/ C'
     すべての除外された未読の記事に既読の印を付けます
     (`gnus-summary-limit-mark-excluded-as-read')。接頭引数が与えられる
     と、可視と保留のみの印の記事も既読として印を付けます。

`/ N'
     すべての新しい記事を概略バッファーに挿入します。
     BACK-END`-get-new-mail' が非-`nil' だったら、新しいメールの到来を
     調べるということです。

`/ o'
     すべての古い記事を概略バッファーに挿入します。数値の接頭引数が与え
     られると、その個数の記事を取り込みます。



File: gnus-ja.info, Node: Threading, Next: Sorting the Summary Buffer, Prev: Limiting, Up: Summary Buffer

スレッド
========

Gnus はディフォルトで記事をスレッド表示します。「スレッドにする」とは、
ある記事への応答を応答した記事の直後に置く--階層的流儀で、ということで
す。

スレッドは記事の `References' 欄を調べることによって行なわれます。理想
的な世界では、これだけで木を完成させるのに十分なのですが、不運なことに
`References' 欄はしばしば壊れているか、時には単に無いことがあります。怪
しげなニュースの伝搬は問題を悪化させるので、満足な結果を得るためには他
の検出法を採用しなければなりません。過剰な対策法は存在していて、その恐
るべき詳細は *Note Customizing Threading:: に詳しく書いてあります。

まず、概念の概観です:

"根本 (root)"
     スレッドで一番頂点にある記事です；スレッドの最初の記事です。

"スレッド (thread)"
     木のような記事の構成です。

"副スレッド (sub-thread)"
     木のような構造の (より) 小さな部分です。

"無束縛スレッド (loose threads)"
     記事の期限切れ消去や、根本がすでに前回のセッションで読まれたことに
     より概略バッファーに表示されない、等の理由により、スレッドはしばし
     ば根本を失います。そのようなときには、普通は多くの副スレッドがあっ
     て、本当は一つのスレッドに属しているのですが、根本にはつながってい
     ない、ということになります。こういうスレッドが無束縛スレッドと呼ば
     れています。

"スレッド集め (thread gathering)"
     副スレッドを大きなスレッドに集めようとする試みです。

"まばらスレッド (sparse threads)"
     そこではたぶんいくつかの記事が失われてしまったのだろうと『推測され
     た』スレッドのことで、概略バッファーでは空行で表示されます。

* Menu:

* Customizing Threading::       スレッドに影響を及ぼす変更可能な変数
* Thread Commands::             概略バッファーでのスレッドに基づいた命令



File: gnus-ja.info, Node: Customizing Threading, Next: Thread Commands, Prev: Threading, Up: Threading

スレッドをカスタマイズする
--------------------------

* Menu:

* Loose Threads::               Gnus が無束縛スレッドを集めて大きなスレッドにする方法
* Filling In Threads::          スレッドを埋める
* More Threading::              スレッドをいじくるさらに多くの変数
* Low-Level Threading::         これで終わったと思ったでしょう... でもあなたは間違っていた!



File: gnus-ja.info, Node: Loose Threads, Next: Filling In Threads, Prev: Customizing Threading, Up: Customizing Threading

無束縛スレッド
..............

`gnus-summary-make-false-root'
     もし `nil' でないと、Gnus はすべてのつながっていない部分木を一つの
     大きな木にして、頂上にみせかけの根本を作ります。(ちょっと待って下
     さい。頂上に根元 (root) ですって? ええ、そうなのです。) つながって
     いない部分木は本当の根本が期限切れ消去されたか、前回のセッションで
     根本を読んだり削除したときにできます。

     本当のスレッドが無いときは、Gnus は何かでっち上げをする必要があり
     ます。この変数は Gnus が使うべきごまかしの方法を示しています。値と
     してとることができる四つの候補があります。

     `養子 (adopt)'
          Gnus は孤児になった記事群の最初のものを親にします。この親はす
          べての他の記事を養子にします。それらの養子記事は、標準の角括
          弧 (`[]') の代わりに、先の尖った括弧 (`<>') で印が付けられま
          す。これがディフォルトの手段です。

     `みせかけ (dummy)'
          Gnus は親のふりをするみせかけの概略行を作ります。このみせかけ
          の行はどの本当の記事にも対応しないので、それを選択することは、
          みせかけの記事の後の最初の本当の記事を選択をするだけになりま
          す。みせかけの根本の様式を指定するために、
          `gnus-summary-dummy-line-format' が使われます。これはたった一
          つだけのフォーマットの仕様を受け付けます: それは `S' で、記事
          の表題です (*Note Formatting Variables::)。たとえ集めるものが
          無くても、すべてのスレッドにみせかけの根本を持たせたい場合は、
          `gnus-summary-make-false-root-always' を `t' に設定して下さい。

     `空 (empty)'
          Gnus は実際にはどの記事も親にはせず、最初の孤児を除いてすべて
          の孤児の表題欄を単に空のままにします。(実際は
          `gnus-summary-same-subject' を表題として使います (*Note
          Summary Buffer Format::)。)

     `none'
          まったくどの記事も親にしません。スレッドを集めて、単に順繰り
          に表示するだけです。

     `nil'
          無束縛スレッドを集めません。

`gnus-summary-gather-subject-limit'
     無束縛スレッドは記事の表題を比較することによって集められます。もし
     この変数が `nil' であると、Gnus は無束縛スレッドを一つの大きな超ス
     レッドに集める前に、無束縛スレッドの表題が完全に一致することを要求
     します。これは、長い表題の行を切り落としてしまう間抜けなニュースリー
     ダーが存在する現状では、あまりに厳しい要求かもしれません。そう思う
     のなら、この変数を例えば 20 に設定して、表題の最初の 20 文字だけが
     一致することを要求するようにして下さい。この変数を本当に低い数値に
     設定すると、目についたもののすべてを Gnus が一つのスレッドに集める
     のを見ることになるでしょう。それはあまり有用ではありません。

     この変数を特別な値 `fuzzy' に設定すると、Gnus は表題の文字列を大雑
     把に比較するアルゴリズムを使います (*Note Fuzzy Matching::)。

`gnus-simplify-subject-fuzzy-regexp'
     正規表現または正規表現のリストのどちらかです。表題の大雑把な比較を
     行なうときに、それらに合致する文字列を表題から取り除きます。

`gnus-simplify-ignored-prefixes'
     もし `gnus-summary-gather-subject-limit' を 10 くらいに低く設定し
     たならば、この変数を何か意味のあるものに設定することを考えるでしょ
     う:

          (setq gnus-simplify-ignored-prefixes
                (concat
                 "\\`\\[?\\("
                 (mapconcat
                  'identity
                  '("looking"
                    "wanted" "followup" "summary\\( of\\)?"
                    "help" "query" "problem" "question"
                    "answer" "reference" "announce"
                    "How can I" "How to" "Comparison of"
                    ;; ...
                    )
                  "\\|")
                 "\\)\\s *\\("
                 (mapconcat 'identity
                            '("for" "for reference" "with" "about")
                            "\\|")
                 "\\)?\\]?:?[ \t]*"))

     この正規表現に合致するすべての語は、二つの表題を比較する前に取り除
     かれます。

`gnus-simplify-subject-functions'
     `nil' でないと、この変数は `gnus-summary-gather-subject-limit' よ
     りも優先されます。この変数は `Subject' の文字列に反復して作用させ
     て簡単にするための、関数のリストである必要があります。

     このリストに入れて役に立つような関数は次のようなものです:

     `gnus-simplify-subject-re'
          前の方にある `Re:' を取り除きます。

     `gnus-simplify-subject-fuzzy'
          大雑把な比較ができるように簡単にします。

     `gnus-simplify-whitespace'
          余分な空白 (whitespace) を取り除きます。

     `gnus-simplify-all-whitespace'
          すべての空白 (whitespace) を取り除きます。

     もちろん、あなた自身の関数を書くこともできます。

`gnus-summary-gather-exclude-subject'
     無束縛スレッド集めは表題だけで行なわれるので、特に `' や `(none)'
     のような良くある表題のときは、多くの間違いを起こす可能性があります。
     この状況を少し良くするために、正規表現
     `gnus-summary-gather-exclude-subject' を使うことによって、集める過
     程においてどんな表題を除外するかを指示することができます。ディフォ
     ルトは `^ *$\\|^(none)$' です。

`gnus-summary-thread-gathering-function'
     Gnus は `Subject' 欄を調べることによってスレッドを集めます。これは、
     結果的にまったく関係の無い記事が同じ『スレッド』に含まれるかもしれ
     ないことを意味し、混乱の元です。代替手段は、合致するものを見つける
     ために `References' 欄にある `Message-ID' をすべて調べることです。
     これは集められたスレッドが関係の無い記事をまったく含まないことを保
     証しますが、いかれたニュースリーダーで投稿した記事は適切に集められ
     ないということでもあります。ペストかコレラかの選択権はあなたにあり
     ます。

     `gnus-gather-threads-by-subject'
          この関数はディフォルトの収集関数で、排他的に `Subject' を調べ
          ます。

     `gnus-gather-threads-by-references'
          この関数は排他的に `References' 欄を調べます。

     `References' によって集めることを試してみたいのであれば、次のよう
     にすることができます:

          (setq gnus-summary-thread-gathering-function
                'gnus-gather-threads-by-references)



File: gnus-ja.info, Node: Filling In Threads, Next: More Threading, Prev: Loose Threads, Up: Customizing Threading

スレッドを埋める
................

`gnus-fetch-old-headers'
     もし `nil' でないと、Gnus は古いスレッドをもっと古いヘッダー、すな
     わち既読の印が付いている記事のヘッダー、を取得することで構築しよう
     とします。できるだけ少ない概略行を表示したいけれど、できるだけたく
     さんの無束縛スレッドをつなげておきたいときは、この変数を `some' か
     数値に設定して下さい。もし数値に設定したときは、それより多い追加の
     ヘッダーは取得されません。どちらの場合でも、古いヘッダーの取得は、
     使っているバックエンドが overview ファイルを使っている場合だけ動作
     します。それらのバックエンドは、普通は `nntp', `nnspool', `nnml'
     および `nnmaildir' です。スレッドの根本がサーバーによって期限切れ
     消去されてしまったら、Gnus はどうしようもないことも覚えておいて下
     さい。

     この変数は `invisible' に設定することもできます。これは視覚的な効
     果は何もありませんが、`A T' 命令をよく使うのであれば役に立つでしょ
     う (*Note Finding the Parent::)。

`gnus-fetch-old-ephemeral-headers'
     `gnus-fetch-old-headers' と同じですが、一時ニュースグループのため
     にだけ使われます。

`gnus-build-sparse-threads'
     古いヘッダーを取得すると遅くなることがあります。この変数を `some'
     に設定することによって、同じような低賃金の効果を得ることができます。
     そうすると、Gnus はすべての記事の完全な `References' 欄を見て、同
     じスレッドに属する記事をつなごうとします。これは、記事がそのスレッ
     ドから失われていると Gnus が推測したスレッド表示に「ずれ」を残すで
     しょう。(これらのずれは普通の概略行のように見えます。もしずれを選
     択すると、Gnus はその当の記事を取得しようとします。) この変数が
     `t' であると、Gnus はスレッドを補完するのに役立つかどうかを考慮せ
     ずに、すべての「ずれ」を表示します。最後に、この変数が `more' であ
     ると、Gnus はどこにもつながっていない枝葉のまばらな節を切り落とし
     ません。この変数はディフォルトでは `nil' です。

`gnus-read-all-available-headers'
     これはあまり役に立たない、いささかはっきりしない変数です。ニュース
     ではないグループにおいて、概略バッファーを作るためにバックエンドが
     極めて多くのものを取り込まなければならず、しかも親記事を辿ることが
     できない場合に使うことを想定しています。それは主に `nnultimate' グ
     ループのような、ウェブに基づいたグループでの場合です。

     そんなグループを使わない場合はディフォルトの `nil' のままにしてお
     くのが無難です。使いたい場合はグループ名に合致する正規表現か、すべ
     てのグループが対象になる `t' にして下さい。



File: gnus-ja.info, Node: More Threading, Next: Low-Level Threading, Prev: Filling In Threads, Up: Customizing Threading

もっとスレッドを
................

`gnus-show-threads'
     この変数が `nil' であると、スレッドは作られず、ここにある残りのす
     べての変数はまったく効果が無くなります。スレッド作りを止めるとグルー
     プの選択が少し速くなりますが、記事を読むのがもっと遅く、不便になる
     ことは確実です。

`gnus-thread-hide-subtree'
     これが `nil' でないと、すべてのスレッドは概略バッファーが生成され
     たときに隠れます。

     これは述語指示子であることもできます (*Note Predicate
     Specifiers::)。利用できる述語は `gnus-article-unread-p' と
     `gnus-article-unseen-p' です。

     これは例です:

          (setq gnus-thread-hide-subtree
                '(or gnus-article-unread-p
                     gnus-article-unseen-p))

     (これはかなりばかげた例です。なぜならすべてのまだ読まれたことが無
     い記事は未読でもあるからなのですが、趣旨は汲み取って下さい。)

`gnus-thread-expunge-below'
     この数値より少ない総スコア (`gnus-thread-score-function' で定義さ
     れた関数を使って算出されます) を持つすべてのスレッドは消去されます。
     この変数はディフォルトでは `nil' で、これはどのスレッドも消去され
     ないということです。

`gnus-thread-hide-killed'
     スレッドを削除すると、この変数が `nil' でない場合、部分木は隠され
     ます。

`gnus-thread-ignore-subject'
     ときどき誰かがスレッドの途中で表題を変更することがあります。この変
     数が `nil' でないと (これがディフォルトですが)、表題の変更は無視さ
     れます。もし `nil' だと、表題の変更をすると別のスレッドになります。

`gnus-thread-indent-level'
     これは、それぞれの副スレッドがどれくらい字下げ (indent) されるべき
     かを決める数値です。ディフォルトは 4 です。

`gnus-sort-gathered-threads-function'
     とりわけメーリングリストでは、ときとして手元にメールが到着する順番
     は必ずしもメーリングリストに到着した順番と同じでは無いことがありま
     す。その結果、副スレッドをディフォルトの
     `gnus-thread-sort-by-number' で並べ換えると、応答の方がそれの元記
     事より先に現れてしまうことがあります。グループパラメーターや適切な
     フック (例えば `gnus-summary-generate-hook') でこの変数を代わりの
     値 (例えば `gnus-thread-sort-by-date') に設定することによって、そ
     のような場合に、より論理的な副スレッドの順番を生成することができま
     す。



File: gnus-ja.info, Node: Low-Level Threading, Prev: More Threading, Up: Customizing Threading

低レベルにおけるスレッド作成
............................

`gnus-parse-headers-hook'
     すべてのヘッダーを解析する前に実行されるフックです。

`gnus-alter-header-function'
     この変数の値が `nil' ではなくて関数であると、ヘッダー構造 (訳注:
     記事の主要なヘッダーの内容を効率良く保持するための Lisp オブジェク
     ト) を変更するために呼ばれます。関数は記事ヘッダーのベクトル (訳注:
     すなわちヘッダー構造) とともに呼ばれ、それが何らかの方法で変更され
     ます。例えば `Message-ID' を体系的な方法で (接頭語などを付け加える
     ことによって) 変更してしまうメールからニュースへのゲートウェイがあ
     る場合、この変数を設定することによって、その `Message-ID' を元の意
     味のあるものに戻すことができます。これは一つの例です:

          (setq gnus-alter-header-function 'my-alter-message-id)

          (defun my-alter-message-id (header)
            (let ((id (mail-header-id header)))
              (when (string-match
                     "\\(<[^<>@]*\\)\\.?cygnus\\..*@\\([^<>@]*>\\)" id)
                (mail-header-set-id
                 (concat (match-string 1 id) "@" (match-string 2 id))
                 header))))

          訳注: 取得した記事の `Message-ID' 欄から、`@' の前に付加され
          た `cygnus.' で始まる文字列を取り除きます。



File: gnus-ja.info, Node: Thread Commands, Prev: Customizing Threading, Up: Threading

スレッドの命令
--------------

`T k'
`C-M-k'
     現在のスレッド (または副スレッド) のすべての記事に既読の印を付けま
     す (`gnus-summary-kill-thread')。もし接頭引数が正であると、代わり
     にすべての印を取り除きます。接頭引数が負であると、代わりに記事を可
     視にします。

`T l'
`C-M-l'
     現在のスレッド (または副スレッド) のスコアを下げます
     (`gnus-summary-lower-thread')。

`T i'
     現在のスレッド (または副スレッド) のスコアを上げます
     (`gnus-summary-raise-thread')。

`T #'
     プロセス印を現在のスレッド (または副スレッド) に付けます
     (`gnus-uu-mark-thread')。

`T M-#'
     現在のスレッド (または副スレッド) からプロセス印を取り除きます
     (`gnus-uu-unmark-thread')。

`T T'
     スレッド表示を切り替えます (`gnus-summary-toggle-threads')。

`T s'
     もしあれば、現在の記事の下に隠れているスレッドを表示します
     (`gnus-summary-show-thread')。

`T h'
     現在のスレッド (または副スレッド) を隠します
     (`gnus-summary-hide-thread')。

`T S'
     すべての隠されているスレッドを表示します
     (`gnus-summary-show-all-threads')。

`T H'
     すべてのスレッドを隠します (`gnus-summary-hide-all-threads')。

`T t'
     現在の記事のスレッドをもう一度作り直します
     (`gnus-summary-rethread-current')。これは概略バッファーがスレッド
     表示されていないときでも動作します。

`T ^'
     現在の記事を印付きの (もしくは前の) 記事の子記事にします
     (`gnus-summary-reparent-thread')。

以下の命令はスレッド移動命令です。これらはすべて数値接頭引数を受け付け
ます。

`T n'
`C-M-f'
`M-down'
     次のスレッドに移動します (`gnus-summary-next-thread')。

`T p'
`C-M-b'
`M-up'
     前のスレッドに移動します (`gnus-summary-prev-thread')。

`T d'
     スレッドを下ります (`gnus-summary-down-thread')。

`T u'
     スレッドを登ります (`gnus-summary-up-thread')。

`T o'
     スレッドの頂上に移動します (`gnus-summary-top-thread')。

スレッドを作成するときに表題を無視すると、当然ながらいくつかの違った表
題があるスレッドが出来上がります。そして `T k'
(`gnus-summary-kill-thread') のような命令を発するときに、全体のスレッド
を削除するのではなく、現在の記事と同じ表題を持つ部分だけを削除したいと
きがあるかもしれません。もしこの発想が良いと思うのであれば、
`gnus-thread-operation-ignore-subject' をいじってみて下さい。これが
`nil' でないと (それがディフォルトですが)、スレッドの命令を実行している
ときに表題は無視されます。これが `nil' だったら、同じスレッドにある異な
る表題を持つ記事は、そのとき行なう操作の対象に含まれません。この変数が
`fuzzy' であると、大雑把な比較によって等しいと判定される表題を持つ記事
だけが対象に含まれます (*Note Fuzzy Matching::)。



File: gnus-ja.info, Node: Sorting the Summary Buffer, Next: Asynchronous Fetching, Prev: Threading, Up: Summary Buffer

並べ替え
========

概略でスレッドの表示を使っているのであれば、
`gnus-thread-sort-functions' を設定することによってスレッドを並べ替える
ことができます。この変数の値は単独の関数、関数のリスト、または関数と
`(関数でないもの)' の要素を含むリストであることができます。

ディフォルトでは並べ替えは記事番号に基づいて行なわれます。すでに用意さ
れている並べ替え述語関数は `gnus-thread-sort-by-number',
`gnus-thread-sort-by-author', `gnus-thread-sort-by-recipient',
`gnus-thread-sort-by-subject', `gnus-thread-sort-by-date',
`gnus-thread-sort-by-date-reverse', `gnus-thread-sort-by-score',
`gnus-thread-sort-by-most-recent-number',
`gnus-thread-sort-by-most-recent-date', `gnus-thread-sort-by-random' お
よび `gnus-thread-sort-by-total-score' です。

それぞれの関数は二つのスレッドをとり、最初のスレッドがもう一方より先に
並べ替えられるべきであれば `nil' でない値を返します。実際の並べ替えは、
普通それぞれのスレッドの根本だけを調べることによって行なわれることに気
を付けて下さい。

二つ以上の関数を使う場合、並べ替えの第一の鍵はリストの最後の関数でなけ
ればなりません。並べ替え関数のリストのなるべく先頭に、おそらく常に
`gnus-thread-sort-by-number' を含めておくべきでしょう。これは、他の並べ
替えの基準が等しいスレッドが、記事番号の登り順に表示されることを保証し
ます。

スコアの逆順、表題、そして最後に番号、の順に並べ替えたいのであれば、次
のようにできます:

     (setq gnus-thread-sort-functions
           '(gnus-thread-sort-by-number
             gnus-thread-sort-by-subject
             (not gnus-thread-sort-by-total-score)))

最大のスコアを持つスレッドが、最初に概略バッファーに表示されます。スレッ
ドが同じスコアの場合は、英字順に並び替えられます。同じスコアと表題を持
つスレッドは番号で並べ替えられ、(普通は) 記事が到着した順番になります。

スコア、到着の逆順に並べ替えたいのであれば、次のようにできます:

     (setq gnus-thread-sort-functions
           '((not gnus-thread-sort-by-number)
             gnus-thread-sort-by-score))

変数 `gnus-thread-score-function' (ディフォルトは `+') に設定されている
関数は、スレッドの総スコアを計算するために用いられます。役立つ関数は
`max', `min', もしくは二乗、もしくはあなたの好奇心をくすぐるような何か
でしょう。

何か変な理由でスレッド表示を使っていないのなら、変数
`gnus-article-sort-functions' をいじくる必要があります。これは
`gnus-thread-sort-functions' と非常に似ていますが、記事の比較には少々違っ
た関数を使います。使用可能な並べ替え述語関数は
`gnus-article-sort-by-number', `gnus-article-sort-by-author',
`gnus-article-sort-by-subject', `gnus-article-sort-by-date',
`gnus-article-sort-by-random' および `gnus-article-sort-by-score' です。

スレッドを使っていない概略の表示を表題で並べ替えたいのであれば、次のよ
うなことをすることができます:

     (setq gnus-article-sort-functions
           '(gnus-article-sort-by-number
             gnus-article-sort-by-subject))

`gnus-parameters' を介することによって、グループによって異なる並べ替え
を定義することができます。*Note Group Parameters::.



File: gnus-ja.info, Node: Asynchronous Fetching, Next: Article Caching, Prev: Sorting the Summary Buffer, Up: Summary Buffer

非同期記事取得
==============

遠くにある NNTP サーバーからニュースを取得していると、ネットワークの遅
延が記事を読むことを嫌な仕事にしてしまうかもしれません。`n' を押してか
ら次の記事が現れるまで、しばらく待たなければなりませんものね。どうして
前の記事を読んでいる間に Gnus が先行して記事を取得してくれないのでしょ
うか? なぜできないんでしょう、本当に。

まず警告しておきましょう。非同期で記事を取得、特に Gnus がそれを行なう
場合には、いくつかの落とし穴があります。

例えば、あなたは短い記事 1 を読んでいて、記事 2 はとても長くて、あなた
はそれを読むことには興味が無いとしましょう。Gnus はこのことはわからない
ので、先行して記事 2 を取得します。あなたは記事 3 を読むことにしますが、
Gnus は記事 2 を取得している最中なので、接続は封鎖されています。

この状況を避けるために、Gnus はサーバーに二つ (二まで数えて下さい) の接
続を張ります。これはあまり良いことではないと考える人もいるでしょうが、
私には実際の代替手段が見つからないのです。余分な接続を立ち上げるために
はいくばくかの時間がかかるので、Gnus の起動は遅くなります。

Gnus はあなたが読むであろう記事よりもたくさんの記事を取得します。これは
記事の先行取得を使わないときよりも、あなたのマシンと NNTP サーバー間の
接続にもっと負荷をかけることになるでしょう。サーバー自身にももっと負荷
がかかるようになります--余分な記事の要求と、余分な接続によって。

はい、本当はこのようなことをすべきで無いことがこれで分かったでしょ
う... 本当にそうしたいと思わない限りは。

やり方です: `gnus-asynchronous' を `t' に設定して下さい。それ以外の諸々
のことは自動的に行なわれます。

`gnus-use-article-prefetch' を設定することによって、どれくらいの記事を
先に取得するべきかを操作することができます。これはディフォルトでは 30
で、グループの記事を読んでいるときに、バックエンドが次の 30 通の記事を
先行取得するということです。この変数が `t' であると、バックエンドは取得
できるすべての記事を際限なく先行取得しようとします。これが `nil' である
と、先行取得は行なわれません。

おそらく先行取得をしたくない記事がいくつかあるでしょう--例えば既読記事
です。変数 `gnus-async-prefetch-article-p' は記事が先に取得されるかどう
かを制御します。この変数に設定される関数は、問題の記事を先行取得するの
であれば `nil' でない値を返さなければなりません。ディフォルトの関数は
`gnus-async-read-p' で、これは既読記事には `nil' を返します。この関数は
記事のデータ構造を唯一の引数として呼ばれます。

例えば、100 行よりも短い未読記事だけを先に取得したいのであれば、次のよ
うにできます:

     (defun my-async-short-unread-p (data)
       "Return non-nil for short, unread articles."
       (and (gnus-data-unread-p data)
            (< (mail-header-lines (gnus-data-header data))
               100)))

     (setq gnus-async-prefetch-article-p 'my-async-short-unread-p)

これらの関数は何度も何度も呼ばれるので、Gnus を遅くしすぎないように、短
く甘美であるのが好ましいです。このようなものをバイトコンパイル
(byte-compile) するのは、おそらく良い着想でしょう。

記事は非同期バッファーから遅かれ早かれ削除されなければなりません。
`gnus-prefetched-article-deletion-strategy' はいつ記事を削除するかを指
定します。これは以下の要素を含むリストです:

`read'
     記事が読まれたときに削除します。

`exit'
     グループを抜けたときに記事を削除します。

ディフォルトの値は `(read exit)' です。



File: gnus-ja.info, Node: Article Caching, Next: Persistent Articles, Prev: Asynchronous Fetching, Up: Summary Buffer

記事のキャッシュ
================

*非常に* 遅い NNTP 接続を使っているのならば、記事をキャッシュすることを
考えても良いでしょう。それをすると、それぞれの記事はあなたのホームディ
レクトリーの下にローカルに溜められます。もう感付いたかもしれませんが、
これは i ノードを非常に速く食いつぶすだけでなく、*巨大な* ディスクスペー
スを食う可能性があります。それはあなたにウォッカの中で泳ぐようなめまい
を起こさせるでしょう。

でも注意深く使われれば、それは記事を保存する、より楽な方法になり得ます。

キャッシュを実行させるには `gnus-use-cache' を `t' に設定して下さい。ディ
フォルトでは、すべての可視または保留として印の付いている記事はローカル
のキャッシュ (`gnus-cache-directory') に複写されます。このキャッシュが
平らな構造か階層的であるかは、通常通り、変数 `gnus-use-long-file-name'
で制御されます。

可視記事か保留記事を再選択した場合は、サーバーの代わりにキャッシュから
取得されます。キャッシュにある記事は期限切れ消去されないので、記事をそ
れらが属するところに居続けさせている間、それらを保存する方法としてこれ
は役立つかもしれません。保存したいすべての記事に保留の印を付けるだけで、
後は心配無用です。

記事に既読の印が付いたときに、それはキャッシュから削除されるのでしょう
か。

記事をキャッシュに入れたりキャッシュから削除することは、変数
`gnus-cache-enter-articles' および `gnus-cache-remove-articles' によっ
て制御されます。これらは両方ともシンボルのリストです。前者はディフォル
トでは `(ticked dormant)' で、可視記事と保留記事はキャッシュに入れられ
ます。後者はディフォルトでは `(read)' で、既読の印が付いた記事はキャッ
シュから削除されます。おそらくこれら二つのリストに含まれるシンボルは
`ticked', `dormant', `unread' および `read' でしょう。

それでは、大規模な記事の取得と格納は、どこで関係してくるのでしょうか。
`gnus-jog-cache' 命令は、すべての購読グループに対して、すべての未読記事
を要求し、スコアを付け、キャッシュに保存します。この命令をいつもいつも
いつもいつも使うのは、1) NNTP サーバーとの接続が本当に本当に本当に遅く
て、2) 本当に本当に本当に巨大なディスクを持っているときだけにするべきで
す。これは真面目に言っています。ダウンロードされる記事の数を控える一つ
の方法は、欲しくない記事のスコアを低くして、それらに既読の印を付けるこ
とです。そうすれば、それらはこの命令ではダウンロードされません。

すべてのグループではキャッシュをしたくないというのは良くあることです。
例えば `nnml' のメールがホームディレクトリーにあるのなら、それをホーム
ディレクトリーの別の場所にキャッシュするのは意味がありません。二倍の容
量を使う方が良いと思うのでなければ。

キャッシュを制限するには、`gnus-cacheable-groups' を例えば `^nntp' のよ
うなキャッシュするグループの正規表現に設定するか、または正規表現
`gnus-uncacheable-groups' を例えば `^nnml' に設定して下さい。両方の変数
ともにディフォルトは `nil' です。もしグループが両方の変数に合致すると、
そのグループはキャッシュされません。

キャッシュは、それがどの記事を含んでいるかの情報を、そのアクティブファ
イル (`gnus-cache-active-file') に格納します。このファイル (もしくは
キャッシュの他の部分) が何らかの理由でぐちゃぐちゃになってしまった場合、
Gnus はものごとを正しくするための二つのコマンドを提供します。`M-x
gnus-cache-generate-nov-databases' はすべての NOV ファイルを (再) 作成
し、`M-x gnus-cache-generate-active' はアクティブファイルを (再) 作成し
ます。

`gnus-cache-move-cache' コマンドは、すべての `gnus-cache-directory' を
どこか別の場所に移動します。あなたはどこに移動させるかを尋ねられます。
それってかっこいいでしょ?



