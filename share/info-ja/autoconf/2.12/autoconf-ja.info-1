これは autoconf-ja.info、autoconf-ja.texi より makeinfo
バージョン 4.8 によって作成されました。

   This manual is for GNU Autoconf (version 2.59, 5 November 2003), a
package for creating scripts to configure source code packages using
templates and an M4 macro package.

   Copyright (C) 1992, 1993, 1994, 1995, 1996, 1998, 1999, 2000, 2001,
2002, 2003 Free Software Foundation, Inc.

     Permission is granted to copy, distribute and/or modify this
     document under the terms of the GNU Free Documentation License,
     Version 1.1 or any later version published by the Free Software
     Foundation; with no Invariant Sections, with the Front-Cover texts
     being "A GNU Manual," and with the Back-Cover Texts as in (a)
     below.  A copy of the license is included in the section entitled
     "GNU Free Documentation License."

     (a) The FSF's Back-Cover Text is: "You have freedom to copy and
     modify this GNU Manual, like GNU software.  Copies published by
     the Free Software Foundation raise funds for GNU development."

INFO-DIR-SECTION Software development
START-INFO-DIR-ENTRY
* Autoconf(ja): (autoconf-ja).         Create source code configuration scripts.
END-INFO-DIR-ENTRY

INFO-DIR-SECTION Individual utilities
START-INFO-DIR-ENTRY
* autoscan(ja): (autoconf-ja)autoscan Invocation.
                                Semi-automatic `configure.ac' writing
* ifnames(ja): (autoconf-ja)ifnames Invocation.
                                Listing conditionals in source.
* autoconf(ja): (autoconf-ja)autoconf Invocation.
                                How to create configuration scripts
* autoreconf(ja): (autoconf-ja)autoreconf Invocation.
                                Remaking multiple `configure' scripts
* autoheader(ja): (autoconf-ja)autoheader Invocation.
                                How to create configuration templates
* autom4te(ja): (autoconf-ja)autom4te Invocation.
                                The Autoconf executables backbone
* configure(ja): (autoconf-ja)configure Invocation.
                                Configuring a package.
* autoupdate(ja): (autoconf-ja)autoupdate Invocation.
                                Automatic update of `configure.ac'
* config.status(ja): (autoconf-ja)config.status Invocation.
                                Recreating configurations.
* testsuite(ja): (autoconf-ja)testsuite Invocation.
                                Running an Autotest test suite.
END-INFO-DIR-ENTRY


File: autoconf-ja.info,  Node: Top,  Next: Introduction,  Up: (dir)

Autoconf
********

This manual is for GNU Autoconf (version 2.59, 5 November 2003), a
package for creating scripts to configure source code packages using
templates and an M4 macro package.

   Copyright (C) 1992, 1993, 1994, 1995, 1996, 1998, 1999, 2000, 2001,
2002, 2003 Free Software Foundation, Inc.

     Permission is granted to copy, distribute and/or modify this
     document under the terms of the GNU Free Documentation License,
     Version 1.1 or any later version published by the Free Software
     Foundation; with no Invariant Sections, with the Front-Cover texts
     being "A GNU Manual," and with the Back-Cover Texts as in (a)
     below.  A copy of the license is included in the section entitled
     "GNU Free Documentation License."

     (a) The FSF's Back-Cover Text is: "You have freedom to copy and
     modify this GNU Manual, like GNU software.  Copies published by
     the Free Software Foundation raise funds for GNU development."

* Menu:

* Introduction::                Autoconf's purpose, strengths, and weaknesses
* The GNU Build System::        A set of tools for portable software packages
* Making configure Scripts::    How to organize and produce Autoconf scripts
* Setup::                       Initialization and output
* Existing Tests::              Macros that check for particular features
* Writing Tests::               How to write new feature checks
* Results::                     What to do with results from feature checks
* Programming in M4::           Layers on top of which Autoconf is written
* Writing Autoconf Macros::     Adding new macros to Autoconf
* Portable Shell::              Shell script portability pitfalls
* Manual Configuration::        Selecting features that can't be guessed
* Site Configuration::          Local defaults for `configure'
* Running configure Scripts::   How to use the Autoconf output
* config.status Invocation::    Recreating a configuration
* Obsolete Constructs::         Kept for backward compatibility
* Using Autotest::              Creating portable test suites
* FAQ::                         Frequent Autoconf Questions, with answers
* History::                     History of Autoconf
* Copying This Manual::         How to make copies of this manual
* Indices::                     Indices of symbols, concepts, etc.

 --- 詳細なノードリスト ---

GNUビルドシステム

* Automake::                    Escaping Makefile hell
* Libtool::                     Building libraries portably
* Pointers::                    More info on the GNU build system

`configure'スクリプトの作成

* Writing configure.ac::        What to put in an Autoconf input file
* autoscan Invocation::         Semi-automatic `configure.ac' writing
* ifnames Invocation::          Listing the conditionals in source code
* autoconf Invocation::         How to create configuration scripts
* autoreconf Invocation::       Remaking multiple `configure' scripts

`configure.ac'を書く

* Shell Script Compiler::       Autoconf as solution of a problem
* Autoconf Language::           Programming in Autoconf
* configure.ac Layout::         Standard organization of `configure.ac'

初期化と出力ファイル

* Initializing configure::      Option processing etc.
* Notices::                     Copyright, version numbers in `configure'
* Input::                       Where Autoconf should find files
* Output::                      Outputting results from the configuration
* Configuration Actions::       Preparing the output based on results
* Configuration Files::         Creating output files
* Makefile Substitutions::      Using output variables in `Makefile's
* Configuration Headers::       Creating a configuration header file
* Configuration Commands::      Running arbitrary instantiation commands
* Configuration Links::         Links depending on the configuration
* Subdirectories::              Configuring independent packages together
* Default Prefix::              Changing the default installation prefix

Makefileへの代入

* Preset Output Variables::     Output variables that are always set
* Installation Directory Variables::  Other preset output variables
* Build Directories::           Supporting multiple concurrent compiles
* Automatic Remaking::          Makefile rules for configuring

ヘッダファイルのコンフィグレーション

* Header Templates::            Input for the configuration headers
* autoheader Invocation::       How to create configuration templates
* Autoheader Macros::           How to specify CPP templates

存在の調査

* Common Behavior::             Macros' standard schemes
* Alternative Programs::        Selecting between alternative programs
* Files::                       Checking for the existence of files
* Libraries::                   Library archives that might be missing
* Library Functions::           C library functions that might be missing
* Header Files::                Header files that might be missing
* Declarations::                Declarations that may be missing
* Structures::                  Structures or members that might be missing
* Types::                       Types that might be missing
* Compilers and Preprocessors::  Checking for compiling programs
* System Services::             Operating system services
* UNIX Variants::               Special kludges for specific UNIX variants

共通の動作

* Standard Symbols::            Symbols defined by the macros
* Default Includes::            Includes used by the generic macros

プログラムの選択

* Particular Programs::         Special handling to find certain programs
* Generic Programs::            How to find other programs

ライブラリ関数

* Function Portability::        Pitfalls with usual functions
* Particular Functions::        Special handling to find certain functions
* Generic Functions::           How to find other functions

ヘッダファイル

* Header Portability::          Collected knowledge on common headers
* Particular Headers::          Special handling to find certain headers
* Generic Headers::             How to find other headers

宣言

* Particular Declarations::     Macros to check for certain declarations
* Generic Declarations::        How to find other declarations

構造体

* Particular Structures::       Macros to check for certain structure members
* Generic Structures::          How to find other structure members

型

* Particular Types::            Special handling to find certain types
* Generic Types::               How to find other types

コンパイラとプリプロセッサ

* Specific Compiler Characteristics::  Some portability issues
* Generic Compiler Characteristics::  Language independent tests and features
* C Compiler::                  Checking its characteristics
* C++ Compiler::                Likewise
* Fortran Compiler::            Likewise

テストを書く

* Language Choice::             Selecting which language to use for testing
* Writing Test Programs::       Forging source files for compilers
* Running the Preprocessor::    Detecting preprocessor symbols
* Running the Compiler::        Detecting language or header features
* Running the Linker::          Detecting library features
* Run Time::                    Testing for run-time features
* Systemology::                 A zoology of operating systems
* Multiple Cases::              Tests for several possible values

テストプログラムを書く

* Guidelines::                  General rules for writing test programs
* Test Functions::              Avoiding pitfalls in test programs
* Generating Sources::          Source program boilerplate

テストの結果

* Defining Symbols::            Defining C preprocessor symbols
* Setting Output Variables::    Replacing variables in output files
* Caching Results::             Speeding up subsequent `configure' runs
* Printing Messages::           Notifying `configure' users

結果のキャッシュ

* Cache Variable Names::        Shell variables used in caches
* Cache Files::                 Files `configure' uses for caching
* Cache Checkpointing::         Loading and saving the cache file

M4でのプログラム

* M4 Quotation::                Protecting macros from unwanted expansion
* Using autom4te::              The Autoconf executables backbone
* Programming in M4sugar::      Convenient pure M4 macros
* Programming in M4sh::         Common shell Constructs

M4の引用符

* Active Characters::           Characters that change the behavior of M4
* One Macro Call::              Quotation and one macro call
* Quotation and Nested Macros::  Macros calling macros
* Changequote is Evil::         Worse than INTERCAL: M4 + changequote
* Quadrigraphs::                Another way to escape special characters
* Quotation Rule Of Thumb::     One parenthesis, one quote

`autom4te'の使用

* autom4te Invocation::         A GNU M4 wrapper
* Customizing autom4te::        Customizing the Autoconf package

M4sugarでのプログラム

* Redefined M4 Macros::         M4 builtins changed in M4sugar
* Evaluation Macros::           More quotation and evaluation control
* Forbidden Patterns::          Catching unexpanded macros

Autoconfマクロを書く

* Macro Definitions::           Basic format of an Autoconf macro
* Macro Names::                 What to call your new macros
* Reporting Messages::          Notifying `autoconf' users
* Dependencies Between Macros::  What to do when macros depend on other macros
* Obsoleting Macros::           Warning about old ways of doing things
* Coding Style::                Writing Autoconf macros a` la Autoconf

マクロ間の依存性

* Prerequisite Macros::         Ensuring required information
* Suggested Ordering::          Warning about possible ordering problems

移植性のあるシェルプログラム

* Shellology::                  A zoology of shells
* Here-Documents::              Quirks and tricks
* File Descriptors::            FDs and redirections
* File System Conventions::     File- and pathnames
* Shell Substitutions::         Variable and command expansions
* Assignments::                 Varying side effects of assignments
* Parentheses::                 Parentheses in shell scripts
* Special Shell Variables::     Variables you should not change
* Limitations of Builtins::     Portable use of not so portable /bin/sh
* Limitations of Usual Tools::  Portable use of portable tools
* Limitations of Make::         Portable Makefiles

手動のコンフィグレーション

* Specifying Names::            Specifying the system type
* Canonicalizing::              Getting the canonical system type
* Using System Type::           What to do with the system type

サイトコンフィグレーション

* External Software::           Working with other optional software
* Package Options::             Selecting optional features
* Pretty Help Strings::         Formatting help string
* Site Details::                Configuring site details
* Transforming Names::          Changing program names when installing
* Site Defaults::               Giving `configure' local defaults

インストール時のプログラム名の変換

* Transformation Options::      `configure' options to transform names
* Transformation Examples::     Sample uses of transforming names
* Transformation Rules::        `Makefile' uses of transforming names

`configure'スクリプトの実行

* Basic Installation::          Instructions for typical cases
* Compilers and Options::       Selecting compilers and optimization
* Multiple Architectures::      Compiling for multiple architectures at once
* Installation Names::          Installing in different directories
* Optional Features::           Selecting optional features
* System Type::                 Specifying the system type
* Sharing Defaults::            Setting site-wide defaults for `configure'
* Defining Variables::          Specifying the compiler etc.
* configure Invocation::        Changing how `configure' runs

時代遅れの構成物

* Obsolete config.status Use::  Different calling convention
* acconfig.h::                  Additional entries in `config.h.in'
* autoupdate Invocation::       Automatic update of `configure.ac'
* Obsolete Macros::             Backward compatibility macros
* Autoconf 1::                  Tips for upgrading your files
* Autoconf 2.13::               Some fresher tips

バージョン1からの更新

* Changed File Names::          Files you might rename
* Changed Makefiles::           New things to put in `Makefile.in'
* Changed Macros::              Macro calls you might replace
* Changed Results::             Changes in how to check test results
* Changed Macro Writing::       Better ways to write your own macros

バージョン2.13からの更新

* Changed Quotation::           Broken code which used to work
* New Macros::                  Interaction with foreign macros
* Hosts and Cross-Compilation::  Bugward compatibility kludges
* AC_LIBOBJ vs LIBOBJS::        LIBOBJS is a forbidden token
* AC_FOO_IFELSE vs AC_TRY_FOO::  A more generic scheme for testing sources

Autotestを用いてテストスイートを生成する

* Using an Autotest Test Suite::  Autotest and the user
* Writing testsuite.at::        Autotest macros
* testsuite Invocation::        Running `testsuite' scripts
* Making testsuite Scripts::    Using autom4te to create `testsuite'

Autotestテストスイートの使用

* testsuite Scripts::           The concepts of Autotest
* Autotest Logs::               Their contents

よくある質問とその回答

* Distributing::                Distributing `configure' scripts
* Why GNU m4::                  Why not use the standard M4?
* Bootstrapping::               Autoconf and GNU M4 require each other?
* Why Not Imake::               Why GNU uses `configure' instead of Imake
* Defining Directories::        Passing `datadir' to program
* autom4te.cache::              What is it?  Can I remove it?
* Present But Cannot Be Compiled::  Compiler and Preprocessor Disagree

Autoconfの歴史

* Genesis::                     Prehistory and naming of `configure'
* Exodus::                      The plagues of M4 and Perl
* Leviticus::                   The priestly code of portability arrives
* Numbers::                     Growth and contributors
* Deuteronomy::                 Approaching the promises of easy configuration

このマニュアルのコピー条件

* GNU Free Documentation License::  License for copying this manual

索引

* Environment Variable Index::  Index of environment variables used
* Output Variable Index::       Index of variables set in output files
* Preprocessor Symbol Index::   Index of C preprocessor symbols defined
* Autoconf Macro Index::        Index of Autoconf macros
* M4 Macro Index::              Index of M4, M4sugar, and M4sh macros
* Autotest Macro Index::        Index of Autotest macros
* Program & Function Index::    Index of those with portability problems
* Concept Index::               General index


File: autoconf-ja.info,  Node: Introduction,  Next: The GNU Build System,  Prev: Top,  Up: Top

1 はじめに
**********

                       物理学者，エンジニア，そしてコンピュータ科学者が
                         神の性質を論じていました．"確かに物理学者だ"と
                    物理学者が言いました．"なぜなら，創造の早いうちに，
           神が光を作ったからだ．ご存じのように，マックスウェル方程式，
              電磁波の二重の性質，相対論者の結果..." "エンジニアだ！"と
                    エンジニアは言いました．"なぜなら，光を作る前に神は
     カオスを土地と水に分けたからだ．それには大量のエンジニアが必要で，
                       大量の泥を処理し，液体から固体を正しく分離し..."
                        コンピュータ科学者は叫びました．"そしてカオス，
                      それはいったいどこからきたと思いますか，う〜ん？"

                                                         --詠み人知らず

   Autoconfは，何種類ものUNIXライクのシステムに適合させるために，ソフ
トウェアソースコードパッケージを自動的にコンフィグレーションするシェルス
クリプトを生成するツールです．Autoconfで生成されたコンフィギュレーション
スクリプトは，実行時にはAutoconfに依存しないので，ユーザがAutoconfを持っ
ている必要がありません．

Autoconfで生成されたコンフィギュレーションスクリプトは，実行時にユーザの
手動の介入を必要としません．通常，システムタイプを指定する引数さえも必要
としません．その代わりに，ソフトウェアパッケージが必要とするそれぞれの機
能が存在するかどうか個別に調査します．(それぞれの調査の前に，調査してい
ることに関する一行のメッセージを出力し，そのため，ユーザはスクリプトが終
わるまで待っている間，そんなに退屈しません．) 結果として，それらは，一般
的なUNIXの変形から混成されたりカスタマイズされたりしているシステム
でうまく動作します．それぞれのUNIXの変形の，それぞれのリリースによっ
てサポートされている特徴をリストアップするファイルを保守する必要はありま
せん．

Autoconfが使用されているそれぞれのソフトウェアパッケージに対し，パッケー
ジが必要とする，または使用可能なシステムの特徴をリストアップしているテン
プレートファイルから，コンフィギュレーションスクリプトを作成します．シス
テムの特徴を認識して応答するシェルコードが書かれた後，使用可能な(または
必要な)機能を多くのパッケージで共有することが，Autoconfで可能になります．
理由があって，シェルコードの調整の必要性が後になって発覚した場合，ただ一ヵ
所だけ変更する必要があります．すべてのコンフィギュレーションスクリプトは，
更新されたコードを利用するため自動的に再生することが可能です．

MetaconfigパッケージはAutoconfの目的に似ていますが，それが生成するスクリ
プトは手動でユーザが介入する必要があり，大きなソースツリーをコンフィグレー
ションするときは全く不便です．Metaconfigスクリプトと異なり，注意して書い
てさえいれば，Autoconfスクリプトはクロスコンパイルもサポート可能です．

Autoconfは，移植性のあるソフトウェアパッケージに関連するすべての問題を解
決しているわけではありません -- より完全に解決するために，Automakeと
Libtoolのような，その他のGNUビルドツールと連係して使用すべきで
す．これらのツールは，すべての標準ターゲットを含んでいる，移植性のある再
帰的な`Makefile'の作成，共有ライブラリのリンクなどの作業を請け負い
ます．詳細は*Note The GNU Build System::.

   Autoconfは，Cプログラムの`#if'で使用するマクロ名に，多少制限を与え
ます(*note Preprocessor Symbol Index::)．

   Autoconfは，スクリプトを生成するためにGNU M4が必要です．
UNIXバージョンのM4が持っていない機能を使用していて，それには GNU M4
1.3も含まれます．バージョン1.4以降のGNU M4 を 使用する必要があります．

   バージョン1からの更新についての情報は，*Note Autoconf 1::.
Autoconfの開 発の物語については，*Note History::.
Autoconfについての一般的な質問へ回 答は，*Note FAQ::.

更新情報，メーリングリストの詳細，既知のバグリストへのポインタなどは，
Autoconf web page(1)を参照してください．

   Autoconfに関する提案は the Autoconf mailing list
<autoconf@gnu.org>にメールして下さい．

   バグの報告は，できれば Autoconf Gnats database(2)へ提出するか，the
Autoconf Bugs mailing list
<bug-autoconf@gnu.org>へ送付してください．できれば最初に，現在の開
発バージョンでバグが既に解決されていないことと，まだ報告されていないこと
を調査してください．すべての必要な情報と問題を立証する短い
`configure.ac'を確実に同封してください．

   Autoconfの開発ツリーは，CVSでアクセス可能です．詳細は，
Autoconfのウェブページを参照してください． CVSweb interface to the
Autoconf development tree(3)もあります．
現在のCVSバージョンに関連するパッチは，レビューするために Autoconf
Patches mailing list <autoconf-patches@gnu.org>に送付す
ることが可能です．

その作業のため，Autoconfは既に有用性が立証されている，よく使用されるマ
クロだけを含めています．それでも，マクロを共有したい，または既存のもの
を探したい場合，Peter Simons <simons@computer.org>の好意で作成
されているAutoconf Macro Archive(4)を参照してください．

   ---------- Footnotes ----------

   (1) Autoconf web page,
`http://www.gnu.org/software/autoconf/autoconf.html'.

   (2) Autoconf Gnats database,
`http://bugs.gnu.org/cgi-bin/gnatsweb.pl?database=autoconf'.

   (3) CVSweb interface to the Autoconf development tree,
`http://subversions.gnu.org/cgi-bin/cvsweb/autoconf/'.

   (4) Autoconf Macro Archive,
`http://www.gnu.org/software/ac-archive/'.


File: autoconf-ja.info,  Node: The GNU Build System,  Next: Making configure Scripts,  Prev: Introduction,  Up: Top

2 GNUビルドシステム
*******************

Autoconfは重要な問題を解決します -- それはシステム特有の，ビルドと実行
時に見つけた信頼できる情報になります -- しかし，これは移植性のあるソフ
トウエアを開発するためのパズルの一つの部品に過ぎません．このために，
GNUプロジェクトは，Autoconfが開始した仕事を完了するためのユー
ティリティの，統合された組み合わせ(スイート)を開発してきました．
GNUビルドシステムの最も重要な構成要素は，Autoconf，Automake，
そしてLibtoolです．この章で，我々はこれらのツールを紹介し，より多くの情
報源を提示し，そして，ソフトウェアに対してGNUビルドシステム全
体を便利に使用するように説得してみたいと思います．

* Menu:

* Automake::                    Escaping Makefile hell
* Libtool::                     Building libraries portably
* Pointers::                    More info on the GNU build system


File: autoconf-ja.info,  Node: Automake,  Next: Libtool,  Up: The GNU Build System

2.1 Automake
============

`make'の偏在とは，`Makefile'はソフトウェアの自動的なビルド
ルールを配布するほとんど唯一の現実的な方法だということを意味しているので
すが，すぐに`make'の多くの限界にぶつかります．それには，自動的な
依存性の追跡に対するサポート，サブディレクトリでの再帰的なビルド，(例え
ば，ネットワークファイルシステムに対する)信頼できるタイムスタンプなどが
足りないので，開発者はそれぞれのプロジェクトに対し，辛い(そして間違うこ
とが多い)車輪の再開発が必要になっています．多くのシステムの
`make'の癖のために，移植性は些細な問題ではなくなっています．なに
よりも，ユーザが期待する多くの標準的なターゲット(`make install'， `make
distclean'，`make uninstall'など)を手作業で実装する必要
があることがあげられます．もちろん，Autoconfを使用しているので，
`@CC@'，`@CFLAGS@'，そして`configure'で提供される
その他の置換式を認識するように，`Makefile.in'に対応するコードを挿入
しているでしょう．この乱雑な状況は"Automake"で処理しましょう． 

   Automakeは，プレーンの`Makefile'の方法と比較して，非常に簡単でより
強力な構文で，ビルドが必要とするものを`Makefile.am'ファイルで指定す
ることを可能とし，Autoconfで使用するための移植性の高い`Makefile.in'
を生成します．例えば，単純な"Hello world"プログラムをビルドしインストー
ルするための`Makefile.am'は以下のようになります．

     bin_PROGRAMS = hello
     hello_SOURCES = hello.c

結果として得られる`Makefile.in'(約400行)は，自動的に，すべての標準
的なターゲット，Autoconfが提供する置換式，自動的な依存性追跡，
`VPATH'のビルドなどをサポートします．`make'で`hello'
プログラムをビルドし，`make install'でそれを`/usr/local/bin'
(または`/usr/local'でないときは`configure'で与えたプレフィ
クス)にインストールします．

Automakeの利点は，パッケージが大きければ大きい(特にサブディレクトリがあ
るもの)ほど有利になりますが，小さなプログラムに対しても重要な利便性と移
植性を追加します．そして，それだけがすべてではありません....


File: autoconf-ja.info,  Node: Libtool,  Next: Pointers,  Prev: Automake,  Up: The GNU Build System

2.2 Libtool
===========

他のプログラムでも，これまでの作業の成果から利益を得ることを可能にするた
め，プログラムだけでなくライブラリをビルドしたいことも頻繁にあるでしょう．
理想的には，_共有_(動的にリンクされる)ライブラリを生成したいと考え，
それは，複数のプログラムからディスクやメモリに同じものを複製せずに使用す
ることが可能で，リンクされているプログラムに依存せずに更新可能だからです．
しかし，移植性の高い共有ライブラリは悪夢の元です -- それぞれのシステム
は，独自の互換性のないツール，コンパイラフラグ，そして魔法の呪文がありま
す．幸いにもGNUは解決方法を提供しています．それは， "Libtool"です． 

Libtoolは，共有ライブラリのビルドに関するすべての要求を処理し，現時点で
は，移植性を扱うための_唯一の_方法だと思われます．また，以下のよう
な頭痛の種も扱います．それは，共有ライブラリの様々な接尾子を扱う
`Makefile'ルールの相互作用，以前にスーパーユーザによってインストー
ルされた共有ライブラリとの信頼できるリンク，そして，整合性の高いバージョ
ン管理システムの提供です(それは，ライブラリの異なるバージョンを，バイナ
リ互換性を壊さないようにインストールし更新することを可能にするためのもの
です)．しかしLibtoolは，Autoconf同様に，単独で使用することは可能ですが，
ほとんどは単純にAutomakeと組み合わせて利用されます -- そこで，Libtool
は共有ライブラリが必要なときに自動的に使用され，そして使用者はその構文を
知っている必要はありません．


File: autoconf-ja.info,  Node: Pointers,  Prev: Libtool,  Up: The GNU Build System

2.3 参考文献
============

単一のシステムでの小さなプロジェクトに対して，簡単な`make'を使用
している開発者は，AutomakeとAutoconfを使用するために学習する見通しを立て
ると圧倒されるかもしれません．しかし，ソフトウェアはより多くのユーザに配
布されるので，GNUビルドツールが提供するサービスを再発明するた
めに多くの努力を費やしていることと，一度犯して解決した過ちを繰り返してい
ることがすぐに分かるでしょう．(また，既にAutoconfを学んでいるので，
Automakeは朝飯前でしょう．)

   GNUビルドツールの詳細な情報を得るために，訪問する場所はたくさ
んあります．

   - Web

     Autoconf(1)， Automake(2)，そして Libtool(3)のホームページ．

   - Automakeのマニュアル

     Automakeの詳細は，*Note Automake: (automake)Top.

   - 書籍

     書籍`GNU Autoconf, Automake and
     Libtool'(4)では，完全なGNUビルド環境が記述されてい ます．"The Goat
     Book" home page(5)では，オンラインで本全体を見ることも可能です．

   - チュートリアルと例

     Autoconf Developer Page(6)では，
     Autoconf/Automakeのオンラインのチュートリアルと， Autoconf Macro
     Archive(7) のリンクも管理しています．


   ---------- Footnotes ----------

   (1) Autoconf, `http://www.gnu.org/software/autoconf/'.

   (2) Automake, `http://www.gnu.org/software/automake/'.

   (3) Libtool, `http://www.gnu.org/software/libtool/'.

   (4) `GNU Autoconf, Automake and Libtool', by G. V. Vaughan, B.
Elliston, T. Tromey, and I. L. Taylor. New Riders, 2000, ISBN
1578701902.

   (5) "The Goat Book" home page, `http://sources.redhat.com/autobook/'.

   (6) Autoconf Developer Page, `http://sources.redhat.com/autoconf/'.

   (7) Autoconf Macro Archive,
`http://www.gnu.org/software/ac-archive/'.


File: autoconf-ja.info,  Node: Making configure Scripts,  Next: Setup,  Prev: The GNU Build System,  Up: Top

3 `configure'スクリプトの作成
*****************************

Autoconfが生成するコンフィギュレーションスクリプトは，慣習的に
`configure'と呼ばれます．実行時に，`configure'はいくつか
のファイルを作成し，そこで，コンフィギュレーションパラメータを適切な値に
置換します．`configure'が作成するファイルは以下の通りです．

   - 一つ以上の`Makefile'で，通常はパッケージのそれぞれのサブディレクト
     リに一つずつあります(*note Makefile Substitutions::)．

   -
     オプションのCヘッダファイルで，それはコンフィグレーション可能な名前で，
     `#define'ディレクティブを含んでいます(*note Configuration
     Headers::)．

   - `config.status'という名のシェルスクリプトで，それは実行時に上記でリ
     ストアップされているファイルを再生成します(*note config.status
     Invocation::)．

   - (`configure --config-cache'が使用されるときに作成される)
     `config.cache'という名のオプションのシェルスクリプトで，それは多く
     のテストの実行結果を保存しています(*note Cache Files::)．

   - `config.log'という名のコンパイラが生成する全てのメッセージを含んで
     いるファイルで，`configure'が失敗した場合はデバッグの助けとなり
     ます．

   Autoconfを用いて`configure'スクリプトを作成するために，Autoconf
の入力ファイル`configure.ac'(または`configure.in')を書き，
`autoconf'をそこで実行する必要があります．Autoconfでもたらされた
ものを補うために独自の機能テストを書く場合，`aclocal.m4'と
`acsite.m4'という名のファイルも書くことになるでしょう．
`#define'ディレクティブを含むCヘッダファイルを使用する場合，
`autoheader'も実行し，パッケージで生成されるファイル
`config.h.in'を配布することになるでしょう．

コンフィギュレーションで使用可能なファイルを生成する方法は，以下で示す図
の用になります．実行するプログラムには，`*'が付いています．オプショ
ンのファイルは角カッコ(`[]')で囲っています．`autoconf'と
`autoheader'は，Autoconfでインストールされる(`autoconf.m4'
が読む)マクロファイルも読み込みます．

ソフトウェアパッケージを配布する準備で使用されるファイルは，以下のように
なっています．
     your source files --> [autoscan*] --> [configure.scan] --> configure.ac

     configure.ac --.
                    |   .------> autoconf* -----> configure
     [aclocal.m4] --+---+
                    |   `-----> [autoheader*] --> [config.h.in]
     [acsite.m4] ---'

     Makefile.in -------------------------------> Makefile.in

ソフトウェアパッケージのコンフィグレーションで使用されるファイルは，以下
のようになっています．
                            .-------------> [config.cache]
     configure* ------------+-------------> config.log
                            |
     [config.h.in] -.       v            .-> [config.h] -.
                    +--> config.status* -+               +--> make*
     Makefile.in ---'                    `-> Makefile ---'

* Menu:

* Writing configure.ac::        What to put in an Autoconf input file
* autoscan Invocation::         Semi-automatic `configure.ac' writing
* ifnames Invocation::          Listing the conditionals in source code
* autoconf Invocation::         How to create configuration scripts
* autoreconf Invocation::       Remaking multiple `configure' scripts


File: autoconf-ja.info,  Node: Writing configure.ac,  Next: autoscan Invocation,  Up: Making configure Scripts

3.1 `configure.ac'を書く
========================

ソフトウェアパッケージの`configure'スクリプトを生成するため，パッ
ケージが必要とする，または利用可能なシステムの特徴をテストするAutoconfマ
クロの呼び出しを含んでいる，`configure.ac'と呼ばれるファイルを作成
してください．Autoconfマクロには，多くの特徴を調査するものはすでに存在し
ています．それら関する記述は，*Note Existing
Tests::を参照してください．ほ
とんどのその他の特徴に対しては，カスタムチェックを生成するAutoconfのテン
プレートマクロを使用することが可能です．それらに関する詳細は， *Note
Writing Tests::を参照してください．特にトリッキーな，または専門的な
特徴に対して，`configure.ac'に，若干の手作りのシェルコマンドを含め
る必要もあるでしょう．`autoscan'プログラムは`configure.ac'
を書くための良いきっかけ与えてくれます．(詳細は，*note autoscan
Invocation::)．

   Autoconfのこれまでのバージョンでは，名前`configure.in'を勧めていま
したが，それは曖昧で(このファイルを処理するために必要なツールは，拡張子
では分かりません)，`config.h.in'などで(`.in'は
"`configure'で生成される"という意味では)ちょっと混乱していまし
た．現在では，`configure.ac'の使用が好まれます．

* Menu:

* Shell Script Compiler::       Autoconf as solution of a problem
* Autoconf Language::           Programming in Autoconf
* configure.ac Layout::         Standard organization of `configure.ac'


File: autoconf-ja.info,  Node: Shell Script Compiler,  Next: Autoconf Language,  Up: Writing configure.ac

3.1.1 シェルスクリプトコンパイラ
--------------------------------

他のコンピュータ言語に対して，Autoconfで`configure.ac'を正しくプロ
グラムするために，言語が解決しようとする問題が_何_で，そうするため
に_どうする_のかを理解する必要があります．

Autoconfが解決する問題は，世界が混乱しているということです．結局，全ての
異なる種類のシステムでパッケージのコンパイルを簡単にするためにAutoconfを
使用しますが，それを極端に嫌う人も中にはいます．Autoconf自身は，これらの
差を価値あるものとして扱います．`configure'をこれらの全てのシス
テムで実行する必要があり，そのため，`configure' には，機能的にそ
れらの最小公倍数に制限する必要があります．

   通常，シェルスクリプトを考えるでしょう．`autoconf'が必要でしょう
か？正しく書かれたシェル関数の組み合わせで，手で`configure'スク
リプトを書くことを十分に簡単にします．ああ！残念ながら，シェル関数は最小
公倍数ではありません．そのため，関数を定義しそれを十回使用したいところで，
その本体を十回コピーする必要があるでしょう．

   そのため，本当に必要なものは，コンパイラのようなもの，すなわち
`autoconf'，Autoconfプログラムが受け入れるもの，すなわち
`configure.ac'，そして，それを移植性の高いシェルスクリプト
`configure'に変換するものです．

   どのようにして，`autoconf'がこの作業を実行するのでしょう？

可能性としては明らかに二つあります．新しい言語を作成すること，または既存
のものを拡張することです．前者は非常に魅力的です．あらゆる最適化が簡単に
実装可能で，Autoconfプログラムで厳密なチェックを実行することが可能です
(例えば，移植性のないあらゆる構成物は除外します)．あるいは，
`sh'(Bourne shell) 言語のように，既存の言語を拡張することが可能です．

   Autoconfは後者の方法で行なっています．それは`sh'の最上位層です．そ
のため，マクロを展開するものとして`autoconf'を実装することが最も
便利になっています．マクロ呼び出しをマクロの本体で置換し，最終的にピュア
な`sh'スクリプトを生成しながら，テキスト入力で"マクロ展開(macro
expansion)"を繰り返し実行するプログラムです．Autoconfマクロの展開に専念
して実装する代わりに，M4のような既存の一般的な目的を持つマクロ言語を使用
し，M4マクロの組み合わせとして拡張部分を実装する方が自然です．


File: autoconf-ja.info,  Node: Autoconf Language,  Next: configure.ac Layout,  Prev: Shell Script Compiler,  Up: Writing configure.ac

3.1.2 Autoconf言語
------------------

Autoconf言語は，プレーンテキスト同様に実際のコードを扱うので，多くの他の
コンピュータ言語と全く異なります．例えばCでは，データと命令は全く異なる
構文上のステータスとなりますが，Autoconfでは，それらのステータスは厳密に
同じです．このため，我々はリテラル文字列を展開されたテキストと区別する手
段が必要です．それは引用符です．

引数があるマクロを呼び出すとき，マクロ名と開いているカッコの間に空白があっ
てはなりません．引数は，M4の引用符文字`['と`]'で囲み，カンマで
分けるべきです．引数が単純なテキストのときは，引用符がなくても大丈夫かも
しれませんが，他のマクロの呼び出しのような複雑な引数は，_常に_引用
符で囲んでください．この規則は，他のマクロからの呼び出しを含め，全てのマ
クロ呼び出しで再帰的に適用されます．

   例えば，以下のようにします．

     AC_CHECK_HEADER([stdio.h],
                     [AC_DEFINE([HAVE_STDIO_H])],
                     [AC_MSG_ERROR([Sorry, can't do anything for you])])

これは，正しく引用符で囲まれます．その引用を以下のように単純にしても大丈
夫かもしれません．

     AC_CHECK_HEADER(stdio.h,
                     [AC_DEFINE(HAVE_STDIO_H)],
                     [AC_MSG_ERROR([Sorry, can't do anything for you])])

`AC_MSG_ERROR'の引数は，引用符で囲まれたままだということに注意して
ください．そうしない場合は，カンマは引数を分離するものとして解釈されるで
しょう．

   以下の例は，引用符で囲まれていないので，間違っていて危険です．

     AC_CHECK_HEADER(stdio.h,
                     AC_DEFINE(HAVE_STDIO_H),
                     AC_MSG_ERROR([Sorry, can't do anything for you]))

場合によっては，マクロ呼び出しのようなテキストを使用する必要があるかもし
れません．マクロ引数として渡されないときでもテキストは引用符で囲む必要が
あります．

     echo "Hard rock was here!  --[AC_DC]"

結果として以下のようになります．

     echo "Hard rock was here!  --AC_DC"

同じテキストをマクロ引数で使用するときは，そのために余分な引用符レベルを
追加する必要があります(一つはマクロ置換で削除されるためです)．従って一般
的に，_全てのリテラル文字列の引数に対して二重に引用符を使用すること_
は良い考えです．

     AC_MSG_WARN([[AC_DC stinks  --Iron Maiden]])

絶えず誤解されていたAutoconfの構成物の一つを，今では理解できるでしょう
....第一の規則は，_マクロ展開が予測されるところでは，引用符の
展開を予測してください_ということです．すなわち，引用符のレベルの一つが
失われるということです．例えば，以下のようにします．

     AC_COMPILE_IFELSE([char b[10];],, [AC_MSG_ERROR([you lose])])

これは正しいものです．ここで，`AC_COMPILE_IFELSE'最初の引数は， `char
b[10];'で，一度展開されて，結果として`char b10;'になりま
す．(M4の`changequote'プリミティブを用いてこの問題を解決することが，
一般的な慣習として以前のAutoconfにありましたが，それを使用しないでくださ
い！)さて，より詳しく見てみましょう．もう一方では，第一引数はリテラルと
して理解され，そのためそれは引用符で二重に囲む必要があります．

     AC_COMPILE_IFELSE([[char b[10];]],, [AC_MSG_ERROR([you lose])])

Voila`，今回は実際に`char b[10];'を生成しているのです！

   注意深く読んでいると，これらのガイドラインによれば，上記の例の
`AC_CHECK_HEADER'で引用符で"正しく"囲まれているものは，実際には三
組の引用符が足りないことに気付くでしょう！それにもかかわらず，可読性のた
め，リテラルを二重に引用符で囲むことは，このマニュアルでは必要なところで
のみ使用されます．

オプションの引数を受け入れるマクロもあり，それはこのドキュメントでは(引
用符の文字を使用して混乱しないように)，[ARG]として表現します．空の
ままにしたり，明示的に引数を空にするために`[]'を使用したり，単純に
後置されるカンマを省略したりすることが可能です．以下の三行は等価となりま
す．

     AC_CHECK_HEADERS(stdio.h, [], [], [])
     AC_CHECK_HEADERS(stdio.h,,,)
     AC_CHECK_HEADERS(stdio.h)

   `configure.ac'では，単独行にそれぞれのマクロ呼び出しを書くことが最
善です．ほとんどのマクロは，余分な改行を加えません．それらは，コマンドを
終端するためのマクロ呼び出しの後の改行に依存しています．このアプローチで
は，生成された`configure'スクリプトを，多くの空白行を挿入するこ
となく，若干読みやすくします．シェルは，改行に干渉されることなく割り当て
ることが可能なので，シェル変数をマクロ呼び出しと同じ行で設定すると，通常
は安全です．

   `configure.ac'ファイルに`#'で始まるコメントを含めることも可能
です．例えば，以下のような行を`configure.ac'ファイルの最初に書くと
役に立つでしょう．

     # Process this file with autoconf to produce a configure script.


File: autoconf-ja.info,  Node: configure.ac Layout,  Prev: Autoconf Language,  Up: Writing configure.ac

3.1.3 標準的な`configure.ac'のレイアウト
----------------------------------------

`configure.ac'でAutoconfマクロを呼び出す順番は，いくつか例外があり
ますが重要ではありません．すべての`configure.ac'では，調査の前の
`AC_INIT'の呼び出しと，最後の`AC_OUTPUT'の呼び出しを含める必要
があります(*note Output::)．さらに，いくつかの変数については，何を行なう
かを決定するため，前もって設定されている値を調査できるように，他のマクロ
が最初に呼ばれることに依存するマクロもあります．これらのマクロはそれぞれ
の説明で書かれていて(*note Existing Tests::)，`configure'が作成
されているとき，間違った順番で呼び出されている場合は警告されます．

整合性を促進するため，Autoconfマクロを呼び出す順番をここで提案します．一
般的に言って，このリストの終わり近くのものは，その前のものに依存します．
例えば，ライブラリ関数は型とライブラリの影響があります．

     Autoconfの必要条件
     `AC_INIT(PACKAGE, VERSION, BUG-REPORT-ADDRESS)'
     パッケージの情報
     プログラムの調査
     ライブラリの調査
     ヘッダファイルの調査
     型の調査
     構造体の調査
     コンパイラの特徴の調査
     ライブラリ関数の調査
     システムサービスの調査
     `AC_CONFIG_FILES([FILE...])'
     `AC_OUTPUT'


File: autoconf-ja.info,  Node: autoscan Invocation,  Next: ifnames Invocation,  Prev: Writing configure.ac,  Up: Making configure Scripts

3.2 `configure.ac'を作成するために`autoscan'を使用する
======================================================

`autoscan'プログラムは，ソフトウェアパッケージに対する
`configure.ac'ファイルの作成と/または管理に役に立ちます．
`autoscan'は，コマンドライン引数で与えられたディレクトリをルート
とするディレクトリツリー，または，与えられていない場合はカレントディレク
トリでソースファイルを調査します．それは，ソースファイルの一般的な移植性
の問題を検索して，パッケージに対する`configure.ac'の準備となるファ
イル`configure.scan'を作成し，あるいは存在している
`configure.ac'の完全性を調査します．

   `configure.ac'を作成するために`autoscan'を使用するとき，
`configure.scan'を`configure.ac'に改名する前に，手作業でそれを
調査する必要があります．恐らくなんらかの調整が必要です．時折
`autoscan'は，`autoconf'が警告を出すような，関連するマク
ロに対して間違った順序でマクロを出力する場合もあります．手作業でそのよう
なマクロを移動する必要があります．また，パッケージでコンフィギュレーショ
ンヘッダファイルを使用する場合も，`AC_CONFIG_HEADER'の呼び出しを加
える必要があります(*note Configuration Headers::)．また，Autoconfで動作
するように，プログラムの`#if'ディレクティブを変更したり加えたりする
必要があります(そのような仕事に役に立つプログラムの情報は， *note
ifnames Invocation::)．

   `configure.ac'を管理するために`autoscan'を使用しているとき，
単純にそれが追加した提案を検討してください．ファイル`autoscan.log'
には，マクロが要求される理由に関する詳細な情報が含まれています．

   `autoscan'は，パッケージのソースファイルで特定のシンボルを見つけ
たときに出力するマクロを決定するため，(Autoconfと一緒にインストールされ
ている)データファイルも使用します．これらのデータファイルはすべて同じ書
式です．それぞれの行は，シンボル，空白スペース，そしてそのシンボルがある
場合に出力するAutoconfマクロから成り立っています．`#'で始まる行はコ
メントです．

   `autoscan'は以下のオプションを受け入れます．

`--help'
`-h'
     コマンドラインオプションの概要を出力して終了します．

`--version'
`-V'
     Autoconfのバージョンナンバーを出力して終了します．

`--verbose'
`-v'
     調査しているファイルと，その中で見つかった興味深いものとなる可能性のある
     シンボル名を出力します．この出力は大量になるはずです．

`--include=DIR'
`-I DIR'
     DIRをインクルードパスの後に追加します．複数回の呼び出しで累積され
     ます．

`--prepend-include=DIR'

`-B DIR'
     DIRをインクルードパスの前に追加します．複数回の呼び出しで累積され
     ます．


File: autoconf-ja.info,  Node: ifnames Invocation,  Next: autoconf Invocation,  Prev: autoscan Invocation,  Up: Making configure Scripts

3.3 条件をリストアップするため`ifnames'を使用する
=================================================

`ifnames'は，ソフトウェアパッケージに対する`configure.ac'
を書くとき役に立つはずです．それは，Cプリプロセッサの条件式でパッケージ
が既に使用している識別子を出力します．パッケージが既に移植性に対して準備
されている場合，`ifnames'は`configure'で調査することが必
要なものを理解することに役く立つはずです．それは`autoscan'が生成
した`configure.ac'とのギャップを埋める役に立つかもしれません (*note
autoscan Invocation::)．

   `ifnames'は，コマンドラインで指名されたすべてのCソースファイルを
(無い場合は標準入力から)走査し，これらのファイルに現れる`#if'，
`#elif'，`#ifdef'，または`#ifndef'ディレクティブの，すべ
ての識別子をソートしたリストを標準出力に書き出します．それは，識別子があ
るファイルの空白で分離されたリストに続いて，一行にぞれぞれの識別子を出力
します．

`ifnames'は以下のオプションを受け入れます．

`--help'
`-h'
     コマンドラインオプションの概要を出力して終了します．

`--version'
`-V'
     Autoconfのバージョンナンバーを出力して終了します．


File: autoconf-ja.info,  Node: autoconf Invocation,  Next: autoreconf Invocation,  Prev: ifnames Invocation,  Up: Making configure Scripts

3.4 `configure'を作成するため`autoconf'を使用する
=================================================

`configure.ac'から`configure'を作成するために，
`autoconf'プログラムを引数無しで実行してください．
`autoconf'は，Autoconfマクロを使用しながら，M4マクロプロセッサを
用いて`configure.ac'を処理します．`autoconf'に引数を与えて
いる場合，`configure.ac'の代わりにそのファイルを読み，
`configure'の代わりに，標準出力にコンフィグレーションスクリプト
を書き出します．`autoconf'に引数`-'を与えた場合，
`configure.ac'の代わりに標準入力から読み込み，標準出力にコンフィグ
レーションスクリプトを書き出します．

Autoconfマクロは，複数のファイルで定義されています．ファイルにはAutoconf
と一緒に配布される物もあります．`autoconf'は最初にそれを読み込み
ます．オプションのファイル`acsite.m4'を，配布されたAutoconfマクロファ
イルを含むディレクトリで探し，オプションのファイル`aclocal.m4'はカ
レントディレクトリで探します．これらのファイルは，サイトやパッケージの
Autoconfマクロ定義を含めることが可能です(詳細は，*note Writing Autoconf
Macros::)．一つ以上のファイルで定義されているマクロを`autoconf'が
読み込む場合，最後の定義がそれ以前の定義に優先します．

   `autoconf'は以下のオプションを受け入れます．

`--help'
`-h'
     コマンドラインオプションの概要を出力して終了します．

`--version'
`-V'
     Autoconfのバージョンナンバーを出力して終了します．

`--verbose'
`-v'
     処理しているステップを報告します．

`--debug'
`-d'
     一時的なファイルを削除しません．

`--force'
`-f'
     入力ファイルより`configure'が新しい場合でも，それを再生成します．

`--include=DIR'
`-I DIR'
     DIRをインクルードパスの後に追加します．複数回の呼び出しで累積され
     ます．

`--prepend-include=DIR'

`-B DIR'
     DIRをインクルードパスの前に追加します．複数回の呼び出しで累積され
     ます．

`--output=FILE'
`-o FILE'
     (出力や追跡の)出力をFILEに保存します．ファイル`-'は標準出力
     に対するものです．

`--warnings=CATEGORY'
`-W CATEGORY'
     (実際にはカンマで分けたリストが可能な)CATEGORYに関連する警告を報告
     します．カテゴリの総合的なリストは，マクロ`AC_DIAGNOSE'と *Note
     Reporting Messages::.  特別な値には，以下のものが含まれています．

    `all'
          全ての警告を報告します．

    `none'
          何も報告しません．

    `error'
          警告をエラーとして扱います．

    `no-CATEGORY'
          CATEGORYに分類される警告を利用不可能にします．

     `syntax'に関する警告はデフォルトで利用可能で，カンマで分けられたカ
     テゴリリストの環境変数`WARNINGS'は尊重されます．`-W
     CATEGORY'を渡すことで，
     `--warnings=syntax,$WARNINGS,CATEGORY'が渡されたかのように動
     作します．デフォルトと`WARNINGS'を利用不可能にしたいが，(例えば) 時
     代遅れの構成物についての警告は利用可能にしたい場合，`-W
     none,obsolete'を使用してください．

     `autoconf'はバックグラウンドで`autom4te'を使用するので，
     それはエラーのバックトレースを表示しますが，警告については行ないません．
     そうしたい場合，`-W error'のみを渡してください．いくつかの例は，
     *Note autom4te Invocation::.

`--trace=MACRO[:FORMAT]'
`-t MACRO[:FORMAT]'
     `configure'スクリプトを作成しませんが，FORMATでマクロの呼
     び出しをリストアップします．複数の`--trace'の引数は，複数のマクロ
     をリストアップするために使用可能です．単一のマクロに対する複数の
     `--trace'の引数は，累積的ではありません．その代わりにFORMAT
     を必要なものにすべきです．

     FORMATは，必要な場合は改行をともなう通常の文字列と，いくつかの特殊
     なエスケープコードです．デフォルトは`$f:$l:$n:$%'です．FORMAT
     の詳細は，*Note autom4te Invocation::を参照してください．

`--initialization'
`-i'
     デフォルトで，`--trace'はAutoconfマクロ(特に`AC_DEFUN'の定義)
     の初期化を追跡しません．これで顕著に高速化されますが，このオプションで利
     用不可能にすることができます．

   `configure.ac'ファイルの内容を調査する必要があることもよくあります
が，自分で解析することは，非常に脆くエラーを起こしやすいものです．
`configure.ac'をスキャンするために，`--trace'を信頼してみて
ください．例えば，置換される変数のリストを見つけるため，以下のようにして
みてください．

     $ autoconf -t AC_SUBST
     configure.ac:2:AC_SUBST:ECHO_C
     configure.ac:2:AC_SUBST:ECHO_N
     configure.ac:2:AC_SUBST:ECHO_T
     More traces deleted

以下の例では，`$@'，`$*'と*$%*の違いを強調しています．

     $ cat configure.ac
     AC_DEFINE(This, is, [an
     [example]])
     $ autoconf -t 'AC_DEFINE:@: $@
     *: $*
     $: $%'
     @: [This],[is],[an
     [example]]
     *: This,is,an
     [example]
     $: This:is:an [example]

FORMATは，柔軟にできます．

     $ autoconf -t 'AC_SUBST:$$ac_subst{"$1"} = "$f:$l";'
     $ac_subst{"ECHO_C"} = "configure.ac:2";
     $ac_subst{"ECHO_N"} = "configure.ac:2";
     $ac_subst{"ECHO_T"} = "configure.ac:2";
     More traces deleted

長いSEPARATORは，複雑な構想の可読性を改善したり，解析を簡単にする
ために使用可能です(例えば，分離文字に適した単一文字が無いときです)．

     $ autoconf -t 'AM_MISSING_PROG:${|:::::|}*'
     ACLOCAL|:::::|aclocal|:::::|$missing_dir
     AUTOCONF|:::::|autoconf|:::::|$missing_dir
     AUTOMAKE|:::::|automake|:::::|$missing_dir
     More traces deleted


File: autoconf-ja.info,  Node: autoreconf Invocation,  Prev: autoconf Invocation,  Up: Making configure Scripts

3.5 `configure'スクリプトを更新するため`autoreconf'を使用する
=============================================================

GNUビルドシステムの様々なコンポーネントをインストールすること
は退屈なものです．それは，Gettextに対する`autopoint'，
`Makefile.in'や`automake'等を，それぞれのディレクトリで実行
することを意味します．`automake'のようなツールが更新されたり，
`configure.ac'のようなソースが更新されたり，ただ単純にGNU
ビルドシステムを新しいツリーにインストールするためだけでも，そうすること
が必要になるかもしれません．

   `autoreconf'は，指定されたディレクトリとそのサブディレクトリ (*note
Subdirectories::)で，GNUビルドシステムを更新するために，
`autoconf'，`autoheader'，`aclocal'，
`automake'，`libtoolize'，そして(適切なときは)
`autopoint'を繰り返し実行します．デフォルトで，ソースファイルよ
り古いファイルだけが再生成されます．

   新しいバージョンのツールをインストールした場合，`autoreconf'に
`--force'オプションを与えることで，_すべての_ファイルを再生
成することが可能です．

   ソースファイルを変更したとき，`configure'スクリプトを自動的に再
生成する`Makefile'ルールについては，*Note Automatic Remaking::.  そ
の方法は，コンフィギュレーションヘッダテンプレートのタイムスタンプを正確
に処理しますが，`--autoconf-dir=DIR'や `--localdir=DIR'を渡しません．

`autoreconf'は以下のオプションを受け入れます．

`--help'
`-h'
     コマンドラインオプションの概要を出力して終了します．

`--version'
`-V'
     Autoconfのバージョンナンバーを出力して終了します．

`--verbose'
     `autoreconf'が`autoconf'(と適切な場合は
     `autoheader')を実行している，それぞれのディレクトリ名を出力しま
     す．

`--debug'
`-d'
     一時ファイルを削除しません．

`--force'
`-f'
     `configure'スクリプトとコンフィグレーションヘッダが入力ファイル
     (`configure.ac'と，存在する場合は`aclocal.m4')より新しくても更
     新します．

`--install'
`-i'
     パッケージの足りない補助ファイルをインストールします．デフォルトで，ファ
     イルはコピーされます．`--symlink'で変更することも可能です．

     このオプションは，`automake --add-missing'，`libtoolize'，
     `autopoint'等を呼び出すきっかけにもなります．

`--symlink'
`-s'
     `--install'とともに使用されるとき，足りない補助ファイルをコピーす
     る代わりに，シンボリックリンクを配置します．

`--make'
`-m'
     ディレクトリがコンフィグレーションされるとき，`./config.status
     --recheck &&
     ./config.status'を実行してコンフィグレーションを更新し，
     `make'を実行します．

`--include=DIR'
`-I DIR'
     DIRをインクルードパスの後に追加します．複数回の呼び出しで累積され
     ます．

`--prepend-include=DIR'

`-B DIR'
     DIRをインクルードパスの前に追加します．複数回の呼び出しで累積され
     ます．

`--warnings=CATEGORY'
`-W CATEGORY'
     (実際にはカンマで分離されているリストになっている)CATEGORYに関連す
     る警告を報告します．

    `cross'
          クロスコンパイルの問題に関連するもの．

    `obsolete'
          時代遅れの構成物の使用を報告．

    `portability'
          移植性の問題．

    `syntax'
          曖昧な構文の構成物．

    `all'
          すべての警告を報告．

    `none'
          何も報告しない．

    `error'
          警告をエラーとして処理．

    `no-CATEGORY'
          CATEGORYに分類される警告を利用不可能にする．

     `syntax'の警告はデフォルトで利用可能で，カンマでカテゴリを分離した
     リストとなっている環境変数`WARNINGS'は尊重されます．`-W
     CATEGORY'を渡すと，実際には
     `--warnings=syntax,$WARNINGS,CATEGORY'を渡したかのように動作
     します．デフォルトのものと`WARNINGS'を利用不可能にし，(例えば) 時代
     遅れの構成物に関する警告を利用可能にしたい場合`-W none,obsolete'
     を使用してください．


File: autoconf-ja.info,  Node: Setup,  Next: Existing Tests,  Prev: Making configure Scripts,  Up: Top

4 出力ファイルの初期化
**********************

Autoconfが生成した`configure'スクリプトは，パッケージのソースファ
イルの見つけ方，そして，生成する出力ファイルといった，初期化の方法の情報
を必要とします．以下のセクションで，初期化と出力ファイルの作成について述
べます．

* Menu:

* Initializing configure::      Option processing etc.
* Notices::                     Copyright, version numbers in `configure'
* Input::                       Where Autoconf should find files
* Output::                      Outputting results from the configuration
* Configuration Actions::       Preparing the output based on results
* Configuration Files::         Creating output files
* Makefile Substitutions::      Using output variables in `Makefile's
* Configuration Headers::       Creating a configuration header file
* Configuration Commands::      Running arbitrary instantiation commands
* Configuration Links::         Links depending on the configuration
* Subdirectories::              Configuring independent packages together
* Default Prefix::              Changing the default installation prefix


File: autoconf-ja.info,  Node: Initializing configure,  Next: Notices,  Up: Setup

4.1 `configure'の初期化
=======================

すべての`configure'スクリプトファイルでは，他の何よりも前に，
`AC_INIT'を呼び出す必要があります．そのほかに必要なマクロは
`AC_OUTPUT'だけです(*note Output::)．

 -- Macro: AC_INIT (PACKAGE, VERSION, [BUG-REPORT], [TARNAME])
     あらゆるコマンドライン引数を処理し，様々な初期化と検証を実行します．

     PACKAGEの名前とそのVERSIONを設定します．これらは通常，
     `configure'に含まれる`--version'のサポートで使用されます．
     オプションの引数BUG-REPORT-ADDRESSは，ユーザがバグレポートを送る電
     子メールアドレスにすべきです．パッケージのTARNAMEはPACKAGEと
     は異なります．後者はパッケージの完全な名前を示します(例えば，`GNU
     Autoconf')が，前者は配布物のtar ballの名前(例えば，`autoconf')を意
     味します．デフォルトはPACKAGEから`GNU ' を取り除き，小文字に
     し，そして英数文字以外を全て`-'にしたものです．

     `AC_INIT'の引数は静的にすることが望ましく，すなわちシェルで演算して
     求めるべきではありませんが，M4で演算してもかまいません．

     以下のM4マクロ(例えば，`AC_PACKAGE_NAME')は，`AC_INIT'によって，
     出力変数(例えば，`PACKAGE_NAME')を出力し，プリプロセッサシンボル(例
     えば，`PACKAGE_NAME')を定義します．

    `AC_PACKAGE_NAME', `PACKAGE_NAME'
          そのままPACKAGEになります．

    `AC_PACKAGE_TARNAME', `PACKAGE_TARNAME'
          そのままTARNAMEになります．

    `AC_PACKAGE_VERSION', `PACKAGE_VERSION'
          そのままVERSIONになります．

    `AC_PACKAGE_STRING', `PACKAGE_STRING'
          そのまま`PACKAGE VERSION'になります．

    `AC_PACKAGE_BUGREPORT', `PACKAGE_BUGREPORT'
          そのままBUG-REPORTになります．


File: autoconf-ja.info,  Node: Notices,  Next: Input,  Prev: Initializing configure,  Up: Setup

4.2 `configure'の注意事項
=========================

以下のマクロは，`configure'スクリプトのバージョンナンバーを管理
します．それはオプションとして使用されます．

 -- Macro: AC_PREREQ (VERSION)
     使用しているAutoconfのバージョンが十分新しいことを保証します．
     `configure'の作成に使用されるAutoconfのバージョンが，
     VERSION以前の場合，標準エラー出力にエラーメッセージを出力し，異常
     終了します(終了ステータスは63です)．例えば以下のようにします．

          AC_PREREQ(2.59)

     このマクロは，`AC_INIT'以前に使用可能な唯一のマクロですが，整合性の
     ためにはそうすべきではありません．

 -- Macro: AC_COPYRIGHT (COPYRIGHT-NOTICE)
     AutoconfマクロへのFree Software Foundationの著作権に加えて，
     `configure'についてCOPYRIGHT-NOTICEでカバーしたい部分を宣
     言してください．

     COPYRIGHT-NOTICEは，`configure'の先頭と，`configure
     --version'の両方で表示されます．

 -- Macro: AC_REVISION (REVISION-INFO)
     リビジョンスタンプREVISION-INFOを，ドル記号やダブルクォートを削除
     して`configure'スクリプトにコピーします．このマクロは，
     `configure'をチェックインしたときにRCSやCVS
     がリビジョンスタンプを変えなくても，`configure.ac'から
     `configure'にそれを書き込みます．そうすることで，特定の
     `configure'に対応する`configure.ac'のリビジョンが簡単に決定
     可能になります．

     例えば，以下の行を`configure.ac'に書いたとします．

          AC_REVISION($Revision: 1.30 $)

     これで，`configure'は以下のようになります．

          #! /bin/sh
          # From configure.ac Revision: 1.30


File: autoconf-ja.info,  Node: Input,  Next: Output,  Prev: Notices,  Up: Setup

4.3 `configure'の入力を見つける
===============================

 -- Macro: AC_CONFIG_SRCDIR (UNIQUE-FILE-IN-SOURCE-DIR)
     UNIQUE-FILE-IN-SOURCE-DIRは，パッケージのソースディレクトリにある
     ファイルです．`configure'は，伝えられたディレクトリに実際にソー
     スコードが含まれていることを確認するために，このファイルの存在を調査しま
     す．`--srcdir'で間違ったディレクトリを指定してしまう人もいます．
     これは安全性の調査です．詳細は，*Note configure Invocation::.

   手動でのコンフィグレーションや，`install'プログラムを使用するパッケー
ジは，デフォルトの位置でほとんど正しいのですが，`AC_CONFIG_AUX_DIR'
を呼び出して，他のシェルスクリプトを探す場所を`configure'に教え
る必要があるかもしれません．

 -- Macro: AC_CONFIG_AUX_DIR (DIR)
     ディレクトリDIRにある補助的なビルドツール(例えば，
     `install-sh'，`config.sub'， `config.guess'，そしてCygnus
     `configure'スクリプト)を使用します．DIRは，絶対パスまたは
     `SRCDIR'の相対パスが可能です．デフォルトは
     `SRCDIR'または`SRCDIR/..'または
     `SRCDIR/../..'で，`install-sh'を含んでいる最初にところで
     す．他のファイルは調査しないので，`AC_PROG_INSTALL'を使用することで，
     他の補助ファイルを配布する必要は自動的になくなります．また，それは
     `install.sh'も調査しますが，`make'プログラムには，
     `Makefile'が無い場合，それから`install'を作るルールを持ってい
     るものあるので，その名前は時代遅れです．

   同様に，`aclocal'を使用しているパッケージでは，ローカルマクロが
見つかる場所を`AC_CONFIG_MACRO_DIR'を使用して宣言すべきです．

 -- Macro: AC_CONFIG_MACRO_DIR (DIR)
     将来のバージョンの`autopoint'，`libtoolize'，
     `aclocal'，そして`autoreconf'は，ディレクトリDIRを，
     追加のローカルなAutoconfマクロがある場所として使用します．このマクロを，
     `aclocal'に対してインストールされているマクロがあるツールで，
     `--trace'が安全に呼び出される前に宣言が見つかるように，直接
     `configure.ac'から確実に呼び出して下さい．


File: autoconf-ja.info,  Node: Output,  Next: Configuration Actions,  Prev: Input,  Up: Setup

4.4 出力ファイルを生成する
==========================

すべてのAutoconfスクリプト，例えば`configure.ac'は，
`AC_OUTPUT'の呼び出しで終えるべきです．それは，コンフィグレーション
の結果生成される`Makefile'とその他のファイルを生成する，
`config.status'を生成し実行するマクロです．`AC_INIT'以外で唯一
必要とされるマクロです(*note Input::)．

 -- Macro: AC_OUTPUT
     `config.status'を生成し，その実行を開始します．`configure.ac'
     の最後にこのマクロを一度呼び出してください．

     `config.status'は，全てのコンフィグレーション作業を実行します．全て
     の出力ファイル(*Note Configuration
     Files::とマクロ`AC_CONFIG_FILES'を
     参照してください)，ヘッダファイル(*Note Configuration
     Commands::とマクロ
     `AC_CONFIG_COMMANDS'を参照してください)，コマンド (*Note
     Configuration Commands::とマクロ`AC_CONFIG_COMMANDS'を参照して
     ください)，リンク(*Note Configuration Links::とマクロ
     `AC_CONFIG_LINKS'を参照してください)，サブディレクトリ (*Note
     Configuration Links::とマクロ`AC_CONFIG_LINKS'を参照してくださ
     い)が尊重されます．

     `AC_OUTPUT'を呼び出す場所が，コンフィグレーションの実行をする場所に
     なります．それ以降のコードは，`config.status'が実行された後に，
     `configure'によって一度実行されます．動作を(`configure' が
     実行されているかどうかに依存しないように)`config.status'自身に組
     み込みたい場合，*Note Running Arbitrary Configuration Commands:
     Configuration Commands.を参照して下さい．

   歴史的には，`AC_OUTPUT'の使用はいくぶん異なっています．
`AC_OUTPUT'がサポートする引数の記述は，*Note Obsolete Macros::.

   サブディレクトリで`make'を実行する場合，`make'を変数
`MAKE'を使用して実行すべきです．たいていのバージョンの
`make'で，`MAKE'に`make'プログラムと，それに与える
あらゆるオプションを追加して設定します．(しかし，その中にコマンドライン
で設定された値を含まないものも多いので，それらは自動的に渡されません．)
古いバージョンの`make'には，変数を設定しないものもあります．以下
のマクロでそれらのバージョンでも使用可能になります．

 -- Macro: AC_PROG_MAKE_SET
     `make'がMake変数`MAKE'を前もって定義している場合，出力変数
     `SET_MAKE'は空で定義されます．それ以外では，`SET_MAKE'は
     `MAKE=make'を含みます．`SET_MAKE'に対して`AC_SUBST'を呼び
     出して下さい．

   このマクロを使用する場合，`MAKE'を実行する他のディレクトリのそれぞ
れの`Makefile.in'に以下の行を書き込んで下さい．

     @SET_MAKE@


File: autoconf-ja.info,  Node: Configuration Actions,  Next: Configuration Files,  Prev: Output,  Up: Setup

4.5 コンフィグレーション作業の実行
==================================

`configure'は，自分が行なっていることが全部分かるように設計されてい
ますが，隠されている従属物も実際にはあります．それは，
`config.status'です．`configure'はシステムの調査を担当していま
すが，`configure'の結果を基に適切な動作を実際に引き受けるのは，
`config.status'です．`config.status'のほとんどの典型的な作業は，
ファイルを_実際に作成する_ことです．

このセクションでは，実際に何かを作成する基本的な四つのマクロの一般的な動
作を説明します．それらは，`AC_CONFIG_FILES'，
`AC_CONFIG_HEADERS'，`AC_CONFIG_COMMANDS'，そして
`AC_CONFIG_LINKS'です．それらは全て以下のものが原型となっています．

     AC_CONFIG_FOOS(TAG..., [COMMANDS], [INIT-CMDS])

ここでの引数は，以下のとおりです．

TAG...
     空白で分けられたタグのリストで，それらは通常，実際に作成されるファイル名
     です．

     TAGSとして，リテラルを使用することを勧めます．特に，以下は避けた方
     が良いでしょう．

          ... && my_foos="$my_foos fooo"
          ... && my_foos="$my_foos foooo"
          AC_CONFIG_FOOS($my_foos)

     この代わりに以下のようにしてください．

          ... && AC_CONFIG_FOOS(fooo)
          ... && AC_CONFIG_FOOS(foooo)

     マクロ`AC_CONFIG_FILES'と`AC_CONFIG_HEADERS'は，特別な
     TAGを使用します．それらは，`OUTPUT'や
     `OUTPUT:INPUTS'にすることが可能です．ファイル
     OUTPUTは，そのテンプレートINPUTSから実際に作成されます(デフォ
     ルトは`OUTPUT.in')．

     例えば，`AC_CONFIG_FILES(Makefile:boiler/top.mk:boiler/bot.mk)'は，
     `boiler/top.mk'と`boiler/bot.mk'を繋げたものに，出力変数を展開
     した`Makefile'を作成するよう要求します．

     特殊な値`-'は，OUTPUTで使用されているときは標準出力を，
     INPUTSで使用されているときは標準入力を示すために使用されます．おそ
     らく`configure.ac'でこれを使用する必要はほとんど無いと思いますが，
     `./config.status'のコマンドラインインターフェースを使用しているとき
     は便利でしょう．詳細は，*Note config.status
     Invocation::,を参照してくださ い．

     INPUTSは，絶対パスまたは相対パスを用いたファイル名が可能です．後者
     の場合，それは最初にビルドツリーで探され，その後でソースツリーで探されま
     す．

COMMANDS
     `config.status'にそのまま出力されるシェルコマンドで，実行するコマン
     ドを`config.status'に伝えるためにユーザが使用することが可能な
     TAGに関連付けされています．TAGの要求が`config.status'
     に与えられるたびにコマンドが実行され，通常はファイル`TAG'が作
     成されるたびになります．

     `configure'の実行中に設定される変数は，ここでは利用_不可能_
     です．それらを最初にINIT-CMDSで設定する必要があります．それにもか
     かわらず，以下の変数は前もって求められます．

    `srcdir'
          ビルドディレクトリのトップからソースディレクトリのトップへのパスです．こ
          れは，`configure'のオプション`--srcdir'で設定されるもので す．

    `ac_top_srcdir'
          現在のビルドディレクトリからソースディレクトリのトップへのパスです．

    `ac_top_builddir'
          現在のビルドディレクトリからビルドディレクトリのトップへのパスです．連結
          できるように，それを空にしたり，スラッシュで終えることが可能です．

    `ac_srcdir'
          現在のビルドディレクトリから対応するソースディレクトリへのパスです．

     "現在の(current)"ディレクトリは，TAGSの一部の入力が含まれるディ
     レクトリ(または疑似ディレクトリ)を参照します．例えば以下を実行したとしま
     す．

          AC_CONFIG_COMMANDS([deep/dir/out:in/in.in], [...], [...])

     `--srcdir=../package'を用いると，以下の値が生成されます．

          # Argument of --srcdir
          srcdir='../package'
          # Reversing deep/dir
          ac_top_builddir='../../'
          # Concatenation of $ac_top_builddir and srcdir
          ac_top_srcdir='../../../package'
          # Concatenation of $ac_top_srcdir and deep/dir
          ac_srcdir='../../../package/deep/dir'

     `in/in.in'とは無関係です．

INIT-CMDS
     `config.status'の先頭付近に_引用符で囲まれることなく_出力され
     るシェルコマンドで，`config.status'が実行されるたびに(TAG に
     関係なく)実行されます．引用符で囲まれていないので，例えば，`$var'は
     `var'の値として出力されます．INIT-CMDSは通常，COMMANDS
     を実行するために必要な同じ変数を`config.status'に与えるために，
     `configure'で使用されます．

     変数名では特に注意すべきです．すべてのINIT-CMDSは同じ名前空間を共
     有し，それぞれ予測できない方法で上書きされるかもしれません．残念です
     ....

   当然ですが，すべてのこれらのマクロは，異なるTAGを用いると，何回で
も呼び出すことが可能です！


File: autoconf-ja.info,  Node: Configuration Files,  Next: Makefile Substitutions,  Prev: Configuration Actions,  Up: Setup

4.6 コンフィグレーションファイルの作成
======================================

きちんとこの前の章を読んでくださいね，*Note Configuration Actions::．

 -- Macro: AC_CONFIG_FILES (FILE..., [CMDS], [INIT-CMDS])
     出力変数の値を置換しながら入力ファイル(デフォルトは`FILE.in')
     をコピーすることで，`AC_OUTPUT'でそれぞれの`FILE'を作成
     するようにします．
     このマクロは，実際に何かを作成するマクロの一つです．*Note
     Configuration
     Actions::を参照してください．出力変数を使用することの詳細な情報は，
     *Note Makefile Substitutions::.
     それらを作成するための詳細な情報は， *Note Setting Output
     Variables::.  これらのマクロは，存在しない場合はファ
     イルを配置するディレクトリを作成します．通常，`Makefile'はこの方法
     で作成されますが，`.gdbinit'のようなそれ以外のファイルは，指定され
     ていることもあります．

     一般的な`AC_CONFIG_FILES'の呼び出しは，以下のようになります．

          AC_CONFIG_FILES([Makefile src/Makefile man/Makefile X/Imakefile])
          AC_CONFIG_FILES([autoconf], [chmod +x autoconf])

     コロンで分離されている入力ファイルFILEのリストを入力ファイルに追加
     することで，優先可能です．例えば以下のようにします．

          AC_CONFIG_FILES([Makefile:boiler/top.mk:boiler/bot.mk]
                          [lib/Makefile:boiler/lib.mk])

     こうすることで，ファイル名をMS-DOSが受け入れ可能なままにしたり，ファイル
     に常套句を前置したり後置したりすることが可能となります．


File: autoconf-ja.info,  Node: Makefile Substitutions,  Next: Configuration Headers,  Prev: Configuration Files,  Up: Setup

4.7 Makefileへの代入
====================

コンパイルされたりインストールされたりするものを含んでいる，配布物のそれ
ぞれのサブディレクトリには，`configure'がそのディレクトリに
`Makefile'を作成するためのファイル`Makefile.in'を配置すべきで
す．`Makefile'を作成するために，`Makefile.in'の
`@VARIABLE@'を`configure'が決定したその変数の値に置
換しながら，`configure'は単純な変数の代入を行います．このように
して出力ファイルに代入される変数は，"出力変数(output variable)"と呼
ばれます．それらは`configure'で設定される普通のシェル変数です．
`configure'が特定の変数を出力ファイルに代入するように，変数名を
引数として`AC_SUBST'マクロを呼び出す必要があります．他の変数に対す
る`@VARIABLE@'が変化することはありません．`AC_SUBST'を
用いた出力変数の作成方法の詳細は，*Note Setting Output Variables::.

   `configure'スクリプトを使用しているソフトウェアパッケージは，ファ
イル`Makefile.in'と一緒に配布すべきですが，`Makefile'は配布す
べきではありません．つまり，ユーザはコンパイルする前にローカルシステムに
対して，正しくパッケージをコンフィグレーションする必要があります．

   `Makefile'に書くものの詳細は*Note Makefile Conventions:
(standards)Makefile Conventions.

* Menu:

* Preset Output Variables::     Output variables that are always set
* Installation Directory Variables::  Other preset output variables
* Build Directories::           Supporting multiple concurrent compiles
* Automatic Remaking::          Makefile rules for configuring


File: autoconf-ja.info,  Node: Preset Output Variables,  Next: Installation Directory Variables,  Up: Makefile Substitutions

4.7.1 出力変数のプリセット
--------------------------

Autoconfマクロが前もって設定する出力変数もあります．追加の出力変数を設定
するAutoconfマクロもあり，それは，それらのマクロの記述で言及されています．
出力変数の完全なリストは，*Note Output Variable Index::.
以下はそれぞれ，
それ以外のプリセットされたもののリストです．それらは全て大切な値です
(*note Setting Output Variables::, `AC_ARG_VAR')．

 -- Variable: CFLAGS
     Cコンパイラに対する，デバッグと最適化のオプションです．
     `configure'を実行するときに環境変数で設定されていない場合，
     `AC_PROG_CC'を呼び出すときにデフォルト値が設定されます(そうでない場
     合は空になります)．Cの特徴をテストするためのプログラムをコンパイルすると
     き，`configure'はこの変数を使用します．

 -- Variable: configure_input
     `configure'によって自動的に生成されるファイルを告げ，入力ファイ
     ル名を与えるコメントです．`AC_OUTPUT'は，それが作成するすべての
     `Makefile'の最初に，この変数を含むコメント行を加えます．それ以外の
     ファイルは，それぞれの入力ファイルの最初のコメントで，この変数を参照すべ
     きです．例えば，入力シェルスクリプトの最初は以下のようにすべきです．

          #! /bin/sh
          # @configure_input@

     またその行の存在で，ファイルを編集している人は，`configure'を使
     用して処理する必要があることを思い出します．

 -- Variable: CPPFLAGS
     ヘッダファイルを探すディレクトリ(`-IDIR')と，Cプリプロセッサ
     とCコンパイラに対する，その他の雑多なオプションです．`configure'
     を実行するときに環境変数で設定されていない場合，デフォルト値は空になりま
     す． `configure'は，Cの特徴をテストするプログラムのコンパイルや
     プリプロセス時にこの変数を使用します．

 -- Variable: CXXFLAGS
     C++コンパイラの，デバッグと最適化のオプションです．`configure'
     を実行するときに環境変数で設定されていない場合，`AC_PROG_CXX'を呼び
     出したときにデフォルト値に設定されます(そうでない場合は空になります)．
     `configure'は，C++の特徴をテストするプログラムのコンパイル時に，
     この変数を使用します．

 -- Variable: DEFS
     Cコンパイラに渡す`-D'オプションです．`AC_CONFIG_HEADER'が呼び
     出されている場合，`configure'は`@DEFS@'の代わりに
     `-DHAVE_CONFIG_H'に置換します(*note Configuration Headers::)．この
     変数は，`configure'がテストを実行している間は定義されず，出力ファ
     イルを作成するときだけ定義されます．前のテストの結果を調査する方法は，
     *Note Setting Output Variables::.

 -- Variable: ECHO_C
 -- Variable: ECHO_N
 -- Variable: ECHO_T
     質問と回答のメッセージの組に対して，`echo'に後置される改行を抑制す
     る方法は？これらの変数は，その方法を提供します．

          echo $ECHO_N "And the winner is... $ECHO_C"
          sleep 100000000000
          echo "${ECHO_T}dead."

     古く一般的でない`echo'の実装では，これを達成する意味が無いものもあ
     り，その場合，`ECHO_T'はタブをに設定されます．そうしたくないかもし
     れません．

 -- Variable: FCFLAGS
     Fortranコンパイラに対するデバッグと最適化のオプションです．
     `configure'の実行時に環境変数で設定されていない場合，
     `AC_PROG_FC'の予備出し時デフォルト値が設定されます(またはそうなけれ
     ば空になります)．`configure'は，Fortranの特徴を調査するプログラ
     ムをコンパイルするとき，この変数を使用します．

 -- Variable: FFLAGS
     Fortran 77コンパイラの，デバッグと最適化オプションです．
     `configure'を実行するときに環境変数で設定されていない場合，
     `AC_PROG_F77'を呼び出したときデフォルト値に設定されます(そうでない
     場合は空になります)．`configure'は，Fortran 77の特徴をテストする
     プログラムのコンパイル時に，この変数を使用します．

 -- Variable: LDFLAGS
     strip(`-s')，パス(`-L')，その他のあらゆる雑多なリンカに対す
     るオプションです．`configure'を実行するときに環境変数で設定され
     ていない場合，デフォルト値は空になります．`configure'は，C，C++，
     そしてFortranの特徴をテストするプログラムのリンク時に，この変数を使用し
     ます．

 -- Variable: LIBS
     リンカに渡す`-l'オプションです．デフォルト値は空ですが，ライブラリ
     が見つかり，必要な関数を提供する場合，Autoconfマクロはこの変数に追加のラ
     イブラリを前置するかもしれません．*Note
     Libraries::を参照してください．
     `configure'は，C，C++，そしてFortranの特徴をテストするプログラム
     のリンク時に，この変数を使用します．

 -- Variable: builddir
     `.'と厳密に等価です．対称性のために追加されました．

 -- Variable: abs_builddir
     `builddir'の絶対パスです．

 -- Variable: top_builddir
     現在のビルドツリーのトップレベルへの相対パスです．トップレベルのディレク
     トリは，ここでは`builddir'と同じです．

 -- Variable: abs_top_builddir
     `top_builddir'の絶対パスです．

 -- Variable: srcdir
     `Makefile'に対するソースコードを含んでいるディレクトリへの相対パス
     です．

 -- Variable: abs_srcdir
     `srcdir'の絶対パスです．

 -- Variable: top_srcdir
     パッケージのためのソースコードのトップレベルのディレクトリへの相対パスで
     す．トップレベルのディレクトリは，ここでは`srcdir'と同じです．

 -- Variable: abs_top_srcdir
     `top_srcdir'の絶対パスです．


File: autoconf-ja.info,  Node: Installation Directory Variables,  Next: Build Directories,  Prev: Preset Output Variables,  Up: Makefile Substitutions

4.7.2 インストールディレクトリの変数
------------------------------------

以下の変数は，パッケージがインストールされる場所を指定します．詳細は，
*Note Variables for Installation Directories: (standards)Directory
Variables.を参照してください．これら
の変数を使用するときとその方法の詳細は，このセクションの終りを参照してく
ださい．

 -- Variable: bindir
     ユーザが実行する実行形式をインストールするディレクトリです．

 -- Variable: datadir
     読み込み専用のアーキテクチャに依存しないデータをインストールするディレク
     トリです．

 -- Variable: exec_prefix
     アーキテクチャに依存するファイルをインストールするプレフィクスです．デフォ
     ルトはPREFIXと同じです．EXEC_PREFIXにいろいろなものを直接イ
     ンストールすることは避けた方が良いでしょう．しかし，アーキテクチャに依存
     するファイルを含むディレクトリに対するデフォルト値は，EXEC_PREFIX
     から相対的なものにすべきです．

 -- Variable: includedir
     Cヘッダファイルをインストールするディレクトリです．

 -- Variable: infodir
     Info形式のドキュメントをインストールするディレクトリです．

 -- Variable: libdir
     オブジェクトコードライブラリをインストールするディレクトリです．

 -- Variable: libexecdir
     他のプログラムが実行する，実行可能なプログラムをインストールするディレク
     トリです．

 -- Variable: localstatedir
     修正可能なシングルマシンのデータをインストールするディレクトリです．

 -- Variable: mandir
     man形式のドキュメントをインストールするトップレベルのディレクトリです．

 -- Variable: oldincludedir
     GCCコンパイラ以外のためのCヘッダファイルをインストールするディレクトリで
     す．

 -- Variable: prefix
     全てのファイルに対する共通のインストールプレフィクスです．
     EXEC_PREFIXが異なる値で定義されている場合，PREFIXはアーキテ
     クチャ非依存ファイルに対してのみ使用されます．

 -- Variable: sbindir
     システム管理者が実行する実行形式をインストールするディレクトリです．

 -- Variable: sharedstatedir
     修正可能な，アーキテクチャに依存しないデータをインストールするディレクト
     リです．

 -- Variable: sysconfdir
     読み込み専用の，シングルマシンのデータをインストールするディレクトリです．

   これらの変数のほとんどは，`prefix'や`exec_prefix'に依存する値
になります．ディレクトリ変数の出力値が展開されないように考慮されています．
典型的な例として，`@datadir@'は，`/usr/local/share' ではなく
`${prefix}/share'に置換されます．

   以下の動作は，GNU coding standardsで示されれていて，ユーザが実
行時にそうなるようになっています．

`make'
     `configure'に指定されるものとは異なるプレフィクスを指定すること
     がまだ可能で，その場合に必要があれば，パッケージはmakeで指定されているプ
     レフィクスに対応するように依存性がハードコード化されます．

`make install'
     異なるインストール位置を指定することが可能で，その場合，パッケージはコン
     パイルで指定した場所に，まだ依存している_はず_です(すなわち，
     `make
     install'を実行するときは再コンパイルされません)．お互いにグルー
     プ化された全てのファイルを，インストール時に決定する人も多いので，これは
     非常に重要な特徴で，そこからインストール後に最終的な場所にリンクが張られ
     ます．

   これらの機能をサポートするために，`datadir'が`prefix'の現在の
値に依存する`${prefix}/share'として定義されたままになっていること
が重要です．

   当然のことですが，これらの変数を`Makefiles'で使用すべきではありませ
ん．例えば，`configure'で`datadir'を評価する代わりに，
`Makefile'で，例えば`AC_DEFINE_UNQUOTED(DATADIR, "$datadir")'
としてハードコードする場合は，`-DDATADIR="$(datadir)"'を
`CPPFLAGS'に加えるべきです．

   同様に，`datadir'とその仲間を，シェルスクリプトやその他のファイルで
置換するために，`AC_OUTPUT_FILES'に頼るべきではなく，その代わりに
`make'にその置換を行なわせてください．例えば，Autoconfは
`.in'で終るシェルスクリプトのテンプレートを配布していて，以下のよう
な`Makefile'の一部を使用しています．

     edit = sed \
             -e 's,@datadir\@,$(pkgdatadir),g' \
             -e 's,@prefix\@,$(prefix),g'

     autoconf: Makefile $(srcdir)/autoconf.in
             rm -f autoconf autoconf.tmp
             $(edit) $(srcdir)/autoconf.in >autoconf.tmp
             chmod +x autoconf.tmp
             mv autoconf.tmp autoconf

     autoheader: Makefile $(srcdir)/autoheader.in
             rm -f autoheader autoheader.tmp
             $(edit) $(srcdir)/autoconf.in >autoheader.tmp
             chmod +x autoheader.tmp
             mv autoheader.tmp autoheader

   注目すべきことがいくつかあります．

`@datadir\@'
     バックスラッシュで`configure'が`@datadir@'をsedの式自身に
     置換することを妨げます．

`$(pkgdatadir)'
     `@pkgdatadir@'を使用しないでください！ 代わりに，makefile変数のマッ
     チングを使用してください．

`,'
     `$(pkgdatadir)'のように`/'を含んでいる変数を使用することもある
     ので，`sed'の式で`/'を使用しないでください．

``Makefile'への依存性'
     `edit'は，コンフィグレーション特有の値(`prefix'等)に依存し，
     `VERSION'やそれの以前のものには依存しない値を使用するので，出力は
     `configure.ac'ではなく`Makefile'に依存します．

`依存性の分割と単一のサフィックスルール'
     それらを使用することは不可能です！上記の断片を，(おそらく)以下のように書
     き換えることは不可能です.

          autoconf autoheader: Makefile
          .in:
                  rm -f $@ $@.tmp
                  $(edit) $< >$@.tmp
                  chmod +x $@.tmp
                  mv $@.tmp $@

     詳細は，*Note Limitations of Make::.

``$(srcdir)''
     ソースへのパスを確実に指定し，そうしない場合はパッケージは分割ビルドをサ
     ポートしないでしょう．


File: autoconf-ja.info,  Node: Build Directories,  Next: Automatic Remaking,  Prev: Installation Directory Variables,  Up: Makefile Substitutions

4.7.3 ビルドディレクトリ
------------------------

同じソースコードのコピーから，同時に複数のアーキテクチャに対するソフトウェ
アパッケージのコンパイルをサポートすることが可能です．それぞれのアーキテ
クチャに対するオブジェクトファイルは，それ自身のディレクトリに保存されま
す．

   これをサポートするために，`make'は，ソースディレクトリにあるファ
イルを見つけるため`VPATH'変数を使用します．GNU Makeとその
他のほとんどの最近の`make'プログラムはこうすることが可能です．もっ
と古い`make'プログラムは，`VPATH'をサポートしていません．そ
れを使用するときは，ソースコードをオブジェクトファイルと同じディレクトリ
置く必要があります．

   `VPATH'をサポートするため，それぞれの`Makefile.in'には，以下の
ような二行が必要です．

     srcdir = @srcdir@
     VPATH = @srcdir@

   `VPATH'の値に変数を代入しない`make'のバージョンもあるので，
`VPATH'に他の値，例えば`VPATH = $(srcdir)'を設定しないでくださ い．

   `configure'は`Makefile'を作成するとき，`srcdir'に正し
い値を代入します．

   暗黙のルールを期待して，(`VPATH'で見つかる)ソースディレクトリのファ
イルのパス名を展開する`make'変数の`$<'を使用しないでくださ
い．(暗黙のルールとは，`.c'ファイルから`.o'ファイルを作成する
方法を教える`.c.o'の様なものです．)暗黙のルールで`$<'を設定し
ないバージョンの`make'もあり，それは，空の値で展開します．

   その代わり，`Makefile'コマンドラインは，ソースファイルを
`$(srcdir)/'を前置して参照します．例えば以下のようにします．

     time.info: time.texinfo
             $(MAKEINFO) $(srcdir)/time.texinfo


File: autoconf-ja.info,  Node: Automatic Remaking,  Prev: Build Directories,  Up: Makefile Substitutions

4.7.4 自動的なリメイク
----------------------

コンフィグレーションファイルを変更したとき自動的にコンフィグレーション情
報を更新するため，パッケージに対するトップレベルの`Makefile.in' に
以下のようなルールを書くことが可能でます．以下の例には，
`aclocal.m4'やそれらが関連するるコンフィグレーションヘッダファイル
のような，全てのオプションのファイルが含まれています．パッケージで使用し
ないこれらのファイルに対する`Makefile.in'ルールは削除してください．

   `${srcdir}/'プレフィクスは`VPATH'メカニズムの制限のため含ま
れています．

   `config.h.in'と`config.h'のタイムスタンプは，内容が変化しない
場合には変化しないので，`stamp-'ファイルが必要です．この機能は不必
要な再コンパイルを避けます．パッケージの配布物に`stamp-h.in' を含め
るべきで，そうすることで`make'は`config.h.in'が最新だというこ
とを考慮します．`touch' (*note Limitations of Usual Tools::)を使
用せず，代わりに`echo'を使用してください(`date'を使用す
ると不必要な差異を生じ，CVSで矛盾したりするでしょう)．

     $(srcdir)/configure: configure.ac aclocal.m4
             cd $(srcdir) && autoconf

     # autoheader might not change config.h.in, so touch a stamp file.
     $(srcdir)/config.h.in: stamp-h.in
     $(srcdir)/stamp-h.in: configure.ac aclocal.m4
             cd $(srcdir) && autoheader
             echo timestamp > $(srcdir)/stamp-h.in

     config.h: stamp-h
     stamp-h: config.h.in config.status
             ./config.status

     Makefile: Makefile.in config.status
             ./config.status

     config.status: configure
             ./config.status --recheck

この行を直接`Makefile'にコピーするときは，インデントされた行がタブ
文字で始まるように置換する必要があるので注意してください．)

   更に，`AC_CONFIG_FILES([stamp-h], [echo timestamp > stamp-h])'を使
用すべきで，そうすることで`config.status'は`config.h'が最新で
あることを確かめます．`AC_OUTPUT'の詳細は，*Note Output::.

   依存性に関係するコンフィグレーションの例は，*Note config.status
Invocation::.


File: autoconf-ja.info,  Node: Configuration Headers,  Next: Configuration Commands,  Prev: Makefile Substitutions,  Up: Setup

4.8 コンフィグレーションヘッダファイル
======================================

パッケージに二，三個以上のCプリプロセッサのシンボルのテストが含まれてい
るとき，コマンドラインでコンパイラに渡す`-D'オプションはかなり長く
なります．これは二つの問題があります．一つは，`make'の出力のエラー
を探すとき，見て分からなくなることです．更に深刻な問題は，コマンドライン
がいくつかのオペレーティングシステムの長さの制限を越えることです．コンパ
イラに`-D'オプションを渡す代わりに， `configure'スクリプト
で`#define'ディレクティブを含んでいるCヘッダファイルを作成すること
が可能です．`AC_CONFIG_HEADER'マクロで，この出力を選択します．それ
は，`AC_INIT'の直後に呼び出します．

   (例えば，`const'を再定義する場合)宣言の不一致を防ぐために，パッケー
ジでは，あらゆる他のヘッダの前で，コンフィグレーションヘッダファイルを
`#include'すべきです．`#include "config.h"'の代わりに `#include
<config.h>'を使用し，Cコンパイラに`-I.'オプション(ま
たは`-I..'．`config.h'がある方)を渡してください．そうすること
で，(おそらく配布物を作成するときに)ソースディレクトリがコンフィグレーショ
ンされても，他のビルドディレクトリは，ソースディレクトリから
`config.h'を探すことなく，コンフィグレーション可能になります．

 -- Macro: AC_CONFIG_HEADERS (HEADER ..., [CMDS], [INIT-CMDS])
     このマクロは，実際にファイルを作成するマクロの一つです． *Note
     Configuration Actions::を参照してください．`AC_OUTPUT'は，
     `#define'宣言のCプリプロセッサを含んでいるHEADERの空白で区切
     られたリストを作成し，生成されたファイルの`@DEFS@'を，`DEFS'
     の値の代わりに，`-DHAVE_CONFIG_H'で置換します．通常，HEADER
     の名前は`config.h'です．

     HEADERがすでに存在していて，その内容が`AC_OUTPUT'が書き込むも
     のと同じ場合は，そのまま残ります．こうすることで，ヘッダファイルに依存す
     るオブジェクトファイルを不必要に再コンパイルする必要がなく，コンフィグレー
     ション時に変更を行なうことが可能になります．

     通常，入力ファイルは`HEADER.in'と命名されます．しかし，入力ファ
     イルをコロンで分けた入力ファイルのリストにHEADERを加えることで優先
     可能です．例えば，以下のようにします．

          AC_CONFIG_HEADERS([config.h:config.hin])
          AC_CONFIG_HEADERS([defines.h:defs.pre:defines.h.in:defs.post])

     こうすることで，MS-DOSでアクセスできるままにしたり，常套句をファイルに前
     置したり，後置したりすることが可能になります．

   HEADERの詳細は，*Note Configuration Actions::.

* Menu:

* Header Templates::            Input for the configuration headers
* autoheader Invocation::       How to create configuration templates
* Autoheader Macros::           How to specify CPP templates


File: autoconf-ja.info,  Node: Header Templates,  Next: autoheader Invocation,  Up: Configuration Headers

4.8.1 コンフィグレーションヘッダのテンプレート
----------------------------------------------

最終的なヘッダファイルが見つかるように，コメントとフックとして使用される
`#undef'宣言を含んでいるテンプレートファイルを，配布物に含めるべき
です．例えば，`configure.ac'で以下のように呼び出します．

     AC_CONFIG_HEADERS([conf.h])
     AC_CHECK_HEADERS([unistd.h])

`conf.h.in'で以下のようなコードを書きます．`unistd.h'があるシ
ステムでは，`configure'は`#define' `HAVE_UNISTD_H' を1
にします．それ以外のシステムでは，行全体がコメントアウトされます(そのシ
ステムの場合，シンボルは前もって定義されません)．

     /* Define as 1 if you have unistd.h.  */
     #undef HAVE_UNISTD_H

   `#undef'が最初の列にあり，`HAVE_UNISTD_H'の後に空白すらないこ
とに注意してください．その後で，プリプロセッサ命令を使用しているコンフィ
グレーションヘッダをデコードすることが可能です．

     #include <conf.h>

     #if HAVE_UNISTD_H
     # include <unistd.h>
     #else
     /* We are in trouble.  */
     #endif

   `#undef'の代わりに`#define'を用いている，古い形式のテンプレー
トの使用は，強く反対します．`#undef'と同じ行にコメントがある古いテ
ンプレートも同様です．とにかく，プロセッサマクロにコメントを書くのは，決
してよい考えではありません．

テンプレートヘッダを更新し続けることは退屈な作業なので，それを生成するた
めに`autoheader'してもかまいません．*Note autoheader Invocation::
を参照してください．


File: autoconf-ja.info,  Node: autoheader Invocation,  Next: Autoheader Macros,  Prev: Header Templates,  Up: Configuration Headers

4.8.2 `config.h.in'を生成するため`autoheader'を使用する
-------------------------------------------------------

`autoheader'プログラムは，`configure'が使用するためのC
の`#define'宣言のテンプレートファイルを作成することが可能です．
`configure.ac'で`AC_CONFIG_HEADERS(FILE)'を呼び出す場合，
`autoheader'は`FILE.in'を作成します．複数のファイルが
引数で与えられている場合，最初のファイルを使用します．それ以外の場合，
`autoheader'は`config.h.in'を作成します．

この作業を行なうために，使用する可能性がある全てのシンボルを記述すること
を`autoheader'は必要とします．すなわち，少なくとも，一つの
`AC_DEFINE'か`AC_DEFINE_UNQUOTED'が，それぞれのシンボルに対し
て三番目の引数を用いて呼び出されている必要があります(*note Defining
Symbols::)．更に，`AC_DEFINE'の最初の引数をリテラルにする必要がある
という制約があります．Autoconfの組み込みテストで定義されている全てのシン
ボルは，既に適切に記述されているということに注意してください．独自に定義
したものだけ記述する必要があります．

   `autoheader'がなぜ必要か不思議に思うかもしれません．つまり，なぜ
`configure'は，スクラッチから`config.h'を作成する代わりに，
`config.h'を生成するために`config.h.in'への"patch"を必要とす
るのでしょうか？さて，全てがロックされたとき，`autoheader'を管理
している時間が無駄になるというのが答えです．直接`config.h'を生成す
ることが，必要なことの全てです．しかし，うまくいかないときは，
`autoheader'の存在に感謝することになるでしょう．

   シンボルが記述されているという事実は，`config.h'に意味があることを
_調査する_ために重要です．`#define'される(またはされない) シン
ボルがうまく定義されているリストがあるという事実もまた，
`configure'が実行不可能な環境にパッケージを移植している人には重
要です．彼らは，_空白で埋め尽くす_必要しかありません．

   では，要点に戻りましょう．`autoheader'の呼び出し...

   引数を`autoheader'に与えた場合，`configure.ac'の代わりにそ
のファイルを使用し，`config.h.in'の代わりに標準出力にヘッダファイル
を書き出します．`-'引数を`autoheader'に与えた場合，
`configure.ac'の代わりに標準入力から読み込み，標準出力にヘッダファ
イルを書き出します．

   `autoheader'は以下のオプションを受け入れます．

`--help'
`-h'
     コマンドラインオプションの概要を出力して終了します．

`--version'
`-V'
     Autoconfのバージョンナンバーを出力して終了します．

`--verbose'
`-v'
     処理しているステップを報告します．

`--debug'
`-d'
     一時的なファイルを削除しません．

`--force'
`-f'
     入力ファイルよりテンプレートファイルが新しい場合でも，それを再生成します．

`--include=DIR'
`-I DIR'
     DIRをインクルードパスの後に追加します．複数回の呼び出しで累積され
     ます．

`--prepend-include=DIR'

`-B DIR'
     DIRをインクルードパスの前に追加します．複数回の呼び出しで累積され
     ます．

`--warnings=CATEGORY'
`-W CATEGORY'
     CATEGORY(実際にはカンマで分けられたリスト)に関連する警告を報告しま
     す．現在のカテゴリには，以下のものが含まれています．

    `obsolete'
          時代遅れの構成物の使用を報告します．

    `all'
          全ての警告を報告します．

    `none'
          何も報告しません．

    `error'
          警告をエラーとして扱います．

    `no-CATEGORY'
          CATEGORYに分類されている警告を利用不可能にします．



File: autoconf-ja.info,  Node: Autoheader Macros,  Prev: autoheader Invocation,  Up: Configuration Headers

4.8.3 autoheaderのマクロ
------------------------

`autoheader'は`configure.ac'を調査し，定義されているCプリプ
ロセッサシンボルを判定します．それは，`AC_CHECK_HEADERS'や
`AC_CHECK_FUNCS'等が定義しているシンボルに対するテンプレートを生成
する方法は知っていますが，あらゆる追加のシンボルを`AC_DEFINE'してい
る場合，それに対するテンプレートを定義する必要があります．テンプレートが
無い場合，`autoheader'はエラーメッセージとともに失敗します．

   SYMBOLに対するテンプレートを作成する最も簡単な方法は，
`AC_DEFINE(SYMBOL)'の引数にDESCRIPTIONを与えることです． *Note Defining
Symbols::を参照してください．以下のマクロの一つを使用するこ
とも可能です．

 -- Macro: AH_VERBATIM (KEY, TEMPLATE)
     `autoheader'に，TEMPLATEをそのままヘッダテンプレートファイ
     ルに含めるよう伝えます．このTEMPLATEはKEYに関連付けされてい
     て，それは全ての異なるテンプレートを並べ替えし，それらのユニーク性を保証
     するために使用されます．それは，`AC_DEFINE'されることが可能なシンボ
     ルにすべきです．

     例えば以下のようにします．

          AH_VERBATIM([_GNU_SOURCE],
          [/* Enable GNU extensions on systems that have them.  */
          #ifndef _GNU_SOURCE
          # define _GNU_SOURCE
          #endif])

 -- Macro: AH_TEMPLATE (KEY, DESCRIPTION)
     `autoheader'に，KEYに対するテンプレートを生成するように伝
     えます．このマクロは，DESCRIPTIONが与えられたときの
     `AC_DEFINE'のような，標準的なテンプレートを生成します．

     例えば，以下のようにします．

          AH_TEMPLATE([CRAY_STACKSEG_END],
                      [Define to one of _getb67, GETB67, getb67
                       for Cray-2 and Cray-YMP systems.  This
                       function is required for alloca.c support
                       on those systems.])

     これは，適切に正当化された記述を用いて，以下のテンプレートを生成します．

          /* Define to one of _getb67, GETB67, getb67 for Cray-2 and
             Cray-YMP systems.  This function is required for alloca.c
             support on those systems.  */
          #undef CRAY_STACKSEG_END

 -- Macro: AH_TOP (TEXT)
     TEXTをヘッダテンプレートファイルの最初に含めます．

 -- Macro: AH_BOTTOM (TEXT)
     TEXTをヘッダテンプレートファイルの最後に含めます．


File: autoconf-ja.info,  Node: Configuration Commands,  Next: Configuration Links,  Prev: Configuration Headers,  Up: Setup

4.9 任意のコンフィグレーションコマンドの実行
============================================

`config.status'の実行前，実行中，そして実行後のいずれかに任意のコマ
ンドを実行することが可能です．以下の三つのマクロは，複数回呼び出されたと
き，実行するコマンドを累積していきます．`AC_CONFIG_COMMANDS' は時代
遅れのマクロ`AC_OUTPUT_COMMANDS'の置換物です．詳細は，*Note Obsolete
Macros::を参照してください．

 -- Macro: AC_CONFIG_COMMANDS (TAG..., [CMDS], [INIT-CMDS])
     `config.status'の終りに実行するシェルコマンドと，
     `configure'からのあらゆる変数を初期化するためのシェルコマンドを
     を追加します．コマンドをTAGに関連付けます．通常，CMDSはファ
     イルを作成するので，TAGは自ずからファイル名にすべきでしょう．実際，
     TAGに書かれているディレクトリが作製されます．このマクロは，実際に
     ファイルを作成するマクロです．*Note Configuration
     Actions::を参照してくだ さい．

     非現実的な例ですが，以下のようにします．
          fubar=42
          AC_CONFIG_COMMANDS([fubar],
                             [echo this is extra $fubar, and so on.],
                             [fubar=$fubar])

     以下はましなものです．
          AC_CONFIG_COMMANDS([time-stamp], [date >time-stamp])

 -- Macro: AC_CONFIG_COMMANDS_PRE (CMDS)
     `config.status'を作成する直前にCMDSを実行します．

 -- Macro: AC_CONFIG_COMMANDS_POST (CMDS)
     `config.status'を作成した直後にCMDSを実行します．


File: autoconf-ja.info,  Node: Configuration Links,  Next: Subdirectories,  Prev: Configuration Commands,  Up: Setup

4.10 コンフィグレーションのリンクを作成する
===========================================

テストの結果によって，対象物へのリンクを作成することが便利だと分かるでしょ
う．`AC_CONFIG_COMMANDS'を使用することも可能ですが，相対的なシンボ
リックリンクを作成することで，パッケージがソースディレクトリとは異なるディ
レクトリでビルドされるときに決定することが可能です．

 -- Macro: AC_CONFIG_LINKS (DEST:SOURCE..., [CMDS], [INIT-CMDS])
     `AC_OUTPUT'で，それぞれの既存のファイルSOURCEから対応するリン
     ク名DESTにリンクを作成します．可能な場合はシンボリックリンクを作成
     し，それ以外ではハードリンクを作成し，それ以外ではコピーします．
     DESTとSOURCEの名前は，ソースやビルドディレクトリのトップレベ
     ルからの相対的なものにすべきです．このマクロは，実際にファイルを作成する
     マクロの一つです．*Note Configuration Actions::を参照してください．

     例えば，以下のように呼び出します．

          AC_CONFIG_LINKS(host.h:config/$machine.h
                          object.h:config/$obj_format.h)

     これで，現在のディレクトリに`SRCDIR/config/$machine.h'へのリ
     ンク`host.h'と，`SRCDIR/config/$obj_format.h'へのリンク
     `object.h'を作成します．

     DESTに対して使用したい値`.'は有効ではありません．そうすると，
     `config.status'で作成するリンクを推定することが不可能になります．

     すると，以下のように実行できるでしょう．
          ./config.status host.h object.h
     これでリンクを作成します．


File: autoconf-ja.info,  Node: Subdirectories,  Next: Default Prefix,  Prev: Configuration Links,  Up: Setup

4.11 サブディレクトリで他のパッケージをコンフィグレーションする
===============================================================

ほとんどの場合，`AC_OUTPUT'を呼び出すことで，サブディレクトリの
`Makefile'を作成するためには十分です．しかし，一つ以上の独立したパッ
ケージを制御する`configure'スクリプトで，サブディレクトリの他の
パッケージの`configure'スクリプトを実行するために
`AC_CONFIG_SUBDIRS'を使用することが可能です．

 -- Macro: AC_CONFIG_SUBDIRS (DIR ...)
     空白で区切られたリストで与えられているそれぞれのサブディレクトリ
     DIRで，`AC_OUTPUT'に`configure'を実行させます．それぞ
     れのDIRはリテラルにすべきです．すなわち，以下のように使用しないで
     ください．

          if test "$package_foo_enabled" = yes; then
            $my_subdirs="$my_subdirs foo"
          fi
          AC_CONFIG_SUBDIRS($my_subdirs)

     これは`./configure --help=recursive'でのパッケージ`foo'のオプ
     ション表示を妨げるためです．その代わりに以下のように書くべきです．

          if test "$package_foo_enabled" = yes; then
            AC_CONFIG_SUBDIRS(foo)
          fi

     該当するDIRが見つからない場合でもエラーを報告しません．サブディレ
     クトリがオプションの場合，以下のように書いてください．

          if test -d $srcdir/foo; then
            AC_CONFIG_SUBDIRS(foo)
          fi

     該当するDIRに`configure.gnu'が含まれている場合，
     `configure'の代わりにそれを実行します．これは，Autoconfスクリプ
     トではない`Configure'を使用しているパッケージに対するもので，大
     文字小文字を識別しないファイルシステムでは同じファイルになるので，それを
     `configure'のラッパーとして呼び出すことは不可能です．同様に，
     DIRが`configure.ac'を含んでいて`configure'が無い場合，
     `AC_CONFIG_AUXDIR'で見つかるCygnusの`configure'スクリプトが
     使用されます．

     サブディレクトリの`configure'スクリプトには，この
     `configure'スクリプトに与えられたものと同じコマンドラインオプショ
     ンが渡され，必要場合は少し変更され，変更されるものには以下のものが含まれ
     ます．

        - キャッシュファイルへの相対的なパスを調整．

        - ソースディレクトリへの相対的なパスを調整．

        -
          デフォルトの場合を含め，現在の`$prefix'の値を，トップレベルとサブディ
          レクトリの`configure'のデフォルト値が異なっている場合でも伝搬させま
          す．

     このマクロは，出力変数`subdirs'も，ディレクトリのリスト
     `DIR...'に設定します．`Makefile'のルールは，この値を
     サブディレクトリの定義に再帰的に使用することが可能です．

     このマクロは何度呼び出してもかまいません．


File: autoconf-ja.info,  Node: Default Prefix,  Prev: Subdirectories,  Up: Setup

4.12 デフォルトプレフィクス
===========================

`configure'はデフォルトで，ファイルをインストールするプレフィク
スを`/usr/local'に設定します．`configure'のユーザは，異なる
ディレクトリを，`--prefix'と`--exec-prefix'オプションで選択す
ることが可能です．デフォルトを変更する方法は二つあります．
`configure'を作成するときと，実行するときです．

   デフォルトで，`/usr/local'以外のディレクトリにインストールしたい，
ソフトウェアパッケージもあります．そうするために，
`AC_PREFIX_DEFAULT'マクロを使用してください．

 -- Macro: AC_PREFIX_DEFAULT (PREFIX)
     デフォルトのインストールプレフィクスを，`/usr/local'の代わりに
     PREFIXに設定します．

   ユーザが既にインストールしている関連するプログラムの場所から，
`configure'がインストールプレフィクスを推測すると便利かもしれま
せん．そうしたい場合，`AC_PREFIX_PROGRAM'を呼び出します．

 -- Macro: AC_PREFIX_PROGRAM (PROGRAM)
     ユーザが(`--prefix'オプションを使用して)インストールプレフィクスを
     指定しない場合，シェルが行うように，`PATH'でPROGRAMを探し，そ
     の値を推測します．PROGRAMが見つかった場合，プレフィクスを
     PROGRAMを含むディレクトリの親に設定します．そうでない場合，上記の
     もの(`/usr/local'や`AC_PREFIX_DEFAULT')がデフォルトのプレフィ
     クスになります．例えば，PROGRAMが`gcc'で，`PATH'が
     `/usr/local/gnu/bin/gcc' を含んでいる場合，プレフィクスを
     `/usr/local/gnu'に設定します．


File: autoconf-ja.info,  Node: Existing Tests,  Next: Writing Tests,  Prev: Setup,  Up: Top

5 存在の調査
************

以下のマクロは，パッケージが必要とする，あるいは使用する，特定のシステム
の特徴をテストします．これらのマクロが調査しない特徴のテストが必要な場合，
適切な引数で基本のテストマクロを呼び出すことで，おそらく可能です (*note
Writing Tests::)．

これらのテストは，調査している特徴と見つかったものをユーザに伝えるメッセー
ジを出力します．将来，`configure'を実行するため，結果をキャッシュ
します(*note Caching Results::)．

これらのマクロには，出力変数を設定するものもあります．変数の取得方法は，
*Note Makefile Substitutions::.  "NAMEを定義します"という文章は，
"CプリプロセッサのシンボルNAMEの値を1に定義します" という意味を
短縮したのもとして，以下で使用します．プログラムでシンボル定義を得る方法
は， *Note Defining Symbols::.

* Menu:

* Common Behavior::             Macros' standard schemes
* Alternative Programs::        Selecting between alternative programs
* Files::                       Checking for the existence of files
* Libraries::                   Library archives that might be missing
* Library Functions::           C library functions that might be missing
* Header Files::                Header files that might be missing
* Declarations::                Declarations that may be missing
* Structures::                  Structures or members that might be missing
* Types::                       Types that might be missing
* Compilers and Preprocessors::  Checking for compiling programs
* System Services::             Operating system services
* UNIX Variants::               Special kludges for specific UNIX variants


File: autoconf-ja.info,  Node: Common Behavior,  Next: Alternative Programs,  Up: Existing Tests

5.1 共通の動作
==============

Autoconfの学習が簡単になるように努力してきました．このゴールに到達するた
めの最も明白な方法は，できるだけ例外を避けながら，単純に標準的なインタ
フェースと動作を実施することです．残念ながら，歴史と慣性のため，多くの例
外がAutoconfにはまだ存在しています．それにもかかわらず，このセクションで
は，一般的な規則を記述します．

* Menu:

* Standard Symbols::            Symbols defined by the macros
* Default Includes::            Includes used by the generic macros


File: autoconf-ja.info,  Node: Standard Symbols,  Next: Default Includes,  Up: Common Behavior

5.1.1 標準的なシンボル
----------------------

テストの結果，シンボルを`AC_DEFINE'する全ての一般的なマクロは，その
引数を標準的なアルファベットに変換します．最初に，ARGUMENTは大文字
に変換され，あらゆるアスタリスク(`*')は，それぞれ`P'に変換され
ます．アルファベットではない残りの全ての文字は，アンダースコアに変換され
ます．

   例えば以下のものを考えます．

     AC_CHECK_TYPES(struct $Expensive*)

これは，調査が成功した場合，シンボル`HAVE_STRUCT__EXPENSIVEP'を定義
します．


File: autoconf-ja.info,  Node: Default Includes,  Prev: Standard Symbols,  Up: Common Behavior

5.1.2 デフォルトのインクルード
------------------------------

ヘッダファイルの設定に依存するテストもあります．これらのヘッダは例外無く
利用可能というわけではないので，テストは，以下のようなインクルードを保護
する(コードの)組を，実際に提供する必要があります．

     #if TIME_WITH_SYS_TIME
     # include <sys/time.h>
     # include <time.h>
     #else
     # if HAVE_SYS_TIME_H
     #  include <sys/time.h>
     # else
     #  include <time.h>
     # endif
     #endif

どうすれば良いか正確に知らない場合，無条件のインクルードの使用は避け，イ
ンクルードする前にヘッダの存在を調査すべきです(*note Header Files::)．

最も一般的なマクロは，以下のようなインクルードのデフォルトの組を提供する
マクロを使用しています．

 -- Macro: AC_DEFAULT_INCLUDES ([INCLUDE-DIRECTIVES])
     INCLUDE-DIRECTIVESが定義されている場合はそれを展開し，そうでなけれ
     ば以下のようになります．

          #include <stdio.h>
          #if HAVE_SYS_TYPES_H
          # include <sys/types.h>
          #endif
          #if HAVE_SYS_STAT_H
          # include <sys/stat.h>
          #endif
          #if STDC_HEADERS
          # include <stdlib.h>
          # include <stddef.h>
          #else
          # if HAVE_STDLIB_H
          #  include <stdlib.h>
          # endif
          #endif
          #if HAVE_STRING_H
          # if !STDC_HEADERS && HAVE_MEMORY_H
          #  include <memory.h>
          # endif
          # include <string.h>
          #endif
          #if HAVE_STRINGS_H
          # include <strings.h>
          #endif
          #if HAVE_INTTYPES_H
          # include <inttypes.h>
          #else
          # if HAVE_STDINT_H
          #  include <stdint.h>
          # endif
          #endif
          #if HAVE_UNISTD_H
          # include <unistd.h>
          #endif

     デフォルトのインクルードが使用される場合，これらのヘッダの存在とその互換
     性を調査します．すなわち，`AC_HEADERS_STDC'を実行する必要も，
     `stdlib.h'などを調査する必要もありません．

     これらのヘッダは，インクルードされる順番と同じ順番で調査されます．例えば，
     `string.h'と`strings.h'の両方があるシステムもありますが，競合
     しません．そこでは，`HAVE_STRING_H'は定義されますが，
     `HAVE_STRINGS_H'は定義されません．


File: autoconf-ja.info,  Node: Alternative Programs,  Next: Files,  Prev: Common Behavior,  Up: Existing Tests

5.2 プログラムの選択
====================

これらのマクロは，特定のプログラムとその動作を調査します．それらは，いく
つかのプログラムからどれかを選択し，一旦選ばれると何をするのかを決定する
ために使用されます．必要なプログラムを調査するために特別に定義されている
マクロが無い場合，一般的なプログラム調査のマクロの一つを使用することが可
能です．

* Menu:

* Particular Programs::         Special handling to find certain programs
* Generic Programs::            How to find other programs


File: autoconf-ja.info,  Node: Particular Programs,  Next: Generic Programs,  Up: Alternative Programs

5.2.1 特定のプログラムの調査
----------------------------

以下のマクロは，特定のプログラムを調査します -- それは存在するかどうか，
そして場合によっては特定の機能をサポートするかどうかです．

 -- Macro: AC_PROG_AWK
     `gawk'，`mawk'，`nawk'，そして`awk'を，この順番で調
     査し，最初に見つかったものに出力変数`AWK'を設定します．最良の実装と
     報告されているので，最初に`gawk'を調査します．

 -- Macro: AC_PROG_EGREP
     `grep -E'と`egrep'をこの順番で調査し，最初に見つかったもので出
     力変数`EGREP'を設定します．

 -- Macro: AC_PROG_FGREP
     `grep -F'と`fgrep'をこの順番で調査し，最初に見つかったもので出
     力変数`FGREP'を設定します．

 -- Macro: AC_PROG_INSTALL
     現在の`PATH'に，BSD互換の`install'プログラムが見つかっ
     た場合，出力変数`INSTALL'をそのパスに設定します．それ以外では，
     `INSTALL'を`DIR/install-sh -c'に設定し，
     `AC_CONFIG_AUX_DIR'で指定されたディレクトリ(またはデフォルトディレ
     クトリ)を，DIRを決定するために調査します(*note Output::)．また，変
     数`INSTALL_PROGRAM'と`INSTALL_SCRIPT'を`${INSTALL}' に，
     `${INSTALL}'と`INSTALL_DATA'を`${INSTALL}-m 644'に設 定します．

     このマクロは，動作しないことが知られている`install'の様々な実例をふ
     るい落とします．それは速度のため，シェルスクリプトよりCプログラムを見付
     けようとします．`install-sh'の代わりに，`install.sh'を使用する
     ことも可能ですが，`make'プログラムには， `Makefile' が無い
     場合，それから`install'を作成するルールを持っているものもあるので，
     その名前は時代遅れです．

     使用可能な`install-sh'のコピーは，Autoconfでインストールされます．
     `AC_PROG_INSTALL'を使用する場合，配布物に`install-sh'か
     `install.sh'を含める必要があり，そうしない場合，`configure'
     は見つからない旨，エラーメッセージを出力します --
     たとえシステムに良い
     `install'があってもそうなります．この調査は，そのファイルをたまたま
     入れ忘れることを阻止する安全対策で，それはBSD互換の
     `install'プログラムが無いシステムでパッケージをインストールすること
     を妨げます．

     標準的な`install'プログラムには見当たらない特徴があるために，独自の
     インストールプログラムを使用する必要がある場合，`AC_PROG_INSTALL'を
     使用する理由はありません．`Makefile.in'ファイルにプログラムのファイ
     ル名を書き込んでください．

 -- Macro: AC_PROG_LEX
     `flex'が見つかった場合，ライブラリが標準的な場所にあれば，出力変数
     `LEX'を`flex'に，`LEXLIB'を`-lfl'に設定します．それ
     以外の場合，`LEX'を`lex'に，`LEXLIB'を`-ll'に設定し ます．

     `yytext'が`char []'ではなく`char *'の場合，
     `YYTEXT_POINTER'を定義します．また，出力変数`LEX_OUTPUT_ROOT'
     をlexerが生成するファイル名のベースに設定します．通常は`lex.yy'です
     が異なることもあります．これらは，結果として`lex'と`flex'のど
     ちらが使用されているかに依存して変化します．

     普通のLexとそれが生成するCソースを使用するより，移植性の面でより好ましい
     ので，ソースでFlexを使用することを推奨します．しかし，移植性を確実にする
     ために，関数`yywrap'を提供する，または，それを使用しない場合(例えば，
     スキャナに`#include'のような機能が無い場合)，単純にスキャナソースで
     `%noyywrap'文を含める必要があります．一旦このようにすることで，スキャ
     ナは(_あなたが_移植性の無い構成物を使用しない限り) 移植性があり，ラ
     イブラリに依存しません．この場合，そしてこの場合のみ，以下のような
     Autoconfの断片を使用することを提案します．

          AC_PROG_LEX
          if test "$LEX" != flex; then
            LEX="$SHELL $missing_dir/missing flex"
            AC_SUBST(LEX_OUTPUT_ROOT, lex.yy)
            AC_SUBST(LEXLIB, '')
          fi

     シェルスクリプト`missing'は，Automakeの配布物で見つかるはずです．

     下位互換を確実にするため，Automakeの`AM_PROG_LEX'は，(間接的に)この
     マクロを二回呼び出し，不快な"`AC_PROG_LEX' invoked multiple times"
     で始まる警告を生じます．将来のバージョンのAutomakeではこの症状は
     修正されるでしょう．それまで，このメッセージを無視してください．

 -- Macro: AC_PROG_LN_S
     現在のファイルシステムで，`ln -s'が動作する(オペレーティングシステ
     ムとファイルシステムがシンボリックリンクをサポートしている)場合，出力変
     数`LN_S'を`ln -s'に設定します．それ以外の場合は，`ln'が動
     作する場合は，`LN_S'を`ln'に設定し，そうでもなければ`cp
     -p'に設定します．

     リンクをカレントディレクトリ以外のディレクトリに作成する場合，その方法は，
     `ln'と`ln -s'のどちらが使用されるかに依存します．
     `$(LN_S)'を使用して安全にリンクを作成するため，使用する書式と正しい
     引数を理解するか，リンクが作成されるディレクトリで`ln'を常に呼び出
     すか，どちらかにしてください．

     言い替えると，以下のものは動作しません．
          $(LN_S) foo /x/bar

     その代わりに，以下のようにします．

          (cd /x && $(LN_S) foo bar)

 -- Macro: AC_PROG_RANLIB
     `ranlib'が見つかった場合，出力変数`RANLIB'を`ranlib'に設
     定し，それ以外では，`:'(何もしません)に設定します．

 -- Macro: AC_PROG_YACC
     `bison'が見つかった場合，出力変数`YACC'を`bison -y'に設定
     します．それ以外で，`byacc'が見つかる場合，`YACC'を
     `byacc'に設定します．それ以外では，`YACC'を`yacc'に設定し ます．


File: autoconf-ja.info,  Node: Generic Programs,  Prev: Particular Programs,  Up: Alternative Programs

5.2.2 一般的なプログラムとファイルの調査
----------------------------------------

これらのマクロは，"特定の"テストマクロによってカバーされていないプログ
ラムを見つけるに使用します．プログラムの存在を確認するだけでなく，その動
作を調査する必要がある場合，そうするために独自のテストを書く必要がありま
す(*note Writing Tests::)．デフォルトで，これらのマクロは環境変数
`PATH'を使用します．ユーザの`PATH'にない可能性があるプログラム
を調査する必要がある場合，以下のようにして，パスを編集して渡すことが可能
です．

     AC_PATH_PROG([INETD], [inetd], [/usr/libexec/inetd],
                  [$PATH:/usr/libexec:/usr/sbin:/usr/etc:etc])

   `AC_CHECK_PROG'等に渡すVARIABLEを，正確に宣言することを強く推
奨します．詳細は，`AC_ARG_VAR'と*Note Setting Output Variables::.

 -- Macro: AC_CHECK_PROG (VARIABLE, PROG-TO-CHECK-FOR,
          VALUE-IF-FOUND, [VALUE-IF-NOT-FOUND], [PATH], [REJECT])
     `PATH'に，プログラムPROG-TO-CHECK-FORが存在するかどうか調査し
     ます．見つかった場合，VARIABLEをVALUE-IF-FOUNDに設定し，それ
     以外で，VALUE-IF-NOT-FOUNDが与えられている場合は，それに設定します．
     たとえREJECT(絶対パスのファイル名)が最初のサーチパスで見つかった場
     合でも，それは候補から外します．この場合，PROG-TO-CHECK-FORが見つ
     かったREJECTではない絶対パスのファイル名を使用し，VARIABLEを
     設定します．VARIABLEが既に設定されている場合，何もしません．
     VARIABLEに対して`AC_SUBST'を呼び出してください．

 -- Macro: AC_CHECK_PROGS (VARIABLE, PROGS-TO-CHECK-FOR,
          [VALUE-IF-NOT-FOUND], [PATH])
     空白で区切られたリストPROGS-TO-CHECK-FORのそれぞれのプログラムが
     `PATH'に存在するかどうかを調査します．見つかった場合，
     VARIABLEをプログラムの名前に設定します．それ以外の場合は引続き，リ
     ストの次にあるプログラムを調査します．リスト内のプログラムが全く見つから
     ない場合， VARIABLE をVALUE-IF-NOT-FOUNDに設定します．
     VALUE-IF-NOT-FOUNDが指定されていない場合，VARIABLEは変更され
     ません．VARIABLEに対して`AC_SUBST'を呼び出してください．

 -- Macro: AC_CHECK_TOOL (VARIABLE, PROG-TO-CHECK-FOR,
          [VALUE-IF-NOT-FOUND], [PATH])
     `AC_CHECK_PROG'に似ていますが，`AC_CANONICAL_HOST'で定義されて
     いるホストタイプにダッシュが続いているプレフィクスを持つ
     PROG-TO-CHECK-FORを，最初に探します(*note Canonicalizing::)．例え
     ば，ユーザが`configure --host=i386-gnu'を実行している場合，以下のよ
     うに呼び出します．
          AC_CHECK_TOOL(RANLIB, ranlib, :)
     これで，`PATH'に`i386-gnu-ranlib'というプログラムが存在する場
     合，`RANLIB'を`i386-gnu-ranlib'に設定し，それ以外で，
     `PATH'に`ranlib'というプログラムがある場合，`RANLIB'を
     `ranlib'に設定し，どちらも無い場合は `:'に設定します．

 -- Macro: AC_CHECK_TOOLS (VARIABLE, PROGS-TO-CHECK-FOR,
          [VALUE-IF-NOT-FOUND], [PATH])
     `AC_CHECK_TOOL'に似ていて，PROGS-TO-CHECK-FORでリストアップさ
     れているそれぞれのツールは，`AC_CANONICAL_HOST'で決定されたホストタ
     イプを前置し，それにダッシュを続けたものを用いて調査されます
     (*note
     Canonicalizing::)．プレフィクスを用いているツールが見つからない場
     合，最初にプレフィクス無しのものが使用されます．ツールが見つかった場合，
     VARIABLEをそのプログラム名に設定します．リストのツールが全く見つか
     らない場合，VARIABLEをVALUE-IF-NOT-FOUNDに設定します．
     VALUE-IF-NOT-FOUNDが指定されていない場合，VARIABLEの値は変更
     されません．VARIABLEに対して`AC_SUBST'を呼び出してください．

 -- Macro: AC_PATH_PROG (VARIABLE, PROG-TO-CHECK-FOR,
          [VALUE-IF-NOT-FOUND], [PATH])
     `AC_CHECK_PROG'に似ていますが，見つかった場合，VARIABLEを
     PROG-TO-CHECK-FORの完全なパスに設定します．

 -- Macro: AC_PATH_PROGS (VARIABLE, PROGS-TO-CHECK-FOR,
          [VALUE-IF-NOT-FOUND], [PATH])
     `AC_CHECK_PROGS'に似ていますが，PROGS-TO-CHECK-FORのどれかが
     見つかった場合，VARIABLEをプログラムが見つかった完全なパスに設定し
     ます．

 -- Macro: AC_PATH_TOOL (VARIABLE, PROG-TO-CHECK-FOR,
          [VALUE-IF-NOT-FOUND], [PATH])
     `AC_CHECK_TOOL'に似ていますが，見つかった場合，VARIABLEをプロ
     グラムが見つかった完全なパスに設定します．


File: autoconf-ja.info,  Node: Files,  Next: Libraries,  Prev: Alternative Programs,  Up: Existing Tests

5.3 ファイル
============

ファイルの存在を調査する必要もあるでしょう．以下のマクロを使用する前に，
実行時の調査がより良い解決ではないかどうか自問してください．ほとんどの
Autoconfマクロのように，それらはホストマシンの機能を調査するため，クロス
コンパイルでは意味が無いことを知っておいてください．

 -- Macro: AC_CHECK_FILE (FILE, [ACTION-IF-FOUND],
          [ACTION-IF-NOT-FOUND])
     ネイティブシステムにFILEが存在するかどうか調査します．見つかった場
     合，ACTION-IF-FOUNDを実行し，それ以外では，与えられていれば
     ACTION-IF-NOT-FOUNDを実行します．

 -- Macro: AC_CHECK_FILES (FILES, [ACTION-IF-FOUND],
          [ACTION-IF-NOT-FOUND])
     FILESでリストアップされているそれぞれのファイルに対し，
     `AC_CHECK_FILE'を一度実行します．さらに，見つかったそれぞれのファイ
     ルに対して`HAVEFILE'を定義します(*note Standard Symbols::)．


File: autoconf-ja.info,  Node: Libraries,  Next: Library Functions,  Prev: Files,  Up: Existing Tests

5.4 ライブラリファイル
======================

以下のマクロは，C，C++やFortranのライブラリアーカイブファイルの存在を調
査します．

 -- Macro: AC_CHECK_LIB (LIBRARY, FUNCTION, [ACTION-IF-FOUND],
          [ACTION-IF-NOT-FOUND], [OTHER-LIBRARIES])
     現在の言語に依存して(*note Language
     Choice::)，テストプログラムが関数利
     用に必要なライブラリLIBRARYとリンク可能かどうかを調査することで，C，
     C++やFortranの関数FUNCTIONが利用可能であることを確認します．
     LIBRARYは，ライブラリのベース名です．例えば，`-lmp'を調査する
     ために，LIBRARYの引数として`mp'を使用します．

     ACTION-IF-FOUNDは，ライブラリとのリンクが成功した場合に実行するシェ
     ルコマンドのリストです．ACTION-IF-NOT-FOUNDは，リンクが失敗した場
     合に実行するシェルコマンドのリストです．ACTION-IF-FOUNDが指定され
     ていない場合，デフォルトで`-lLIBRARY'を`LIBS' に加え，
     `HAVE_LIBLIBRARY'を(全て大文字で)定義します．このマクロは，ラ
     イブラリの依存が連続的なテストの自然な副作用で十分になるように，右から左
     (最小依存から最大依存)の方法で`LIBS'のビルドサポートを試みます．ラ
     イブラリの順序に注意が必要なリンカもあるので，`LIBS'が生成される順
     序は，ライブラリの信頼できる検出にとって重要です．

     LIBRARYとのリンクの結果が，追加のライブラリとのリンクで解決される
     未解決のシンボルとなる場合，これらのライブラリを，`-lXt -lX11' のよ
     うに，スペースで区切られたOTHER-LIBRARIES引数で与えてください．そ
     うしない場合，テストプログラムとのリンクが未解決のシンボルで常に失敗する
     ので，このマクロはLIBRARYの存在の検出に失敗します．
     OTHER-LIBRARIES引数は，まだ`LIBS'に無い，その他のライブラリの
     一つを調査することが望ましい場合は制限があります．

 -- Macro: AC_SEARCH_LIBS (FUNCTION, SEARCH-LIBS,
          [ACTION-IF-FOUND], [ACTION-IF-NOT-FOUND], [OTHER-LIBRARIES])
     まだ利用可能ではない，FUNCTIONを定義しているライブラリを探します．
     これは，最初にライブラリ無しで，その後でそれぞれのライブラリを
     SEARCH-LIBSにリストアップしている
     `AC_LINK_IFELSE([AC_LANG_CALL([], [FUNCTION])])'の呼び出しと
     等価です．

     FUNCTIONが含まれている最初のライブラリに対して，
     `-lLIBRARY'を`LIBS'に追加し，ACTION-IF-FOUNDを実
     行します．関数が見つからない場合，ACTION-IF-NOT-FOUNDを実行します．

     LIBRARYとのリンクの結果が，未解決のシンボルで，追加のライブラリと
     のリンクで解決できる場合，これらのライブラリを，`-lXt
     -lX11'の様に，
     スペースで区切られたOTHER-LIBRARIES引数で与えてください．そうしな
     ければ，テストプログラムとのリンクが，常に未解決のシンボルで失敗するので，
     このマクロはLIBRARYの存在の調査に失敗します．


File: autoconf-ja.info,  Node: Library Functions,  Next: Header Files,  Prev: Libraries,  Up: Existing Tests

5.5 ライブラリ関数
==================

以下のマクロは，特定のCライブラリ関数を調査します．必要な関数を調査する
ための特別に定義されたマクロがなく，その特別な特性を調査する必要がない場
合，一般的な関数調査のマクロを使用することが可能です．

* Menu:

* Function Portability::        Pitfalls with usual functions
* Particular Functions::        Special handling to find certain functions
* Generic Functions::           How to find other functions


File: autoconf-ja.info,  Node: Function Portability,  Next: Particular Functions,  Up: Library Functions

5.5.1 C関数の移植性
-------------------

ほとんどの通常の関数は，足りない，またはバグがある，またはアーキテクチャ
によって制限があるはずです．このセクションでは，これらの移植性の問題を目
録にしようと思います．定義からすると，このリストは常に追加が必要です．で
きるだけ完全なものを保つために，我々への手助けをお願いします．

`exit'
     古いホストでは，`exit'が`int'を返すものがあることを御存知です
     か？これは，`exit'のほうが`void'より時代が古く，`int' を
     返すという伝統が長い間あったためです．

`putenv'
     POSIXでは，`putenv'は与えられた文字列を直接`environ'に書き込む
     ように指定していますが，システムによってはその代わりにコピーするものもあ
     ります(例えば，glibc 2.0やBSD)．そして，コピーが作成されたとき，
     `unsetenv'はそれを解放し，メモリリークの原因になります(例えば，
     FreeBSD 4がそうです)．

     POSIXでは，`putenv("FOO")'は`FOO'を環境変数から削除するように
     指定していますが，システムによっては(例えばFreeBSD
     4)，こうならないので， 代わりに`unsetenv'を使用して下さい．

     MINGWでは，`putenv("FOO=")'の呼び出しで，空の値を挿入する代わりに，
     `FOO'を環境変数から削除します．

`signal'ハンドラ
     通常，`signal'は`void'の型を返す関数へのハンドルを受け取ります
     が，古いシステムには，代わりに`int'を要求するものもあります．実際に
     返される`int'の値を利用しませんが，これは関数のプロトタイプの要求が
     異なるだけです．

     現在知っているシステムはすべて`void'を受け取ります．おそらく，
     `int'がK&R Cでサポートされていたのですが，もちろん`void'は利用
     可能ではありませんでした．`AC_TYPE_SIGNAL' (*note Particular
     Types::)は，すべての状況で正しい型を構築するために使用することが可能です．

`snprintf'
     ISO
     C99標準では，出力配列があまり大きくなくその他のエラーが無い場合，
     `snprintf'と`vsnprintf'は出力を切捨て，生成された出力が必要と
     するバイト数を返すことになっています．古いシステムでは切り捨てられた長さ
     を返したり(例えば，GNU Cライブラリ2.0.xやIRIX 6.5)，負の
     値を返したり(例えば，より古いバージョンのGNU Cライブラリ)，切
     り捨てられなかったバッファの長さを返したり(例えば32ビットのSolaris
     7)し
     ます．また，バグの多い古いシステムにはバッファの長さとオーバーランを無視
     するもの(例えば64ビットのSoraris 7)もあります．

`sprintf'
     ISO Cの標準では，`sprintf'と`vsprintf'は書き込まれたバイト数を
     返すことになっていますが，古いシステム(例えばSunOS
     4)ではその代わりにバッ ファへのポインタを返すものもあります．

`sscanf'
     様々な古いシステム，例えばHP-UX 9では，`sscanf'は入力文字列が(たと
     えそれが実際には変更されなくても)書き込み可能であることを要求します．こ
     れは，`gcc'は通常，固定文字列を読み込み専用のメモリに書き込むの
     で(*note Incompatibilities of GCC:
     (gcc)Incompatibilities.)，それを使用するとき問題
     になるはずです．場合によっては，フォーマット文字列が明らかに読み込み専用
     であっても問題になるはずです．

`strnlen'
     AIX 4.3は，以下の結果を生成する壊れたバージョンを提供していま す．

          strnlen ("foobar", 0) = 0
          strnlen ("foobar", 1) = 3
          strnlen ("foobar", 2) = 2
          strnlen ("foobar", 3) = 1
          strnlen ("foobar", 4) = 0
          strnlen ("foobar", 5) = 6
          strnlen ("foobar", 6) = 6
          strnlen ("foobar", 7) = 6
          strnlen ("foobar", 8) = 6
          strnlen ("foobar", 9) = 6

`sysconf'
     `_SC_PAGESIZE'は標準ですが，古いシステム(例えばHP-UX 9)には，代わり
     に`_SC_PAGE_SIZE'が存在します．これは`#ifdef'でテスト可能です．

`unlink'
     POSIXの仕様では，`unlink'は開かれているファイルへのハンド
     ルがなくなった後でファイルを削除するように述べられています．全てのOS
     が
     この動作をサポートしているわけではありません．そのため，システムが
     `unlink'を提供している場合でも，開いているファイルに対して呼び出し
     ても大丈夫だと仮定した移植は不可能です．例えば，Windows
     9xとMEでは，その
     ような呼び出しは失敗します．DOSは可能ですが，OSが削除した後に
     ファイルへの書き込みが終了するので，ファイルシステムが駄目になります．

`unsetenv'
     MINGWでは，`unsetenv'が利用不可能ですが，`putenv'で上述したよ
     うに，変数`FOO'は`putenv("FOO=")'の呼び出しで削除可能です．

`va_copy'
     ISO C99標準では，`va_list'をコピーするため`va_copy'を提供して
     います．古い環境でも利用可能かもしれませんが，おそらくは
     `__va_copy'(例えば厳密なC89モード)でしょう．これらは`#ifdef'
     でテスト可能です．`memcpy (&dst, &src, sizeof(va_list))'で代替する
     ことで最大の移植性となるでしょう．

`va_list'
     `va_list'はポインタである必要はありません．`struct'(例えば
     Alphaの`gcc')にすることが可能で，それは`NULL'では移植性が無
     いことを意味します．配列(例えばPowerPCでコンフィグレーションされた
     `gcc')も可能で，それは関数のパラメータとして効果的に参照呼び出し
     が可能であり，ライブラリルーチンで呼び出しが返す値を修正する可能性がある
     (例えばGNU Cライブラリ2.1の`vsnprintf')ことを意味します．

符合付の`>>'
     通常，Cの符号付きの右シフト`>>'はハイビットを複製し，いわゆる"算術"
     シフトになります．しかし，ISO
     Cの標準ではその動作を要求していないので，
     注意すべきです．ネイティブの算術シフトが無いプロセッサ(例えばCrayベクター
     システム)では，符号無しのシフトと同様に，ゼロビットがシフトインされる可
     能性があります．


File: autoconf-ja.info,  Node: Particular Functions,  Next: Generic Functions,  Prev: Function Portability,  Up: Library Functions

5.5.2 特定の関数の調査
----------------------

これらのマクロは -- その存在にかかわらず -- 特定のC関数を調査し，場合
によっては，特定の引数が与えられたときの反応を調査します．

 -- Macro: AC_FUNC_ALLOCA
     `alloca'を使用する方法を調査します．`alloca.h'や，前もって定義
     されているCプリプロセッサマクロの`__GNUC__'と`_AIX'を調査する
     ことで，組み込みバージョンを取得しようとします．このマクロが
     `alloca.h'を見つけた場合，`HAVE_ALLOCA_H'を定義します．

     その試みが失敗する場合，標準Cライブラリで関数を探します．それらの手法の
     いずれかが成功した場合，それは`HAVE_ALLOCA'を定義します．それ以外の
     場合は，出力変数の`ALLOCA'を`alloca.o'に設定し，
     `C_ALLOCA'を定義します(それで，プログラムがガーベージコレクションの
     ため定期的に`alloca(0)'を呼び出すことが可能になります．この変数は，
     `LIBOBJS'とは別物なので，実際にライブラリを作成しなくても複数のプロ
     グラムで`ALLOCA'の値を共有することが可能ですが，`LIBOBJS'で使
     用する場合もわずかにあります．

     このマクロは，System V R3 の`libPW'やSystem V R4の`libucb'の
     `alloca'の使用を試みません．なぜなら，それらのライブラリには互換性
     がない関数があり問題が生じるためです．`alloca'を含まないものやバグ
     だらけのバージョンもあります．それでも，その`alloca'を使用したい場
     合，`alloca.c'をコンパイルする代わりに，ライブラリから
     `alloca.o'を抽出するため，`ar'を使用してください．

     `alloca'を使用するソースファイルでは，正確に宣言するために，以下の
     ようなコードで始めるべきです．AIXのバージョンによっては，
     `alloca'の宣言を，コメントとプリプロセッサディレクティブ以外の，全
     ての行の前に書く必要があります．`#pragma'ディレクティブは， ANSI
     C以前のコンパイラが停止するのではなく無視するように，字下
     げを行います．

          /* AIX requires this to be the first thing in the file.  */
          #ifndef __GNUC__
          # if HAVE_ALLOCA_H
          #  include <alloca.h>
          # else
          #  ifdef _AIX
           #pragma alloca
          #  else
          #   ifndef alloca /* predefined by HP cc +Olibcalls */
          char *alloca ();
          #   endif
          #  endif
          # endif
          #endif

 -- Macro: AC_FUNC_CHOWN
     `chown'関数が利用可能で動作する場合(特に，`uid'と`gid' に
     対する`-1'を受け入れるべきです)，`HAVE_CHOWN'を定義します．

 -- Macro: AC_FUNC_CLOSEDIR_VOID
     `closedir'関数が意味のある値を返さない場合，`CLOSEDIR_VOID' を
     定義します．それ以外では，呼び出し側で，エラーを示す戻り値を調査する必要
     があります．

 -- Macro: AC_FUNC_ERROR_AT_LINE
     `error_at_line'関数が見つからない場合，`AC_LIBOBJ'が
     `error'で置換されることを要求します．

 -- Macro: AC_FUNC_FNMATCH
     `fnmatch'関数がPOSIX準拠の場合，`HAVE_FNMATCH'を定義
     します．例えば，Solaris
     2.4のバグのような，一般的な実装上のバグを検出し ます．

     歴史的な理由のため，それ以外の`AC_FUNC'マクロとは反対に，
     `AC_FUNC_FNMATCH'は壊れていたり見つからなかったりする`fnmatch'
     を置換しません．以下の`AC_REPLACE_FNMATCH'を参照してください．

 -- Macro: AC_FUNC_FNMATCH_GNU
     `AC_REPLACE_FNMATCH'(_置換_)のように動作しますが，
     `fnmatch'がGNUの拡張をサポートするかどうかも調査します．
     例えば，GNU Cライブラリ2.1のバグのような，一般的な実装上のバ
     グを検出します．

 -- Macro: AC_FUNC_FORK
     このマクロは，`fork'と`vfork'関数を調査します．動作する
     `fork'が見つかった場合，`HAVE_WORKING_FORK'を定義します．この
     マクロは，`fork'がスタブかどうかを実行してみることで調査します．

     `vfork.h'が見つかった場合，`HAVE_VFORK_H'を定義します．動作す
     る`vfork'が見つかった場合，`HAVE_WORKING_VFORK'を定義します．
     それ以外の場合，以前のバージョンの`autoconf'に対する下位互換のた
     め，`vfork'を`fork'と定義します．このマクロは，`vfork'の
     実装のいくつかの既知のエラーを調査し，そのエラーのいずれかを検出した場合，
     システムには動作する`vfork'が無いと考えます．子プロセスは，シグナル
     ハンドラを変えることがめったにないので，子プロセスの`signal'の呼び
     出しが，親プロセスのシグナルハンドラを変更する場合，実装エラーだとは考え
     られません．

     このマクロは，以前のバージョンの`autoconf'への下位互換性のためだ
     けに`vfork'を定義するので，コード内で独自に定義することを推奨します．
          #if !HAVE_WORKING_VFORK
          # define vfork fork
          #endif

 -- Macro: AC_FUNC_FSEEKO
     `fseeko'関数が利用可能な場合，`HAVE_FSEEKO'を定義します．必要
     があれば，プロトタイプがいくつかのシステム上で(例えばglibc
     2.2)見て分か
     るように，`_LARGEFILE_SOURCE'を定義します．それ以外では，
     `AC_SYS_LARGEFILE'を用いてコンパイルするとき，`off_t'がデフォ
     ルトで64bitになっていないラージファイルに問題があるシステム上で，リンク
     の問題が発生する可能性があります．

 -- Macro: AC_FUNC_GETGROUPS
     `getgroups'関数が利用可能で，(`getgroups (0, 0)'が常に失敗する
     Ultrix 4.3と異なり)動作する場合，`HAVE_GETGROUPS'を定義します．
     `GETGROUPS_LIBS'をその関数の使用に必要な全てのライブラリに定義しま
     す．このマクロは，`AC_TYPE_GETGROUPS'を実行します．

 -- Macro: AC_FUNC_GETLOADAVG
     システムのロードアベレージを取得する方法を調査します．適切に調査を実行す
     るため，このマクロはファイル`getloadavg.c'が必要です．このため，適
     切な置換ディレクトリを`AC_LIBOBJ'で確実に設定してください (*Note
     Generic Functions::と，`AC_CONFIG_LIBOBJ_DIR'を参照してくださ い)．

     システムに`getloadavg'関数がある場合，`HAVE_GETLOADAVG'を定義
     し，その関数の使用に必要な全てのライブラリを`GETLOADAVG_LIBS'に設定
     します．また，`GETLOADAVG_LIBS'を`LIBS'に加えます．それ以外の
     場合，`AC_LIBOBJ'で`getloadavg'を`DIR/getloadavg.c'
     のソースコードで置換することを要求し，おそらく以下のようないくつかのCプ
     リプロセッサのマクロと出力変数を定義します．

       1. `C_GETLOADAVG'を定義します．

       2. システムが，`SVR4'，`DGUX'，`UMAX'，または`UMAX4_3'
          の場合，それを定義します．

       3. `nlist.h'が見つかる場合，`HAVE_NLIST_H'を定義します．

       4. `struct nlist'が`n_un'メンバーを持つ場合，
          `HAVE_STRUCT_NLIST_N_UN_N_NAME'を定義します．時代遅れのシンボル
          `NLIST_NAME_UNION'も定義しますが，それに依存しないようにしてくださ
          い．

       5.
          プログラムによっては，`getloadavg'が動作するために，setgid(または
          setuid)がインストールされていることを必要とするかもしれません．この場合，
          `GETLOADAVG_PRIVILEGED'を定義し，出力変数`NEED_SETGID'を
          `true'に(それ以外では`false'に)設定し，そして`KMEM_GROUP'
          をインストールされているプログラムを所有するグループの名前に設定します．

 -- Macro: AC_FUNC_GETMNTENT
     IRIX 4，PTXと，Unixwareに対し，`sun'，`seq'，そして `gen'
     のライブラリ内の`getmntent'をそれぞれ調査します．
     `getmntent'が利用可能な場合，`HAVE_GETMNTENT'を定義します．

 -- Macro: AC_FUNC_GETPGRP
     `getpgrp'に0を渡すとエラーになる場合，`GETPGRP_VOID'を定義しま
     す．これはPOSIXの動作です．古いBSDシステムでは，それ
     は引数をとりPOSIXの`getpgid'のように動作するので，
     `getpgrp'に0を渡す必要があります．

          #if GETPGRP_VOID
            pid = getpgrp ();
          #else
            pid = getpgrp (0);
          #endif

     このマクロは`getpgrp'が存在するかどうかを全く調査しません．そのよう
     な状況で動作する必要がある場合，`getpgrp'に対して最初に
     `AC_CHECK_FUNC'を呼び出してください．

 -- Macro: AC_FUNC_LSTAT_FOLLOWS_SLASHED_SYMLINK
     `link'がシンボリックリンクの場合，`lstat'は`link/'を
     `link/.'と同じものとして扱います．しかし，多くの古い`lstat' の
     実装では，後置されているスラッシュを間違って無視します．

     `lstat'が後置されているスラッシュを間違って無視する場合，それ以外の
     `unlink'のようなsymbolic-link-aware関数も後置されているスラッシュを
     間違って無視すると仮定した方が確実です．

     `lstat'が正しく動作する場合，`LSTAT_FOLLOWS_SLASHED_SYMLINK'
     を定義し，それ以外の場合は，`AC_LIBOBJ'を`lstat'で置換するよう
     要求します．

 -- Macro: AC_FUNC_MALLOC
     `malloc'関数がGNU Cライブラリの`malloc'と互換性があ
     る場合，(すなわち`malloc (0)'が有効なポインタを返す)場合，
     `HAVE_MALLOC'を1に定義します．それ以外では，`HAVE_MALLOC'を0
     に定義し，`AC_LIBOBJ'で`malloc'を置換し，ネイティブの
     `malloc'が中心的なプロジェクトで使用されないように`malloc'を
     `rpl_malloc'で定義するかどうかを尋ねます．

     通常，ファイル`malloc.c'の置換は以下のようになります(`#undef
     malloc'に注意してください)．


     #if HAVE_CONFIG_H
     # include <config.h>
     #endif
     #undef malloc

     #include <sys/types.h>

     void *malloc ();

     /* Allocate an N-byte block of memory from the heap.
        If N is zero, allocate a 1-byte block.  */

     void *
     rpl_malloc (size_t n)
     {
       if (n == 0)
         n = 1;
       return malloc (n);
     }

 -- Macro: AC_FUNC_MEMCMP
     `memcmp'関数が利用不可能，または(SunOS 4.1.3のように)8ビットデータ
     で動作しない，または(NeXT x86
     OpenStepのように)16バイトかそれ以上で少な
     くとも一つのバッファが4バイト境界で始まらないものの比較時に失敗する場合，
     `AC_LIBOBJ'で`memcmp'を置換することを要求します．

 -- Macro: AC_FUNC_MBRTOWC
     関数`mbrtowc'と型`mbstate_t'が正しく宣言されている場合，
     `HAVE_MBRTOWC'を1に設定します．

 -- Macro: AC_FUNC_MKTIME
     `mktime'関数が利用不可能，または正しく動作しない場合，
     `AC_LIBOBJ'で`mktime'を置換することを要求します．このテストの
     目的に対して，`mktime'はPOSIXに準拠すべきで，
     `localtime'の反対になっているべきです．

 -- Macro: AC_FUNC_MMAP
     `mmap'関数が存在して正しく動作する場合，`HAVE_MMAP'を定義しま
     す．すでにマップされたメモリの，プライベートな固定したマッピングのみ調査
     します．

 -- Macro: AC_FUNC_OBSTACK
     obstackが見つかった場合，`HAVE_OBSTACK'を定義し，そうでない場合は
     `AC_LIBOBJ'で`obstack'を置換することを要求します．

 -- Macro: AC_FUNC_REALLOC
     `realloc'関数がGNU Cライブラリの`realloc'と互換性が
     ある場合，(すなわち`realloc (0, 0)'が有効なポインタを返す)場合，
     `HAVE_REALLOC'を1に定義します．それ以外では，`HAVE_REALLOC' を
     0に定義し，`AC_LIBOBJ'で`realloc'を置換し，ネイティブの
     `realloc'が中心的なプロジェクトで使用されないように`realloc'
     を`rpl_realloc'で定義するかどうかを尋ねます．詳細は
     `AC_FUNC_MALLOC'を参照してください．

 -- Macro: AC_FUNC_SELECT_ARGTYPES
     `select'関数の引数それぞれに渡される正しい型を決定し，それらの型を
     `SELECT_TYPE_ARG1'，`SELECT_TYPE_ARG234'，そして
     `SELECT_TYPE_ARG5'にそれぞれ定義します．`SELECT_TYPE_ARG1'のデ
     フォルトは`int'で，`SELECT_TYPE_ARG234'のデフォルトは`int
     *'で，そして`SELECT_TYPE_ARG5'のデフォルトは`struct timeval *'
     です．

 -- Macro: AC_FUNC_SETPGRP
     `setpgrp'が引数を持たない(POSIXバージョンの)場合，
     `SETPGRP_VOID'を定義します．それ以外では，BSDバージョンで，
     二つのプロセスIDを引数とします．このマクロは`setpgrp'の存在を全く調
     査しません．その状況で動作する必要がある場合，`setpgrp'に対して最初
     に`AC_CHECK_FUNC'を呼び出してください．

 -- Macro: AC_FUNC_STAT
 -- Macro: AC_FUNC_LSTAT
     `stat'や`lstat'に，長さが0のファイル名を引数で与えたときに成功
     するというバグがあるかどうかを決定します．SunOS
     4.1.4とHurd(1998-11-01) の`stat'と`lstat'ではこうなります．

     その場合，`HAVE_STAT_EMPTY_STRING_BUG'(または
     `HAVE_LSTAT_EMPTY_STRING_BUG')を定義し，`AC_LIBOBJ'でそれを置
     換することを要求します．

 -- Macro: AC_FUNC_SETVBUF_REVERSED
     `setvbuf'が他とは異なり，第二引数でバッファの型，第三引数でバッファ
     ポインタをとる場合，`SETVBUF_REVERSED'を定義します．

 -- Macro: AC_FUNC_STRCOLL
     `strcoll'関数が存在して，正しく動作する場合，`HAVE_STRCOLL' を
     定義します．使用すべきではない`strcoll'の間違った定義を持つシステム
     もあるので，`AC_CHECK_FUNCS(strcoll)'より多少ましです．

 -- Macro: AC_FUNC_STRTOD
     `strtod'関数が存在していない，または正しく動作しない場合，
     `AC_LIBOBJ'で`strtod'を置換するよう要求します．この場合，
     `strtod.c'は`pow'を必要とすることもあり得るので，出力変数
     `POW_LIB'を必要な外部ライブラリに設定します．

 -- Macro: AC_FUNC_STRERROR_R
     `strerror_r'が利用可能な場合は`HAVE_STRERROR_R'を定義し，それ
     が宣言されている場合，`HAVE_DECL_STRERROR_R'を定義します．それが
     `char *'のメッセージを返す場合，`STRERROR_R_CHAR_P'を定義しま
     す．それ以外では`int'のエラーナンバーを返します．POSIXで
     は`strerror_r'が`int'を返すように要求していますが，多くのシス
     テムのスレッドセーフな関数のオプション(例えばGNU Cライブラリの
     バージョン2.2.4を含む)は，バッファ引数に等しい必要が無い`char *' の
     値を返します．

 -- Macro: AC_FUNC_STRFTIME
     `intl'ライブラリ内で，SCO UNIXに対する`strftime'を調査し
     ます．`strftime'が利用可能な場合，`HAVE_STRFTIME'を定義します．

 -- Macro: AC_FUNC_STRNLEN
     `strnlen'が利用不可能な場合や(AIX 4.3のように)バグが多い
     場合，`AC_LIBOBJ'で置換することを要求します．

 -- Macro: AC_FUNC_UTIME_NULL
     `utime(FILE, NULL)'がFILEのタイムスタンプを現在のものに
     設定する場合，`HAVE_UTIME_NULL'を定義します．

 -- Macro: AC_FUNC_VPRINTF
     `vprintf'が見つかった場合，`HAVE_VPRINTF'を定義します．それ以
     外で，`_doprnt'が見つかった場合，`HAVE_DOPRNT'を定義します．
     (`vprintf'が利用可能な場合，`vfprintf'と`vsprintf'も利用
     可能だと仮定できるでしょう．)

 -- Macro: AC_REPLACE_FNMATCH
     `fnmatch'関数がPOSIX準拠でない場合(`AC_FUNC_FNMATCH'
     を参照してください)，それを`AC_LIBOBJ'で置換するかどうかを尋ねます．

     `AC_LIBOBJ'の置換用ディレクトリのファイル`fnmatch.c'，
     `fnmatch_loop.c'，そして`fnmatch_.h'が，GNU
     `fnmatch'のソースコードをのコピーを含んでいると想定されます．必要な
     場合，このソースコードは`AC_LIBOBJ'での置換物としてコンパイルされ，
     システムの`<fnmatch.h>'でインクルードできるように，
     `fnmatch_.h'が`fnmatch.h'にリンクされます．


File: autoconf-ja.info,  Node: Generic Functions,  Prev: Particular Functions,  Up: Library Functions

5.5.3 一般の関数の調査
----------------------

これらのマクロは，"特定の"テストマクロによってカバーていない関数を見つ
けるために使用されます．関数が，デフォルトのCライブラリ以外のライブラリ
にある場合，最初にそれらのライブラリに対して`AC_CHECK_LIB'を呼び出
してください．存在の確認だけでなく動作も調査したい場合，独自のテストを書
く必要があります(*note Writing Tests::)．

 -- Macro: AC_CHECK_FUNC (FUNCTION, [ACTION-IF-FOUND],
          [ACTION-IF-NOT-FOUND])
     Cの関数FUNCTIONが利用可能な場合，シェルコマンド
     ACTION-IF-FOUNDを，それ以外ではACTION-IF-NOT-FOUNDを実行しま
     す．関数が利用可能な場合にシンボルを定義したいだけならば，代わりに
     `AC_CHECK_FUNCS'を使用してください．このマクロは， CのほうがC++より
     標準化されているので，`AC_LANG_CPLUSPLUS'が呼び出された場合でも，C
     にリンクされる関数を調査します．(言語の選択の調査ついての詳細は，
     *note Language Choice::．)

 -- Macro: AC_CHECK_FUNCS (FUNCTION..., [ACTION-IF-FOUND],
          [ACTION-IF-NOT-FOUND])
     空白で区切られた引数のリストで与えられているそれぞれのFUNCTIONに対
     し，利用可能な場合は`HAVE_FUNCTION'を(全て大文字で)定義します．
     ACTION-IF-FOUNDが与えられている場合，関数の一つが見つかったとき実
     行する，追加のシェルコードになります．最初に一致したループでブレイクする
     ためには，`break'を与えることで可能になります．
     ACTION-IF-NOT-FOUNDが与えられている場合，それは関数が一つでも見つ
     からないときに実行されます．


Autoconfは，移植性について苦心してきた人々によって，何年もかけて形作られ
てきた哲学に従います．特定のファイルの移植性の問題と，POSIX環
境にいるかのような問題とは別物です．関数によっては，無いものがあったり修
正不可能だったりするものもあり，パッケージではそれらを置き換える準備が必
要になります．

 -- Macro: AC_LIBOBJ (FUNCTION)
     無かったり壊れたりしているFUNCTIONの実装を置換するために，実行形式
     に含める必要がある`FUNCTION.c'を指定します．

     技術的には，それは`FUNCTION.$ac_objext'を，それがまだ無い場合
     は出力変数`LIBOBJS'に追加し，`FUNCTION.c'に対し
     `AC_LIBSOURCE'を呼び出します．`LIBOBJS'は追跡不可能なので，直
     接`LIBOBJS'を変更すべきではありません．

 -- Macro: AC_LIBSOURCE (FILE)
     プロジェクトをコンパイルするために必要になるFILEを指定します．
     `configure.ac'で必要になるファイルを知る必要がある場合，
     `AC_LIBSOURCE'を追跡調査してください．FILEはリテラルにする必
     要があります．

     このマクロは，自動的に`AC_LIBOBJ'から呼び出されますが，シェル変数に
     `AC_LIBOBJ'を渡す場合，明示的に指定する必要があります．この場合，シェ
     ル変数は静的な追跡調査ができないので，`AC_LIBOBJ'を生成するために必
     要になりそうなあらゆるシェル変数を，`AC_LIBSOURCE'に渡す必要があり
     ます．例えば，`"foo"'または`"bar"'を保持している
     `AC_LIBOBJ'に変数`$foo_or_bar'を渡したい場合は，以下のようにす
     べきでしょう．

          AC_LIBSOURCE(foo.c)
          AC_LIBSOURCE(bar.c)
          AC_LIBOBJ($foo_or_bar)

     しかし，これを避ける一般的な方法もあり，それには単純にリテラルの引数で
     `AC_LIBOBJ'を呼び出すことを推奨します．

     このマクロは，時代遅れの`AC_LIBOBJ_DECL'を若干異なる意味で置換する
     ことに注意してください．古いマクロは，ファイル名ではなく関数名，例えば
     `foo'を引数としてとります．

 -- Macro: AC_LIBSOURCES (FILES)
     `AC_LIBSOURCE'に似ていますが，カンマで分けられているM4リストに，一
     つ以上のFILESを受け入れます．このため，上記の例は以下のように書き
     換えられるでしょう．

          AC_LIBSOURCES([foo.c, bar.c])
          AC_LIBOBJ($foo_or_bar)

 -- Macro: AC_CONFIG_LIBOBJ_DIR (DIRECTORY)
     `AC_LIBOBJ'で置換するファイルがDIRECTORYで見つかるように，ソー
     スツリーのトップレベルから始まる相対パスを指定します．置換ディレクトリの
     デフォルトはトップレベルディレクトリの`.'で，最も一般的な値は
     `lib'で，`AC_CONFIG_LIBOBJ_DIR(lib)'で対応します．

     `configure'は以下の理由で，置換ディレクトリを知る必要がないかも
     しれません．(i)置換ファイルを使用する調査もあります．(ii)置換ヘッダのリ
     ンクを導入することで，壊れたシステムヘッダをバイパスするマクロもあります．
     等々．


   `AC_LIBOBJ'が無い場合，単に関数の存在を調査し，置換するかどうか尋ね
るだけのことは一般的です．以下のマクロは，便利で手短なものです．

 -- Macro: AC_REPLACE_FUNCS (FUNCTION...)
     `AC_CHECK_FUNCS'に似ていますが，ACTION-IF-NOT-FOUND として
     `AC_LIBOBJ(FUNCTION)'を使用します．`#if
     !HAVE_FUNCTION'にプロトタイプを含めることで，置換する関数を宣言す
     ることが可能です．システムに関数が存在する場合，おそらくインクルードして
     いるヘッダファイルで宣言されているので，宣言が衝突しないように，それを再
     定義すべきではありません．


File: autoconf-ja.info,  Node: Header Files,  Next: Declarations,  Prev: Library Functions,  Up: Existing Tests

5.6 ヘッダファイル
==================

以下のマクロは，ある特定のCヘッダファイルの存在を調査します．必要として
いるヘッダファイルを調査するために特に定義されたマクロがなく，その特別な
特性を調査する必要がない場合，一般的なヘッダファイルチェックマクロの一つ
を使用することが可能です．

* Menu:

* Header Portability::          Collected knowledge on common headers
* Particular Headers::          Special handling to find certain headers
* Generic Headers::             How to find other headers


File: autoconf-ja.info,  Node: Header Portability,  Next: Particular Headers,  Up: Header Files

5.6.1 ヘッダの移植性
--------------------

このセクションでは，一般的なヘッダとそれらの問題に関する知識を正しくして
みたいと思います．定義上，以下のリストは常なる追加を必要とします．可能な
限り完全に保つ手助けをお願いします．

`inttypes.h'対`stdint.h'
     Paul Eggertのメモ：ISO C 1999では，`inttypes.h'は`stdint.h' を
     インクルードするので，標準的な環境では`stdint.h'を個別にインクルー
     ドする必要な無いことになっています．多くの実装では，`inttypes.h'は
     ありますが`stdint.h'はありませんし(例えば，Solaris 7)，
     `stdint.h'があって`inttypes.h'が無いと言う実装は知りません．ま
     た，`stdint.h'をインクルードしているフリーソフトウェアも知りません．
     `stdint.h'は，委員会で作成されたようです．

`linux/irda.h'
     それは，`linux/types.h'と`sys/socket.h'を要求します．

`linux/random.h'
     それは，`linux/types.h'を要求します．

`net/if.h'
     Darwin上では，このファイルは`sys/socket.h'がそれ以前にインクルード
     されていることを要求します．以下のように実行すべきです．

          AC_CHECK_HEADERS([sys/socket.h])
          AC_CHECK_HEADERS([net/if.h], [], [],
          [#include <stdio.h>
          #if STDC_HEADERS
          # include <stdlib.h>
          # include <stddef.h>
          #else
          # if HAVE_STDLIB_H
          #  include <stdlib.h>
          # endif
          #endif
          #if HAVE_SYS_SOCKET_H
          # include <sys/socket.h>
          #endif
          ])

`netinet/if_ether.h'
     Darwin上では，このファイルは`stdio.h'と`sys/socket.h'がそれ以
     前にインクルードされていることを要求します．以下のように実行すべきです．

          AC_CHECK_HEADERS([sys/socket.h])
          AC_CHECK_HEADERS([netinet/if_ether.h], [], [],
          [#include <stdio.h>
          #if STDC_HEADERS
          # include <stdlib.h>
          # include <stddef.h>
          #else
          # if HAVE_STDLIB_H
          #  include <stdlib.h>
          # endif
          #endif
          #if HAVE_SYS_SOCKET_H
          # include <sys/socket.h>
          #endif
          ])

`stdint.h'
     上記の`inttypes.h'対`stdint.h'を参照して下さい．

`stdlib.h'
     多くのシステム上で(例えばDarwin)，`stdio.h'が必須になります．

`sys/mount.h'
     ia32のFreeBSD
     4.8と，gccのバージョン2.95.4を使用しているシステムでは，
     `sys/params.h'が必須になります．

`sys/socket.h'
     Darwin上では，`stdlib.h'が必須になります．

`sys/ucred.h'
     HP Tru64 5.1上では，`sys/types.h'が必須になります．

`X11/extensions/scrnsaver.h'
     XFree86を使用している場合は，このヘッダは`X11/Xlib.h'を要求し，おそ
     らくそれを探すことを考えなくても良いでしょう．

          AC_CHECK_HEADERS([X11/extensions/scrnsaver.h], [], [],
          [[#include <X11/Xlib.h>
          ]])


File: autoconf-ja.info,  Node: Particular Headers,  Next: Generic Headers,  Prev: Header Portability,  Up: Header Files

5.6.2 特定のヘッダの調査
------------------------

これらのマクロは，特定のシステムヘッダファイルを調査します -- それらが
存在しているか，そして場合によっては，特定のシンボルを宣言しているかを調
査します．

 -- Macro: AC_HEADER_DIRENT
     以下のヘッダファイルを調査します．最初に見つかった`DIR'を定義してい
     るものに対して，リストアップされているCプリプロセッサマクロを定義します．

     `dirent.h'     `HAVE_DIRENT_H'
     `sys/ndir.h'   `HAVE_SYS_NDIR_H'
     `sys/dir.h'    `HAVE_SYS_DIR_H'
     `ndir.h'       `HAVE_NDIR_H'

     ソースコード内のディレクトリライブラリの宣言は，以下のようにすべきでしょ
     う．

          #if HAVE_DIRENT_H
          # include <dirent.h>
          # define NAMLEN(dirent) strlen((dirent)->d_name)
          #else
          # define dirent direct
          # define NAMLEN(dirent) (dirent)->d_namlen
          # if HAVE_SYS_NDIR_H
          #  include <sys/ndir.h>
          # endif
          # if HAVE_SYS_DIR_H
          #  include <sys/dir.h>
          # endif
          # if HAVE_NDIR_H
          #  include <ndir.h>
          # endif
          #endif

     上記の宣言を使用している場合，プログラムは型を`struct direct'ではな
     く`struct dirent'として変数を宣言し，`struct dirent'へのポイン
     タを渡すことによって，`NAMLEN'マクロまでのディレクトリエントリ名の
     長さにアクセスします．

     このマクロは，SCO Xenix `dir'と`x'ライブラリも調査します．

 -- Macro: AC_HEADER_MAJOR
     `sys/types.h'が`major'，`minor'，そして`makedev'を定
     義していないが，`sys/mkdev.h'が定義している場合，
     `MAJOR_IN_MKDEV'を定義します．それ以外の場合で，
     `sys/sysmacros.h'が定義している場合は，`MAJOR_IN_SYSMACROS' を
     定義します．

 -- Macro: AC_HEADER_STAT
     `sys/stat.h'で定義されている`S_ISDIR'，`S_ISREG'等のマク
     ロが正確に動作しない(間違った正の値を返す)場合，
     `STAT_MACROS_BROKEN' を定義します．Tektronix UTekV，Amdahl UTS，そ
     してMotorola System V/88の場合がそうです．

 -- Macro: AC_HEADER_STDBOOL
     `stdbool.h'が存在し，それがC99に準拠している場合，
     `HAVE_STDBOOL_H'を1に定義します．型`_Bool'が定義されている場合，
     `HAVE__BOOL'を1に定義します．C99の要求を満たすため，`system.h'
     には以下のコードを含めるべきです．


     #if HAVE_STDBOOL_H
     # include <stdbool.h>
     #else
     # if ! HAVE__BOOL
     #  ifdef __cplusplus
     typedef bool _Bool;
     #  else
     typedef unsigned char _Bool;
     #  endif
     # endif
     # define bool _Bool
     # define false 0
     # define true 1
     # define __bool_true_false_are_defined 1
     #endif

 -- Macro: AC_HEADER_STDC
     システムにANSI Cヘッダファイルが存在する場合，
     `STDC_HEADERS'を定義します．特にこのマクロは，`stdlib.h'，
     `stdarg.h'，`string.h'，そして`float.h'を調査し，システム
     にそれらが存在している場合は，おそらくANSI Cヘッダーファイルの
     残りも存在します．同様に，このマクロは`string.h'が`memchr'を宣
     言(他の`mem'関数もおそらく存在)しているかどうか，`stdlib.h'が
     `free'を宣言(`malloc'や他の関連する関数もおそらく存在)している
     かどうか，そして，`ctype.h'マクロが，ANSI Cが要求するハイ
     ビットセット文字でも動作するかどうかを調査します．

     GCCがあるシステムの多くはANSI Cヘッダファイルが存在していない
     ので，システムにANSI対応のヘッダファイル(そして，おそらくC ラ
     イブラリ関数) が存在していることを決定するために，`__STDC__'の代わ
     りに`STDC_HEADERS'を使用してください．

     ANSI Cヘッダが無いシステムには多くの変種が存在していて，そこで
     は，システムヘッダファイルが宣言しているものを正確に理解するより，使用す
     る関数を宣言する方がより容易でしょう．ANSIとBSDの関
     数が混在しているシステムもあります．ほとんどANSIだが
     `memmove'が無いものもあります．BSD関数が`string.h'や `strings.h'
     でマクロで定義されているものもあります．BSD関 数しか持っていないが
     `string.h'が存在するものもあります．メモリ関数
     が`memory.h'で定義されていて，`string.h'でも定義されているもの
     もあります．等々いろいろなシステムがあります．一つの文字列関数と一つのメ
     モリ関数を調査すれば恐らく十分です．ライブラリにANSIバージョン
     のものが存在する場合，他のものもほとんど存在します．以下を
     `configure.ac'に書き込む場合を考えます．

          AC_HEADER_STDC
          AC_CHECK_FUNCS(strchr memcpy)

     コード内に，以下のような宣言を使用することが可能です．

          #if STDC_HEADERS
          # include <string.h>
          #else
          # if !HAVE_STRCHR
          #  define strchr index
          #  define strrchr rindex
          # endif
          char *strchr (), *strrchr ();
          # if !HAVE_MEMCPY
          #  define memcpy(d, s, n) bcopy ((s), (d), (n))
          #  define memmove(d, s, n) bcopy ((s), (d), (n))
          # endif
          #endif

     BSDとは異なる`memchr'，`memset'，`strtok'，また は
     `strspn'の様な関数を使用する場合，マクロは不十分でしょう．それぞ
     れの関数を実装する必要があります．(システムのCライブラリのものが，手動で
     最適化されているかもしれないので)必要なときだけ実装を組み込む簡単な方法
     として，例えば`memchr'を使用する場合は，それを`memchr.c'に書き
     込み，`AC_REPLACE_FUNCS(memchr)'を使用することです．

 -- Macro: AC_HEADER_SYS_WAIT
     `sys/wait.h'が存在して，POSIXと互換性がある場合，
     `HAVE_SYS_WAIT_H'を定義します．非互換性は，`sys/wait.h'が存在
     しない場合や，ステータスの値を保存するため，`int'の代わりに古い
     BSDの`union wait'使用する場合に生じます．
     `sys/wait.h'がPOSIXと互換性がない場合，それをインクルード
     する代わりに，それらの通常の解釈を用いてPOSIXのマクロを定義し
     てください．例えば以下のようにします．

          #include <sys/types.h>
          #if HAVE_SYS_WAIT_H
          # include <sys/wait.h>
          #endif
          #ifndef WEXITSTATUS
          # define WEXITSTATUS(stat_val) ((unsigned)(stat_val) >> 8)
          #endif
          #ifndef WIFEXITED
          # define WIFEXITED(stat_val) (((stat_val) & 255) == 0)
          #endif

   `unistd.h'がPOSIXシステムに含まれている場合，
`_POSIX_VERSION'が定義されます．`unistd.h'が無い場合，明らかに
POSIXシステムではありません．しかし，`unistd.h'を持つ
POSIXではないシステムもあります．

   システムがPOSIXをサポートしているかどうか調査する方法は以下の
ようにします．

     #if HAVE_UNISTD_H
     # include <sys/types.h>
     # include <unistd.h>
     #endif

     #ifdef _POSIX_VERSION
     /* Code for POSIX systems.  */
     #endif

 -- Macro: AC_HEADER_TIME
     プログラムが，`time.h'と`sys/time.h'の両方をインクルードする可
     能性がある場合，`TIME_WITH_SYS_TIME'を定義します．古いシステムでは，
     `sys/time.h'が`time.h'をインクルードするものもありますが，
     `time.h'は複数回のインクルードに対して保護されていないので，プログ
     ラムで明示的に両方のファイルをインクルードすべきではありません．このマク
     ロは，例えば，`struct tm'と同様，`struct timeval'を使用するプ
     ログラムで役に立ちます． `AC_CHECK_HEADERS(sys/time.h)' を使用して
     いることを調査可能にする`HAVE_SYS_TIME_H'と一緒に使用するのが最善の
     方法です．

          #if TIME_WITH_SYS_TIME
          # include <sys/time.h>
          # include <time.h>
          #else
          # if HAVE_SYS_TIME_H
          #  include <sys/time.h>
          # else
          #  include <time.h>
          # endif
          #endif

 -- Macro: AC_HEADER_TIOCGWINSZ
     `TIOCGWINSZ'の使用が`<sys/ioctl.h>'を要求する場合，
     `GWINSZ_IN_SYS_IOCTL'を定義します．それ以外では，`TIOCGWINSZ'
     は`<termios.h>'で見つかるはずです．

     以下のようにして使用します．

          #if HAVE_TERMIOS_H
          # include <termios.h>
          #endif

          #if GWINSZ_IN_SYS_IOCTL
          # include <sys/ioctl.h>
          #endif


File: autoconf-ja.info,  Node: Generic Headers,  Prev: Particular Headers,  Up: Header Files

5.6.3 一般的なヘッダの調査
--------------------------

これらのマクロは，"特定の"テストマクロでカバーされていない，システムヘッ
ダファイルを見つけるために使用されます．その存在を見つけるだけでなく，ヘッ
ダの内容を調査する必要がある場合，そのために独自のテストを書く必要があり
ます(*note Writing Tests::)．

 -- Macro: AC_CHECK_HEADER (HEADER-FILE, [ACTION-IF-FOUND],
          [ACTION-IF-NOT-FOUND], [INCLUDES = `default-includes'])
     システムヘッダファイルHEADER-FILEがコンパイル可能な場合，シェルコ
     マンドACTION-IF-FOUNDを，それ以外ではACTION-IF-NOT-FOUND を
     実行します．ヘッダファイルが利用可能な場合で，シンボルを定義したいだけの
     場合は，代わりに，`AC_CHECK_HEADERS'を使用を考えてみてください．

     古いバージョンのAutoconfとの互換性の問題は，以下を読んでください．

 -- Macro: AC_CHECK_HEADERS (HEADER-FILE..., [ACTION-IF-FOUND],
          [ACTION-IF-NOT-FOUND], [INCLUDES = `default-includes'])
     空白で区切られた引数のリストで与えられているシステムヘッダファイル
     HEADER-FILEが存在しているものに対し，`HAVE_HEADER-FILE'
     を(全て大文字で)定義します．ACTION-IF-FOUNDが与えられている場合，
     それはヘッダファイルの一つが見つかったときに実行する追加のシェルコードに
     なります．最初に一致したループでブレイクするために`break'を与えるこ
     とが可能です． ACTION-IF-NOT-FOUNDが与えられている場合，ヘッダファ
     イルが一つでも見つからないとき実行されます．

     古いバージョンのAutoconfとの互換性の問題は，以下を読んでください．

以前のバージョンのAutoconfは，ヘッダがプリプロセッサに適合しているかどう
かを，単純に調査していました．古いテストは，代表的な使用に対して不適切で
あるため変更されました．ヘッダは通常コンパイルで使用され，プリプロセスで
は滅多に使用されませんし，古い動作では，コンパイル時にだめになるヘッダを
受け入れることもありました．ヘッダがプリプロセス可能かどうかを調査する必
要がある場合，`AC_PREPROC_IFELSE'を使用することが可能です (*note
Running the Preprocessor::)．

   このテストの耐性を高める手法は，HEADER-FILEの前にインクルードする
必要があるヘッダが，INCLUDESにあることも要求します(*note Default
Includes::)．`foo.h'が存在する場合，その前でインクルードされる必要が
ある`bar.h'を探す場合，以下の手法を提案します．


AC_CHECK_HEADERS([foo.h])
AC_CHECK_HEADERS([bar.h], [], [],
[#if HAVE_FOO_H
# include <foo.h>
# endif
])


File: autoconf-ja.info,  Node: Declarations,  Next: Structures,  Prev: Header Files,  Up: Existing Tests

5.7 宣言
========

以下のマクロは，変数と関数の宣言を調査します．必要なシンボルを調査するた
めに特別なマクロが定義されていない場合，一般的なマクロ(*note Generic
Declarations::を使用することが可能で，より複雑なテストに対しては，
`AC_COMPILE_IFELSE'を使用してもかまいません(*note Running the
Compiler::)．

* Menu:

* Particular Declarations::     Macros to check for certain declarations
* Generic Declarations::        How to find other declarations


File: autoconf-ja.info,  Node: Particular Declarations,  Next: Generic Declarations,  Up: Declarations

5.7.1 特定の宣言の調査
----------------------

宣言を調査する特別なマクロはありません．


File: autoconf-ja.info,  Node: Generic Declarations,  Prev: Particular Declarations,  Up: Declarations

5.7.2 一般的な宣言の調査
------------------------

これらのマクロは，"特定の"テストマクロでカバーされていない宣言を調査す
るために使用します．

 -- Macro: AC_CHECK_DECL (SYMBOL, [ACTION-IF-FOUND],
          [ACTION-IF-NOT-FOUND], [INCLUDES = `default-includes'])
     SYMBOL(関数や変数)がINCLUDESで定義されていなくて宣言が必要な
     場合，シェルコマンドACTION-IF-NOT-FOUNDを実行し，それ以外では
     ACTION-IF-FOUNDを実行します．INCLUDESが宣言されていない場合，
     デフォルトのインクルードが使用されます(*note Default Includes::)．

     このマクロは，必要でないときに余分な宣言を導入することを避けた方が安全な
     ので，SYMBOLがr-valueとして有効かどうかを実際にテストし，実際に宣
     言されているかどうかはテストしません．

 -- Macro: AC_CHECK_DECLS (SYMBOLS, [ACTION-IF-FOUND],
          [ACTION-IF-NOT-FOUND], [INCLUDES = `default-includes'])
     それぞれの(_カンマ_で分けられているリスト)SYMBOLSに対し，
     SYMBOLが宣言されれいる場合は`HAVE_DECL_SYMBOL'を(全て大
     文字で)`1'に定義し，それ以外では`0'に定義します．
     ACTION-IF-NOT-FOUNDが与えられている場合，関数宣言の一つが必要なと
     き実行するシェルコードを追加し，それ以外ではACTION-IF-FOUNDが実行
     されます．

     このマクロは，最初の引数としてM4のリストを使用します．
          AC_CHECK_DECLS(strdup)
          AC_CHECK_DECLS([strlen])
          AC_CHECK_DECLS([malloc, realloc, calloc, free])

     他の`AC_CHECK_*S'マクロと異なり，SYMBOLが宣言されていないとき，
     `HAVE_DECL_SYMBOL'を宣言しないままにする代わりに，
     `HAVE_DECL_SYMBOL'は`0'で定義されます．調査の実行を
     _確かめている_ときは，`HAVE_DECL_SYMBOL'をAutoconfの他の
     結果と同じように，以下のように使用してください．

          #if !HAVE_DECL_SYMBOL
          extern char *symbol;
          #endif

     しかし，テストが実行されていない場合，システムのものと衝突するような宣言
     を使用するより，シンボルを宣言_しない_方が安全なので，以下のように
     使用すべきでしょう．

          #if defined HAVE_DECL_MALLOC && !HAVE_DECL_MALLOC
          void *malloc (size_t *s);
          #endif

     究極の状態でのみ二番目のカテゴリに分類されます．ファイルがコンフィグレー
     ションされずに使用されている場合か，コンフィグレーション時に使用されてい
     る場合のいずれかです．ほとんどの場合はこれまでの方法で十分です．


File: autoconf-ja.info,  Node: Structures,  Next: Types,  Prev: Declarations,  Up: Existing Tests

5.8 構造体
==========

以下のマクロは，特定のCの構造体の存在を調査します．必要なメンバーの調査
するために定義されている特定のマクロが無い場合，一般的な構造体メンバーの
マクロを使用したり(*note Generic Structures::)，より複雑なテストに対して
は，`AC_COMPILE_IFELSE'を使用してもかまいません(*note Running the
Compiler::)．

* Menu:

* Particular Structures::       Macros to check for certain structure members
* Generic Structures::          How to find other structure members


File: autoconf-ja.info,  Node: Particular Structures,  Next: Generic Structures,  Up: Structures

5.8.1 特定の構造体の調査
------------------------

以下のマクロは，特定の構造体と構造体のメンバーを調査します．

 -- Macro: AC_STRUCT_ST_BLKSIZE
     `struct stat'が`st_blksize'メンバーを含んでいる場合，
     `HAVE_STRUCT_STAT_ST_BLKSIZE'を定義します．これまでの名前
     `HAVE_ST_BLKSIZE'は，将来サポートを中止するので避けてください．この
     マクロは時代遅れで，以下のもので置換すべきです．

          AC_CHECK_MEMBERS([struct stat.st_blksize])

 -- Macro: AC_STRUCT_ST_BLOCKS
     `struct stat'が`st_blocks'メンバーを含んでいる場合， `HAVE_STRUCT
     STAT_ST_BLOCKS'を定義します．それ以外では，出力変数
     `AC_LIBOBJS'で`fileblocks'の置換を要求します．これまでの名前
     `HAVE_ST_BLOCKS'は，将来サポートを中止するので避けてください．

 -- Macro: AC_STRUCT_ST_RDEV
     `struct stat'が`st_rdev'メンバーを含んでいる場合，
     `HAVE_STRUCT_STAT_ST_RDEV'を定義します．これまでの名前
     `HAVE_ST_RDEV'は，将来サポートを中止するので避けてください．実際に
     は新しいマクロでさえ時代遅れで，以下のもので置換すべきです．
          AC_CHECK_MEMBERS([struct stat.st_rdev])

 -- Macro: AC_STRUCT_TM
     `time.h'が`struct tm'を定義しない場合，`TM_IN_SYS_TIME'
     を定義し，それは，`sys/time.h'をインクルードすることで`struct
     tm'を定義した方が良いことを意味します．

 -- Macro: AC_STRUCT_TIMEZONE
     現在のタイムゾーンの取得法を判別します．`struct tm'に`tm_zone'
     メンバーが存在する場合，`HAVE_STRUCT_TM_TM_ZONE' (と時代遅れの
     `HAVE_TM_ZONE')を定義します．それ以外では，外部配列の`tzname'
     が見つかる場合，`HAVE_TZNAME'を定義します．


File: autoconf-ja.info,  Node: Generic Structures,  Prev: Particular Structures,  Up: Structures

5.8.2 一般的な構造体の調査
--------------------------

これらのマクロは，"特定の"テストマクロでカバーされていない構造体のメン
バーを検索するために使用します．

 -- Macro: AC_CHECK_MEMBER (AGGREGATE.MEMBER, [ACTION-IF-FOUND],
          [ACTION-IF-NOT-FOUND], [INCLUDES = `default-includes'])
     MEMBERが集合体AGGREGATEのメンバーかどうかを調査します．
     INCLUDESが指定されていない場合，デフォルトのインクルードが使用され
     ます(*note Default Includes::)．

          AC_CHECK_MEMBER(struct passwd.pw_gecos,,
                          [AC_MSG_ERROR([We need `passwd.pw_gecos'!])],
                          [#include <pwd.h>])

     このマクロはサブメンバーに対して使用可能です．

          AC_CHECK_MEMBER(struct top.middle.bot)

 -- Macro: AC_CHECK_MEMBERS (MEMBERS, [ACTION-IF-FOUND],
          [ACTION-IF-NOT-FOUND], [INCLUDES = `default-includes'])
     直前のマクロで使用されているMEMBERSのそれぞれの
     `AGGREGATE.MEMBER'の存在を調査します．MEMBERが
     AGGREGATEに属しているとき， `HAVE_AGGREGATE_MEMBER'
     を(全て大文字で，スペースとドッ
     トをアンダースコアで置換しながら)定義します．ACTION-IF-FOUNDが与え
     られている場合，メンバーが見つかるたびにそれを実行します．
     ACTION-IF-NOT-FOUNDが与えられている場合，メンバーが見つからないた
     びに実行されます．

     このマクロはM4のリストを使用します．
          AC_CHECK_MEMBERS([struct stat.st_rdev, struct stat.st_blksize])


File: autoconf-ja.info,  Node: Types,  Next: Compilers and Preprocessors,  Prev: Structures,  Up: Existing Tests

5.9 型
======

以下のマクロは，組み込みまたはtypedefになっている，Cの型を調査します．必
要な型を調査するための特別に定義されたマクロがなく，その特別な特性を調査
する必要がない場合，一般的な型調査マクロを使用することが可能です．

* Menu:

* Particular Types::            Special handling to find certain types
* Generic Types::               How to find other types


File: autoconf-ja.info,  Node: Particular Types,  Next: Generic Types,  Up: Types

5.9.1 特定の型の調査
--------------------

これらのマクロは，`sys/types.h'，`stdlib.h'，そして存在する場
合はその他の，特定のCの型を調査します．

 -- Macro: AC_TYPE_GETGROUPS
     `gid_t'と`int'のどちらかを，`getgroups'への配列引数の基本
     の型にするため，`GETGROUPS_T'を定義します．

 -- Macro: AC_TYPE_MBSTATE_T
     `<wchar.h>'で`mbstate_t'型が宣言されている場合，
     `HAVE_MBSTATE_T'を定義します．また，`<wchar.h>'で宣言されてい
     ない場合，型として`mbstate_t'を定義します．

 -- Macro: AC_TYPE_MODE_T
     `AC_CHECK_TYPE(mode_t, int)'と同じです．

 -- Macro: AC_TYPE_OFF_T
     `AC_CHECK_TYPE(off_t, long)'と同じです．

 -- Macro: AC_TYPE_PID_T
     `AC_CHECK_TYPE(pid_t, int)'と同じです．

 -- Macro: AC_TYPE_SIGNAL
     `signal.h'が，`signal'を`void'返す関数へのポインタを返す
     ものと宣言されている場合，`RETSIGTYPE'を`void'と定義します．そ
     れ以外では`int'と定義します．

     シグナルハンドラが返す型を`RETSIGTYPE'と定義してください．

          RETSIGTYPE
          hup_handler ()
          {
          ...
          }

 -- Macro: AC_TYPE_SIZE_T
     `AC_CHECK_TYPE(size_t, unsigned)'と同じです．

 -- Macro: AC_TYPE_UID_T
     `uid_t'が定義されていない場合，`uid_t'を`int'に，そして
     `gid_t'を`int'に定義します．


File: autoconf-ja.info,  Node: Generic Types,  Prev: Particular Types,  Up: Types

5.9.2 一般的な型の調査
----------------------

これらのマクロは，"特定の"テストマクロがカバーしない型を調査するために
使用されます．

 -- Macro: AC_CHECK_TYPE (TYPE, [ACTION-IF-FOUND],
          [ACTION-IF-NOT-FOUND], [INCLUDES = `default-includes'])
     TYPEが定義されているかどうかを調査します．コンパイラ組み込みの型や，
     INCLUDES(*note Default
     Includes::)で定義されている可能性があります．

 -- Macro: AC_CHECK_TYPES (TYPES, [ACTION-IF-FOUND],
          [ACTION-IF-NOT-FOUND], [INCLUDES = `default-includes'])
     定義されているTYPESのそれぞれのTYPEに対し，
     `HAVE_TYPE'を(全て大文字で)定義します．INCLUDESが定義さ
     れていない場合，デフォルトのインクルードが使用されます(*note
     Default
     Includes::)．ACTION-IF-FOUNDが与えられている場合，型の一つが見つかっ
     たときに実行する追加のシェルコードとなります．ACTION-IF-NOT-FOUND
     が与えられている場合，型の一つでも見つからないときに実行されます．

     このマクロはM4のリストを使用します．
          AC_CHECK_TYPES(ptrdiff_t)
          AC_CHECK_TYPES([unsigned long long, uintmax_t])


   2.13までのAutoconfは，設計に問題がある他のバージョンの
`AC_CHECK_TYPE'を提供するために使用されていました．単純な経験則とし
て，全体的ではないが全く安全なので，下位互換性のため，実装されました．疑
うのなら，以前の`AC_CHECK_TYPE'のドキュメントを読んでください． *Note
Obsolete Macros::を参照してください．


File: autoconf-ja.info,  Node: Compilers and Preprocessors,  Next: System Services,  Prev: Types,  Up: Existing Tests

5.10 コンパイラとプリプロセッサ
===============================

コンパイラ(`AC_PROG_CC'，`AC_PROG_CXX'，`AC_PROG_F77') に
対する全てのテストは，コンパイラの出力のベースとなる出力変数
`EXEEXT'を定義し，通常，Unixでは空の文字列でWin32やOS/2では
`.exe'に定義されます．

   それらは，`.c'ファイルが除外された後で，コンパイラ出力のベースとな
る出力変数`OBJEXT'も定義し，通常，Unixでは`o'でWin32では
`obj'に定義されますます．

使用しているコンパイラが実行形式を生成しない場合，テストは失敗します．
実行形式が実行不可能な場合で，クロスコンパイルが利用できない場合も失敗
します．クロスコンパイルのサポートの詳細は，*Note Manual
Configuration::.

* Menu:

* Specific Compiler Characteristics::  Some portability issues
* Generic Compiler Characteristics::  Language independent tests and features
* C Compiler::                  Checking its characteristics
* C++ Compiler::                Likewise
* Fortran Compiler::            Likewise


File: autoconf-ja.info,  Node: Specific Compiler Characteristics,  Next: Generic Compiler Characteristics,  Up: Compilers and Preprocessors

5.10.1 特定のコンパイラの特徴
-----------------------------

コンパイラによっては異なる動作を示すものもあります．

スタティック/ダイナミックな式
     Autoconfは，Cコンパイラからの情報の1ビットを抽出するトリックを信頼してい
     ます．負の配列の大きさを使用します．例えば，以下のCソースの引用で，
     `int' が4バイト長かどうかをテストする方法を説明します．

          int
          main (void)
          {
            static int test_array [sizeof (int) == 4 ? 1 : -1];
            test_array [0] = 0
            return 0;
          }

     知っている限りでは，このトリックをサポートしないコンパイラは一つです．そ
     れはHP-UX
     11.00のHPのCコンパイラです("バンドル"されているものだけでは
     なく，実際のものもそうです)．

          $ cc -c -Ae +O2 +Onolimit conftest.c
          cc: "conftest.c": error 1879: Variable-length arrays cannot \
              have static storage.

     Autoconfは，比較する前に`sizeof (int)'を`long'にキャストするこ
     とで，この問題を解決します．


File: autoconf-ja.info,  Node: Generic Compiler Characteristics,  Next: C Compiler,  Prev: Specific Compiler Characteristics,  Up: Compilers and Preprocessors

5.10.2 一般的なコンパイラの特徴
-------------------------------

 -- Macro: AC_CHECK_SIZEOF (TYPE, [UNUSED], [INCLUDES =
          `default-includes'])
     `SIZEOF_TYPE'(*note Standard Symbols::)をTYPEのバイトサ
     イズに定義します．`type'が分からない場合，そのサイズは0になります．
     INCLUDESが指定されていない場合，デフォルトのインクルードが使用され
     ます(*note Default Includes::)．INCLUDEを与える場合，このマクロを
     実行するために必要な`stdio.h'を必ずインクルードしてください．

     このマクロは，現在クロスコンパイル時にも動作します．UNUSED引数は，
     クロスコンパイル時に使用します．

     例えば，以下のように呼び出します．

          AC_CHECK_SIZEOF(int *)

     これは，DEC Alpha AXPシステムでは`SIZEOF_INT_P'を8に定義します．

 -- Macro: AC_LANG_WERROR
     通常，Autoconfはコンパイラ，リンカ，そしてプリプロセッサが生成する警告を
     無視します．このマクロが使用されている場合，現在の言語に対し，警告は重大
     なエラーとして処理されます．このマクロは，コンフィグレーションの結果が，
     予期せぬ警告が生じる場所で使用されるとき役に立ちます．例えば，プログラム
     の一部を`-Werror'オプションでビルドしている場合があてはまります．プ
     ログラム全体を`-Werror'を使用してビルドしている場合，コンパイラフラ
     グに単純に(`CFLAGS'などで)`-Werror'を追加したほうがより単純で
     しょう．


File: autoconf-ja.info,  Node: C Compiler,  Next: C++ Compiler,  Prev: Generic Compiler Characteristics,  Up: Compilers and Preprocessors

5.10.3 Cコンパイラの特徴
------------------------

以下のマクロは，Cコンパイラを探し使用する方法を提供します．避けたほうが
良い構成物もいくつかありますが，それらは容易に回避可能なので，調査に使用
しているなら無くしてしまうこともないでしょう．

単一のバックスラッシュを含んでいる行を使用しないでください
     それらは，HP-UX
     Cコンパイラにあるバグにはめられます(HP-UXの10.20，11.00，
     そして11iで調査しました)．以下のソースをコンパイラで実行します．

          #ifdef __STDC__
          /\
          * A comment with backslash-newlines in it. %{ %} *\
          \
          /
          char str[] = "\\
          " A string with backslash-newlines in it %{ %} \\
          "";
          char apostrophe = '\\
          \
          '\
          ';
          #endif

     以下のようになります．

          error-->cpp: "foo.c", line 13: error 4048: Non-terminating comment at end of file.
          error-->cpp: "foo.c", line 13: error 4033: Missing #endif at end of file.

     単一のバックスラッシュを用いた行を削除することで，問題を解決できます．

出力が問題になる場合，一度に複数のファイルをコンパイルしないでください
     HPのようにコンパイラには，ファイルが複数の_とき_，コンパイルしてい
     るファイル名を報告するものもあります．例えば以下のものです．

          $ cc a.c b.c
          a.c:
          b.c:

     失敗を検出するために，コンパイラの出力を観察する場合，これは問題になるは
     ずです．`cc -c a.c -o a.o; cc -c b.c -o b.o; cc a.o b.o -o c'で呼び
     出すことで問題を解決します．

正しい`#line'のサポートに依存しないで下さい
     Solaris 8上で，`c89'(Sun WorkShop 6 update 2 C 5.3 Patch 111679-08
     2002/05/09))は行番号全体で32767より大きな`#line'指示語を
     拒絶します．さらにPOSIXでは，これは有効になっていません．これは，
     Autoconfが`#line'指示語の生成を停止した理由です．

 -- Macro: AC_PROG_CC ([COMPILER-SEARCH-LIST])
     使用するCコンパイラを決定します．`CC'が環境変数で設定されていない場
     合，`gcc'と`cc'を調査し，その後で他のCコンパイラを調査します．
     出力変数`CC'を，見つかったコンパイラの名前に設定します．

     しかし，このマクロはオプションで最初の引数を用いて呼び出すことも可能で，
     それが指定されている場合，それをスペースで区切られている検索するCコンパ
     イラのリストにする必要があります．これは，別のCコンパイラの検索リストを
     指定する機会をユーザに与えます．例えば，デフォルトの順序が好きではない場
     合，以下のような`AC_PROG_CC'を呼び出すことが可能です．

          AC_PROG_CC(cl egcs gcc cc)

     CコンパイラがデフォルトでANSI Cモードでない場合，そうするため
     のオプションを出力変数`CC'に追加します．このマクロは，様々なシステ
     ムでANSI Cを選択するように，様々なオプションを試します．関数の
     プロトタイプを正しく処理する場合，コンパイラがANSI Cモードだと
     考えます．

     このマクロを呼び出した後，CコンパイラがANSI Cを受け入れるよう
     に設定されているかどうかを調査することが可能です．そうでない場合，シェル
     変数`ac_cv_prog_cc_stdc'は`no'に設定されます．ソースコードを ANSI
     Cで書いている場合，Automake附属のプログラム `ansi2knr'
     を使用して，非ANSIfiedされたコピーを作成するこ
     とが可能です．`AC_C_PROTOTYPES'以下も参照してください．

     GNU Cコンパイラを使用する場合，シェル変数の`GCC'を
     `yes'に設定します．出力変数`CFLAGS'がいまだ設定されていない場
     合，GNU Cコンパイラに対しては`-g -O2'に設定し(GCCが
     `-g'を受け入れないシステムは`-O2')，それ以外のコンパイラに対し
     ては`-g'に設定します．

 -- Macro: AC_PROG_CC_C_O
     Cコンパイラが`-c'と`-o'オプションを同時に受け入れない場合，
     `NO_MINUS_C_MINUS_O'を定義します．このマクロは，`AC_PROG_CC'
     で見つかったコンパイラと，パスの最初の`cc'がそれと異なっている場合
     はその両方を，実際にテストします．一つでも失敗した場合，テストは失敗しま
     す．このマクロは，GNU Makeがデフォルトのコンパイルルールを選択
     するように作成されました．

 -- Macro: AC_PROG_CPP
     出力変数`CPP'を，Cプリプロセッサを実行するコマンドに設定ます．
     `$CC -E'が動作しない場合，`/lib/cpp'を使用します．拡張子が
     `.c'のファイルで`CPP'を実行することは移植性のためだけです．

     プロセッサによっては，足りないインクルードファイルをエラーステータスで示
     さないものもあります．そのようなプロセッサに対する内部変数は，プリプロセッ
     サからの標準エラーを調査するための他のマクロを設定し，警告が報告された場
     合はテストに失敗したと判断します．それにもかかわらず，ほとんどのプリプロ
     セッサに対して，`AC_PROG_CPP_WERROR'も指定しない限り，警告でインク
     ルードファイルのテストは失敗します．

 -- Macro: AC_PROG_CPP_WERROR
     これは`AC_PROG_CPP'のように動作しますが，プリプロセッサからの警告を，
     プリプロセッサが成功したことを示すステータスで終了した場合でも，エラーが
     あったとして処理します．これは，推奨されない注意のような，強制的な警告を
     生成するヘッダを避けるときに役に立ちます．

以下のマクロは，Cコンパイラやマシンアーキテクチャの特徴を調査します．こ
こでリストアップされない特徴を調査するために，`AC_COMPILE_IFELSE'
(*note Running the Compiler::)や`AC_RUN_IFELSE' (*note Run Time::)
を使用してください．

 -- Macro: AC_C_BACKSLASH_A
     Cコンパイラが`\a'を理解する場合，`HAVE_C_BACKSLASH_A'を1に定義
     します．

 -- Macro: AC_C_BIGENDIAN ([ACTION-IF-TRUE], [ACTION-IF-FALSE],
          [ACTION-IF-UNKNOWN])
     (MotorolaとSPARCのCPUのように)wordが最上位バイトに最初に保存される場合，
     ACTION-IF-TRUEを実行します．(IntelとVAXのCPUのように)wordが最下位
     バイトに最初に保存される場合，ACTION-IF-FALSEを実行します．

     システムヘッダファイルからエンディアンを決定不可能な場合，このマクロはテ
     ストケースを実行します．クロスコンパイル時に，テストケースは実行されませ
     んが，いくつかのマジック変数を検索します．後者の状況でホストシステムのバ
     イト特性の決定に失敗した場合，ACTION-IF-UNKNOWNが実行されます．

     ACTION-IF-TRUEのデフォルトは`WORDS_BIGENDIAN'を定義することで
     す．ACTION-IF-FALSEのデフォルトは何もしないことです．そして最後に，
     ACTION-IF-UNKNOWNのデフォルトは，コンフィグレーションを中断し，イ
     ンストールしている人に，このテストをバイパスさせるために変数を前もって定
     義するよう伝えます．

 -- Macro: AC_C_CONST
     CコンパイラがANSI Cの修飾子`const'を完全にサポートしない 場合，
     `const'を空で定義します．`__STDC__'を定義しないCコンパ
     イラには，`const'をサポートするものもあります．`__STDC__'を定
     義するCコンパイラには，`const'を完全にサポートしないものもあります．
     全てのCコンパイラが`const'をサポートするかのように，プログラムはそ
     れを使用することができます．サポートしないもののために`Makefile'や
     コンフィグレーションヘッダファイルは，それを空で定義します．

     Cコンパイラが無いために，インストールしている人がCコードをコンパイルする
     ためにC++コンパイラを使用することもあります．CとC++は`const'を異な
     る方法で処理するので，これは`const'の問題が生じます．例えば，以下の
     ようにします．

          const int foo;

     Cでは有効ですがC++ではそうではありません．残念ながら，これらの違いを
     `const'を空で定義することで誤魔化すことは不可能です．

     `autoconf'がこの状況を検出した場合，一般的に実際問題としてより良
     い結果になるので，それは`const'のままにしておきます．しかし，C コー
     ドコンパイルするためにC++コンパイラを使用することは推奨されていませんし，
     サポートもしていません．そして，この状況で問題が生じたインストール者は，
     CコードをコンパイルするためにGCCのようなCコンパイラを入手すべきです．

 -- Macro: AC_C_RESTRICT
     Cコンパイラが`restrict'キーワードを認識する場合は何もしません．
     (`__restrict'，`__restrict__'，または`_Restrict')という，
     かわったつづりだけを認識する場合，`restrict'をそれに定義します．そ
     れ以外では，`restrict'を空で定義します．このため，プログラムでは
     `restrict'をすべてのCコンパイラがサポートしているかのように，単純に
     使用してかまいません．そうしない人は，`Makefile'やコンフィグレーショ
     ンヘッダで頑張って定義して下さい．

     C++での`restrict'キーワードサポートは要求されていませんが，いくつか
     のC++コンパイラはそのキーワードを受け入れます．このマクロは，そこでも動
     作します．

 -- Macro: AC_C_VOLATILE
     Cコンパイラがキーワード`volatile'を理解しない場合，`volatile'
     を空で定義します．プログラムでは`volatile'をサポートしているコンパ
     イラのように単純に使用することが可能です．サポートしないものに対しては，
     `Makefile'やコンフィグレーションヘッダで，それを空として定義されま
     す．

     プログラムの正当性が`volatile'の意味に依存している場合，単純に空で
     定義するとある意味ではコードが壊れます．しかし，`volatile'をサポー
     トしていないコンパイラでは，自分で何とかしてください．少なくともプログラ
     ムはコンパイルされますが，多分駄目でしょう．

     一般的に，`volatile'キーワードはANSI Cの機能なので，
     `__STDC__'が定義されているときだけ，`volatile'が利用可能だと期
     待するかもしれません．しかし，Ultrix 4.3のネイティブコンパイラは
     `volatile'をサポートとしていますが，`__STDC__'を定義しません．

 -- Macro: AC_C_INLINE
     Cコンパイラがキーワード`inline'をサポートする場合，何もしません．そ
     れ以外では，受け入れられるものによって，`inline'を`__inline__'
     や`__inline'に定義し，それ以外では`inline' を空で定義します．

 -- Macro: AC_C_CHAR_UNSIGNED
     Cの型`char'がunsignedの場合，Cコンパイラが前もって定義していない限
     り，`__CHAR_UNSIGNED__'を定義します．

 -- Macro: AC_C_LONG_DOUBLE
     Cコンパイラが，`double'の型以上の範囲で動作する`long double'
     の型をサポートしている場合，`HAVE_LONG_DOUBLE'を定義します．

 -- Macro: AC_C_STRINGIZE
     Cプリプロセッサが文字列作成オペレータをサポートする場合，
     `HAVE_STRINGIZE'を定義します．文字列作成オペレータは`#'と，以
     下のようなマクロで見つかります．

          #define x(y) #y

 -- Macro: AC_C_PROTOTYPES
     関数のプロトタイプをコンパイラが理解する場合(`AC_PROG_CC'で決定され
     ます)，`PROTOTYPES'と`__PROTOTYPES'を定義します．コンパイラが
     プロトタイプを処理しない場合，関数定義のプロトタイプを止めるために，
     Automake配布物でインストールされる`ansi2knr'を使用すべきです．関数
     のプロトタイプに対して，最初に`PARAMS'を定義すべきです．

          #ifndef PARAMS
          # if PROTOTYPES
          #  define PARAMS(protos) protos
          # else /* no PROTOTYPES */
          #  define PARAMS(protos) ()
          # endif /* no PROTOTYPES */
          #endif

     そして，以下のように使用してください．

          size_t my_strlen PARAMS ((const char *));

   このマクロは，`__PROTOTYPES'も定義します．これは，ユーザの名前空間
を侵害するマクロが使用不可能なヘッダファイルの利便性ためです．

 -- Macro: AC_PROG_GCC_TRADITIONAL
     使用しているGNU Cコンパイラと`ioctl'が，
     `-traditional'無しでは正確に動作しない場合，出力変数`CC'に
     `-traditional'を加えます．それは通常，修正されたヘッダファイルが古
     いシステムにインストールされていないときに発生します．GNU Cコ
     ンパイラの最近のバージョンは，インストール時に，自動的にヘッダファイルを
     修正するので，これはほとんど問題になりません．


File: autoconf-ja.info,  Node: C++ Compiler,  Next: Fortran Compiler,  Prev: C Compiler,  Up: Compilers and Preprocessors

5.10.4 C++コンパイラの特徴
--------------------------

 -- Macro: AC_PROG_CXX ([COMPILER-SEARCH-LIST])
     使用するC++コンパイラを定義します．環境変数`CXX'や`CCC'が設定
     されているかどうか(この順番で)調査します．その場合，出力変数をその値に設
     定します．

     それ以外でマクロが引数無しで呼び出されている場合，以下のような名前のC++
     コンパイラを探します(最初が`g++'と`c++'その後でそれ以外の名前
     です)．これらの調査がすべて失敗した場合，最後の手段で`CXX' を
     `g++'に設定します．

     しかし，このマクロはオプション引数を用いて呼び出すことが可能で，指定する
     場合は，検索するC++コンパイラをスペースで区切ったリストにする必要があり
     ます．これで，ユーザがC++コンパイラに対する代わりの検索リストを指定する
     機会が与えられます．例えば，デフォルトの順序がいやな場合は，以下のように
     して`AC_PROG_CXX'を呼び出すことが可能です．

          AC_PROG_CXX(cl KCC CC cxx cc++ xlC aCC c++ g++ egcs gcc)

     GNU C++コンパイラを使用している場合，シェル変数`GXX'を
     `yes'に設定します．出力変数`CXXFLAGS'がまだ設定されていない
     場合，GNU C++コンパイラに対しては`-g -O2'(`-g'を
     受け入れないG++のシステムでは`-O2')を設定し，他のコンパイラでは
     `-g'を設定します．

 -- Macro: AC_PROG_CXXCPP
     出力変数`CXXCPP'を，C++プリプロセッサを実行するコマンドに設定します．
     `$CXX -E'が動作しない場合，`/lib/cpp'を使用します．`.c'，
     `.C'，または`.cc'の拡張子を持つファイルで`CXXCPP'を実行す
     るのは移植性のためだけです．

     プリプロセッサによっては，足りないインクルードファイルをエラーステータス
     で示さないものもあります．そのようなプリプロセッサに対して，内部変数は，
     プリプロセッサからの標準エラー出力を調査する他のマクロに設定され，警告が
     報告されない場合はテストに失敗したと考えます．しかし，C++に対してそのよ
     うな壊れ方をしているプリプロセッサがあるかどうかは知りません．


File: autoconf-ja.info,  Node: Fortran Compiler,  Prev: C++ Compiler,  Up: Compilers and Preprocessors

5.10.5 Fortranコンパイラの特徴
------------------------------

AutoconfのFortranサポートは，二つのカテゴリに分けられました．これまでの
Fortran 77マクロ(`F77')と，現在のFortramマクロ(`FC')です．前者
は伝統的なFortram 77コードを想定していて，`F77'，`FFLAGS'，そ
して`FLIBS'といった出力変数があります．後者は，より新しいFortranの
標準の元でコンパイル可能(または必須)である，より新しいプログラムを想定し
ていて，`FC'，`FCFLAGS'，そして`FCLIBS'といった出力変数が あります．

   二つの新しいマクロ`AC_FC_SRCEXT'と`AC_FC_FREEFORM'(以下を参照)
以外では，`FC'と`F77'のマクロの動作はほとんど同じなので，この
セクションでまとめて説明しています．

 -- Macro: AC_PROG_F77 ([COMPILER-SEARCH-LIST])
     使用するFortran 77コンパイラを決定します．`F77'が環境変数でまだ設定
     されていない場合，`g77'，`f77'，そしてその他の名前を調査します．
     見つかったコンパイラ名を，出力変数`F77'に設定します．

     しかし，このマクロはオプション引数を用いて呼び出すことが可能で，指定する
     場合は，検索するFortran
     77コンパイラをスペースで区切ったリストにする必要
     があります．これで，ユーザがFortran
     77コンパイラに対する代わりの検索リス
     トを指定する機会が与えられます．例えば，デフォルトの順序がいやな場合は，
     以下のようにして`AC_PROG_F77'を呼び出すことが可能です．

          AC_PROG_F77(fl32 f77 fort77 xlf g77 f90 xlf90)

     `g77'(GNU Fortran 77コンパイラ)を使用している場合，
     `AC_PROG_F77'はシェル変数`G77'を`yes'に設定します．出力変
     数`FFLAGS'が環境変数で設定されていない場合，`g77'に対して `-g
     -O2'(`-g'を受け入れない`g77'では`-O2')を設定し， 他のFortran
     77コンパイラでは`-g'を設定します．

 -- Macro: AC_PROG_FC ([COMPILER-SEARCH-LIST], [DIALECT])
     使用するFortranコンパイラを決定します．`FC'が環境変数でまだ設定され
     ていない場合，`dialect'が検索しているFortran dialect何かを示すヒン
     トになります．デフォルトとして，利用可能なdialectの最も新しいものを検索
     します．見つかったコンパイラ名を出力変数`FC'に設定します．

     デフォルトで，より新しいdialectがより古いdialectに代わって選択されますが，
     `dialect'が指定されている場合，指定されているdialectで始まる，より
     古いdialectが選択されます．`dialect'は，現在Fortran 77，Fortran
     90， またはFortran
     95が可能です．しかし，これは選択されるコンパイラの_名
     前_のヒント(例えば，`f90'または`f95')になるだけで，特定の言語
     の標準を実際にサポートしていることへの保証は試みません．このため，
     `dialect'オプションを避け，`AC_PROG_FC'だけを最も新しいFortran
     標準に互換性のあるコード対して使用した方が良いでしょう．

     また，このマクロは，最初のオプション引数を指定して呼び出される場合，それ
     は，`AC_PROG_F77'と同様に，検索するFortranコンパイラをスペースで分
     離したリストにする必要があります．

     出力変数`FCFLAGS'が環境変数で設定されていない場合，GNU `g77'に
     対してはそれを`-g -02'に(または，`g77'が`-g'を受け入
     れないところでは`-O2'に)設定します．それ以外では，すべてのFortran
     コンパイラに対し，`FCFLAGS'を`-g'に設定します．

 -- Macro: AC_PROG_F77_C_O
 -- Macro: AC_PROG_FC_C_O
     Fortranコンパイラが，オプション`-c'と`-o'を同時にを受け入れる
     かどうかテストし，そうでない場合は，それぞれ
     `F77_NO_MINUS_C_MINUS_O'または`FC_NO_MINUS_C_MINUS_O'を定義し
     ます．

以下のマクロは，Fortranコンパイラの特徴を調査します．ここでリストアップ
されていない特徴を調査するために，現在の言語(*note Language Choice::)が
Fortran 77またはFortranに設定されていることを`AC_LANG(Fortran 77)'
や`AC_LANG(Fortran)'で最初に確認し，`AC_COMPILE_IFELSE' (*note Running
the Compiler::)や`AC_RUN_IFELSE' (*note Run Time::) を使用してください．

 -- Macro: AC_F77_LIBRARY_LDFLAGS
 -- Macro: AC_FC_LIBRARY_LDFLAGS
     Fortranプログラムや共有ライブラリをうまくリンクするために必要な
     "Fortranのイントリンシックとランタイムライブラリ(Fortran intrinsic
     and run-time libraries)"に対して，リンカフラグ(例えば`-L' と
     `-l')を決定します．出力変数 `FLIBS'や`FCLIBS'には，これら
     のフラグが設定されます(それらはリンク時に`LIBS'の後に含めるべきです)．

     このマクロは，単一のプログラムや共有ライブラリに，例えば，C++とFortranの
     ソースコードを混在させる必要があるとき利用されます(*note Mixing
     Fortran 77 With C and C++: (automake)Mixing Fortran 77 With C and
     C++.)．

     例えば，C++とFortranコンパイラで生成されるオブジェクトファイルを，お互い
     にリンクする必要があるとき，リンクにはC++コンパイラ/リンカが使用されるは
     ずです(C++特有のものは，リンク時にグローバルコンストラクタ，インスタンス
     テンプレート，例外処理等を呼び出す必要が生じるためです)．

     しかし，Fortranのイントリンシックとランタイムライブラリもリンクする必要
     がありますが，C++コンパイラ/リンカは，これらのFortranライブラリを追加す
     る方法をデフォルトでは知っていません．そのため，これらのFortranライブラ
     リを決定するマクロが作成されました．

     マクロ`AC_F77_DUMMY_MAIN'/`AC_FC_DUMMY_MAIN'や
     `AC_F77_MAIN'/`AC_FC_MAIN'は，FortranでC/C++にリンクする必要が
     あるときもおそらく必要です．以下を参照してください．

 -- Macro: AC_F77_DUMMY_MAIN ([ACTION-IF-FOUND],
          [ACTION-IF-NOT-FOUND])
 -- Macro: AC_FC_DUMMY_MAIN ([ACTION-IF-FOUND],
          [ACTION-IF-NOT-FOUND])
     多くのコンパイラでは，`AC_F77_LIBRARY_LDFLAGS'や
     `AC_FC_LIBRARY_LDFLAGS'で見つかるFortranライブラリは，Fortran I/Oの
     ようなものを初期化したり，ユーザプログラムを実行するために，(いわゆる)
     `MAIN__'のような名前を持つユーザ提供のエントリー関数を呼び出す，独
     自の`main'エントリー関数を提供しています．
     `AC_F77_DUMMY_MAIN'/`AC_FC_DUMMY_MAIN'や
     `AC_F77_MAIN'/`AC_FC_MAIN'マクロは，この相互作用を扱う方法を理
     解します．

     (I/Oなどではない)純粋な数値関数のためにFortranを使用しているとき，独自の
     `main'を提供し，Fortranライブラリの初期化を停止したいこともよくあり
     ます．しかしこの場合は，いくつかのシステムでのリンクエラーを避けるため，
     ダミーの`MAIN__'ルーチンを提供する必要があるかもしれません．
     `AC_F77_DUMMY_MAIN'や`AC_FC_DUMMY_MAIN'は，そのようなルーチン
     がリンク時に_要求されている_かどうか，そしてその名前が何かを検出し
     ます．シェル変数`F77_DUMMY_MAIN'や`F77_DUMMY_MAIN'は，解決方法
     が見つからないときは`unknown'，そのようなダミーの`main'が不要
     なときは`none'という値を保持します．

     デフォルトで，必要な_場合_は，ACTION-IF-FOUNDは
     `F77_DUMMY_MAIN'や`FC_DUMMY_MAIN'をこのルーチン名(例えば
     `MAIN__')に定義します．[ACTION-IF-NOT-FOUND]はデフォルトでエラー
     で終了します．

     Fortranとリンクするために，必要な場合はダミーの`main'を定義するため
     に，userのC/C++プログラムで以下のようなコードをインクルードすべきです．

          #ifdef F77_DUMMY_MAIN
          #  ifdef __cplusplus
               extern "C"
          #  endif
             int F77_DUMMY_MAIN() { return 1; }
          #endif

     (Fortran 77ではなくFortranに対しては，`F77'を`FC'で置換して下
     さい．)

     このマクロはは`AC_F77_WRAPPERS'や`AC_FC_WRAPPERS'から自動的に
     呼び出されることに注意してください．一般的にデフォルトの動作を変更したく
     ない限り，明示的にに呼び出す必要はありません．

 -- Macro: AC_F77_MAIN
 -- Macro: AC_FC_MAIN
     上で議論したように，Fortranライブラリには，通常の`main'の代わりに，
     (いわゆる)`MAIN__'と呼ばれるエントリーポイントを提供することが可能
     なものも多く，それは，Fortran
     I/Oのようなものを初期化するために，Fortran
     ライブラリの`main'関数で呼び出されます．
     `AC_F77_MAIN'/`AC_FC_MAIN'マクロは，そのような代理の
     `main'関数の利用が_可能か_どうかを検出し，
     `F77_MAIN'/`AC_FC_MAIN'を関数の名前に定義します．(代理の
     `main'関数の名前が見つからない場合，
     `F77_MAIN'/`AC_FC_MAIN'は単純に`main'に定義します．)

     このため，Fortranルーチンが，I/Oのようなものを実行するためにCから呼び出
     されるとき，このマクロを使用し，"main"関数を`main'ではなく
     `F77_MAIN'/`FC_MAIN'の名前にすべきです．

 -- Macro: AC_F77_WRAPPERS
 -- Macro: AC_FC_WRAPPERS
     名前がmangleされる方法をFortranコンパイラで使用されているものに一致させ
     るため，mangleされているC/C++の識別子とアンダースコアが付いた識別子の名
     前が正しくなるように，Cマクロの
     `F77_FUNC(name,NAME)'/`FC_FUNC(name,NAME)'と
     `F77_FUNC_(name,NAME)'/`FC_FUNC_(name,NAME)'をそれぞれ定義しま す．

     Fortranは大文字小文字の区別が無く，このために，Fortranコンパイラは全ての
     識別子を標準的な文字と書式に変換します．CからFortranのサブルーチンを呼び
     出したり，Fortranから呼び出し可能なC関数を書いたりするために，Cプログラ
     ムではFortranコンパイラが期待する書式で，識別子を明示的に使用する必要が
     あります．こうするために，全てのC識別子を`AC_F77_WRAPPERS'や
     `AC_FC_WRAPPERS'で提供されるマクロの一つで，単純にラッパー関数にし
     ます．例えば，以下のようなFortranのサブルーチンがあるとします．

                subroutine foobar(x,y)
                double precision x, y
                y = 3.14159 * x
                return
                end

     CやC++のプロトタイプで，以下のように宣言します．

          #define FOOBAR_F77 F77_FUNC(foobar,FOOBAR)
          #ifdef __cplusplus
          extern "C"  /* prevent C++ name mangling */
          #endif
          void FOOBAR_F77(double *x, double *y);

     正しいものが選択できるように，関数名の大文字と小文字の両方のバージョンを
     `F77_FUNC'に渡していることに注意してください．また，Fortran 77
     のルー
     チンへの全てのパラメータを，ポインタとして渡していることにも注意してくだ
     さい(*note Mixing Fortran 77 With C and C++: (automake)Mixing
     Fortran 77 With C and C++.)．

     (Fortran 77の代わりに，Fortranに対しては`F77'は`FC'で置換して
     下さい．)

     AutoconfはFortranコンパイラが名前をmangleする手法を検出するために知的な
     手法で試みていますが，Fortranコンパイラはそれをまだサポートしていないか
     もしれません．この場合，上記のコードはコンパイル時にエラーとなりますが，
     それ以外の動作(例えば，Fortranに関連する機能の停止)は，
     `F77_FUNC'/`FC_FUNC'マクロが定義されているかどうかを調査するこ
     とで引き起こされます．

     さて，そのようなルーチンをCプログラムから呼び出すために，以下のようにし
     てみます．

          {
              double x = 2.7183, y;
              FOOBAR_F77(&x, &y);
          }

     Fortran 77の識別子がアンダースコアを含んでいる(例えば`foo_bar'の)
     場合，`F77_FUNC'/`FC_FUNC'の代わりに
     `F77_FUNC_'/`FC_FUNC_'を(同じ引数で)使用すべきです．これは，ア
     ンダースコアを含んでいる場合，Fortranコンパイラによっては異なる名前に
     mangleするものもあるからです．

 -- Macro: AC_F77_FUNC (NAME, [SHELLVAR])
 -- Macro: AC_FC_FUNC (NAME, [SHELLVAR])
     識別子NAMEが与えられている場合，シェル変数SHELLVARをFortran
     リンカの規則(`AC_F77_WRAPPERS'や`AC_FC_WRAPPERS'も参照してくだ
     さい)によって，mangleされるバージョンのNAMEを保持するように設定し
     ます．SHELLVARはオプションです．提供されていない場合，シェル変数は
     単純にNAMEになります．このマクロの目的は，上記のようにCプリプロセッ
     サを通じてではなく，呼び出し側に名前のmangleに関する情報にアクセスする方
     法を与えることで，例えば，C/C++以外の言語からFortranルーチンを呼び出すた
     めです．

 -- Macro: AC_FC_SRCEXT (EXT, [ACTION-IF-SUCCESS],
          [ACTION-IF-FAILURE])
     デフォルトで，`FC'マクロは，ソースコードファイルを`.f'の拡張子
     を使用しているテストを実行します．しかし，コンパイラによっては，適切なファ
     イル名に対してのみ，より新しい言語の機能を利用可能にし，例えば，Fortran
     90の機能は`.f90'ファイルだけになります．一方，すべてのソースファイ
     ルが`.f'で終わることを期待していて，他のファイル名の拡張子をサポー
     トするためには特殊なフラグが必要になります．`AC_FC_SRCEXT'マクロは
     両方の問題を扱います．

     `AC_FC_SRCEXT'は，拡張子EXT(すなわち，EXTにはドットは含
     まれ_ません_)で終わるファイルを受け入れる`FC'コンパイラの取得
     を試みます．こうするために特定のコンパイラフラグが必要な場合，それを出力
     変数`FCFLAGS_'EXTに保存します．この拡張子とこのフラグは
     (`AC_FC_SRCEXT'が再び呼び出されるまで)，それ以降に呼び出されるすべ
     ての`FC'で使用されます．

     例えば，機能テストで`.f90'の拡張子を用いるため，
     `AC_FC_SRCEXT(f90)'を使用し，そのようなファイルをコンパイルするため
     に必要な追加フラグがあれば，`FCFLAGS_f90'出力変数を設定します．

     `FCFLAGS_'EXTを単純に`FCFLAGS'に書き込むことは_不可
     能_で，それにはコンパイラの制限に起因する二つの理由があります．最初のも
     のは，一度に一つの`FCFLAGS_'EXTが使用可能なので，ことなる拡張
     子を持つファイルは別々にコンパイルする必要があるためです．二番目のものは，
     `FCFLAGS_'EXTはコンパイル時のソースコードのファイル名の
     _直前_に書く必要があるためです．そのため，上記の例を続けると，以下
     のコマンドを持つMakefileで`foo.f90'ファイルがコンパイルされるでしょ
     う．

          foo.o: foo.f90
               $(FC) -c $(FCFLAGS) $(FCFLAGS_f90) foo.f90

     EXTの拡張子を持つファイルのコンパイルで`AC_FC_SRCEXT'が成功す
     る場合，それは[ACTION-IF-SUCCESS](デフォルトでは何もしません)を呼び
     出します．失敗した場合と，`FC'コンパイラにそのようなファイルを受け
     入れさせる方法が見つからない場合，[ACTION-IF-FAILURE](デフォルトは
     エラーメッセージとともに終了します)を呼び出します．


 -- Macro: AC_FC_FREEFORM ([ACTION-IF-SUCCESS], [ACTION-IF-FAILURE])
     `AC_FC_FREEFORM'は，Fortranコンパイラ(`$FC')でフリーフォーマッ
     トのソースコードが可能であることの確認を試みます(逆に，Fortran
     77はより
     古い固定フォーマット形式です)．必要な場合，`FCFLAGS'に追加フラグを
     加えてもかまいません．

     デフォルトの`.f'拡張子を使用している場合，追加のフラグが提供されて
     いない限り，多くのコンパイラがこの拡張子を固定フォーマットのソースコード
     であると解釈するので，このマクロが最も重要です．`.f90'や`.f95'
     のように，異なる拡張子を`AC_FC_SRCEXT'で指定している場合，
     `AC_FC_FREEFORM'は，通常，`FCFLAGS'を編集することなく成功しま す．

     `AC_FC_FREEFORM'はフリーフォームのソースのコンパイルで成功する場合，
     それは[ACTION-IF-SUCCESS](デフォルトでは何もしません)を呼び出します．
     失敗した場合，[ACTION-IF-FAILURE](デフォルトはエラーメッセージとと
     もに終了します)を呼び出します．


File: autoconf-ja.info,  Node: System Services,  Next: UNIX Variants,  Prev: Compilers and Preprocessors,  Up: Existing Tests

5.11 システムサービス
=====================

以下のマクロはオペレーティングシステムのサービスや機能を調査します．

 -- Macro: AC_PATH_X
     X Window
     Systemのインクルードファイルとライブラリの場所を調査します．ユー
     ザがコマンドラインオプションで，`--x-includes=DIR'と
     `--x-libraries=DIR'を与えている場合，そのディレクトリを使用し
     ます．どちらか一つまたは両方とも与えられない場合，`xmkmf'を平凡な
     `Imakefile'で実行し，生成された`Makefile'を調査し，足りない値
     を取得します．(`xmkmf'が存在しない等のように)失敗した場合，配置され
     ることが多いディレクトリ等でファイルを検索します．いずれかの手法で成功し
     た場合，コンパイラがデフォルトで検索するディレクトリに無い限り，シェル変
     数`x_includes'と`x_libraries'をその場所に設定します．

     両方の方法が失敗する，またはユーザがコマンドラインオプションの
     `--without-x'を与えている場合，シェル変数の`no_x'を`yes'
     に設定し，それ以外では空の文字列に設定します．

 -- Macro: AC_PATH_XTRA
     `AC_PATH_X'の拡張バージョンです．Xが必要とするCコンパイラフラグを出
     力変数`X_CFLAGS'に，Xリンカフラグを`X_LIBS'に追加します．X が
     利用可能でない場合，`X_DISPLAY_MISSING'を定義します．

     また，このマクロは，Xプログラムをコンパイルするためにシステムが必要とす
     る特別なライブラリも調査します．それは，システムが必要とするあらゆるもの
     を出力変数`X_EXTRA_LIBS'に追加します．そして，`-lX11'の前にリ
     ンクする必要がある特別なX11R6ライブラリを調査し，見つかったものは全て出
     力変数`X_PRE_LIBS'に追加します．


 -- Macro: AC_SYS_INTERPRETER
     スクリプトを使用するためのインタプリタを選択するため，`#!
     /bin/csh'の形式の行を用いたスクリプトをサポートするかどうかを調査します．
     このマクロを実行した後で，`configure.ac'のシェルコードは，シェル変
     数の `interpval'を調査することが可能になります．システムで`#!'
     がサポートされている場合は`yes'，そうでなければ`no' を設定しま す．

 -- Macro: AC_SYS_LARGEFILE
     large-file
     support(1)のために用意しています．ホストによっては，大きなファ
     イルにアクセスできるプログラムをビルドするため，特別なコンパイラオプショ
     ンが必要になります．そのようなオプションを出力変数`CC'に，全て追加
     します．必要な場合は，`_FILE_OFFSET_BITS'と`_LARGE_FILES' を定
     義します．

     大きなファイルのサポートは，`--disable-largefile'オプションを用い
     てコンフィグレーションすることで利用不可能にすることが可能です．

     このマクロを使用する場合，大きなファイルのサポートが利用可能なときは，
     `off_t'が`long'より長いときが一般的なので，それでもプログラム
     が動作するかどうかを調査してください．例えば，`printf ("%ld",
     (long) X)'で任意の`off_t'の値`X'を出力しても正しくなくなります．

     LFSは`fseeko'と`ftello'関数を，Cの`off_t'を使用していない
     `fseek'と`ftell'に相当するものを置き換えるために導入しました．
     それらの関数を使用しているときで，大きなファイルのサポートが利用可能になっ
     ているときに，利用可能なプロトタイプを作成するために
     `AC_FUNC_FSEEKO'を注意して使用して下さい．

 -- Macro: AC_SYS_LONG_FILE_NAMES
     システムが14文字より長いファイル名をサポートする場合，
     `HAVE_LONG_FILE_NAMES'を定義します．

 -- Macro: AC_SYS_POSIX_TERMIOS
     POSIX termiosヘッダと関数がシステムで利用可能かどうかを調査し
     ます．その場合は，シェル変数`ac_cv_sys_posix_termios'を`yes'に
     設定します．それ以外ではその変数を`no'に設定します．

   ---------- Footnotes ----------

   (1) large-file support,
`http://www.unix-systems.org/version2/whatsnew/lfs20mar.html'.


File: autoconf-ja.info,  Node: UNIX Variants,  Prev: System Services,  Up: Existing Tests

5.12 様々なUNIX
===============

以下のマクロは，ヘッダファイルやライブラリが例外的に特異なため，プログラ
ムに対して特別な処理が必要なオペレーティングシステムを調査します．これら
のマクロは不要なものです．利用可能にする関数や，供給する環境に基づき，よ
り規則正しい手法で置換されるでしょう．

 -- Macro: AC_AIX
     AIXの場合，`_ALL_SOURCE'を定義します．いくつかの
     BSD関数の使用を許可します．Cコンパイラを実行するあらゆるマクロ
     の前に呼び出すべきです．

 -- Macro: AC_GNU_SOURCE
     GNU Cライブラリを使用している場合，`_GNU_SOURCE'を定義し
     ます．いくつかのGNUの関数が使用可能になります．Cコンパイラを実
     行するマクロの前で呼び出すべきです．

 -- Macro: AC_ISC_POSIX
     INTERACTIVE UNIX (ISC)に対して，POSIXの機能が必
     要な場合，出力変数`LIBS'に`-lcposix'を追加します．これは
     `AC_PROG_CC'の後で，POSIXインターフェースを使用するその他
     のマクロの前で呼び出してください．INTERACTIVE UNIXはすでに販売され
     ておらず，Sunは2006-07-23でサポートを終了することを告げているので，この
     マクロは時代遅れになっています．

 -- Macro: AC_MINIX
     Minixの場合，`_MINIX'と`_POSIX_SOURCE'を定義し，
     `_POSIX_1_SOURCE'を2と定義します．これでPOSIXの機能が使用
     可能になります．Cコンパイラを実行するあらゆるマクロの前で呼び出すべきで
     す．


File: autoconf-ja.info,  Node: Writing Tests,  Next: Results,  Prev: Existing Tests,  Up: Top

6 テストを書く
**************

既存の特徴テストでは必要なことができない場合，新しいものを書く必要があり
ます．これらのマクロはブロックの組み立てです．他のマクロで様々な特徴が利
用可能かどうか調査し結果を報告するための方法を提供します．

この章には，提案と，既存のテストが書かれている方法の理由も含まれています．
また，既存のものを見ることで，Autoconfテストの書き方について知ることが可
能です．Autoconfのテストの一つ以上がうまくいかない場合，この情報は背後で
行われていることの理解を助けるので，最善の問題解決法が分かるでしょう．

   以下のマクロは，現在の言語のコンパイラシステムの出力を調査します
(*note Language Choice::)．それらは，キャッシュ変数名を生成するために調
査している情報を十分には知らないので，将来使用するためにテスト結果をキャッ
シュしません(*note Caching Results::)．同じ理由でメッセージも出力しませ
ん．特定の種類の機能の調査では，これらのマクロを呼び出し，結果をキャッシュ
し，そして調査していることに関するメッセージを出力します．

一つ以上のソフトウェアパッケージに適用可能な特徴テストを書いているとき，
新しいマクロに要約することがベストです．その方法は，*Note Writing
Autoconf Macros::.

* Menu:

* Language Choice::             Selecting which language to use for testing
* Writing Test Programs::       Forging source files for compilers
* Running the Preprocessor::    Detecting preprocessor symbols
* Running the Compiler::        Detecting language or header features
* Running the Linker::          Detecting library features
* Run Time::                    Testing for run-time features
* Systemology::                 A zoology of operating systems
* Multiple Cases::              Tests for several possible values


File: autoconf-ja.info,  Node: Language Choice,  Next: Writing Test Programs,  Up: Writing Tests

6.1 言語の選択
==============

Autoconfが生成した`configure'スクリプトは，Cコンパイラとその特徴
をデフォルトで調査します．他のプログラム言語を使用するパッケージ(一つ以
上で，例えば，CとC++)は，それぞれの言語のコンパイラの特徴をテストする必
要があります．以下のマクロは`configure.ac'内のそれ以降のテストで使
用されるプログラミング言語のコンパイラを決定します．

 -- Macro: AC_LANG (LANGUAGE)
     LANGUAGEで指定されている，コンパイラ，プリプロセッサ，そしてファイ
     ル拡張子をコンパイルテストで使用します．

     サポートされている言語は以下のとおりです．

    `C'
          `CC'と`CPP'を使用してコンパイルテストを行ない，テストプログラ
          ムでは`.c'の拡張子を使用します．コンパイルフラグを使用します．
          `CPP'では`CPPFLAGS'，`CC'では`CPPFLAGS'と
          `CFLAGS'の両方を使用します．

    `C++'
          `CXX'と`CXXCPP'を使用してコンパイルテストを行ない，テストプロ
          グラムでは`.C'の拡張子を使用します．コンパイルフラグを使用します．
          `CXXPP'では`CPPFLAGS'，`CXX'では`CPPFLAGS'と
          `CXXFLAGS'の両方を使用します．

    `Fortran 77'
          `F77'を使用してコンパイルテストを行ない，テストプログラムでは
          `.f'の拡張子を使用します．コンパイルフラグを使用します．
          `FFLAGS'です．

    `Fortran'
          `FC'を使用してコンパイルテストを行ない，テストプログラムでは
          `.f'の拡張子(または`AC_FC_SRCEXT'で設定されているもの)を使用し
          ます．コンパイルフラグを使用します．`FCFLAGS'です．

 -- Macro: AC_LANG_PUSH (LANGUAGE)
     現在の言語を(`AC_LANG'に設定するように)スタックに記録してから，
     LANGUAGEを選択します．このマクロと`AC_LANG_POP'を，一時的に特
     定の言語に切替える必要があるマクロで使用してください．

 -- Macro: AC_LANG_POP ([LANGUAGE])
     `AC_LANG_PUSH'で設定するように，スタックのトップに保存されている言
     語に選択し，スタックからそれを削除します．

     LANGUAGE与えられている場合，それは言語を_そのまま_指定します．
     分かっているときは，Autoconfが間違いを検出するので(case...にすべきで
     すが)，それを指定することは良い考えです．

          AC_LANG_PUSH(Fortran 77)
          # Perform some tests on Fortran 77.
          # ...
          AC_LANG_POP(Fortran 77)

 -- Macro: AC_LANG_ASSERT (LANGUAGE)
     現在の言語がLANGUAGEであることを十分に調査します．言語指定のマクロ
     で不適切な言語での呼び出しを避けるため使用すべきです．

     このマクロは，`autoconf'時のみで実行され，`configure'時
     に時間がかかることはありません．残念ながら，Autoconfは二つのレイヤーの言
     語があるため(1)，マクロの`AC_LANG_PUSH'/`AC_LANG_POP' は"最適化"
     されず，そのため，できるだけコードのラッパーを行なうために
     それらを使用することを避け，代わりに，ユーザがマクロを現在の言語で実行す
     ることを要求し，`AC_LANG_ASSERT'で調査するようにして下さい．いずれ
     にせよ，Fortran
     77コンパイラの結果を期待している，ユーザが実行している
     Fortranマクロを理解する助けとなるでしょう....

 -- Macro: AC_REQUIRE_CPP
     現在のテストに使用されるプリプロセッサが見つかることを保証します．現在の
     言語に依存して，`AC_PROG_CPP'または`AC_PROG_CXXCPP'のいずれか
     の引数を用いて，`AC_REQUIRE'(*note Prerequisite Macros::)を呼び出し
     てください．

   ---------- Footnotes ----------

   (1) M4は特別な条件文となっているShのコードに注目しない
ので，十分に良いと感じられる最適化でも，実行時の結果が間違っているものに
なる可能性があります．


File: autoconf-ja.info,  Node: Writing Test Programs,  Next: Running the Preprocessor,  Prev: Language Choice,  Up: Writing Tests

6.2 テストプログラムを書く
==========================

Autoconfのテストの流れは，共通の手法です．いくつかの入力をいくつかのプロ
グラムに与え，ほとんどの場合，ソースファイルをコンパイラに与えます．この
セクションでは，これらのソースのサンプルを提供します．

* Menu:

* Guidelines::                  General rules for writing test programs
* Test Functions::              Avoiding pitfalls in test programs
* Generating Sources::          Source program boilerplate


File: autoconf-ja.info,  Node: Guidelines,  Next: Test Functions,  Up: Writing Test Programs

6.2.1 テストプログラムのためのガイドライン
------------------------------------------

テストサンプルを書くときに従うべきもっとも重要な規則は以下のとおりです．

                          _現実を見つめる．_

このモットーは，テストサンプルが現実にかかれるプログラムと同じ厳密さで書
く必要があるということです．特に，"ショートカット"と単純にしたものは避
けるべきです．

コンパイルの準備をしたい場合，プリプロセッサだけで実行しないでください．
例えば，ヘッダが機能することを調査するために`cpp'を使用するだけ
では，`configure'が_コンパイラ_のエラーを生じるヘッダを受け
入れるかもしれません．以前にインクルードした他のヘッダ，特に必要とされる
ヘッダを用いたヘッダの調査をためらわないでください．

使用しているシンボルが，適切に定義されている，すなわち適切なヘッダをイン
クルードする代わりに，自分で関数を単純に定義していないことを確かめてくだ
さい．

テストプログラムは，標準出力に何かを書き出すべきではありません．コアダン
プや他の異常終了と簡単に区別できるように，成功した場合は0，それ以外では
ゼロ以外を返すべきです．セグメンテーション違反やその他の異常終了は，終了
ステータスでゼロ以外を生成します．`main'内の`return'の引数を無
視するシステム(少なくとも古いSun)もあるので，テストプログラムの
`main'では`return'ではなく`exit'を使用するべきです．

既に実行されたテストで定義されたプリプロセッサの値を調査するため，テスト
プログラムで`#if'や`#ifdef'を使用することが可能です．例えば，
`AC_HEADER_STDC'を呼び出す場合，`configure.ac'の後の方で，条件 付でANSI
Cヘッダファイルをインクルードするテストプログラムを使用すること
が可能です．

     #if STDC_HEADERS
     # include <stdlib.h>
     #endif

テストプログラムでデータファイルを使用したり，作成したりする必要がある場
合， `conftest.data'のような，`conftest'で始まる名前を与えてく
ださい．`configure'スクリプトは，テストプログラム終了後やスクリ
プトが中断された場合，`rm -rf conftest*'を実行しクリーンアップしま す．


File: autoconf-ja.info,  Node: Test Functions,  Next: Generating Sources,  Prev: Guidelines,  Up: Writing Test Programs

6.2.2 関数のテスト
------------------

テストプログラムでの関数宣言には，C++に対する条件付のプロトタイプを持た
せるべきです．しかし，テストプログラムで引数をとる関数が必要になることは，
実際には滅多にありません．

     #ifdef __cplusplus
     foo (int i)
     #else
     foo (i) int i;
     #endif

   テストプログラムが宣言する関数には，`extern "C"'プロトタイプを要求
するC++に対する条件付けも行なうべきです．壊れたプロトタイプを含んでいる
ヘッダファイルをインクルードしていないことを確かめてください．

     #ifdef __cplusplus
     extern "C" void *malloc (size_t);
     #else
     void *malloc ();
     #endif

テストプログラムが(その存在の確認のためにだけ)無効なパラメータで関数を呼
び出す場合，その関数を決して呼び出さないことを保証するようにプログラムを
構成してください．決して呼び出されないそれ以外の他の関数から関数を呼び出
すことで，こうすることが可能です．GCCバージョン2は，`exit' は値を返
さず，同じブロックにあるそれ以降のコードを最適化で外してしまうことが知ら
れているので，`exit'の呼び出し以降にそれを書き込まないでください．

ヘッダファイルをインクルードする場合は，たとえ引数が0だけであっても，プ
ロトタイプで生じるコンパイルエラーを避けるため，正しい数の引数を適切にし
て関数を呼び出していることを確認してください．GCCのバージョン2は，自動的
にインライン化される関数プロトタイプ，例えば`memcpy'もあります．そ
れらを調査しているときのエラーを避けるため，正しい数の引数を与えるか，
(`char'のような)異なる戻り値で再定義してください．


File: autoconf-ja.info,  Node: Generating Sources,  Prev: Test Functions,  Up: Writing Test Programs

6.2.3 ソースの生成
------------------

Autoconfは，テストソースファイルを生成するために使用することが可能なマク
ロの組みを提供しています．それらは，一般的な言語で書かれていて，すなわち，
それらは実際に現在の言語(*note Language Choice::)に依存して適切な出力
"フォーマット"になっています．

 -- Macro: AC_LANG_CONFTEST (SOURCE)
     現在のテストソースファイルにSOURCEのテキストを保存します．
     `conftest.EXTENSION'のEXTENSIONは現在の言語に依存します．

     通常のAutoconfマクロ引数のように，SOURCEは一度だけ評価され，そのた
     め，(i)マクロ呼び出しに渡してもかまわず，(ii)そうでなければ，必要があれ
     ば二重に引用符で囲む必要があることに注意してください．

 -- Macro: AC_LANG_SOURCE (SOURCE)
     すべての`AC_DEFINE'で実行されるこれまでの定義を用いて，SOURCE
     に展開します．

   例えば，以下を実行します(二重の引用符を守ってください！)．

     AC_INIT(Autoconf Documentation, 2.59, bug-autoconf@gnu.org)
     AC_DEFINE([HELLO_WORLD], ["Hello, World\n"])
     AC_LANG_CONFTEST(
        [AC_LANG_SOURCE([[const char hw[] = "Hello, World\n";]])])
     gcc -E -dD conftest.c -o -

結果は以下のようになります．

     # 1 "conftest.c"
     # 1169 "configure"

     # 1 "confdefs.h" 1

     #define PACKAGE_NAME "Autoconf Documentation"
     #define PACKAGE_TARNAME "autoconf-documentation"
     #define PACKAGE_VERSION "2.59"
     #define PACKAGE_STRING "Autoconf Documentation 2.59"
     #define PACKAGE_BUGREPORT "bug-autoconf@gnu.org"
     #define HELLO_WORLD "Hello, World\n"
     # 1170 "configure" 2

     const char hw[] = "Hello, World\n";

 -- Macro: AC_LANG_PROGRAM (PROLOGUE, BODY)
     PROLOGUEの内容と，BODYをmain関数(例えばCの`main')として
     ソースファイルに展開します．それは`AC_LANG_SOURCE'を使用するので，
     後者の機能は利用可能です．

   例えば以下のようにします．

     AC_INIT(Autoconf Documentation, 2.59, bug-autoconf@gnu.org)
     AC_DEFINE([HELLO_WORLD], ["Hello, World\n"])
     AC_LANG_CONFTEST(
     [AC_LANG_PROGRAM([[const char hw[] = "Hello, World\n";]],
                      [[fputs (hw, stdout);]])])
     gcc -E -dD conftest.c -o -

結果は以下のようになります．

     # 1 "conftest.c"
     # 1169 "configure"

     # 1 "confdefs.h" 1

     #define PACKAGE_NAME "Autoconf Documentation"
     #define PACKAGE_TARNAME "autoconf-documentation"
     #define PACKAGE_VERSION "2.59"
     #define PACKAGE_STRING "Autoconf Documentation 2.59"
     #define PACKAGE_BUGREPORT "bug-autoconf@gnu.org"
     #define HELLO_WORLD "Hello, World\n"
     # 1170 "configure" 2

     const char hw[] = "Hello, World\n";
     int
     main ()
     {
     fputs (hw, stdout);
       ;
       return 0;
     }

 -- Macro: AC_LANG_CALL (PROLOGUE, FUNCTION)
     PROLOGUEの内容と，FUNCTIONの呼び出しをmain関数(例えばCの
     `main')の本体としてソースファイルに展開します．それは
     `AC_LANG_SOURCE'を使用するので，後者の機能は利用可能です．

     この関数は，おそらく将来の引数指定が利用可能なバージョンで置換されます．
     このマクロは特定のシステムをひどく侵害するので，その使用は推奨しません．

 -- Macro: AC_LANG_FUNC_LINK_TRY (FUNCTION)
     main関数(例えばCでは`main')の本体として，偽のFUNCTIONを使用し
     ている内容をソースファイルに展開します．単純な(関数ポインタの)割当です．
     それは`AC_LANG_SOURCE'を使用するので，後者の機能は利用可能です．

     `AC_LANG_CALL'があるので，このマクロは，補完の意味で説明しています．
     ひどく壊れていて，(適切な型の引数を用いた)実際の関数の呼び出しに将来は変
     更しようと考えています．


File: autoconf-ja.info,  Node: Running the Preprocessor,  Next: Running the Compiler,  Prev: Writing Test Programs,  Up: Writing Tests

6.3 プリプロセッサの実行
========================

いくつかのソースファイルでプリプロセッサを実行する必要があるときもありま
す．通常はプロジェクトを_コンパイル_する必要があり，プリプロセッサ
を実行する必要があることは滅多に無いので，_そうすることは，普通は悪
い考えです_．そのため，きっとプリプロセッサではなくコンパイラを実行した
いと思うでしょう．安易な道をたどる誘惑に逆らってください．

   それにもかかわらず，プリプロセッサを実行する必要がある場合，
`AC_PREPROC_IFELSE'を使用してください．

 -- Macro: AC_PREPROC_IFELSE (INPUT, [ACTION-IF-TRUE],
          [ACTION-IF-FALSE])
     INPUTで現在の言語(*note Language
     Choice::)のプリプロセッサを実行し，
     成功したらシェルコマンドACTION-IF-TRUEを実行し，そうでなければ
     ACTION-IF-FALSEを実行します．INPUTは`AC_LANG_PROGRAM'と
     その仲間で作成することが可能です．

     このマクロは`CPPFLAGS'を使用しますが，`-g'，`-O'など
     は多くのCプリプロセッサで有効なオプションではないので，`CFLAGS' は
     使用しません．

     予期せぬ異常終了は，通常`AC_MSG_FAILURE'で報告します．

   例えば以下のようにします．

     AC_INIT(Autoconf Documentation, 2.59, bug-autoconf@gnu.org)
     AC_DEFINE([HELLO_WORLD], ["Hello, World\n"])
     AC_PREPROC_IFELSE(
        [AC_LANG_PROGRAM([[const char hw[] = "Hello, World\n";]],
                         [[fputs (hw, stdout);]])],
        [AC_MSG_RESULT([OK])],
        [AC_MSG_FAILURE([unexpected preprocessor failure])])

結果は以下のようになります．

     checking for gcc... gcc
     checking for C compiler default output... a.out
     checking whether the C compiler works... yes
     checking whether we are cross compiling... no
     checking for suffix of executables...
     checking for suffix of object files... o
     checking whether we are using the GNU C compiler... yes
     checking whether gcc accepts -g... yes
     checking for gcc option to accept ANSI C... none needed
     checking how to run the C preprocessor... gcc -E
     OK


   マクロ`AC_TRY_CPP'(*note Obsolete Macros::)は，
`AC_PREPROC_IFELSE'の役目を果たすために使用されていましたが，その引
数を二重の引用符で囲んでいるので，精巧なソースで使用することが不可能でし
た．マクロ`AC_TRY_CPP'の`AC_PREPROC_IFELSE'をような古い使い方
を取り除くことも推奨しますが，最初にコンパイラではなく_プリプロセッ
サ_を実行する必要があるのかを確かめることを推奨します．

 -- Macro: AC_EGREP_HEADER (PATTERN, HEADER-FILE, ACTION-IF-FOUND,
          [ACTION-IF-NOT-FOUND])
     システムヘッダファイルHEADER-FILEでのプリプロセッサの実行での出力
     が拡張正規表現のPATTERNにマッチする場合，シェルコマンド
     ACTION-IF-FOUNDを実行し，それ以外ではACTION-IF-NOT-FOUNDを実
     行します．

 -- Macro: AC_EGREP_CPP (PATTERN, PROGRAM, [ACTION-IF-FOUND],
          [ACTION-IF-NOT-FOUND])
     PROGRAMがCやC++プログラムのテキストで，そのなかではシェル変数，バッ
     ククオート，そしてバックスラッシュの代入が実行されたものになっています．
     PROGRAMでのプリプロセッサの実行での出力が拡張正規表現の
     PATTERNにマッチする場合，シェルコマンドACTION-IF-FOUNDを実行
     し，それ以外ではACTION-IF-NOT-FOUNDを実行します．


File: autoconf-ja.info,  Node: Running the Compiler,  Next: Running the Linker,  Prev: Running the Preprocessor,  Up: Writing Tests

6.4 コンパイラの実行
====================

特定のキーワードを認識するかどうかといった，現在の言語のコンパイラの構文
の特徴を調査するため，また，単純にいくつかのライブラリの特徴を試すため，
それらの特徴を使用している小さなプログラムのコンパイルを試みる
`AC_COMPILE_IFELSE'を使用してください．

 -- Macro: AC_COMPILE_IFELSE (INPUT, [ACTION-IF-FOUND],
          [ACTION-IF-NOT-FOUND])
     現在の言語(*note Language Choice::)のコンパイラとコンパイラフラグを
     INPUTで実行し，成功したらシェルコマンドACTION-IF-TRUEを，そ
     れ以外ではACTION-IF-FALSEを実行します．INPUTは
     `AC_LANG_PROGRAM'やその仲間で作成することが可能です．

     慣習的に，予期せぬ異常終了は`AC_MSG_FAILURE'で報告します．このマク
     ロはリンクを試みません．そうする必要がある場合，`AC_LINK_IFELSE'を
     使用してください(*note Running the Linker::)．


File: autoconf-ja.info,  Node: Running the Linker,  Next: Run Time,  Prev: Running the Compiler,  Up: Writing Tests

6.5 リンカの実行
================

ライブラリ，関数，またはグローバル変数を調査するため，Autoconfの
`configure'スクリプトは，それを使用している小さなプログラムのコ
ンパイルとリンクを試みます．これはMetaconfigとは異なり，それはデフォルト
で，C ライブラリで関数が利用可能かどうか判定するために`nm'や
`ar'を使用します．オプションと`nm'と`ar'の出力の違いと，
標準ライブラリの位置の違いを処理することを避けるので，関数とのリンクを試
みることは，通常，より信頼性が高い方法になります．クロスコンパイルのコン
フィグレーションや，必要な場合は関数の実行時の動作を調査も可能です．一方，
一度のライブラリスキャンより遅くなるはずですが，正確さは時間より重要です．

   `AC_LINK_IFELSE'は，関数とグローバル変数に対するテストのため，テス
トプログラムをコンパイルするために使用されます．ライブラリを調査する
`AC_CHECK_LIB'でも，調査しているライブラリを一時的に`LIBS'に追
加したり，小さなプログラムのリンクを試みたりすることで，使用されています
(*note Libraries::)．

 -- Macro: AC_LINK_IFELSE (INPUT, [ACTION-IF-FOUND],
          [ACTION-IF-NOT-FOUND])
     現在の言語(*note Language
     Choice::)のコンパイラ(とコンパイラフラグ)とリ
     ンカをINPUTで実行し，成功したらシェルコマンドの
     ACTION-IF-TRUEを，それ以外ではACTION-IF-FALSEを実行します．
     INPUTは`AC_LANG_PROGRAM'やその仲間で作成することが可能です．

     リンク時には，現在のコンパイラフラグに加えて，`LDFLAGS'と
     `LIBS'も使用されます．

     慣習的に，予期せぬ異常終了は`AC_MSG_FAILURE'で報告します．このマク
     ロはリンクを試みません．そうする必要がある場合，`AC_RUN_IFELSE'を使
     用してください(*note Run Time::)．


File: autoconf-ja.info,  Node: Run Time,  Next: Systemology,  Prev: Running the Linker,  Up: Writing Tests

6.6 実行時の動作の調査
======================

当該関数に特定の能力やバグがあるかどうかといった，実行時にシステムがどの
ような動作をするか調べる必要があることもあります．可能であれば，コンフィ
グレーション時ではなくプログラムを実行するときそのような調査をしてくださ
い．マシンのエンディアンのようなものは，プログラムの初期化時に調査するこ
とが可能です．

コンフィグレーション時に実行時の動作を調査する必要が本当にある場合，結果
を決定するテストプログラムを書き，コンパイルして`AC_RUN_IFELSE' を
使用して実行することも可能です．これは，クロスコンパイルでパッケージをコ
ンフィグレーションする人々の妨げになるので，可能であれば，テストプログラ
ムの実行は避けてください．

 -- Macro: AC_RUN_IFELSE (INPUT, [ACTION-IF-FOUND],
          [ACTION-IF-NOT-FOUND], [ACTION-IF-CROSS-COMPILING])
     PROGRAMのコンパイルとリンクが正常終了し，実行時に0の終了ステータス
     が返る場合，シェルコマンドACTION-IF-TRUEを実行します．それ以外では，
     シェルコマンドACTION-IF-FALSEを実行します．

     INPUTは，`AC_LANG_PROGRAM'とその仲間で作成することが可能です．
     現在の言語(*note Language
     Choice::)のコンパイラフラグに加えて，リンク時
     には`LDFLAGS'と`LIBS'も使用します．

     使用されるコンパイラが，`configure'が実行されているシステムで実
     行する実行形式を生成しない場合，テストプログラムは実行されません．オプショ
     ンのシェルコマンドACTION-IF-CROSS-COMPILINGが与えられている場合，
     それらが変わりに実行されます．それ以外の場合，`configure'はエラー
     メッセージを出力し終了します．

     ACTION-IF-FALSEセクションでは，プログラムの終了ステータスはシェル
     変数`$?'で利用可能ですが，127未満の正の値に制限するよう十分注意して
     ください．大きな値は，PROGRAMでファイルに保存すべきです．また，こ
     の終了ステータスがPROGRAMで，またはそのコンパイルの異常終了で，生
     成されることを保証されていないことに注意してください．言い替えると，苛め
     られるのが好きな人だけこの機能を使用してください．それは，Autoconfの管理
     者が飽き飽きするほど"バグの報告"を受けとることになったので，元に戻しま
     した．

     慣習的に，予期せぬ異常終了は`AC_MSG_FAILURE'で報告します．

クロスコンパイルで実行時のテストが不可能な時は，使用する悲観的なデフォル
ト値を提供してみてください．オプションの最後の引数を`AC_RUN_IFELSE'
に渡すことでこうします．`autoconf'は，
ACTION-IF-CROSS-COMPILING引数無しで`AC_RUN_IFELSE'を呼び出す
ごとに，`configure'を生成するときに警告メッセージを出力します．
警告を無視してもかまいませんが，ユーザはクロスコンパイルでパッケージのコ
ンフィグレーションが不可能になります．Autoconfで配布されるマクロには，こ
の警告メッセージを生成するものもあります．

クロスコンパイルでコンフィグレーションするため，これらのパラメータの値を
標準的なシステム名を基に選択することも可能です(*note Manual
Configuration::)．または，テスト結果のキャッシュファイルをホストシステム
に対する正しい値で設定してください(*note Caching Results::)．

   Autoconfとともに含まれている他のマクロに埋め込まれている，
`AC_RUN_IFELSE'の呼び出しに対するデフォルトを提供するため，シェル変
数`cross_compiling'が`yes'に設定されているかどうかを調査し，マ
クロ呼び出しの代わりに結果を取得するため，代わりの手法を使用してください．


File: autoconf-ja.info,  Node: Systemology,  Next: Multiple Cases,  Prev: Run Time,  Up: Writing Tests

6.7 システム
============

このセクションは，ドキュメントへのシステムとポインタを紹介することを目的
としています．ユーザが報告する特定の問題を解決するとき役に立つでしょう．

   Rosetta Stone for Unix(1)には，様々な
Unixの興味深い相互的な情報が大量にあります．

Darwin
     DarwinはMac OS
     Xとしても知られています．ファイルシステムで大文字小文字の
     違いを保存することが_可能_ですが，大文字小文字の区別をしないことに
     注意してください．例えば，`INSTALL'ファイルがあるパッケージでインス
     トールを試みるとき，`make install'で「何もすることが無い！」のよう
     な結果が得られ，これは厄介な問題になります．

     それは，ファイルシステムがUFS(大文字小文字を区別する)かHFS+(大文字小文字
     の違いを保存する)かに依存します．デフォルトで，AppleはHFS+にOSをインストー
     ルして欲しがっています．残念ながら，本当にUFSでビルドする必要があるソフ
     トウェアもあります．DarwinをUFSとHFS+の両方で利用可能なように再構築して
     (そして/local/buildのツリーに配置して)欲しいと思います．

QNX 4.25
     QNXは，小さな組み込みシステムから百個のプロセッサを持つスーパー
     コンピュータまで幅広く利用できる，Intelアーキテクチャでまで動作するリア
     ルタイムオペレーティングシステムです．それはPOSIXであることが
     証明されていると主張しています．QNX home page(2)
     で，より多くの情報が利用可能で，そこには， QNX man
     pages(3)もあります．

Tru64
     documentation of several versions of
     Tru64(4)では，様々な書式が利用可能で す．

Unix version 7
     V7 Manual(5)でドキュ メントが利用可能です．

   ---------- Footnotes ----------

   (1) Rosetta Stone for Unix, `http://bhami.com/rosetta.html'.

   (2) QNX home page, `www.qnx.com'.

   (3) QNX man pages, `http://support.qnx.com/support/docs/qnx4/'.

   (4) documentation of several versions of Tru64,
`http://www.tru64unix.compaq.com/docs/base_doc/DOCUMENTATION/'.

   (5) V7 Manual, `http://plan9.bell-labs.com/7thEdMan/index.html'.


File: autoconf-ja.info,  Node: Multiple Cases,  Prev: Systemology,  Up: Writing Tests

6.8 複数のケース文
==================

処理によっては，それぞれ異なるUNIXに依存して，考えられるいくつかの
方法で達成されるものもあります．それを本質的に調査するためには，"case
文"が必要です．Autoconfは直接それを提供していません．しかし，実行する処
理が見つかったかどうかの追跡を続けるため，シェル変数を使用することで簡単
にシミュレート可能です．

残っているcaseを調査する必要があるかどうかに関係なく追跡を続けるために，
シェル変数`fstype'を使用する例は，以下のようになります．

     AC_MSG_CHECKING([how to get file system type])
     fstype=no
     # The order of these tests is important.
     AC_COMPILE_IFELSE([AC_LANG_PROGRAM([[#include <sys/statvfs.h>
     #include <sys/fstyp.h>]])],
                       [AC_DEFINE(FSTYPE_STATVFS) fstype=SVR4])
     if test $fstype = no; then
       AC_COMPILE_IFELSE([AC_LANG_PROGRAM([[#include <sys/statfs.h>
     #include <sys/fstyp.h>]])],
                       [AC_DEFINE(FSTYPE_USG_STATFS) fstype=SVR3])
     fi
     if test $fstype = no; then
       AC_COMPILE_IFELSE([AC_LANG_PROGRAM([[#include <sys/statfs.h>
     #include <sys/vmount.h>]])]),
                       [AC_DEFINE(FSTYPE_AIX_STATFS) fstype=AIX])
     fi
     # (more cases omitted here)
     AC_MSG_RESULT([$fstype])


File: autoconf-ja.info,  Node: Results,  Next: Programming in M4,  Prev: Writing Tests,  Up: Top

7 テストの結果
**************

一度`configure'で特徴の存在を定義すると，その情報を記録するため
に何ができるのでしょうか？そうする方法は四種類あります．Cプリプロセッサ
シンボルの定義，出力ファイルで変数を設定，`configure'実行時のキャッ
シュファイルに結果を保存，そして，テスト結果をユーザに知らせるメッセージ
の出力です．

* Menu:

* Defining Symbols::            Defining C preprocessor symbols
* Setting Output Variables::    Replacing variables in output files
* Caching Results::             Speeding up subsequent `configure' runs
* Printing Messages::           Notifying `configure' users


File: autoconf-ja.info,  Node: Defining Symbols,  Next: Setting Output Variables,  Up: Results

7.1 Cプリプロセッサシンボルの定義
=================================

特徴テストからの応答を受けとる通常の動作は，テストの結果を示すCプリプロ
セッサシンボルを定義することです．それは`AC_DEFINE'や
`AC_DEFINE_UNQUOTED'と呼ばれるもので行います．

   デフォルトで，`AC_OUTPUT'はマクロが定義したシンボルを，出力変数
`DEFS'に配置し，それはそれぞれのシンボルに対する
`-DSYMBOL=VALUE'を含んでいます．Autoconfバージョン1
と異なり，`configure'が実行中に定義する変数`DEFS'はありませ
ん．Autoconfマクロが，あるCプリプロセッサシンボルを既に定義しているかど
うか調査するため，以下の例のように，適切なキャッシュ変数の値をテストして
ください．

     AC_CHECK_FUNC(vprintf, [AC_DEFINE(HAVE_VPRINTF)])
     if test "$ac_cv_func_vprintf" != yes; then
       AC_CHECK_FUNC(_doprnt, [AC_DEFINE(HAVE_DOPRNT)])
     fi

   `AC_CONFIG_HEADERS'が呼び出された場合，`DEFS'を作成する代わり
に，`AC_OUTPUT'でテンプレートファイルに`#define'文で正しい値を
代入したヘッダファイルを作成します．この種類の出力の詳細は， *Note
Configuration Headers::.

 -- Macro: AC_DEFINE (VARIABLE, VALUE, [DESCRIPTION])
 -- Macro: AC_DEFINE (VARIABLE)
     Cプリプロセッサ変数VARIABLEをVALUEに(そのまま)定義します．
     VALUEは改行のリテラルを含むべきではなく， `AC_CONFIG_HEADERS'
     を使用しない場合，`make'が処理してしまうので，`#'文字を含め
     るべきではありません．シェル変数(M4の引用符文字`['や`]'を含む
     定義値が必要なもの)を使用するために，代わりに`AC_DEFINE_UNQUOTED'を
     使用してください．DESCRIPTIONは， `AC_CONFIG_HEADER'を使用す
     る場合だけ役に立ちます．この場合， DESCRIPTIONは，生成された
     `config.h.in'に，マクロ定義前のコメントとして書き込まれます．以下の
     例は，Cプリプロセッサ変数`EQUATION' を文字定数`"$a > $b"'と定
     義します．

          AC_DEFINE(EQUATION, "$a > $b")

     VALUEもDESCRIPTIONも与えられていない場合，VALUEのデフォ
     ルトは空の文字列ではなく1になります．これは古いバージョンのAutoconfの下
     位互換性のためですが，この使用方法は時代遅れで，Autoconfの将来のバージョ
     ンでは無くなるかもしれません．

 -- Macro: AC_DEFINE_UNQUOTED (VARIABLE, VALUE, [DESCRIPTION])
 -- Macro: AC_DEFINE_UNQUOTED (VARIABLE)
     `AC_DEFINE'に似ていますが，VARIABLEとVALUEで，三つのシェ ル展開が
     -- 一度に -- 実行されます．変数の展開(`$')，コマンドの置
     換(``')，そしてバックスラッシュエスケープ(`\')です．値の中のシ
     ングルクオートとダブルクオートの文字列，特別な意味を持ちません．
     VARIABLEや VALUEがシェル変数のときは，`AC_DEFINE'の代わ
     りにこのマクロを使用してください．以下がその例です．

          AC_DEFINE_UNQUOTED(config_machfile, "$machfile")
          AC_DEFINE_UNQUOTED(GETGROUPS_T, $ac_cv_type_getgroups)
          AC_DEFINE_UNQUOTED($ac_tr_hdr)

Bourneシェルの構文の特異性のため，他のマクロから呼び出しやシェルコードと
`AC_DEFINE'や`AC_DEFINE_UNQUOTED'を分けるために，セミコロンを
使用しないでください．そうすると，`configure'スクリプトの結果と
して構文エラーの原因となります．以下のようにします．

     AC_CHECK_HEADER(elf.h, [AC_DEFINE(SVR4) LIBS="$LIBS -lelf"])

あるいは以下のようにします．

     AC_CHECK_HEADER(elf.h,
      [AC_DEFINE(SVR4)
       LIBS="$LIBS -lelf"])

それらは以下の代わりのものです．

     AC_CHECK_HEADER(elf.h, [AC_DEFINE(SVR4); LIBS="$LIBS -lelf"])


File: autoconf-ja.info,  Node: Setting Output Variables,  Next: Caching Results,  Prev: Defining Symbols,  Up: Results

7.2 出力変数の設定
==================

テストの結果を記録するもう一つの方法は，"出力変数(output variables)"
を設定することで，それは，`configure'が出力したファイルの中に，
シェル変数の値を代入することです．以下の二つのマクロで新しい出力変数を作
ります．利用可能な出力変数のリストは，*Note Preset Output Variables::.

 -- Macro: AC_SUBST (VARIABLE, [VALUE])
     シェル変数から出力変数を作成します．`AC_OUTPUT'は，出力ファイルの変
     数VARIABLEに代入します(通常，一つ以上の`Makefile'です)．これ
     は，`AC_OUTPUT'が呼び出されたとき，入力ファイルの
     `@VARIABLE@'のインスタンスをシェル変数VARIABLEが持つ
     値で`AC_OUTPUT'が置換することを意味します．VARIABLEのこの値は
     改行のリテラルを含むべきではありません．

     VALUEが与えられている場合，さらにそれもVARIABLEに渡されます．

 -- Macro: AC_SUBST_FILE (VARIABLE)
     シェル変数から出力ファイルを作成するもう一つの方法です．`AC_OUTPUT'
     で，シェル変数VARIABLEで名付けられたファイルの内容を出力ファイルに
     挿入します(代入ではありません)．これは，`AC_OUTPUT'が呼び出されたと
     き，シェル変数VARIABLEの名前のファイルの内容で，
     (`Makefile.in')のような出力ファイルの`@VARIABLE@'のイ
     ンスタンスを，`AC_OUTPUT'が置換することを意味します．挿入するファイ
     ルがない場合には，変数`/dev/null' に設定します．

     このマクロは，`Makefile'に特別な依存を含むフラグを挿入したり，特定
     のホストやターゲットのための`make'ディレクティブを`Makefile'に
     挿入するとき役に立ちます．例えば，`configure.ac'
     に以下を含ませます．

          AC_SUBST_FILE(host_frag)
          host_frag=$srcdir/conf/sun4.mh

     そして`Makefile.in'に以下を含ませます．

          @host_frag@

   異なる環境変数で`configure'を実行することは非常に危険です．例え
ば，ユーザが`CC=bizarre-cc ./configure'を実行した場合，キャッシュ，
`config.h'，そして多くの出力ファイルは，Cコンパイラが
`bizarre-cc'だということに依存します．理由があって，ユーザが再び
`./configure'を実行した場合や，`./config.status --recheck'
でそれが実行される場合(*Note Automatic Remaking::.  *note config.status
Invocation::)，コンフィグレーションは矛盾し，二つの異なるコンパイラに依存
した結果で構成されます．

   上記の`CC'のように，この状況に影響する環境変数は"貴重な変数
(precious variables)"と命名されていて，`AC_ARG_VAR'のようなもので宣
言することが可能です．

 -- Macro: AC_ARG_VAR (VARIABLE, DESCRIPTION)
     VARIABLEを貴重な変数として宣言し，`./configure --help'の可変
     部分にそのDESCRIPTIONを含めます．

     貴重とは，以下のことを意味します．
        - VARIABLEが`AC_SUBST'されていること．

        - `configure'が開始されたとき，VARIABLEの値は，コマンドライ
          ンで指定されておらず環境変数で指定されている場合も含めて，キャッシュに保
          存されません．実際，`configure'は`./configure
          CC=bizarre-cc'の`CC'の定義に注目できますが，`CC=bizarre-cc
          ./configure'のものには注意できません．そして，残念ながらほとんどのユーザ
          がそうしています．

          それは，保存されるVARIABLEの_初期_値ですが，
          `configure'の実行中は見つからないことを強調しておきます．実際，
          `./configure FOO=foo'と指定することと，`./configure'に
          `FOO'が`foo'だと分からせることは，かなり違った結果になるはずで
          す．

        - VARIABLEは二回の`configure'の実行の間の整合性を調査されま
          す．例えば，以下のようにします．

               $ ./configure --silent --config-cache
               $ CC=cc ./configure --silent --config-cache
               configure: error: `CC' was not set in the previous run
               configure: error: changes in the environment can compromise \
               the build
               configure: error: run `make distclean' and/or \
               `rm config.cache' and start over

          そして，それは変数を未設定にする場合や，その内容が変更される場合も似たよ
          うなものです．

        -
          VARIABLEは，自動的な再コンフィグレーションの間，コマンド引数として
          渡されているかのように保存され，キャッシュを使用していないときもそうなり
          ます．

               $ CC=/usr/bin/cc ./configure undeclared_var=raboof --silent
               $ ./config.status --recheck
               running /bin/sh ./configure undeclared_var=raboof --silent \
                 CC=/usr/bin/cc  --no-create --no-recursion


File: autoconf-ja.info,  Node: Caching Results,  Next: Printing Messages,  Prev: Setting Output Variables,  Up: Results

7.3 結果のキャッシュ
====================

様々な`configure'スクリプトで，同じ特徴を繰り返し調査する(あるい
は何度も一つのスクリプトを実行する)ことを避けるため，`configure'
は，多くの調査結果を"キャッシュファイル(cache file)"に保存します (*note
Cache Files::)．キャッシュ可能な状態で`configure' スクリ
プトを実行していてキャッシュファイルが見つかった場合，前回の実行結果を
キャッシュから読み込み，これらの調査の再実行を避けます．結果として，
`configure'は，毎回全ての調査を実行するより早くなります．

 -- Macro: AC_CACHE_VAL (CACHE-ID, COMMANDS-TO-SET-IT)
     CACHE-IDで識別した調査結果が，利用可能だということを保証します．調
     査結果が読み込まれたキャッシュファイルにあり，`configure'に，
     `--quiet'や`--silent'オプションが与えられていない場合，結果が
     キャッシュされていることを示すメッセージを出力します．それ以外では，シェ
     ルコマンドCOMMANDS-TO-SET-ITを実行します．シェルコマンドを値を決定
     するために実行する場合，`configure'が出力ファイルを作成する直前
     に，値をキャッシュファイルに保存します．CACHE-ID変数の名前を選択す
     る方法は，*Note Cache Variable Names::.

     COMMANDS-TO-SET-ITは，設定された変数CACHE-ID以外に_副作
     用がないはずです_．以下を参照してください．

 -- Macro: AC_CACHE_CHECK (MESSAGE, CACHE-ID, COMMANDS-TO-SET-IT)
     メッセージ出力に注意が必要な`AC_CACHE_VAL'のラッパーです．このマク
     ロは，これらのマクロを使用する最も一般的な方法に対して，便利な略記法を提
     供します．それは，MESSAGEに対して`AC_MSG_CHECKING'を呼び出し，
     その後で，CACHE-IDとCOMMANDS引数を伴う`AC_CACHE_VAL'と，
     CACHE-IDを伴う`AC_MSG_RESULT'を呼び出します．

     COMMANDS-TO-SET-ITは，設定された変数CACHE-ID以外に_副作
     用がないはずです_．以下を参照してください．

   COMMANDS-TO-SET-ITで`AC_DEFINE'の呼び出しを試みるため，
`AC_CACHE_VAL'や`AC_CACHE_CHECK'を使用しているバグの多いマクロ
を発見することはよくあります．その代わりに，`AC_CACHE_VAL'を呼び出
している_以下の_ようなコードでは，キャッシュ変数の値を調べることで，
`AC_DEFINE'を呼び出すべきです．例えば，以下のマクロは駄目です．

     AC_DEFUN([AC_SHELL_TRUE],
     [AC_CACHE_CHECK([whether true(1) works], [ac_cv_shell_true_works],
                     [ac_cv_shell_true_works=no
                      true && ac_cv_shell_true_works=yes
                      if test $ac_cv_shell_true_works = yes; then
                        AC_DEFINE([TRUE_WORKS], 1
                                  [Define if `true(1)' works properly.])
                      fi])
     ])

これは，キャッシュが利用可能な場合，失敗します．このマクロの二回目の実行
で，`TRUE_WORKS'は_定義されていないでしょう_．適切な実装は以下
のようになります．

     AC_DEFUN([AC_SHELL_TRUE],
     [AC_CACHE_CHECK([whether true(1) works], [ac_cv_shell_true_works],
                     [ac_cv_shell_true_works=no
                      true && ac_cv_shell_true_works=yes])
      if test $ac_cv_shell_true_works = yes; then
        AC_DEFINE([TRUE_WORKS], 1
                  [Define if `true(1)' works properly.])
      fi
     ])

   また，COMMANDS-TO-SET-ITでは，例えば`AC_MSG_CHECKING'を用いて
メッセージを出力すべきではありません．調査の結果がキャッシュから取り出さ
れるか，シェルコマンドの実行で決定されるかに依存せずメッセージが出力され
るので，`AC_CACHE_VAL'の呼び出しの前にしてください．

* Menu:

* Cache Variable Names::        Shell variables used in caches
* Cache Files::                 Files `configure' uses for caching
* Cache Checkpointing::         Loading and saving the cache file


File: autoconf-ja.info,  Node: Cache Variable Names,  Next: Cache Files,  Up: Caching Results

7.3.1 キャッシュ変数名
----------------------

キャッシュ変数の名前は以下の書式にすべきです．

     PACKAGE-PREFIX_cv_VALUE-TYPE_SPECIFIC-VALUE_[ADDITIONAL-OPTIONS]

例えば，`ac_cv_header_stat_broken'や
`ac_cv_prog_gcc_traditional'です．変数名の一部は以下のようにします．

PACKAGE-PREFIX
     パッケージや組織の省略です．小文字の慣習以外は，ローカルなAutoconfマクロ
     と同じプレフィクスで開始します．配布されているAutoconfマクロで使用される
     キャッシュ値に対して，この値は`ac'になっています．

`_cv_'
     シェル変数がキャッシュ値であることを示します．この文字列は，前置されるア
     ンダースコアを含め，変数名に存在する_必要があります_．

VALUE-TYPE
     合理的な命名システムを生成するため，キャッシュ値の分類のための慣習です．
     Autoconfで使用する値は，*Note Macro Names::にリストがあります．

SPECIFIC-VALUE
     このテストが適応しているキャッシュ値のクラスのメンバーです．例えば，関数
     (`alloca')，プログラム(`gcc')，または，出力変数 (`INSTALL')です．

ADDITIONAL-OPTIONS
     このテストが適応している特定のメンバーの特定の動作です．例えば，
     `broken'や`set'です．適応されない場合，名前のこの部分は省略さ
     れます．

キャッシュ変数に割り当てられた値には，改行を含めてはなりません．通常，そ
れらの値は真偽値(`yes'や`no')，あるいはファイルや関数の名前で
す．そのため，これは重要な制限ではありません．


File: autoconf-ja.info,  Node: Cache Files,  Next: Cache Checkpointing,  Prev: Cache Variable Names,  Up: Caching Results

7.3.2 キャッシュファイル
------------------------

キャッシュファイルは，コンフィグレーションスクリプトとコンフィグレーショ
ンの実行の間で結果を共有できるように，一つのシステムでコンフィグレーショ
ンテストの結果をキャッシュしているシェルスクリプトです．他のシステムでは
役に立ちません．その内容が，何らかの理由で無効な場合，ユーザは削除したり
編集したりしてもかまいません．

デフォルトでは，古いキャッシュファイルの使用で偶然生じる問題を避けるため，
`configure'はキャッシュファイルを使用しません(技術的には，
`--cache-file=/dev/null'を使用します)．

   キャッシュを利用可能にするために，`configure'は結果をファイル
`config.cache'にキャッシュする`--config-cache'(または，
`-C')を受け入れます．代わり方法として，
`--cache-file=FILE'でFILEキャッシュファイルにを指定し
ます．`configure'がサブディレクトリの`configure'スクリプ
トを呼び出すとき，同じキャッシュファイルを共有するように，
`--cache-file'引数を使用します．`AC_CONFIG_SUBDIRS'マクロを
用いてサブディレクトリでコンフィグレーションすることの情報は， *Note
Subdirectories::.

   `config.status'は，`configure'を再実行する
`--recheck'オプションが与えられている場合のみ，キャッシュファイル
に注意を払います．

特定のシステム形式に対してキャッシュファイルを配布しようとすることは間違
いです．そうすることによるエラーに対する機会が非常に多くなり，メンテナン
ス時の管理上のオーバーヘッドが非常に多くなります．自動的に推測できない特
徴に対して，標準的なシステムの形式とリンクファイルの標準的な方法を使用し
てください (*note Manual Configuration::)．

サイトの初期化スクリプトで，通常のプログラムごとのキャッシュの代わりに，
使用するサイト全体のキャッシュファイルを指定することが可能になります．こ
の場合，キャッシュファイルは，新しい`configure'スクリプトを実行
する度に，情報がどんどん蓄積されていきます．(`configure'を実行す
ると，既存のキャッシュファイルを用いて新しい結果をマージします．)
しかし，
システムのコンフィグレーションが(例えば，ライブラリやコンパイラをインス
トールされて)変化し，古いキャッシュファイルが削除されない場合，これは問
題になるかもしれません．


File: autoconf-ja.info,  Node: Cache Checkpointing,  Prev: Cache Files,  Up: Caching Results

7.3.3 キャッシュのチェックポイント方法
--------------------------------------

`configure'スクリプトや`configure.ac'から呼び出されるマクロ
がコンフィグレーション処理を中断する場合，二，三回`AC_CACHE_SAVE'を
使用して，キーポイントでキャッシュのチェックポイントにすることが役に立ち
ます．そうすると，(おそらく)前に異常終了を引き起こしたエラーを修正するこ
とで，`configure'スクリプトを再実行する時間が大幅に削減されます．

 -- Macro: AC_CACHE_LOAD
     既存のキャッシュファイルから値をロードしたり，キャッシュファイルがない場
     合は新しいキャッシュファイルを作成したりします．自動的に`AC_INIT'か
     ら呼び出されます．

 -- Macro: AC_CACHE_SAVE
     キャッシュファイルに全てのキャッシュ値を書き込みます．自動的に
     `AC_OUTPUT'から呼び出されますが，`configure.ac'のキーポイント
     で`AC_CACHE_SAVE'を呼び出すことは，大変役に立つはずです．

   例えば，以下のようにします．

      ... AC_INIT, etc. ...
     # Checks for programs.
     AC_PROG_CC
     AC_PROG_GCC_TRADITIONAL
      ... more program checks ...
     AC_CACHE_SAVE

     # Checks for libraries.
     AC_CHECK_LIB(nsl, gethostbyname)
     AC_CHECK_LIB(socket, connect)
      ... more lib checks ...
     AC_CACHE_SAVE

     # Might abort...
     AM_PATH_GTK(1.0.2,, [AC_MSG_ERROR([GTK not in path])])
     AM_PATH_GTKMM(0.9.5,, [AC_MSG_ERROR([GTK not in path])])
      ... AC_OUTPUT, etc. ...


File: autoconf-ja.info,  Node: Printing Messages,  Prev: Caching Results,  Up: Results

7.4 メッセージの出力
====================

`configure'スクリプトは，それらを実行しているユーザに，何種類か
の情報を与える必要があります．以下のマクロは，それぞれの種類に対して適切
な方法でメッセージを出力します．全ての引数は，シェルのダブルクオートで囲
まれているので，シェルは変数とバッククオートの代入を実行します．

   これらのマクロは，`echo'シェルコマンドを全てラップします．
`configure'スクリプトは，ユーザに対してメッセージを出力するため，
直接`echo'を実行する必要は滅多にありません．これらのマクロを使用す
ると，出力されるそれぞれのメッセージの種類を，いつでもどのようにでも簡単
に変更できます．そのような変更にはマクロ定義の変更だけが必要で，呼び出し
側は自動的に変更されます．

   静的な問題を診断するため，例えば`autoconf'が実行されるときは， *Note
Reporting Messages::を参照してください．

 -- Macro: AC_MSG_CHECKING (FEATURE-DESCRIPTION)
     `configure'が調査している特徴を，ユーザに通知します．このマクロ
     は`checking 'で始まり`...'で終る，改行無しのメッセージを出力し
     ます．調査の結果と改行のため，`AC_MSG_RESULT'を続けて呼び出す必要が
     あります．FEATURE-DESCRIPTIONは`FortranコンパイラがC++のコメ
     ントを受け入れるかどうか(whether the Fortran compiler accepts C++
     comments)'や`c89の調査(for c89)'のようなものです．

     `configure'が`--quiet'や`--silent'オプションを用いて実
     行されている場合，このマクロは何も出力しません．

 -- Macro: AC_MSG_RESULT (RESULT-DESCRIPTION)
     調査結果をユーザに通知します．RESULT-DESCRIPTIONは，ほとんどいつも
     調査に対するキャッシュ変数の値で，普通は`yes'，`no'，またはファ
     イル名になります．このマクロは`AC_MSG_CHECKING'の呼び出しに続けるべ
     きで，RESULT-DESCRIPTIONは，`AC_MSG_CHECKING'の呼び出しで出力
     されるメッセージを完成するものにするべきです．

     `configure'が`--quiet'や`--silent'オプションで実行され
     る場合，このマクロは何も出力しません．

 -- Macro: AC_MSG_NOTICE (MESSAGE)
     MESSAGEをユーザに伝えます．特徴を調査しているグループ全体の特徴に
     ついて，例えば以下のような，一般的な記述を出力するときに主に役に立ちます．

          AC_MSG_NOTICE([checking if stack overflow is detectable])

     `configure'が`--quiet'や`--silent'オプションで実行され
     る場合，このマクロは何も出力しません．

 -- Macro: AC_MSG_ERROR (ERROR-DESCRIPTION, [EXIT-STATUS])
     `configure'の完了を妨げるエラーをユーザに通知します．このマクロ
     は，エラーメッセージを標準エラー出力に出力し，`configure'は
     EXIT-STATUS(デフォルトは1)で終了します．ERROR-DESCRIPTION は
     `\$HOMEに対し$HOMEは無効な値です(invalid value $HOME for \$HOME)'の
     ようにすべきです．

     ERROR-DESCRIPTIONは小文字で開始すべきで，"can't"より"cannot"
     のほうが好ましいでしょう．

 -- Macro: AC_MSG_FAILURE (ERROR-DESCRIPTION, [EXIT-STATUS])
     これは，`AC_MSG_ERROR'のラッパーで，`configure'が終了するの
     を妨げるエラーをユーザに告知し，_そして_詳細を`config.log' に
     追加します．これは通常，コンパイル時に異常な結果が見つかったときに使用さ
     れます．

 -- Macro: AC_MSG_WARN (PROBLEM-DESCRIPTION)
     可能性のある問題を`configure'を実行しているユーザに通知します．
     このマクロは，標準エラー出力にメッセージを出力します．
     `configure'はその後も実行を続けるので，`AC_MSG_WARN'を呼び
     出すマクロでは，警告するような状態に対してデフォルト(バックアップ)の動作
     を提供すべきです． PROBLEM-DESCRIPTIONは`ln -s はハードリンク
     されます(ln -s seems to make hard links)'のようなものにすべきです．


File: autoconf-ja.info,  Node: Programming in M4,  Next: Writing Autoconf Macros,  Prev: Results,  Up: Top

8 M4でのプログラミング
**********************

Autoconfは，二つのレイヤーのトップに書かれています．それは，純粋なM4プロ
グラムで便利なマクロを提供している"M4sugar"と，シェルスクリプトの生
成に専念するマクロを提供する"M4sh"です．

このバージョンのAutoconfでは，二つのレイヤーはまだ実験段階で，そのインター
フェースは将来変更される可能性があります．実際問題，_文章化されてい
ないものは使用しないでください_．

* Menu:

* M4 Quotation::                Protecting macros from unwanted expansion
* Using autom4te::              The Autoconf executables backbone
* Programming in M4sugar::      Convenient pure M4 macros
* Programming in M4sh::         Common shell Constructs


File: autoconf-ja.info,  Node: M4 Quotation,  Next: Using autom4te,  Up: Programming in M4

8.1 M4の引用符
==============

既存のマクロの最も一般的な問題は，不適当な引用符です．このセクションでは，
Autoconfのユーザは飛ばすことができますが，マクロを書く人は読む_必要
があり_，最初にAutoconfで採択された引用符を利用する方法を正当化し，最後
に経験則を述べます．前者を理解すると後者で役立ちます．

* Menu:

* Active Characters::           Characters that change the behavior of M4
* One Macro Call::              Quotation and one macro call
* Quotation and Nested Macros::  Macros calling macros
* Changequote is Evil::         Worse than INTERCAL: M4 + changequote
* Quadrigraphs::                Another way to escape special characters
* Quotation Rule Of Thumb::     One parenthesis, one quote


File: autoconf-ja.info,  Node: Active Characters,  Next: One Macro Call,  Up: M4 Quotation

8.1.1 アクティブな文字
----------------------

適切な引用符の重要性を完全に理解するため，最初にAutoconfでの特殊な文字が
何かを知る必要があります．`#'はマクロ展開が実行されない内部コメント
の導入で，`,'は引数のセパレータ，`['と`]'はそれらの引用符，
そして最後は，(M4が対の一致を試みる)`('と`)'です．

マクロ呼び出しの微妙な状況を理解するために，最初に明らかな失敗を紹介しな
ければならないでしょう．以下で"明確にされ"ていて，実生活でも見つかるで
しょうが，それらは通常ごまかしです．

ハッシュと改行まで実行することで導入されるコメントは，トップレベルへの不
明瞭なトークンです．アクティブな文字はそうではなくなり，マクロの展開もあ
りません．

     # define([def], ine)
     =># define([def], ine)

マクロの展開があるごとに，引用符も展開されます．すなわち，第一レベルの引
用符は削除されます．

     int tab[10];
     =>int tab10;
     [int tab[10];]
     =>int tab[10];

   これを覚えていなければ，読者は絶望しながらもマクロの`array'を使用し
てみるでしょう．

     define([array], [int tab[10];])
     array
     =>int tab10;
     [array]
     =>array

期待する結果を正しく出力するにはどうすれば良いでしょうか (1)？

   ---------- Footnotes ----------

   (1) `defn'を使用します．


File: autoconf-ja.info,  Node: One Macro Call,  Next: Quotation and Nested Macros,  Prev: Active Characters,  Up: M4 Quotation

8.1.2 一つのマクロの呼び出し
----------------------------

さて，アクティブな文字と以下の単に最初の引数を返す小さなマクロを用いたマ
クロで，対話的に進めていきましょう．

     define([car], [$1])

上記の二組の引用符は`define'の引数の一部ではありません．そうではな
く，`define'の引数の検索が試みられるときに，それらはトップレベルで
理解されます．そのため，それは以下のように書くことと等価です．

     define(car, $1)

しかし，`configure.ac'が不必要な引用符を避けることは受け入れてもか
まいませんが，より強固で，完全な形式を提案する必要もあるAutoconfマクロに
とっては悪い慣習です．

トップレベルでは，二つの可能性があります．引用符で囲む，または囲まないで
の二つです．

     car(foo, bar, baz)
     =>foo
     [car(foo, bar, baz)]
     =>car(foo, bar, baz)

   特殊文字に注目してみましょう．

     car(#)
     error-->EOF in argument list

閉じカッコはコメント内に隠れてしまいます．引用符を推測することで，トップ
レベルでは以下のように理解します．

     car([#)]

適切な引用符は，もちろんこの問題を修正します．

     car([#])
     =>#

   読者は，以下の例の方が理解しやすいかもしれません．

     car(foo, bar)
     =>foo
     car([foo, bar])
     =>foo, bar
     car((foo, bar))
     =>(foo, bar)
     car([(foo], [bar)])
     =>(foo
     car([], [])
     =>
     car([[]], [[]])
     =>[]

これを覚えていると，マクロがマクロを呼び出し，マクロがマクロを呼び出し
...となっているような状況も調査することが可能です．


File: autoconf-ja.info,  Node: Quotation and Nested Macros,  Next: Changequote is Evil,  Prev: One Macro Call,  Up: M4 Quotation

8.1.3 引用符と入れ子状のマクロ
------------------------------

これ以降の例では，以下のマクロを使用しています．

     define([car], [$1])
     define([active], [ACT, IVE])
     define([array], [int tab[10]])

追加の埋め込まれたマクロ呼び出しは，それぞれ興味深い引用符について，その
他の可能性を導き出します．

     car(active)
     =>ACT
     car([active])
     =>ACT, IVE
     car([[active]])
     =>active

   最初の状況では，トップレベルでは`car'の引数を探し，`active' が
見つかります．M4はマクロを適用する前のその引数と等価なので，
`active'は展開され，結果として以下のようになります．

     car(ACT, IVE)
     =>ACT

二番目の状況では，トップレベルは`car'の最初で唯一の引数として
`active'を与えるので，結果として以下のようになります．

     active
     =>ACT, IVE

すなわち，マクロが呼び出された_後で_，引数が評価されます．三番目の
状況では，`car'は`[active]'を受けとり，結果として以下のように なります．

     [active]
     =>active

上記で見たものと同じですね．

   より現実的な例を適用して，上記の例に与えてみましょう．

     car(int tab[10];)
     =>int tab10;
     car([int tab[10];])
     =>int tab10;
     car([[int tab[10];]])
     =>int tab[10];

う〜ん？ 最初の状況は簡単に理解できますが，なぜ二番目が間違っていて，三
番目は正しいのでしょうか？それを理解するために，M4がマクロを展開した後，
結果として生じるテキストがすぐにマクロを展開に従って引用符が取り除かれる
ことを知っておく必要があります．これは，引用符の削除が二回行なわれること
を意味します -- 最初に引数として`car'マクロに渡されるとき，二回目
は`car'マクロが最初の引数を展開するときです．

   Autoconfマクロ`car'の作者として，ユーザが`car'の引数を二重の引
用符にする必要があることは間違っていると考えるようにし，マクロを_修
正_してください．引用符で囲まれている`car'に対して，それを
`qar'と呼ぶことにしましょう．

     define([qar], [[$1]])

そして，`qar'が適切に修正されていることを調査してみます．

     qar([int tab[10];])
     =>int tab[10];

あぁ！そうした方が良さそうですね．

しかし，自分が行なったことに注意してください．現在その引数はリテラル文字
列ですが，引数を展開した結果をユーザが使用したい場合，_引用符で囲ま
れていない_マクロを使用する必要があります．

     qar(active)
     =>ACT

`car'を用いて行なっていたことを再生成したい状況を考えます．

     car([active])
     =>ACT, IVE

まだ駄目ですね．`cpp'マクロの組を生成するマクロを使用したい状況を考
えてみましょう．

     define([my_includes], [#include <stdio.h>])
     car([my_includes])
     =>#include <stdio.h>
     qar(my_includes)
     error-->EOF in argument list

   このマクロ`qar'は，引数を二重に引用符で囲むので，ユーザはマクロの呼
び出しを引用符で囲まないままにしておくよう強制されるので，それは危険です．
カンマとその他のアクティブなシンボルは，マクロに渡される前にM4で解釈され，
それはユーザが期待している手法ではないことが多いものです．また，
`qar'は，他のマクロとは異なる動作をするので，Autoconfでは避けるべき
例外になります．


File: autoconf-ja.info,  Node: Changequote is Evil,  Next: Quadrigraphs,  Prev: Quotation and Nested Macros,  Up: M4 Quotation

8.1.4 `changequote'の弊害
-------------------------

特に夜も遅くなると，適切な引用符をバイパスする誘惑が大きくなることも多い
ものです．そして，経験豊富なAutoconfのハッカーの多くは，最終的に暗黒の力
に支配され，最終兵器を持ち出します．それは`changequote'です．

   M4組み込みの`changequote'は，言語の構文を必要に応じて調整することを
可能にするプリミティブの組に属しています．例えば，M4では引用符としてデフォ
ルトで``'と`''を使用しますが，シェルプログラムの文脈(そして，
ほとんどの実際のプログラミング言語)では，それは利用可能なものの中での最
悪の選択です．シェルコードでの(`'this''と``that`' のような)文
字列とバッククオートされた式と，通常のプログラミング言語で使用される
(`'0''のような)リテラル文字のため，多くの対にならない``'と
`''が存在します．そのような文脈での厳密なM4の引用符が(変更)不可能な
場合は，悪夢になります．そのような文脈でM4を役立たせるため，それを設計し
た人は別の引用符の組の選択を可能にする`changequote'を装備しました．
M4sugar，M4sh，Autoconf，そしてAutotestでは，すべてのものが`['と
`]'の使用を選択しています．それらが滅多に使用されない文字という理由
だけでなく，_対にならないことも滅多に無い文字という理由もあります_．

構文形式がコメントだということを指定するため(M4がHTMLページを生成するた
めに使用されるとき，`changecom(<!--, -->)'が一般的だと分かるでしょ
う)の`changecom'と，それ以外の構文の詳細を変更するための
`changeword'と`changesyntax'(n番目の引数を示す，デフォルトで
`$'となっている文字や，引数の周りを囲むカッコなど)のような，それ以
外のマジックプリミティブもあります．

これらのプリミティブは，特定の分野に対してM4がより役に立つようにするため，
本当に意味があるものです．それらはコマンドラインオプションのように考える
べきです．それらは，`--quotes'，`--comments'，
`--words'，そして`--syntax'のようなものです．それにもかかわ
らず，M4ライブラリ自身が含まれる(追加のオプションが必要無い)ように，M4の
組み込みとして実装されています．

   そこに問題があります....


問題は，M4スクリプトの途中で，その初期化を目的としてそれを使用するときに
発生します．これは，あまり注意していない場合，甚大な影響があるはずです．
_実行の途中で言語を変更しているようなものです_．構文の変更とそれか
らの復帰が十分でないことが多いものです．その間でマクロの呼び出しを行なっ
た場合，現在の構文はおそらくマクロを実装していないので，これらのマクロは
失われることになります．


File: autoconf-ja.info,  Node: Quadrigraphs,  Next: Quotation Rule Of Thumb,  Prev: Changequote is Evil,  Up: M4 Quotation

8.1.5 四文字表記
----------------

Autoconfマクロを書いているとき，標準的なAutoconfの引用符の規則で表現する
ことが難しい，特殊な文字を生成する必要が生じるかもしれません．例えば，
`['以外の全ての文字に一致する正規表現`[^[]'を出力する必要があ
るかもしれません．この表現は，対称ではないカッコを含んでいるので，M4 マ
クロの中に簡単に書き込むことはできません．

   以下の"四文字表記(quadrigraph)"の一つを使用することで，この問題を解
決することが可能です．

`@<:@'
     `['

`@:>@'
     `]'

`@S|@'
     `$'

`@%:@'
     `#'

`@&t@'
     何にも展開されません．

   四文字表記は，`m4'が実行された後，変換処理の終りの段階で置換され
るので，M4の引用符の邪魔になりません．例えば，文字列`[^@<:@]' は，
その引用符で囲まれている状態に依存せず，出力では`[^[]'として現れま す．

   空の四文字表記を使用することも可能です．

   - 明示的に後置されるスペースに印を付けるため

     後置される空白は`autom4te'で壊されます．これは仕様です．

   - その他の四文字表記を生成するため

     例えば，`@<@&t@:@'は`@<:@'を生成します．

   - 禁止されているパターンの_発生_をエスケープするため

     例えば，`AC_FOO'をコメントとして書きたいかもしれませんが，
     `autom4te'は展開されていない`AC_*'を確実に受けとります．そ
     のときは，`AC@&t@_FOO'と書いてください．

   `@&t@'の名前はPaul Eggertの提案です．

     私は，`@&t@'の語呂合わせに称賛を与えるべきでしょう．`&'は私
     自身の発明ですが，`t'はSteve Bourne(Bourneシェルで有名です)によって
     書かれたALGOL68Cコンパイラのソースコードが由来となっていて，そこで
     は空の文字列を示すために`mt'を使用しています．Cでは，それは以下のよ
     うなものになるでしょう．

          char const mt[] = "";

     しかし，ソースコードは当然Algol 68で書かれています．

     彼が`mt'を得た場所を，私は知りません．それは独自の発明かもしれませ
     んし，当時のケンブリッジ大学のコンピュータ研究所で，一般的な語呂合わせだっ
     たのかもしれません．


File: autoconf-ja.info,  Node: Quotation Rule Of Thumb,  Prev: Quadrigraphs,  Up: M4 Quotation

8.1.6 引用符の経験則
--------------------

終りに引用符の経験則を述べます．

                     _カッコの組ごとに引用符の組_

特にマクロ定義では，多過ぎる引用符もだめ，少な過ぎる引用符も駄目です．カッ
コを使用する必要があるマクロ(通常Cのプログラム文や正規表現の中)では，適
切に_引数を_引用符で囲んでください！

   以下のような断片を用いたAutoconfプログラムを読むことはよくあります．

     AC_TRY_LINK(
     changequote(<<, >>)dnl
     <<#include <time.h>
     #ifndef tzname /* For SGI.  */
     extern char *tzname[]; /* RS6000 and others reject char **tzname.  */
     #endif>>,
     changequote([, ])dnl
     [atoi (*tzname);], ac_cv_var_tzname=yes, ac_cv_var_tzname=no)

それは，`AC_TRY_LINK'は_すでに_二重に引用符で囲まれているので，
全く無駄になり，実際は以下のようにするだけで十分です．

     AC_TRY_LINK(
     [#include <time.h>
     #ifndef tzname /* For SGI.  */
     extern char *tzname[]; /* RS6000 and others reject char **tzname.  */
     #endif],
                 [atoi (*tzname);],
                 [ac_cv_var_tzname=yes],
                 [ac_cv_var_tzname=no])

M4に親しんでいる読者は，M4が引数を"まとめる(collect)"ときに
`changequote(<<, >>)'と`<<' `>>'の両方を飲み込むので，こ
れら二つの例が厳密に等価であることに注意してください．これらの引用符は引
数の一部ではありません！

   単純にしてみると，上記の例は以下のようになります．

     changequote(<<, >>)dnl
     <<[]>>
     changequote([, ])dnl

その代わりに単純に以下のようにします．

     [[]]

引数を(規則で)二重に引用符で囲まないマクロを用いると，二重の引用は(危険
な)文字列になります．

     AC_LINK_IFELSE([AC_LANG_PROGRAM(
     [[#include <time.h>
     #ifndef tzname /* For SGI.  */
     extern char *tzname[]; /* RS6000 and others reject char **tzname.  */
     #endif]],
                                     [atoi (*tzname);])],
                    [ac_cv_var_tzname=yes],
                    [ac_cv_var_tzname=no])

引用符が十分でない状況で望みがなくなった場合どうすればいいかということに
ついては，*Note Quadrigraphs::.

   新たに書かれたマクロを用いて`configure'スクリプトを作成するとき，
マクロにより多くの引用符を加える必要があるかどうかの調査は，気を付けて吟
味してください．一つ以上の単語がM4の出力に現れない場合，より多くの引用符
が必要になります．迷ったときは引用符です．

しかし，引用符のレイヤーが多過ぎる可能性もあります．この場合は，結果とし
て得られる`configure'スクリプトは，展開されていないマクロが含ま
れているでしょう．`autoconf'プログラムは，`grep AC_
configure'を行なうことでこの問題を調査します．


File: autoconf-ja.info,  Node: Using autom4te,  Next: Programming in M4sugar,  Prev: M4 Quotation,  Up: Programming in M4

8.2 `autom4te'の呼び出し
========================

Autoconf自身のものに加え，M4sugar，M4sh，そしてAutotestを含めた
Autoconfスイートは，M4にかなり依存しています．使い方が異なるこれらはす
べて，`m4'の上のレイヤーに集約したいという共通の要求を具体化し
ました．それは`autom4te'(1)です.

   `autom4te'は，`m4'のようなプリプロセッサです．それは
Autoconfのようなツールで使用するために設計された，M4の拡張をサポートして
います．

* Menu:

* autom4te Invocation::         A GNU M4 wrapper
* Customizing autom4te::        Customizing the Autoconf package

   ---------- Footnotes ----------

   (1) Lars J. Aasのもう一つの偉大な名前です．


File: autoconf-ja.info,  Node: autom4te Invocation,  Next: Customizing autom4te,  Up: Using autom4te

8.2.1 `autom4te'の呼び出し
--------------------------

コマンドライン引数は，M4のものをモデルにしています．

     autom4te OPTIONS FILES

ここでのFILESは，直接`m4'に渡すものです．正規の展開に加え，
それは四文字表記(*note Quadrigraphs::)と，出力の現在の行の
`__oline__'の置換を処理します．それは，FILESに対して拡張され
た構文もサポートしています．

`FILE.m4f'
     このファイルは，M4を固めたファイルです．_以前のファイルはすべて無視
     されることに_注意してください．正当性については，オプション
     `--melt'を参照してください．

`FILE?'
     ライブラリパスで見つかった場合，FILEは展開に含められ，それ以外では，
     異常終了を発生する代わりに無視されます．


もちろん，それはAutoconfの一般的のオプションのサブセットをサポートしてい
ます．

`--help'
`-h'
     コマンドラインオプションの概要を出力し，終了します．

`--version'
`-V'
     Autoconfのバージョンナンバーを出力し，終了します．

`--verbose'
`-v'
     処理しているステップを報告します．

`--debug'
`-d'
     一時的なファイルを削除せず，さらに冗長になります．

`--include=DIR'
`-I DIR'
     入力ファイルをDIRでも探します．複数回の呼び出しは累積されます．

`--output=FILE'
`-o FILE'
     (スクリプトやトレースの)出力をFILEに保存します．ファイル`-'
     は標準出力を意味します．


   `m4'の拡張として，それらは以下のオプションが含まれます．

`--warnings=CATEGORY'
`-W CATEGORY'
     (実際にはカンマで分けられたリストになっている)CATEGORYに関連する警
     告を報告します．カテゴリの包括的なリストは，マクロ`AC_DIAGNOSE' の
     *Note Reporting Messages::.  以下の特殊な値が含まれます．

    `all'
          すべての警告を報告します．

    `none'
          何も報告しません．

    `error'
          警告をエラーとして扱います．

    `no-CATEGORY'
          CATEGORYに分類される警告を利用不可能にします．

     `syntax'に関する警告は，デフォルトで利用可能で，カテゴリのカンマで
     分離されたリストの環境変数`WARNINGS'は尊重されます． `autom4te -W
     CATEGORY'は，実際に悪いことを実行したかのよう に動作します．

          autom4te --warnings=syntax,$WARNINGS,CATEGORY

     `autom4te'のデフォルトと`WARNINGS'を利用不可能にしたいけれ
     ども，(例えば)時代遅れの構成物に関する警告は利用可能にしたい場合，
     `-W none,obsolete'を使用するべきでしょう．

     `autom4te'はエラーのバックトレースを表示しますが，警告は表示しま
     せん．警告も表示したい場合，`-W error'を渡してください．例えば以
     下のような`configure.ac'を考えます．

          AC_DEFUN([INNER],
          [AC_RUN_IFELSE([AC_LANG_PROGRAM([exit (0)])])])

          AC_DEFUN([OUTER],
          [INNER])

          AC_INIT
          OUTER

     以下のようになるでしょう．

          $ autom4te -l autoconf -Wcross
          configure.ac:8: warning: AC_RUN_IFELSE called without default \
          to allow cross compiling
          $ autom4te -l autoconf -Wcross,error -f
          configure.ac:8: error: AC_RUN_IFELSE called without default \
          to allow cross compiling
          acgeneral.m4:3044: AC_RUN_IFELSE is expanded from...
          configure.ac:2: INNER is expanded from...
          configure.ac:5: OUTER is expanded from...
          configure.ac:8: the top level

`--melt'
`-m'
     固められたファイルを使用しません．すべての引数`FILE.m4f'は
     `FILE.m4'で置換されます．これは，ファイルが固められているとき
     だけに実行されるマクロ，通常は`m4_define'の追跡で役に立ちます．例え
     ば以下のように実行します．

          autom4te --melt 1.m4 2.m4f 3.m4 4.m4f input.m4

     これは以下を実行したのと等価です．

          m4 1.m4 2.m4 3.m4 4.m4 input.m4

     一方，以下を実行した場合を考えます．

          autom4te 1.m4 2.m4f 3.m4 4.m4f input.m4

     これは以下と等価です．

          m4 --reload-state=4.m4f input.m4

`--freeze'
`-f'
     固まった状態のファイルを生成します．`autom4te'の固め方は，M4より
     厳密です．警告を生成させたり，空の行(空白行は空の行では_ありません_)
     とコメント(`#'で始まります)以外の出力を生成してはいけません．
     `m4'とは異なり，このオプションは以下のように引数をとらないことに
     注意してください．

          autom4te 1.m4 2.m4 3.m4 --freeze --output=3.m4f

     これは以下に対応します．

          m4 1.m4 2.m4 3.m4 --freeze-state=3.m4f

`--mode=OCTAL-MODE'
`-m OCTAL-MODE'
     OCTAL-MODEにトレース出力以外のモードを設定します．デフォルトは
     `0666'です．


   それ以外の`m4'上の追加機能として，`autom4te'がその結果を
キャッシュするというものがあります．GNU M4は，標準出力を生成す
ると同時にトレースすることが可能です．トレースはGNUビルドシス
テムで重点的に使用されています．`autoheader'は，
`config.h.in'をビルドするために，`autoreconf'は，使用されて
いるGNUビルドシステムの構成要素を決定するために，
`automake'は`configure.ac'をパースするため等として使用して
います．`m4'の長い実行結果を保存するために，通常の展開を実行して
いる間，トレースはキャッシュされます(1)．このキャッシュ(実際には複数あ
る) は，ディレクトリ`autom4te.cache'に保存されます．いつでも
_削除して大丈夫です_(特に，理由があれば`autom4te'はそれが捨
てられてしまったと考えます)．

`--cache=DIRECTORY'
`-C DIRECTORY'
     結果をキャッシュするディレクトリの名前を指定します．空の値を渡すことで
     キャッシュが利用不可能になります．グローバルキャッシュがサポートされると
     きまで，相対パスで渡してください．

`--no-cache'
     結果をキャッシュしません．

`--force'
`-f'
     キャッシュが使用されている場合，時代遅れだと考えません(しかし，それはい
     ずれにせよ更新されます)．


   トレースはGNUビルドシステムに重きをおいて実装されているので，
`autom4te'は，M4と比較して高度なトレース機能を提供していて，キャッ
シュを利用する手助けとなります．

`--trace=MACRO[:FORMAT]'
`-t MACRO[:FORMAT]'
     FORMATによって，MACROの呼び出しをトレースします．複数の
     `--trace'引数は，いくつかのマクロリストを使用するために使用可能で
     す．単一マクロに対する複数の`--trace'引数は累積されません．その代
     わりに，必要な長さのFORMATにすべきです．

     FORMATは，必要なときは改行を用いていて，特殊なエスケープコードをも
     用いている通常の文字列です．デフォルトは`$f:$l:$n:$%'です．以下の特
     殊なエスケープ文字が使用可能です．

    `$$'
          文字`$'．

    `$f'
          MACROが呼び出されているファイル名．

    `$l'
          MACROが呼び出されている行番号．

    `$d'
          MACRO呼び出しの深さ．これはM4の技術的な詳細で，特に知りたいとは思
          わないでしょう．

    `$n'
          MACROの名前．

    `$NUM'
          MACRO呼び出しのNUM番目の引数．

    `$@'
    `$SEP@'
    `${SEPARATOR}@'
          文字SEPまたは文字列SEPARATORで分離されている，マクロに渡され
          ているすべての引数(デフォルトは`,')．それぞれの引数は引用符で囲まれ
          ています．すなわち，角カッコの組で囲まれています．

    `$*'
    `$SEP*'
    `${SEPARATOR}*'
          上と同じですが，引数は引用符で囲まれていません．

    `$%'
    `$SEP%'
    `${SEPARATOR}%'
          上と同じですが，引数は引用符で囲まれておらず，引数内部のすべての改行文字
          は取り除かれていて，そして，デフォルトの分離子は`:'です．

          エスケープの`$%'は，(`separator'に改行を書き込まない限り)一行
          のトレース出力を生成しますが，`$@'と`$*'はそうではありません．

     トレースの使用例は*Note autoconf Invocation::.

`--preselect=MACRO'
`-p MACRO'
     MACROのトレースをキャッシュしますが，キャッシュを利用可能にしませ
     ん．これは特に，将来のCPUサイクルを無駄にしないために重要です．例えば呼
     び出し時に，`m4'の実行でトレースする必要が無いように，
     `autoconf'は`autoheader'，`automake'，
     `autoreconf'などがトレースするすべてのマクロを前もって選択します．
     キャッシュは十分です．これは結果として非常に高速になります．


   最後に，`autom4te'は"Autom4teライブラリ(Autom4te libraries)"
の概念を導入します．それらは，強力ですが非常にシンプルな機能から成り立っ
ています．コマンドライン引数の組み合わせの組です．

`--language=LANGUAGE'
`-l =LANGUAGE'
     LANGUAGEをAutom4teライブラリで使用します．現在の言語は以下のものが
     含まれています．

    `M4sugar'
          M4sugar出力を作成します．

    `M4sh'
          M4shの実行可能なシェルスクリプトを作成します．

    `Autotest'
          Autotestの実行可能なテストスイートを作成します．

    `Autoconf'
          Autoconfの実行可能なコンフィグレーションスクリプトを作成します．

    `Autoconf-without-aclocal-m4'
          `aclocal.m4'を読み込まずに，Autoconfの実行可能なコンフィグレーショ
          ンスクリプトを作成します．

`--prepend-include=DIR'

`-B DIR'
     検索パスにディレクトリDIRを前置します．これは，サードパーティーの
     マクロの前に，言語指定ファイルを含めるために使用します．


   例として，Autoconfがデフォルトの場所`/usr/local'にインストールされ
ている場合，`autom4te -l m4sugar foo.m4'を実行することは， `autom4te
--prepend-include /usr/local/share/autoconf m4sugar/m4sugar.m4f
--warning syntax foo.m4'を実行することと厳密に等価と
なります．再帰的な展開も適用します．`autom4te --language m4sh
foo.m4'を実行することは，`autom4te --language M4sugar m4sugar/m4sh.m4f
foo.m4'と同じで，すなわち，`autom4te --prepend-include
/usr/local/share/autoconf m4sugar/m4sugar.m4f m4sugar/m4sh.m4f --mode
777 foo.m4'と同じになります．言語の定義は，
`autom4te.cfg'に保存されます．

   ---------- Footnotes ----------

   (1) 訳注：原文にある"and conversely"が何を指すのか分かりません．


File: autoconf-ja.info,  Node: Customizing autom4te,  Prev: autom4te Invocation,  Up: Using autom4te

8.2.2 `autom4te'のカスタマイズ
------------------------------

`~/.autom4te.cfg' (すなわち，ユーザのホームディレクトリにあるとき)
と，`./.autom4te.cfg' (すなわち，`autom4te'が実行されるディ
レクトリにあるとき)で，`autom4te'をカスタマイズすることが可能で
す．順番として，最初に`autom4te.cfg'を読み込み，そして
`~/.autom4te.cfg'，そして`./.autom4te.cfg'，そして最後にコマン
ドライン引数を読み込みます．

   これらのテキストファイルでは，コメントは`#'ではじまり，空の行は無視
されます．カスタマイズは，言語ごとを基本に実行され， `begin-language:
"LANGUAGE"'と`end-language: "LANGUAGE"'の組みで囲まれます．

   言語のカスタマイズとは，現在の言語の定義にオプションを追加すること
(*note autom4te Invocation::)を意味します．オプションと一般的な引数は，
`args: ARGUMENTS'で始まります．ARGUMENTSを引用符で囲む
ことによって伝統的なシェルの構文を使用してもかまいません．

   例として，Autoconfのキャッシュ(`autom4te.cache')を大域的に利用不可
能にするため，以下の行を`~/.autom4te.cfg'に含めます．


## ------------------ ##
## User Preferences.  ##
## ------------------ ##

begin-language: "Autoconf"
args: --no-cache
end-language: "Autoconf"


File: autoconf-ja.info,  Node: Programming in M4sugar,  Next: Programming in M4sh,  Prev: Using autom4te,  Up: Programming in M4

8.3 M4sugarでのプログラミング
=============================

M4自身は非常に小さいけれど十分な，汎用マクロの組を提供しています．
M4sugarは，追加の一般的なマクロを導入しています．その名前は，Lars J. Aas
によってつくり出されました："Readability And Greater Understanding
Stands 4 M4sugar"．

* Menu:

* Redefined M4 Macros::         M4 builtins changed in M4sugar
* Evaluation Macros::           More quotation and evaluation control
* Forbidden Patterns::          Catching unexpanded macros


File: autoconf-ja.info,  Node: Redefined M4 Macros,  Next: Evaluation Macros,  Up: Programming in M4sugar

8.3.1 M4マクロの再定義
----------------------

いくつか例外がありますが，全てのM4ネイティブなマクロは，`m4_'疑似名
前空間に移動されていて，例えば，M4sugarでは`define'を
`m4_define'に名前を変えるなどのようになっています．

M4マクロには再定義されているものもあり，ネイティブな同義語とわずかに互換
性がなくなっています．

 -- Macro: dnl
     このマクロは，もともとの名前を維持しています．`m4_dnl'は定義されて
     いません．

 -- Macro: m4_defn (MACRO)
     M4組み込みのものと比較して，このマクロは，MACROが定義されていない
     場合は失敗します．`m4_undefine'を参照してください．

 -- Macro: m4_exit (EXIT-STATUS)
     このマクロは`m4exit'に対応します．

 -- Macro: m4_if (COMMENT)
 -- Macro: m4_if (STRING-1, STRING-2, EQUAL, [NOT-EQUAL])
 -- Macro: m4_if (STRING-1, STRING-2, EQUAL, ...)
     このマクロは`ifelse'に対応します．

 -- Macro: m4_undefine (MACRO)
     M4組み込みのものとは異なり，このマクロはMACROが定義されていない場
     合は失敗します．以下のように使用してください．

          m4_ifdef([MACRO], [m4_undefine([MACRO])])

     それで，組み込みのものの動作に復旧します．

 -- Macro: m4_bpatsubst (STRING, REGEXP, [REPLACEMENT])
     このマクロは`patsubst'に対応します．`m4_patsubst'の名前は，
     `epatsubst'で拡張した正規表現の構文を提供する，GNU M4の最
     上位のM4shの将来のバージョンに対して残されています．

 -- Macro: m4_popdef (MACRO)
     M4組み込みのものとは異なり，このマクロはMACROが定義されていない場
     合は失敗します．`m4_undefine'を参照してください．

 -- Macro: m4_bregexp (STRING, REGEXP, [REPLACEMENT])
     このマクロは`regexp'に対応しています．`m4_regexp'の名前は，
     `eregexp'で拡張した正規表現の構文を提供する，GNU M4の最上
     位のM4shの将来のバージョンに対して残されています．

 -- Macro: m4_wrap (TEXT)
     このマクロは`m4wrap'に対応しています．

     二つの連続して呼び出される`m4_wrap'が，そのままトークンとして渡され
     るという予期しない結果となる危険が無いように，TEXTを`[]' で終
     えることが推奨されます．

          m4_define([foo], [Foo])
          m4_define([bar], [Bar])
          m4_define([foobar], [FOOBAR])
          m4_wrap([bar])
          m4_wrap([foo])
          =>FOOBAR


File: autoconf-ja.info,  Node: Evaluation Macros,  Next: Forbidden Patterns,  Prev: Redefined M4 Macros,  Up: Programming in M4sugar

8.3.2 マクロの評価
------------------

以下のマクロは，引用符のレベルを追加したり削除したりすることで，評価の順
序全体を制御するものです．それらは，ハードコアなM4プログラマに対して意味
があります．

 -- Macro: m4_dquote (ARG1, ...)
     引用符で囲まれたリストを引用符で囲んだ引数を返します．

 -- Macro: m4_quote (ARG1, ...)
     単一の要素として引数を返し，すなわち，一つの引用符の組でそれらを囲みます．

   以下の例は，(i)これらの例を使用していない，(ii)`m4_quote'を使用して
いる，(iii)`m4_dquote'を使用している，といったそれぞれの間の差を強
調することを目的としています．

     $ cat example.m4
     # Overquote, so that quotes are visible.
     m4_define([show], [$[]1 = [$1], $[]@ = [$@]])
     m4_divert(0)dnl
     show(a, b)
     show(m4_quote(a, b))
     show(m4_dquote(a, b))
     $ autom4te -l m4sugar example.m4
     $1 = a, $@ = [a],[b]
     $1 = a,b, $@ = [a,b]
     $1 = [a],[b], $@ = [[a],[b]]


File: autoconf-ja.info,  Node: Forbidden Patterns,  Prev: Evaluation Macros,  Up: Programming in M4sugar

8.3.3 禁止されているパターン
----------------------------

M4sugar提供の目的は，怪しげはパターン，つまり出力に現れるべきではないトー
クンを記述しているパターンを定義するためです．例えば，Autoconf
`configure'スクリプトに`AC_DEFINE'や`dnl'のようなトークン
が含められている場合，おそらく何か問題が発生するでしょう(通常は，余分な
引用符のためにマクロが評価されていないためです)．

   M4sugarは，`^m4_'と`^dnl$'に一致する全てのトークンを禁止します．

 -- Macro: m4_pattern_forbid (PATTERN)
     出力で見つかる必要のあるPATTERNにマッチするトークンを宣言しません．
     コメントは調査されません．これは，例えば，`#include'より後に展開さ
     れないまま残っているマクロがある場合に問題になるはずです．現在，Autoconf
     コミュニティでは合意がとおらず，コメント内で指名されているマクロを有効に
     すべきだと考えている人もいるからです(`#'のコメントは出力を説明する
     べきで，`dnl'コメントのように入力を説明するのではないため，このドキュ
     メントの著者には意味がありません)．

   もちろん，これらの一般的な規則の例外に遭遇する可能性もあり，例えば，
`$m4_flags'を参照する必要があるかもしれません．

 -- Macro: m4_pattern_allow (PATTERN)
     PATTERNに一致している全てのトークンが可能で，それには
     `m4_pattern_forbid'パターンに一致しているものも含まれます．


File: autoconf-ja.info,  Node: Programming in M4sh,  Prev: Programming in M4sugar,  Up: Programming in M4

8.4 M4shでのプログラミング
==========================

M4shは，"mash"と発音し，移植性の高いBourneシェルスクリプトを生成するこ
とが狙いです．この名前はLars J. Aasが発明し，Webster's Revised
Unabridged Dictionary (1913)にメモがあります．

     Mash \Mash\, n.  [Akin to G. meisch, maisch, meische, maische,
     mash, wash, and prob. to AS. miscian to mix.  See "Mix".]

       1. 混合成分の塊を，こう解や圧搾でパルプ状に軟らかくして絞った....

       2. 動物に与える粉餌やぬかと水を混ぜたもの．

       3. 混乱．トラブル．  [Obs.] -Beau. & Fl.

   今しばらくは，広範囲の使用に十分なほど熟していません．

M4shは，実験してみると残念ながら移植性が無い，一般的なシェルの構成に対す
る移植性の高い代替物を提供しています．

 -- Macro: AS_DIRNAME (PATHNAME)
     POSIXで要求されるアルゴリズムを使用しながら，PATHNAME の
     ディレクトリ部分を返します．これが返すものと，それが`dirname'コ
     マンドより移植性が高い理由の詳細は，*Note Limitations of Usual
     Tools::.

 -- Macro: AS_IF (TEST, [RUN-IF-TRUE], [RUN-IF-FALSE])
     シェルコードTESTを実行します．TESTがゼロのステータスで終了し
     た場合，シェルコードのRUN-IF-TRUEを実行し，それ以外ではシェルコー
     ドのRUN-IF-FALSEを実行し，RUN-IF-TRUEやRUN-IF-FALSEが
     空の場合は何もしません．

 -- Macro: AS_MKDIR_P (FILENAME)
     間に入る必要なディレクトリを含め，ディレクトリFILENAMEを作成します．
     これは`mkdir -p FILENAME'と等価ですが，`-p'オプション
     が無い古いバージョンの`mkdir'に移植性を持たせます．

 -- Macro: AS_SET_CATFILE (VAR, DIR, FILE)
     シェル変数VARをDIR/FILEに設定しますが，一般的に最適な
     ものにします(DIRやFILEが`.'のときはFILEは絶対パス になるなどです)．


File: autoconf-ja.info,  Node: Writing Autoconf Macros,  Next: Portable Shell,  Prev: Programming in M4,  Up: Top

9 Autoconfマクロを書く
**********************

一つ以上のソフトウェアパッケージに適用する特徴テストを書くとき，新しいマ
クロの中にそれをカプセル化することが最も良い方法です．Autoconfマクロを書
くための説明とガイドラインは以下のようになります．

* Menu:

* Macro Definitions::           Basic format of an Autoconf macro
* Macro Names::                 What to call your new macros
* Reporting Messages::          Notifying `autoconf' users
* Dependencies Between Macros::  What to do when macros depend on other macros
* Obsoleting Macros::           Warning about old ways of doing things
* Coding Style::                Writing Autoconf macros a` la Autoconf


File: autoconf-ja.info,  Node: Macro Definitions,  Next: Macro Names,  Up: Writing Autoconf Macros

9.1 マクロの定義
================

Autoconfマクロは，M4組み込みの`m4_define'マクロに似た
`AC_DEFUN'マクロを使用して定義されています．マクロ定義に加える際，
`AC_DEFUN'は，マクロを呼び出す順番を制限するために使用されるコード
を加えます(*note Prerequisite Macros::)．

   Autoconfマクロ定義は以下のようになります．

     AC_DEFUN(MACRO-NAME, MACRO-BODY)

   マクロに渡す引数は，`$1'，`$2'等のように参照することが可能です．
M4マクロを書く際の完全な情報は，*Note How to define new macros:
(m4.info)Definitions.

   マクロが偶然前に定義されている場合の問題を避けるために，
MACRO-BODY_と_MACRO-NAMEの両方を，適切に引用符で囲んで
いることを確かめてください．

それぞれのマクロには，そのプロトタイプと短い説明を付与するため，ヘッダの
コメントを書くべきです．引数がデフォルト値の場合，そのプロトタイプを表示
してください．例えば以下のようにします．

     # AC_MSG_ERROR(ERROR, [EXIT-STATUS = 1])
     # --------------------------------------
     m4_define([AC_MSG_ERROR],
     [{ _AC_ECHO([configure: error: $1], 2); exit m4_default([$2], 1); }])

マクロに関するコメントは，ヘッダコメントに残すべきです．その他のほとんど
のコメントは，勝手に`configure'に入るので，コメントを導入するために
`#'を使用し続けるだけで結構です．

ピュアなM4コードに関して，非常に特殊なコメントがある場合は，コメントを
`configure'とヘッダコメントに入れる意味がないので，組み込みの
`dnl'を使用してください．それでM4は，次の改行までのテキストを廃棄し
ます．

   `dnl'がコメントの導入に必要になることは滅多にないということを覚えて
おいてください．`dnl'は，`AC_REQUIRE'のような，出力を生成しな
いマクロに続く改行を除去するときに，より役に立ちます．


File: autoconf-ja.info,  Node: Macro Names,  Next: Reporting Messages,  Prev: Macro Definitions,  Up: Writing Autoconf Macros

9.2 マクロ名
============

全てのAutoconfマクロは，他のテキストと偶然衝突することを避けるため
`AC_'で始まる全て大文字の名前になっています．内部目的で使用する全て
のシェル変数は，`ac_'で始まるほとんど小文字の名前になっています．マ
クロが，現在または将来のAutoconfマクロと衝突しないことを保証するため，マ
クロ名と他の手続きで使用するシェル変数に，独自の接頭辞を付けてください．
可能性としては，イニシャルや組織やソフトウェアパッケージの名前の省略を含
めることになるでしょう．

ほとんどのAutoconfマクロ名は，名前によって調査している特徴の種類を示す，
構造化された命名則に続きます．複数の単語から成り立つマクロ名は，アンダー
スコアで分けられ，最も一般的なものから最も特殊なものへとなっています．
キャッシュ変数の名前も，同じ規則を使用しています(詳細は*note Cache
Variable Names::)．

   `AC_'の後の名前の最初の単語は，通常テストしている特徴のカテゴリを伝
えるものです．よく書くマクロの種類のテストマクロを指定するため，Autoconf
が使用するカテゴリは以下のようになっています．それらはキャッシュ変数でも
全て小文字で使用されます．適用可能なものを使用してください．無ければ独自
のカテゴリを考え出してください．

`C'
     C言語組み込み特徴．

`DECL'
     ヘッダファイルでのC変数の宣言．

`FUNC'
     ライブラリの関数．

`GROUP'
     ファイルのUNIXグループオーナー．

`HEADER'
     ヘッダファイル．

`LIB'
     Cライブラリ．

`PATH'
     プログラムを含むファイルのフルパス名．

`PROG'
     プログラムのベース名．

`MEMBER'
     集合体のメンバ．

`SYS'
     オペレーティングシステムの特徴．

`TYPE'
     C組み込みや宣言されている型．

`VAR'
     ライブラリのC変数．

カテゴリの後には，特定の特徴をテストしている名前が来ます．マクロ名のそれ
以外の単語は，特徴の特定の側面を示します．例えば，
`AC_FUNC_UTIME_NULL'は，`NULL'ポインタで呼び出されたときの
`utime'関数の動作を調査します．

内部マクロは，アンダースコアで始まる名前にすべきです．そのため，Autoconf
内部のものは`_AC_'で始まります．さらに，他のマクロ内部のサブルーチ
ンとなるマクロは，アンダースコアと他のマクロ名ではじまり，内部マクロが行
うことを伝える一つ以上の単語が続きます．例えば， `AC_PATH_X'は，内
部マクロに`_AC_PATH_X_XMKMF'と`_AC_PATH_X_DIRECT'があります．


File: autoconf-ja.info,  Node: Reporting Messages,  Next: Dependencies Between Macros,  Prev: Macro Names,  Up: Writing Autoconf Macros

9.3 メッセージの報告
====================

マクロが良性または悪性の異常な状況を静的に診断しているとき，以下のマクロ
を使用してそれを報告すべきです．動的な発行，すなわち`configure'
が実行されているときは，*Note Printing Messages::を参照してください．

 -- Macro: AC_DIAGNOSE (CATEGORY, MESSAGE)
     CATEGORYの警告をオンにしている場合，MESSAGEを警告として(また
     はユーザが要求する場合はエラーとして)報告します．以下の現在含められてい
     る標準的なカテゴリを使用することを勧めます．

    `all'
          以下のカテゴリの一つに分類されないメッセージです．空のCATEGORYを使
          用することと等価です．

    `cross'
          クロスコンパイルに関連する問題です．

    `obsolete'
          時代遅れの構成の使用です．

    `syntax'
          曖昧な構文構成，間違った順序のマクロ呼び出しです．

 -- Macro: AC_WARNING (MESSAGE)
     `AC_DIAGNOSE([syntax], MESSAGE)'と等価ですが，より良く分類さ
     れているカテゴリを使用することを推奨します．

 -- Macro: AC_FATAL (MESSAGE)
     ひどいエラーMESSAGEを報告し，`autoconf'は終了します．

   ユーザが`autoconf -W error'を実行しているとき，`AC_DIAGNOSE'
と`AC_WARNING'からの警告はエラーとして報告されます．*Note autoconf
Invocation::を参照してください．


File: autoconf-ja.info,  Node: Dependencies Between Macros,  Next: Obsoleting Macros,  Prev: Reporting Messages,  Up: Writing Autoconf Macros

9.4 マクロ間の依存性
====================

正確に動作するために，最初に他のマクロが呼び出されていることに依存する
Autoconfマクロもあります．Autoconfは，必要な場合はある特定のマクロが呼び
出されていることを保証する方法と，マクロが間違った処理を引き起こす順序で
呼び出された場合に警告する方法を供給します．

* Menu:

* Prerequisite Macros::         Ensuring required information
* Suggested Ordering::          Warning about possible ordering problems


File: autoconf-ja.info,  Node: Prerequisite Macros,  Next: Suggested Ordering,  Up: Dependencies Between Macros

9.4.1 マクロの必要条件
----------------------

書いているマクロが，以前に他のマクロが計算した値を使用する必要があるかも
しれません．例えば，`AC_DECL_YYTEXT'は，`flex'や`lex' の
出力を調査するので，シェル変数 `LEX'を設定するために，
`AC_PROG_LEX'が最初に呼び出されていることに依存します．

   マクロのユーザにそれら間の依存性を追跡させるより，自動的にするために
`AC_REQUIRE'を使用することが可能です．`AC_REQUIRE'は，必要な
場合のみマクロが呼び出され，そして一度だけ呼び出されることを保証します．

 -- Macro: AC_REQUIRE (MACRO-NAME)
     M4マクロMACRO-NAMEがまだ呼び出されていない場合，それを(引数無しで)
     呼び出します．角カッコでMACRO-NAMEを囲んでいることを確認してくださ
     い．MACRO-NAMEは，`AC_DEFUN'を使用して定義されている，または
     呼び出されていることを示す`AC_PROVIDE'の呼び出しを含んでいる必要が
     あります．

     `AC_REQUIRE'は`AC_DEFUN'マクロの内部で使用する必要があります．
     それはトップレベルから呼び出してはいけません．

   `AC_REQUIRE'はよく誤解されます．一つのマクロが他のものに依存してい
る場合，後者は前者の本体の_前に_展開されるように，それはマクロ間の
依存性を実装しています．特に，`AC_REQUIRE(FOO)'は，`FOO' の本
体では置換されません．例えば，マクロを以下のように定義したとします．

     AC_DEFUN([TRAVOLTA],
     [test "$body_temperature_in_celsius" -gt "38" &&
       dance_floor=occupied])
     AC_DEFUN([NEWTON_JOHN],
     [test "$hair_style" = "curly" &&
       dance_floor=occupied])

     AC_DEFUN([RESERVE_DANCE_FLOOR],
     [if date | grep '^Sat.*pm' >/dev/null 2>&1; then
       AC_REQUIRE([TRAVOLTA])
       AC_REQUIRE([NEWTON_JOHN])
     fi])

これを`configure.ac'で使用します．

     AC_INIT
     RESERVE_DANCE_FLOOR
     if test "$dance_floor" = occupied; then
       AC_MSG_ERROR([cannot pick up here, let's move])
     fi

それは以下のように展開されるので，土曜日の夜以外に仲間に会う機会が残って
いません．

     test "$body_temperature_in_Celsius" -gt "38" &&
       dance_floor=occupied
     test "$hair_style" = "curly" &&
       dance_floor=occupied
     fi
     if date | grep '^Sat.*pm' >/dev/null 2>&1; then


     fi

   この動作は意図的に選択されました．(i)
それは要求されるマクロのメッセージ
が，要求しているマクロのメッセージとして解釈されることを妨げます．(ii)
それは，シェルの条件文が使用されるときひどく驚くことを妨げます．以下のよ
うになります．

     if ...; then
       AC_REQUIRE([SOME_CHECK])
     fi
     ...
     SOME_CHECK

   マクロの最初に全ての`AC_REQUIRE'を書き込むことを推奨します．空の行
が残ることを避けるため，`dnl'を使用することが可能です．


File: autoconf-ja.info,  Node: Suggested Ordering,  Prev: Prerequisite Macros,  Up: Dependencies Between Macros

9.4.2 推奨される順序
--------------------

両方が呼び出されても，片方がもう一方が呼び出されることを_要求_しな
い場合，もう一方のマクロの前に実行するすべきマクロもあります．例えば，C
コンパイラの動作を変更するマクロは，Cコンパイラを実行するあらゆるマクロ
の前に呼び出されるべきです．これらの依存性の多くはドキュメントに記されて
います．

   Autoconfは，これらの依存性を持つマクロが`configure.ac'ファイルで順
序が間違って現れるとき，ユーザに警告する`AC_BEFORE'を提供しています．
警告は，`configure.ac'から`configure'を作成するときに発生し
ますが，`configure'実行時には発生しません．

   例えば`AC_PROG_CPP'は，Cコンパイラに`-E'オプションが与えられて
いるとき，Cプリプロセッサが実行可能かどうか調査します．従って，使用され
るCコンパイラが変更される`AC_PROG_CC'のようなマクロの後で，それは呼
び出すべきです．そのため，`AC_PROG_CC'は以下を含んでいます．

     AC_BEFORE([$0], [AC_PROG_CPP])dnl

これで，`AC_PROG_CC'が呼び出されたとき，`AC_PROG_CPP'が既に呼
び出されている場合，ユーザに警告します．

 -- Macro: AC_BEFORE (THIS-MACRO-NAME, CALLED-MACRO-NAME)
     CALLED-MACRO-NAMEが既に呼び出されている場合，M4は標準エラー出力に
     警告メッセージを出力します．THIS-MACRO-NAMEは，`AC_BEFORE'を
     呼び出すマクロの名前にすべきです．マクロCALLED-MACRO-NAMEは，
     `AC_DEFUN'を使用して定義されている，または呼び出されていることを示
     す`AC_PROVIDE'の呼び出しを含んでいる必要があります．


File: autoconf-ja.info,  Node: Obsoleting Macros,  Next: Coding Style,  Prev: Dependencies Between Macros,  Up: Writing Autoconf Macros

9.5 時代遅れのマクロ
====================

コンフィグレーションと移植性の技術は，何年もかかって進展しました．特定の
問題を解決するより良い方法が開発されたり，特別なアプローチが体系化される
ことはよくあります．この過程はAutoconfの数多くの部分で発生しました．一つ
の結果は，今では"時代遅れ(obsolete)"と思われるマクロの存在です．まだ
動作しますが，すでにそれが最善の方法ではなくなっていて，より近代的なマク
ロで置換すべきでしょう．理想的には，`autoupdate'が古いマクロの呼
び出しを現在のマクロに置換すべきでしょう．

Autoconfは，マクロが時代遅れだということを意味する単純なものを提供してい
ます．

 -- Macro: AU_DEFUN (OLD-MACRO, IMPLEMENTATION, [MESSAGE])
     IMPLEMENTATIONとしてOLD-MACROを定義します．`AC_DEFUN'
     を用いたものとは，OLD-MACROが現在は時代遅れだという警告をユーザが
     受けるところだけが異なります．

     `autoupdate'を使用する場合，OLD-MACROの呼び出しは現在の
     IMPLEMENTATIONで置換されます．更に，MESSAGEが出力されます．

