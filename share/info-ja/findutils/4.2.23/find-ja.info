-*- coding: utf-8 -*-
INFO-DIR-SECTION Basics
START-INFO-DIR-ENTRY
* Finding files(ja): (find-ja).        Operating on files matching certain criteria.
END-INFO-DIR-ENTRY

INFO-DIR-SECTION Individual utilities
START-INFO-DIR-ENTRY
* find(ja): (find-ja)Invoking find.                Finding and acting on files.
* locate(ja): (find-ja)Invoking locate.            Finding files in a database.
* updatedb(ja): (find-ja)Invoking updatedb.        Building the locate database.
* xargs(ja): (find-ja)Invoking xargs.              Operating on many files.
END-INFO-DIR-ENTRY

   This file documents the GNU utilities for finding files that match
certain criteria and performing various operations on them.

   Copyright (C) 1994, 1996, 1998, 2000, 2001, 2003, 2004, 2005 Free
Software Foundation, Inc.

   Permission is granted to make and distribute verbatim copies of this
manual provided the copyright notice and this permission notice are
preserved on all copies.

   Permission is granted to copy and distribute modified versions of
this manual under the conditions for verbatim copying, provided that
the entire resulting derived work is distributed under the terms of a
permission notice identical to this one.

   Permission is granted to copy and distribute translations of this
manual into another language, under the above conditions for modified
versions, except that this permission notice may be stated in a
translation approved by the Foundation.


File: find-ja.info,  Node: Top,  Next: Introduction,  Up: (dir)

このファイルは，特定の基準にマッチするファイルを検索し，それらに様々な
アクションを実行するGNUユーティリティの説明です．これは，`find'の
バージョン4.2.23に対する，エディション4.2.23です．

* Menu:

* Introduction::                Summary of the tasks this manual describes.
* Finding Files::               Finding files that match certain criteria.
* Actions::                     Doing things to files you have found.
* Common Tasks::                Solutions to common real-world problems.
* Databases::                   Maintaining file name databases.
* File Permissions::            How to control access to files.
* Reference::                   Summary of how to invoke the programs.
* Security Considerations::     Security issues relating to findutils.
* Error Messages::              Explanations of some messages you might see.
* Primary Index::               The components of `find' expressions.


File: find-ja.info,  Node: Introduction,  Next: Finding Files,  Prev: Top,  Up: Top

1 はじめに
**********

このマニュアルは，指定した基準に合ったファイルを検索する方法と，見つけ
たファイルに様々なアクションを実行する方法を示します．これらの作業を実
行するために使用する主なプログラムは，`find'，`locate'，そし
て`xargs'です．このマニュアルにある例は，これらのプログラムのGNUバー
ジョン特有の能力を使用します．

   GNU `find'は，元々Eric Deckerによって書かれ，David MacKenzie，Jay
Plett，そしてTim Woodによって拡張されました．GNU `xargs'は，元々 Mike
Rendellによって書かれ，David MacKenzieによって拡張されました．GNU
`locate'とそれに関連するユーティリティは，元々James Woodsによって
書かれ，David MacKenzieよって拡張されました．`find -print0'と `xargs
-0'に関するアイデアは，Dan Bernsteinによります．GNU findutils
(とこのマニュアル)の現在の監理者はJames Youngman.です．その他，
多くの人がバグの修正，小さな改良，そして有益な提案を寄与してくれました．
どうもありがとう！

   これらのプログラムに関するメールでの提案とバグの報告先は
`bug-findutils@gnu.org'になります．`find --version'を実行し
て得られるバージョンナンバーを含めてください．

* Menu:

* Scope::
* Overview::
* find Expressions::


File: find-ja.info,  Node: Scope,  Next: Overview,  Up: Introduction

1.1 スコープ
============

簡潔にするため，このマニュアル内の単語"ファイル(file)"は，通常のファ
イル，ディレクトリ，シンボリックリンク，またはディレクトリエントリを持
つノードのようなその他のあらゆるものを意味します．ディレクトリエントリ
は"ファイル名(file name)"とも呼ばれます．ファイル名は，ファイルに前
置されるパス内のディレクトリを，いくつか含む，すべて含む，または全く含
まないかもしれません．このマニュアルで"ファイル名"と呼ばれるもののす
べての例は以下のものです．

     parser.c
     README
     ./budget/may-94.sc
     fred/.cshrc
     /usr/local/include/termcap.h

   "ディレクトリツリー(file name)"はディレクトリとそれが含むファイル，
そのすべてのサブディレクトリとそれが含むファイル等です．それは，単一の
ディレクトリではないファイルにすることも可能です．

これらのプログラムは，一つまたはそれ以上のディレクトリツリー内部の，以
下のようなファイルを見つけることを可能にします．

   * 特定のテキストや特定のパターンにマッチする名前を持つもの．

   * 特定のファイルにリンクしているもの．

   * 最近の特定の期間に使用されたもの．

   * 特定の大きさの範囲にあるもの．

   *
     特定の形式(通常のファイル，ディレクトリ，シンボリックリンク等)のもの．

   * 特定のユーザやグループに所有されているもの．

   * 特定のアクセス権限を持つもの．

   * 特定のパターンにマッチするテキストを含むもの．

   * ディレクトリツリーの特定の深さにあるもの．

   * 上記の組み合わせ．

一旦，探しているファイル(または，探している可能性があるファイル)を見つ
けると，単純なそれらの名前のリスト以上のものにすることが可能です．ファ
イルを個別に，または様々な大きさのまとまりとして，属性のあらゆる組み合
わせを取得したり，多くの方法で処理したりすることが可能です．見つけたファ
イル上で実行したい動作は，以下のことだけに制限されません．

   * 閲覧または編集．

   * アーカイブへ保存．

   * 削除や名前の変更．

   * アクセス権限の変更．

   * グループ分け．

このマニュアルでは，これらのそれぞれの作業を実行する方法と，それ以上の
ものを記述しています．


File: find-ja.info,  Node: Overview,  Next: find Expressions,  Prev: Scope,  Up: Introduction

1.2 概要
========

与えられた基準にマッチするファイルのリストを作成し，その上でコマンドを
実行するために使用される主なプログラムは，`find'，`locate'，
そして`xargs'です．追加のコマンドは`updatedb'で，それは `locate'
が使用するデータベースを作成するために，システム管理者が 使用します．

   `find'はディレクトリ階層内でファイルを検索し，見つかったファイルの
情報を出力します．以下のように実行します．

     find [FILE...] [EXPRESSION]

ここに典型的な`find'の使用方法があります．この例では， `/usr/src'
をルートとしたディレクトリツリー内で，名前が`.c'で
終り，100Kバイト以上の大きさを持つ，すべてのファイルの名前を出力します．
     find /usr/src -name '*.c' -size +100k -print

ワイルドカードは，シェルでの展開から守るため，確実に引用符で囲む必要が
あることに注意してください．

   `locate'は，特別なファイル名のデータベースで，パターンにマッチする
ファイル名を探します．システム管理者は，データベースを作成するために
`updatedb'を実行します．`locate'は以下のように実行します．

     locate [OPTION...] PATTERN...

この例は，デフォルトファイル名のデータベースで，名前が`Makefile'ま
たは`makefile'で終わる，すべてのファイルの名前を出力します．データ
ベースに保存されるファイル名は，システム管理者が`updatedb'を実行し
た方法に依存します．
     locate '*[Mm]akefile'

   名前`xargs'は，EX-argsと発音され，それは"引数を統合する"という意
味があります．`xargs'は，標準入力から読み込む引数をかき集めてコマ
ンド行を構築し実行します．これらの引数は，`find'で生成されるファイ
ル名のリストとなることが最も多くなっています．`xargs'は，以下のよ
うに実行します．

     xargs [OPTION...] [COMMAND [INITIAL-ARGUMENTS]]

以下のコマンドは，ファイル`file-list'内にリストアップされているファ
イルを検索し，単語`typedef'を含むもののすべての行を出力します．
     xargs grep typedef < file-list


File: find-ja.info,  Node: find Expressions,  Prev: Overview,  Up: Introduction

1.3 `find'の式
==============

ファイルを選択するために`find'が使用する式は，一つまたはそれ以上の
"プライマリ(primaries)"から成り立ち，それらはそれぞれ分離した
`find'へのコマンドライン引数です．`find'はそのたびに式を評価
し，ファイルを処理します．式は以下のプライマリの形式のいずれかを含むこ
とが可能です．

"オプション(options)"
     特定のファイルの処理ではなく全体的な処理に影響を与えます．

"テスト(tests)"
     ファイルの属性に依存し，真または偽の値を返します．

"アクション(actions)"
     それらを評価するとき他の引数と連結し影響を与えます．

   二つのプライマリの間のオペレータは省略可能です．そのデフォルトは
`-and'です．プライマリをより複雑な式に連結する方法は， *Note Combining
Primaries With Operators::.  式が`-prune'以外のアク
ションを含まない場合，全部の式が真になるすべてのファイルで，
`-print'が動作します(*note Print File Name::)．

式の中にオプションがあるとき，それぞれのファイルに対し評価されるのでは
なく，すぐに影響を与えます．そのため，明確にするため，式の最初にそれら
を配置するのが最善です．

   プライマリの多くは引数をとり，それらは`find'への次のコマンドライン
引数の直後に続きます．引数は，ファイル名，パターン，またはその他の文字
列になるものもあります．それ以外は数字です．数字の引数は以下のように指
定することが可能です．

`+N'
     Nより大きい．

`-N'
     Nより小さい．

`N'
     Nに等しい．


File: find-ja.info,  Node: Finding Files,  Next: Actions,  Prev: Introduction,  Up: Top

2 ファイル検索
**************

デフォルトで，`find'は標準出力に，与えられた基準にマッチするファイ
ルの名前を出力します．マッチしたファイルに関する詳細を取得する方法は，
*Note Actions::.

* Menu:

* Name::
* Links::
* Time::
* Size::
* Type::
* Owner::
* Permissions::
* Contents::
* Directories::
* Filesystems::
* Combining Primaries With Operators::


File: find-ja.info,  Node: Name,  Next: Links,  Up: Finding Files

2.1 名前
========

基準パターンにマッチする名前を持つファイルを検索する方法は，以下のよう
になります．これらのテストでのPATTERN引数の記述については， *Note Shell
Pattern Matching::.

   これらのテストには，`i'で始まる名前を持つ，大文字小文字を区別バー
ジョンと区別しないバージョンがあります．大文字小文字を区別しない比較で
は，パターン`fo*'と`F??'は，ファイル名`Foo'，`FOO'，
`foo'，`fOo'等にマッチします．

* Menu:

* Base Name Patterns::
* Full Name Patterns::
* Fast Full Name Search::
* Shell Pattern Matching::      Wildcards used by these programs.


File: find-ja.info,  Node: Base Name Patterns,  Next: Full Name Patterns,  Up: Name

2.1.1 ベース名のパターン
------------------------

 -- Test: -name pattern
 -- Test: -iname pattern
     ファイル名のベース(前置されるディレクトリが削除されたパス)がシェルパター
     ンPATTERNにマッチする場合は真です．`-iname'の場合は，大文字
     小文字の区別をしないマッチです．ディレクトリツリー全体を無視するために，
     `-prune'を使用して下さい(*note Directories::)．例として，
     `/usr/local/doc'のTexinfoソースファイルを見つけるため以下のように
     します．

          find /usr/local/doc -name '*.texi'

ワイルドカードは，シェルでの展開から守るため，確実に引用符で囲む必要が
あることに注意してください．

   `-name'と`-iname'に対するパターンは，前に`.'が付いている
ファイル名にもマッチします．例えば，コマンド`find /tmp -name \*bar'
はファイル`/tmp/.foobar'にマッチします．


File: find-ja.info,  Node: Full Name Patterns,  Next: Fast Full Name Search,  Prev: Base Name Patterns,  Up: Name

2.1.2 完全なファイル名のパターン
--------------------------------

 -- Test: -wholename pattern
 -- Test: -iwholename pattern
     コマンドライン引数で始まる見つかったファイルのファイル名全体が，シェル
     パターンPATTERNにマッチする場合は真になります．
     `-iwholename'では，マッチ時に大文字小文字を区別します．ディレクト
     リツリーのすべてのファイルを調査するのではなく，ディレクトリツリー全体
     を無視するために，`-prune'を使用してください(*note Directories::)．
     `find'が使用する"entire file name"は，コマンドラインで指定す
     る起点で，絶対パスに変換されないので，例えば，`cd /; find tmp
     -wholename /tmp'では何にもマッチしません．

 -- Test: -path pattern
 -- Test: -ipath pattern
     これらのテストは推奨されませんが，`-wholename'と
     `-iwholename'は，それぞれ動作します．`-ipath'のテストはGNUの
     拡張ですが，`-path'はHP-UX `find'でも提供されています．

 -- Test: -regex expr
 -- Test: -iregex expr
     ファイル名全体が正規表現EXPRにマッチする場合は真です．これはパス
     全体へのマッチで，サーチではありません．例えば，`./fubar3'というファ
     イル名にマッチさせるため，正規表現`.*bar.'や`.*b.*3'は使用可
     能ですが，`f.*r3'は不可能です．正規表現の構文の記述は， *Note
     Syntax of Regular Expressions: (emacs)Regexps.
     `-iregex'の場合は，大文字小文字を区別しません．


File: find-ja.info,  Node: Fast Full Name Search,  Next: Shell Pattern Matching,  Prev: Full Name Patterns,  Up: Name

2.1.3 すばやい完全な名前の検索
------------------------------

実際にディスク上のディレクトリをスキャンすることなく(きっと遅いでしょ
う)，ファイルを名前で検索するために，`locate'プログラムを使用する
ことが可能です．与えたそれぞれのシェルパターンに対し，`locate'は，
一つ，またはそれ以上のファイル名のデータベースを検索し，パターンを含む
ファイル名を表示します．シェルパターンの詳細は，*Note Shell Pattern
Matching::.

   パターンが--メタ文字を含まない--通常の文字列の場合，`locate'は，
文字列を含むすべてのファイル名を表示します．パターンがメタ文字を含む場
合，`locate'はパターンに正確にマッチしているファイル名のみ表示しま
す．結果として，メタ文字を含むパターンは，通常`*'で開始すべきで，
同じもので終わることが最も多くなっています．例外は，ファイル名の最初ま
たは最後への，明示的なマッチを試みるパターンです．

   `locate'をファイル名の最後の部分(ファイルの"ベース名")に対しての
みマッチさせたい場合，`--basename'を使用することが可能です．反対の
動作がデフォルトですが，`--wholename'オプションを使用して，明示的
に選択することが可能です．

   以下のコマンドを考えます．
     locate PATTERN

   以下とほとんど等価です．
     find DIRECTORIES -name PATTERN

   ここでのDIRECTORIESは，情報を含んでいるファイル名データベースのディ
レクトリです．違いは`locate'情報が古い可能性があり，そして，
`locate'は`find'とわずかに異なるパターンでワイルドカードを扱
うことです(*note Shell Pattern Matching::) ．

ファイル名データベースには，データベースが最後に更新されたときにシステ
ムに存在したファイルのリストが含まれています．システム管理者はデフォル
トのデータベースのファイル名，データベースを更新する頻度，そして，エン
トリーを含むディレクトリを選択することが可能です．

   `locate'が検索するファイル名データベースを選択する方法は以下のよう
になります．デフォルトはシステムに依存します．

`--database=PATH'
`-d PATH'
     デフォルトのファイル名データベースを検索する代わりに，PATH内のファ
     イル名データベースを検索し，それはコロンで分けられたデータベースのファ
     イル名リストとなります．検索するデータベースファイルのリストを設定する
     ために，環境変数`LOCATE_PATH'を使用することも可能です．両方使用さ
     れている場合，オプションは環境変数に優先します．


File: find-ja.info,  Node: Shell Pattern Matching,  Prev: Fast Full Name Search,  Up: Name

2.1.4 シェルパターンマッチング
------------------------------

`find'と`locate'は，ファイル名やファイル名の一部を，シェルパ
ターンと比較することが可能です．"シェルパターン(hell pattern)"は，
以下の特殊文字を含む文字列で，それは"ワイルドカード(wildcards)"や
"メタ文字(metacharacters)"として知られています．

メタ文字を含むパターンを，シェルがそれ自身を展開することから避けるため
引用符で囲む必要があります．二重引用符とシングル引用符の両方が動作しま
す．そのため，(それ自身は)バックスラッシュでエスケープします．

`*'
     ゼロ以上の文字にマッチします．

`?'
     あらゆる一文字にマッチします．

`[STRING]'
     文字列STRINGに存在する，正確に一文字にマッチします．これは"文
     字集合(character class)"と呼ばれます．短いものとして，STRINGには
     範囲を含めることが可能で，それは間にダッシュがある二つの文字です．例え
     ば，集合`[a-z0-9_]'は小文字，数字，またはアンダースコアです． `!'
     や`^'を開括弧の前に配置することで，否定集合も可能です．
     このため，`[^A-Z@]'は大文字とアットマーク以外にマッチします．

`\'
     それ以降の特殊文字の意味をなくします．これは文字集合でも動作します．

   `find'がシェルのパターンマッチ(`-name'，`-wholename'等)
で行なうテストでは，パターンの中のワイルドカードはファイル名の最初の
`.'にマッチしません．これは`locate'ではそうなりません．このた め，`find
-name '*macs''は`locate '*macs''だけでなく `.emacs'にもマッチします．

   スラッシュ文字は，`find'と`locate'が行なうシェルのパターンマッ
チでは特殊な意味が無いので，ワイルドカードがそれにマッチしないシェルと
は異なります．そのため，パターン`foo*bar'はファイル名
`foo3/bar'にマッチし，パターン`./sr*sc'はファイル名
`./src/misc'にマッチするはずです．

   `locate'コマンドでファイルの場所を知りたいが，完全なリストを見る必
要は無い場合，ちょっとした数の結果を見る`--limit'オプションや，マッ
チの総数だけを表示する`--count'オプションを使用することが可能です．


File: find-ja.info,  Node: Links,  Next: Time,  Prev: Name,  Up: Finding Files

2.2 リンク
==========

ファイルをお互いにリンクすること可能にする方法は二つあります．"シン
ボリックリンク(symbolic link)"は，他のファイルの名前の部分が内容になる，
ファイルの特殊な形式です．"ハードリンク(hard link)"は，一つのファイ
ルに対する，複数のディレクトリエントリです．ファイル名はすべて，同じイ
ンデックスノード("inode")番号をディスク上に持ちます．

* Menu:

* Symbolic Links::
* Hard Links::


File: find-ja.info,  Node: Symbolic Links,  Next: Hard Links,  Up: Links

2.2.1 シンボリックリンク
------------------------

シンボリックリンクとは，他のファイルを参照する名前です．GNU
`find'は，シンボリックリンクを二つの方法のいずれかで処理します．最
初のものは，リンク先を参照する方法で，これはシンボリックリンクの場合は，
指定した特徴にマッチするかどうかを確認するため，リンク先のファイルを調
査することを意味します．二番目の方法は，実際のリンクを探している状況で，
リンク自身を調査することが可能です．シンボリックリンクのリンク先のファ
イルも，`find'コマンドで検索しているディレクトリ階層にある場合，こ
れら二つの選択肢の違いを詳しく理解しておく必要はありません．

   デフォルトで，`find'はシンボリックリンクが見つかると，それ自身を調
査します(そして，その後でリンク先のファイルをたどり，それも調査します)．
`find'にリンク先を参照するようにし，リンクが示すファイルを調査させ
るため，`find'で`-L'オプションを指定してください．デフォルト
の動作を明示的に指定するため，`-P'オプションを使用することが可能で
す．`-H'オプションは中間的なオプションで，コマンドラインでリストアッ
プされているシンボリックリンクはリンク先を参照しますが，それ以外のシン
ボリックリンクはリンク先を参照しません．

   シンボリックリンクは"ハードリンク"とは異なり，リンク先を参照可能にす
るために，リンク先のファイルへの権限が必要になることを意味します．つま
り，`-L'オプションを指定している場合でも，`find'はリンクが示
すファイルの属性を(十分な権限が無いという理由で)調査することができない
可能性があります．この状況では，`find'はリンク自身の属性を使用しま
す．シンボリックリンクは存在するが，それが指し示すファイルが無い場合も，
同じようなことになります．

   リンクに関連した`find'の動作を制禦するオプションには，以下のものが
あります．

`-P'
     `find'はシンボリックリンク先を参照しません．これはデフォルトの動作
     です．このオプションは，コマンドラインのパス名の前に指定する必要があり
     ます．

`-H'
     `find'はシンボリックリンク先を参照しません(しかし，コマンドライン
     上ののファイル名はリンク先を参照します)．シンボリックリンク先を参照でき
     ない場合，シンボリックリンク自身の情報が使用されます．このオプションは，
     コマンドラインのパス名の前に指定する必要があります．

`-L'
     `find'は，可能であればシンボリックリンク先を参照し，不可能なところ
     では，シンボリックリンク自身の属性を使用します．このオプションはコマン
     ドラインのパス名の前に指定する必要があります．このオプションを使用する
     と，`-noleaf'オプションと同じ動作も暗黙に指定されます．後で
     `-H'や`-P'オプションを使用する場合でも，`-noleaf'はオフ
     になりません．

`-follow'
     このオプションは，"expression"の部分の形式で，パス名の後に指定する必
     要がありますが，それ以外は`-L'と同じです．

   `-L'オプションを与えた時の動作には，以下の違いがあります．

   * `find'は，ディレクトリツリーを検索するとき，ディレクトリへのシンボ
     リックリンクをたどります．

   * `-lname'と`-ilname'は常に偽を返します(ただし，壊れたシンボリッ
     クリンクにマッチしない限り)．

   * `-type'はシンボリックリンクが示すファイルの形式を報告します．

   * 暗黙に`-noleaf'を指定します(*note Directories::)．

   `-L'オプションまたは`-H'オプションが使用されている場合，
`-newer'，`-anewer'，そして`-cnewer'の引数として使用され
ているファイル名は，リンク先を参照され，リンク先のタイムスタンプが代わ
りに使用されます(可能であれば - そうでなければ，シンボリックリンクのタ
イムスタンプが使用されます)．

 -- Test: -lname pattern
 -- Test: -ilname pattern
     ファイルがシェルパターンPATTERNにマッチする内容のシンボリックリン
     クの場合は真です．`-ilname'は，大文字小文字を区別しないマッチです．
     PATTERN引数の詳細は，*Note Shell Pattern Matching::.  `-L'の
     効果がある場合，このテストはシンボリックリンクが壊れていない限り，常に
     失敗します．そして，現在のディレクトリとそのサブディレクトリ内の，
     `sysdep.c'へのシンボリックリンクをすべてリストアップするために，以
     下のように実行します．

          find . -lname '*sysdep.c'


File: find-ja.info,  Node: Hard Links,  Prev: Symbolic Links,  Up: Links

2.2.2 ハードリンク
------------------

ハードリンクは，同じファイルを参照する一つ以上の名前を提供します．同じ
ファイルを参照している全てのファイルをNAMEで見つけるため， `-samefile
NAME'を使用してください．`-L'オプションを使用して
いない場合，`-xdev'オプションを使用して，検索を一つのファイルシス
テムに制限することが可能です．ハードリンクは単一のファイルシステム以外
を指し示すことができないため，不必要な検索を停止することができるので，
これは役に立ちます．

   `-L'オプションの効果があり，NAMEが実際にはシンボリックリンク
の場合，シンボリックリンクの参照先を参照します．このため，NAMEが
示すファイル以外のリンク(ハードリンクまたはシンボリックリンク)を検索し
ます．`-L'の効果があり，NAMEがシンボリックリンクではない場合，
ファイルNAMEへのシンボリックリンクがマッチします．

inode番号でファイルを検索することも可能です．例えば，ファイルシステムの
問題を診断するとき，`fsck'がinode番号を出力するので，これは役に立
ちます．inode番号は，ソフトウエアのログメッセージの形式で出力されること
もあり，`ftok()'ライブラリ関数のサポートで使用されています．

   ファイルのinode番号とリンク数を`ls -li'や`find -ls'で知ること
が可能です．

   inode番号NUMへのハードリンクを`-inum NUM'で検索することが可
能です．検索を開始したディレクトリ以下に，ファイルシステムのマウントポ
イントがある場合，`-L'オプションを使用していない場合は
`-xdev'オプションを使用してください．ハードリンク差機のファイルは
同じファイルシステムであることが必要なので，`-xdev'を使用すること
で不必要な検索といった無駄を省きます．

 -- Test: -samefile NAME
     NAMEと同じinodeを持つファイルの調査です．`-L'オプションに効
     果がある場合，同一ファイルNAMEへのシンボリックリンクもマッチしま
     す．

 -- Test: -inum n
     inode番号Nを持つファイルの調査．`+'と`-'の修飾辞も動作
     するのですが，滅多に役に立ちません．

   `-links'を用いると，特定の数のリンクを持つファイルを検索することも
可能です．ディレクトリは通常，少なくとも二つのハードリンクがあります．
それらの`.'エントリは二番目のものです．サブディレクトリがある場合，
それは個別に親ディレクトリを示す`..'と呼ばれるハードリンクもありま
す．通常，`.'と`..'のディレクトリエントリーは，`find'の
コマンドラインに書かれていない限り検索されません．

 -- Test: -links n
     N個のハードリンクを持つファイルの調査．

 -- Test: -links +n
     N個の以上のハードリンクを持つファイルの調査．

 -- Test: -links -n
     N個未満ののハードリンクを持つファイルの調査．


File: find-ja.info,  Node: Time,  Next: Size,  Prev: Links,  Up: Finding Files

2.3 時間
========

それぞれのファイルには三つのタイムスタンプがあり，それらはファイルに対
して特定の処理を実行した，最後の時間を記録します．

  1. アクセス(ファイルの内容を読み込む)

  2. ステータスの変更(ファイルの編集や属性の変更)

  3. 編集(ファイルの内容を変更)

   ファイルが_作成された_時間を示すタイムスタンプはありません．

タイムスタンプが特定の範囲にあるファイルを検索したり，他のタイムスタン
プと比較したりすることが可能です．

* Menu:

* Age Ranges::
* Comparing Timestamps::


File: find-ja.info,  Node: Age Ranges,  Next: Comparing Timestamps,  Up: Time

2.3.1 期間の範囲
----------------

これらのテストは，範囲(`+N'と`-N')を用いる場合に， 主に役立ちます．

 -- Test: -atime n
 -- Test: -ctime n
 -- Test: -mtime n
     ファイルの最後のアクセス(またはステータスの変更，または編集)が，
     N*24時間前の場合は真です．24時間の数の区切りは，ファイルのタイム
     スタンプが常に切り捨てで処理されます．このため，0は"24時間未満"，1は
     "24〜48時間の間"といった感じになります．

 -- Test: -amin n
 -- Test: -cmin n
 -- Test: -mmin n
     ファイルの最後のアクセス(またはステータスの変更，または編集)が，
     N分前の場合は真です．これらのテストは，`-atime'等よりも細か
     な計測を提供しますが，同じ方法で切り捨てられます．例えば，
     `/u/bill'内の最後に読み込まれたのが2〜6分前のファイルをリストアッ
     プするために以下のようにします．

          find /u/bill -amin +2 -amin -6

 -- Option: -daystart
     24時間前ではなく今日の最初から時間をはかります．そのため，ホームディレ
     クトリ内で昨日編集された通常のファイルをリストアップするために，以下の
     ようにします．

          find ~ -daystart -type f -mtime 1

   `-daystart'オプションは，それ以外のオプションとは異なり，他の調査
の実行に効果を与える方法です．影響される調査は，`-amin'，
`-cmin'，`-mmin'，`-atime'，`-ctime'，そして `-mtime'です．


File: find-ja.info,  Node: Comparing Timestamps,  Prev: Age Ranges,  Up: Time

2.3.2 タイムスタンプの比較
--------------------------

タイムスタンプを現在の時間と比較する代わりに，それを他のファイルのタイ
ムスタンプと比較することが可能です．そのファイルのタイムスタンプは，い
くつかのイベントによって，他のプログラムによって更新されるかもしれませ
ん．また，`touch'コマンドを使用して，特定の固定した日付に設定する
こともできるでしょう．例えば，今年の一月一日以降に編集された
`/usr'内のファイルをリストアップするために，以下のようにします．

     touch -t 02010000 /tmp/stamp$$
     find /usr -newer /tmp/stamp$$
     rm -f /tmp/stamp$$

 -- Test: -anewer file
 -- Test: -cnewer file
 -- Test: -newer file
     ファイルが最後にアクセス(またはステータスの変更，または編集)されたのが
     FILEの編集以降の場合は真です．これらのテストは，`-follow'が
     コマンドラインのそれら(のオプション)の前にある場合のみ，`-follow'
     影響を受けます．

          find . -newer /bin/sh

 -- Test: -used n
     ファイルが最後にアクセスされたのが，そのステータスが最後に変更されてか
     らN日後の場合は真です．使用されておらず，ディスクスペースを確保す
     るために圧縮または削除されたファイルを探すのに役立ちます．


File: find-ja.info,  Node: Size,  Next: Type,  Prev: Time,  Up: Finding Files

2.4 サイズ
==========

 -- Test: -size n[bckwMG]
     切上げでN単位領域をファイルが使用している場合は真です．単位はデフォ
     ルトで512バイトブロックですが，Nの接尾子として一文字加えることで
     変更することが可能です．

    `b'
          512バイトブロック単位(1024にはなりません)

    `c'
          バイト単位

    `k'
          キロバイト(1024バイト)単位

    `w'
          2バイトワード単位

    `M'
          メガバイト単位

    `G'
          ギガバイト単位

     `b'の接尾辞は常に512バイトのブロックを想定します．これは，
     `POSIXLY_CORRECT'環境変数の設定(または未設定)に影響されません．この
     の動作は`-ls'の動作とは異なります．1024バイト単位を使用したい場合，
     `k'接尾辞を代わりに使用してください．

     数字には`+'や`-'を前置することが可能です．正の符号は，ストレージ内でファ
     イルが少なくともN単位を使用している場合，調査が成功したことを示し
     (これは，このテストが使用する一般的な方法です)，負の符号は，ストレージ
     内でファイルがN単位未満使用している場合，調査が成功したことを示し
     ます．`='接頭辞は無く，これはデフォルトだからです．

     サイズは間接的なブロックを数えませんが，実際には割り当てられていない疎
     らなファイル内のブロックは数えます．言い替えると，`ls -l'や `wc
     -c'で得られる結果と矛盾します．この疎らなファイルの処理は，
     `-printf'指示語の`%k'と`%b'の書式指定の出力とは異なりま す．

 -- Test: -empty
     ファイルが空の場合で，通常のファイルまたはディレクトリのどちらかの場合
     は真です．これで，削除に適した候補が作成されるでしょう．このテストは，
     `-depth' (*note Directories::)と`-delete' (*note Single
     File::)とともに用いた場合，役に立ちます．


File: find-ja.info,  Node: Type,  Next: Owner,  Prev: Size,  Up: Finding Files

2.5 ファイル形式
================

 -- Test: -type c
     ファイルがCの形式の場合は真です．

    `b'
          (バッファされる)ブロックスペシャルファイル

    `c'
          (バッファされない)キャラクタスペシャルファイル

    `d'
          ディレクトリ

    `p'
          名前付きパイプ(FIFO)

    `f'
          通常のファイル

    `l'
          シンボリックリンク

    `s'
          ソケット

    `D'
          door (Solaris)

 -- Test: -xtype c
     ファイルがシンボリックリンクでない場合，`-type'と同じです．シンボ
     リックリンクに対しては以下のようになります．`-follow'が与えられて
     いない場合，ファイルがC形式のファイルにリンクしている場合は真です．
     `-follow'が与えられている場合，Cが`l'の場合は真です．言
     い替えると，シンボリックリンクに対し，`-xtype'は，`-type'が調
     査しないファイルの形式を調査します．`-follow'の詳細は， *Note
     Symbolic Links::.


File: find-ja.info,  Node: Owner,  Next: Permissions,  Prev: Type,  Up: Finding Files

2.6 所有者
==========

 -- Test: -user uname
 -- Test: -group gname
     ファイルが(グループGNAMEに所属する)ユーザUNAMEに所有されて
     いる場合は真です．数字のIDも可能です．

 -- Test: -uid n
 -- Test: -gid n
     ファイルの数字のユーザID(グループID)がNの場合は真です．これらのテ
     ストは，`-user'と`-group'とは異なり，範囲指定 (`+N'
     と`-N')をサポートします．

 -- Test: -nouser
 -- Test: -nogroup
     ファイルの数字のユーザIDに対応するユーザがいない(数字のグループIDに対応
     するグループがない)場合は真です．これらの場合は，通常，システムから削除
     されているため，ユーザに属さなくなったファイルを意味します．そのような
     ファイルの所有権を，`chown'や`chgrp'プログラムを使用して，既
     存のユーザとグループに変更したほうが良いでしょう．


File: find-ja.info,  Node: Permissions,  Next: Contents,  Prev: Owner,  Up: Finding Files

2.7 ファイルの権限
==================

ファイルの権限の構造とそれを指定する方法に関する情報は，*Note File
Permissions::.

 -- Test: -perm mode
     ファイルの権限が正確にMODE(数値的でも象徴的でも可能です)と同一の
     場合は真です．

     MODEが`-'で始まっている場合，MODEの権限が_すべ
     て_ファイルに設定されている場合は真です．MODEに設定されていない権
     限は無視されます．MODEが`/'で始まっている場合，MODEの
     権限が_ひとつでも_ファイルに設定されている場合は真です．
     MODEに設定されていない権限は無視されます．これはGNUの拡張です．

     `/'や`-'の形式を記号的なモードの文字列で使用していない場合，
     より複雑なモード文字列を指定する必要があるかもしれません．例えば，
     `-perm
     g=w'はモードが0020のファイルだけにマッチします(つまり，グルー
     プの書き込み権限だけ権限が設定されているものです)．`/'や`-'の
     形式のほうがより好ましい結果でしょう．例えば，`-perm
     -g=w'は，グルー
     プの書き込み権限がある，すべてのファイルにマッチします．

    `-perm 664'
          所有者とグループに読み込みと書き込みの権限があり，それ以外は読み込み可
          能で書き込み不可能なファイルにマッチします．これらの基準に合致したファ
          イルで，それ以外の権限のビットが設定されているもの(例えば，実行可能なファ
          イル)にはマッチしません．

    `-perm -664'
          所有者とグループに読み込みと書き込みの権限があり，それ以外は読み込み可
          能で書き込み不可能なファイルにマッチし，それ以外の権限ビット(例えば，実
          行権限ビット)の存在に依存しません．例えばこれは，0777のモードのファイル
          にマッチします．

    `-perm /222'
          書き込み権限があるファイル(所有者，グループ，またはそれ以外誰でも)にマッ
          チします．

    `-perm /022'
          所有者またはグループに書き込み権限があるファイルにマッチします．マッチ
          するためには，ファイルに所有者とグループの両方の書き込み権限がある必要
          はありません．いずれかでマッチします．

    `-perm /g+w,o+w'
          上記と同じです．

    `-perm /g=w,o=w'
          上記と同じです．

    `-perm -022'
          所有者とグループの両方の書き込み権限があるファイルを検索します．

    `-perm -g+w,o+w'
          上記と同じです．


File: find-ja.info,  Node: Contents,  Next: Directories,  Prev: Permissions,  Up: Finding Files

2.8 内容
========

ファイルの内容を基に検索するために，`grep'プログラムを使用すること
が可能です．例えば，現在のディレクトリで，文字列`thing'を含むCのソー
スファイルを見つけるために，以下のようにすることが可能です．

     grep -l thing *.[ch]

   サブディレクトリのファイルの文字列を検索したい時も，以下のように
`find'と`xargs'を用いて，`grep'を組み合わせることが可能 です．

     find . -name '*.[ch]' | xargs grep -l thing

   `grep'は`-l'オプションで，文字列を含む行ではなくそれを含むファ
イル名のみ出力します．文字列の引数(`thing')は，実際には正規表現で，
そのためメタ文字を含みます．この方法で，`find'の出力がない場合は
`xargs'に`grep'を実行させないように，`-r'オプションを使
用したり，名前にスペースを含んでいて間違って解釈することを防ぐために，
`find'のアクション`-print0'と`xargs'のオプション
`-0'を使用することで改善可能です．

     find . -name '*.[ch]' -print0 | xargs -r -0 grep -l thing

パターンにマッチする内容があるファイルを見つけるためのより完全な扱いは，
`grep'のマニュアルページを参照して下さい．


File: find-ja.info,  Node: Directories,  Next: Filesystems,  Prev: Contents,  Up: Finding Files

2.9 ディレクトリ
================

ディレクトリでの`find'の検索を制御し，それらを検索する方法がここに
あります．これらの二つのオプションで，ディレクトリツリーを輪切りにする
処理が可能となります．

 -- Option: -maxdepth levels
     コマンドライン引数以下の，最大LEVELS (正の整数)のレベルのディレク
     トリまで下ります．`-maxdepth 0'はコマンドライン引数のみ，テストと
     アクションを適用することを意味します．

 -- Option: -mindepth levels
     LEVELS (正の整数)未満のレベルではテストもアクションも適用しません．
     `-mindepth 1'はコマンドライン引数以外のすべてのファイルを処理する
     ことを意味します．

 -- Option: -depth
     ディレクトリ自身の前に，それぞれのディレクトリの内容を処理します．
     `cpio'や`tar'でファイルのリストを生成する時，これを行なうのは
     良い考えです．ディレクトリにその所有者に対する書き込み権限がない場合，
     ディレクトリの権限はその内容の後で復元されるため，その内容はアーカイブ
     から復元することが可能です．

 -- Option: -d
     これは，`-depth'の推奨されない同意語で，Mac OS X，FreeBSD，そして
     OpenBSDとの互換性が目的です．`-depth'オプションはPOSIXの機能なので，
     そちらを使用したほうが良いでしょう．

 -- Action: -prune
     ファイルがディレクトリの場合，その中まで下って行きません．結果は真です．
     例えば，ディレクトリ`src/emacs'と，そのすべてのファイルと，それ以
     下のディレクトリを省略し，それ以外で見つかったファイルの名前を出力する
     ために以下のようにします．

          find . -wholename './src/emacs' -prune -o -print

     上記のコマンドでは，結果リストに`./src/emacs'を出力しません．しか
     し，これは`-prune'の動作の影響が原因ではありません(それ以上，下っ
     て行くのを避けるだけで，その項目を確実に無視するわけではありません)．そ
     うではなく，これは`-o'を使用していることが原因です．左側の"or"条
     件が`./src/emacs'で成功しているので，この指定しているファイルに対
     する右側の評価(`-print')が不要になります．ディレクトリ名を出力した
     い場合，さらに`-print'アクションを使用します．

          find . -wholename './src/emacs' -prune -print -o -print

     または，カンマ・オペレータを使用します．

          find . -wholename './src/emacs' -prune , -print

     `-depth'オプションの影響がある場合，サブディレクトリはあらゆる状況
     で調査されています．このため，`-prune'に効果はありません．

 -- Action: -quit
     すぐに修了します(エラーが無ければ，ゼロの値を返します)．実行中の子プロ
     セスは無く，コマンドラインで指定されたパスの処理も無い状態になります．
     例えば，`find /tmp/foo /tmp/bar -print -quit'では`/tmp/foo'だ
     けを出力します．

 -- Option: -noleaf
     ディレクトリが，ハードリンクの数より二つ少ないサブディレクトリを含むこ
     とを仮定することで，最適化を行ないません．このオプションは，CD-ROMや
     MS-DOSファイルシステムやAFSボリュームマウントポイントといった，Unixのディ
     レクトリリンクの規約に従わないファイルシステムを検索する時に必要です．
     通常のUnix
     のファイルシステムのそれぞれのディレクトリは，少なくとも二つ
     のハードリンクがあります．その名前とその`.'エントリです．更に，そ
     のサブディレクトリ(が存在する場合)には，そのディレクトリにリンクしてい
     る`..'エントリが，それぞれにあります．`find'がディレクトリを
     調査している時，ディレクトリのリンク数よりサブディレクトリが二つ少ない
     ことがはっきりした後で，それはディレクトリのエントリの残りがディレクト
     リでない(ディレクトリ内の"leaf"ツリー)ことが分かります．ファイルの
     名前のみ調査に必要な場合は，それらをはっきりさせる必要はありません．こ
     れで検索スピードが飛躍的に増加します．

 -- Option: -ignore_readdir_race
     ディレクトリから読み込まれた名前のファイルが，`find'が`stat'
     でファイルを調査する前に見つからない場合，エラーメッセージを出力しませ
     ん．このオプションを指定していない場合，エラーメッセージが出力されます．
     頻繁に変更されるファイルシステム領域(メールのキュー，テンポラリ・ディレ
     クトリ等)を調査するシステムスクリプト(例えばcronスクリプト)では，このオ
     プションは役に立ち，その理由は，このような種類のディレクトリではよくあ
     ることだからです．`find'からのエラーメッセージを完全に無くすことは
     望まないので，このオプションは，うまく問題を解決します．しかし，ファイ
     ルシステムの一部はこのオプションをオンにし，一部ではこのオプションをオ
     フにして検索する方法はありません．

 -- Option: -noignore_readdir_race
     このオプションは，`-ignore_readdir_race'オプションの効果を反転しま
     す．


File: find-ja.info,  Node: Filesystems,  Next: Combining Primaries With Operators,  Prev: Directories,  Up: Finding Files

2.10 ファイルシステム
=====================

"ファイルシステム(filesystem)"とはディスクの区分のことで，それはロー
カルホスト，または，ネットワーク経由のリモートホストからマウントしたも
ののいずれかになります．ネットワークファイルシステムを検索すると遅くな
るはずなので，通常，`find'はそれを避けます．

特定のファイルシステムの検索を避ける二つの方法があります．一つの方法は，
`find'に一つのファイルシステムのみを検索するよう伝えることです．

 -- Option: -xdev
 -- Option: -mount
     他のファイルシステムのディレクトリに下りません．これらのオプションは同
     じです．

もう一つの方法は，それぞれのファイルがあるファイルシステムの形式を調査
し，好ましくないファイルシステムの形式にあるディレクトリに下らないよう
にします．

 -- Test: -fstype type
     ファイルが，形式TYPEのファイルシステム上にある場合は真です．有効
     なファイルシステム形式は，Unixの異なるバージョン間で異なります．いくつ
     かのバージョンのUnixなどが受け入れる，ファイルシステムの形式の不完全な
     リストは，以下のとおりです．
          ext2 ext3 proc sysfs ufs 4.2 4.3 nfs tmp mfs S51K S52K
     ファイルシステムの形式を知るために，`%F'指示語とともに
     `-printf'を使用することが可能です．`%D'指示語はデバイス番号を
     表示します．*Note Print File Information::.
     リモートファイルシステムの
     検索を避けるために，`-fstype'は通常，`-prune'とともに使用され
     ます．(*note Directories::).


File: find-ja.info,  Node: Combining Primaries With Operators,  Prev: Filesystems,  Up: Finding Files

2.11 オペレータの主なものを組み合わせる
=======================================

オペレータはテストとアクションから，複雑な表現を構築します．オペレータ
は優先順位が下がる順序で，以下のものがあります．

`( EXPR )'
     優先順位をあげます．EXPRが真の場合は真です．

`! EXPR'
`-not EXPR'
     EXPRが偽の場合は真です．

`EXPR1 EXPR2'
`EXPR1 -a EXPR2'
`EXPR1 -and EXPR2'
     And(論理積)です．EXPR1が偽の場合，EXPR2は評価されません．

`EXPR1 -o EXPR2'
`EXPR1 -or EXPR2'
     Or(論理和)です．EXPR1が真の場合，EXPR2は評価されません．

`EXPR1 , EXPR2'
     リストです．EXPR1とEXPR2は，常に評価されます．EXPR2が
     真の場合は真です．EXPR1の値は放棄されます．このオペレータで，一回
     の処理で，他の処理が成功したかどうかに依存せず，複数の独立した処理を行
     なうことができます．二つの処理EXPR1とEXPR2は，常に完全に独
     立というわけではなく，それはEXPR1にファイルを編修したり削除したり
     する副作用がある可能性があり，また，EXPR2に影響する`-prune'
     を使用している可能性もあるためです．

   `find'は，右から左まで式を評価しながら，それぞれのファイル名を起点
としたディレクトリツリーを，優先順位の規則に従い，(`-and'に対して
は左が偽，`-or'に対しては真となる)結果が分かるまで検索し，そして，
`find'は次のファイル名へ移動します．

   複雑な表現で役に立つ，二つのテストが他にあります．

 -- Test: -true
     常に真です．

 -- Test: -false
     常に偽です．


File: find-ja.info,  Node: Actions,  Next: Common Tasks,  Prev: Finding Files,  Up: Top

3 アクション
************

`find'の式で与えた基準にマッチするファイルの情報を出力する方法が，
いくつかあります．標準出力または指名したファイルに，情報を出力すること
が可能です．ファイル名を引数として，コマンドを実行することも可能です．
これらのコマンドを，選択したファイルへのフィルター以外の目的で使用する
ことが可能です．

* Menu:

* Print File Name::
* Print File Information::
* Run Commands::
* Delete Files::
* Adding Tests::


File: find-ja.info,  Node: Print File Name,  Next: Print File Information,  Up: Actions

3.1 ファイル名の出力
====================

 -- Action: -print
     真の時，完全なファイル名を標準出力に出力し，改行を追加します．

 -- Action: -fprint file
     真の時，完全なファイル名をファイルFILEに出力し，改行を追加します．
     `find'の実行時にFILEが存在しない場合は作成されます．存在する
     場合は0バイトに切り詰められます．ファイル名`/dev/stdout'と
     `/dev/stderr'は，特別な扱いをされます．それらはそれぞれ，標準出力
     と標準エラー出力を参照します．


File: find-ja.info,  Node: Print File Information,  Next: Run Commands,  Prev: Print File Name,  Up: Actions

3.2 ファイル情報の出力
======================

 -- Action: -ls
     真の時，現在のファイルを`ls -dils'の書式で標準出力にリストアップし
     ます．出力は以下のようになります．

          204744   17 -rw-r--r--   1 djm      staff       17337 Nov  2  1992 ./lwall-quotes

     フィールドは以下のとおりです．

       1.
          ファイルのinodeナンバーです．inodeナンバーを元にしたファイルの検索方法
          は，*Note Hard Links::.

       2.
          ファイルのブロック数です．ブロック計算は，512バイトブロック単位を使用す
          る環境変数`POSIXLY_CORRECT'が設定されていない場合，1Kブロック単位
          です．サイズを元にしたファイルの検索方法は，*Note Size::.

       3.
          ファイルの形式と権限です．形式は，通常のファイルに対してはダッシュで表
          示されます．それ以外のファイル形式に対しては，`-type'に対して使用
          される文字です(*note
          Type::)．権限は，読み込み，書き込み，そして実行で，
          それぞれファイルの所有者，そのグループ，そしてその他のユーザに対するも
          のです．ダッシュは権限が与えられていないことを意味します．ファイルの権
          限の詳細は，*Note File Permissions::.
          その権限を元にしたファイルの検索 方法は，*Note Permissions::.

       4. ファイルに対するハードリンクの数です．

       5. ファイルを所有しているユーザです．

       6. ファイルのグループです．

       7. ファイルのバイト単位のサイズです．

       8. ファイルが最後に編集された日付です．

       9.
          ファイル名です．`-ls'は，ファイル名で使用されている出力不可能な文
          字を，Cのようなバックスラッシュエスケープを使用して引用符で囲みます．印
          字不可能な文字の扱いは`-ls'，`-fls'，`-print'，
          `-fprint'，`-printf'，そして`-fprintf'では同じなので，こ
          れは将来，変更される可能性があります．

 -- Action: -fls file
     真の時，`-ls'に似ていますが，`-fprint'のようにFILEに書
     き出します(*note Print File Name::)．

 -- Action: -printf format
     真の時，`\'エスケープと`%'指示語を解釈しながら，FORMAT
     を標準出力に出力します．フィールドの幅と精度は，C関数の`printf'の
     ように指定することが可能です．書式フラグ(例えば`#')は，多くのフィー
     ルドは`%s'で出力されるので，数値的なものであっても期待したように動
     作しません．これは，書式フラグ`-'が動作することを意味します．それ
     はフィールドを左寄せに強制します．`-print'とは異なり，
     `-printf'は文字列の終わりに改行を追加しません．文字列の終わりを改
     行にしたい場合，`\n'を追加してください．

 -- Action: -fprintf file format
     真の時，`-printf'に似ていますが，`-fprint'のようにFILE
     に書き出します(*note Print File Name::)．

* Menu:

* Escapes::
* Format Directives::
* Time Formats::


File: find-ja.info,  Node: Escapes,  Next: Format Directives,  Up: Print File Information

3.2.1 エスケープ
----------------

`-printf'と`-fprintf'で認識されるエスケープは以下のとおりです．

`\a'
     アラームベル．

`\b'
     バックスペース．

`\c'
     この書式の直後出力の停止し，出力をフラッシュ．

`\f'
     フォームフィード．

`\n'
     改行．

`\r'
     キャリッジリターン．

`\t'
     水平タブ．

`\v'
     垂直タブ．

`\\'
     バックスラッシュそのもの(`\')．

`\NNN'
     ASCIIコードがNNNの文字(八進数)．
   `\'文字に他の文字が続くものは，通常の文字として扱われるので，両方
が出力され，(おそらくそれは入力ミスなので)標準エラー出力に警告メッセー
ジが出力されます．


File: find-ja.info,  Node: Format Directives,  Next: Time Formats,  Prev: Escapes,  Up: Print File Information

3.2.2 書式指示語
----------------

`-printf'と`-fprintf'は，処理しているファイルに関する情報を出
力するため，以下の書式指示語をサポートします．Cの`printf'関数での
フィールド幅と精度指定は，文字列(`%s')の形式に適用するようにサポー
トされています．つまり，それぞれの指示語に対する"最小フィールド幅"."最
大フィールド幅"を指定することが可能です．書式フラグ(例えば`#')は，
多くのフィールドは`%s'で出力されるので，数値的なものであっても期待
したように動作しません．書式フラグ`-'は動作することを意味します．
それはフィールドを左寄せに強制します．

   `%%'はパーセント記号そのものです．認識できない文字が続く`%'文
字(例えば，既知の指示語でも，`printf'のフィールド幅や精度指定でも
ないもの)は削除され(しかし，認識できない文字は出力されます)，(おそらく
入力ミスのため)標準出力に警告メッセージが出力されます．

* Menu:

* Name Directives::
* Ownership Directives::
* Size Directives::
* Location Directives::
* Time Directives::
* Formatting Flags::


File: find-ja.info,  Node: Name Directives,  Next: Ownership Directives,  Up: Format Directives

3.2.2.1 名前指示語
..................

`%p'
     ファイル名(絶対パスではなく，`find'が見つけたファイル名です - つま
     り，開始点からの相対パスです)．

`%f'
     前置されるディレクトリを削除したファイル名(最後の要素のみ)．

`%h'
     ファイル名に前置されるディレクトリ(最後の要素とその前のスラッシュ以外す
     べて)．ファイル名にスラッシュが無い(例えば，コマンドラインで指名されて
     いたり，現在のワーキング・ディレクトリにある)場合，`%h'は`.'
     に展開されます．これは，`%h/%f'を`/foo'に展開することが，予想
     外でおそらく要求されることでないので，そうすることを避けます．

`%P'
     ファイル名で，それが見つけられたコマンドライン引数の名前は，最初から削
     除されます．

`%H'
     それによりファイルが見つけられた，コマンドライン引数．


File: find-ja.info,  Node: Ownership Directives,  Next: Size Directives,  Prev: Name Directives,  Up: Format Directives

3.2.2.2 所有者指示語
....................

`%g'
     ファイルのグループ名，または名前が無い場合はグループID．

`%G'
     ファイルの数値的なグループID．

`%u'
     ファイルのユーザ名，または名前が無い場合はユーザID．

`%U'
     ファイルの数値的なユーザID．

`%m'
     ファイルの権限(八進数)．数字の前に常にゼロを前置したい場合，例えば`%#m'の
     ように，`#'書式フラグを使用してください．


File: find-ja.info,  Node: Size Directives,  Next: Location Directives,  Prev: Ownership Directives,  Up: Format Directives

3.2.2.3 サイズ指示語
....................

`%k'
     このファイルが使用している1Kブロック単位でのディスク使用量．ディスク領
     域はファイルシステムのブロックサイズの倍数を占有するので，これは通常
     `%s/1024'より大きくなりますが，ファイルが疎らなファイル(いわゆる
     "穴"があるもの)の場合は小さくなるはずです．

`%b'
     このファイルが使用している512バイトブロック単位でのディスク使用量．ディ
     スク領域はファイルシステムのブロックサイズの倍数を占有するので，これは
     通常`%s/1024'より大きくなりますが，ファイルが疎らなファイル(いわゆ
     る"穴"があるもの)の場合は小さくなるはずです．

`%s'
     バイト単位でのファイルサイズ．


File: find-ja.info,  Node: Location Directives,  Next: Time Directives,  Prev: Size Directives,  Up: Format Directives

3.2.2.4 位置指示語
..................

`%d'
     ディレクトリツリーでのファイルの深さ(コマンドラインで指名されたファイル
     からの深さで，ルートディレクトリからではありません)．コマンドラインのファ
     イル名は，深さが0です．直下のサブディレクトリは1となり，そのように続い
     ていきます．

`%D'
     ファイルが存在するデバイス番号(`struct stat'の`st_dev'フィー
     ルド)で，十進数です．

`%F'
     ファイルが存在するファイルシステム．この値は，`-fstype'で使用する
     ものです(*note Directories::)．

`%l'
     シンボリックリンクのオブジェクト(ファイルがシンボリックリンクでない場合
     は空文字です．)

`%i'
     ファイルのinode番号(十進数)．

`%n'
     ファイルのハードリンクの数．

`%y'
     `-type'で使用されるファイルの形式．ファイルがシンボリックリンクの
     場合，`l'が出力されます．

`%Y'
     `-type'で使用されるファイルの形式．ファイルがシンボリックリンクの
     場合，リンクをたどります．ファイルが壊れているシンボリックリンクの場合，
     `N'が出力されます．


File: find-ja.info,  Node: Time Directives,  Next: Formatting Flags,  Prev: Location Directives,  Up: Format Directives

3.2.2.5 時間指示語
..................

これらの指示語にはCの`ctime'関数を使用するものもあります．その出力
は現在のロカールに依存しますが，典型的なものは以下のようになります．

     Wed Nov  2 00:42:36 1994

`%a'
     Cの`ctime'関数で返される書式での，ファイルが最後にアクセスされた時
     間．

`%AK'
     Kで指定される書式での，ファイルが最後にアクセスされた時間 (*note
     Time Formats::)．

`%c'
     Cの`ctime'関数で返される書式での，ファイルのステータスが最後に変更
     された時間．

`%CK'
     Kで指定される書式での，ファイルのステータスが最後に変更された時間
     (*note Time Formats::)．

`%t'
     Cの`ctime'関数で返される書式での，ファイルが最後に編集された時間．

`%TK'
     Kで指定される書式での，ファイルが最後に編集された時間 (*note Time
     Formats::)．


File: find-ja.info,  Node: Time Formats,  Prev: Format Directives,  Up: Print File Information

3.2.3 時間の書式
----------------

以下は，指示語`%A'，`%C'，そして`%T'に対する書式で，それ
はファイルのタイムスタンプを出力します．これらの書式には，Cの
`strftime'関数のシステム間での違いにより，すべてのシステムで利用可
能でないものもあります．

* Menu:

* Time Components::
* Date Components::
* Combined Time Formats::


File: find-ja.info,  Node: Time Components,  Next: Date Components,  Up: Time Formats

3.2.3.1 時間の内容
..................

以下の書式指示語は，時間の単一の内容を出力します．

`H'
     時間(00..23)

`I'
     時間(01..12)

`k'
     時間( 0..23)

`l'
     時間( 1..12)

`p'
     ロカールの午前や午後

`Z'
     タイムゾーン(例えば，EDT)，またはタイムゾーンが定義されていない場合は何
     も出力しない．

`M'
     分(00..59)

`S'
     秒(00..61)

`@'
     1970年1月1日00:00 GMT以来の秒．


File: find-ja.info,  Node: Date Components,  Next: Combined Time Formats,  Prev: Time Components,  Up: Time Formats

3.2.3.2 日付の内容
..................

以下の書式指示語は，日付の単一の内容を出力します．

`a'
     ロカールの略記された曜日名(Sun..Sat)

`A'
     ロカールの完全な曜日名，可変長(Sunday..Saturday)

`b'
`h'
     ロカールの略記された月名(Jan..Dec)

`B'
     ロカールの完全な月名，可変長(January..December)

`m'
     月(01..12)

`d'
     日(01..31)

`w'
     曜日(0..6)

`j'
     年間の日付(001..366)

`U'
     日曜日を週の最初の日とした時の，年間の週数(00..53)

`W'
     月曜日を週の最初の日とした時の，年間の週数(00..53)

`Y'
     年(1970...)

`y'
     年の最後の二桁(00..99)


File: find-ja.info,  Node: Combined Time Formats,  Prev: Date Components,  Up: Time Formats

3.2.3.3 時間の書式の組み合わせ
..............................

以下の書式指示語は，時間と日付の組み合わせを出力します．

`r'
     時間，12時間制(hh:mm:ss [AP]M)

`T'
     時間，24時間制(hh:mm:ss)

`X'
     ロカールの時間表現(H:M:S)

`c'
     ロカールの日付と時間(Sat Nov 04 12:02:33 EST 1989)

`D'
     日付(mm/dd/yy)

`x'
     ロカールの日付表現(mm/dd/yy)

`+'
     日付と時間を`+'で分離し，例えば`2004-04-28+22:22:05'とします．
     時間は，現在のタイムゾーンで与えられたものになります(TZ環境変数で設定さ
     れたものに影響されるかもしれません)．これはGNUの拡張です．


File: find-ja.info,  Node: Formatting Flags,  Prev: Time Directives,  Up: Format Directives

3.2.3.4 書式フラグ
..................

`%m'と`%d'指示語は，`#'，`0'，そして`+'フラグ
をサポートしますが，それ以外の指示語は数値を出力するものでもサポートし
ません．これらのフラグをサポートしない数値の指示語には，以下のものが含
まれます．

   `G'，`U'，`b'，`D'，`k'，そして`n'です．

   すべてのフィールドは書式化フラグ`-'をサポートし，それは左寄せの
フィールドになります．つまり，フィールドの幅がフィールドの実際の内容よ
り大きい場合，必要なスペースがフィールド内容のの前ではなく後に出力され
ます．


File: find-ja.info,  Node: Run Commands,  Next: Delete Files,  Prev: Print File Information,  Up: Actions

3.3 コマンドの実行
==================

`find'や`locate'で作成されたファイル名のリストを，他のコマン
ドへの引数として使用することが可能です．この方法で，ファイルへの任意の
動作を実行することが可能です．

* Menu:

* Single File::
* Multiple Files::
* Querying::


File: find-ja.info,  Node: Single File,  Next: Multiple Files,  Up: Run Commands

3.3.1 単一のファイル
--------------------

ここに一つのファイルへのコマンドを，一度に実行する方法があります．

 -- Action: -execdir command ;
     COMMANDを実行します．0のステータスが返される場合は真です．
     `find'は，`-exec'以降のすべての引数を，`;'までの内容から
     成り立つ引数をコマンドとして受けとります．それは，文字列`{}'を現
     在のファイル名で置換し，コマンドにそれがある場所で処理されます．これら
     の構文はどちらも，シェルによる展開を防ぐために(`\'を用いて)エスケー
     プしたり，引用符で囲む必要があります．コマンドは，`find' を実行し
     ているディレクトリで実行されます．

     例えば，現在のディレクトリのそれぞれのCのヘッダファイルを，ファイル
     `/tmp/master'と比較するために以下のようにします．

          find . -name '*.h' -execdir diff -u '{}' /tmp/master ';'

   それに似たもう一つのオプションとして，`-exec'がサポートされていま
すが，余りセキュリティーが高くありません．`-exec'に関するセキュリ
ティーの問題の議論は，*Note Security Considerations::.

 -- Action: -exec command ;
     この，余りセキュリティーの高くない`-execdir'アクションの亜種は，
     POSIXで指定されているものです．主な違いは，`find'が呼び出されたディ
     レクトリでコマンドが実行されるということで，`{}'が，マッチしたファ
     イルのベース名ではなく，開始ディレクトリからの相対パスに展開されること
     を意味します．


File: find-ja.info,  Node: Multiple Files,  Next: Querying,  Prev: Single File,  Up: Run Commands

3.3.2 複数のファイル
--------------------

一度に一つずつのファイルを処理する必要がある時もあります．しかし，これ
は不要で，ファイルごとにコマンドを実行するより，できるだけ多くのファイ
ルをコマンドで実行した方が速くなります．こうすることで，それぞれのコマ
ンドを開始する時間を稼ぐことになります．

   `-execdir'と`-exec'アクションには，できるだけ多くのマッチした
ファイルを含むコマンドラインを構築する亜種があります．

 -- Action: -execdir command {} +
     これは`-execdir command ;'と同じように動作しますが，コマンドの終わ
     りの`{}'はマッチしたファイルの名前のリストになります．この展開は，
     システムで利用可能なコマンドラインの最大の長さを越えないように行われま
     す．コマンドには一つの`{}'だけが可能で，`+'の直前に，最後に
     書く必要があります．`{}'直後以外の位置にある`+'は，特別扱い
     されません(つまり，コマンドの終端ではありません)．

 -- Action: -exec command {} +
     この，余りセキュリティーの高くない`-execdir'アクションの亜種は，
     POSIXで指定されているものです．主な違いは，`find'が呼び出されたディ
     レクトリでコマンドが実行されるということで，`{}'が，マッチしたファ
     イルのベース名ではなく，開始ディレクトリからの相対パスに展開されること
     を意味します．

   `find'が終了する前に，部分的に構築されたコマンドラインが実行されま
す．これは，`-quit'アクションで終了された場合もそうなります．しか
し，エラーの形式によっては(例えば`stat()'の呼び出しがカレントディ
レクトリで不可能)，直後に致命的な終了になります．この状況では，部分的に
構築されたコマンド莱因は呼び出されません(これで，無限ループを抑止しま
す)．

もう一つの，余りセキュリティは高くありませんが，一度に一つ以上のファイ
ルでコマンドを実行する方法は，`xargs'コマンドを使用する方法で，以
下のように呼び出します．

     xargs [OPTION...] [COMMAND [INITIAL-ARGUMENTS]]

   `xargs'は通常，標準入力から引数を読み込みます．これらの引数は空白
(それは，ダブルクオートやシングルクオートまたはバックスラッシュで保護可
能)や改行で分離されています．それはCOMMAND (デフォルトで
`/bin/echo')を，標準入力から読み込まれた引数が続くあらゆる
INITIAL-ARGUMENTSを用いて，一回以上実行します．標準入力の空白行は
無視されます．

   空白の分離名の代わりに，`find -print0'や`find -fprint0'を使用
し，GNU `xargs'，GNU `tar'，GNU `cpio'，または
`perl'へ，`-0'や`--null'オプションを与えて，出力を処理し
た方が安全です．`locate'コマンドにも，同じことを行う`-0'や
`--null'オプションがあります．

以下のように，引数リストを処理するためシェルコマンドの置換(バッククオー
ト)を使用することが可能です．

     grep -l sprintf `find $HOME -name '*.c' -print`

   しかし，その方法は，`.c'ファイル名の長さが，オペレーティングシステ
ムのコマンドラインの長さの制限を超過する場合，エラーが生じるでしょう．
`xargs'は，制限を超過しないようにするために必要なだけコマンドを実
行することで，その問題を避けます．

     find $HOME -name '*.c' -print | xargs grep -l sprintf

   しかし，標準入力が端末であることを必要とするコマンド(例えば，
`less')の場合，シェルコマンドの置換の手法や，`xargs'の
`--arg-file'オプションを使用する必要があります．

   `xargs'コマンドは，コマンドが255のステータスで終了したり
(`xargs'がエラーメッセージを出力し停止しています)，ファイルの終
わりとなる`--eof'オプションで指定されている文字列を含んでいる行を
読み込むまでは，すべての入力を処理し，コマンドラインを構築し，それを実
行します．

* Menu:

* Unsafe File Name Handling::
* Safe File Name Handling::
* Unusual Characters in File Names::
* Limiting Command Size::
* Interspersing File Names::


File: find-ja.info,  Node: Unsafe File Name Handling,  Next: Safe File Name Handling,  Up: Multiple Files

3.3.2.1 安全でないファイル名の扱い
..................................

ファイル名には，引用符，バックスラッシュ，空白文字，そして改行でさえ含
めることが可能なので，処理のデフォルトモードで`xargs'を使用しなが
らそれを処理することは安全ではありません．しかし，ほとんどのファイル名
は空白を含まないので，この問題は滅多に発生しません．安全なファイル名だ
と知っているファイルを検索している場合のみ，それについて悩む必要はあり
ません．

   応用する際は，名前に特殊文字を含んでいるため，`xargs'ファイルをう
まく処理できない場合も多く，失われるデータもあります．この問題の重要性
は，データの重要性に依存し，それを訂正するためにはできるだけ速く，失っ
たものに気づくかに依存します．しかし，ここに，空白で分離した名前の使用
で引き起こされる究極の例があります．以下のコマンドが，毎日`cron'で
実行される場合，あらゆるユーザは任意のファイルを削除することが可能です．

     find / -name '#*' -atime +7 -print | xargs rm

   例えば，以下のようなことが可能でしょう．

     eg$ echo > '#
     vmunix'

`/'を現在のディレクトリとして，`xargs'を実行してしまった場合，
そして，`cron'は`/vmunix'を削除するでしょう．

   他のファイルを削除するために，例えば`/u/joeuser/.plan'は，以下のよ
うにすることで可能でしょう．

     eg$ mkdir '#
     '
     eg$ cd '#
     '
     eg$ mkdir u u/joeuser u/joeuser/.plan'
     '
     eg$ echo > u/joeuser/.plan'
     /#foo'
     eg$ cd ..
     eg$ find . -name '#*' -print | xargs echo
     ./# ./# /u/joeuser/.plan /#foo


File: find-ja.info,  Node: Safe File Name Handling,  Next: Unusual Characters in File Names,  Prev: Unsafe File Name Handling,  Up: Multiple Files

3.3.2.2 安全なファイル名の扱い
..............................

`find'が出力したファイル名を，他のプログラムでめちゃくちゃにされた
り誤解されたりしないで，他のプログラムで使用可能にする方法は以下のよう
になります．この方法で生成されたファイル名に，`-0'や`--null'
オプションを，GNU `xargs'，GNU `tar'，GNU `cpio'，または， `perl'
に渡すことで，処理することが可能です．

 -- Action: -print0
     真です．標準出力の完全なファイル名にヌル文字を続けて出力します．

 -- Action: -fprint0 file
     真です．`-print0'ににていますが，FILEを`-fprint'のように
     書き出します(*note Print File Name::)．

   findutilsのバージョン4.2.4からは，`locate'プログラムにも同様なこと
を行う`--null'オプションがあります．`xargs'と同様，短い形式の
オプション`-0'も使用することが可能です．

ファイル名を安全に処理したいが，コマンドを入力の終わりに繋げて実行する
必要がある場合，以下のように`xargs'の`--arg-file'オプションを
使用することが可能です．

     find / -name xyzzy -print0 > list
     xargs --null --arg-file=list munge

   上記の例では，見つけることができた`xyzzy'と命名されたすべてのファ
イルで，`munge'プログラムを実行しまが，`munge'の入力は端末に
なっています(また，実際にはシェルが標準入力を使用しています)．シェルに
"処理の代入"機能`<(...)'がある場合，ワンステップで実行することが
可能です．

     xargs --null --arg-file=<(find / -name xyzzy -print0) munge


File: find-ja.info,  Node: Unusual Characters in File Names,  Next: Limiting Command Size,  Prev: Safe File Name Handling,  Up: Multiple Files

3.3.2.3 ファイル名の通常ではない文字
....................................

これまで議論したように，`find'とその他のプログラムでのファイル名の
処理方法について，頻繁に注意する必要があります．`find'の出力を他の
プログラムに渡さず端末に表示させる場合でも，問題になることがあります．
例えば，特定の文字の並びには端末のファンクションキーを再構成するものも
あります．`find'のセキュリティの問題に関する議論は， *Note Security
Considerations::.

通常ではない文字は，以下の記述のように，さまざまなアクションとは別に処
理されます．

`-print0'
`-fprint0'
     常に正確なファイル名を出力し，出力が端末の場合でも変更されません．

`-ok'
`-okdir'
     常に正確なファイル名を出力し，変更されません．これは将来のリリースで，
     おそらく変更されるでしょう．

`-ls'
`-fls'
     通常ではない文字は常にエスケープされます．空白，バックスラッシュ，そし
     て二重引用符文字はC形式のエスケープ(例えば，`\f'，`\"')で出力
     されます．それ以外の通常ではない文字は，八進数を用いて出力されます．そ
     れ以外の印字可能文字(`-ls'と`-fls'では，八進数の041と0176の間
     の文字)は，そのまま出力されます．

`-printf'
`-fprintf'
     出力が端末でない場合，そのまま出力されます．それ以外の場合，結果は使用
     されている指示語に依存します．
    %D, %F, %H, %Y, %y
          これらは，ファイルの所有者の制御下には無い値に展開され，そのまま出力さ
          れます．

    %a, %b, %c, %d, %g, %G, %i, %k, %m, %M, %n, %s, %t, %u, %U
          これらは，ファイルの所有者の制御下にはある値になりますが，端末に不明瞭
          はデータを送るために使用されることが無いので，そのまま出力されます．

    %f, %h, %l, %p, %P
          これらの指示語の出力は，出力が端末の場合，引用符で囲まれます．

          この引用符で囲む手法は，GNU `ls'と同じ方法で実行されます．
          `-ls'と`-fls'で使用される引用符で囲むメカニズムとは異なります．
          `find'の出力で使用する書式を決定することが可能な場合，通常は改行で
          はなく`\0'を終端文字として使用するほうが良く，それは，ファイル名に
          は空白や改行文字を含めることができるからです．


`-print'
`-fprint'
     引用符での囲み方は，`-printf'と`-fprintf'の`%p'指示語と
     同じ方法で処理されます．スクリプト内やマッチしたファイルが不明瞭な名前
     を持つ状況で`find'を使用している場合，`-print'の代わりに
     `-print0'の使用を検討すべきでしょう．

   `locate'プログラムは，`find'の`-print'アクションと同じ方
法で，ファイル名の通常ではない文字を引用符で囲んだり，エスケープしたり
します．

これまで記述してきた動作はまもなく変更される可能性があり，それは，印字
不能な文字列の処理を，`-ls'，`-fls'，`-print'，
`-fprint'，`-printf'，そして`-fprintf'で調和させるためで す．


File: find-ja.info,  Node: Limiting Command Size,  Next: Interspersing File Names,  Prev: Unusual Characters in File Names,  Up: Multiple Files

3.3.2.4 コマンドサイズの制限
............................

`xargs'で，それぞれの実行時にコマンドに渡す引数の数を制御すること
ができます．デフォルトで，`ARG_MAX' - 2k，または128kまでの小さい方
を，コマンドごとの文字として使用します．それは，制限以内のできるだけ多
くの行と引数を使用します．以下のオプションはこれらの値を変更します．

`--no-run-if-empty'
`-r'
     標準入力が空白でない文字を含まない場合，コマンドを実行しません．デフォ
     ルトで，入力が無い場合でもコマンドは一度実行されます．

`--max-lines[=MAX-LINES]'
`-L[MAX-LINES]'
`-l[MAX-LINES]'
     最大MAX-LINESの空白でない入力行を，コマンドラインごとに使用します．
     省略された場合，MAX-LINESのデフォルトは1です．後置される空白は，
     行を数える目的で，入力行を次の入力行に論理的に連結します．`-x'を暗
     黙に指定します．より好まれるこのオプションの名前は`-L'で，それは
     POSIXで指定されています．このオプションは`-I'と互換性があるべきで
     すが，現在はそうなっていません．

`--max-args=MAX-ARGS'
`-n MAX-ARGS'
     最大MAX-ARGS個の引数を，コマンドラインごとに使用します．大きさが
     MAX-ARGSを超過した場合，それより小さいものが使用されますが，それ
     は`-x'オプションが与えられていない場合に限り，その場合は
     `xargs'は終了します．

`--max-chars=MAX-CHARS'
`-s MAX-CHARS'
     最大MAX-CHARS文字を，コマンドラインごとに使用し，それはコマンドと
     最初の引数と引数文字列の最後の終端のヌルを含みます．このオプションに大
     きすぎたり小さすぎたりする値を指定している場合，警告メッセージが出力さ
     れ，代わりに適切な上限や下限が使用されます．

`--max-procs=MAX-PROCS'
`-P MAX-PROCS'
     MAX-PROCSプロセスまで一度に実行します．デフォルトは1です．
     MAX-PROCSが0の場合，`xargs'は可能な限り多くのプロセスを，一
     度に実行します．`-P'とともに，`-n'，`-s'，または
     `-L'オプションを使用して下さい．そうしない場合，コマンドが実行され
     る機会は，一度しかありません．


File: find-ja.info,  Node: Interspersing File Names,  Prev: Limiting Command Size,  Up: Multiple Files

3.3.2.5 服数のファイル名を分割する
..................................

`xargs'は，処理するファイル名を，コマンドに対して与えた引数の間に
挿入することが可能です．コマンドの大きさを制限するオプションを与えてい
ない場合(*note Limiting Command Size::)，このモードの処理は`find
-exec'と等価です(*note Single File::)．

`--replace[=REPLACE-STR]'
`-i[REPLACE-STR]'
     最初の引数のREPLACE-STRがあるところを，入力から読み込まれる名前に
     置換します．また，引用符で囲まれていない空白は，引数の最後になりません．
     その代わりに，入力は改行だけで分離されます．REPLACE-STRが省略され
     た場合，デフォルトは`{}'です(`find -exec'に似ています)． `-x'と`-l
     1'を暗黙に指定します．例えば，`bills'ディレク
     トリのそれぞれのファイルをソートし，出力をファイル名に`.sorted'を
     後置したものに書き出す時，以下のようにすることで可能です．

          find bills -type f | xargs -iXX sort -o XX.sorted XX

     `find -execdir'を使用した等価のコマンドは以下のようになります．

          find bills -type f -execdir sort -o '{}.sorted' '{}' ';'


File: find-ja.info,  Node: Querying,  Prev: Multiple Files,  Up: Run Commands

3.3.3 問い合わせ
----------------

ユーザに単一のファイル上でコマンドを実行するかどうかを尋ねるため，
`find'のプライマリ`-execdir'の代わりに`-okdir'を，そして
`find'のプライマリ`-exec'の代わりに`-ok'を使用することが 可能です．

 -- Action: -okdir command ;
     `-execdir'に似ていますが(*note Single File::)，ユーザに(標準入力上
     で)最初に尋ねます．応答が`y'や`Y'で始まらない場合，コマンドを
     実行せず，偽を返します．

 -- Action: -ok command ;
     この，余りセキュリティーの高くない`-okdir'アクションの亜種は，
     POSIXで指定されているものです．主な違いは，`find'が呼び出されたディ
     レクトリでコマンドが実行されるということで，`{}'が，マッチしたファ
     イルのベース名ではなく，開始ディレクトリからの相対パスに展開されること
     を意味します．

単一のコマンドで複数のファイルを処理する時，ユーザに問い合わせるため，
`xargs'に以下のオプションを与えます．このオプションを使用する時，
コマンドの呼出ごとに処理するファイルの数を制御することが役に立つと分か
るでしょう．

`--interactive'
`-p'
     ユーザにそれぞれのコマンドラインを実行するかどうかプロンプトを表示し，
     端末から一行読み込みます．応答が`y'や`Y'で始まる場合のみコマ
     ンドラインを実行します．暗黙に`-t'が指定されます．


File: find-ja.info,  Node: Delete Files,  Next: Adding Tests,  Prev: Run Commands,  Up: Actions

3.4 ファイルの削除
==================

 -- Action: -delete
     ファイルやディレクトリを削除します．削除に成功した場合は真です．削除に
     失敗した場合，エラーメッセージが出力されます．

     コマンドラインで`-delete'アクションを使用すると，自動的に
     `-depth'オプションがオンになります(*note find Expressions::)．


File: find-ja.info,  Node: Adding Tests,  Prev: Delete Files,  Up: Actions

3.5 テストの追加
================

`find'の組み込みテストが調査しない，ファイルの属性の調査をすること
が可能です．こうするために，`find'が出力したファイルリストへのフィ
ルターとなるプログラムを実行するため，`xargs'を使用してください．
`xargs'によって実行されるプログラムが行なう仕事を減らすため，リス
トが少なくなるように，`find'の組み込みテストをできるだけ使用して下
さい．`find'の組み込みテストは，他のプログラムが実行するテストより
速く実行されるでしょう．

効率の問題で，外部プログラムの実行回数を制限することが役に立つこともよ
くあります．このため，`xargs'を使用して"拡張"テストを実装するの
は良い考えです．

   例えば以下に，`/usr/local'ディレクトリツリー内のstripされていない
バイナリの，すべての名前を出力する方法があります．組み込みテストは，通
常のファイルでないものや，実行可能でないファイルで，`file'を実行す
ることを避けます．

     find /usr/local -type f -perm /a=x | xargs file |
       grep 'not stripped' | cut -d: -f1

`cut'プログラムは，`file'の出力からファイル名以降のものすべて
を削除します．

   しかし，`xargs'を使用することは，セキュリティの重要な問題に遭遇す
ることもあります(*note Security Considerations::)．これらは
`-execdir'を使用することで回避することが可能です．`-execdir'
アクションは，他のテスト集の合間や`find'のアクションに独自のテスト
を書くときにも役に立ちます(例えば，`-prune'を使用したいかもしれま
せん)．

   `find'の式の中間のどこかで特殊なテストを配置したい場合，テストを実
施するプログラムを実行するために，`-execdir' (または，余りセキュリ
ティの高くない`-exec')を使用することが可能です．`-execdir'は，
実行されたプログラムの終了ステータスを評価するので，特殊な属性を検査す
るプログラム(それは，シェルスクリプトも可能です)を書くことと，真(ゼロ)
や偽(ゼロ以外)のステータスで終了させることが可能です．そのような特殊な
テストは，組み込みテストが偽と評価される場合は行なわない新しいプロセス
を開始するので，それを組み込みテストの_後に_配置することは良い考え
です．

   以下は，引数がstripされているバイナリファイルかどうかを調査する，
`unstripped'という名前のシェルスクリプトです．

     #! /bin/sh
     file "$1" | grep -q "not stripped"

このスクリプトは，パイプラインの最後のコマンドのステータスでシェルが終
了することに依存し，この場合`grep'になります．`grep'は，マッ
チが見つかる場合は真で終了し，それ以外では偽で終了します．以下にに(サー
チパスにあると仮定している)スクリプトを利用している例があります．それは，
ファイル`sbins'内のstripされている実行形式と，`ubins'内の
stripされていない実行形式をリストアップします．

     find /usr/local -type f -perm /a=x \
       \( -execdir unstripped '{}' \; -fprint ubins -o -fprint sbins \)


File: find-ja.info,  Node: Common Tasks,  Next: Databases,  Prev: Actions,  Up: Top

4 一般的な作業
**************

以下のセクションには，これらのプログラムの能力を利用する際の良い考えを
与え，一般的な現実問題を解説する方法を提示している，拡張された例を含ま
れています．

* Menu:

* Viewing And Editing::
* Archiving::
* Cleaning Up::
* Strange File Names::
* Fixing Permissions::
* Classifying Files::


File: find-ja.info,  Node: Viewing And Editing,  Next: Archiving,  Up: Common Tasks

4.1 閲覧と編集
==============

特定の基準を満たすファイルのリストを見るために，引数にファイル名を用い
て，単純にファイルビューアープログラムを実行します．シェルは，バックク
オートで囲まれたコマンドを，その出力に置換するので，コマンド全体は以下
のようになります．

     less `find /usr/include -name '*.h' | xargs grep -l mode_t`

ファイルビューアープログラムの代わりにエディタの名前を与えることで，こ
れらのファイルを編集することも可能です．

     emacs `find /usr/include -name '*.h' | xargs grep -l mode_t`

コマンドラインには個別の長さに制限があるので，この方法で処理されるファ
イル数には制限があります．以下のように`xargs'を使用することで，
この面倒なことを回避します．

     find /usr/include -name '*.h' | xargs grep -l mode_t > todo
     xargs --arg-file=todo emacs

   これで，`xargs'はファイル`todo'にリストアップされているすべて
のファイルに必要な回数，`emacs'を実行します．


File: find-ja.info,  Node: Archiving,  Next: Cleaning Up,  Prev: Viewing And Editing,  Up: Common Tasks

4.2 アーカイブ
==============

`find'で生成したファイルリストを，ファイルアーカイブプログラムに渡
すことも可能です．GNU `tar'と`cpio'は，どちらも標準入力からファ
イル名のリストを読み込むことが可能です--ヌル(安全な方法)，または，空白
(簡単だが危険なデフォルトの方法)のどちらかで分離します．ヌルで名前を分
離する方法を使用するため，`--null'オプションを与えてください．ファ
イルアーカイブをファイルに保存したり，テープに書き出したり，ネットワー
ク越しの他のマシンに展開したりすることも可能です。

   ファイルをアーカイブする一般的な`find'の使用方法は，ディレクトリツ
リー内のファイルリストを`cpio'に送る方法です．所有者がディレクトリ
に書き込み権限が無い場合は`-depth'を使用し，(その場合)ディレクトリ
の権限はそのコンテンツのリストア後にリストアされるため，そのコンテンツ
をアーカイブからリストアすることが可能です．こうするために`cpio'使
用した例がここにあります．特定のファイルのみアーカイブするために，より
複雑な`find'の式を使用することも可能です．

     find . -depth -print0 |
       cpio --create --null --format=crc --file=/dev/nrst0

以下のコマンドを使用して，そのアーカイブをリストアすることが可能です．

     cpio --extract --null --make-dir --unconditional \
       --preserve --file=/dev/nrst0

   同じことを`tar'を使用して行なうコマンドは以下のようになります．

     find . -depth -print0 |
       tar --create --null --files-from=- --file=/dev/nrst0

     tar --extract --null --preserve-perm --same-owner \
       --file=/dev/nrst0

一つのマシンから他のマシンに，ディレクトリをコピーする例は以下のように
なります．

     find . -depth -print0 | cpio -0o -Hnewc |
       rsh OTHER-MACHINE "cd `pwd` && cpio -i0dum"


File: find-ja.info,  Node: Cleaning Up,  Next: Strange File Names,  Prev: Archiving,  Up: Common Tasks

4.3 クリーンアップ
==================

このセクションでは，さまざまな状況で，不要なファイルを削除する例を提供
します．マージの要求で更新された時に作成されるCVSバックアップファイルを
削除するコマンドは以下のようになります．

     find . -name '.#*' -print0 | xargs -0r rm -f

   上記のコマンドは動作しますが，以下のものがより安全です．

     find . -name '.#*' -depth -delete

   `/tmp'内のゴミファイルをきれいにするためにこのコマンドを実行するこ
とが可能です．ログアウトする時にシェルがそれを実行するよう，(使用してい
るシェルに依存しますが，`.bash_logout'，`.logout'，または
`.zlogout')ファイルに書き出すことも可能です．

     find /tmp -depth -user "$LOGNAME" -type f -delete

   `find'コマンドでディレクトリを削除する場合，`find'が削除され
たディレクトリの再帰的な削除を試みるとき，偽りのエラーメッセージを見る
かもしれません．`-depth'オプションを使用することで，通常この問題は
解決されます．

古いEmacsのバックアップファイルと自動保存ファイルを削除するために，以下
のようなコマンドが使用可能です．VMメーラーのようなEmacsパッケージは，
`#reply to David J. MacKenzie<1>#'のようにスペースを含む一時ファイ
ルを作成することが多いので，ヌルで終端されているファイル名を使用する方
法は，この場合には特に重要です．

     find ~ \( -name '*~' -o -name '#*#' \) -print0 |
       xargs --no-run-if-empty --null rm -vf

   `/tmp'から古いファイルを削除するため，通常は`cron'から実行し ます．

     find /tmp /var/tmp -not -type d -mtime +3 -delete
     find /tmp /var/tmp -depth -mindepth 1 -type d -empty -delete

   上記の二番目の`find'コマンドは，空のディレクトリの最初の深度をきれ
いにするため`-depth'を使用し，それで親が空になり，削除も可能になる
ことを期待しています．全体が空になった場合，`/tmp'自身を削除しない
ように，`-mindepth'を使用しています．


File: find-ja.info,  Node: Strange File Names,  Next: Fixing Permissions,  Prev: Cleaning Up,  Up: Common Tasks

4.4 奇妙なファイル名
====================

`find'は，名前に奇妙な文字を含むファイルを，削除したり名前を変更し
たりする手助けにもなります．スペース，タブ，制御文字，またはハイビット
セットを用いた文字のような，もの(文字)を含む名前のファイルに邪魔される
ときもあります．そのようなファイルを削除する最も簡単な方法は，以下のよ
うになります．

     rm -i SOME*PATTERN*THAT*MATCHES*THE*PROBLEM*FILE

   `rm'は，与えられたパターンにマッチするそれぞれのファイルを削除する
かどうか尋ねます．古いシェルを使用している場合で，ファイル名にハイビッ
トセットを用いた文字を含む場合には，この方法は動作しません．シェルはそ
れを削除します．より信頼できる方法は，以下のようになります．

     find . -maxdepth 1 TESTS -okdir rm '{}' \;

ここでのTESTSは，ファイルをユニークに識別します．`-maxdepth
1'オプションは，`find'があらゆるサブディレクトリのファイルを検索す
ることで，時間を無駄にすることを妨げます．サブディレクトリが無い場合は
省略してもかまいません．問題のファイルをユニークに識別する良い方法は，
そのinode番号を知ることです．以下のように使用します．

     ls -i

制御文字を名前に含んでいるファイルがあって，そのinode番号が12345だと分
かったと仮定します．以下のコマンドは，それを削除するかどうか，プロンプ
トを表示します．

     find . -maxdepth 1 -inum 12345 -okdir rm -f '{}' \;

ファイル名が奇妙な文字列を含んでいて，出力時にスクリーンが駄目になるた
め，尋ねられたくない場合は，`-okdir'の代わりに`-execdir'を使
用して下さい．

   そうではなく，ファイルの名前を変更したい場合，`rm'の代わりに
`mv'を使用することが可能です．

     find . -maxdepth 1 -inum 12345 -okdir mv '{}' NEW-FILE-NAME \;


File: find-ja.info,  Node: Fixing Permissions,  Next: Classifying Files,  Prev: Strange File Names,  Up: Common Tasks

4.5 権限の修正
==============

特定のディレクトリツリーのディレクトリに，誰でも書き込めることを確実に
したいと仮定します．ユーザまたはグループ(または両方)の権限が無く，それ
らの権限を修正する方法は以下のようになります．

     find . -type d -not -perm -ug=w | xargs chmod ug+w

ディレクトリが誰でも書き込め_ない_ことを確実にしたい場合，反対の処
理も可能でしょう．


File: find-ja.info,  Node: Classifying Files,  Prev: Fixing Permissions,  Up: Common Tasks

4.6 ファイルの分類
==================

ファイルの集合を異なる基準でいくつかのグループに分類したい場合，ファイ
ル上で複数の独立したテストを実行するため，カンマオペレータを使用するこ
とが可能です．例えば以下のようにします．

     find / -type d \( -perm -o=w -fprint allwrite , \
       -perm -o=x -fprint allexec \)

     echo "Directories that can be written to by everyone:"
     cat allwrite
     echo ""
     echo "Directories with search permissions for everyone:"
     cat allexec

   `find'は，ディレクトリツリー全体を一度走査する必要があるだけです
(それはその作業で最も時間がかかる部分の一つです)．


File: find-ja.info,  Node: Databases,  Next: File Permissions,  Prev: Common Tasks,  Up: Top

5 ファイル名のデータベース
**************************

`locate'で使用されるファイル名のデータベースには，データベースが最
後に更新された時の，特定のディレクトリツリー内のファイルのリストが含ま
れています．データベースのデフォルトファイル名は，`locate'と
`updatedb'がコンフィグレーションされインストールされた時に決定され
ます．データベースが更新される頻度と，項目に含めるディレクトリは，
`updatedb'が実行される頻度と，その引数に依存します．

   `locate --statistics'を使用することで，データベースの統計情報を得
ることが可能です．

* Menu:

* Database Locations::
* Database Formats::
* Newline Handling::


File: find-ja.info,  Node: Database Locations,  Next: Database Formats,  Up: Databases

5.1 データベースの位置
======================

複数のファイル名のデータベースを存在させることが可能です．ユーザは，
`locate'が検索を行なうデータベースを，`LOCATE_PATH'環境変数や
コマンドラインオプションを使用して選択することが可能です．システム管理
者は，デフォルトのデータベースのファイル名，データベースを更新する頻度，
そして，項目に含めるディレクトリを選択することが可能です．ファイル名の
データベースは，`updatedb'プログラムで，通常夜に実行され更新されま す．

ネットワーク環境では，ファイルシステムの項目を含めながら，それぞれのルー
トファイルシステムでデータベースを構築することに意味があります．
`updatedb'は，ネットワークのスラッシングを避けるため，ファイルシス
テムがローカルディスクにあるファイルサーバの，それぞれのファイルシステ
ムで実行されます．`updatedb'に，それぞれのデータベースが含んでいる
項目のディレクトリを選択させるオプションは以下のとおりです．

   `updatedb'のオプションの記述で，項目を含むデータベースがあるディレ
クトリの指定は，*Note Invoking updatedb::.


File: find-ja.info,  Node: Database Formats,  Next: Newline Handling,  Prev: Database Locations,  Up: Databases

5.2 データベースの書式
======================

ファイル名のデータベースには，データベースが最後に更新された時の，特定
のディレクトリツリーのファイルのリストを含まれます．ファイル名のデータ
ベースの書式変更は，異なるバイト順序を用いるマシンでも，データベースの
共有が可能となるように，GNU `locate'バージョン4.0から開始されまし
た．新しいGNU `locate'は，新旧両方のデータベースの書式を読み込むこ
とが可能です．しかし，古いバージョンの`locate'と`find'では，
新しい書式のデータベースを与えられた場合，間違った結果となります．

   `locate --statistics'を実行した場合，要約された結果は，それぞれの
`locate'のデータベースの形式を示します．

* Menu:

* New Database Format::
* Sample Database::
* Old Database Format::


File: find-ja.info,  Node: New Database Format,  Next: Sample Database,  Up: Database Formats

5.2.1 新しいデータベースの書式
------------------------------

`updatedb'は，4の要素を5にする(1)ことでデータベースの大きさが小さくなるように，ファイル名のリ
ストを"前部圧縮(front-compress)"するため，`frcode'を実行します．
前部圧縮(増分符合化としても知られている)は以下のように動作します．

データベースの項目は，(ユーザの利便性のため，大文字小文字を識別しないで)
ソートされているリストです．リストはソートされているので，それぞれの項
目は，前の項目と同じ接頭辞(最初の文字列)を共有することがよくあります．
それぞれのデータベース項目はオフセットバイトの差分の数で始まっていて，
それは前の項目の更に前のものが使用している数より多くなる，前の項目に前
置される接頭辞への追加の文字数です．(数は負になることもあります．) それ
以降の数は，ヌルで終端されているASCII文字の残りです--共有している接尾
辞以降の名前の部分です．

オフセット差分数がバイト(+/-127)で保存できるものより大きい場合，バイト
の値が0x80になり，それ以下の2バイトがその数値になっていて，それはハイバ
イトを最初(ネットワークバイトの順序)にしたものを用います．

   すべてのデータベースは，`LOCATE02'と呼ばれるダミーの項目で始まって
いて，それは，データベースファイルの書式が正しいことを確認するために，
`locate'が調査するものです．検索時にはその項目は無視されます．

最初の(ダミー)項目を，先頭のデータベース以外からすべて切り取っても，デー
タベースを連結させることは不可能です．これは，二番目とそれ以降の最初の
項目にあるオフセット差分数が間違ってしまうためです．

   `locate --statistics'の出力で，新しいデータベースの書式は
`LOCATE02'として参照します．

   ---------- Footnotes ----------

   (1) 訳注：原文はby a factor of 4 to 5


File: find-ja.info,  Node: Sample Database,  Next: Old Database Format,  Prev: New Database Format,  Up: Database Formats

5.2.2 サンプルデータベース
--------------------------

`frcode'へのサンプル入力です．

     /usr/src
     /usr/src/cmd/aardvark.c
     /usr/src/cmd/armadillo.c
     /usr/tmp/zoo

共有するために前置される，最も長い接頭辞の長さは以下のようになります．

     0 /usr/src
     8 /cmd/aardvark.c
     14 rmadillo.c
     5 tmp/zoo

   最後のヌルを改行に変更し，バイトを印字可能文字に変更した場合の，
`frcode'からの出力は以下のようになります．

     0 LOCATE02
     0 /usr/src
     8 /cmd/aardvark.c
     6 rmadillo.c
     -9 tmp/zoo

   (6 = 14 - 8，そして -9 = 5 - 14)


File: find-ja.info,  Node: Old Database Format,  Prev: Sample Database,  Up: Database Formats

5.2.3 古いデータベースの書式
----------------------------

古いデータベースの書式は，Unixの`locate'と`find'プログラム，
そして早期のGNUがリリースしたもので使用されています．`updatedb'は，
`--old-format'オプションが与えられた場合，この書式で生成します．

   `updatedb'は，古い書式のデータベースを生成するために， `bigram'
と`code'と呼ばれるプログラムを実行します．古い書式は，
新しいものと以下の方式で異なります．オフセット差分数バイトで始まりヌル
で終るそれぞれの項目の代わりに，-14から14までのオフセット差分数を示す0
から28の値になります．それ以上の大きなオフセット差分数を示すバイト値は，
0x1e
(30)で0x80ではありません．大きな数は，ホストのバイト順でソートされ，
それはネットワークバイトの順序である必要はなく，ホストのワード整数の大
きさとなっていて，それは通常4バイトです．その値が14より小さいものは表示
されません．データベースの行には終端バイトがありません．次の行の先頭は，
30より小さい値を持つバイトで示されます．

更に，最初のダミー項目で始まる代わりに，古いデータベース書式は，ファイ
ルリストで最も一般的な128の`bigram'を含んでいる，256バイトの表で始
まります．`bigram'は調整されたバイトの組となっています．ハイビット
セットを持つデータベースのバイトは，(ハイビットがクリアされてい
る)`bigram'表内部の索引です．`bigram'とオフセット差分数の符合
化は，これらのデータベースを，新しい書式より20から25%まで小さくしますが，
8ビットクリーンにはなりません．特殊コードに使用される範囲にあるファイル
名のバイトは，データベース内では疑問符に置換され，それは，単一文字にマッ
チするシェルのワイルドカードにはマッチしません．

そのため古い書式では，ASCII以外の文字の項目を忠実の保存することが不可能
です．そのため，国際化環境では使用すべきではありません．

   `locate --statistics'の出力は，古い書式の改行やハイビット文字を含
むファイル名の計数で間違えてしまうでしょう．


File: find-ja.info,  Node: Newline Handling,  Prev: Database Formats,  Up: Databases

5.3 改行の取り扱い
==================

データベースでは，ファイル名はヌル文字で終端されています．これは，古い
書式も新しい書式も同じようになっています．

   新しいデータベースの書式が使用されているとき，`frcode'に渡す前の，
ファイルのリストの並べ替え能力に依存する圧縮技術が，データベースの生成
に使用されています．

   システムのソートコマンドが，入力されるファイルのリストを`-z'オプショ
ンでヌル文字で分離している場合，このオプションが使用され，そのため，
`updatedb'と`locate'は両方共，改行を含むファイル名を正しく処
理します．`sort'コマンドにこのサポートが無い場合，ファイルのリスト
は改行文字で分離され，つまり，改行を含むファイルの部分は間違って並べ替
えられます．結果として，正しくないマッチと，正しくない間違ったマッチの
両方が発生します．

一方，古いデータベース書式を使用している場合，改行が埋め込まれたファイ
ル名は正しく処理されません．これを強制する技術的な制限は無いので，
`bigram'プログラムはヌルで分離されているファイル名のリストをサポー
トするように更新されていません．

そのため，新しいデータベース書式を使用していて(これはデフォルトです)，
システムでGNU `find'を使用している場合，改行はいつでも正しく処理さ
れます．そうでなければ，改行は正しく処理されない可能性があります．


File: find-ja.info,  Node: File Permissions,  Next: Reference,  Prev: Databases,  Up: Top

6 ファイルの権限
****************

それぞれのファイルには，ファイルに対してユーザ持つアクセスの種類を制御
する"権限(permissions)"の設定があります．ファイルに対する権限は
"アクセスモード(access mode)"とも呼ばれます．それらは，抽象的な形式
または八進数で表示可能です．

* Menu:

* Mode Structure::              Structure of file permissions.
* Symbolic Modes::              Mnemonic permissions representation.
* Numeric Modes::               Permissions as octal numbers.


File: find-ja.info,  Node: Mode Structure,  Next: Symbolic Modes,  Up: File Permissions

6.1 ファイルの権限の構造
========================

ユーザがファイルに対して持つ権限は三種類のあります．

  1. ファイルを読み込む権限です．ディレクトリに対しては，これはディレクトリ
     の内容をリストアップする権限という意味があります．

  2. ファイルを書き込む(変更する)権限です．ディレクトリに対しては，これはディ
     レクトリでのファイルの作成と削除の権限を意味します．

  3. ファイルを実行(それをプログラムとして実行)する権限です．ディレクトリに
     対しては，これはディレクトリのファイルにアクセスする権限を意味します．

ファイル上で上記のあらゆる処理を行うため，異なる権限を持つ，三つのユー
ザの分類があります．

  1. ファイルの所有者．

  2. ファイルのグループにいるその他のユーザ．

  3. その他全員．

ファイルが作成されるとき，所有者とグループが与えられます．通常，所有者
は現在のユーザで，グループはファイルがあるディレクトリのグループですが，
これはオペレーティングシステム，ファイルが作成されるファイルシステム，
そしてファイルが作成される方法で変化します．`chown'と`chgrp'
コマンドを使用してファイルの所有者とグループを変更することが可能です．

上記でリストアップされた三つの権限の三つの設定に加えて，ファイルの権限
には三つの特別な構成部分があり，それは実行可能なファイル(プログラム)と，
システムによっては，ディレクトリだけに効果があります．

  1. プロセスの事実上のユーザIDを，実行時にファイルのものに設定します
     ("setuid bit"と呼ばれます)．ディレクトリには効果がありません．

  2. プロセスの事実上のグループIDを，実行時にファイルのものに設定します
     ("setgid
     bit"と呼ばれます)．システムによって，ディレクトリに対して，
     そのディレクトリで作成されたファイルを同じグループのディレクトリに書き
     込んでも，それを作成したユーザのグループは問題ありません．

  3. スワップデバイス上にプログラムのテキストイメージを保存するので，実行時
     により速くロードされます("sticky bit"と呼ばれます)．システムによっ
     て，ディレクトリに対して，ユーザがそのディレクトリで所有していないファ
     イルを削除することを妨げます．これは"追加のみ(append-only)"のディレ
     クトリ作成と呼ばれます．


File: find-ja.info,  Node: Symbolic Modes,  Next: Numeric Modes,  Prev: Mode Structure,  Up: File Permissions

6.2 記号的なモード
==================

"記号的なモード(symbolic modes)"とは，単一文字のシンボルを処理して，
ファイルの権限を変更することを表します．それは，ファイルの権限のすべて
または選択された部分を修正可能にし，オプションでそれらに前置される値と，
おそらく現在の`umask'にも基づきます(*note Umask and Protection::)．

   記号的なモードの書式は以下の通りです．

     [ugoa...][[+-=][rwxXstugo...]...][,...]

   以下のセクションで，記号的なモードのその他の詳細の処理を記述します．

* Menu:

* Setting Permissions::          Basic operations on permissions.
* Copying Permissions::          Copying existing permissions.
* Changing Special Permissions:: Special permissions.
* Conditional Executability::    Conditionally affecting executability.
* Multiple Changes::             Making multiple changes.
* Umask and Protection::              The effect of the umask.


File: find-ja.info,  Node: Setting Permissions,  Next: Copying Permissions,  Up: Symbolic Modes

6.2.1 権限の設定
----------------

ファイル権限へ基本的な記号的な処理で，特定ユーザのファイルの読み込み，
書き込み，そして実行の権限を，追加，削除，そして設定します．これらの処
理は以下の書式です．

     USERS OPERATION PERMISSIONS

上記の三つの部分の間のスペースは，可読性のみのために表示しています．記
号的なモードではスペースを含めることはできません．

   USERS部は，変更されるファイルのユーザアクセス権限を伝えます．それ
は，一文字以上の以下の文字から成り立ちます(または，空にすることもできま
す．そのとき生じることは，*note Umask and Protection::)．これらの文字の
一つ以上が与えられるとき，その順番は重要ではありません．

`u'
     ファイルを所有しているユーザ．

`g'
     ファイルのグループのその他のユーザ．

`o'
     その他すべてのユーザ．

`a'
     すべてのユーザで，`ugo'と同じです．

   OPERATION部は，ファイルにアクセスするユーザの効果を変更する方法を
伝え，以下のシンボルの一つになります．

`+'
     USERSが既に持つ，そのファイルに対するあらゆる権限に，
     PERMISSIONSを加えます．

`-'
     USERSが既に持つ，そのファイルに対するあらゆる権限から，
     PERMISSIONSを削除します．

`='
     USERSが持つ，そのファイルに対する権限を，PERMISSIONSのみにし ます．

   PERMISSIONS部は，ファイルの変更されるアクセスの種類を伝えます．ゼ
ロ以上の文字になります．USERS部を用いた場合，一文字以上与えられた
ときは，その順序は重要ではありません．PERMISSIONS部の省略は，
`='の時のみ役に立ち，それは指定されたUSERSにそのファイルに対
するすべてのアクセス権を取り除きます．

`r'
     USERSがファイルを読み込むのに必要な権限です．

`w'
     USERSがファイルに書き込むのに必要な権限です．

`x'
     USERSがファイルを実行するのに必要な権限です．

例えば，全員にファイルの読み込みと書き込みの権限を与え，実行を与えない
ために，以下を使用してください．

     a=rw

ファイルの所有者以外のすべてのユーザから書き込み権限を削除するため，以下を
使用してください．

     go-w

上記のコマンドは，ファイルの所有者のアクセス権に効果が無く，その他のユー
ザが，ファイルの読み込みと実行が可能かどうかにも効果がありません．

ファイルの所有者以外全員に，そのファイルに対しあらゆる権限を与えないた
めに，以下のモードを使用してください．他のユーザは，ファイルがあるディ
レクトリに書き込み権限がある場合，ファイルを削除可能です．

     go=

同じことを指定するもう一つの方法です．

     og-rxw


File: find-ja.info,  Node: Copying Permissions,  Next: Changing Special Permissions,  Prev: Setting Permissions,  Up: Symbolic Modes

6.2.2 既存の権限をコピー
------------------------

ファイルの権限を，既存の権限の一部を基準にすることができます．こうする
ために，オペレータの後に`r'，`w'や`x'を使用する代わりに，
文字`u'，`g'や`o'を使用します．例えば以下のモードです．

     o+g

それは，ファイルのグループにいるユーザに対する権限を，その他のユーザが
そのファイルに対して持っている権限に追加します．このため，ファイルが最
初にモード664 (`rw-rw-r--')の場合，上記のモードは，それを666
(`rw-rw-rw-')に変更します．ファイルが最初にモード741
(`rwxr----x')の場合，上記のモードは，それを745 (`rwxr--r-x')
に変更します．`-'と`='の処理は同様に動作します．


File: find-ja.info,  Node: Changing Special Permissions,  Next: Conditional Executability,  Prev: Copying Permissions,  Up: Symbolic Modes

6.2.3 特定の権限を変更
----------------------

ファイルの読み込み，書き込み，そして実行の権限の変更に加えて，特別な権
限を変更できます．権限の概要は，*Note Mode Structure::.

   実行時にファイルの権限をユーザIDに設定するため，記号的なモードの
USERS部で`u'と，PERMISSIONS部で`s'を使用してくだ さい．

   実行時にファイルの権限をグループIDに設定するため，記号的なモードの
USERS部で`g'とPERMISSIONS部で`s'を使用してくださ い．

スワップデバイスに永久に残すファイルの権限を変更するため，記号的なモー
ドのUSERS部で`o'とPERMISSIONS部で`t'を使用してく ださい．

例えば，ユーザID権限をプログラムに加えるため，以下のモードを使用するこ
とが可能です．

     u+s

ユーザIDのとグループIDの権限の設定をそれから削除するため，以下のモード
を使用することが可能です．

     ug-s

プログラムがスワップデバイスに保存されるようにするため，以下のモードを
使用することが可能です．

     o+t

特別な権限は実行形式のファイルと，システムによってはディレクトリ(そこで
は異なる意味を持ちます．*note Mode Structure::)だけに効果があることを，
覚えておいてください．記号的なモードのUSERS部で`a'を用いる場
合，特別な権限には効果がありません．このため，以下の例を考えます．

     a+s

これは，_全く効果がありません_．特別な権限を効果的にするために，
`u'，`g'，そして`o'を明示的に使用する必要があります．ま
た，`u+t'，`g+t'，そして`o+s'の組み合わせも効果がありま せん．

   `='オペレータは，特別な権限に用いる場合，全く役に立ちません．例え
ば，モードを以下のようにします．

     o=t

これは，ファイルをスワップデバイスに保存するようにしますが，それは，ファ
イルのグループにいないユーザが持っている可能性のある，すべての，読み込
み，書き込み，そして実行の権限を削除します．


File: find-ja.info,  Node: Conditional Executability,  Next: Multiple Changes,  Prev: Changing Special Permissions,  Up: Symbolic Modes

6.2.4 実行可能の条件
--------------------

記号的な権限の特別な形式がもう一つあります．`x'の代わりに`X'
を用いた場合，実行権限は，既に実行形式があるファイル，またはディレクト
リのみに効果があります．それは，ディレクトリが最初にあらゆる実行権限を
持っていない場合でも，ディレクトリの実行権限に効果があります．

   例えば，以下のようなモードにします．

     a+X

これは，すべてのユーザに，それまでに持っていなかった，ファイルの実行(や
ディレクトリの検索)の権限を与えます．


File: find-ja.info,  Node: Multiple Changes,  Next: Umask and Protection,  Prev: Conditional Executability,  Up: Symbolic Modes

6.2.5 複数の変更
----------------

記号的なモードの書式は，実際に上記で記述したより複雑です (*note Setting
Permissions::)．それは，ファイルの権限を複数変更する二つ
の方法を提供します．

   最初の方法は，記号的なモードで，複数のOPERATION部と
PERMISSIONS部をUSERS部の後で指定する方法です．

   例えば，以下のようなモードにします．

     og+rX-w

これは，ファイルの所有者以外のユーザに，ファイルの読み込み権限を与え，
それがディレクトリの場合や，既に誰かに実行形式の権限がある場合，実行権
限を与えます．そして，それはファイルの書き込み権限を禁止します．それは
ファイルの所有者が持つ権限に影響しません．上記のモードは以下の二つのモー
ドと同じです．

     og+rX
     og-w

複数の変更をするための二番目の方法は，一つ以上の単純な記号的なモードを
カンマで分けて指定する方法です．例えば，以下のようなモードにします．

     a+r,go-w

これは，全員にファイルの読み込み権限を与え，所有者以外全員の書き込み権
限を削除します．もう一つの例です．

     u=rwx,g=rx,o=

これは，特別でない権限のすべてを，ファイルに明示的に設定します．(それは
ファイルのグループではないユーザに，権限を全く与えません．)

   二つの方法は組み合わせることが可能です．以下のモードになります．

     a+r,g+x-w

これは，すべてのユーザに，ファイルの読み込み権限を与え，ファイルのグルー
プにいるユーザに実行権限も与えますが，書き込み権限は与えません．上記の
モードは別の方法で書くこともできます．その一つは以下になります．

     u+r,g+rx,o+r,g-w


File: find-ja.info,  Node: Umask and Protection,  Prev: Multiple Changes,  Up: Symbolic Modes

6.2.6 umaskと保護
-----------------

記号的なモードのUSERS部が省略されている場合，システム変数
`umask'で_無効に__設定されている_権限以外，デフォルトは `a'
(で，すべてのユーザに影響します)．`umask'の値は
`umask'コマンドを使用して設定できます．そのデフォルト値は，システ
ムごとに異なります．

   記号的なモードのUSERS部の省略は，`+'以外のオペレーションでは
通常は役に立ちません．希望しないファイルに対する追加の権限を与えるため
に，簡単なカスタマイズを保護するため`umask'が使用可能なので，それ
は`+'とともに用いると役に立ちます．

   例として，`umask'の値が2の場合，それはファイルのグループ以外のユー
ザに対し書き込み権限を削除します．以下のモードを考えます．

     +w

これは，その所有者とファイルのグループのユーザに対する書き込み権限を追
加しますが，それ以外のユーザには与え_ません_．対照的に，以下のモー
ドを考えます．

     a+w

これは`umask'を無視し，すべてのユーザに対し，書き込み権限を与える
_のです_．


File: find-ja.info,  Node: Numeric Modes,  Prev: Symbolic Modes,  Up: File Permissions

6.3 数値的なモード
==================

ファイルの権限は，内部では16ビットの整数で保存されます．記号的なモード
の代わりとして，新しいモードの内部に対応した適切な八進数(基数8)で与える
ことができます．この数は常に八進数で処理されます．Cのような0を前置する
必要はありません．モード0055はモード55と同じです．

通常，数値的なモードは，対応する記号的なモードより短くなりますが，以前
のファイルの権限を考慮にいれることに制限があります．それは絶対的な設定
が可能なだけです．

ユーザ，ファイルのグループのその他のユーザ，そしてファイルのグループで
はないその他のユーザに応じた権限は，それぞれ三つのビットになり，それは
一つの八進数として表現されます．ここに16ビットの整数にアレンジされたビッ
トがあり，最下位ビットからはじめます．

     対応する値
     モード    権限

               ファイルのグループにいないその他のユーザ：
        1      実行
        2      書き込み
        4      読み込み

               ファイルのグループのその他のユーザ：
       10      実行
       20      書き込み
       40      読み込み

               ファイルの所有者：
      100      実行
      200      書き込み
      400      読み込み

               特別な権限：
     1000      テキストイメージをスワップデバイスに保存
     2000      実行時のグループIDを設定
     4000      実行時のユーザIDを設定

   例えば，数値的なモードの4755は，記号的なモードの`u=rwxs,go=rx'に，
数値的なモードの664は，記号的なモードの`ug=rw,o=r'に対応します．数
値的なモードの0は，記号的なモードの`ugo='に対応します．


File: find-ja.info,  Node: Reference,  Next: Security Considerations,  Prev: File Permissions,  Up: Top

7 リファレンス
**************

以下は，このマニュアルで示してきたプログラムに対する，コマンドラインの
構文の概要です．

* Menu:

* Invoking find::
* Invoking locate::
* Invoking updatedb::
* Invoking xargs::


File: find-ja.info,  Node: Invoking find,  Next: Invoking locate,  Up: Reference

7.1 `find'の呼び出し
====================

     find [-H] [-L] [-P] [FILE...] [EXPRESSION]

   `find'は，それぞれのファイル名FILEをルートとするディレクトリ
ツリーを，そのツリーで見つかったそれぞれのファイル上でEXPRESSION
を評価しながら検索します．

   オプションの`-H'，`-L'，または`-P'は，コマンドラインの最
初に指定してもかまいません(これらが指定されていない場合，`-P'が仮
定されます)．これらの後の引数は，検索するファイルやディレクトリのリスト
です．

検索するファイルのリストには，検索したいファイルの記述式のリストが続き
ます．式の最初の部分は，`-'，`(', `)'，`,'，または
`!'で始まるという事で認識されます．それ以降のあらゆる引数は式の残
りとみなします．パスが与えられていない場合，現在のディレクトリが使用さ
れます．式が与えられていない場合，式`-print'が使用されます．

   `find'は，すべてのファイルが正しく処理された場合は0のステータスで，
エラーが発生した場合は0より大きなステータスで終了します．

パス名に三つのオプションを前置することが可能です．それらはシンボリック
リンクの扱い方を決定します．

`-P'
     `-xtype'指示語以外で，シンボリックリンクをたどりません(これがデフォ
     ルトです)．

`-L'
     `-xtype'指示語以外で，常にシンボリックリンクをたどります．

`-H'
     検索パスのリストで指定されている，または，コマンドラインで指定されてい
     るシンボリックリンクをたどります．

   `find'がシンボリックリンクをたどるつもりが，なんらかの理由で不可能
な場合(例えば，十分な権限が無いとか，リンクが壊れているとか)，シンボリッ
クリンク自身の属性を使用するようになります．シンボリックリンクの取り扱
いの完全な記述は，*Note Symbolic Links::.

式に含めることが可能なすべてのテスト，アクション，そしてオプションの概
要は，*Note Primary Index::.  式が無い場合，`-print'が仮定されます．

   `find'は，管理上で使用するため，二つのオプションも認識します．

`--help'
     コマンドライン引数の書式の概要を出力し，終了します．

`--version'
     `find'のバージョンナンバーを出力し，終了します．

* Menu:

* Warning Messages::


File: find-ja.info,  Node: Warning Messages,  Up: Invoking find

7.1.1 警告メッセージ
--------------------

`find'のコマンドラインにエラーがある場合，通常エラーメッセージが出
力されます．しかし，勧められないが`find'は受け入れる使用方法もあり
ます．この状況では，`find'は警告メッセージを出力します．デフォルト
で，`find'が対話的に実行されている場合だけ(特に，標準入力が端末の
場合)，警告メッセージが利用可能です．警告メッセージはコマンドラインオプ
ションで，明示的に制御することが可能です．

`-warn'
     適切なところで警告メッセージを発行します．

`-nowarn'
     警告メッセージを発行しません．

これらのオプションは，コマンドラインで指定されている場所で効果がありま
す．このため，`-nowarn'をコマンドラインの最後に指定している場合，
それ以前に発生した問題の警告メッセージは表示されません．上記のオプショ
ンで変更される警告メッセージは，以下のものに影響します．

   - 推奨されない`-d'オプションの使用．POSIX互換の`-depth'を代わり
     に使用してください．

   - 推奨されない`-ipath'オプションの使用．`-iwholename'を代わりに
     使用してください．

   - コマンドラインのオプション以外(例えば，`-type'や`-print')の後
     でのオプション(例えば`-mindepth')の指定．

上記のデフォルトの動作は，そのような構成の既存のシェルスクリプトで重大
なエラーを生成しない方法で，ユーザが問題に気付くように動作するよう設計
されています．

警告メッセージには，あまり一般的ではない，またはより重要な問題で出力さ
れ，それらは停止できません．

   - `-fprintf'での，認識できないバックスラッシュ・エスケープ・シーケン
     スの使用．

   - `-fprintf'での，認識できない書式指示語の使用．


File: find-ja.info,  Node: Invoking locate,  Next: Invoking updatedb,  Prev: Invoking find,  Up: Reference

7.2 `locate'の呼び出し
======================

     locate [OPTION...] PATTERN...

`--all'
`-A'
     オプションではない引数の，一つまたはそれ以上ではなく，すべての引数にマッ
     チした名前だけを出力します．

`--basename'
`-b'
     `locate'データベースのファイル名の最後の構成要素に対してマッチする
     パターンを指定します．最後の構成要素は，"ベース名(base
     name)"と呼ばれ ます．例えば，`/tmp/mystuff/foo.old.c'のベース名は
     `foo.old.c'になります．パターンにメタ文字が含まれている場合，ベー
     ス名に正確にマッチする必要があります．そうでない場合，ベース名の一部が
     マッチする必要があります．

`--count'
`-c'
     `--print' (`-p')も指定されていない限り，マッチしたファイル名
     を出力する代わりに，見つかったマッチ数だけを出力します．

`--database=PATH'
`-d PATH'
     デフォルトのファイル名のデータベースを検索する代わりに，PATHにあ
     るファイル名のデータベースを検索し，それはコロンで分離されたデータベー
     スファイル名のリストになります．環境変数`LOCATE_PATH'を検索するデー
     タベースファイルに設定する方法も使用可能です．両方使用されている場合，
     オプションは環境変数に優先します．PATHの空の項目(すなわち，先頭と
     末尾のコロンや，一行に二つのコロン)は，デフォルトのデータベースとして受
     け取ります．`path'の項目で`-'を使用することで，データベースは
     標準入力からも提供することが可能です．`path'の一つ以上の`-'が
     構成要素にある場合，後のものが無視されます(しかし，警告メッセージは出力
     されます)．

`--existing'
`-e'
     (データベースが作成されたときに存在していた名前の代わりに)現在，存在し
     ている名前だけ出力されます．データベースのマッチが多い場合，プログラム
     が非常に遅くなることに注意してください．壊れたシンボリックリンクの扱い
     方は，`-L'，`-P'，そして`-H'オプションが影響します．

`--non-existing'
`-E'
     (データベースが作成されたときに存在していた名前の代わりに)現在，存在し
     ていない名前だけ出力されます．データベースのマッチが多い場合，プログラ
     ムが非常に遅くなることに注意してください．壊れたシンボリックリンクの扱
     い方は，`-L'，`-P'，そして`-H'オプションが影響します．

`--follow'
`-L'
     (`-e'や`-E'オプションで)ファイルの存在を調査する場合，壊れて
     いるシンボリックリンクは存在しないものとみなします．これはデフォルトで
     す．

`--nofollow'
`-P'
`-H'
     (`-e'や`-E'オプションで)ファイルの存在を調査する場合，壊れて
     いるシンボリックリンクはファイルが存在しているかのように処理します．こ
     のオプションの`-H'の形式は，`find'に類似しているために提供さ
     れています．`-H'ではなく`-P'の使用が推奨されます．

`--ignore-case'
`-i'
     パターンとファイル名の両方で，大文字小文字の違いを無視します．

`--limit=N'
`-l N'
     結果として出力する数をNに制限します．`--count'オプションを使
     用している場合，出力される値はこの制限より大きくなりません．

`--mmap'
`-m'
     受け入れられますが何もしません．このオプションは，BSDの`locate'と
     の互換性を提供するためだけにサポートされています．

`--null'
`-0'
     結果を，改行文字ではなく，ASCIIのヌル文字で分離します．このオプションの
     利便性を完全に利用するため，新しいデータベース書式を使用してください(デ
     フォルトです)．

`--print'
`-p'
     `--statistics' (`-S')や`--count' (`-c')のために，通
     常は出力されない検索結果を出力します．

`--wholename'
`-w'
     指定されたパターンはを，`locate'データベースのファイル名全体に
     対してマッチさせます．パターンにメタ文字が含まれている場合，正確にマッ
     チする必要があります．そうでない場合，ファイル名全体にマッチする必要が
     あります．これはデフォルトの動作です．

`--regex'
`-r'
     部分文字列やシェルのglobマッチを使用する代わりに，コマンドラインで指定
     されているパターンをPOSIXの拡張正規表現として解釈します．指定されている
     正規表現にマッチする`locate'データベースのファイル名が出力(また
     はカウント)されます．`-i'フラグも与えられている場合，大文字小文字
     を区別しません．マッチは，パス名全体に対して実行され，デフォルトではパ
     ス名は指定されている正規表現のマッチする部分にマッチします．正規表現で
     は`^'や`$'を，パス名の最初や最後にマッチするものとして使用し
     ても構いません．

`--stdio'
`-s'
     受け入れられますが何もしません．このオプションは，BSDの`locate'と
     の互換性を提供するためだけにサポートされています．

`--statistics'
`-S'
     それぞれの`locate'データベースの概要情報を出力しません．オプショ
     ン以外の引数が与えられていない限り，検索は実行されません．

`--help'
     `locate'へのオプションの概要を出力し，終了します．

`--version'
     `locate'のバージョンナンバーを出力し，終了します．


File: find-ja.info,  Node: Invoking updatedb,  Next: Invoking xargs,  Prev: Invoking locate,  Up: Reference

7.3 `updatedb'の呼び出し
========================

     updatedb [OPTION...]

`--findoptions='OPTION...''
     `find'渡す大域的なオプションです．環境変数`FINDOPTIONS'でもこ
     の値を設定します．デフォルトはありません．

`--localpaths='PATH...''
     データベースに書き込むネットワーク以外のディレクトリです．デフォルトは
     `/'です．

`--netpaths='PATH...''
     データベースに書き込むネットワーク(NFS，AFS，RFS等)のディレクトリです．
     環境変数`NETPATHS'でもこの値を設定します．デフォルトはありません．

`--prunepaths='PATH...''
     データベースに書き込まないディレクトリで，それ以外は書き込まれます．環
     境変数`PRUNEPATHS'でもこの値を設定します．デフォルトは， `/tmp
     /usr/tmp /var/tmp /afs'です．パスは正規表現として (`find ...
     -regex'のように)使用されるので，これらのパスを
     `find'で行うのと同じ方法で指定する必要があります．例えば，パスに最
     後のスラッシュを含めてはならないことを意味します．

`--prunefs='PATH...''
     データベースに書き込まないファイルシステムで，それ以外は書き込まれます．
     当該ファイルシステム以下のファイルが除去されることに注意してください．
     期待されないファイルシステム以下にあるファイルシステムはすべて無視され
     ます．環境変数`PRUNEFS'でもこの値を設定します．デフォルトは `nfs
     NFS proc'です．

`--output=DBFILE'
     構築されるデータベースファイルです．デフォルトはシステムに依存しますが，
     通常は`/usr/local/var/locatedb'です．

`--localuser=USER'
     `su'を使用して，ネットワーク以外のディレクトリを検索するユーザです．
     デフォルトは，カレントユーザとしてネットワーク以外のディレクトリを検索
     します．このユーザを設定するために，環境変数`LOCALUSER'を使用する
     ことも可能です．

`--netuser=USER'
     `su'を使用しながら，ネットワークディレクトリを検索するユーザです．
     デフォルトは`daemon'です．このユーザを設定するために，環境変数
     `NETUSER'を使用することも可能です．

`--old-format'
     GNU `locate'より古いバージョンの`locate'との互換性のため，
     `locate'データベースを古い書式で出力します．このオプションを使
     用することは，ファイル名でASCII以外の文字を適切に処理することができなく
     なる事を意味します(それは，ISO-8859-1文字集合の多くの文字のように，八番
     目のビットが設定されている文字を含むファイル名です)．

`--help'
     コマンドライン引数の書式の概要を出力して終了します．

`--version'
     `updatedb'のバージョン番号を出力して終了します．


File: find-ja.info,  Node: Invoking xargs,  Prev: Invoking updatedb,  Up: Reference

7.4 `xargs'の呼び出し
=====================

     xargs [OPTION...] [COMMAND [INITIAL-ARGUMENTS]]

   `xargs'は，以下のステータスで終了します．

0
     成功した場合．

123
     1-125のステータスで終了されたコマンドの呼出があった場合．

124
     コマンドが255のステータスで終了した場合．

125
     コマンドがシグナルでキルされた場合．

126
     コマンドが実行不可能な場合．

127
     コマンドが見つからない場合．

1
     その他のエラーが発生した場合．

`--arg-file=INPUTFILE'
`-a =INPUTFILE'
     標準入力の代わりに，ファイルINPUTFILEから名前を読み込みます．

`--null'
`-0'
     入力ファイル名を空白の代わりにヌル文字で終端し，引用符とバックスラッシュ
     は特別扱いされません(すべての文字は，文字通りに扱われます)．引数として
     扱われるような，ファイル文字列の終端部分を使用不可能にします．

`--eof[=EOF-STR]'
`-e[EOF-STR]'
     ファイル文字列の終端をEOF-STRに設定します．ファイル文字列の終端が，
     入力行に現れた場合，残りの入力は無視されます．EOF-STRが省略されて
     いる場合，ファイル文字列の終端はありません．このオプションが与えられて
     いない場合，ファイル文字列の終端はデフォルトで`_'になります．

`--help'
     `xargs'のオプションの概要を出力して，終了します．

`--replace[=REPLACE-STR]'
`-i[REPLACE-STR]'
     最初から存在する引数にあるREPLACE-STRを，標準入力から読み込まれた
     名前に置換します．また，引用符で囲まれていない空白は，引数の終りになり
     ません．代わりに，入力は改行のみで分割されます．REPLACE-STRが省略
     されている場合，デフォルトは`{}' になります(`find -exec'に
     似ています)．`-x'と`-l 1'を暗黙に指定します．

`--max-lines[=MAX-LINES]'
`-l[MAX-LINES]'
     最大MAX-LINESの空白でない入力行を，コマンドラインごとに使用します．
     後置されている空白は，入力行を論理的に次の行に続かせ，それは行を数える
     目的のためです．`-x'を暗黙に指定します．

`--max-args=MAX-ARGS'
`-n MAX-ARGS'
     最大MAX-ARGSの引数を，コマンドラインごとに使用します．
     MAX-ARGSより引数が少ないときは，サイズ(`-s'オプションを参照
     して下さい)を越ていても，`-x'オプションが与えられていない場合はそ
     れが使用され，それ以外では`xargs'は終了します．

`--interactive'
`-p'
     それぞれのコマンドラインを実行するかどうか，ユーザにプロンプトを表示し，
     端末から一行読み込みます．応答が`y'や`Y'で始まっている場合の
     み，コマンドラインを実行します．`-t'を暗黙に指定します．

`--no-run-if-empty'
`-r'
     標準入力が全く空行を含まない場合，コマンドを実行しません．デフォルトで，
     コマンドは入力が無い場合でも一度実行されます．

`--max-chars=MAX-CHARS'
`-s MAX-CHARS'
     コマンドと最初からある引数と引数文字列の最後の終端のヌルを含め，最大
     MAX-CHARS文字をコマンドラインごとに使用します．

`--verbose'
`-t'
     コマンドラインを実行前に標準エラー出力に出力します．

`--version'
     `xargs'のバージョンナンバーを出力し，終了します．

`--exit'
`-x'
     サイズ(`-s'オプションを参照して下さい)を越えた場合，終了します．

`--max-procs=MAX-PROCS'
`-P MAX-PROCS'
     一度にMAX-PROCSプロセスまで実行します．デフォルトは1です．
     MAX-PROCSが0の場合，`xargs'は一度に実行可能な最大数のプロセ
     スを実行します．


File: find-ja.info,  Node: Security Considerations,  Next: Error Messages,  Prev: Reference,  Up: Top

8 セキュリティの考慮
********************

`find'や`xargs'を，所有者ではない，または他の人の制御下にある
ファイルの検索や処理で使用している場合，セキュリティを考慮することは重
要です．`locate'でも，他人に見られたくないファイルがある場合，関係
するセキュリティの考慮が適用されます．

   一般的に，`find'と関連プログラムに影響する最も厳しいセキュリティの
問題の形態は，第三者がそれらのプログラムによって，通常は実行できない何
かを実行することが可能になる状況になりうることです．これは，_特権
の昇格(privilege elevation)_と呼ばれています．これは，通常は削除不可能
なファイルの削除も含まれます．システムが定期的に，ごみ掃除の目的で
`find'を呼び出すのも一般的です．このような`find'の呼び出しは，
スーパーユーザから呼び出され，ファイルシステムの全階層を検索するので，
セキュリティの観点からは特に問題になります．関連する問題の重大さは，
`find'の出力を元にシステムが実施することに依存します．

* Menu:

* Levels of Risk::      What is your level of exposure to security problems?
* Security Considerations for find::  Security problems with find
* Security Considerations for xargs:: Security problems with xargs
* Security Considerations for locate:: Security problems with locate
* Security Summary:: That was all very complex, what does it boil down to?


File: find-ja.info,  Node: Levels of Risk,  Next: Security Considerations for find,  Up: Security Considerations

8.1 リスクのレベル
==================

`find'，`xargs'，そして(程度は小さい)`locate'の使用にお
いて，もともとセキュリティのリスクがあります．リスクの重大さは，使用し
ているシステムの種類に依存します．

*高いリスク*
     他のユーザを制御(または信用)できない，他のユーザが操作可能なファイルシ
     ステムの領域(例えば，`/home'や`/tmp'以下)を含めて`find'
     を実行するマルチユーザシステム．

*中程度のリスク*
     他のユーザのアクションで任意のファイル名を作成することが可能で，
     `find'の実行中アクセスできないシステム．このアクセスには，放置され
     たプログラムの実行(例えば，バックグラウンドのジョブ，`at'や
     `cron'のタスク)が含まれます．この種のシステムでは，注意して書かれ
     たコマンド(例えば，`-print'の使用を避ける)は，高度な危険にならない
     でしょう．ほとんどのシステムはこのカテゴリに分類されます．

*低いリスク*
     信用できない連中がアクセスしない，自分で選んだファイル名を(リモートで
     も)作成できない，信用できない第三者のアクセスを増加させるようなセキュリ
     ティの欠陥が無いシステム．ほとんどのシステムでは，外部の人がシステムに
     作成するファイルの名前に影響する方法がたくさんあるので，このカテゴリに
     分類されません．例えば，これを書いているシステム自動的にソフトウェアを
     インターネットからダウンロードし，ソフトウェアを更新します．これらの更
     新されるファイルには名前は，第三者が選択したものが存在しています
     (1)．

   上記の"リスク"とは，`find'，`xargs'，`locate'，または，
それらのプログラムから制御される，他のプログラムで，期待しないことが実
行され得ることを意味します．提案したリスクのレベルは，事態の重大さを考
慮したものではありません．つまり，"低リスク"のシステムで処理をしてい
ても，セキュリティの問題の重大さは悲惨なものとなり，ここで議論されてい
ないものもたくさんありますが，すべての可能性のあるセキュリティの問題を
真面目に考えるべきです - マニュアルのこのセクションの目的は情報提供で
すが，総合的でも徹底的でもありません．

セキュリティの問題が非常に重要なシステムでの操作に責任がある場合，二つ
のことを行うべきです．

  1.
     システム上で，誰が何を行っても良いかということを決定する，セキュリティ
     ポリシーを定義してください．

  2.
     ポリシーの執行，ポリシーの侵害の検出，さらに，ポリシーのスコープ以外に
     ついても可能性のある問題の考慮について，手法に関するアドバイスを十分に
     探してください．

   ---------- Footnotes ----------

   (1) もちろん，インストールするソフトウェアを提供しているので，こ
れらの連中を信用しています．こうして信用するものを選択するしていて，ま
あ良く考えて選択しているということです


File: find-ja.info,  Node: Security Considerations for find,  Next: Security Considerations for xargs,  Prev: Levels of Risk,  Up: Security Considerations

8.2 `find'のセキュリティの考慮
==============================

`find'のアクションには，直接影響するものがあります．これには
`-exec'と`-delete'が含まれます．しかし，`-print'の明示的
または暗黙の使用も一般的で，`find'は間違ったファイル名のリストを生
成し，セキュリティの問題になり得ます．例えば，ファイルを削除するために
`find'が生成したファイルのリストを考えてみてください．

   我々は通常，`find'のコマンドラインはファイルの選択の基準と，ユーザ
が考えているアクションを表現していると仮定します - つまり，コマンドラ
インは"信用できる"データだということです．

   セキュリティの分析の観点から，`find'の外部は正しくありません．つま
り，出力にはユーザがコマンドラインで指定した基準にマッチしたファイルの
名前だけが含まれているべきです．これを，`-exec'と`-delete'ア
クションに適用します．これらも出力の一部だと考える人もいます．

   一方，ファイルシステムの内容は他の人も操作可能なので，我々はこれを"信
用できない"データだとみなします．つまり，`find'コマンドラインは，
信用できないファイルシステムの内容を，出力ファイルの正しいリストに変換
するフィルタであることを暗示しています．

   ファイルシステムは，一般的に，`find'の検索中に変更されます．実際に，
`find'がセキュリティの問題となる可能性のほとんどは，この問題にある
程度関連します．

   競合状態は，(例えば) `find'に渡されるアクションの順番に関連するセ
キュリティの問題に分類され，それ以外が重要です(1)．

一般的に，普通は影響するはずがないファイルに対して，攻撃者が期待するア
クションでファイルやディレクトリの移動や削除を行います．また，このよう
なの攻撃は，`find'に，普通は検索されない(例えば，`-prune'アク
ションで抑止)ファイルシステムの一部を検索するようにしむけます．

* Menu:

* Changing the Current Working Directory::
* Race Conditions with -exec::
* Race Conditions with -print and -print0::

   ---------- Footnotes ----------

   (1) これは，用語 "競合状態(race condition)"のだいたいの定義になります


File: find-ja.info,  Node: Changing the Current Working Directory,  Next: Race Conditions with -exec,  Up: Security Considerations for find

8.2.1 現在の作業ディレクトリの変更
----------------------------------

`find'がファイルシステムを検索するとき，サブディレクトリを探し，
作業ディレクトリを変更しながら検索します．最初に，`find'はサブディ
レクトリに注目します．サブディレクトリが検索する基準にあっている場合，
それが決定されます．つまり，`-xdev'や`-prune'式は考慮されます．
`find'プログラムは，作業ディレクトリを変更し，ディレクトリの検索を
進めていきます．

   競合状態の攻撃とは，`-xdev'と`-prune'に関連して一度調査された
後，攻撃者は考えられるディレクトリの名前を変更し，その場所を別の場所を
示しているシンボリックリンクを配置するといった形態になります．

   この攻撃のは以後にある考えとは，`find'が間違ったディレクトリに行っ
てしまう程度に愚かであるということです．これは，攻撃者が選択した作業ディ
レクトリで`find'を続け，`-xdev'と`-prune'で明示的に提供
された保護機能と，`find'コマンドラインにリストアップされた特定のディ
レクトリ_以外を_利用できなくすることで提供される保護機能をバイパス
するということです．この形態の攻撃は，攻撃者が`find'コマンドを実行
するときが予測可能な場合，例えば`cron'のタスク等で，特に問題になり
ます．

   GNU `find'には，この一般に分類される問題を避けるための，固有のセー
フガードがあります．これらのセーフガードの正確な形態は，システムの特性
に依存します．

* Menu:

* O_NOFOLLOW::                     Safely changing directory using fchdir().
* Systems without O_NOFOLLOW::     Checking for symbolic links after chdir().
* Working with automounters::      These can look like race condition exploits
* Problems with dead NFS servers:: If you don't have O_NOFOLLOW, this is a problem.


File: find-ja.info,  Node: O_NOFOLLOW,  Next: Systems without O_NOFOLLOW,  Up: Changing the Current Working Directory

8.2.1.1 O_NOFOLLOW
..................

システムが`open(2)'システムコールのO_NOFOLLOWフラグをサポートする
場合(1)，`find'は安全にディレク
トリを変更するとき使用します．目的となるディレクトリは最初にオープンさ
れ，`find'は`fchdir()'システムコールで作業ディレクトリを変更
します．これで，シンボリックリンクは確実にたどられなくなり，シンボリッ
クリンクの作成を使用する競合状態の攻撃の類は避けられます．

   なんらかの理由でこの手法が動作しない場合，`find'はO_NOFOLLOWがサポー
トされていない状況で一般的に使用される手法に戻ります．

以下を実行することで，システムがO_NOFOLLOWをサポートしてかどうか分かり
ます．

     find --version

これで，バージョン番号と利用可能な機能が表示されます．例えば，私のシス
テムでは以下のようになります．
     GNU find version 4.2.18-CVS
     Features enabled: D_TYPE O_NOFOLLOW(enabled)

   ここで，実行している`find'のバージョンがfindutils-4.2.18の前の
リリースの開発(CVS)コードからビルドされたことと，D_TYPEとO_NOFOLLOWの機
能が存在することが分かります．O_NOFOLLOWは"enabled"であると分かります．
これは，現在のシステムでO_NOFOLLOWをサポートしているらしいことを，簡単
に示しています．システムでビルドされた`find'がO_NOFOLLOWを定義
していて，O_NOFOLLOWフラグを無視するシステムで実行されている可能性があ
るので，この調査は必要です．我々は，開始時にオペレーティングシステムと
バージョン番号を調査することで，そのような状況の検出を試みます．このよ
うな状況では，"O_NOFOLLOW(disabled)"を代わりに見ることになります．

   ---------- Footnotes ----------

   (1) GNU/Linux (kernel version 2.1.126 以降)そしてFreeBSD
(3.0-CURRENT 以降)はこれをサポートします


File: find-ja.info,  Node: Systems without O_NOFOLLOW,  Next: Working with automounters,  Prev: O_NOFOLLOW,  Up: Changing the Current Working Directory

8.2.1.2 O_NOFOLLOWが無いシステム
................................

O_NOFOLLOWフラグのサポートがが無いシステムで，この形式の問題を避ける戦
略はより複雑です．`find'がディレクトリを変更するたびに，移動先のディ
レクトリを調査し，`chdir()'システムコールを発行し，期待されている
サブディレクトリまで調査します．それ以外の場合，エラーメッセージを出力
し，`find'はただちに終了します．この手法は，`find'に意図しな
いファイルシステムの部分を検索させる，ファイルシステム操作の攻撃を妨げ
ます．しかし，"automount"のマウントポイントで問題となる無駄な断定を行
わないよう，特殊なステップが必要になります．


File: find-ja.info,  Node: Working with automounters,  Next: Problems with dead NFS servers,  Prev: Systems without O_NOFOLLOW,  Up: Changing the Current Working Directory

8.2.1.3 オートマウントでの作業
..............................

オートマウントを使用中は，`chdir()'システムコールの使用で，マウン
トポイントにマウントされた新しいファイルシステムに移動することが可能に
なる状況です．O_NOFOLLOWをサポートしていないシステムでは，`find'の
セキュリティ調査に失敗します．

しかし，通常はセキュリティの問題にはなりません(通常はシステム管理者がオー
トマウントの構成を設定しているためです)．そのため，`chdir()'の正統
性の調査が失敗する場合，`find'は新しいファイルシステムが現在のディ
レクトリにマウントされているかどうかを調査します．その場合，
`find'は警告メッセージを出力し，動作を続けます．

   この解決法を動作させるため，`find'はマウントされているファイルシス
テムのリストを，開始時と，正統性の調査に失敗したときに読み込みます．マ
ウントされたときからディレクトリが移動されているかどうかを調べるため，
二つのリストを比較します．


File: find-ja.info,  Node: Problems with dead NFS servers,  Prev: Working with automounters,  Up: Changing the Current Working Directory

8.2.1.4 NFSサーバが落ちている問題
.................................

システムのマウントポイントごとに調査することは，非常に悪い方向です．一
般的に，`find'は，ファイルシステムの一部だけを検索します．しかし，
`find'はすべてのマウントポイントを調査します．システムに，信用でき
ないNFSサーバをマウントしたファイルシステムがある場合，`find'はハ
ングアップし，NFSサーバが応答するまで待ち続けます．更に悪いことに，マウ
ントポイントが，`find'が検索しないディレクトリツリーにあっても影響
します．

これは非常に不幸です．しかし，この問題は，O_NOFOLLOWをサポートしていな
いシステムだけに影響します．私が知る限り，そのようなシステムで，これら
三つのすべての問題を(競合状態，オートマウントの間違った警告，NFSサーバ
がダウンしていた場合のハングアップ)一度に修正することは不可能です．
`find'で可能なより良いアイデアがあれば，メーリングリスト
<bug-findutils@gnu.org>に電子メールを送って下さい．


File: find-ja.info,  Node: Race Conditions with -exec,  Next: Race Conditions with -print and -print0,  Prev: Changing the Current Working Directory,  Up: Security Considerations for find

8.2.2 -execでの競合状態
-----------------------

`-exec'アクションでは別のプログラムを実行します．その時にファイル
名を渡します．そしてプログラムを呼び出します -通常- ファイルになんらか
のアクションを実施します．ここでも，利用可能な競合状態があります．我々
は，コマンド例を以下のように指定します．

     find /tmp -path /tmp/umsp/passwd -exec /bin/rm

   この見本例では，我々は削除する一つのファイルを識別し，削除するために
`/bin/rm'を呼び出しています．`find'が`-exec'アクションを
処理する必要があることを決定する時点と，`/bin/rm'コマンドが実際に
`unlink()'システムコールを実施する時点に時間差があるので，問題が存
在します．このとき，攻撃者は`/tmp/umsp'ディレクトリの名前を変更し，
`/etc'へのシンボリックリンクに置換することが可能です．`find'
が想定しているのと同じファイルで，`/bin/rm'を実施していることを調
査する方法はありません．一度シンボリックリンクが配置されると，実際に呼
び出したコマンドが意図している効果ではなく，攻撃者は`find'に
`/etc/passwd'ファイルを削除させるようだますこともあります．

   この形態の攻撃から守る一つの可能性として，`-exec'の動作を
`/bin/rm'コマンドを`./passwd'引数で，適切なワーキングディレク
トリで実行するようにする方法です．これは，この形式の攻撃から守るために
`find'が実行する，通常の健全性の調査でも可能です．残念ながら，この
戦略はPOSIX標準で指定されている物では利用不可能で，そこでは
`-exec'でコマンドが呼び出されたカレントワーキングディレクトリと，
`find'が呼び出されたカレントワーキングディレクトリは同じにする必要
があります．つまり，`-exec'アクションは本質的にセキュリティが低く，
修正不可能だということを意味します．

   GNU `find'では，`-exec'アクション等よりセキュリティが高い
`-execdir'を実装しています．`-execdir'アクションは，ターゲッ
トファイルを処理するため，サブディレクトリを参照しないようにする必要が
なくなるようにします．プログラムの呼び出しで使用されるカレントディレク
トリが，処理するファイルが存在するディレクトリと同じ(例では
`/tmp/umsp')になっていて，処理するファイルのベース名が呼び出しコマ
ンドに渡され，それには`./'が(例では`./passwd')前置されます．

   `-execdir'アクションは，カレントディレクトリが$PATH環境変数
に含まれている場合，すべての動作を拒否します．これは，`-execdir'が
ファイルが見つかったディレクトリと同じディレクトリのプログラムを実行す
るので必要になります - 一般的に，そのようなディレクトリは信用できない
ユーザは書き込みません．同じような理由で，`-execdir'は実行するコマ
ンド名の`{}'を許可しません．


File: find-ja.info,  Node: Race Conditions with -print and -print0,  Prev: Race Conditions with -exec,  Up: Security Considerations for find

8.2.3 -printと-print0の競合状態
-------------------------------

`-print'と`-print0'アクションは，幾つかの条件にマッチしたファ
イルリストを生成するために利用することが可能で，そのリストは他のコマン
ド，おそらく`xargs'で使用することが可能です．残念ながら，これには，
`find'が条件に合致した一つ以上のファイルを見つけたときと，関連する
コマンドが実行されるときの，やむおえない時間差が存在することを意味しま
す．このため，`-print'と`-print0'のアクションは，
`-exec'同様にセキュリティが高くありません．

   実際に，以下を考えてみます．

     find ....   -print | xargs ....

   これは，改行やその他の"空白"がファイル名にある場合，正しく対処できま
せんし，引用符を含むファイル名への対応もいまいちですし，`-print'ア
クションは，`-print0'ほどセキュリティが高くありません．


File: find-ja.info,  Node: Security Considerations for xargs,  Next: Security Considerations for locate,  Prev: Security Considerations for find,  Up: Security Considerations

8.3 `xargs'のセキュリティの検討
===============================

`find'の`-print'による競合状態の影響の記述は，`find'の開
始後かつ`xargs'がすべてのアクションを完了する前に攻撃者がファイル
システムを変更する可能性がある場合，`xargs'でセキュリティを高くす
ることが不可能なことを示しています．

しかし，攻撃者がリアルタイムでファイルシステムにアクセスできない場合で
さえも，セキュリティの問題が他にも存在しています．第一に，攻撃者がファ
イルシステム上に，自分が選んだ名前でファイルを作成可能な場合，
`xargs'は`-0'オプションを使用しない限りセキュリティが低くなり
ます．`/home/someuser/foo/bar\n/etc/passwd'というファイル名が存在
する場合(`\n'が改行文字を意味すると仮定します)，`find ...
-print'では，間違って三行に分割した行を出力するはずです．

     /home/someuser/foo/bar

     /etc/passwd

   入力に改行がある場合，`xargs'はそれを無視します．このため，このファ
イルリストを元に実施されるアクションには，これが`find'を実行し
ている人が期待していない`/etc/passwd'ファイルが含まれます．攻撃者
がこの優位性を使用可能な状況も存在します．同じ状況は，ファイル名に改行
ではなく普通の空行が存在する場合も存在し，もちろん，ファイル名のリスト
には"余分な"改行は含まれていません．

   この問題は，`xargs'コマンドのデフォルトの動作，つまりPOSIX標準で指
定された動作の結果から回避することができません．この問題を避ける方法は，
`xargs'の使用を避け，より好ましい`find -exec'や(利用可能であ れば)`find
-execdir'を使用したり，`xargs'にファイル名が空白で
はなくASCIIのNUL文字で分離していると理解させる`-0'オプションを使用
することだけです．しかし，このオプションは役に立ちますが，POSIXの標準で
は必須とされていません．


File: find-ja.info,  Node: Security Considerations for locate,  Next: Security Summary,  Prev: Security Considerations for xargs,  Up: Security Considerations

8.4 `locate'のセキュリティの検討
================================

`locate'の出力を他のコマンドに渡すことは滅多にありません．しかし，
そうする場合は`find ... -print'の使用と同じようなセキュリティの問
題が生じるでしょう．しかし，ファイル名の空白に依存する問題は，
`locate'の`-0'オプションで解決することが可能ですが，これでも `find ...
-print0'に関連する競合状態の問題は残ります．
`locate'では，これらの問題を避ける方法がありません．


File: find-ja.info,  Node: Security Summary,  Prev: Security Considerations for locate,  Up: Security Considerations

8.5 概要
========

信用できない第三者が，システム上にファイルを作成できたり，作成したファ
イル名に化如することができる場合，`find'，`locate'，そして
`xargs'の使用時には，以下以外のセキュリティの問題を知っておいてく
ださい．

Informational use only
     プログラムが前もって準備されているファイル名のリストを使用し，それ以上
     のアクションを実施しないように使用する．

-delete
     指定した条件に合致したファイルを削除する`-delete'アクションを使用
     する．

-execdir
     `PATH'環境変数が，信用されたプログラムだけが含まれているディレクト
     リとなっている状況で，`-execdir'アクションを使用する．


File: find-ja.info,  Node: Error Messages,  Next: Primary Index,  Prev: Security Considerations,  Up: Top

9 エラーメッセージ
******************

このセクションでは，`find'，`xargs'，または`locate'から
得られるエラーメッセージの説明，為すべきことへのアドバイスを記述します．

   このマニュアルは英語で書かれています．GNU
findutilsソフトウェアはエラー
メッセージを多くの言語に翻訳されています．このためできるだけ我々は，プ
ログラムに自明のことでエラーメッセージを生成させようと思います．この手
法は，英語のエラーメッセージに対応する別のものを実際には見ることになる
人々に，理解してもらうようお願いすることが難しくなります．通常，自明の
エラーメッセージは記述しませんし，このドキュメントでも議論しません．こ
のドキュメントで議論しているメッセージとして，英後のバージョンのメッセー
ジだけリストアップしています．

* Menu:

* Error Messages From find::
* Error Messages From xargs::
* Error Messages From locate::
* Error Messages From updatedb::


File: find-ja.info,  Node: Error Messages From find,  Next: Error Messages From xargs,  Up: Error Messages

9.1 findのエラーメッセージ
==========================

`invalid predicate `-foo''
     これは，`find'のコマンドラインにダッシュやその他の特殊文字で開始さ
     れるものが含まれていることを意味します．`find'プログラムはこれを，
     テスト，アクション，またはオプションとして解釈しようとしますが，認識は
     しません．テストを試みる場合，指定しているものについてドキュメントを調
     査して下さい．一方，文字列がワイルドカードを展開したファイル名の場合(例
     えば，コマンドラインに`*'がある場合)，`./*'や`.'を代わり
     に使用していると考慮します．

`unexpected extra predicate'
     コマンドラインに余分な括弧がある場合(例えば，`find . -print \)')，
     通常はこうなります．

`Warning: filesystem /path/foo has recently been mounted'
`Warning: filesystem /path/foo has recently been unmounted'
     これらのメッセージは，`find'がディレクトリに移動し，デバイス番号と
     inodeが期待したものと異なるものが見つかったときに出力されます．
     `find'が移動したディレクトリがNFSファイルシステムの場合，
     `automount'は新しいファイルシステムを移動先のディレクトリにマウン
     トすることが多いので(つまり，使用したいファイルシステムを知る方法です)，
     このメッセージは出力されません．そのため，このメッセージが出力される場
     合は油断しないでください - `automount'が信用できない可能性があり
     ます．他の誰かが`find'の実行中にファイルシステムを捜査している可能
     性を検討してください．`find'を迷わせたり，別のファイル集合を探して
     いるときに，それもファイルの集合だとみせかけたい人もいます．

`/path/foo changed during execution of find (old device number 12345, new device number 6789, filesystem type is <whatever>) [ref XXX]'
     このメッセージは，`find'がディレクトリを変更し，期待しない場所に移
     動したときに出力されます．これは二つの状況のいずれかになります．最初の
     ものは，"オートマウント"で，`find'がマウントされているファイルシ
     ステムの現在の場所を決定する方法を知らないときに生じます．

     二番目は，`find'がファイルシステムの階層を降りるのではなく上がって
     行くときに，ディレクトリのデバイス番号がカレントディレクトリの変更中に
     変わるとき生じます．`find'がファイルシステムの期待しない部分に迷い
     込まないように，我々はこの時点で停止します．

`Don't know how to use getmntent() to read `/etc/mtab'.  This is a bug.'
     このメッセージは，`find'が現在のマウントポイントのリストを知る方法
     が分からないシステムで上記と同じように出力されます．
     <bug-findutils@gnu.org>でたずねてください．

`/path/foo/bar changed during execution of find (old inode number 12345, new inode number 67893, filesystem type is <whatever>) [ref XXX]"),'
     このメッセージは，`find'がディレクトリを変更したとき，ディレクトリ
     のinode番号が以前取得したinode番号と異なる場合に出力されます．これは通
     常，`find'がディレクトリ階層の深いところに長時間いて，他の人が親ディ
     レクトリを同じファイルシステムの別の場所に移動したことを意味します．こ
     れは，悪意があったり無かったりします．この状況では，思いがけないファイ
     ルシステムの矛盾を避けるため，その時点で`find'は停止します．生じた
     ことを理解するため，`ls -li'や`find /path -inum 12345 -o -inum
     67893'を実行することが可能です．

`sanity check of the fnmatch() library function failed.'
     バグの報告をしてください．`findutils'のコードを自分でコンパイルし
     た場合，ビルドツリーのコピーを保持したまま，システムの問題を質問しても
     かまいません．同様の解釈として，GNUバージョンの`configure'に問題が
     あるように思われますが，システムの`fnmatch'にバグがあるということ
     で，恐らく正しく動かないでしょう．

`cannot fork'
     `-exec'アクションや，似たようなもの(`-ok'など)を使用していて，
     システムがフリーのプロセススロットを使いきった場合に，通常これが発生し
     ます．また，システムが非常にビジーでシステムの最大プロセスの制限に到達
     したり，リソースの制限に到達したことも考えられます．暴走したプロセスを
     システムで調査してください(`ps'が動作すればですが)．プロセススロッ
     トには，`root'の利用に予約されているものもあります．

`some-program terminated by signal 99'
     `-exec'やそれに似たもので起動されたプログラムは，異常終了のシグナ
     ルでキルされるものもあります．これは，それを報告するだけのメッセージで
     す．


File: find-ja.info,  Node: Error Messages From xargs,  Next: Error Messages From locate,  Prev: Error Messages From find,  Up: Error Messages

9.2 xargsのエラーメッセージ
===========================

`environment is too large for exec'
     このメッセージは環境変数が設定されすぎて(または，大きな値になっていて)
     プログラムを呼び出すプログラムのコマンドラインの引数の長さに関するシス
     テムの制限によって，余裕が無いことを意味します．これを意識的に行ってい
     るかどうかを確かめたいと思います．環境変数を未設定状態にしたり，現在の
     シェルを終了したりしてみてください．

`can not fit single argument within argument list size limit'
     `-i'オプションを使用していて，`xargs'のコマンドラインが非常に
     大きな項目があり，適切に実施できないほどになっていて，コマンドラインを
     作成する空間が十分に無いことを意味します．この問題は`-s'オプション
     で回避できると思いますが，デフォルトのサイズは非常に大きいものです．
     `xargs'を壊すぐらいに大きいものを試していることでしょう．

`cannot fork'
     `find'の同様のメッセージの記述を参照してください．

`<program>: exited with status 255; aborting'
     `xargs'が実行するコマンドが255のステータスで終了したとき，
     `xargs'は停止することになっています．こうすることを期待しない場合，
     プログラムをシェルスクリプトから呼び出して，255のステータスを返さないよ
     うなラッパーにしてください．

`<program>: terminated by signal 99'
     `find'の同様のメッセージの記述を参照してください．


File: find-ja.info,  Node: Error Messages From locate,  Next: Error Messages From updatedb,  Prev: Error Messages From xargs,  Up: Error Messages

9.3 locateのエラーメッセージ
============================

`warning: database `/usr/local/var/locatedb' is more than 8 days old'
     `locate'プログラムは，`updatedb'によって前もって構築されたデー
     タベースに依存します．しばらく実行しないとそうなります．この問題を修正
     するために，`updatedb'を手動で実行してください．これは，システムか
     らしばらく離れていたときに発生することが多く，それは，定期的な"cron"
     タスクが実行されないためです．

`locate database `/usr/local/var/locatedb' is corrupt or invalid'
     これは発生すべきではありません．`updatedb'を再実行してください．動
     作するが，`locate'がまだこのエラーを生成する場合，`locate
     --version'と`updatedb --version'を実行してください．これらは同じ出
     力を生成すべきです．そうでない場合，道具をまぜて使用しています．
     `$PATH'環境変数と，シェルのaliase(もしあれば)を調べてください．両
     方のプログラムがGNUバージョンであれば，これはバグです．これらのプログラ
     ムのすべてのバージョンは，問題なければ相互互換性があるべきです．
     <bug-findutils@gnu.org>でたずねてみてください．


File: find-ja.info,  Node: Error Messages From updatedb,  Prev: Error Messages From locate,  Up: Error Messages

9.4 updatedbのエラーメッセージ
==============================

`updatedb'プログラム(と，それが呼び出すプログラム)はエラーメッセー
ジを出力しますが，ガイダンスを要求する人がいそうにありません問題があっ
て．これらを理解したい場合，<bug-findutils@gnu.org>でたずねてみ
てください．


File: find-ja.info,  Node: Primary Index,  Prev: Error Messages,  Up: Top

`find'のプライマリの索引
************************

これは，ファイルを検索するために`find'の式を作り上げる，(テスト，
アクション，そしてオプション) すべてのプライマリのリストです．式の詳細
は，*Note find Expressions::.

 [index ]
* Menu:

* !:                                     Combining Primaries With Operators.
                                                               (line 14)
* ():                                    Combining Primaries With Operators.
                                                               (line 10)
* ,:                                     Combining Primaries With Operators.
                                                               (line 26)
* -a:                                    Combining Primaries With Operators.
                                                               (line 19)
* -amin:                                 Age Ranges.           (line 17)
* -and:                                  Combining Primaries With Operators.
                                                               (line 19)
* -anewer:                               Comparing Timestamps. (line 18)
* -atime:                                Age Ranges.           (line  9)
* -cmin:                                 Age Ranges.           (line 18)
* -cnewer:                               Comparing Timestamps. (line 19)
* -ctime:                                Age Ranges.           (line 10)
* -d:                                    Directories.          (line 28)
* -daystart:                             Age Ranges.           (line 28)
* -delete:                               Delete Files.         (line  7)
* -depth:                                Directories.          (line 21)
* -empty:                                Size.                 (line 46)
* -exec <1>:                             Multiple Files.       (line 23)
* -exec:                                 Single File.          (line 27)
* -execdir <1>:                          Multiple Files.       (line 15)
* -execdir:                              Single File.          (line  9)
* -false:                                Combining Primaries With Operators.
                                                               (line 45)
* -fls:                                  Print File Information.
                                                               (line 51)
* -fprint:                               Print File Name.      (line 10)
* -fprint0:                              Safe File Name Handling.
                                                               (line 16)
* -fprintf:                              Print File Information.
                                                               (line 65)
* -fstype:                               Filesystems.          (line 24)
* -gid:                                  Owner.                (line 13)
* -group:                                Owner.                (line  8)
* -ignore_readdir_race:                  Directories.          (line 80)
* -ilname:                               Symbolic Links.       (line 78)
* -iname:                                Base Name Patterns.   (line  8)
* -inum:                                 Hard Links.           (line 41)
* -ipath:                                Full Name Patterns.   (line 19)
* -iregex:                               Full Name Patterns.   (line 25)
* -iwholename:                           Full Name Patterns.   (line  8)
* -links:                                Hard Links.           (line 55)
* -lname:                                Symbolic Links.       (line 77)
* -ls:                                   Print File Information.
                                                               (line  7)
* -maxdepth:                             Directories.          (line 11)
* -mindepth:                             Directories.          (line 16)
* -mmin:                                 Age Ranges.           (line 19)
* -mount:                                Filesystems.          (line 16)
* -mtime:                                Age Ranges.           (line 11)
* -name:                                 Base Name Patterns.   (line  7)
* -newer:                                Comparing Timestamps. (line 20)
* -nogroup:                              Owner.                (line 19)
* -noignore_readdir_race:                Directories.          (line 92)
* -noleaf:                               Directories.          (line 64)
* -not:                                  Combining Primaries With Operators.
                                                               (line 14)
* -nouser:                               Owner.                (line 18)
* -o:                                    Combining Primaries With Operators.
                                                               (line 23)
* -ok:                                   Querying.             (line 16)
* -okdir:                                Querying.             (line 11)
* -or:                                   Combining Primaries With Operators.
                                                               (line 23)
* -path:                                 Full Name Patterns.   (line 18)
* -perm:                                 Permissions.          (line 10)
* -print:                                Print File Name.      (line  7)
* -print0:                               Safe File Name Handling.
                                                               (line 13)
* -printf:                               Print File Information.
                                                               (line 55)
* -prune:                                Directories.          (line 33)
* -quit:                                 Directories.          (line 58)
* -regex:                                Full Name Patterns.   (line 24)
* -samefile:                             Hard Links.           (line 36)
* -size:                                 Size.                 (line  7)
* -true:                                 Combining Primaries With Operators.
                                                               (line 42)
* -type:                                 Type.                 (line  7)
* -uid:                                  Owner.                (line 12)
* -used:                                 Comparing Timestamps. (line 28)
* -user:                                 Owner.                (line  7)
* -wholename:                            Full Name Patterns.   (line  7)
* -xdev:                                 Filesystems.          (line 15)
* -xtype:                                Type.                 (line 34)



Tag Table:
Node: Top1545
Node: Introduction2523
Node: Scope3718
Node: Overview5726
Node: find Expressions7593
Node: Finding Files9002
Node: Name9446
Node: Base Name Patterns10071
Node: Full Name Patterns10945
Node: Fast Full Name Search12378
Node: Shell Pattern Matching14658
Node: Links16607
Node: Symbolic Links17091
Node: Hard Links21006
Node: Time23454
Node: Age Ranges24025
Node: Comparing Timestamps25361
Node: Size26565
Node: Type28274
Node: Owner29236
Node: Permissions30086
Node: Contents32333
Node: Directories33450
Node: Filesystems37931
Node: Combining Primaries With Operators39433
Node: Actions40898
Node: Print File Name41422
Node: Print File Information41979
Node: Escapes44752
Node: Format Directives45429
Node: Name Directives46483
Node: Ownership Directives47334
Node: Size Directives47846
Node: Location Directives48615
Node: Time Directives49718
Node: Time Formats50614
Node: Time Components51035
Node: Date Components51524
Node: Combined Time Formats52218
Node: Formatting Flags52885
Node: Run Commands53481
Node: Single File53851
Node: Multiple Files55262
Node: Unsafe File Name Handling58796
Node: Safe File Name Handling60341
Node: Unusual Characters in File Names61841
Node: Limiting Command Size64588
Node: Interspersing File Names66593
Node: Querying67738
Node: Delete Files69024
Node: Adding Tests69443
Node: Common Tasks72102
Node: Viewing And Editing72508
Node: Archiving73481
Node: Cleaning Up75216
Node: Strange File Names77070
Node: Fixing Permissions78769
Node: Classifying Files79255
Node: Databases79956
Node: Database Locations80658
Node: Database Formats81733
Node: New Database Format82559
Ref: New Database Format-Footnote-184204
Node: Sample Database84246
Node: Old Database Format84935
Node: Newline Handling86800
Node: File Permissions88081
Node: Mode Structure88646
Node: Symbolic Modes90756
Node: Setting Permissions91738
Node: Copying Permissions94102
Node: Changing Special Permissions94852
Node: Conditional Executability96634
Node: Multiple Changes97245
Node: Umask and Protection98778
Node: Numeric Modes99785
Node: Reference101342
Node: Invoking find101658
Node: Warning Messages103668
Node: Invoking locate105233
Node: Invoking updatedb109827
Node: Invoking xargs112308
Node: Security Considerations115449
Node: Levels of Risk116805
Ref: Levels of Risk-Footnote-1119244
Node: Security Considerations for find119423
Ref: Security Considerations for find-Footnote-1121370
Node: Changing the Current Working Directory121444
Node: O_NOFOLLOW123172
Ref: O_NOFOLLOW-Footnote-1124768
Node: Systems without O_NOFOLLOW124870
Node: Working with automounters125617
Node: Problems with dead NFS servers126650
Node: Race Conditions with -exec127670
Node: Race Conditions with -print and -print0130244
Node: Security Considerations for xargs131154
Node: Security Considerations for locate132932
Node: Security Summary133527
Node: Error Messages134252
Node: Error Messages From find135198
Node: Error Messages From xargs139480
Node: Error Messages From locate140940
Node: Error Messages From updatedb142160
Node: Primary Index142554

End Tag Table
